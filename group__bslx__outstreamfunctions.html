<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslx_outstreamfunctions Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslx_outstreamfunctions<br/>
<small>
[<a class="el" href="group__bslx.html">Package bslx</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Facilitate uniform externalization of user and fundamental types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslx.html">bslx</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Component Design, Anticipated Usage, and the BDEX Contract</a> <ul>
<li>
<a href="#3.1.1">Implementing BDEX Streaming in Value-Semantic Template Classes</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using <code>bslx::OutStreamFunctions</code> to Externalize Data</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Facilitate uniform externalization of user and fundamental types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="namespacebslx_1_1OutStreamFunctions.html">bslx::OutStreamFunctions</a> </td><td>namespace for BDEX externalization functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslx__instreamfunctions.html" title="Facilitate uniform unexternalization of user and fundamental types.">Component bslx_instreamfunctions</a>, <a class="el" href="group__bslx__versionfunctions.html" title="Provide functions to return BDEX version information for types.">Component bslx_versionfunctions</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a namespace, <code><a class="el" href="namespacebslx_1_1OutStreamFunctions.html">bslx::OutStreamFunctions</a></code>, that facilitates uniform support for BDEX externalization across all BDEX-compliant user-defined types, including template types and containers, as well as those fundamental types (and <code>bsl::string</code> and <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>) for which the BDEX protocol provides direct support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The namespace <code><a class="el" href="namespacebslx_1_1OutStreamFunctions.html">bslx::OutStreamFunctions</a></code> facilitates client externalization of objects in a uniform, type-independent manner. It contains the <code>bdexStreamOut</code> function that externalizes objects of all BDEX-compliant types. This function externalizes the specified <code>object</code> in the specified <code>version</code>. The <code>bdexStreamOut</code> function is overloaded for fundamental types, enumeration types, <code>bsl::string</code>, and <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>. Note that, excluding <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>, version information is never written to the stream while externalizing these types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>By default, objects of enumeration type are streamed out as 32-bit <code>int</code> values. Users can override this behavior by providing overloads of the <code>OutStreamFunctions::bdexStreamOut</code> function in the enumeration's namespace for their enumeration types. The general form of this overload is: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(STREAM&amp; stream, <span class="keyword">const</span> MyEnum&amp; value, <span class="keywordtype">int</span> version)
  {
      <span class="keyword">using</span> bslx::OutStreamFunctions::bdexStreamOut;

      <span class="comment">// Code to stream out objects of &#39;MyEnum&#39; type.</span>

      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 For value-semantic types that support the BDEX protocol, the free function <code>bdexStreamOut</code> calls the <code>bdexStreamOut</code> member function for that type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_design,_anticipated_usage,_and_the_bdex_contract"></a> <a class="anchor" id="description.component_design,_anticipated_usage,_and_the_bdex_contract"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Component Design, Anticipated Usage, and the BDEX Contract: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslx_outstreamfunctions</code> is an integral part of the BDEX externalization contract. The BDEX contract is at least in part "collaborative", which is to say that each developer of a given <em>kind</em> of component (e.g., a stream or a value-semantic container) must comply with the relevant portions of the contract to ensure that the "system as a whole" works for everybody. <code>bslx_outstreamfunctions</code> plays several related but different roles in helping various developers to produce BDEX-compliant components. In this section we briefly highlight how and why <code>bslx_outstreamfunctions</code> is helpful (or required) for these different developers. By discussing different aspects of usage, we convey the general design goals of this component, and, to a certain extent, the overall BDEX contract. See the <code>bslx</code> package-level documentation for a full specification of the BDEX contract. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implementing_bdex_streaming_in_value-semantic_template_classes"></a> <a class="anchor" id="component_design,_anticipated_usage,_and_the_bdex_contract.implementing_bdex_streaming_in_value-semantic_template_classes"></a> <a class="anchor" id="description.component_design,_anticipated_usage,_and_the_bdex_contract.implementing_bdex_streaming_in_value-semantic_template_classes"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Implementing BDEX Streaming in Value-Semantic Template Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The author of a non-template value-semantic type has full knowledge of the details of the "value" of that type, and may choose to use the appropriate output stream <code>put</code> methods directly when implementing the required <code>bdexStreamOut</code> method for that type. However, if one or more aspects of the value are of template parameter type, then the author cannot in general know how to stream the value using the <code>put</code> methods. For example, if a type has as its value one <code>int</code> data member: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> d_value;
</pre></div><br/>
<br/>
 then the implementation of the <code>bdexStreamOut</code> method can contain: <br/>
<br/>
<div class="fragment"><pre class="fragment">  stream.putInt32(d_value);
</pre></div><br/>
<br/>
 However, if the data member is of (template parameter) <code>TYPE</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  TYPE d_value;
</pre></div><br/>
<br/>
 then the implementation of the <code>bdexStreamOut</code> method must rely on the <code><a class="el" href="namespacebslx_1_1OutStreamFunctions.html">bslx::OutStreamFunctions</a></code> implementation to output the value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">using</span> bslx::OutStreamFunctions::bdexStreamOut;
  <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(stream, d_value, 1);
</pre></div><br/>
<br/>
 This call will resolve to the correct sequence of <code>put</code> calls no matter whether <code>TYPE</code> is a fundamental type, a BDEX-compliant <code>enum</code>, or a proper BDEX-compliant class. In the latter two cases, the explicit specification of the version format (in this case, 1) guarantees the stable operation of this method whether or not <code>TYPE</code> is provided additional version formats. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_bslx~3A~3Aoutstreamfunctions_to_externalize_data"></a> <a class="anchor" id="usage.example_1~3A_using_bslx~3A~3Aoutstreamfunctions_to_externalize_data"></a> <a class="anchor" id="description.usage.example_1~3A_using_bslx~3A~3Aoutstreamfunctions_to_externalize_data"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using bslx::OutStreamFunctions to Externalize Data: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we illustrate the primary intended use of the parameterized methods of this component, as well as a few trivial invocations just to show the syntax clearly. To accomplish this, we exhibit two separate example "components": a value-semantic point object, and an <code>enum</code>. In all cases, the component designs are very simple, with much of the implied functionality omitted, in order to focus attention on the key aspects of the functionality of <em>this</em> component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, consider an <code>enum</code> <code>Color</code> that enumerates a set of colors: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> Color {
      RED   = 0,
      GREEN = 1,
      BLUE  = 2
  };
</pre></div><br/>
<br/>
 Next, we consider a very special-purpose point that has as a data member its color. Such a point provides an excellent opportunity for factoring, but since we are interested in highlighting BDEX streaming of various types, we will present a simple and unfactored design here. In a real-world problem, the <code>mypoint</code> component would be implemented differently. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the <code>MyPoint</code> class in this example represents its coordinates as <code>short</code> integer values; this is done to make the BDEX stream output byte pattern somewhat easier for the reader of this example to recognize when the output buffer is printed. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// mypoint.h</span>

  <span class="keyword">class </span>MyPoint {
      <span class="comment">// This class provides a geometric point having integer coordinates and</span>
      <span class="comment">// an enumerated color property.</span>

      <span class="keywordtype">short</span> d_x;      <span class="comment">// x coordinate</span>
      <span class="keywordtype">short</span> d_y;      <span class="comment">// y coordinate</span>
      Color d_color;  <span class="comment">// enumerated color property</span>

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> versionSelector);
          <span class="comment">// Return the maximum valid BDEX format version, as indicated by</span>
          <span class="comment">// the specified &#39;versionSelector&#39;, to be passed to the</span>
          <span class="comment">// &#39;bdexStreamOut&#39; method.  Note that it is highly recommended that</span>
          <span class="comment">// versionSelector&#39; be formatted as &quot;YYYYMMDD&quot;, a date</span>
          <span class="comment">// representation.  Also note that &#39;versionSelector&#39; should be a</span>
          <span class="comment">// *compile*-time-chosen value that selects a format version</span>
          <span class="comment">// supported by both externalizer and unexternalizer.  See the</span>
          <span class="comment">// &#39;bslx&#39; package-level documentation for more information on BDEX</span>
          <span class="comment">// streaming of value-semantic types and containers.</span>

      <span class="comment">// CREATORS</span>
      MyPoint();
          <span class="comment">// Create a default point.</span>

      MyPoint(<span class="keywordtype">short</span> x, <span class="keywordtype">short</span> y, Color color);
          <span class="comment">// Create a point having the specified &#39;x&#39; and &#39;y&#39; coordinates</span>
          <span class="comment">// and the specified &#39;color&#39;.</span>

      ~MyPoint();
          <span class="comment">// Destroy this point.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> x() <span class="keyword">const</span>;
          <span class="comment">// Return the x coordinate of this point.</span>

      <span class="keywordtype">int</span> y() <span class="keyword">const</span>;
          <span class="comment">// Return the y coordinate of this point.</span>

      Color color() <span class="keyword">const</span>;
          <span class="comment">// Return the enumerated color of this point.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write the value of this object, using the specified &#39;version&#39;</span>
          <span class="comment">// format, to the specified output &#39;stream&#39;, and return a reference</span>
          <span class="comment">// to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation</span>
          <span class="comment">// has no effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is</span>
          <span class="comment">// invalidated, but otherwise unmodified.  Note that &#39;version&#39; is</span>
          <span class="comment">// not written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level</span>
          <span class="comment">// documentation for more information on BDEX streaming of</span>
          <span class="comment">// value-semantic types and containers.</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPoint&amp; lhs, <span class="keyword">const</span> MyPoint&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; points have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two points have the same value if</span>
      <span class="comment">// they have the same x and y coordinates and the same color.</span>
</pre></div><br/>
<br/>
 Representative (inline) implementations of these methods are shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ========================================================================</span>
  <span class="comment">//                      INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">MyPoint::maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> versionSelector)
  {
      <span class="keywordflow">if</span> (versionSelector &gt;= 20131201) {
          <span class="keywordflow">return</span> 2;
      }
      <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyPoint::MyPoint(<span class="keywordtype">short</span> x, <span class="keywordtype">short</span> y, Color color)
  : d_x(x)
  , d_y(y)
  , d_color(color)
  {
  }

  <span class="keyword">inline</span>
  MyPoint::~MyPoint()
  {
  }

  <span class="comment">// ...</span>

  <span class="comment">// MANIPULATORS</span>
  <span class="comment">// ...</span>

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyPoint::x()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_x;
  }

  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">MyPoint::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putInt16(d_x);          <span class="comment">// output the x coordinate</span>
          stream.putInt16(d_y);          <span class="comment">// output the y coordinate</span>
          stream.putInt8(static_cast&lt;char&gt;(d_color));
                                         <span class="comment">// output the color enum as one byte</span>
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPoint&amp; lhs, <span class="keyword">const</span> MyPoint&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.x()     == rhs.x()
          &amp;&amp; lhs.y()     == rhs.y()
          &amp;&amp; lhs.color() == rhs.color();
  }
</pre></div><br/>
<br/>
 Then, we will implement an extremely simple output stream that supports the BDEX documentation-only protocol. For simplicity, we will use a fixed-size buffer (usually a bad idea in any event, and more so here since the implementation knows the buffer size, but makes no effort to prevent overwriting that buffer), and will only show a few methods needed for this example. See other <code>bslx</code> stream components for examples of properly-designed BDEX streams. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// myoutstream.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">class </span>MyOutStream {
      <span class="comment">// This class implements a limited-size fixed-buffer output stream that</span>
      <span class="comment">// partially conforms to the BDEX protocol for output streams.  This</span>
      <span class="comment">// class is suitable for demonstration purposes only.</span>

      <span class="keywordtype">char</span> d_buffer[1000]; <span class="comment">// externalized values stored as contiguous bytes</span>

      <span class="keywordtype">int</span>  d_length;       <span class="comment">// length of data in &#39;d_buffer&#39; (in bytes)</span>

      <span class="keywordtype">bool</span> d_validFlag;    <span class="comment">// stream validity flag; &#39;true&#39; if stream is in</span>
                           <span class="comment">// valid state, &#39;false&#39; otherwise</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MyOutStream();
          <span class="comment">// Create an empty output stream of limited, fixed capacity.  Note</span>
          <span class="comment">// that this object is suitable for demonstration purposes only.</span>

      ~MyOutStream();
         <span class="comment">// Destroy this output stream.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> invalidate();
          <span class="comment">// Put this input stream in an invalid state.  This function has no</span>
          <span class="comment">// effect if this stream is already invalid.  Note that this</span>
          <span class="comment">// function should be called whenever a value extracted from this</span>
          <span class="comment">// stream is determined to be invalid, inconsistent, or otherwise</span>
          <span class="comment">// incorrect.</span>

      MyOutStream&amp; putVersion(<span class="keywordtype">int</span> version);
          <span class="comment">// Write to this stream the one-byte, two&#39;s complement integer</span>
          <span class="comment">// comprised of the least-significant one byte of the specified</span>
          <span class="comment">// &#39;version&#39;, and return a reference to this stream.</span>

      MyOutStream&amp; putInt32(<span class="keywordtype">int</span> value);
          <span class="comment">// Write to this stream the four-byte, two&#39;s complement integer (in</span>
          <span class="comment">// network byte order) comprised of the least-significant four</span>
          <span class="comment">// bytes of the specified &#39;value&#39; (in host byte order), and return</span>
          <span class="comment">// a reference to this stream.</span>

      MyOutStream&amp; putInt16(<span class="keywordtype">int</span> value);
          <span class="comment">// Write to this stream the two-byte, two&#39;s complement integer</span>
          <span class="comment">// (in network byte order) comprised of the least-significant two</span>
          <span class="comment">// bytes of the specified &#39;value&#39; (in host byte order), and return</span>
          <span class="comment">// a reference to this stream.</span>

      MyOutStream&amp; putInt8(<span class="keywordtype">int</span> value);
          <span class="comment">// Write to this stream the one-byte, two&#39;s complement integer</span>
          <span class="comment">// comprised of the least-significant one byte of the specified</span>
          <span class="comment">// &#39;value&#39;, and return a reference to this stream.</span>

      <span class="keywordtype">void</span> removeAll();
          <span class="comment">// Remove all content in this stream.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *data() <span class="keyword">const</span>;
          <span class="comment">// Return the address of the contiguous, non-modifiable internal</span>
          <span class="comment">// memory buffer of this stream.  The address will remain valid as</span>
          <span class="comment">// long as this stream is not destroyed or modified.  The behavior</span>
          <span class="comment">// of accessing elements outside the range</span>
          <span class="comment">// &#39;[ data() .. data() + (length() - 1) ]&#39; is undefined.</span>

      <span class="keywordtype">int</span> length() <span class="keyword">const</span>;
          <span class="comment">// Return the number of bytes in this stream.</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp;      stream,
                           <span class="keyword">const</span> MyOutStream&amp; <span class="keywordtype">object</span>);
      <span class="comment">// Write the specified &#39;object&#39; to the specified output &#39;stream&#39; in</span>
      <span class="comment">// some reasonable (multi-line) format, and return a reference to</span>
      <span class="comment">// &#39;stream&#39;.</span>
</pre></div><br/>
<br/>
 The relevant (inline) implementations are as follows. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ========================================================================</span>
  <span class="comment">//                      INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyOutStream::MyOutStream()
  : d_length(0)
  , d_validFlag(true)
  {
  }

  <span class="keyword">inline</span>
  MyOutStream::~MyOutStream()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> MyOutStream::invalidate()
  {
      d_validFlag = <span class="keyword">false</span>;
  }

  <span class="keyword">inline</span>
  MyOutStream&amp; MyOutStream::putVersion(<span class="keywordtype">int</span> value)
  {
      d_buffer[d_length] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(value);
      ++d_length;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyOutStream&amp; MyOutStream::putInt32(<span class="keywordtype">int</span> value)
  {
      d_buffer[d_length + 0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt; 24) &amp; 0xff);
      d_buffer[d_length + 1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt; 16) &amp; 0xff);
      d_buffer[d_length + 2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt;  8) &amp; 0xff);
      d_buffer[d_length + 3] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt;  0) &amp; 0xff);
      d_length += 4;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyOutStream&amp; MyOutStream::putInt16(<span class="keywordtype">int</span> value)
  {
      d_buffer[d_length + 0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt; 8) &amp; 0xff);
      d_buffer[d_length + 1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt; 0) &amp; 0xff);
      d_length += 2;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyOutStream&amp; MyOutStream::putInt8(<span class="keywordtype">int</span> value)
  {
      d_buffer[d_length] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(value);
      d_length += 1;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> MyOutStream::removeAll()
  {
      d_length = 0;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *MyOutStream::data()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(d_buffer);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyOutStream::length()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_length;
  }
</pre></div><br/>
<br/>
 Finally, use the above <code>enum</code>, point class, and output stream to illustrate <code><a class="el" href="namespacebslx_1_1OutStreamFunctions.html">bslx::OutStreamFunctions</a></code> functionality. This test code does not attempt to do anything more useful than writing known values to a stream and confirming that the expected byte pattern was in fact written. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span>             i     = 168496141;  <span class="comment">// byte pattern 0a 0b 0c 0d</span>
  Color           color = BLUE;       <span class="comment">// byte pattern 02</span>
  MyPoint         p(0, -1, color);    <span class="comment">// byte pattern 00 00 ff ff 02</span>

  <span class="keyword">using</span> bslx::OutStreamFunctions::bdexStreamOut;

  MyOutStream out;
  assert(0 == out.length());

  <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(out, i, 1);
  assert(4 == out.length());
  assert(0 == bsl::memcmp(out.data(), <span class="stringliteral">&quot;\x0a\x0b\x0c\x0d&quot;</span>, out.length()));

  out.removeAll();
  assert(0 == out.length());

  <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(out, i, 0);
  assert(4 == out.length());
  assert(0 == bsl::memcmp(out.data(), <span class="stringliteral">&quot;\x0a\x0b\x0c\x0d&quot;</span>, out.length()));

  out.removeAll();
  assert(0 == out.length());

  <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(out, color, 1);
  assert(4 == out.length());
  assert(0 == bsl::memcmp(out.data(), <span class="stringliteral">&quot;\x00\x00\x00\x02&quot;</span>, out.length()));

  out.removeAll();
  assert(0 == out.length());

  <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(out, color, 0);
  assert(4 == out.length());
  assert(0 == bsl::memcmp(out.data(), <span class="stringliteral">&quot;\x00\x00\x00\x02&quot;</span>, out.length()));

  out.removeAll();
  assert(0 == out.length());

  <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(out, p, 1);
  assert(5 == out.length());
  assert(0 == bsl::memcmp(out.data(), <span class="stringliteral">&quot;\x00\x00\xff\xff\x02&quot;</span>, out.length()));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:12 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
