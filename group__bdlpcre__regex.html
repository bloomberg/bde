<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlpcre_regex Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlpcre_regex<br/>
<small>
[<a class="el" href="group__bdlpcre.html">Package bdlpcre</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mechanism for regular expression pattern matching.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlpcre.html">bdlpcre</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">"Prepared" State</a> </li>
<li>
<a href="#3.2">Prepare-Time Flags</a> <ul>
<li>
<a href="#3.2.1">Case-Insensitive Matching</a> </li>
<li>
<a href="#3.2.2">Multi-Line Matching</a> </li>
<li>
<a href="#3.2.3">UTF-8 Support</a> </li>
<li>
<a href="#3.2.4">Dot Matches All</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Appendix: Perl Compatibility</a> </li>
<li>
<a href="#3.3.2">Additional Copyright Notice</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mechanism for regular expression pattern matching. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlpcre_1_1RegEx.html">bdlpcre::RegEx</a> </td><td>mechanism for compiling and matching regular expressions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.pcre.org/">http://www.pcre.org/</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism, <code><a class="el" href="classbdlpcre_1_1RegEx.html">bdlpcre::RegEx</a></code>, for compiling (or "preparing") regular expressions, and subsequently matching subject strings against a prepared expression. The regular expressions supported by this component correspond approximately with Perl 5.10. See the appendix entitled "Perl Compatibility" below for more information. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Upon construction, a <code><a class="el" href="classbdlpcre_1_1RegEx.html">bdlpcre::RegEx</a></code> object is initially not associated with a regular expression. A regular expression pattern is compiled for use by the object using the <code>prepare</code> method. Subject strings may then be matched against the prepared pattern using the set of overloaded <code>match</code> methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The component provides the following groups of <code>match</code> overloads: <ol>
<li>
The first group of <code>match</code> overloads simply returns 0 if a given subject string matches the prepared regular expression, and returns a non-zero value otherwise.  </li>
<li>
The second group of <code>match</code> overloads returns the substring of the subject that was matched, ether as a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, or as a <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;size_t, size_t&gt;</code> holding the (offset, length) pair.  </li>
<li>
The third group of <code>match</code> overloads returns a vector of either <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> or <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;size_t, size_t&gt;</code> holding the matched substrings. The first element of the vector indicate the substring of the subject that matched the entire pattern. Subsequent elements indicate the substrings of the subject that matched respective sub-patterns.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="~22prepared~22_state"></a> <a class="anchor" id="description.~22prepared~22_state"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Prepared</b></dt><dd>State:  </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlpcre_1_1RegEx.html">bdlpcre::RegEx</a></code> object must first be prepared with a valid regular expression before attempting to match subject strings. We say that an instance of <code><a class="el" href="classbdlpcre_1_1RegEx.html">bdlpcre::RegEx</a></code> is in the "prepared" state if the object holds a valid regular expression, in which case calls to the overloaded <code>match</code> methods of that instance are valid. Otherwise, the object is in the "unprepared" state. Upon construction, an <code><a class="el" href="classbdlpcre_1_1RegEx.html">bdlpcre::RegEx</a></code> object is in the "unprepared" state. A successful call to the <code>prepare</code> method puts the object into the "prepared" state. The <code>clear</code> method, as well as an unsuccessful call to <code>prepare</code>, puts the object into the "unprepared" state. The <code>isPrepared</code> accessor may be used to determine whether an object is prepared. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="prepare-time_flags"></a> <a class="anchor" id="description.prepare-time_flags"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Prepare-Time Flags: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A set of flags may be optionally supplied to the <code>prepare</code> method to affect specific pattern matching behavior. The flags recognized by <code>prepare</code> are defined in an enumeration declared within the <code><a class="el" href="classbdlpcre_1_1RegEx.html">bdlpcre::RegEx</a></code>. The following describes these flags and their effects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="case-insensitive_matching"></a> <a class="anchor" id="prepare-time_flags.case-insensitive_matching"></a> <a class="anchor" id="description.prepare-time_flags.case-insensitive_matching"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Case-Insensitive Matching: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <code>RegEx::k_FLAG_CASELESS</code> is included in the flags supplied to <code>prepare</code>, then letters in the regular expression pattern supplied to <code>prepare</code> match both lower- and upper-case letters in subject strings subsequently supplied to <code>match</code>. This is equivalent to Perl's <code>/i</code> option, and can be turned off within a pattern by a <code>(?i)</code> option setting. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="multi-line_matching"></a> <a class="anchor" id="prepare-time_flags.multi-line_matching"></a> <a class="anchor" id="description.prepare-time_flags.multi-line_matching"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Multi-Line Matching: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>By default, a subject string supplied to <code>match</code> is treated as consisting of a single line of characters (even if it actually contains <code>\n</code> characters). The start-of-line meta-character <code>^</code> matches only at the beginning of the string, and the end-of-line meta-character <code>$</code> matches only at the end of the string (or before a terminating <code>\n</code>, if present). This matches the behavior of Perl. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <code>RegEx::k_FLAG_MULTILINE</code> is included in the flags supplied to <code>prepare</code>, then start-of-line and end-of-line meta-characters match immediately following or immediately before any <code>\n</code> characters in subject strings supplied to <code>match</code>, respectively (as well as at the very start and end of subject strings). This is equivalent to Perl's <code>/m</code> option, and can be turned off within a pattern by a <code>(?m)</code> option setting. If there are no <code>\n</code> characters in the subject string, or if there are no occurrences of <code>^</code> or <code>$</code> in the prepared pattern, then including <code>k_FLAG_MULTILINE</code> has no effect. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="utf-8_support"></a> <a class="anchor" id="prepare-time_flags.utf-8_support"></a> <a class="anchor" id="description.prepare-time_flags.utf-8_support"></a> <a class="anchor" id="3.2.3"></a> </dd></dl>
<dl class="user"><dt><b>UTF-8 Support: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <code>RegEx::k_FLAG_UTF8</code> is included in the flags supplied to <code>prepare</code>, then the regular expression pattern supplied to <code>prepare</code>, as well as the subject strings subsequently supplied to <code>match</code>, are interpreted as strings of UTF-8 characters instead of strings of ASCII characters. The behavior of <code>match</code> methods is undefined if <code>pattern()</code> was prepared with <code>k_FLAG_UTF8</code>, but <code>subject</code> is not a valid UTF-8 string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="dot_matches_all"></a> <a class="anchor" id="prepare-time_flags.dot_matches_all"></a> <a class="anchor" id="description.prepare-time_flags.dot_matches_all"></a> <a class="anchor" id="3.2.4"></a> </dd></dl>
<dl class="user"><dt><b>Dot Matches All: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <code>RegEx::k_FLAG_DOTMATCHESALL</code> is included in the flags supplied to <code>prepare</code>, then a dot metacharacter in the pattern matches a character of any value, including one that indicates a newline. However, it only ever matches one character, even if newlines are encoded as <code>\r\n</code>. If <code>k_FLAG_DOTMATCHESALL</code> is not used to prepare a regular expression, a dot metacharacter will <em>not</em> match a newline; hence, patterns expected to match across lines will fail to do so. This flag is equivalent to Perl's <code>/s</code> option, and can be changed within a pattern by a <code>(?s)</code> option setting. A negative class such as <code>[^a]</code> always matches newline characters, independent of the setting of this option. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate using this component to extract the text of the "Subject:" field from an Internet e-mail message (RFC822). The following <code>parseSubject</code> function accepts an RFC822-compliant message of a specified length and returns the text of the message's subject in the <code>result</code> "out" parameter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> parseSubject(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *result,
                   <span class="keyword">const</span> <span class="keywordtype">char</span>  *message,
                   bsl::size_t  messageLength)
      <span class="comment">// Parse the specified &#39;message&#39; of the specified &#39;messageLength&#39; for</span>
      <span class="comment">// the &quot;Subject:&quot; field of &#39;message&#39;.  Return 0 on success and load the</span>
      <span class="comment">// specified &#39;result&#39; with the text of the subject of &#39;message&#39;; return</span>
      <span class="comment">// a non-zero value otherwise with no effect on &#39;result&#39;.</span>
  {
</pre></div><br/>
<br/>
 The following is the regular expression that will be used to find the subject text of <code>message</code>. The "?P&lt;subjectText&gt;" syntax, borrowed from Python, allows us later to refer to a particular matched sub-pattern (i.e., the text between the <code>:</code> and the <code>\r</code> in the "Subject:" field of the header) by the name "subjectText": <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">char</span> PATTERN[] = <span class="stringliteral">&quot;^subject:(?P&lt;subjectText&gt;[^\r]*)&quot;</span>;
</pre></div><br/>
<br/>
 First we compile the <code>PATTERN</code>, using the <code>prepare</code> method, in order to match subject strings against it. In the event that <code>prepare</code> fails, the first two arguments will be loaded with diagnostic information (an informational string and an index into the pattern at which the error occurred, respectively). Two flags, <code>RegEx::k_FLAG_CASELESS</code> and <code>RegEx::k_FLAG_MULTILINE</code>, are used in preparing the pattern since Internet message headers contain case-insensitive content as well as <code>\n</code> characters. The <code>prepare</code> method returns 0 on success, and a non-zero value otherwise: <br/>
<br/>
<div class="fragment"><pre class="fragment">      RegEx       regEx;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> errorMessage;
      <span class="keywordtype">size_t</span>      errorOffset;

      <span class="keywordtype">int</span> returnValue = regEx.prepare(&amp;errorMessage,
                                      &amp;errorOffset,
                                      PATTERN,
                                      RegEx::k_FLAG_CASELESS |
                                      RegEx::k_FLAG_MULTILINE);
      assert(0 == returnValue);
</pre></div><br/>
<br/>
 Next we call <code>match</code> supplying <code>message</code> and its length. The <code>matchVector</code> will be populated with (offset, length) pairs describing substrings in <code>message</code> that match the prepared <code>PATTERN</code>. All variants of the overloaded <code>match</code> method return 0 if a match is found, and return a non-zero value otherwise: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::pair&lt;size_t, size_t&gt;</a> &gt; matchVector;
      returnValue = regEx.match(&amp;matchVector, message, messageLength);

      <span class="keywordflow">if</span> (0 != returnValue) {
          <span class="keywordflow">return</span> returnValue;  <span class="comment">// no match</span>
      }
</pre></div><br/>
<br/>
 Then we pass "subjectText" to the <code>subpatternIndex</code> method to obtain the index into <code>matchVector</code> that describes how to locate the subject text within <code>message</code>. The text is then extracted from <code>message</code> and assigned to the <code>result</code> "out" parameter: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;size_t, size_t&gt;</a> capturedSubject =
                           matchVector[regEx.subpatternIndex(<span class="stringliteral">&quot;subjectText&quot;</span>)];

      *result = <a class="code" href="group__bslstl__string.html#gab67de1ebe0184939129507efe5c86bb1">bsl::string</a>(&amp;message[capturedSubject.<a class="code" href="group__bslstl__pair.html#gafff8113b0b2f4bbe5df93ce0ba30fad8">first</a>],
                            capturedSubject.<a class="code" href="group__bslstl__pair.html#gaf89d2b38598dfb6fa42775f2e135f1d8">second</a>);

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 The following array contains the sample Internet e-mail message from which we will extract the subject: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> RFC822_MESSAGE[] =
      <span class="stringliteral">&quot;Received: ; Fri, 23 Apr 2004 14:30:00 -0400\r\n&quot;</span>
      <span class="stringliteral">&quot;Message-ID: &lt;12345@mailgate.bloomberg.net&gt;\r\n&quot;</span>
      <span class="stringliteral">&quot;Date: Fri, 23 Apr 2004 14:30:00 -0400\r\n&quot;</span>
      <span class="stringliteral">&quot;From: &lt;someone@bloomberg.net&gt;\r\n&quot;</span>
      <span class="stringliteral">&quot;To: &lt;someone_else@bloomberg.net&gt;\r\n&quot;</span>
      <span class="stringliteral">&quot;Subject: This is the subject text\r\n&quot;</span>
      <span class="stringliteral">&quot;MIME-Version: 1.0\r\n&quot;</span>
      <span class="stringliteral">&quot;Content-Type: text/plain\r\n&quot;</span>
      <span class="stringliteral">&quot;\r\n&quot;</span>
      <span class="stringliteral">&quot;This is the message body.\r\n&quot;</span>
      <span class="stringliteral">&quot;.\r\n&quot;</span>;
</pre></div><br/>
<br/>
 Finally, we call <code>parseSubject</code> to extract the subject from <code>RFC822_MESSAGE</code>. The assertions verify that the subject of the message is correctly extracted and assigned to the local <code>subject</code> variable: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> subject;
      <span class="keyword">const</span> <span class="keywordtype">int</span>   returnValue = parseSubject(&amp;subject,
                                             RFC822_MESSAGE,
                                             <span class="keyword">sizeof</span>(RFC822_MESSAGE) - 1);
      assert(0 == returnValue);
      assert(<span class="stringliteral">&quot; This is the subject text&quot;</span> == subject);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="appendix~3A_perl_compatibility"></a> <a class="anchor" id="usage.appendix~3A_perl_compatibility"></a> <a class="anchor" id="description.usage.appendix~3A_perl_compatibility"></a> <a class="anchor" id="appendix"></a> <a class="anchor" id="usage.appendix"></a> <a class="anchor" id="description.usage.appendix"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Appendix: Perl Compatibility: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the differences in the ways that PCRE2 and Perl handle regular expressions. The differences described here are with respect to Perl versions 5.10 and above. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>1) PCRE2 has only a subset of Perl's Unicode support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>2) PCRE2 allows repeat quantifiers only on parenthesized assertions, but they do not mean what you might think. For example, <code>(?!a){3}</code> does not assert that the next three characters are not "a". It just asserts that the next character is not "a" three times (in principle: PCRE2 optimizes this to run the assertion just once). Perl allows repeat quantifiers on other assertions such as <code>\b</code>, but these do not seem to have any use. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>3) Capturing subpatterns that occur inside negative lookahead assertions are counted, but their entries in the offsets vector are never set. Perl sometimes (but not always) sets its numerical variables from inside negative assertions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>4) The following Perl escape sequences are not supported: <code>\l</code>, <code>\u</code>, <code>\L</code>, <code>\U</code>, and <code>\N</code> when followed by a character name or Unicode value. (<code>\N</code> on its own, matching a non-newline character, is supported.) In fact these are implemented by Perl's general string-handling and are not part of its pattern matching engine. If any of these are encountered by PCRE2, an error is generated by default. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>5) The Perl escape sequences <code>\p</code>, <code>\P</code>, and <code>\X</code> are supported only if PCRE2 is built with Unicode support. The properties that can be tested with <code>\p</code> and <code>\P</code> are limited to the general category properties such as <code>Lu</code> and <code>Nd,</code> script names such as Greek or Han, and the derived properties <code>Any</code> and <code>L&amp;</code>. PCRE2 does support the Cs (surrogate) property, which Perl does not; the Perl documentation says "Because Perl hides the need for the user to understand the internal representation of Unicode characters, there is no need to implement the somewhat messy concept of surrogates." </dd></dl>
<dl class="user"><dt><b></b></dt><dd>6) PCRE2 does support the <code>\Q...\E</code> escape for quoting substrings. Characters in between are treated as literals. This is slightly different from Perl in that <code>$</code> and <code>@</code> are also handled as literals inside the quotes. In Perl, they cause variable interpolation (but of course PCRE2 does not have variables). Note the following examples: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Pattern            PCRE2 matches  Perl matches
 ----------------   -------------  ------------------------------------
 \Qabc$xyz\E        abc$xyz        abc followed by the contents of $xyz
 \Qabc\$xyz\E       abc\$xyz       abc\$xyz
 \Qabc\E\$\Qxyz\E   abc$xyz        abc$xyz
</pre></div><br/>
<br/>
 The <code>\Q...\E</code> sequence is recognized both inside and outside character classes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>7) PCRE2 does not support the <code>(?{code})</code> and <code>(??{code})</code> constructions. However, there is support for recursive patterns. This is not available in Perl 5.8, but it is in Perl 5.10. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>8) Subroutine calls (whether recursive or not) are treated as atomic groups. Atomic recursion is like Python, but unlike Perl. Captured values that are set outside a subroutine call can be referenced from inside in PCRE2, but not in Perl. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>9) If any of the backtracking control verbs are used in a subpattern that is called as a subroutine (whether or not recursively), their effect is confined to that subpattern; it does not extend to the surrounding pattern. This is not always the case in Perl. In particular, if <code>(*THEN)</code> is present in a group that is called as a subroutine, its action is limited to that group, even if the group does not contain any <code>|</code> characters. Note that such subpatterns are processed as anchored at the point where they are tested. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>10) If a pattern contains more than one backtracking control verb, the first one that is backtracked onto acts. For example, in the pattern <code><a class="el" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A(*COMMIT)</a>B(*PRUNE)C</code> a failure in <code>B</code> triggers <code>(*COMMIT)</code>, but a failure in <code>C</code> triggers <code>(*PRUNE)</code>. Perl's behaviour is more complex; in many cases it is the same as PCRE2, but there are examples where it differs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>11) Most backtracking verbs in assertions have their normal actions. They are not confined to the assertion. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>12) There are some differences that are concerned with the settings of captured strings when part of a pattern is repeated. For example, matching <code>"aba"</code> against the pattern <code>/^(a(b)?)+$/</code> in Perl leaves <code>$2</code> unset, but in PCRE2 it is set to <code>"b"</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>13) PCRE2's handling of duplicate subpattern numbers and duplicate subpattern names is not as general as Perl's. This is a consequence of the fact the PCRE2 works internally just with numbers, using an external table to translate between numbers and names. In particular, a pattern such as <code>(?|(?&lt;a&gt;A)|(?&lt;b)B)</code>, where the two capturing parentheses have the same number but different names, is not supported, and causes an error at compile time. If it were allowed, it would not be possible to distinguish which parentheses matched, because both names map to capturing subpattern number 1. To avoid this confusing situation, an error is given at compile time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>14) Perl recognizes comments in some places that PCRE2 does not, for example, between the <code>(' and '?</code> at the start of a subpattern. If the <code>/x</code> modifier is set, Perl allows white space between <code>(' and '?</code> (though current Perls warn that this is deprecated) but PCRE2 never does, even if the <code>PCRE2_EXTENDED</code> option is set. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>15) Perl, when in warning mode, gives warnings for character classes such as <code>[A-\d]</code> or <code>[a-[:digit:]]</code>. It then treats the hyphens as literals. PCRE2 has no warning features, so it gives an error in these cases because they are almost certainly user mistakes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>16) In PCRE2, the upper/lower case character properties <code>Lu</code> and <code>Ll</code> are not affected when case-independent matching is specified. For example, <code>\p{Lu}</code> always matches an upper case letter. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>17) PCRE2 provides some extensions to the Perl regular expression facilities. This list is with respect to Perl 5.10: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(a) Although lookbehind assertions in PCRE2 must match fixed length strings, each alternative branch of a lookbehind assertion can match a different length of string. Perl requires them all to have the same length. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(b) If <code>PCRE2_DOLLAR_ENDONLY</code> is set and <code>PCRE2_MULTILINE</code> is not set, the <code>$</code> meta-character matches only at the very end of the string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(c) A backslash followed by a letter with no special meaning is faulted. (Perl can be made to issue a warning.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(d) If <code>PCRE2_UNGREEDY</code> is set, the greediness of the repetition quantifiers is inverted, that is, by default they are not greedy, but if followed by a question mark they are. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(e) <code>PCRE2_ANCHORED</code> can be used at matching time to force a pattern to be tried only at the first matching position in the subject string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(f) The <code>PCRE2_NOTBOL</code>, <code>PCRE2_NOTEOL</code>, <code>PCRE2_NOTEMPTY</code>, <code>PCRE2_NOTEMPTY_ATSTART</code>, and <code>PCRE2_NO_AUTO_CAPTURE</code> options have no Perl equivalents. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(g) The <code>\R</code> escape sequence can be restricted to match only <code>CR,</code> <code>LF,</code> or <code>CRLF</code> by the <code>PCRE2_BSR_ANYCRLF</code> option. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(h) The callout facility is PCRE2-specific. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(i) The partial matching facility is PCRE2-specific. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(j) The alternative matching function (<code>pcre2_dfa_match()</code> matches in a different way and is not Perl-compatible. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(k) PCRE2 recognizes some special sequences such as <code>(*CR)</code> at the start of a pattern that set overall options that cannot be changed within the pattern. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="additional_copyright_notice"></a> <a class="anchor" id="usage.additional_copyright_notice"></a> <a class="anchor" id="description.usage.additional_copyright_notice"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Additional Copyright Notice: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment"> Copyright (c) 1997-2015 University of Cambridge
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 Redistributions of source code must retain the above copyright notice,
      <span class="keyword">this</span> list of conditions and the following disclaimer.

 Redistributions in binary form must reproduce the above copyright
      notice, <span class="keyword">this</span> list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

 Neither the name of the University of Cambridge nor the names of any
      contributors may be used to endorse or promote products derived from
      <span class="keyword">this</span> software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS <span class="stringliteral">&quot;AS IS&quot;</span>
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:47 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
