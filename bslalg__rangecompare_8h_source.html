<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslalg_rangecompare.h                                              -*-C++-*-
#ifndef INCLUDED_BSLALG_RANGECOMPARE
#define INCLUDED_BSLALG_RANGECOMPARE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide algorithms to compare iterator-ranges of elements.
//
//@CLASSES:
//  bslalg::RangeCompare: comparison algorithms for iterator ranges
//
//@SEE_ALSO: bslmf_isbitwiseequalitycomparable
//
//@DESCRIPTION: This component provides a utility &#39;struct&#39;,
// &#39;bslalg::RangeCompare&#39;, that defines two overloaded class methods, &#39;equal&#39;
// and &#39;lexicographical&#39;, for comparing two ranges, each specified by a pair of
// input iterators that are compliant with the C++11 standard [24.2.3].  The
// &#39;equal&#39; method determines whether two specified ranges compare equal.  The
// &#39;lexicographical&#39; method determines whether the first range compares
// lexicographically less than, equal to, or greater than the second range.
// Under certain circumstances, &#39;bslalg::RangeCompare::equal&#39; and
// &#39;bslalg::RangeCompare::lexicographical&#39; may perform optimized comparisons,
// as described below.
//
// &#39;bslalg::RangeCompare::equal&#39; may perform a bit-wise comparison of the two
// ranges when the following two criteria are met:
//: o The input iterators are convertible to a pointer type.
//: o The trait &#39;bslmf::IsBitwiseEqualityComparable&#39; is declared for
//:   the type of the objects in the ranges being compared.
//
// &#39;bslalg::RangeCompare::lexicographical&#39; may perform a bit-wise comparison of
// the two ranges when the following criterion is met:
//: o The input iterators are convertible to pointers to a wide or unsigned
//    character type.
//
// Note that a class having the &#39;bslmf::IsBitwiseEqualityComparable&#39;
// trait can be described as bit-wise comparable and should meet the following
// criteria:
//: o The values represented by two objects belonging to the class are the same
//:   if and only if each of the data members in the class has the same value
//:   in both objects.
//: o The class layout includes no padding.
//: o The class has no virtual members.
//
// Note that this component is for use primarily by the &#39;bslstl&#39; package.
// Other clients should use the STL algorithms (in headers &#39;&lt;bsl_algorithm.h&gt;&#39;
// and &#39;&lt;bsl_memory.h&gt;&#39;).
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Defining Equality Comparison Operators on a Container
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In this example we will use the &#39;bslalg::RangeCompare::equal&#39; class method
// to implement the equality comparison operators for an iterable container
// type residing in the &#39;bslstl&#39; package, and highlight the circumstances under
// which the optimization provided by the class method may be applied.
//
// Suppose that we have a new iterable container type that will be included in
// the &#39;bslstl&#39; package, and we wish to define comparison operators for the
// container.  If the container has an iterator that provides access to the
// container&#39;s elements in a consistent order, and the elements themselves are
// equality-comparable, we can implement the container&#39;s equality comparison
// operators by pair-wise comparing each of the elements over the entire range
// of elements in both containers.  In such cases the container can use the
// &#39;bslalg::RangeCompare::equal&#39; class method to equal-compare the container&#39;s
// elements, taking advantage of the optimizations the class method provides
// for bit-wise equality-comparable objects.
//
// First, we create an elided definition of a container class, &#39;MyContainer&#39;,
// which provides read-only iterators of the type &#39;MyContainer::ConstIterator&#39;:
//..
//  template &lt;class VALUE_TYPE&gt;
//  class MyContainer {
//      // This class implements a container, semantically similar to
//      // &#39;std::vector&#39;, holding objects of the (template parameter) type
//      // &#39;VALUE_TYPE&#39;.
//
//    private:
//      // DATA
//      // ...
//
//    public:
//      // PUBLIC TYPES
//      typedef const VALUE_TYPE *ConstIterator;
//          // This &#39;typedef&#39; provides an alias for the type of iterator
//          // providing non-modifiable access to the elements in the
//          // container.
//
//      // CREATORS
//      explicit MyContainer(bslma::Allocator *basicAllocator = 0);
//          // Create an empty &#39;MyContainer&#39; object having no capacity.
//          // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
//          // &#39;basicAllocator&#39; is 0, the currently installed default allocator
//          // is used.
//
//      // ...
//
//      // MANIPULATORS
//      // ...
//
//      void push_back(const VALUE_TYPE&amp; value);
//          // Append the specified &#39;value&#39; at the past-the-end position in
//          // this container, increasing the container&#39;s capacity if needed.
//
//      // ...
//
//      // ACCESSORS
//      ConstIterator begin() const;
//          // Return an iterator providing non-modifiable access to the first
//          // element in this container.
//
//      ConstIterator end() const;
//          // Return an iterator providing non-modifiable access to the
//          // past-the-end element in this container.
//
//      std::size_t size() const;
//          // Return the number of elements in this container.
//
//      // ...
//  };
//..
// Notice that &#39;ConstIterator&#39; is defined as a pointer type, which is one of
// the criteria required to enable the optimizations provided by the
// &#39;bslalg::RangeCompare::equal&#39; class method.
//
// Then, we declare the equality comparison operators for &#39;MyContainer&#39;:
//..
//  template &lt;class VALUE_TYPE&gt;
//  bool operator==(const MyContainer&lt;VALUE_TYPE&gt;&amp; lhs,
//                  const MyContainer&lt;VALUE_TYPE&gt;&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
//      // value, and &#39;false&#39; otherwise.  Two &#39;MyContainer&#39; objects have the
//      // same value if they have the same length, and each element in &#39;lhs&#39;
//      // has the same value as the corresponding element in &#39;rhs&#39;.
//
//  template &lt;class VALUE_TYPE&gt;
//  bool operator!=(const MyContainer&lt;VALUE_TYPE&gt;&amp; lhs,
//                  const MyContainer&lt;VALUE_TYPE&gt;&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have
//      // the same value, and &#39;false&#39; otherwise.  Two &#39;MyContainer&#39; objects do
//      // not have the same value if they do not have the same length, or if
//      // any element in &#39;lhs&#39; does not have the same value as the
//      // corresponding element in &#39;rhs&#39;.
//..
// Next, we implement the equality comparison operators using
// &#39;bslalg::RangeCompare::equal&#39;:
//..
//  template &lt;class VALUE_TYPE&gt;
//  inline
//  bool operator==(const MyContainer&lt;VALUE_TYPE&gt;&amp; lhs,
//                  const MyContainer&lt;VALUE_TYPE&gt;&amp; rhs)
//  {
//      return BloombergLP::bslalg::RangeCompare::equal(lhs.begin(),
//                                                      lhs.end(),
//                                                      lhs.size(),
//                                                      rhs.begin(),
//                                                      rhs.end(),
//                                                      rhs.size());
//  }
//
//  template &lt;class VALUE_TYPE&gt;
//  inline
//  bool operator!=(const MyContainer&lt;VALUE_TYPE&gt;&amp; lhs,
//                  const MyContainer&lt;VALUE_TYPE&gt;&amp; rhs)
//  {
//      return !BloombergLP::bslalg::RangeCompare::equal(lhs.begin(),
//                                                       lhs.end(),
//                                                       lhs.size(),
//                                                       rhs.begin(),
//                                                       rhs.end(),
//                                                       rhs.size());
//  }
//..
// Then, we create the elided definition of a value-semantic class, &#39;MyString&#39;,
// together with its definition of &#39;operator==&#39;:
//..
//  class MyString {
//      // This class provides a simple, elided string class that conforms to
//      // the &#39;bslma::Allocator&#39; model.
//
//    private:
//      // DATA
//      char             *d_start_p;      // storage for the string
//      std::size_t       d_length;       // length of the string
//      bslma::Allocator *d_allocator_p;  // memory allocator (held, not owned)
//
//      // ...
//
//      // FRIENDS
//      friend bool operator==(const MyString&amp;, const MyString&amp;);
//      // ...
//
//    public:
//      // CREATORS
//      explicit MyString(const char       *string,
//                        bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;MyString&#39; object initialized to the value of the
//          // specified &#39;string&#39;.  Optionally specify a &#39;basicAllocator&#39; used
//          // to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
//          // installed default allocator is used.
//
//      // ...
//  };
//
//  bool operator==(const MyString&amp; lhs, const MyString&amp; rhs)
//  {
//      return lhs.d_length == rhs.d_length
//          &amp;&amp; 0 == std::strncmp(lhs.d_start_p, rhs.d_start_p, lhs.d_length);
//  }
//..
// Notice that &#39;MyString&#39; is not bit-wise comparable because the address values
// of the &#39;d_start_p&#39; pointer data members in two &#39;MyString&#39; objects will be
// different, even if the string values of the two objects are the same.
//
// Next, we create two &#39;MyContainer&lt;MyString&gt;&#39; objects, and compare them using
// &#39;operator==&#39;:
//..
//  MyContainer&lt;MyString&gt; c1;
//  MyContainer&lt;MyString&gt; c2;
//
//  c1.push_back(MyString(&quot;hello&quot;));
//  c1.push_back(MyString(&quot;goodbye&quot;));
//
//  c2.push_back(MyString(&quot;hello&quot;));
//  c2.push_back(MyString(&quot;goodbye&quot;));
//
//  assert(c1 == c2);
//..
// Here, the call to the &#39;bslalg::RangeCompare::equal&#39; class method in
// &#39;operator==&#39; will perform an unoptimized pair-wise comparison of the
// elements in &#39;c1&#39; and &#39;c2&#39;.
//
// Then, we create the elided definition of another value-semantic class,
// &#39;MyPoint&#39;, together with its definition of &#39;operator==&#39;:
//..
//  class MyPoint {
//      // This class provides a simple, elided point type that is bit-wise
//      // comparable with other objects of the same type.
//
//    private:
//      // DATA
//      int d_x;  // the x-coordinate of the point
//      int d_y;  // the y-coordinate of the point
//
//      // FRIENDS
//      friend bool operator==(const MyPoint&amp;, const MyPoint&amp;);
//      // ...
//
//    public:
//      // TRAITS
//      BSLALG_DECLARE_NESTED_TRAITS(MyPoint,
//                    BloombergLP::bslalg::TypeTraitBitwiseEqualityComparable);
//
//      // CREATORS
//      MyPoint(int x, int y);
//          // Create a &#39;MyPoint&#39; object whose x- and y-coordinates have the
//          // specified &#39;x&#39; and &#39;y&#39; values, respectively.
//
//      // ...
//  };
//
//  bool operator==(const MyPoint&amp; lhs, const MyPoint&amp; rhs)
//  {
//      return lhs.d_x == rhs.d_x &amp;&amp; lhs.d_y == rhs.d_y;
//  }
//..
// Notice that the value of a &#39;MyPoint&#39; object derives from the values of all
// of its data members, and that no padding is required for alignment.
// Furthermore, &#39;MyPoint&#39; has no virtual methods.  Therefore, &#39;MyPoint&#39; objects
// are bit-wise comparable, and we can correctly declare the
// &#39;bslalg::TypeTraitBitwiseEqualityComparable&#39; trait for the class, as shown
// above under the public &#39;TRAITS&#39; section.
//
// Now, we create two &#39;MyContainer&lt;MyPoint&gt;&#39; objects and compare them using
// &#39;operator==&#39;:
//..
//  MyContainer&lt;MyPoint&gt; c3;
//  MyContainer&lt;MyPoint&gt; c4;
//
//  c3.push_back(MyPoint(1, 2));
//  c3.push_back(MyPoint(3, 4));
//
//  c4.push_back(MyPoint(1, 2));
//  c4.push_back(MyPoint(3, 4));
//
//  assert(c3 == c4);  // potentially optimized
//..
// Here, the call to &#39;bslalg::RangeCompare::equal&#39; in &#39;operator==&#39; may take
// advantage of the fact that &#39;MyPoint&#39; is bit-wise comparable and perform the
// comparison by directly bit-wise comparing the entire range of elements
// contained in the &#39;MyContainer&lt;MyPoint&gt;&#39; objects.  This comparison can
// provide a significant performance boost over the comparison between two
// &#39;MyContainer&lt;MyPoint&gt;&#39; objects in which the nested
// &#39;TypeTraitBitwiseEqualityComparable&#39; trait is not associated with the
// &#39;MyPoint&#39; class.
//
// Finally, note that we can instantiate &#39;MyContainer&#39; with &#39;int&#39; or any other
// primitive type as the &#39;VALUE_TYPE&#39; and still benefit from the optimized
// comparison operators, because primitive (i.e.: fundamental, enumerated, and
// pointer) types are inherently bit-wise comparable:
//..
//  MyContainer&lt;int&gt; c5;
//  MyContainer&lt;int&gt; c6;
//
//  c5.push_back(1);
//  c5.push_back(2);
//  c5.push_back(3);
//
//  c6.push_back(1);
//  c6.push_back(2);
//  c6.push_back(3);
//
//  assert(c5 == c6);  // potentially optimized
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEEQUALITYCOMPARABLE
#include &lt;bslmf_isbitwiseequalitycomparable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISCONVERTIBLE
#include &lt;bslmf_isconvertible.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MATCHANYTYPE
#include &lt;bslmf_matchanytype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_METAINT
#include &lt;bslmf_metaint.h&gt;
#endif

#ifndef INCLUDED_CLIMITS
#include &lt;climits&gt;
#define INCLUDED_CLIMITS
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;
#define INCLUDED_CSTDDEF
#endif

#ifndef INCLUDED_CSTRING
#include &lt;cstring&gt;
#define INCLUDED_CSTRING
#endif

#ifndef INCLUDED_CWCHAR
#include &lt;cwchar&gt;
#define INCLUDED_CWCHAR
#endif

namespace BloombergLP {

namespace bslalg {

                          // ==================
                          // class RangeCompare
                          // ==================

struct RangeCompare {
    // This utility &#39;struct&#39; provides two static class methods, &#39;equal&#39; and
    // &#39;lexicographical&#39;, for comparing two ranges of values.  &#39;equal&#39; returns
    // &#39;true&#39; if each element in one range has the same value as the
    // corresponding element in the other range, and &#39;false&#39; otherwise.
    // &#39;lexicographical&#39; returns 0 if the two ranges are equal, a positive
    // value if the first range is greater than the second, and a negative
    // value if the second range is greater than the first.  A range is
    // specified by a pair of beginning and ending iterators, with an optional
    // length parameter.  Additionally, an overload is provided for the &#39;equal&#39;
    // class method that allows the end iterator for one range to be omitted.
    //
    // &#39;equal&#39; requires that the elements in the ranges can be compared with
    // &#39;operator==&#39;.
    //
    // &#39;lexicographical&#39; requires that the elements in the ranges can be
    // compared with &#39;operator&lt;&#39;.

    // TYPES
    typedef std::size_t size_type;
        // &#39;size_type&#39; is an alias for an unsigned value representing the size
        // of an object or the number of elements in a range.

    // CLASS METHODS
    template &lt;typename INPUT_ITER&gt;
    static bool equal(INPUT_ITER start1,
                      INPUT_ITER end1,
                      INPUT_ITER start2);
        // Compare each element in the range beginning at the specified
        // &#39;start1&#39; position and ending immediately before the specified &#39;end1&#39;
        // position to the corresponding element in the range of the same
        // length beginning at the specified &#39;start2&#39; position, as if using
        // &#39;operator==&#39; element-by-element.  Return &#39;true&#39; if every pair of
        // corresponding elements compares equal, and &#39;false&#39; otherwise.  Note
        // that this implementation uses &#39;operator==&#39; to perform the
        // comparisons, or bit-wise comparison if the value type has the
        // bit-wise equality-comparable trait.

    template &lt;typename INPUT_ITER&gt;
    static bool equal(INPUT_ITER start1,
                      INPUT_ITER end1,
                      INPUT_ITER start2,
                      INPUT_ITER end2);
    template &lt;typename INPUT_ITER&gt;
    static bool equal(INPUT_ITER start1, INPUT_ITER end1, size_type length1,
                      INPUT_ITER start2, INPUT_ITER end2, size_type length2);
        // Compare each element in the range beginning at the specified
        // &#39;start1&#39; position and ending immediately before the specified &#39;end1&#39;
        // position, to the corresponding element in the range beginning at the
        // specified &#39;start2&#39; position and ending immediately before the
        // specified &#39;end2&#39; position, as if by using &#39;operator==&#39;
        // element-by-element.  Optionally specify the length of each range,
        // &#39;length1&#39; and &#39;length2&#39;.  Return &#39;true&#39; if the ranges have the same
        // length and every element in the first range compares equal with the
        // corresponding element in the second, and &#39;false&#39; otherwise.  The
        // behavior is undefined unless &#39;length1&#39; is either unspecified or
        // equals the length of the range &#39;[start1, end1)&#39;, and &#39;length2&#39; is
        // either unspecified or equals the length of the range
        // &#39;[start2, end2)&#39;.  Note that this implementation uses &#39;operator==&#39;
        // to perform the comparisons, or bit-wise comparison if the value type
        // has the bit-wise equality-comparable trait.  Also note that
        // providing lengths may reduce the runtime cost of this operation.

    template &lt;typename INPUT_ITER&gt;
    static int lexicographical(INPUT_ITER start1,
                               INPUT_ITER end1,
                               INPUT_ITER start2,
                               INPUT_ITER end2);
    template &lt;typename INPUT_ITER&gt;
    static int lexicographical(INPUT_ITER start1,
                               INPUT_ITER end1,
                               size_type  length1,
                               INPUT_ITER start2,
                               INPUT_ITER end2,
                               size_type  length2);
        // Compare each element in the range beginning at the specified
        // &#39;start1&#39; position and ending immediately before the specified &#39;end1&#39;
        // position, to the corresponding element in the range beginning at the
        // specified &#39;start2&#39; position and ending immediately before the
        // specified &#39;end2&#39; position.  Optionally specify the length of each
        // range, &#39;length1&#39; and &#39;length2&#39;.  Return a negative value if the
        // first range compares lexicographically less than the second range, 0
        // if they are the same length and compare lexicographically equal, and
        // a positive value if the first range compares lexicographically
        // greater than the second range.  The behavior is undefined unless
        // &#39;length1&#39; is either unspecified or equals the length of the range
        // &#39;[start1, end1)&#39;, and &#39;length2&#39; is either unspecified or equals the
        // length of the range &#39;[start2, end2)&#39;.  Note that this implementation
        // uses &#39;std::memcmp&#39; for unsigned character comparisons,
        // &#39;std::wmemcmp&#39; for wide character comparisons, and &#39;operator&lt;&#39; for
        // all other types.
};

                       // =======================
                       // struct RangeCompare_Imp
                       // =======================

struct RangeCompare_Imp {
    // This utility &#39;struct&#39; provides the implementations for
    // &#39;bslalg::RangeCompare&#39;.  Multiple implementations are provided for each
    // method in &#39;bslalg::RangeCompare&#39;, and the most efficient version is
    // found by disambiguating based on the iterator type, the value type, or
    // the presence of nested traits.

    // CLASS METHODS
    template &lt;typename VALUE_TYPE&gt;
    static bool equal(const VALUE_TYPE  *start1,
                      const VALUE_TYPE  *end1,
                      const VALUE_TYPE  *start2,
                      const VALUE_TYPE  *end2,
                      const VALUE_TYPE&amp;,
                      bslmf::MetaInt&lt;1&gt;);
    template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
    static bool equal(INPUT_ITER         start1,
                      INPUT_ITER         end1,
                      INPUT_ITER         start2,
                      INPUT_ITER         end2,
                      const VALUE_TYPE&amp;,
                      bslmf::MetaInt&lt;0&gt;);
    template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
    static bool equal(INPUT_ITER         start1,
                      INPUT_ITER         end1,
                      INPUT_ITER         start2,
                      INPUT_ITER         end2,
                      const VALUE_TYPE&amp;);
        // Compare the range beginning at the specified &#39;start1&#39; position and
        // ending immediately before the specified &#39;end1&#39; position with the
        // range beginning at the specified &#39;start2&#39; position and ending
        // immediately before the specified &#39;end2&#39; position, as if using
        // &#39;operator==&#39; element-by-element.  The unnamed &#39;VALUE_TYPE&#39; argument
        // is for automatic type deduction, and is ignored.  The fifth argument
        // is for overloading resolution, and is also ignored.

    template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
    static bool equal(INPUT_ITER        start1,
                      INPUT_ITER        end1,
                      INPUT_ITER        start2,
                      const VALUE_TYPE&amp;,
                      bslmf::MetaInt&lt;1&gt;);
    template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
    static bool equal(INPUT_ITER        start1,
                      INPUT_ITER        end1,
                      INPUT_ITER        start2,
                      const VALUE_TYPE&amp;,
                      bslmf::MatchAnyType);
    template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
    static bool equal(INPUT_ITER        start1,
                      INPUT_ITER        end1,
                      INPUT_ITER        start2,
                      const VALUE_TYPE&amp;);
        // Compare the range beginning at the specified &#39;start1&#39; position and
        // ending immediately before the specified &#39;end1&#39; position with the
        // range beginning at the specified &#39;start2&#39; position of the same
        // length (namely, &#39;end1 - start1&#39;), as if using &#39;operator==&#39;
        // element-by-element.  The unnamed &#39;VALUE_TYPE&#39; argument is for
        // automatic type deduction, and is ignored.  The fifth argument is for
        // overloading resolution, and is also ignored.

    template &lt;typename VALUE_TYPE&gt;
    static bool equalBitwiseEqualityComparable(const VALUE_TYPE  *start1,
                                               const VALUE_TYPE  *end1,
                                               const VALUE_TYPE  *start2,
                                               bslmf::MetaInt&lt;1&gt;);
        // Compare the range beginning at the specified &#39;start1&#39; position and
        // ending immediately before the specified &#39;end1&#39; position with the
        // range beginning at the specified &#39;start2&#39; position of the same
        // length (namely, &#39;end1 - start1&#39;), using bit-wise comparison across
        // the entire ranges.  The last argument is for removing overload
        // ambiguities, and is not used.  Return &#39;true&#39; if the ranges are
        // bit-wise equal, and &#39;false&#39; otherwise.

    template &lt;typename INPUT_ITER&gt;
    static bool equalBitwiseEqualityComparable(INPUT_ITER        start1,
                                               INPUT_ITER        end1,
                                               INPUT_ITER        start2,
                                               bslmf::MetaInt&lt;0&gt;);
        // Compare the range beginning at the specified &#39;start1&#39; position and
        // ending immediately before the specified &#39;end1&#39; position with the
        // range beginning at the specified &#39;start2&#39; position of the same
        // length (namely, &#39;end1 - start1&#39;), using &#39;operator==&#39;
        // element-by-element.  The last argument is for removing overload
        // ambiguities, and is not used.  Return &#39;true&#39; if each element in the
        // first range is equal to the corresponding element in the second
        // range, and &#39;false&#39; otherwise.

    template &lt;typename VALUE_TYPE&gt;
    static int lexicographical(const VALUE_TYPE  *start1,
                               const VALUE_TYPE  *end1,
                               const VALUE_TYPE  *start2,
                               const VALUE_TYPE  *end2,
                               const VALUE_TYPE&amp;,
                               bslmf::MetaInt&lt;1&gt;);
        // Compare the range beginning at the specified &#39;start1&#39; position and
        // ending immediately before the specified &#39;end1&#39; position with the
        // range beginning at the specified &#39;start2&#39; position and ending
        // immediately before the specified &#39;end2&#39; position.  The last two
        // arguments are for removing overload ambiguities and are not used.
        // Return a negative value if the
        // first range compares lexicographically less than the second range, 0
        // if they are the same length and compare lexicographically equal, and
        // a positive value if the first range compares lexicographically
        // greater than the second range.

    template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
    static int lexicographical(INPUT_ITER        start1,
                               INPUT_ITER        end1,
                               INPUT_ITER        start2,
                               INPUT_ITER        end2,
                               const VALUE_TYPE&amp;,
                               bslmf::MetaInt&lt;0&gt;);
        // Compare each element in the range beginning at the specified
        // &#39;start1&#39; position and ending immediately before the specified &#39;end1&#39;
        // position with the corresponding element in the range beginning at
        // the specified &#39;start2&#39; position and ending immediately before the
        // specified &#39;end2&#39; position using &#39;operator&lt;&#39;.  The last two arguments
        // are for removing overload ambiguities and are not used.  Return a
        // negative value if the first range compares lexicographically less
        // than the second range, 0 if they are the same length and compare
        // lexicographically equal, and a positive value if the first range
        // compares lexicographically greater than the second range.

    template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
    static int lexicographical(INPUT_ITER        start1,
                               INPUT_ITER        end1,
                               INPUT_ITER        start2,
                               INPUT_ITER        end2,
                               const VALUE_TYPE&amp;);
        // Compare the range beginning at the specified &#39;start1&#39; position and
        // ending immediately before the specified &#39;end1&#39; position with the
        // range beginning at the specified &#39;start2&#39; position and ending
        // immediately before the specified &#39;end2&#39; position.  The type of the
        // last argument is considered in determining what optimizations, if
        // any, can be applied to the comparison.  The last argument is not
        // used in any other way.  Return a negative value if the
        // first range compares lexicographically less than the second range, 0
        // if they are the same length and compare lexicographically equal, and
        // a positive value if the first range compares lexicographically
        // greater than the second range.

    static int lexicographical(const char *start1,
                               const char *end1,
                               const char *start2);
        // Compare the range beginning at the specified &#39;start1&#39; position and
        // ending immediately before the specified &#39;end1&#39; position with the
        // range beginning at the specified &#39;start2&#39; position of the same
        // length (namely, &#39;end1 - start1&#39;), using a bit-wise comparison
        // across the entire range, if &#39;const char&#39; is unsigned, and using
        // &#39;operator&lt;&#39; otherwise.  Return a negative value if the
        // first range compares lexicographically less than the second range, 0
        // if they are the same length and compare lexicographically equal, and
        // a positive value if the first range compares lexicographically
        // greater than the second range.

    static int lexicographical(const unsigned char *start1,
                               const unsigned char *end1,
                               const unsigned char *start2);
    static int lexicographical(const wchar_t *start1,
                               const wchar_t *end1,
                               const wchar_t *start2);
    template &lt;typename INPUT_ITER&gt;
    static int lexicographical(INPUT_ITER           start1,
                               INPUT_ITER           end1,
                               INPUT_ITER           start2,
                               bslmf::MatchAnyType);
    template &lt;typename INPUT_ITER&gt;
    static int lexicographical(INPUT_ITER     start1,
                               INPUT_ITER     end1,
                               INPUT_ITER     start2);
        // Compare each element in the range beginning at the specified
        // &#39;start1&#39; position and ending immediately before the specified &#39;end1&#39;
        // position with the corresponding element in the range of the same
        // length beginning at the specified &#39;start2&#39; position.  Return a
        // negative value if the first range compares lexicographically less
        // than the second range, 0 if they are the same length and compare
        // lexicographically equal, and a positive value if the first range
        // compares lexicographically greater than the second range.
};

// ===========================================================================
//                  INLINE AND TEMPLATE FUNCTION DEFINITIONS
// ===========================================================================

                         // -------------------
                         // struct RangeCompare
                         // -------------------

// CLASS METHODS
template &lt;typename INPUT_ITER&gt;
inline
bool RangeCompare::equal(INPUT_ITER start1,
                         INPUT_ITER end1,
                         INPUT_ITER start2)
{
    if (start1 == end1) {
        return true;                                                  // RETURN
    }
    return RangeCompare_Imp::equal(start1, end1, start2, *start1);
}

template &lt;typename INPUT_ITER&gt;
inline
bool RangeCompare::equal(INPUT_ITER start1,
                         INPUT_ITER end1,
                         INPUT_ITER start2,
                         INPUT_ITER end2)
{
    if (start1 == end1) {
        return start2 == end2;                                        // RETURN
    }
    return RangeCompare_Imp::equal(start1, end1, start2, end2, *start1);
}

template &lt;typename INPUT_ITER&gt;
inline
bool RangeCompare::equal(INPUT_ITER start1,
                         INPUT_ITER end1,
                         size_type  length1,
                         INPUT_ITER start2,
                         INPUT_ITER,
                         size_type  length2)
{
    if (length1 != length2) {
        return false;                                                 // RETURN
    }
    if (start1 == end1) {
        return true;                                                  // RETURN
    }
    return RangeCompare_Imp::equal(start1, end1, start2, *start1);
}

template &lt;typename INPUT_ITER&gt;
int RangeCompare::lexicographical(INPUT_ITER start1,
                                  INPUT_ITER end1,
                                  INPUT_ITER start2,
                                  INPUT_ITER end2)
{
    if (start1 == end1) {
        return start2 != end2 ? -1 : 0;                               // RETURN
    }
    return RangeCompare_Imp::lexicographical(start1,
                                             end1,
                                             start2,
                                             end2,
                                             *start1);
}

template &lt;typename INPUT_ITER&gt;
int RangeCompare::lexicographical(INPUT_ITER start1,
                                  INPUT_ITER end1,
                                  size_type  length1,
                                  INPUT_ITER start2,
                                  INPUT_ITER end2,
                                  size_type  length2)
{
    const int result = length2 &lt; length1
                       ? - RangeCompare_Imp::lexicographical(start2,
                                                             end2,
                                                             start1)
                       :   RangeCompare_Imp::lexicographical(start1,
                                                             end1,
                                                             start2);

    if (result &lt; 0) {
        return -1;                                                    // RETURN
    }
    if (0 &lt; result) {
        return 1;                                                     // RETURN
    }
    if (length1 &lt; length2) {
        return -1;                                                    // RETURN
    }
    if (length2 &lt; length1) {
        return 1;                                                     // RETURN
    }
    return 0;
}

                       // -----------------------
                       // struct RangeCompare_Imp
                       // -----------------------

// CLASS METHODS

                          // *** equal overloads: ***

template &lt;typename VALUE_TYPE&gt;
inline
bool RangeCompare_Imp::equal(const VALUE_TYPE  *start1,
                             const VALUE_TYPE  *end1,
                             const VALUE_TYPE  *start2,
                             const VALUE_TYPE  *end2,
                             const VALUE_TYPE&amp;,
                             bslmf::MetaInt&lt;1&gt;)
{
    return RangeCompare::equal(start1,
                               end1,
                               end1 - start1,
                               start2,
                               end2,
                               end2 - start2);
}

template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
bool RangeCompare_Imp::equal(INPUT_ITER        start1,
                             INPUT_ITER        end1,
                             INPUT_ITER        start2,
                             INPUT_ITER        end2,
                             const VALUE_TYPE&amp;,
                             bslmf::MetaInt&lt;0&gt;)
{
    for ( ; start1 != end1 &amp;&amp; start2 != end2; ++start1, ++start2) {
        if (!(*start1 == *start2)) {
            return false;                                             // RETURN
        }
    }
    return start1 == end1 &amp;&amp; start2 == end2;
}

template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
bool RangeCompare_Imp::equal(INPUT_ITER        start1,
                             INPUT_ITER        end1,
                             INPUT_ITER        start2,
                             INPUT_ITER        end2,
                             const VALUE_TYPE&amp; value)
{
    typedef typename bslmf::IsConvertible&lt;INPUT_ITER, const VALUE_TYPE *&gt;::Type
                                                      CanUseLengthOptimization;

    return equal(start1,
                 end1,
                 start2,
                 end2,
                 value,
                 CanUseLengthOptimization());
}

template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
inline
bool RangeCompare_Imp::equal(INPUT_ITER        start1,
                             INPUT_ITER        end1,
                             INPUT_ITER        start2,
                             const VALUE_TYPE&amp;,
                             bslmf::MetaInt&lt;1&gt;)
{
    // Note: We are forced to call a different function to resolve whether
    // &#39;INPUT_ITER&#39; is convertible to &#39;const TARGET_TYPE *&#39; or not, otherwise
    // we would be introducing ambiguities (the additional parameter
    // &#39;CanUseBitwiseCopyOptimization&#39; is necessary to remove further
    // ambiguities on SunPro).

    typedef typename bslmf::IsConvertible&lt;INPUT_ITER, const VALUE_TYPE *&gt;::Type
                                              CanUseBitwiseCompareOptimization;

    return equalBitwiseEqualityComparable(start1,
                                          end1,
                                          start2,
                                          CanUseBitwiseCompareOptimization());
}

template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
bool RangeCompare_Imp::equal(INPUT_ITER        start1,
                             INPUT_ITER        end1,
                             INPUT_ITER        start2,
                             const VALUE_TYPE&amp;,
                             bslmf::MatchAnyType)
{
    for ( ; start1 != end1; ++start1, ++start2) {
        if (!(*start1 == *start2)) {
            return false;                                             // RETURN
        }
    }
    return true;
}

template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
inline
bool RangeCompare_Imp::equal(INPUT_ITER        start1,
                             INPUT_ITER        end1,
                             INPUT_ITER        start2,
                             const VALUE_TYPE&amp; value)
{
    typedef bslmf::MetaInt&lt;
        bslmf::IsBitwiseEqualityComparable&lt;VALUE_TYPE&gt;::value&gt; Trait;
    return equal(start1, end1, start2, value, Trait());
}

             // *** equalBitwiseEqualityComparable overloads: ***

template &lt;typename VALUE_TYPE&gt;
inline
bool RangeCompare_Imp::equalBitwiseEqualityComparable(
                                                     const VALUE_TYPE  *start1,
                                                     const VALUE_TYPE  *end1,
                                                     const VALUE_TYPE  *start2,
                                                     bslmf::MetaInt&lt;1&gt;)
{
    std::size_t numBytes = reinterpret_cast&lt;const char *&gt;(end1)
                         - reinterpret_cast&lt;const char *&gt;(start1);

    return 0 == std::memcmp(reinterpret_cast&lt;const void *&gt;(start1),
                            reinterpret_cast&lt;const void *&gt;(start2),
                            numBytes);
}

template &lt;typename INPUT_ITER&gt;
inline
bool RangeCompare_Imp::equalBitwiseEqualityComparable(INPUT_ITER        start1,
                                                      INPUT_ITER        end1,
                                                      INPUT_ITER        start2,
                                                      bslmf::MetaInt&lt;0&gt;)
{
    // We can&#39;t be as optimized as above.

    return equal(start1, end1, start2, *start1, bslmf::MatchAnyType(0));
}

                     // *** lexicographical overloads: ***

template &lt;typename VALUE_TYPE&gt;
inline
int RangeCompare_Imp::lexicographical(const VALUE_TYPE  *start1,
                                      const VALUE_TYPE  *end1,
                                      const VALUE_TYPE  *start2,
                                      const VALUE_TYPE  *end2,
                                      const VALUE_TYPE&amp;,
                                      bslmf::MetaInt&lt;1&gt;)
{
    // In this case, we can compute the length directly, and avoid the overhead
    // of the two comparisons in the loop condition (one is enough).

    return RangeCompare::lexicographical(start1,
                                         end1,
                                         end1 - start1,
                                         start2,
                                         end2,
                                         end2 - start2);
}

template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
int RangeCompare_Imp::lexicographical(INPUT_ITER        start1,
                                      INPUT_ITER        end1,
                                      INPUT_ITER        start2,
                                      INPUT_ITER        end2,
                                      const VALUE_TYPE&amp;,
                                      const bslmf::MetaInt&lt;0&gt;)
{
    for ( ; start1 != end1 &amp;&amp; start2 != end2; ++start1, ++start2) {
        if (*start1 &lt; *start2) {
            return -1;                                                // RETURN
        }
        else if (*start2 &lt; *start1) {
            return 1;                                                 // RETURN
        }
    }
    if (start1 != end1) {
        return 1;                                                     // RETURN
    }
    if (start2 != end2) {
        return -1;                                                    // RETURN
    }
    return 0;
}

template &lt;typename INPUT_ITER, typename VALUE_TYPE&gt;
inline
int RangeCompare_Imp::lexicographical(INPUT_ITER        start1,
                                      INPUT_ITER        end1,
                                      INPUT_ITER        start2,
                                      INPUT_ITER        end2,
                                      const VALUE_TYPE&amp; value)
{
    typedef typename bslmf::IsConvertible&lt;INPUT_ITER, const VALUE_TYPE *&gt;::Type
                                                      CanUseLengthOptimization;

    return lexicographical(start1, end1, start2, end2, value,
                           CanUseLengthOptimization());
}

inline
int RangeCompare_Imp::lexicographical(const unsigned char *start1,
                                      const unsigned char *end1,
                                      const unsigned char *start2)
{
    return std::memcmp(start1, start2, end1 - start1);
}

inline
int RangeCompare_Imp::lexicographical(const char *start1,
                                      const char *end1,
                                      const char *start2)
{
#if CHAR_MAX == SCHAR_MAX
    return std::memcmp(start1, start2, (end1 - start1));
#else
    return lexicographical&lt;const char *&gt;(start1, end1, start2, 0);
#endif
}

inline
int RangeCompare_Imp::lexicographical(const wchar_t *start1,
                                      const wchar_t *end1,
                                      const wchar_t *start2)
{
    return std::wmemcmp(start1, start2, end1 - start1);
}

template &lt;typename INPUT_ITER&gt;
int RangeCompare_Imp::lexicographical(INPUT_ITER start1,
                                      INPUT_ITER end1,
                                      INPUT_ITER start2,
                                      bslmf::MatchAnyType)
{
    for ( ; start1 != end1; ++start1, ++start2) {
        if (*start1 &lt; *start2) {
            return -1;                                                // RETURN
        }
        else if (*start2 &lt; *start1) {
            return 1;                                                 // RETURN
        }
    }
    return 0;
}

template &lt;typename INPUT_ITER&gt;
inline
int RangeCompare_Imp::lexicographical(INPUT_ITER start1,
                                      INPUT_ITER end1,
                                      INPUT_ITER start2)
{
    if (start1 != end1) {
        return lexicographical(start1, end1, start2, *start1);        // RETURN
    }
    return 0;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
