<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_nullptr Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_nullptr<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a distinct type for null pointer literals.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Limitations</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a distinct type for null pointer literals. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bsls::Nullptr </td><td>namespace for a type matching only null pointer literals  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a limited emulation of the C++11 type, <code>std::nullptr_t</code>, which can be used as a function parameter type to create an overload set where null pointer literals are handled specially. Note that this component will be deprecated, and ultimately removed, once BDE code can assume support for a C++11 compiler. On a platform that supports the language feature, a fully-conforming <code>typedef</code> is supplied rather than using the emulation layer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="limitations"></a> <a class="anchor" id="description.limitations"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Limitations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a simple emulation of the C++11 facility, which cannot be expressed with a pure library solution. As such it comes with a number of limitations. The most obvious is that C++11 provides a new null pointer literal, <code>nullptr</code>, which is not emulated by this component. The new null pointer literal is an object of a new type, expressed by the alias <code>nullptr_t</code>, which this component emulates. However, as this is a library-only emulation, it does not have any preference in the overloading rules, so will be an equal-rank ambiguous match. For example, given the following overload set, a call to <code>myFunction</code> with a null pointer literal would be ambiguous: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myFunction(<span class="keywordtype">void</span> *p);
  <span class="keywordtype">void</span> myFunction(<a class="code" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>);

  <span class="keywordtype">int</span> main() {
     myFunction(0);  <span class="comment">// ERROR, ambiguous function call</span>
  }
</pre></div><br/>
<br/>
 However, if the pointer-argument is a pointer whose type is deduced from the function call, then no pointer type can be deduced from the null pointer and this component becomes necessary. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
  <span class="keywordtype">void</span> myFunction(T *p);
  <span class="keywordtype">void</span> myFunction(<a class="code" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>);

  <span class="keywordtype">int</span> main() {
     myFunction(0);  <span class="comment">// call the &#39;bsl::nullptr_t&#39; method</span>
  }
</pre></div><br/>
<br/>
 Null pointer values can be created in C++11 by creating objects of type <code>std::nullptr_t</code>, and then used to initialize pointer and pointer-to-member objects: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">std::nullptr_t</a> nullLiteral = <a class="code" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">std::nullptr_t</a>();
  <span class="keywordtype">int</span> *pI = nullLiteral;
</pre></div><br/>
<br/>
 The type of a <code><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a></code> object cannot be used in such assignments or initializations, unless compiled on a platform that natively supports this C++11 language feature. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Example 1: Constructing a "smart pointer"<ul>
<li>- - - - - - - - - - - - - - - - - - - - First we define a smart pointer class template, as a guard to destroy a managed object as the smart pointer leaves scope. This class will have a constructor template taking a pointer to a type potentially derived from the parameterized type of the smart pointer, and also a deletion-policy function. By capturing the most-derived type through type-deduction when the smart pointer is constructed, we can ensure the correct destructor is called, even if the destructor of the base class has not been declared as <code>virtual</code>. However, relying on type-deduction means we cannot pass a null pointer to this constructor, as it is not possible to deduce what type a null pointer is supposed to refer to, therefore we must use a special null pointer type, such as <code>bsls::nullptr_t</code>. Note that in real code we would allocate and reclaim memory using a user-specified allocator, but defining such protocols in this low level component would further distract from the <code>nullptr</code> usage in this example. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TARGET_TYPE&gt;
  <span class="keyword">class </span>ScopedPointer {
      <span class="comment">// This class template is a guard to manage a dynamically created</span>
      <span class="comment">// object of the parameterized &#39;TARGET_TYPE&#39;.</span>

    <span class="keyword">private</span>:
      <span class="keyword">typedef</span> <span class="keywordtype">void</span> DeleterFn(TARGET_TYPE *);  <span class="comment">// deleter type</span>

      <span class="comment">// DATA</span>
      TARGET_TYPE *d_target_p;    <span class="comment">// wrapped pointer</span>
      DeleterFn   *d_deleter_fn;  <span class="comment">// deleter function</span>

      <span class="comment">// Objects of this type cannot be copied.</span>
      ScopedPointer(<span class="keyword">const</span> ScopedPointer&amp;);
      ScopedPointer&amp; operator=(<span class="keyword">const</span> ScopedPointer&amp;);

      <span class="keyword">template</span>&lt;<span class="keyword">class</span> SOURCE_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span> defaultDeleteFn(TARGET_TYPE *ptr);
          <span class="comment">// Destroy the specified &#39;*ptr&#39; by calling &#39;delete&#39; on the pointer</span>
          <span class="comment">// cast to the parameterized &#39;SOURCE_TYPE*&#39;.  It is an error to</span>
          <span class="comment">// instantiate this template with a &#39;SOURCE_TYPE&#39; that is not</span>
          <span class="comment">// derived from (and cv-compatible with) &#39;TARGET_TYPE&#39;.</span>

    <span class="keyword">public</span>:
      <span class="keyword">template</span>&lt;<span class="keyword">class</span> SOURCE_TYPE&gt;
      ScopedPointer(SOURCE_TYPE *pointer,
                    DeleterFn   *fn = &amp;defaultDeleteFn&lt;SOURCE_TYPE&gt;);
          <span class="comment">// Create a &#39;ScopedPointer&#39; object owning the specified &#39;pointer&#39;</span>
          <span class="comment">// and using the specified &#39;fn&#39; to destroy the owned pointer when</span>
          <span class="comment">// this object is destroyed.</span>

      ScopedPointer(<a class="code" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a> = 0);
          <span class="comment">// Create an empty &#39;ScopedPointer&#39; object that does not own a</span>
          <span class="comment">// pointer.</span>

      ~ScopedPointer();
          <span class="comment">// Destroy this &#39;ScopedPointer&#39; object and the target object</span>
          <span class="comment">// that it owns, using the stored deleter function.</span>

      <span class="comment">// Further methods appropriate to a smart pointer, such as</span>
      <span class="comment">// &#39;operator*&#39; and &#39;operator-&gt;&#39; elided from this example.</span>
  };
</pre></div><br/>
<br/>
 Then we provide a definition for each of the methods. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TARGET_TYPE&gt;
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> SOURCE_TYPE&gt;
  <span class="keywordtype">void</span> ScopedPointer&lt;TARGET_TYPE&gt;::defaultDeleteFn(TARGET_TYPE *ptr)
  {
      <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>SOURCE_TYPE *<span class="keyword">&gt;</span>(ptr);
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TARGET_TYPE&gt;
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> SOURCE_TYPE&gt;
  <span class="keyword">inline</span>
  ScopedPointer&lt;TARGET_TYPE&gt;::ScopedPointer(SOURCE_TYPE *pointer,
                                            DeleterFn   *fn)
  : d_target_p(pointer)
  , d_deleter_fn(fn)
  {
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TARGET_TYPE&gt;
  <span class="keyword">inline</span>
  ScopedPointer&lt;TARGET_TYPE&gt;::ScopedPointer(<a class="code" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>)
  : d_target_p(0)
  , d_deleter_fn(0)
  {
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TARGET_TYPE&gt;
  <span class="keyword">inline</span>
  ScopedPointer&lt;TARGET_TYPE&gt;::~ScopedPointer()
  {
      <span class="keywordflow">if</span> (d_deleter_fn) {
          d_deleter_fn(d_target_p);
      }
  }
</pre></div><br/>
<br/>
 Finally, we can construct a <code>ScopedPointer</code> with a null pointer literal, that would otherwise be non-deducible, using our <code><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a></code> overload. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testScopedPointer()
  {
      ScopedPointer&lt;int&gt; x(0);
  }
</pre></div><br/>
<br/>
 </li>
</ul>
</dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
