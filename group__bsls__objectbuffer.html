<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bsls_objectbuffer Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_objectbuffer<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide raw buffer with size and alignment of user-specified type.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Creating a Dynamic Array of Objects</a> </li>
<li>
<a href="#3.1.2">Example 2: Containing Different Object Types</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide raw buffer with size and alignment of user-specified type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a> </td><td>templatized buffer aligned to hold specified type  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bsls__alignmentfromtype.html" title="Provide a meta-function that maps a TYPE to its alignment.">Component bsls_alignmentfromtype</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a templated buffer type, <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a></code>, which is compile-time sized and aligned to hold a specified object type. Defining a <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a>&lt;T&gt;</code> object does not cause the constructor for <code>T</code> to be called. Similarly, destroying the object buffer does not call the destructor for <code>T</code>. Instead, the user instantiates <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a></code> with a specific type, then constructs an object of that type within that buffer. When the object is no longer needed, the user must explicitly call its destructor. A <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a></code> can reside on the stack or within another object, including within a <code>union</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Typically, a <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a></code> is used in situations where efficient (e.g., stack-based) storage is required but where straight-forward initialization or destruction of an object is not possible. For example, <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a></code> can be used to construct an array where the number of used elements varies at run-time or where the element type does not have a default constructor. It can also be used to create a <code>union</code> containing non-POD element types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The examples below use a value-semantic string class, <code>my_String</code> which can be constructed from a null-terminated string and contains a member, <code>c_str</code> which returns a null-terminated string. <code>my_String</code> does not have a default constructor and thus cannot be used in C-style arrays or unions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_dynamic_array_of_objects"></a> <a class="anchor" id="usage.example_1~3A_creating_a_dynamic_array_of_objects"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_dynamic_array_of_objects"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Dynamic Array of Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Here we use <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a></code> to create a variable-length array of <code>my_String</code> objects. For efficiency, the array is created on the stack as a fixed-sized array of <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a>&lt;my_String&gt;</code> objects and the length is kept in a separate variable. Only <code>len</code> calls are made to the <code>my_String</code> constructor, with the unused array elements left as raw memory. An array directly containing <code>my_String</code> objects would not have been possible because <code>my_String</code> does not have a default constructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>WARNING: the <code>manipulateStrings</code> function below is not exception-safe. If an exception is thrown anywhere within the function (e.g., from a constructor call), the destructor will not be called on the constructed string objects. This logic would typically be augmented with guard objects that call destructors in case of exception. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> manipulateStrings(<span class="keyword">const</span> my_String* stringArray, <span class="keywordtype">int</span> len)
  {
      assert(len &lt;= 10);

      <a class="code" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer&lt;my_String&gt;</a> tempArray[10];
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i) {
          <span class="keyword">new</span> (tempArray[i].<a class="code" href="unionbsls_1_1ObjectBuffer.html#ac945532bb38c2fceaef0ef34e68cf591">buffer</a>()) my_String(stringArray[i]);
          assert(stringArray[i] == tempArray[i].<span class="keywordtype">object</span>())
      }

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i)
      {
          my_String&amp; s = tempArray[i].<a class="code" href="unionbsls_1_1ObjectBuffer.html#a6bc8bb8e0767e20cfe4c3d41bbd8391d">object</a>();
          <span class="comment">// ... String manipulations go here.  &#39;s&#39; might be analyzed,</span>
          <span class="comment">// appended-to, passed to other functions, etc.</span>
      }

      <span class="keywordflow">while</span> (len) {
          <span class="comment">// Destroy strings.  Although not critical to this example, we</span>
          <span class="comment">// follow the general rule of destroying the objects in reverse</span>
          <span class="comment">// order of their construction, thus mimicking the</span>
          <span class="comment">// compiler-generated destruction order for normal array objects.</span>
          tempArray[--len].<a class="code" href="unionbsls_1_1ObjectBuffer.html#a6bc8bb8e0767e20cfe4c3d41bbd8391d">object</a>().~my_String();
      }
  }

  <span class="keywordtype">int</span> main()
  {
      <span class="keyword">const</span> my_String INARRAY[3] = {
          my_String(<span class="stringliteral">&quot;hello&quot;</span>),
          my_String(<span class="stringliteral">&quot;goodbye&quot;</span>),
          my_String(<span class="stringliteral">&quot;Bloomberg&quot;</span>)
      };

      manipulateStrings(INARRAY, 3);

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_containing_different_object_types"></a> <a class="anchor" id="usage.example_2~3A_containing_different_object_types"></a> <a class="anchor" id="description.usage.example_2~3A_containing_different_object_types"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Containing Different Object Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Here we use <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a></code> to compose a variable-type object capable of holding a string or an integer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Union
  {
    <span class="keyword">public</span>:
      <span class="keyword">enum</span> TypeTag { INT, STRING };

    <span class="keyword">private</span>:
      TypeTag                           d_type;
      <span class="keyword">union </span>{
          <span class="keywordtype">int</span>                           d_int;
          <a class="code" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer&lt;my_String&gt;</a> d_string;
      };

    <span class="keyword">public</span>:
      my_Union(<span class="keywordtype">int</span> i = 0) : d_type(INT) { d_int = i; }            <span class="comment">// IMLPICIT</span>
      my_Union(<span class="keyword">const</span> my_String&amp; s) : d_type(STRING) {             <span class="comment">// IMLPICIT</span>
          <span class="keyword">new</span> (d_string.buffer()) my_String(s); }
      my_Union(<span class="keyword">const</span> <span class="keywordtype">char</span> *s) : d_type(STRING) {                  <span class="comment">// IMLPICIT</span>
          <span class="keyword">new</span> (d_string.buffer()) my_String(s); }
      my_Union(<span class="keyword">const</span> my_Union&amp; rhs) : d_type(rhs.d_type) {
          <span class="keywordflow">if</span> (INT == d_type) {
              d_int = rhs.d_int;
          }
          <span class="keywordflow">else</span> {
              <span class="keyword">new</span> (d_string.buffer()) my_String(rhs.d_string.object());
          }
      }
      ~my_Union() {
          <span class="keywordflow">if</span> (STRING == d_type) d_string.object().~my_String(); }

      my_Union&amp; operator=(<span class="keyword">const</span> my_Union&amp; rhs) {
          <span class="keywordflow">if</span> (INT == d_type) {
              <span class="keywordflow">if</span> (INT == rhs.d_type) {
                  d_int = rhs.d_int;
              }
              <span class="keywordflow">else</span> { <span class="comment">// if STRING == rhs.d_type</span>
                  <span class="keyword">new</span> (d_string.buffer()) my_String(rhs.d_string.object());
              }
          }
          <span class="keywordflow">else</span> { <span class="comment">// if (STRING == d_type)</span>
              <span class="keywordflow">if</span> (INT == rhs.d_type) {
                  d_string.object().~my_String();
                  d_int = rhs.d_int;
              }
              <span class="keywordflow">else</span> { <span class="comment">// if STRING == rhs.d_type</span>
                  d_string.object() = rhs.d_string.object();
              }
          }
          d_type = rhs.d_type;
          <span class="keywordflow">return</span> *<span class="keyword">this</span>;
      }

      TypeTag typeTag()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_type; }

      <span class="keywordtype">int</span> asInt()<span class="keyword"> const </span>{
          <span class="keywordflow">return</span> INT == d_type ?
                          d_int : <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(
                                    strtol(d_string.object().c_str(), 0, 0));
  }

      my_String asString()<span class="keyword"> const </span>{
          <span class="keywordflow">if</span> (INT == d_type) {
              <span class="keywordtype">char</span> temp[15];
              sprintf(temp, <span class="stringliteral">&quot;%d&quot;</span>, d_int);
              <span class="keywordflow">return</span> my_String(temp);
          }
          <span class="keywordflow">else</span> {
              <span class="keywordflow">return</span> d_string.object();
          }
      }
  };

  <span class="keywordtype">int</span> main()
  {
      assert(<span class="keyword">sizeof</span>(<a class="code" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer&lt;my_String&gt;</a>) == <span class="keyword">sizeof</span>(my_String));

      <span class="comment">// Create a &#39;my_Union&#39; object containing a string.</span>
      <span class="keyword">const</span> my_Union U1(<span class="stringliteral">&quot;hello&quot;</span>);
      assert(my_Union::STRING == U1.typeTag());
      assert(0 == U1.asInt());
      assert(<span class="stringliteral">&quot;hello&quot;</span> == U1.asString());

      <span class="comment">// Create a &#39;my_Union&#39; object containing an integer.</span>
      <span class="keyword">const</span> my_Union U2(123);
      assert(my_Union::INT == U2.typeTag());
      assert(123 == U2.asInt());
      assert(<span class="stringliteral">&quot;123&quot;</span> == U2.asString());

      <span class="comment">// Create a &#39;my_Union&#39; object containing a string that can be</span>
      <span class="comment">// interpreted as an integer.</span>
      <span class="keyword">const</span> my_Union U3(<span class="stringliteral">&quot;0x456&quot;</span>);
      assert(my_Union::STRING == U3.typeTag());
      assert(0x456 == U3.asInt());
      assert(<span class="stringliteral">&quot;0x456&quot;</span> == U3.asString());

      <span class="comment">// Copy-construct a &#39;my_Union&#39; object containing a string.</span>
      my_Union u4(U3);
      assert(my_Union::STRING == u4.typeTag());
      assert(0x456 == u4.asInt());
      assert(<span class="stringliteral">&quot;0x456&quot;</span> == u4.asString());

      <span class="comment">// Use assignment to change &#39;u4&#39; from string to integer.</span>
      u4 = U2;
      assert(my_Union::INT == u4.typeTag());
      assert(123 == u4.asInt());
      assert(<span class="stringliteral">&quot;123&quot;</span> == u4.asString());

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:02 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
