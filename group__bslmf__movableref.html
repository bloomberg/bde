<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslmf_movableref Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmf_movableref<br/>
<small>
[<a class="el" href="group__bslmf.html">Package bslmf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a vocabulary type to enable move semantics.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmf.html">bslmf</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Use of <code>MovableRef&lt;TYPE&gt;</code> Parameters</a> </li>
<li>
<a href="#3.2">Template Deduction and Argument Forwarding</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a vocabulary type to enable move semantics. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a> </td><td>a template indicating that an object can be moved from  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1MovableRefUtil.html">bslmf::MovableRefUtil</a> </td><td>a namespace for functions dealing with movables  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class template, <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a></code> used to convey the information that an object will not be used anymore so that its representation can be transferred elsewhere. In C++11 terminology an object represented by a <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> can be moved from. This component also provides a utility <code>struct</code> <code><a class="el" href="structbslmf_1_1MovableRefUtil.html">bslmf::MovableRefUtil</a></code> that enables use of identical code for C++03 and C++11 to implement move semantics. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An object is /movable/ when it isn't being used in a way depending on its current representation after an operation on this object. For example, when passing a temporary object to a function the temporary object is movable: it can't be referred to other than in the function call. When objects are no longer be used their internal representation can be transferred to another object. Transferring the internal representation of an object to another object is called /moving an object/. The purpose of <code>bslmf::MoveableRef&lt;T&gt;</code> is to indicate to a function that an object can be moved to another object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>With a C++11 implementation <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> is an alias template for <code>T&amp;&amp;</code>. With a C++03 implementation <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> is a class template providing l-value access to a movable object. The objective of this component is to provide a name for the concept of a movable object. Using a common name enables use of manual move semantics when using C++03. With C++11 additionally automatic move semantics is enabled resulting in moving objects known to the compiler to go out of scope, e.g., when passing a temporary object to a function or returning a local variable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> to support movable types enables the implementation of move semantics that work with both C++03 and C++11 without conditional compilation of the user code. Only the implementation of the component <code>bslmf_movableref</code> uses conditional compilation to select the appropriate implementation choice. For a C++11 implementation the use of <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> instead of <code>T&amp;&amp;</code> has the advantage that the <code>T</code> will not be deduced an the argument is known to be movable: when a function takes a <code>T&amp;&amp;</code> as argument with a deduced <code>T</code> the deduced type may be an l-value reference that isn't necessarily movable. When using <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> with C++11 the type will not be deduced and to turn an l-value into a movable object it is necessary to explicitly use <code>move()</code> at the call site. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For consistent use across different versions of the C++ standard, a few utility functions are provided in the utility class <code><a class="el" href="structbslmf_1_1MovableRefUtil.html">bslmf::MovableRefUtil</a></code>. This class contains functions for moving and accessing objects. To enable an identical notation to access an object with C++11 (where <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> is just an l-value of type <code>T</code>) and with C++03 where <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> is a class type referencing an l-value of type <code>T</code>, the function template <code>bslmf::MovableRefUtil::access(r)</code> is provided. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="use_of_movableref~3Ctype~3E_parameters"></a> <a class="anchor" id="description.use_of_movableref~3Ctype~3E_parameters"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Use of MovableRef&lt;TYPE&gt; Parameters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are a number of differences how <code>MovableRef&lt;TYPE&gt;</code> parameters are handled between C++03 and C++11 implementations. Due to the language differences there is no way to avoid these. This component enables use of move semantics in both C++03 and C++11 when done right. It doesn't try to make implementation of move semantics easier. Here are some notes to keep in mind when using this component: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
When using a <code>TYPE&amp;&amp;</code> in a context where <code>TYPE</code> is deduced, the resulting reference does normally <em>not</em> refer to an object that can be moved from! If <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;TYPE&gt;</code> would deduce the type when using a C++11 implementation the name would be rather misleading. Thus, the <code>TYPE</code> won't be deduced. When using a C++03 the type /can/ be deduced. However, a program depending on the <code>TYPE</code> being deduced from a <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;TYPE&gt;</code> will not compile with a C++11 implementation.  </li>
<li>
Returning <code>MovableRef&lt;TYPE&gt;</code> (or <code>TYPE&amp;&amp;</code>) from a function is almost always wrong. In particular note that the same life-time issues apply to <code>MovableRef&lt;TYPE&gt;</code> as they do to references of objects: when returning a reference the object referred to cannot be on the stack, i.e., returning a <code>MovableRef&lt;TYPE&gt;</code> refering to a local variable or a by-value function parameter is certainly wrong. Returning a <code>MovableRef&lt;TYPE&gt;</code> to a function parameter received as a reference type can be correct.  </li>
<li>
Using the argument of type <code>MovableRef&lt;TYPE&gt;</code> directly in a function typically results in incorrect behavior either when using C++03 or when using C++11. Instead, use these arguments together with <code>MovableRefUtil::move()</code>, <code>MovableRefUtil::access()</code>, or bind them to a non-'const' l-value reference.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The purpose of <code>access(x)</code> is to use the same notation for member access to <code>x</code> independent on whether it is an actual l-value reference or an <code>MovableRef&lt;TYPE&gt;</code>. For a concrete examples assume <code>x</code> is a <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;A, B&gt;</code>. When using a C++11 implementation <code>MovableRef&lt;<a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;A, B&gt; &gt;</code> is really just a <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;A, B&gt;&amp;&amp;</code> and the elements could be accessed using <code>x.first</code> and <code>x.second</code>. For a C++03 implementation <code>MovableRef&lt;<a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;A, B&gt; &gt;</code> is a class type and <code>x.first</code> and <code>x.second</code> are not available. Instead, a reference to the pair needs to be obtained which could be done using <code>static_cast&lt;<a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;A, B &gt;&amp;&gt;(x)</code> or by using a named variable. To unify the notation between the C++03 and C++11 implementation, simultanously simplifying the C++03 use <code>MovableRefUtil::access(x)</code> can be used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="template_deduction_and_argument_forwarding"></a> <a class="anchor" id="description.template_deduction_and_argument_forwarding"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Template Deduction and Argument Forwarding: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>C++11 has two entirely different uses of the notation <code>T&amp;&amp;</code>: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
In contexts where the type <code>T</code> is not deduced the notation implies that only an r-value can be bound to the corresponding reference. For this use <code>T&amp;&amp;</code> is truly an r-value reference.  </li>
<li>
In contexts where the type <code>T</code> is deduced the notation implies that the type <code>T</code> will include information on whether the entity bound is an r-value or an l-value.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The use of <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code> and <code>T&amp;&amp;</code> can only indicate that the reference is refering to an object whose content can be transferred if the type <code>T</code> is not deduced. Also, the C++03 implementation cannot distinguish between r-value and l-value, i.e., the component should be used only in contexts where <code>T</code> is not deduced. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two sides of move semantics: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Classes or class templates that are <em>move-enabled</em>, i.e., which can transfer their internal representation to another object in some situations. To become move-enabled a class needs to implement, at least, a move constructor. It should probably also implement a move assignment.  </li>
<li>
Users of a potentially move-enabled class may take advantage of moving objects by explicitly indicating that ownership of resources may be transferred. When using C++11 the compiler can automatically detect some situations where it is safe to move objects but this features is not available with C++03.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The usage example below demonstrate both use cases using a simplified version of <code>std::vector&lt;T&gt;</code>. The class template is simplified to concentrate on the aspects relevant to <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;T&gt;</code>. Most of the operations are just normal implementations to create a container. The last two operations described are using move operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The definition of the <code>vector&lt;TYPE&gt;</code> class template is rather straight forward. For simplicity a few trivial operations are implemented directly in the class definition: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>vector
  {
      TYPE *d_begin;
      TYPE *d_end;
      TYPE *d_endBuffer;

      <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a>(TYPE*&amp; a, TYPE*&amp; b);
          <span class="comment">// Swap the specified pointers &#39;a&#39; and &#39;b&#39;.</span>

    <span class="keyword">public</span>:
      vector();
          <span class="comment">// Create an empty vector.</span>

      vector(<a class="code" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef&lt;vector&gt;</a> other);                    <span class="comment">// IMPLICIT</span>
          <span class="comment">// Create a vector by transfering the content of the specified</span>
          <span class="comment">// &#39;other&#39;.</span>

      vector(<span class="keyword">const</span> vector&amp; other);
          <span class="comment">// Create a vector by copying the content of the specified &#39;other&#39;.</span>

      vector&amp; operator= (vector other);
          <span class="comment">// Assign a vector by copying the content of the specified &#39;other&#39;</span>
          <span class="comment">// and return a reference to this object.  Note that &#39;other&#39; is</span>
          <span class="comment">// passed by value to have the copy or move already be done, or</span>
          <span class="comment">// even elided.  Within the body of the assignment operator the</span>
          <span class="comment">// content of &#39;this&#39; and &#39;other&#39; are simply swapped.</span>

      ~vector();
          <span class="comment">// Destroy the vector&#39;s elements and release any allocated memory.</span>

      TYPE&amp;       operator[](<span class="keywordtype">int</span> index)      { <span class="keywordflow">return</span> this-&gt;d_begin[index]; }
          <span class="comment">// Return a reference to the object at the specified &#39;index&#39;.</span>

      <span class="keyword">const</span> TYPE&amp; operator[](<span class="keywordtype">int</span> index)<span class="keyword"> const</span>{ <span class="keywordflow">return</span> this-&gt;d_begin[index]; }
          <span class="comment">// Return a reference to the object at the specified &#39;index&#39;.</span>

      TYPE       *begin()       { <span class="keywordflow">return</span> this-&gt;d_begin; }
          <span class="comment">// Return a pointer to the first element.</span>

      <span class="keyword">const</span> TYPE *begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;d_begin; }
          <span class="comment">// Return a pointer to the first element.</span>

      <span class="keywordtype">int</span> capacity()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> int(this-&gt;d_endBuffer - this-&gt;d_begin); }
          <span class="comment">// Return the capacity of the vector.</span>

      <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;d_begin == this-&gt;d_end; }
          <span class="comment">// Return &#39;true&#39; if the vector is empty and &#39;false&#39; otherwise.</span>

      TYPE       *end()       { <span class="keywordflow">return</span> this-&gt;d_end; }
          <span class="comment">// Return a pointer to the end of the range.</span>

      <span class="keyword">const</span> TYPE *end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;d_end; }
          <span class="comment">// Return a pointer to the end of the range.</span>

      <span class="keywordtype">void</span> push_back(<span class="keyword">const</span> TYPE&amp; value);
          <span class="comment">// Append a copy of the specified &#39;value&#39; to the vector.</span>

      <span class="keywordtype">void</span> push_back(<a class="code" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef&lt;TYPE&gt;</a> value);
          <span class="comment">// Append an object moving the specified &#39;value&#39; to the new</span>
          <span class="comment">// location.</span>

      <span class="keywordtype">void</span> reserve(<span class="keywordtype">int</span> newCapacity);
          <span class="comment">// Reserve enough capacity to fit at least as many elements as</span>
          <span class="comment">// specified by &#39;newCapacity&#39;.</span>

      <span class="keywordtype">int</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> int(this-&gt;d_end - this-&gt;d_begin); }
          <span class="comment">// Return the size of the object.</span>

      <span class="keywordtype">void</span> <a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a>(vector&amp; other);
          <span class="comment">// Swap the content of the vector with the specified &#39;other&#39;.</span>
  };
</pre></div><br/>
<br/>
 The class stores pointers to the begin and the end of the elements as well as a pointer to the end of the allocated buffer. If there are no elements, null pointers are stored. There a number of accessors similar to the accessors used by <code>std::vector&lt;TYPE&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default constructor creates an empty <code>vector&lt;TYPE&gt;</code> by simply initializing all member pointers to be null pointers: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  vector&lt;TYPE&gt;::vector()
      : d_begin()
      , d_end()
      , d_endBuffer()
  {
  }
</pre></div><br/>
<br/>
 To leverage already implemented functionality some of the member functions operate on a temporary <code>vector&lt;TYPE&gt;</code> and move the result into place using the <code><a class="el" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap()</a></code> member function that simply does a memberwise <code><a class="el" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap()</a></code> (the function swapping pointers is implemented here to avoid any dependency on functions defined in another level): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> <a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">vector&lt;TYPE&gt;::swap</a>(TYPE*&amp; a, TYPE*&amp; b)
  {
      TYPE *tmp = a;
      a = b;
      b = tmp;
  }
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> <a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">vector&lt;TYPE&gt;::swap</a>(vector&amp; other)
  {
      this-&gt;<a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a>(this-&gt;d_begin, other.d_begin);
      this-&gt;<a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a>(this-&gt;d_end, other.d_end);
      this-&gt;<a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a>(this-&gt;d_endBuffer, other.d_endBuffer);
  }
</pre></div><br/>
<br/>
 The member function <code>reserve()</code> arranges for the <code>vector&lt;TYPE&gt;</code> to have enough capacity for the number of elements specified as argument. The function first creates an empty <code>vector&lt;TYPE&gt;</code> called <code>tmp</code> and sets <code>tmp</code> up to have enough capacity by allocating sufficient memory and assigning the different members to point to the allocated buffer. The function then iterates over the elements of <code>this</code> and for each element it constructs a new element in <code>tmp</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> vector&lt;TYPE&gt;::reserve(<span class="keywordtype">int</span> newCapacity)
  {
      <span class="keywordflow">if</span> (this-&gt;capacity() &lt; newCapacity) {
          vector tmp;
          <span class="keywordtype">int</span>    size = int(<span class="keyword">sizeof</span>(TYPE) * newCapacity);
          tmp.d_begin = <span class="keyword">static_cast&lt;</span>TYPE*<span class="keyword">&gt;</span>(<a class="code" href="group__bdlma__bufferedsequentialpool.html#gae18335d3caf814f9f9cd5250ec6696ad">operator new</a>(size));
          tmp.d_end = tmp.d_begin;
          tmp.d_endBuffer = tmp.d_begin + newCapacity;

          <span class="keywordflow">for</span> (TYPE* it = this-&gt;d_begin; it != this-&gt;d_end; ++it) {
              <span class="keyword">new</span> (tmp.d_end) TYPE(*it);
              ++tmp.d_end;
          }
          this-&gt;<a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a>(tmp);
      }
  }
</pre></div><br/>
<br/>
 Any allocated data and constructed elements need to be release in the destructor. The destructor does so by calling the destructor of the elements in the buffer from back to front. Once the elements are destroyed the buffer is released: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  vector&lt;TYPE&gt;::~vector()
  {
      <span class="keywordflow">if</span> (this-&gt;d_begin) {
          <span class="keywordflow">while</span> (this-&gt;d_begin != this-&gt;d_end) {
              --this-&gt;d_end;
              this-&gt;d_end-&gt;~TYPE();
          }
          <a class="code" href="group__bdlma__bufferedsequentialpool.html#gaa564d26c9804cdedf140db32da6c1ca7">operator delete</a>(this-&gt;d_begin);
      }
  }
</pre></div><br/>
<br/>
 Using <code>reserve()</code> and constructing the elements it is straight forward to implement the copy constructor. First the member pointers are initialed to null. If <code>other</code> is empty there is nothing further to do as it is desirable to not allocate a buffer for an empty <code>vector</code>. If there are elements to copy the buffer is set up by calling <code>reserve()</code> to create sufficient capacity. Once that is done elements are copied by iterating over the elements of <code>other</code> and constructing elements using placement new in the appropriate location. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  vector&lt;TYPE&gt;::vector(<span class="keyword">const</span> vector&amp; other)
      : d_begin()
      , d_end()
      , d_endBuffer()
  {
      <span class="keywordflow">if</span> (!other.empty()) {
          this-&gt;reserve(4 &lt; other.size()? other.size(): 4);

          ASSERT(other.size() &lt;= this-&gt;capacity());
          <span class="keywordflow">for</span> (TYPE* it = other.d_begin; it != other.d_end; ++it) {
              <span class="keyword">new</span> (this-&gt;d_end) TYPE(*it);
              ++this-&gt;d_end;
          }
      }
  }
</pre></div><br/>
<br/>
 A simple copy assignment operator can be implemented in terms of copy/move constructors, <code><a class="el" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap()</a></code>, and destructor (in a real implementation the copy assignment would probably try to use already allocated objects). In this implementation that argument is taken by value, i.e., the argument is already constructed using copy or move construction (which may have been elided), the content of <code>this</code> is swapped with the content of <code>other</code> leaving this in the desired state, and the destructor will release the former representation of <code>this</code> when <code>other</code> is destroyed': <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  vector&lt;TYPE&gt;&amp; vector&lt;TYPE&gt;::operator= (vector other)
  {
      this-&gt;<a class="code" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a>(other);
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div><br/>
<br/>
 To complete the normal C++03 operations of <code>vector&lt;TYPE&gt;</code> the only remaining member function is <code>push_back()</code>. This function calls <code>reserve()</code> to obtain more capacity if the current capacity is filled and then constructs the new element at the location pointed to by <code>d_end</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> vector&lt;TYPE&gt;::push_back(<span class="keyword">const</span> TYPE&amp; value)
  {
      <span class="keywordflow">if</span> (this-&gt;d_end == this-&gt;d_endBuffer) {
          this-&gt;reserve(this-&gt;size()? <span class="keywordtype">int</span>(1.5 * this-&gt;size()): 4);
      }
      assert(this-&gt;d_end != this-&gt;d_endBuffer);
      <span class="keyword">new</span>(this-&gt;d_end) TYPE(value);
      ++this-&gt;d_end;
  }
</pre></div><br/>
<br/>
 The first operation actually demonstrating the use of <code>MovableRef&lt;TYPE&gt;</code> is the move constructor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  vector&lt;TYPE&gt;::vector(<a class="code" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef&lt;vector&gt;</a> other)
      : d_begin(bslmf::MovableRefUtil::access(other).d_begin)
      , d_end(bslmf::MovableRefUtil::access(other).d_end)
      , d_endBuffer(bslmf::MovableRefUtil::access(other).d_endBuffer)
  {
      vector&amp; reference(other);
      reference.d_begin = 0;
      reference.d_end = 0;
      reference.d_endBuffer = 0;
  }
</pre></div><br/>
<br/>
 This constructor gets an <code>MovableRef&lt;vector&lt;TYPE&gt; &gt;</code> passed as argument that indicates that the referenced objects can be modified as long as it is left in a state meeting the class invariants. The implementation of this constructor first copies the <code>d_begin</code>, <code>d_end</code>, and <code>d_capacity</code> members of <code>other</code>. Since <code>other</code> is either an object of type <code>MovableRef&lt;vector&lt;TYPE&gt; &gt;</code> (when compiling using a C++03 compiler) or an r-value reference <code>vector&lt;TYPE&gt;&amp;&amp;</code> the members are accessed using <code>MovableRefUtil::access(other)</code> to get a reference to a <code>vector&lt;TYPE&gt;</code>. Within the body of the constructor an l-value reference is obtained either via the conversion operator of <code>MovableRef&lt;T&gt;</code> or directly as <code>other</code> is just an l-value when compiling with a C++11 compiler. This reference is used to set the pointer members of the object referenced by <code>other</code> to <code>0</code> completing the move of the content to the object under construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, a move version of <code>push_back()</code> is provided: it takes an <code>MovableRef&lt;TYPE&gt;</code> as argument. The type of this argument indicates that the state can be transferred and after arranging enough capacity in the <code>vector&lt;TYPE&gt;</code> object a new element is move constructed at the position <code>d_end</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> vector&lt;TYPE&gt;::push_back(<a class="code" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef&lt;TYPE&gt;</a> value)
  {
      <span class="keywordflow">if</span> (this-&gt;d_end == this-&gt;d_endBuffer) {
          this-&gt;reserve(this-&gt;size()? <span class="keywordtype">int</span>(1.5 * this-&gt;size()): 4);
      }
      assert(this-&gt;d_end != this-&gt;d_endBuffer);
      <span class="keyword">new</span>(this-&gt;d_end) TYPE(<a class="code" href="structbslmf_1_1MovableRefUtil.html#a81937fc82df2e42449aa541ec1954bb7">bslmf::MovableRefUtil::move</a>(value));
      ++this-&gt;d_end;
  }
</pre></div><br/>
<br/>
 Note that this implementation of <code>push_back()</code> uses <code>bslmf::MovableRefUtil::move(value)</code> to move the argument. For a C++03 implementation the argument would be moved even when using <code>value</code> directly because the type of <code>value</code> stays <code><a class="el" href="classbslmf_1_1MovableRef.html">bslmf::MovableRef</a>&lt;TYPE&gt;</code>. However, for a C++11 implementation the argument <code>value</code> is an l-value and using it directly would result in a copy. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To demonstrate the newly created <code>vector&lt;TYPE&gt;</code> class in action, first a <code>vector&lt;int&gt;</code> is created and filled with a few elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  vector&lt;int&gt; vector0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 5; ++i) {
      vector0.push_back(i);
  }
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 5; ++i) {
      assert(vector0[i] == i);
  }
</pre></div><br/>
<br/>
 To verify that copying of <code>vector&lt;TYPE&gt;</code> objects works, a copy is created: <br/>
<br/>
<div class="fragment"><pre class="fragment">  vector&lt;int&gt; vector1(vector0);
  assert(vector1.size() == 5);
  assert(vector1.size() == vector0.size());
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != vector1.size(); ++i) {
      assert(vector1[i] == i);
      assert(vector1[i] == vector0[i]);
  }
</pre></div><br/>
<br/>
 When using moving this <code>vector0</code> to a new location the representation of the new object should use the original <code>begin()</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">int</span> *first = vector0.begin();
  vector&lt;int&gt; vector2(<a class="code" href="structbslmf_1_1MovableRefUtil.html#a81937fc82df2e42449aa541ec1954bb7">bslmf::MovableRefUtil::move</a>(vector0));
  assert(first == vector2.begin());
</pre></div><br/>
<br/>
 When create a <code>vector&lt;vector&lt;int&gt; &gt;</code> and using <code>push_back()</code> on this object with <code>vector2</code> a copy should be inserted: <br/>
<br/>
<div class="fragment"><pre class="fragment">  vector&lt;vector&lt;int&gt; &gt; vvector;
  vvector.push_back(vector2);                          <span class="comment">// copy</span>
  assert(vector2.size() == 5);
  assert(vvector.size() == 1);
  assert(vvector[0].size() == vector2.size());
  assert(vvector[0].begin() != first);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 5; ++i) {
      assert(vvector[0][i] == i);
      assert(vector2[i] == i);
  }
</pre></div><br/>
<br/>
 When adding another element by moving <code>vector2</code> the <code>begin()</code> of the newly inserted element will be the same as <code>first</code>, i.e., the representation is transferred: <br/>
<br/>
<div class="fragment"><pre class="fragment">  vvector.push_back(<a class="code" href="structbslmf_1_1MovableRefUtil.html#a81937fc82df2e42449aa541ec1954bb7">bslmf::MovableRefUtil::move</a>(vector2)); <span class="comment">// move</span>
  assert(vvector.size() == 2);
  assert(vvector[1].begin() == first);
  assert(vvector[1].size() == 5);
</pre></div><br/>
<br/>
 Compiling this code with both C++03 and C++11 compilers shows that there is no need for conditional compilation in when using <code>MovableRef&lt;TYPE&gt;</code> while move semantics is enabled in both modes. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:21 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
