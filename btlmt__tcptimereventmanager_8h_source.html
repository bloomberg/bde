<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlmt_tcptimereventmanager.h                                       -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLMT_TCPTIMEREVENTMANAGER
#define INCLUDED_BTLMT_TCPTIMEREVENTMANAGER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a thread-enabled multiplexor of socket events and timers.
//
//@CLASSES:
//  btlmt::TcpTimerEventManager: thread-enabled socket event/timer multiplexor
//
//@SEE_ALSO: btlmt_channelpool bdlmt_threadpool bslmt_threadutil
//
//@DESCRIPTION: This component provides a concrete implementation of a
// thread-enabled multiplexer for socket events and timers.  An interested
// party can register a callback to be invoked whenever a particular event
// occurs on a particular socket, or when a timer expires.  Socket events have
// a permanent semantics (i.e., once registered, a callback is invoked until it
// is explicitly deregistered).  Timers have &quot;one-time&quot; semantics (i.e., a
// timer callback is invoked at most once).  Registering the same socket handle
// and the same event with different instances of this event manager may result
// in undefined behavior.  The timers are unstable with respect to
// registration; that is, if two timer callbacks are registered with the same
// time, they maybe invoked in an order different from the order of
// registration.  Socket events take priority over timers; if a socket event
// and a timer occur at the same time, a socket event callback is invoked
// first.
//
// All registered callbacks are invoked from an internal thread managed by
// &#39;this&#39; event manager if its underlying thread is enabled (see below).  If
// the thread is disabled, the queries and registrations are processed (in a
// thread-safe fashion) but no callbacks are invoked.  On UNIX platforms all
// signals are disabled for this thread.
//
// An event manager can optimize its performance based on a hint provided at
// construction.  Generally speaking, a particular usage falls into two
// categories: socket events are registered: 1)frequently, and 2)infrequently.
// On some platforms, a significant performance improvement can be achieved if
// the registrations are infrequent.  For this situation, the appropriate hint
// should be provided to this event manager at construction for optimal
// performance.
//
///Thread Safety
///-------------
// This event manager is *thread* *safe*, i.e., operations can be invoked
// simultaneously on a single instance of this event manager from multiple
// threads without undesirable side-effects.
//
// To the extent that this component uses local synchronization primitives
// internally to protect access to different pieces of private data, and to
// maximize the ability of different threads to operate concurrently on a
// single instance of this component, it is *thread* *enabled*.
//
// This component is not *async-safe*, i.e., one or more methods cannot be
// invoked safely from a signal handler.
//
///Performance
///-----------
// This component minimizes the number of system calls for the set of
// callbacks.  A significant performance improvement can be achieved if an
// appropriate registration frequency &quot;hint&quot; is provided.  Supplying a false
// hint (e.g., indicating infrequent registration when the reverse is true) may
// result in significant performance degradation.
//
// Given that T is the number of timers registered and S is the number of
// socket events registered, the following complexity is guaranteed by this
// component:
//..
//  NOTE: The following table is a place holder and needs to be rethought.
//  +========================================================================+
//  |        FUNCTION          | EXPECTED COMPLEXITY | WORST CASE COMPLEXITY |
//  +------------------------------------------------------------------------+
//  | registerTimer            |      O(log[T])      |      O(log[T])        |
//  +------------------------------------------------------------------------+
//  | deregisterTimer          |        O(T)         |        O(T)           |
//  +------------------------------------------------------------------------+
//  | registerSocketEvent      |        O(1)         |        O(S)           |
//  +------------------------------------------------------------------------+
//  | deregisterSocketEvent    |        O(1)         |        O(S)           |
//  +------------------------------------------------------------------------+
//  | isRegistered             |        O(1)         |        O(S)           |
//  +------------------------------------------------------------------------+
//  | deregisterSocket         |        O(1)         |        O(S)           |
//  +------------------------------------------------------------------------+
//  | deregisterAllSocketEvents|        O(S)         |        O(S)           |
//  +------------------------------------------------------------------------+
//  | deregisterAllTimers      |        O(T)         |        O(T)           |
//  +------------------------------------------------------------------------+
//  | deregisterAll            |       O(S+T)        |       O(S+T)          |
//  +------------------------------------------------------------------------+
//  | numEvents                |        O(1)         |        O(1)           |
//  +------------------------------------------------------------------------+
//  | numTimers                |        O(1)         |        O(1)           |
//  +------------------------------------------------------------------------+
//  | numSocketEvents          |        O(1)         |        O(S)           |
//  +========================================================================+
//..
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Syntax
///- - - - - - - - - - - -
// In the following usage example, we demonstrate how to use timer
// functionality provided by &#39;btlmt::TcpTimerEventManager&#39;.  For simplicity, we
// simulate enqueueing a job to a queue periodically.  Let&#39;s assume that a job
// is represented by an integer.  First, let&#39;s implement a function that
// enqueues a job to a given queue.  This function will also re-register the
// &quot;next&quot; timer with the event manager since timers have &quot;one-time&quot; semantics.
//..
//  static void producer(bdlcc::Queue&lt;int&gt;           *workQueue,
//                       btlmt::TcpTimerEventManager *manager,
//                       bsls::TimeInterval           nextTime)
//      // Enqueue a work item onto the specified &#39;workQueue&#39; and register
//      // this function with the specified &#39;manager&#39; to be invoked after
//      // the specified &#39;nextTime&#39; absolute time interval.
//  {
//      assert(workQueue);
//      assert(manager);
//
//      enum { TIME_OFFSET = 50 };   // invoke timer every 50 milliseconds
//
//      int item = bdlt::CurrentTime::now().nanoseconds() / 1000;
//      workQueue-&gt;pushBack(item);
//
//      bsls::TimeInterval nextNextTime(nextTime);
//      nextNextTime.addMilliseconds(TIME_OFFSET);
//      bsl::function&lt;void()&gt; callback(bdlf::BindUtil::bind(&amp;producer,
//                                                          workQueue,
//                                                          manager,
//                                                          nextNextTime));
//
//      void *timerId = manager-&gt;registerTimer(nextTime, callback);
//      assert(timerId);
//  }
//..
// Second, implement the main function.  In main, create a work queue and
// a timer event manager, register with the event manager an initial timer
// with its callback and begin monitoring the work queue:
//..
//  int main() {
//      enum {
//          TIME_OFFSET         = 50, // milliseconds
//          INITIAL_TIME_OFFSET = 10  // milliseconds
//      };
//
//      bdlcc::Queue&lt;int&gt; workQueue(&amp;testAllocator);;
//      btlmt::TcpTimerEventManager manager(&amp;testAllocator);;
//
//      bsls::TimeInterval now = bdlt::CurrentTime::now();
//      now.addMilliseconds(INITIAL_TIME_OFFSET);
//      bsls::TimeInterval nextTime(now);
//      nextTime.addMilliseconds(TIME_OFFSET);
//
//      bsl::function&lt;void()&gt; callback(bdlf::BindUtil::bind(&amp;producer,
//                                                          &amp;workQueue,
//                                                          &amp;manager,
//                                                          nextNextTime));
//
//      void *timerId = manager.registerTimer(now, callback);
//      assert(timerId);
//      int rc = manager.enable();
//      assert(0 == rc);
//      while(1) {
//          // Monitor &#39;workQueue&#39; here
//          // ...
//      }
//      return 0;
//  }
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLSO_SOCKETHANDLE
#include &lt;btlso_sockethandle.h&gt;
#endif

#ifndef INCLUDED_BTLSO_EVENTTYPE
#include &lt;btlso_eventtype.h&gt;
#endif

#ifndef INCLUDED_BTLSO_IPV4ADDRESS
#include &lt;btlso_ipv4address.h&gt;
#endif

#ifndef INCLUDED_BTLSO_IOUTIL
#include &lt;btlso_ioutil.h&gt;
#endif

#ifndef INCLUDED_BTLSO_SOCKETIMPUTIL
#include &lt;btlso_socketimputil.h&gt;
#endif

#ifndef INCLUDED_BTLSO_SOCKETOPTUTIL
#include &lt;btlso_socketoptutil.h&gt;
#endif

#ifndef INCLUDED_BTLSO_EVENTMANAGER
#include &lt;btlso_eventmanager.h&gt;
#endif

#ifndef INCLUDED_BTLSO_TIMEREVENTMANAGER
#include &lt;btlso_timereventmanager.h&gt;
#endif

#ifndef INCLUDED_BTLSO_TIMEMETRICS
#include &lt;btlso_timemetrics.h&gt;
#endif

#ifndef INCLUDED_BDLCC_QUEUE
#include &lt;bdlcc_queue.h&gt;
#endif

#ifndef INCLUDED_BDLCC_TIMEQUEUE
#include &lt;bdlcc_timequeue.h&gt;
#endif

#ifndef INCLUDED_BDLMA_CONCURRENTPOOL
#include &lt;bdlma_concurrentpool.h&gt;
#endif

#ifndef INCLUDED_BSLMT_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_BSLMT_THREADATTRIBUTES
#include &lt;bslmt_threadattributes.h&gt;
#endif

#ifndef INCLUDED_BSLMT_THREADUTIL
#include &lt;bslmt_threadutil.h&gt;
#endif

#ifndef INCLUDED_BSLMT_RWMUTEX
#include &lt;bslmt_rwmutex.h&gt;
#endif

#ifndef INCLUDED_BSLMT_LOCKGUARD
#include &lt;bslmt_lockguard.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BDLT_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTR
#include &lt;bslma_managedptr.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {

namespace btlmt {

class TcpTimerEventManager_Request;

              // =========================================
              // class TcpTimerEventManager_ControlChannel
              // =========================================

class TcpTimerEventManager_ControlChannel {
    // This class is an implementation detail of &#39;TcpTimerEventManager&#39;.
    // Do not use.

    // DATA
#if defined(BTLSO_PLATFORM_WIN_SOCKETS) &amp;&amp; defined(BSLS_PLATFORM_CPU_64_BIT)
    bsls::AtomicInt64 d_fds[2];              // connected socket pair
#else
    bsls::AtomicInt   d_fds[2];              // connected socket pair
#endif

    const char        d_byte;                // signal byte

    int               d_numServerReads;      // read operations
    int               d_numServerBytesRead;  // total number of bytes read
    bsls::AtomicInt   d_numPendingRequests;  // number of pending requests

    // NOT IMPLEMENTED
    TcpTimerEventManager_ControlChannel(
                                   const TcpTimerEventManager_ControlChannel&amp;);
    TcpTimerEventManager_ControlChannel&amp; operator=(
                                   const TcpTimerEventManager_ControlChannel&amp;);

  public:
    // CREATORS
    TcpTimerEventManager_ControlChannel();
        // Create an instance of this component by instantiating a connected
        // pair of sockets.

    ~TcpTimerEventManager_ControlChannel();
        // Close the internal sockets and destroy this object.

    // MANIPULATORS
    int clientWrite(bool forceWrite = false);
        // Write the control byte into the client handle.  If the specified
        // &#39;forceWrite&#39; is &#39;true&#39; write to the client handle even if a previous
        // write is outstanding.  By default, &#39;forceWrite&#39; is &#39;false&#39; and the
        // control byte is not written to the client handle if a previous write
        // is outstanding.  Return the number of bytes written on success, and
        // a negative value otherwise.  Note that &#39;forceWrite&#39; can be used when
        // a write might be lost because the control channel had closed and
        // ensures that the control byte is unconditionally written to the
        // client handle.

    int close();
        // Shutdown this control channel and close the connection between the
        // &#39;serverFd&#39; and &#39;clientFd&#39; managed by this object.  Return 0 on
        // success and a non-zero value otherwise.

    int open();
        // Open this control channel and establish a connection between the
        // &#39;serverFd&#39; and &#39;clientFd&#39; managed by this object.  Return 0 on
        // success and a non-zero value otherwise.

    int serverRead();
        // Read as many bytes as possible from the server buffer without
        // blocking.  Return the number of bytes read on success, and a
        // negative value otherwise.

    // ACCESSORS
    btlso::SocketHandle::Handle clientFd();
        // Return a handle to the client socket.

    btlso::SocketHandle::Handle serverFd();
        // Return a handle to the server socket.
};

                       // ==========================
                       // class TcpTimerEventManager
                       // ==========================

class TcpTimerEventManager : public btlso::TimerEventManager {
    // This class provides a thread-enabled implementation of an event manager
    // for socket events and timers.  The supported event types for sockets are
    // ACCEPT, CONNECT, READ, and WRITE; only READ and WRITE can be registered
    // simultaneously for a single socket.  Timers are stable (i.e., the
    // relative order of registrations is maintained).  Callbacks are invoked
    // from dedicated threads, created internally for this purpose by this
    // component.

    // PRIVATE TYPES
    enum State {
        e_ENABLED  = 0,  // dispatching thread is running
        e_DISABLED = 1   // dispatching thread is not running
    };

    typedef TcpTimerEventManager_ControlChannel ControlChannel;
        // Channel for sending messages from external threads operating on this
        // component and its internal dispatch thread.

    // DATA
    mutable bdlma::ConcurrentPool  d_requestPool;     // memory pool for
                                                      // operations

    mutable bdlcc::Queue&lt;TcpTimerEventManager_Request*&gt;
                                   d_requestQueue;    // queue of requests to
                                                      // dispatcher thread

    mutable bslmt::ThreadUtil::Handle
                                   d_dispatcher;      // dispatcher thread
                                                      // handle

    volatile State                 d_state;           // the state of the
                                                      // dispatcher thread

    bsls::AtomicInt                d_terminateThread; // signals end of
                                                      // dispatcher

    mutable bslmt::RWMutex         d_stateLock;       // protects access to the
                                                      // state changes via
                                                      // &#39;enable&#39; and &#39;disable&#39;

    bsl::function&lt;void()&gt;          d_dispatchThreadEntryPoint;
                                                      // functor containing the
                                                      // dispatch thread&#39;s
                                                      // entry point

    btlso::EventManager           *d_manager_p;       // socket event manager

    int                            d_isManagedFlag;   // whether or not event
                                                      // manager is internal or
                                                      // external

    bsl::vector&lt;bsl::function&lt;void()&gt; &gt;
                                  *d_executeQueue_p;  // queue of executed
                                                      // timers (pointer, to
                                                      // be swappable in
                                                      // dispatcher thread
                                                      // loop)

    mutable bslmt::Mutex           d_executeQueueLock;
                                                      // protects access to the
                                                      // execute queue

    bdlcc::TimeQueue&lt;bsl::function&lt;void()&gt; &gt;
                                   d_timerQueue;      // queue of registered
                                                      // timers

    mutable bslma::ManagedPtr&lt;ControlChannel&gt;
                                   d_controlChannel_p;// channel for sending
                                                      // control bytes from
                                                      // external threads
                                                      // operating on this
                                                      // manager to unlock its
                                                      // internal &#39;dispatch&#39;
                                                      // thread after they
                                                      // post a message for
                                                      // the &#39;dispatch&#39; thread
                                                      // to process

    mutable btlso::TimeMetrics     d_metrics;         // cached metrics

    const bool                     d_collectMetrics;  // whether to update
                                                      // &#39;d_metrics&#39;

    bsls::AtomicInt                d_numTotalSocketEvents;
                                                      // the total number of
                                                      // all socket events
                                                      // registered (excluding
                                                      // registered events of
                                                      // &#39;d_controlChannel_p&#39;)

    bsls::AtomicInt                d_numControlChannelReinitializations;
                                                      // number of times the
                                                      // control channel was
                                                      // reinitialized

    bslma::Allocator              *d_allocator_p;     // memory allocator
                                                      // (held, not owned)

    // FRIENDS
    friend struct TcpTimerEventManager_TestUtil;

    // NOT IMPLEMENTED
    TcpTimerEventManager(const TcpTimerEventManager&amp;);
    TcpTimerEventManager&amp; operator=(const TcpTimerEventManager&amp;);

    // PRIVATE MANIPULATORS
    void initialize();
        // Initialize this event manager.

    void dispatchThreadEntryPoint();
        // Entry point for the dispatch thread.

    void controlCb();
        // Internal callback method to process control information received on
        // &#39;d_controlChannel_p.serverFd()&#39;.

    int initiateControlChannelRead();
        // Initiate a request to the internal control channel&#39;s &#39;serverFd&#39; to
        // make it operational and to start waiting for subsequent writes.
        // Return 0 on success and a non-zero value otherwise.

    int reinitializeControlChannel();
        // Reinitialize this event manager&#39;s internal control channel.  Return
        // 0 on success and a non-zero value otherwise.

  public:
    // CREATORS
    explicit TcpTimerEventManager(bslma::Allocator *basicAllocator = 0);
    explicit TcpTimerEventManager(bool              collectTimeMetrics,
                                  bslma::Allocator *basicAllocator = 0);
    TcpTimerEventManager(bool              collectTimeMetrics,
                         bool              poolTimerMemory,
                         bslma::Allocator *basicAllocator = 0);
        // Create an event manager.  Optionally specify &#39;collectTimeMetrics&#39;
        // indicating whether this event manager should collect timing metrics.
        // If &#39;collectTimeMetrics&#39; is unspecified or &#39;true&#39; then the event
        // manager will provide a categorization of the time it spends
        // processing data via &#39;timeMetrics()&#39;, and if &#39;collectTimeMetrics&#39; is
        // &#39;false&#39; the value of &#39;timeMetrics()&#39; is unspecified.  Optionally
        // specify &#39;poolTimerMemory&#39; indicating whether the memory used for
        // internal timers should be pooled.  If &#39;poolTimerMemory&#39; is
        // unspecified then the memory used for allocating timers will not be
        // pooled.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.  The behavior is undefined unless
        // &#39;basicAllocator&#39; refers to a *thread* *safe* allocator.  Note that
        // the dispatcher thread is NOT started by this method (i.e., it must
        // be started explicitly).

    TcpTimerEventManager(btlso::EventManager *rawEventManager,
                         bslma::Allocator    *basicAllocator = 0);
        // Create an event manager with timer support that uses the specified
        // &#39;rawEventManager&#39; to monitor for socket events.  Optionally specify
        // a &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  &#39;basicAllocator&#39;
        // must refer to a *thread* *safe* allocator, and the behavior is
        // undefined, otherwise.  The value of the event manager&#39;s
        // &#39;timeMetrics()&#39; object will be unspecified, clients interested in
        // those metrics must use the &#39;btlso::TimeMetrics&#39; object provided to
        // &#39;rawEventManager&#39; on its construction.  Note that the dispatcher
        // thread is NOT started by this method (and, therefore, must be
        // started explicitly).

    virtual ~TcpTimerEventManager();
        // Terminate the dispatcher thread, if it is running, and destroy this
        // event manager without invoking any registered callback.

    // MANIPULATORS
    virtual void deregisterAllSocketEvents();
        // Deregister all callbacks associated with any event on any socket
        // handle so that no callbacks are not invoked when any event occurs on
        // any handle.

    virtual void deregisterAllTimers();
        // Remove all timer callbacks currently registered.  The number of
        // timers (as reported by &#39;numTimers&#39;) method is 0 after this method is
        // completed.

    virtual void deregisterAll();
        // Deregister all callbacks currently registered.  Note that the
        // behavior is equivalent to the sequence:
        //..
        //  deregisterAllTimers();
        //  deregisterAllSocketEvents();
        //..

    virtual void deregisterSocketEvent(
                                     const btlso::SocketHandle::Handle&amp; handle,
                                     btlso::EventType::Type             event);
        // Deregister the callback associated with the specified &#39;event&#39; on the
        // specified &#39;handle&#39; so that said callback will not be invoked if the
        // &#39;event&#39; occurs.

    virtual void deregisterSocket(const btlso::SocketHandle::Handle&amp; handle);
        // Deregister all callbacks associated with any event on the specified
        // &#39;handle&#39; such that no callback will be invoked if an event occurs on
        // the &#39;handle&#39;.

    virtual void deregisterTimer(const void *timerId);
        // Deregister the callback associated with the specified &#39;timerId&#39;
        // (returned when the timer callback was registered) so that the
        // callback will not be invoked at the appointed time.

    int disable();
        // Destroy the internal thread responsible for monitoring sockets and
        // dispatching timer and socket callbacks.  Return 0 on success and a
        // non-zero value otherwise.  If this event manager is not already
        // enabled, as reported by &#39;isEnabled&#39; method, this method returns
        // immediately with 0.  Otherwise, it will block until the internal
        // thread exits.  Note that &#39;disable&#39; will always fail if invoked,
        // through a callback, in the internal thread.

    int enable();
    int enable(const bslmt::ThreadAttributes&amp; attribute);
        // Create the internal thread responsible for monitoring sockets and
        // dispatching timer and socket callbacks, optionally setting the
        // &#39;attribute&#39; of the new thread to the specified &#39;attribute&#39;.  Return
        // 0 on success and a non-zero value otherwise.  If this event manager
        // is already enabled, as reported by &#39;isEnabled&#39; method, this method
        // returns immediately with 0.  Otherwise, it will block until the
        // internal thread is started or failure occurs.

    void execute(const bsl::function&lt;void()&gt;&amp; functor);
        // Execute the specified &#39;functor&#39; in the internal thread, if it is
        // started.

    void clearExecuteQueue();
        // Clear the functors enqueued to the execute queue.

    virtual int registerSocketEvent(
                                   const btlso::SocketHandle::Handle&amp;   handle,
                                   btlso::EventType::Type               event,
                                   const btlso::EventManager::Callback&amp; cb);
        // Register the specified &#39;cb&#39; functor to be invoked whenever the
        // specified &#39;event&#39; occurs on the socket specified by &#39;handle&#39;.
        // Return 0 on success and a negative number on error.  No two
        // different socket events can have callbacks registered with the same
        // socket handle other than read and write.  Any invocation of this
        // method that would cause this to occur will result in an error and
        // the callback will not be registered.  The callback is recurring
        // (i.e., it remains registered until it is explicitly deregistered).
        // Note that the callback will be invoked only from the internal thread
        // and that the callback may be invoked before this method returns.

    virtual void *registerTimer(const bsls::TimeInterval&amp;            timeout,
                                const btlso::EventManager::Callback&amp; cb);
        // Register the specified &#39;cb&#39; functor to be invoked when the absolute
        // time of the specified &#39;timeout&#39; is reached or exceeded.  Return a
        // &#39;void*&#39; registration id which can be used to deregister this timer
        // before expiration.  Specifying a &#39;timeout&#39; previous to the current
        // time will result in the associated &#39;cb&#39; being executed almost
        // immediately.  Note also that the callback is not recurring (i.e.,
        // after being invoked it is deregistered automatically).  Note that
        // the callback will be invoked only from the internal thread and that
        // the callback may be invoked before this method returns.

    int rescheduleTimer(const void                *timerId,
                        const bsls::TimeInterval&amp;  timeout);
        // Reschedule the timer indicated by the specified &#39;timerId&#39; such that
        // the callback function supplied to &#39;registerTimer&#39; will be invoked
        // after the specified &#39;expiryTime&#39; is reached.  Return 0 on success,
        // and a negative value otherwise.  &#39;expiryTime&#39; is expressed as the
        // absolute time from 00:00:00 UTC, January 1, 1970 (the epoch time
        // defined by &#39;bdetu_epoch&#39;).  The behavior is undefined unless
        // &#39;timerId&#39; is a timer id returned from &#39;registerTimer&#39;, and has not
        // subsequently been deregistered.  Note that if &#39;expiryTime&#39; is
        // earlier than the current time (&#39;bdlt::CurrentTime::now()&#39;) the
        // associated callback will be invoked the first time that the
        // callbacks are dispatched.

    // ACCESSORS
    virtual bool hasLimitedSocketCapacity() const;
        // Return &#39;true&#39; if this event manager has a limited socket capacity,
        // and &#39;false&#39; otherwise.

    virtual int isRegistered(const btlso::SocketHandle::Handle&amp; handle,
                             btlso::EventType::Type             event) const;
        // Return 1 if a callback is registered to be invoked when a socket
        // event of the specified &#39;event&#39; occurs on the specified socket
        // &#39;handle&#39;, and 0 otherwise.

    virtual int numEvents() const;
        // Return the total number of callbacks registered with this event
        // manager for either timers or sockets.

    virtual int numTimers() const;
        // Return the number of timers that are currently registered.

    virtual int numSocketEvents(
                              const btlso::SocketHandle::Handle&amp; handle) const;
        // Return the number of callbacks registered for the specified socket
        // &#39;handle&#39;.

    int numTotalSocketEvents() const;
        // Return the number of socket callbacks registered with this event
        // manager.

    btlso::TimeMetrics *timeMetrics() const;
        // Return the address of the modifiable time metrics object that
        // provides a breakdown of the time this event manager has spent
        // processing data.  Note that the metrics managed by the returned
        // object have unspecified values unless &#39;hasTimeMetrics&#39; returns
        // &#39;true&#39;.

    bslmt::ThreadUtil::Handle dispatcherThreadHandle() const;
        // Return the thread handle of the dispatcher thread of this object.

    int isEnabled() const;
        // Return 1 if the dispatch thread is created/running and 0 otherwise.

    bool hasTimeMetrics() const;
        // Return &#39;true&#39; if the object returned by &#39;timeMetrics()&#39; contains a
        // valid value, and &#39;false&#39; otherwise.  This value will be &#39;false&#39; if
        // either the (optional) &#39;collectTimeMetrics&#39; value supplied at
        // construction was &#39;false&#39;, or if a &#39;rawEventManager&#39; was provided at
        // construction.  Note that if the value is &#39;false&#39;, the value of the
        // object returned by &#39;timeMetrics()&#39; is not specified.
};

                       // ===================================
                       // class TcpTimerEventManager_TestUtil
                       // ===================================

struct TcpTimerEventManager_TestUtil {
    // This &#39;struct&#39; provides access to the internal control channel of a
    // &#39;TcpTimerEventManager&#39; object and is used for testing only.  This
    // &#39;struct&#39; should *NOT* be used directly to gain access to the control
    // channel.

    static const TcpTimerEventManager_ControlChannel *getControlChannel(
                                          const TcpTimerEventManager&amp; manager);
        // Return a pointer providing non-modifiable access to the control
        // channel object held by the specified &#39;manager&#39; or 0 if the control
        // channel has not been initialized.
};

//-----------------------------------------------------------------------------
//                      INLINE FUNCTIONS DEFINITIONS
//-----------------------------------------------------------------------------

               // -----------------------------------------
               // class TcpTimerEventManager_ControlChannel
               // -----------------------------------------

// MANIPULATORS
inline
btlso::SocketHandle::Handle TcpTimerEventManager_ControlChannel::clientFd()
{
    return static_cast&lt;btlso::SocketHandle::Handle&gt;(d_fds[0].loadRelaxed());
}

inline
btlso::SocketHandle::Handle TcpTimerEventManager_ControlChannel::serverFd()
{
    return static_cast&lt;btlso::SocketHandle::Handle&gt;(d_fds[1].loadRelaxed());
}

                        // --------------------------
                        // class TcpTimerEventManager
                        // --------------------------

// MANIPULATORS
inline
int TcpTimerEventManager::enable()
{
    return enable(bslmt::ThreadAttributes());
}

// ACCESSORS
inline
bool TcpTimerEventManager::hasLimitedSocketCapacity() const
{
    return d_manager_p-&gt;hasLimitedSocketCapacity();
}

inline
btlso::TimeMetrics *TcpTimerEventManager::timeMetrics() const
{
    return &amp;d_metrics;
}

inline
bslmt::ThreadUtil::Handle TcpTimerEventManager::dispatcherThreadHandle() const
{
    return d_dispatcher;
}

inline
bool TcpTimerEventManager::hasTimeMetrics() const
{
    return d_collectMetrics;
}

                        // -----------------------------------
                        // class TcpTimerEventManager_TestUtil
                        // -----------------------------------

inline
const TcpTimerEventManager_ControlChannel *
TcpTimerEventManager_TestUtil::getControlChannel(
                                           const TcpTimerEventManager&amp; manager)
{
    return manager.d_controlChannel_p.ptr();
}

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
