<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlc_bitarray.h                                                    -*-C++-*-
#ifndef INCLUDED_BDLC_BITARRAY
#define INCLUDED_BDLC_BITARRAY

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a space-efficient, sequential container of boolean values.
//
//@CLASSES:
//   bdlc::BitArray: vector-like, sequential container of boolean values
//
//@DESCRIPTION: This component implements an efficient value-semantic,
// sequential container of boolean values (i.e., 0 or 1) of type &#39;bool&#39;.  A
// &#39;BitArray&#39; may be thought of as an arbitrary-precision &#39;unsigned int&#39;.  This
// metaphor is used to motivate the rich set of &quot;bitwise&quot; operations on
// &#39;BitArray&#39; objects provided by this component, as well as the notion of
// &quot;zero extension&quot; of a (shorter) bit array during binary operations on bit
// arrays having lengths that are not the same.
//
///Bit-Array-Specific Functionality
///--------------------------------
// In addition to many typical vector-like container methods, this component
// supports &quot;boolean&quot; functionality unique to &#39;BitArray&#39;.  However, unlike
// other standard container types such as &#39;bsl::bitset&#39;, there is no
// &#39;operator[](bsl::size_t index)&#39; that returns a reference to a (modifiable)
// boolean element at the specified index position.  This difference is due to
// the densely-packed internal representation of bits within bit arrays:
//..
//  bdlc::BitArray mA(128);
//  assert(0 == mA[13]);             // Ok
//  mA[13] = &#39;false&#39;;                // Error -- &#39;mA[13]&#39; is not an lvalue.
//  mA.assign(13, 1);                // Ok
//
//  const bdlc::BitArray&amp; A = mA;    // Ok
//  assert(1 == A[13]);              // Ok
//  const bool *bp  = &amp;A[13]         // Error -- &#39;A[13]&#39; is not an lvalue.
//  const bool  bit = A[13];         // Ok
//..
// Also note that there is no &#39;data&#39; method returning a contiguous sequence of
// &#39;bool&#39;.
//
// Finally note that, wherever an argument of non-boolean type -- e.g., the
// literal &#39;5&#39; (of type &#39;int&#39;) -- is used in a &#39;BitArray&#39; method to specify a
// boolean (bit) value, every non-zero value is automatically converted (via a
// standard conversion) to a &#39;bool&#39; value &#39;true&#39;, before the method of the
// &#39;BitArray&#39; is invoked:
//..
//  bdlc::BitArray a(10);
//  assert(0 == a[5]);
//  a.assign(5, 24);            // Ok -- non-boolean value converted to &#39;true&#39;.
//  assert(1 == a[5]);
//..
//
///Performance and Exception-Safety Guarantees
///-------------------------------------------
// The asymptotic worst-case performance of representative operations is
// characterized using big-O notation, &#39;O[f(N,M)]&#39;, where &#39;N&#39; and &#39;M&#39; refer to
// the number of respective bits (i.e., &#39;length&#39;) of arrays &#39;X&#39; and &#39;Y&#39;,
// respectively.  Here, *Amortized* *Case* complexity, denoted by &#39;A[f(N)]&#39;, is
// defined as the average of &#39;N&#39; successive invocations, as &#39;N&#39; gets very
// large.
//..
//                                        Average   Exception-Safety
//  Operation                Worst Case    Case        Guarantee
//  ---------                ----------   -------   ----------------
//  DEFAULT CTOR             O[1]                   No-Throw
//  COPY CTOR(Y)             O[M]                   Exception Safe
//
//  X.DTOR()                 O[1]                   No-Throw
//
//  X.OP=(Y)                 O[M]                   Basic &lt;*&gt;
//  X.insert(index, value)   O[N]                   Basic &lt;*&gt;
//
//  X.reserveCapacity(M)     O[N]                   Strong &lt;*&gt;
//  X.append(value)          O[N]         A[1]      Strong &lt;*&gt;
//
//  X.assign(index, value)   O[1]                   No-Throw
//  X.assign1(value)         O[1]                   No-Throw
//  X.assign0(value)         O[1]                   No-Throw
//
//  X.remove(index)          O[N]                   No-Throw
//  X.assignAll0()           O[N]                   No-Throw
//  X.assignAll1()           O[N]                   No-Throw
//
//  X.length()               O[1]                   No-Throw
//  X.OP[](index)            O[1]                   No-Throw
//
//  X.isAny1                 O[N]                   No-Throw
//  X.isAny0                 O[N]                   No-Throw
//
//  other &#39;const&#39; methods    O[1] .. O[N]           No-Throw
//
//  OP==(X, Y)               O[min(N, M)]           No-Throw
//  OP!=(X, Y)               O[min(N, M)]           No-Throw
//
//                &lt;*&gt; No-Throw guarantee when capacity is sufficient.
//..
// Note that *all* of the non-creator methods of &#39;BitArray&#39; provide the
// *No-Throw* guarantee whenever sufficient capacity is already available.
//
///Usage
///-----
// This section illustrates the intended use of this component.
//
///Example 1: Creating a &#39;NullableVector&#39; Class
/// - - - - - - - - - - - - - - - - - - - - - -
// An efficient implementation of an arbitrary precision bit sequence container
// has myriad applications.  For example, a &#39;bdlc::BitArray&#39; can be used
// effectively as a parallel array of flags indicating some special property,
// such as &#39;isNull&#39;, &#39;isBusinessDay&#39;, etc.; its use is especially indicated
// when (1) the number of elements of the primary array can grow large, and (2)
// the individual elements do not have the capacity or capability to store the
// information directly.
//
// As a simple example, we&#39;ll implement a (heavily elided) value-semantic
// template class, &#39;NullableVector&lt;TYPE&gt;&#39;, that behaves like a
// &#39;bsl::vector&lt;TYPE&gt;&#39; but additionally allows storing a nullness flag to
// signify that the corresponding element was not specified.  Elements added to
// a &#39;NullableVector&#39; are null by default, although there are manipulator
// functions that allow appending a non-null element.  Each null element
// stores the default value for &#39;TYPE&#39;.
//
// Note that this class has a minimal interface (suitable for illustration
// purpose only) that allows users to either append a (non-null) &#39;TYPE&#39; value
// or a null value.  A real &#39;NullableVector&#39; class would support a complete set
// of *value* *semantic* operations, including copy construction, assignment,
// equality comparison, &#39;ostream&#39; printing, and BDEX serialization.  Also note
// that, for simplicity, exception-neutrality is ignored (some methods are
// clearly not exception-neutral).
//
// First, we define the interface of &#39;NullableVector&#39;:
//..
//  template &lt;class TYPE&gt;
//  class NullableVector {
//      // This class implements a sequential container of elements of the
//      // template parameter &#39;TYPE&#39;.
//
//      // DATA
//      bsl::vector&lt;TYPE&gt;  d_values;       // data elements
//      bdlc::BitArray     d_nullFlags;    // &#39;true&#39; indicates i&#39;th element is
//                                         // null
//
//    private:
//      // NOT IMPLEMENTED
//      NullableVector(const NullableVector&amp;);
//      NullableVector&amp; operator=(const NullableVector&amp;);
//
//    public:
//      // TRAITS
//      BSLMF_NESTED_TRAIT_DECLARATION(NullableVector,
//                                     bslma::UsesBslmaAllocator);
//
//    public:
//      // CREATORS
//      explicit
//      NullableVector(bsl::size_t       initialLength,
//                     bslma::Allocator *basicAllocator = 0);
//          // Construct a vector having the specified &#39;initialLength&#39; null
//          // elements.  Optionally specify a &#39;basicAllocator&#39; used to supply
//          // memory.  If &#39;basicAllocator&#39; is 0, the currently supplied
//          // default allocator is used.
//
//      // ...
//
//      ~NullableVector();
//          // Destroy this vector.
//
//      // MANIPULATORS
//      void appendNullElement();
//          // Append a null element to this vector.  Note that the appended
//          // element will have the same value as a default constructed &#39;TYPE&#39;
//          // object.
//
//      void appendElement(const TYPE&amp; value);
//          // Append an element having the specified &#39;value&#39; to the end of
//          // this vector.
//
//      void makeNonNull(bsl::size_t index);
//          // Make the element at the specified &#39;index&#39; in this vector
//          // non-null.  The behavior is undefined unless &#39;index &lt; length()&#39;.
//
//      void makeNull(bsl::size_t index);
//          // Make the element at the specified &#39;index&#39; in this vector null.
//          // The behavior is undefined unless &#39;index &lt; length()&#39;.  Note that
//          // the new value of the element will be the default constructed
//          // value for &#39;TYPE&#39;.
//
//      TYPE&amp; modifiableElement(bsl::size_t index);
//          // Return a reference providing modifiable access to the (valid)
//          // element at the specified &#39;index&#39; in this vector.  The behavior
//          // is undefined unless &#39;index &lt; length()&#39;.  Note that if the
//          // element at &#39;index&#39; is null then the nullness flag is reset and
//          // the returned value is the default constructed value for &#39;TYPE&#39;.
//
//      void removeElement(bsl::size_t index);
//          // Remove the element at the specified &#39;index&#39; in this vector.  The
//          // behavior is undefined unless &#39;index &lt; length()&#39;.
//
//      // ACCESSORS
//      const TYPE&amp; constElement(bsl::size_t index) const;
//          // Return a reference providing non-modifiable access to the
//          // element at the specified &#39;index&#39; in this vector.  The behavior
//          // is undefined unless &#39;index &lt; length()&#39;.  Note that if the
//          // element at &#39;index&#39; is null then the nullness flag is not reset
//          // and the returned value is the default constructed value for
//          // &#39;TYPE&#39;.
//
//      bool isAnyElementNonNull() const;
//          // Return &#39;true&#39; if any element in this vector is non-null, and
//          // &#39;false&#39; otherwise.
//
//      bool isAnyElementNull() const;
//          // Return &#39;true&#39; if any element in this vector is null, and &#39;false&#39;
//          // otherwise.
//
//      bool isElementNull(bsl::size_t index) const;
//          // Return &#39;true&#39; if the element at the specified &#39;index&#39; in this
//          // vector is null, and &#39;false&#39; otherwise.  The behavior is
//          // undefined unless &#39;index &lt; length()&#39;.
//
//      bsl::size_t length() const;
//          // Return the number of elements in this vector.
//
//      bsl::size_t numNullElements() const;
//          // Return the number of null elements in this vector.
//  };
//..
// Then, we implement, in turn, each of the methods declared above:
//..
//                   // --------------------
//                   // class NullableVector
//                   // --------------------
//
//  // CREATORS
//  template &lt;class TYPE&gt;
//  NullableVector&lt;TYPE&gt;::NullableVector(bsl::size_t       initialLength,
//                                       bslma::Allocator *basicAllocator)
//  : d_values(initialLength, TYPE(), basicAllocator)
//  , d_nullFlags(initialLength, true, basicAllocator)
//  {
//  }
//
//  template &lt;class TYPE&gt;
//  NullableVector&lt;TYPE&gt;::~NullableVector()
//  {
//      BSLS_ASSERT(d_values.size() == d_nullFlags.length());
//  }
//
//  // MANIPULATORS
//  template &lt;class TYPE&gt;
//  inline
//  void NullableVector&lt;TYPE&gt;::appendElement(const TYPE&amp; value)
//  {
//      d_values.push_back(value);
//      d_nullFlags.append(false);
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  void NullableVector&lt;TYPE&gt;::appendNullElement()
//  {
//      d_values.push_back(TYPE());
//      d_nullFlags.append(true);
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  void NullableVector&lt;TYPE&gt;::makeNonNull(bsl::size_t index)
//  {
//      BSLS_ASSERT_SAFE(index &lt; length());
//
//      d_nullFlags.assign(index, false);
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  void NullableVector&lt;TYPE&gt;::makeNull(bsl::size_t index)
//  {
//      BSLS_ASSERT_SAFE(index &lt; length());
//
//      d_values[index] = TYPE();
//      d_nullFlags.assign(index, true);
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  TYPE&amp; NullableVector&lt;TYPE&gt;::modifiableElement(bsl::size_t index)
//  {
//      BSLS_ASSERT_SAFE(index &lt; length());
//
//      d_nullFlags.assign(index, false);
//      return d_values[index];
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  void NullableVector&lt;TYPE&gt;::removeElement(bsl::size_t index)
//  {
//      BSLS_ASSERT_SAFE(index &lt; length());
//
//      d_values.erase(d_values.begin() + index);
//      d_nullFlags.remove(index);
//  }
//
//  // ACCESSORS
//  template &lt;class TYPE&gt;
//  inline
//  const TYPE&amp; NullableVector&lt;TYPE&gt;::constElement(bsl::size_t index) const
//  {
//      BSLS_ASSERT_SAFE(index &lt; length());
//
//      return d_values[index];
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  bool NullableVector&lt;TYPE&gt;::isAnyElementNonNull() const
//  {
//      return d_nullFlags.isAny0();
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  bool NullableVector&lt;TYPE&gt;::isAnyElementNull() const
//  {
//      return d_nullFlags.isAny1();
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  bool NullableVector&lt;TYPE&gt;::isElementNull(bsl::size_t index) const
//  {
//      BSLS_ASSERT_SAFE(index &lt; length());
//
//      return d_nullFlags[index];
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  bsl::size_t NullableVector&lt;TYPE&gt;::length() const
//  {
//      return d_values.size();
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  bsl::size_t NullableVector&lt;TYPE&gt;::numNullElements() const
//  {
//      return d_nullFlags.num1();
//  }
//..
// Next, we create an empty &#39;NullableVector&#39;:
//..
//  NullableVector&lt;int&gt;        array(0);
//  const NullableVector&lt;int&gt;&amp; ARRAY       = array;
//  const int                  DEFAULT_INT = 0;
//
//  assert(0       == ARRAY.length());
//  assert(0       == ARRAY.numNullElements());
//  assert(false   == ARRAY.isAnyElementNonNull());
//  assert(false   == ARRAY.isAnyElementNull());
//..
// Then, we append a non-null element to it:
//..
//  array.appendElement(5);
//  assert(1       == ARRAY.length());
//  assert(5       == ARRAY.constElement(0));
//  assert(false   == ARRAY.isElementNull(0));
//  assert(0       == ARRAY.numNullElements());
//  assert(true    == ARRAY.isAnyElementNonNull());
//  assert(false   == ARRAY.isAnyElementNull());
//..
// Next, we append a null element:
//..
//  array.appendNullElement();
//  assert(2           == ARRAY.length());
//  assert(5           == ARRAY.constElement(0));
//  assert(DEFAULT_INT == ARRAY.constElement(1));
//  assert(false       == ARRAY.isElementNull(0));
//  assert(true        == ARRAY.isElementNull(1));
//  assert(1           == ARRAY.numNullElements());
//  assert(true        == ARRAY.isAnyElementNonNull());
//  assert(true        == ARRAY.isAnyElementNull());
//..
// Then, we make the null element non-null:
//..
//  array.makeNonNull(1);
//  assert(2           == ARRAY.length());
//  assert(5           == ARRAY.constElement(0));
//  assert(DEFAULT_INT == ARRAY.constElement(1));
//  assert(false       == ARRAY.isElementNull(0));
//  assert(false       == ARRAY.isElementNull(1));
//  assert(0           == ARRAY.numNullElements());
//  assert(true        == ARRAY.isAnyElementNonNull());
//  assert(false       == ARRAY.isAnyElementNull());
//..
// Next, we make the first element null:
//..
//  array.makeNull(0);
//  assert(2           == ARRAY.length());
//  assert(DEFAULT_INT == ARRAY.constElement(0));
//  assert(DEFAULT_INT == ARRAY.constElement(1));
//  assert(true        == ARRAY.isElementNull(0));
//  assert(false       == ARRAY.isElementNull(1));
//  assert(1           == ARRAY.numNullElements());
//  assert(true        == ARRAY.isAnyElementNonNull());
//  assert(true        == ARRAY.isAnyElementNull());
//..
// Now, we remove the front element:
//..
//  array.removeElement(0);
//  assert(1           == ARRAY.length());
//  assert(DEFAULT_INT == ARRAY.constElement(0));
//  assert(false       == ARRAY.isElementNull(0));
//  assert(0           == ARRAY.numNullElements());
//  assert(true        == ARRAY.isAnyElementNonNull());
//  assert(false       == ARRAY.isAnyElementNull());
//..
// Finally, we remove the last remaining element and observe that the object is
// empty again:
//..
//  array.removeElement(0);
//  assert(0       == ARRAY.length());
//  assert(0       == ARRAY.numNullElements());
//  assert(false   == ARRAY.isAnyElementNonNull());
//  assert(false   == ARRAY.isAnyElementNull());
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLB_BITMASKUTIL
#include &lt;bdlb_bitmaskutil.h&gt;
#endif

#ifndef INCLUDED_BDLB_BITSTRINGUTIL
#include &lt;bdlb_bitstringutil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDINT
#include &lt;bsl_cstdint.h&gt;
#endif

#ifndef INCLUDED_BSL_CLIMITS
#include &lt;bsl_climits.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace bdlc {

                                // ==============
                                // class BitArray
                                // ==============

class BitArray {
    // This class implements an efficient, value-semantic array of boolean
    // (a.k.a. bit, i.e., binary digit) values stored in contiguous memory.
    // The physical capacity of this array may grow, but never shrinks.
    // Capacity may be reserved initially via a constructor, or at any time
    // thereafter by using the &#39;reserveCapacity&#39; method; otherwise, capacity
    // will be increased automatically as needed.  Note that capacity is not a
    // *salient* attribute of this object, and, as such, does not contribute to
    // overall value.  Also note that this class provides an implicit no-throw
    // guarantee for all methods (including manipulators) that do not attempt
    // to alter capacity.

  public:
    // PUBLIC TYPES
    enum { k_BITS_PER_UINT64 = 64 };  // bits used to represent a &#39;uint64_t&#39;

    // PUBLIC CLASS CONSTANTS
    static const bsl::size_t k_INVALID_INDEX =
                                          bdlb::BitStringUtil::k_INVALID_INDEX;

  private:
    // DATA
    bsl::vector&lt;bsl::uint64_t&gt; d_array;   // array of 64-bit words
    bsl::size_t                d_length;  // number of significant bits in this
                                          // array

    // CLASS DATA
    static const bsl::uint64_t s_one      =                              1;
    static const bsl::uint64_t s_minusOne = ~static_cast&lt;bsl::uint64_t&gt;(0);

    // FRIENDS
    friend bool operator==(const BitArray&amp;, const BitArray&amp;);

  private:
    // PRIVATE CLASS METHODS
    static bsl::size_t arraySize(bsl::size_t numBits);
        // Return the size, in 64-bit words, of the integer array required to
        // store the specified &#39;numBits&#39;.

    // PRIVATE MANIPULATORS
    bsl::uint64_t *data();
        // Return an address providing modifiable access to the array of
        // &#39;uint64_t&#39; values managed by this array.

    // PRIVATE ACCESSORS
    const bsl::uint64_t *data() const;
        // Return an address providing non-modifiable access to the array of
        // &#39;uint64_t&#39; values managed by this array.

  public:
    // CLASS METHODS

                                // Aspects

    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    // CREATORS
    explicit
    BitArray(bslma::Allocator *basicAllocator = 0);
    explicit
    BitArray(bsl::size_t       initialLength,
             bslma::Allocator *basicAllocator = 0);
    BitArray(bsl::size_t       initialLength,
             bool              value,
             bslma::Allocator *basicAllocator = 0);
        // Create an array of binary digits (bits).  By default, the array is
        // empty and has a capacity of 0 bits.  Optionally specify the
        // &#39;initialLength&#39; (in bits) of the array.  If &#39;initialLength&#39; is not
        // specified, the default length is 0.  If &#39;initialLength&#39; is
        // specified, optionally specify the &#39;value&#39; for each bit in the
        // &#39;initialLength&#39;.  If &#39;value&#39; is not specified, the default value for
        // each bit is &#39;false&#39; (0).  Optionally specify a &#39;basicAllocator&#39; used
        // to supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    BitArray(const BitArray&amp;   original,
             bslma::Allocator *basicAllocator = 0);
        // Create an array of binary digits (bits) having the same value as the
        // specified &#39;original&#39; array.  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.

    ~BitArray();
        // Destroy this object.

    // MANIPULATORS
    BitArray&amp; operator=(const BitArray&amp; rhs);
        // Assign to this array the value of the specified &#39;rhs&#39; array, and
        // return a reference providing modifiable access to this array.

    BitArray&amp; operator&amp;=(const BitArray&amp; rhs);
        // Bitwise AND the value of the specified &#39;rhs&#39; array with the value of
        // this array (retaining the results), and return a reference providing
        // modifiable access to this object.  If &#39;length() &gt; rhs.length()&#39;, the
        // unmatched most-significant bits in this array are set to 0;
        // otherwise, any unmatched most-significant bits in &#39;rhs&#39; are ignored.
        // Note that this behavior is consistent with zero-extending &#39;rhs&#39; if
        // needed, but leaving the length of this array unchanged.

    BitArray&amp; operator-=(const BitArray&amp; rhs);
        // Bitwise MINUS the value of the specified &#39;rhs&#39; array from the value
        // of this array (retaining the results), and return a reference
        // providing modifiable access to this object.  If
        // &#39;length() &gt; rhs.length()&#39;, the unmatched most-significant bits in
        // this array are left unchanged; otherwise, any unmatched
        // most-significant bits in &#39;rhs&#39; are ignored.  Note that this behavior
        // is consistent with zero-extending &#39;rhs&#39; if needed, but leaving the
        // length of this array unchanged.  Also note that the logical
        // difference &#39;A - B&#39; is defined to be &#39;A &amp; !B&#39;.

    BitArray&amp; operator|=(const BitArray&amp; rhs);
        // Bitwise OR the value of the specified &#39;rhs&#39; array with the value of
        // this array (retaining the results), and return a reference providing
        // modifiable access to this object.  If &#39;length() &gt; rhs.length()&#39;, the
        // unmatched most-significant bits in this array are left unchanged;
        // otherwise, any unmatched most-significant bits in &#39;rhs&#39; are ignored.
        // Note that this behavior is consistent with zero-extending &#39;rhs&#39; if
        // needed, but leaving the length of this array unchanged.

    BitArray&amp; operator^=(const BitArray&amp; rhs);
        // Bitwise XOR the value of the specified &#39;rhs&#39; array with the value of
        // this array (retaining the results), and return a reference providing
        // modifiable access to this object.  If &#39;length() &gt; rhs.length()&#39;, the
        // unmatched most-significant bits in this array are left unchanged;
        // otherwise, any unmatched most-significant bits in &#39;rhs&#39; are ignored.
        // Note that this behavior is consistent with zero-extending &#39;rhs&#39; if
        // needed, but leaving the length of this array unchanged.

    BitArray&amp; operator&lt;&lt;=(bsl::size_t numBits);
        // Shift the bits in this array LEFT by the specified &#39;numBits&#39;,
        // filling lower-order bits with zeros (retaining the results), and
        // return a reference providing modifiable access to this object.  The
        // behavior is undefined unless &#39;numBits &lt;= length()&#39;.  Note that the
        // length of this array is unchanged and the highest-order &#39;numBits&#39;
        // are discarded.

    BitArray&amp; operator&gt;&gt;=(bsl::size_t numBits);
        // Shift the bits in this array RIGHT by the specified &#39;numBits&#39;,
        // filling higher-order bits with zeros and discarding low-order bits,
        // and return a reference providing modifiable access to this object.
        // The behavior is undefined unless &#39;numBits &lt;= length()&#39;.  Note that
        // the length of this array is unchanged.

    void andEqual(bsl::size_t index, bool value);
        // AND the bit at the specified &#39;index&#39; in this array with the
        // specified &#39;value&#39; (retaining the result).  The behavior is undefined
        // unless &#39;index &lt; length()&#39;.

    void andEqual(bsl::size_t     dstIndex,
                  const BitArray&amp; srcArray,
                  bsl::size_t     srcIndex,
                  bsl::size_t     numBits);
        // Bitwise AND the specified &#39;numBits&#39; in this array, beginning at the
        // specified &#39;dstIndex&#39;, with values from the specified &#39;srcArray&#39;,
        // beginning at the specified &#39;srcIndex&#39; (retaining the results).  The
        // behavior is undefined unless &#39;dstIndex + numBits &lt;= length()&#39; and
        // &#39;srcIndex + numBits &lt;= srcArray.length()&#39;.

    void append(bool value);
        // Append to this array the specified &#39;value&#39;.  Note that this method
        // has the same behavior as:
        //..
        //  insert(length(), value);
        //..

    void append(bool value, bsl::size_t numBits);
        // Append to this array the specified &#39;numBits&#39; having the specified
        // &#39;value&#39;.  Note that this method has the same behavior as:
        //..
        //  insert(length(), value, numBits);
        //..

    void append(const BitArray&amp; srcArray);
        // Append to this array the values from the specified &#39;srcArray&#39;.  Note
        // that this method has the same behavior as:
        //..
        //  insert(length(), srcArray);
        //..

    void append(const BitArray&amp; srcArray,
                bsl::size_t     srcIndex,
                bsl::size_t     numBits);
        // Append to this array the specified &#39;numBits&#39; from the specified
        // &#39;srcArray&#39;, beginning at the specified &#39;srcIndex&#39;.  The behavior is
        // undefined unless &#39;srcIndex + numBits &lt;= srcArray.length()&#39;.  Note
        // that this method has the same behavior as:
        //..
        //  insert(length(), srcArray, srcIndex, numBits);
        //..

    void assign(bsl::size_t index, bool value);
        // Set the value at the specified &#39;index&#39; in this array to the
        // specified &#39;value&#39;.  The behavior is undefined unless
        // &#39;index &lt; length()&#39;.

    void assign(bsl::size_t index, bool value, bsl::size_t numBits);
        // Set the value of the specified &#39;numBits&#39; bits starting at the
        // specified &#39;index&#39; in this array to the specified &#39;value&#39;.  The
        // behavior is undefined unless &#39;index + numBits &lt; length()&#39;.

    void assign(bsl::size_t     dstIndex,
                const BitArray&amp; srcArray,
                bsl::size_t     srcIndex,
                bsl::size_t     numBits);
        // Replace the specified &#39;numBits&#39; in this array, beginning at the
        // specified &#39;dstIndex&#39;, with values from the specified &#39;srcArray&#39;
        // beginning at the specified &#39;srcIndex&#39;.  The behavior is undefined
        // unless &#39;dstIndex + numBits &lt;= length()&#39; and
        // &#39;srcIndex + numBits &lt;= srcArray.length()&#39;.  Note that, absent
        // aliasing, this method has the same behavior as, but is more
        // efficient than:
        //..
        //  remove(dstIndex, numBits);
        //  insert(dstIndex, srcArray, srcIndex, numBits);
        //..

    void assign0(bsl::size_t index);
        // Set to 0 the value of the bit at the specified &#39;index&#39; in this
        // array.  The behavior is undefined unless &#39;index &lt; length()&#39;.

    void assign0(bsl::size_t index, bsl::size_t numBits);
        // Set to 0 the specified &#39;numBits&#39; values in this array, beginning at
        // the specified &#39;index&#39;.  The behavior is undefined unless
        // &#39;index + numBits &lt;= length()&#39;.

    void assign1(bsl::size_t index);
        // Set to 1 the value of the bit at the specified &#39;index&#39; in this
        // array.  The behavior is undefined unless &#39;index &lt; length()&#39;.

    void assign1(bsl::size_t index, bsl::size_t numBits);
        // Set to 1 the specified &#39;numBits&#39; values in this array, beginning at
        // the specified &#39;index&#39;.  The behavior is undefined unless
        // &#39;index + numBits &lt;= length()&#39;.

    void assignAll(bool value);
        // Set all bits in this array to the specified &#39;value&#39;.

    void assignAll0();
        // Set to 0 the value of every bit in this array.

    void assignAll1();
        // Set to 1 the value of every bit in this array.

    void assignBits(bsl::size_t   index,
                    bsl::uint64_t srcBits,
                    bsl::size_t   numBits);
        // Assign the low-order specified &#39;numBits&#39; from the specified
        // &#39;srcBits&#39; to this object, starting at the specified &#39;index&#39;.  The
        // behavior is undefined unless &#39;numBits &lt;= k_BITS_PER_UINT64&#39; and
        // &#39;index + numBits &lt;= length()&#39;.

    void insert(bsl::size_t dstIndex, bool value);
        // Insert into this array at the specified &#39;dstIndex&#39; the specified
        // &#39;value&#39;.  All values with indices at or above &#39;dstIndex&#39; in this
        // array are shifted up by one bit position.  The behavior is undefined
        // unless &#39;dstIndex &lt;= length()&#39;.

    void insert(bsl::size_t dstIndex, bool value, bsl::size_t numBits);
        // Insert into this array at the specified &#39;dstIndex&#39; the specified
        // &#39;numBits&#39; having the specified &#39;value&#39;.  All values with indices at
        // or above &#39;dstIndex&#39; in this array are shifted up by &#39;numBits&#39; bit
        // positions.  The behavior is undefined unless &#39;dstIndex &lt;= length()&#39;.

    void insert(bsl::size_t dstIndex, const BitArray&amp; srcArray);
        // Insert into this array, beginning at the specified &#39;dstIndex&#39;, the
        // values from the specified &#39;srcArray&#39;.  All values with indices at or
        // above &#39;dstIndex&#39; in this array are shifted up by &#39;srcArray.length()&#39;
        // bit positions.  The behavior is undefined unless
        // &#39;dstIndex &lt;= length()&#39;.

    void insert(bsl::size_t     dstIndex,
                const BitArray&amp; srcArray,
                bsl::size_t     srcIndex,
                bsl::size_t     numBits);
        // Insert into this array, beginning at the specified &#39;dstIndex&#39;, the
        // specified &#39;numBits&#39; from the specified &#39;srcArray&#39; beginning at the
        // specified &#39;srcIndex&#39;.  All values with initial indices at or above
        // &#39;dstIndex&#39; are shifted up by &#39;numBits&#39; positions.  The behavior is
        // undefined unless &#39;dstIndex &lt;= length()&#39; and
        // &#39;srcIndex + numBits &lt;= srcArray.length()&#39;.

    void minusEqual(bsl::size_t index, bool value);
        // MINUS (subtract) from the bit at the specified &#39;index&#39; in this array
        // the specified &#39;value&#39; (retaining the result).  The behavior is
        // undefined unless &#39;index &lt; length()&#39;.  Note that the logical
        // difference &#39;A - B&#39; is defined to be &#39;A &amp; !B&#39;.

    void minusEqual(bsl::size_t     dstIndex,
                    const BitArray&amp; srcArray,
                    bsl::size_t     srcIndex,
                    bsl::size_t     numBits);
        // Bitwise MINUS (subtract) from the specified &#39;numBits&#39; in this array,
        // beginning at the specified &#39;dstIndex&#39;, values from the specified
        // &#39;srcArray&#39; beginning at the specified &#39;srcIndex&#39; (retaining the
        // results).  The behavior is undefined unless
        // &#39;dstIndex + numBits &lt;= length()&#39; and
        // &#39;srcIndex + numBits &lt;= srcArray.length()&#39;.  Note that the logical
        // difference &#39;A - B&#39; is defined to be &#39;A &amp; !B&#39;.

    void orEqual(bsl::size_t index, bool value);
        // OR the bit at the specified &#39;index&#39; in this array with the specified
        // &#39;value&#39; (retaining the result).  The behavior is undefined unless
        // &#39;index &lt; length()&#39;.

    void orEqual(bsl::size_t     dstIndex,
                 const BitArray&amp; srcArray,
                 bsl::size_t     srcIndex,
                 bsl::size_t     numBits);
        // Bitwise OR the specified &#39;numBits&#39; in this array, beginning at the
        // specified &#39;dstIndex&#39;, with values from the specified &#39;srcArray&#39;
        // beginning at the specified &#39;srcIndex&#39; (retaining the results).  The
        // behavior is undefined unless &#39;dstIndex + numBits &lt;= length()&#39; and
        // &#39;srcIndex + numBits &lt;= srcArray.length()&#39;.

    void remove(bsl::size_t index);
        // Remove from this array the bit at the specified &#39;index&#39;.  All values
        // at indices above &#39;index&#39; in this array are shifted down by one bit
        // position.  The length of this array is reduced by 1.  The behavior
        // is undefined unless &#39;index &lt; length()&#39;.

    void remove(bsl::size_t index, bsl::size_t numBits);
        // Remove from this array the specified &#39;numBits&#39;, beginning at the
        // specified &#39;index&#39;.  All values at indices above &#39;index&#39; in this
        // array are shifted down by &#39;numBits&#39; positions.  The length of this
        // array is reduced by &#39;numBits&#39;.  The behavior is undefined unless
        // &#39;index + numBits &lt;= length()&#39;.

    void removeAll();
        // Remove all of the bits in this array, leaving the length 0, but
        // having no effect on capacity.

    void reserveCapacity(bsl::size_t numBits);
        // Reserve sufficient internal capacity to accommodate a length of at
        // least the specified &#39;numBits&#39; without reallocation.  If an exception
        // is thrown during this reallocation attempt (i.e., by the memory
        // allocator indicated at construction) the value of this array is
        // guaranteed to be unchanged.

    void rotateLeft(bsl::size_t numBits);
        // Shift the values in this array to the left by the specified
        // &#39;numBits&#39; positions, with the high-order values &quot;rotating&quot; into the
        // low-order bits.  The behavior is undefined unless
        // &#39;numBits &lt;= length()&#39;.  Note that the length of this array remains
        // unchanged.

    void rotateRight(bsl::size_t numBits);
        // Shift the values in this array to the right by the specified
        // &#39;numBits&#39; positions, with the low-order values &quot;rotating&quot; into the
        // high-order bits.  The behavior is undefined unless
        // &#39;numBits &lt;= length()&#39;.  Note that the length of this array remains
        // unchanged.

    void setLength(bsl::size_t newLength, bool value = false);
        // Set the number of bits in this array to the specified &#39;newLength&#39;.
        // If &#39;newLength &lt; length()&#39;, bits at index positions at or above
        // &#39;newLength&#39; are removed; otherwise, any new bits (at or above the
        // current length) are initialized to the optionally specified &#39;value&#39;,
        // or to 0 if &#39;value&#39; is not specified.

    void swapBits(bsl::size_t index1, bsl::size_t index2);
        // Efficiently exchange the values of the bits at the specified
        // &#39;index1&#39; and &#39;index2&#39; indices.  The behavior is undefined unless
        // &#39;index1 &lt; length()&#39; and &#39;index2 &lt; length()&#39;.

    void toggle(bsl::size_t index);
        // Complement the value of the bit at the specified &#39;index&#39; in this
        // array.  The behavior is undefined unless &#39;index &lt; length()&#39;.

    void toggle(bsl::size_t index, bsl::size_t numBits);
        // Complement the values of each of the specified &#39;numBits&#39; in this
        // array, beginning at the specified &#39;index&#39;.  The behavior is
        // undefined unless &#39;index + numBits &lt;= length()&#39;.

    void toggleAll();
        // Complement the value of every bit in this array.  Note that the
        // behavior is analogous to applying the &#39;~&#39; operator to an object of
        // fundamental type &#39;unsigned int&#39;.

    void xorEqual(bsl::size_t index, bool value);
        // XOR the bit at the specified &#39;index&#39; in this array with the
        // specified &#39;value&#39; (retaining the result).  The behavior is undefined
        // unless &#39;index &lt; length()&#39;.

    void xorEqual(bsl::size_t     dstIndex,
                  const BitArray&amp; srcArray,
                  bsl::size_t     srcIndex,
                  bsl::size_t     numBits);
        // Bitwise XOR the specified &#39;numBits&#39; in this array, beginning at the
        // specified &#39;dstIndex&#39;, with values from the specified &#39;srcArray&#39;
        // beginning at the specified &#39;srcIndex&#39; (retaining the results).  The
        // behavior is undefined unless &#39;dstIndex + numBits &lt;= length()&#39; and
        // &#39;srcIndex + numBits &lt;= srcArray.length()&#39;.

                                // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    void swap(BitArray&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.  The behavior is undefined unless this
        // object was created with the same allocator as &#39;other&#39;.

    // ACCESSORS
    bool operator[](bsl::size_t index) const;
        // Return the value of the bit at the specified &#39;index&#39; in this array.
        // The behavior is undefined unless &#39;index &lt; length()&#39;.

    bsl::uint64_t bits(bsl::size_t index, bsl::size_t numBits) const;
        // Return the specified &#39;numBits&#39; beginning at the specified &#39;index&#39; in
        // this array as the low-order bits of the returned value.  The
        // behavior is undefined unless
        // &#39;numBits &lt;= sizeof(uint64_t) * CHAR_BIT&#39; and
        // &#39;index + numBits &lt;= length()&#39;.

    bsl::size_t find0AtMaxIndex(bsl::size_t begin = 0,
                                bsl::size_t end   = k_INVALID_INDEX) const;
        // Return the index of the most-significant 0 bit in this array in the
        // range optionally specified by &#39;begin&#39; and &#39;end&#39;, and
        // &#39;k_INVALID_INDEX&#39; otherwise.  The range is
        // &#39;[begin .. effectiveEnd)&#39;, where &#39;effectiveEnd == length()&#39; if &#39;end&#39;
        // is not specified and &#39;effectiveEnd == end&#39; otherwise.  The behavior
        // is undefined unless &#39;begin &lt;= effectiveEnd &lt;= length()&#39;.

    bsl::size_t find0AtMinIndex(bsl::size_t begin = 0,
                                bsl::size_t end   = k_INVALID_INDEX) const;
        // Return the index of the least-significant 0 bit in this array in the
        // range optionally specified by &#39;begin&#39; and &#39;end&#39;, and
        // &#39;k_INVALID_INDEX&#39; otherwise.  The range is
        // &#39;[begin .. effectiveEnd)&#39;, where &#39;effectiveEnd == length()&#39; if &#39;end&#39;
        // is not specified and &#39;effectiveEnd == end&#39; otherwise.  The behavior
        // is undefined unless &#39;begin &lt;= effectiveEnd &lt;= length()&#39;.

    bsl::size_t find1AtMaxIndex(bsl::size_t begin = 0,
                                bsl::size_t end   = k_INVALID_INDEX) const;
        // Return the index of the most-significant 1 bit in this array in the
        // range optionally specified by &#39;begin&#39; and &#39;end&#39;, and
        // &#39;k_INVALID_INDEX&#39; otherwise.  The range is
        // &#39;[begin .. effectiveEnd)&#39;, where &#39;effectiveEnd == length()&#39; if &#39;end&#39;
        // is not specified and &#39;effectiveEnd == end&#39; otherwise.  The behavior
        // is undefined unless &#39;begin &lt;= effectiveEnd &lt;= length()&#39;.

    bsl::size_t find1AtMinIndex(bsl::size_t begin = 0,
                                bsl::size_t end   = k_INVALID_INDEX) const;
        // Return the index of the least-significant 1 bit in this array in the
        // range optionally specified by &#39;begin&#39; and &#39;end&#39;, and
        // &#39;k_INVALID_INDEX&#39; otherwise.  The range is
        // &#39;[begin .. effectiveEnd)&#39;, where &#39;effectiveEnd == length()&#39; if &#39;end&#39;
        // is not specified and &#39;effectiveEnd == end&#39; otherwise.  The behavior
        // is undefined unless &#39;begin &lt;= effectiveEnd &lt;= length()&#39;.

    bool isAny0() const;
        // Return &#39;true&#39; if the value of any bit in this array is 0, and
        // &#39;false&#39; otherwise.

    bool isAny1() const;
        // Return &#39;true&#39; if the value of any bit in this array is 1, and
        // &#39;false&#39; otherwise.

    bool isEmpty() const;
        // Return &#39;true&#39; if the length of this bit array is 0, and &#39;false&#39;
        // otherwise.

    bsl::size_t length() const;
        // Return the number of bits in this array.

    bsl::size_t num0(bsl::size_t begin = 0,
                     bsl::size_t end   = k_INVALID_INDEX) const;
        // Return the number of bits in the range optionally specified by
        // &#39;begin&#39; and &#39;end&#39; having a value of 0.  The range is
        // &#39;[begin .. effectiveEnd)&#39;, where &#39;effectiveEnd == length()&#39; if &#39;end&#39;
        // is not specified and &#39;effectiveEnd == end&#39; otherwise.  The behavior
        // is undefined unless &#39;begin &lt;= effectiveEnd &lt;= length()&#39;.

    bsl::size_t num1(bsl::size_t begin = 0,
                     bsl::size_t end   = k_INVALID_INDEX) const;
        // Return the number of bits in the range optionally specified by
        // &#39;begin&#39; and &#39;end&#39; having a value of 1.  The range is
        // &#39;[begin .. effectiveEnd)&#39;, where &#39;effectiveEnd == length()&#39; if &#39;end&#39;
        // is not specified and &#39;effectiveEnd == end&#39; otherwise.  The behavior
        // is undefined unless &#39;begin &lt;= effectiveEnd &lt;= length()&#39;.

                                // Aspects

    bslma::Allocator *allocator() const;
        // Return the allocator used by this object to supply memory.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

};

// FREE OPERATORS
bool operator==(const BitArray&amp; lhs, const BitArray&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; arrays have the same
    // value, and &#39;false&#39; otherwise.  Two arrays have the same value if they
    // have the same length, and corresponding bits at each bit position have
    // the same value.

bool operator!=(const BitArray&amp; lhs, const BitArray&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; arrays do not have the
    // same value, and &#39;false&#39; otherwise.  Two arrays do not have the same
    // value if they do not have the same length, or there is at least one
    // valid index position at which corresponding bits do not have the same
    // value.

BitArray operator~(const BitArray&amp; array);
    // Return the bitwise complement (&quot;toggle&quot;) of the specified &#39;array&#39;.

BitArray operator&amp;(const BitArray&amp; lhs, const BitArray&amp; rhs);
    // Return the value that is the bitwise AND of the specified &#39;lhs&#39; and
    // &#39;rhs&#39; arrays.  The length of the resulting bit array will be the maximum
    // of that of &#39;lhs&#39; and &#39;rhs&#39;, with any unmatched high-order bits set to
    // 0.  Note that this behavior is consistent with zero-extending the
    // shorter array.

BitArray operator-(const BitArray&amp; lhs, const BitArray&amp; rhs);
    // Return the value that is the bitwise MINUS of the specified &#39;lhs&#39; and
    // &#39;rhs&#39; arrays.  The length of the resulting bit array will be the maximum
    // of that of &#39;lhs&#39; and &#39;rhs&#39;, with any unmatched high-order &#39;lhs&#39; bits
    // copied unchanged, and any unmatched high-order &#39;rhs&#39; bits set to 0.
    // Note that this behavior is consistent with zero-extending the shorter
    // array.

BitArray operator|(const BitArray&amp; lhs, const BitArray&amp; rhs);
    // Return the value that is the bitwise OR of the specified &#39;lhs&#39; and &#39;rhs&#39;
    // arrays.  The length of the resulting bit array will be the maximum of
    // that of &#39;lhs&#39; and &#39;rhs&#39;, with any unmatched high-order bits copied
    // unchanged.  Note that this behavior is consistent with zero-extending
    // the shorter array.

BitArray operator^(const BitArray&amp; lhs, const BitArray&amp; rhs);
    // Return the value that is the bitwise XOR of the specified &#39;lhs&#39; and
    // &#39;rhs&#39; arrays.  The length of the resulting bit array will be the maximum
    // of that of &#39;lhs&#39; and &#39;rhs&#39;, with any unmatched high-order bits copied
    // unchanged.  Note that this behavior is consistent with zero-extending
    // the shorter array.

BitArray operator&lt;&lt;(const BitArray&amp; array, bsl::size_t numBits);
    // Return the value of the specified &#39;array&#39; left-shifted by the specified
    // &#39;numBits&#39; positions, having filled the lower-index positions with zeros.
    // The behavior is undefined unless &#39;numBits &lt;= array.length()&#39;.  Note that
    // the length of the result equals the length of the original array, and
    // that the highest-order &#39;numBits&#39; are discarded in the result.

BitArray operator&gt;&gt;(const BitArray&amp; array, bsl::size_t numBits);
    // Return the value of the specified &#39;array&#39; right-shifted by the specified
    // &#39;numBits&#39; positions, having filled the higher-index positions with
    // zeros.  The behavior is undefined unless
    // &#39;numBits &lt;= array.length()&#39;.  Note that the length of the result equals
    // the length of the original array, and that the lowest-order &#39;numBits&#39;
    // are discarded in the result.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const BitArray&amp; rhs);
    // Format the bits in the specified &#39;rhs&#39; bit array to the specified output
    // &#39;stream&#39; in a single-line format, and return a reference to &#39;stream&#39;.

// FREE FUNCTIONS
void swap(BitArray&amp; a, BitArray&amp; b);
    // Efficiently exchange the values of the specified &#39;a&#39; and &#39;b&#39; objects.
    // This function provides the no-throw exception-safety guarantee.  The
    // behavior is undefined unless the two objects were created with the same
    // allocator.

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                                // --------------
                                // class BitArray
                                // --------------

// PRIVATE CLASS METHODS
inline
bsl::size_t BitArray::arraySize(bsl::size_t numBits)
{
    // Note that we ensure that the capacity of &#39;d_array&#39; is at least 1 at all
    // times.  This way we know that &#39;d_array.front()&#39; is valid.

    const bsl::size_t ret = (numBits + k_BITS_PER_UINT64 - 1) /
                                                             k_BITS_PER_UINT64;
    return ret ? ret : 1;
}

// PRIVATE MANIPULATORS
inline
bsl::uint64_t *BitArray::data()
{
    BSLS_ASSERT_SAFE(!d_array.empty());

    return d_array.data();
}

// PRIVATE ACCESSORS
inline
const bsl::uint64_t *BitArray::data() const
{
    BSLS_ASSERT_SAFE(!d_array.empty());

    return d_array.data();
}

// CLASS METHODS

                                // Aspects

inline
int BitArray::maxSupportedBdexVersion(int)
{
    return 1;
}

// MANIPULATORS
inline
BitArray&amp; BitArray::operator=(const BitArray&amp; rhs)
{
    if (this != &amp;rhs) {
        // The allocator used by the temporary copy must be the same as the
        // allocator of this object.

        BitArray(rhs, allocator()).swap(*this);
    }

    return *this;
}

inline
BitArray&amp; BitArray::operator&amp;=(const BitArray&amp; rhs)
{
    if (this != &amp;rhs) {
        bdlb::BitStringUtil::andEqual(data(),
                                      0,
                                      rhs.data(),
                                      0,
                                      bsl::min(d_length, rhs.d_length));
        if (d_length &gt; rhs.d_length) {
            assign0(rhs.d_length, d_length - rhs.d_length);
        }
    }

    return *this;
}

inline
BitArray&amp; BitArray::operator-=(const BitArray&amp; rhs)
{
    if (this != &amp;rhs) {
        bdlb::BitStringUtil::minusEqual(data(),
                                        0,
                                        rhs.data(),
                                        0,
                                        bsl::min(d_length, rhs.d_length));
    }
    else {
        assignAll0();
    }

    return *this;
}

inline
BitArray&amp; BitArray::operator|=(const BitArray&amp; rhs)
{
    if (this != &amp;rhs) {
        bdlb::BitStringUtil::orEqual(data(),
                                     0,
                                     rhs.data(),
                                     0,
                                     bsl::min(d_length, rhs.d_length));
    }

    return *this;
}

inline
BitArray&amp; BitArray::operator^=(const BitArray&amp; rhs)
{
    if (this != &amp;rhs) {
        bdlb::BitStringUtil::xorEqual(data(),
                                      0,
                                      rhs.data(),
                                      0,
                                      bsl::min(d_length, rhs.d_length));;
    }
    else {
        assignAll0();
    }

    return *this;
}

inline
BitArray&amp; BitArray::operator&gt;&gt;=(bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(numBits &lt;= d_length);

    if (numBits) {
        if (d_length &gt; numBits) {
            const bsl::size_t remBits = d_length - numBits;

            bdlb::BitStringUtil::copyRaw(data(), 0, data(), numBits, remBits);
            assign0(remBits, numBits);
        }
        else {
            assignAll0();
        }
    }

    return *this;
}

inline
BitArray&amp; BitArray::operator&lt;&lt;=(bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(numBits &lt;= d_length);

    if (numBits) {
        if (d_length &gt; numBits) {
            const bsl::size_t remBits = d_length - numBits;

            bdlb::BitStringUtil::copy(data(), numBits, data(), 0, remBits);
            assign0(0, numBits);
        }
        else {
            assignAll0();
        }
    }

    return *this;
}

inline
void BitArray::andEqual(bsl::size_t index, bool value)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    if (!value) {
        assign0(index);
    }
}

inline
void BitArray::andEqual(bsl::size_t     dstIndex,
                        const BitArray&amp; srcArray,
                        bsl::size_t     srcIndex,
                        bsl::size_t     numBits)
{
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= d_length);
    BSLS_ASSERT_SAFE(srcIndex + numBits &lt;= srcArray.d_length);

    bdlb::BitStringUtil::andEqual(data(),
                                  dstIndex,
                                  srcArray.data(),
                                  srcIndex,
                                  numBits);
}

inline
void BitArray::append(bool value)
{
    if (d_length &amp;&amp; 0 == d_length % k_BITS_PER_UINT64) {
        d_array.push_back(value);
    }
    else if (value) {
        bdlb::BitStringUtil::assign1(data(), d_length);
    }
    ++d_length;
}

inline
void BitArray::append(bool value, bsl::size_t numBits)
{
    insert(d_length, value, numBits);
}

inline
void BitArray::append(const BitArray&amp; srcArray)
{
    insert(d_length, srcArray, 0, srcArray.d_length);
}

inline
void BitArray::append(const BitArray&amp; srcArray,
                      bsl::size_t     srcIndex,
                      bsl::size_t     numBits)
{
    BSLS_ASSERT_SAFE(srcIndex + numBits &lt;= srcArray.d_length);

    insert(d_length, srcArray, srcIndex, numBits);
}

inline
void BitArray::assign(bsl::size_t index, bool value)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    bdlb::BitStringUtil::assign(data(), index, value);
}

inline
void BitArray::assign(bsl::size_t index, bool value, bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(index + numBits &lt;= d_length);

    bdlb::BitStringUtil::assign(data(), index, value, numBits);
}

inline
void BitArray::assign(bsl::size_t     dstIndex,
                      const BitArray&amp; srcArray,
                      bsl::size_t     srcIndex,
                      bsl::size_t     numBits)
{
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= d_length);
    BSLS_ASSERT_SAFE(srcIndex + numBits &lt;= srcArray.d_length);

    if (&amp;srcArray == this) {
        // Might be overlapping copy.

        bdlb::BitStringUtil::copy(data(),
                                  dstIndex,
                                  srcArray.data(),
                                  srcIndex,
                                  numBits);
    }
    else {
        // Definitely not overlapping copy.

        bdlb::BitStringUtil::copyRaw(data(),
                                     dstIndex,
                                     srcArray.data(),
                                     srcIndex,
                                     numBits);
    }
}

inline
void BitArray::assign0(bsl::size_t index)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    bdlb::BitStringUtil::assign0(data(), index);
}

inline
void BitArray::assign0(bsl::size_t index, bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(index + numBits &lt;= d_length);

    bdlb::BitStringUtil::assign0(data(), index, numBits);
}

inline
void BitArray::assign1(bsl::size_t index)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    bdlb::BitStringUtil::assign1(data(), index);
}

inline
void BitArray::assign1(bsl::size_t index, bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(index + numBits &lt;= d_length);

    bdlb::BitStringUtil::assign1(data(), index, numBits);
}

inline
void BitArray::assignAll(bool value)
{
    if (value) {
        assignAll1();
    }
    else {
        assignAll0();
    }
}

inline
void BitArray::assignAll0()
{
    bdlb::BitStringUtil::assign0(data(), 0, d_length);
}

inline
void BitArray::assignAll1()
{
    bdlb::BitStringUtil::assign1(data(), 0, d_length);
}

inline
void BitArray::assignBits(bsl::size_t   index,
                          bsl::uint64_t srcBits,
                          bsl::size_t   numBits)
{
    BSLS_ASSERT_SAFE(        numBits &lt;= k_BITS_PER_UINT64);
    BSLS_ASSERT_SAFE(index + numBits &lt;= d_length);

    bdlb::BitStringUtil::assignBits(data(), index, srcBits, numBits);
}

inline
void BitArray::insert(bsl::size_t dstIndex, const BitArray&amp; srcArray)
{
    BSLS_ASSERT_SAFE(dstIndex &lt;= d_length);

    insert(dstIndex, srcArray, 0, srcArray.d_length);
}

inline
void BitArray::insert(bsl::size_t dstIndex, bool value)
{
    BSLS_ASSERT_SAFE(dstIndex &lt;= d_length);

    setLength(d_length + 1);
    bdlb::BitStringUtil::insert(data(), d_length - 1, dstIndex, value, 1);
}

inline
void BitArray::insert(bsl::size_t dstIndex, bool value, bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(dstIndex &lt;= d_length);

    setLength(d_length + numBits);
    bdlb::BitStringUtil::insert(data(),
                                d_length - numBits,
                                dstIndex,
                                value,
                                numBits);
}

inline
void BitArray::minusEqual(bsl::size_t index, bool value)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    if (value) {
        assign0(index);
    }
}

inline
void BitArray::minusEqual(bsl::size_t     dstIndex,
                          const BitArray&amp; srcArray,
                          bsl::size_t     srcIndex,
                          bsl::size_t     numBits)
{
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= d_length);
    BSLS_ASSERT_SAFE(srcIndex + numBits &lt;= srcArray.d_length);

    bdlb::BitStringUtil::minusEqual(data(),
                                    dstIndex,
                                    srcArray.data(),
                                    srcIndex,
                                    numBits);
}

inline
void BitArray::orEqual(bsl::size_t index, bool value)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    if (value) {
        assign1(index);
    }
}

inline
void BitArray::orEqual(bsl::size_t     dstIndex,
                       const BitArray&amp; srcArray,
                       bsl::size_t     srcIndex,
                       bsl::size_t     numBits)
{
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= d_length);
    BSLS_ASSERT_SAFE(srcIndex + numBits &lt;= srcArray.d_length);

    bdlb::BitStringUtil::orEqual(data(),
                                 dstIndex,
                                 srcArray.data(),
                                 srcIndex,
                                 numBits);
}

inline
void BitArray::remove(bsl::size_t index)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    remove(index, 1);
}

inline
void BitArray::remove(bsl::size_t index, bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(index + numBits &lt;= d_length);

    bdlb::BitStringUtil::remove(data(), d_length, index, numBits);
    setLength(d_length - numBits);
}

inline
void BitArray::removeAll()
{
    d_array.clear();
    d_array.resize(1);
    d_length = 0;
}

inline
void BitArray::reserveCapacity(bsl::size_t numBits)
{
    d_array.reserve(arraySize(numBits));
}

inline
void BitArray::swapBits(bsl::size_t index1, bsl::size_t index2)
{
    BSLS_ASSERT_SAFE(index1 &lt; d_length);
    BSLS_ASSERT_SAFE(index2 &lt; d_length);

    if (index1 != index2) {
        const bool tmp = (*this)[index1];
        assign(index1,   (*this)[index2]);
        assign(index2, tmp);
    }
}

inline
void BitArray::toggle(bsl::size_t index)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    const bsl::size_t idx =                       index  / k_BITS_PER_UINT64;
    const int         pos = static_cast&lt;unsigned&gt;(index) % k_BITS_PER_UINT64;

    d_array[idx] ^= (s_one &lt;&lt; pos);
}

inline
void BitArray::toggle(bsl::size_t index, bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(index + numBits &lt;= d_length);

    // &#39;index&#39; and &#39;numBits&#39; non-negative checked by &#39;BitStringUtil&#39;.

    bdlb::BitStringUtil::toggle(data(), index, numBits);
}

inline
void BitArray::toggleAll()
{
    toggle(0, d_length);
}

inline
void BitArray::xorEqual(bsl::size_t index, bool value)
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    if (value) {
        toggle(index);
    }
}

inline
void BitArray::xorEqual(bsl::size_t     dstIndex,
                        const BitArray&amp; srcArray,
                        bsl::size_t     srcIndex,
                        bsl::size_t     numBits)
{
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= d_length);
    BSLS_ASSERT_SAFE(srcIndex + numBits &lt;= srcArray.d_length);

    bdlb::BitStringUtil::xorEqual(data(),
                                  dstIndex,
                                  srcArray.data(),
                                  srcIndex,
                                  numBits);
}

                                // Aspects

template &lt;class STREAM&gt;
STREAM&amp; BitArray::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) {  // Switch on the schema version (starting with 1).
          case 1: {
            int newLength;
            stream.getLength(newLength);
            if (!stream) {
                return stream;                                        // RETURN
            }

            if (0 == newLength) {
                removeAll();

                return stream;                                        // RETURN
            }

            const bsl::size_t len = arraySize(newLength);
            removeAll();
            d_array.resize(len);

            // &#39;getArrayUint64&#39; will throw if there is bad input, so to prevent
            // invariants tests in the bit array destructor from failing, we
            // must make &#39;d_length&#39; consistent with &#39;d_array.size()&#39; before
            // that happens.

            d_length = newLength;

            stream.getArrayUint64(
                       reinterpret_cast&lt;bsls::Types::Uint64 *&gt;(d_array.data()),
                       static_cast&lt;int&gt;(len));
            if (!stream) {
                removeAll();
                return stream;                                        // RETURN
            }

            // Test for corrupted data.

            const int rem = static_cast&lt;unsigned&gt;(d_length) %
                                                             k_BITS_PER_UINT64;
            if (rem) {
                const bsl::uint64_t mask = (s_one &lt;&lt; rem) - 1;
                if (d_array.back() &amp; ~mask) {
                    // Correct invalid bit array and invalidate stream.  This
                    // is fastest way to valid, arbitrary state.

                    d_array.back() &amp;= mask;
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
            }
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;
}

inline
void BitArray::swap(BitArray&amp; other)
{
    // &#39;swap&#39; is undefined for objects with non-equal allocators.

    BSLS_ASSERT_SAFE(allocator() == other.allocator());

    bslalg::SwapUtil::swap(&amp;d_array,  &amp;other.d_array);
    bslalg::SwapUtil::swap(&amp;d_length, &amp;other.d_length);
}

// ACCESSORS
inline
bool BitArray::operator[](bsl::size_t index) const
{
    BSLS_ASSERT_SAFE(index &lt; d_length);

    return bdlb::BitStringUtil::bit(data(), index);
}

inline
bsl::uint64_t BitArray::bits(bsl::size_t index, bsl::size_t numBits) const
{
    BSLS_ASSERT_SAFE(index + numBits &lt;= d_length);

    return bdlb::BitStringUtil::bits(data(), index, numBits);
}

inline
bsl::size_t BitArray::find0AtMaxIndex(bsl::size_t begin, bsl::size_t end) const
{
    if (k_INVALID_INDEX == end) {
        end = d_length;
    }
    BSLS_ASSERT_SAFE(begin &lt;= end);
    BSLS_ASSERT_SAFE(         end &lt;= d_length);

    return bdlb::BitStringUtil::find0AtMaxIndex(data(), begin, end);
}

inline
bsl::size_t BitArray::find0AtMinIndex(bsl::size_t begin, bsl::size_t end) const
{
    if (k_INVALID_INDEX == end) {
        end = d_length;
    }
    BSLS_ASSERT_SAFE(begin &lt;= end);
    BSLS_ASSERT_SAFE(         end &lt;= d_length);

    return bdlb::BitStringUtil::find0AtMinIndex(data(), begin, end);
}

inline
bsl::size_t BitArray::find1AtMaxIndex(bsl::size_t begin, bsl::size_t end) const
{
    if (k_INVALID_INDEX == end) {
        end = d_length;
    }
    BSLS_ASSERT_SAFE(begin &lt;= end);
    BSLS_ASSERT_SAFE(         end &lt;= d_length);

    return bdlb::BitStringUtil::find1AtMaxIndex(data(), begin, end);
}

inline
bsl::size_t BitArray::find1AtMinIndex(bsl::size_t begin, bsl::size_t end) const
{
    if (k_INVALID_INDEX == end) {
        end = d_length;
    }
    BSLS_ASSERT_SAFE(begin &lt;= end);
    BSLS_ASSERT_SAFE(         end &lt;= d_length);

    return bdlb::BitStringUtil::find1AtMinIndex(data(), begin, end);
}

inline
bool BitArray::isAny0() const
{
    return bdlb::BitStringUtil::isAny0(data(), 0, d_length);
}

inline
bool BitArray::isAny1() const
{
    return bdlb::BitStringUtil::isAny1(data(), 0, d_length);
}

inline
bool BitArray::isEmpty() const
{
    return 0 == d_length;
}

inline
bsl::size_t BitArray::length() const
{
    return d_length;
}

inline
bsl::size_t BitArray::num0(bsl::size_t begin, bsl::size_t end) const
{
    if (k_INVALID_INDEX == end) {
        end = d_length;
    }
    BSLS_ASSERT_SAFE(begin &lt;= end);
    BSLS_ASSERT_SAFE(         end &lt;= d_length);

    return bdlb::BitStringUtil::num0(data(), begin, end - begin);
}

inline
bsl::size_t BitArray::num1(bsl::size_t begin, bsl::size_t end) const
{
    if (k_INVALID_INDEX == end) {
        end = d_length;
    }
    BSLS_ASSERT_SAFE(begin &lt;= end);
    BSLS_ASSERT_SAFE(         end &lt;= d_length);

    return bdlb::BitStringUtil::num1(data(), begin, end - begin);
}

                                // Aspects

inline
bslma::Allocator *BitArray::allocator() const
{
    return d_array.get_allocator().mechanism();
}

template &lt;class STREAM&gt;
STREAM&amp; BitArray::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {
      case 1: {
        BSLS_ASSERT_SAFE(d_length &lt;= INT_MAX);

        stream.putLength(static_cast&lt;int&gt;(d_length));
        if (0 != d_length) {
            stream.putArrayUint64(
                 reinterpret_cast&lt;const bsls::Types::Uint64 *&gt;(d_array.data()),
                 static_cast&lt;int&gt;(d_array.size()));
        }
      } break;
      default: {
        stream.invalidate();
      }
    }

    return stream;
}


// FREE OPERATORS
inline
bool operator==(const BitArray&amp; lhs, const BitArray&amp; rhs)
{
    if (lhs.d_length != rhs.d_length) {
        return false;                                                 // RETURN
    }

    return bdlb::BitStringUtil::areEqual(lhs.data(),
                                         rhs.data(),
                                         lhs.d_length);
}

inline
bool operator!=(const BitArray&amp; lhs, const BitArray&amp; rhs)
{
    return !(lhs == rhs);
}

inline
BitArray operator~(const BitArray&amp; array)
{
    BitArray tmp(array);
    tmp.toggleAll();
    return tmp;
}

inline
BitArray operator&amp;(const BitArray&amp; lhs, const BitArray&amp; rhs)
{
    BitArray tmp(lhs);
    tmp &amp;= rhs;
    return tmp;
}

inline
BitArray operator|(const BitArray&amp; lhs, const BitArray&amp; rhs)
{
    BitArray tmp(lhs);
    tmp |= rhs;
    return tmp;
}

inline
BitArray operator^(const BitArray&amp; lhs, const BitArray&amp; rhs)
{
    BitArray tmp(lhs);
    tmp ^= rhs;
    return tmp;
}

inline
BitArray operator-(const BitArray&amp; lhs, const BitArray&amp; rhs)
{
    BitArray tmp(lhs);
    tmp -= rhs;
    return tmp;
}

inline
BitArray operator&lt;&lt;(const BitArray&amp; array, bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(numBits &lt;= array.length());

    BitArray tmp(array);
    tmp &lt;&lt;= numBits;
    return tmp;
}

inline
BitArray operator&gt;&gt;(const BitArray&amp; array, bsl::size_t numBits)
{
    BSLS_ASSERT_SAFE(numBits &lt;= array.length());

    BitArray tmp(array);
    tmp &gt;&gt;= numBits;
    return tmp;
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const BitArray&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}

// FREE FUNCTIONS
inline
void swap(BitArray&amp; a, BitArray&amp; b)
{
    a.swap(b);
}

}  // close package namespace

namespace bslmf {

template &lt;&gt;
struct IsBitwiseMoveable&lt;bdlc::BitArray&gt; :
                        public IsBitwiseMoveable&lt;bsl::vector&lt;bsl::uint64_t&gt; &gt; {
    // This template specialization for &#39;IsBitwiseMoveable&#39; indicates that
    // &#39;BitArray&#39; is a bitwise moveable type if &#39;vector&lt;uint64_t&gt;&#39; is a bitwise
    // moveable type.
};

}  // close namespace bslmf

namespace bslma {

template &lt;&gt;
struct UsesBslmaAllocator&lt;bdlc::BitArray&gt; : bsl::true_type {
    // This template specialization for &#39;UsesBslmaAllocator&#39; indicates that
    // &#39;BitArray&#39; uses &#39;bslma::Allocator&#39;.
};

}  // close namespace bslma

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
