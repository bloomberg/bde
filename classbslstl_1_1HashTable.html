<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bslstl::HashTable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslstl.html">bslstl</a>      </li>
      <li><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslstl::HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslstl::HashTable" -->
<p><code>#include &lt;<a class="el" href="bslstl__hashtable_8h_source.html">bslstl_hashtable.h</a>&gt;</code></p>

<p><a href="classbslstl_1_1HashTable-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a1d065f7c792ed72c7a408fed3492dbfb">AllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classbslstl_1_1HashTable.html#a1d065f7c792ed72c7a408fed3492dbfb">AllocatorType</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a53f7a06c05942466bae032b67d62265c">AllocatorTraits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY_CONFIG::KeyType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY_CONFIG::ValueType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode</a><br class="typebreak"/>
&lt; <a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a0e8f9d9687085e2e6dd424c095509d45">NodeType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__bslstl__allocatortraits.html#gae5fea114d04c6a2615a8c75e820f9364">AllocatorTraits::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#ac9f1d7328021a279c4df5fc955cba4b0">HashTable</a> (const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a4d842d4759aa4a79804c45c0dae1c5e4">HashTable</a> (const HASHER &amp;hash, const COMPARATOR &amp;compare, <a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> initialNumBuckets, float initialMaxLoadFactor, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#afb3d75d57c8bb990c2e4c73406ea32c0">HashTable</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#affbe891c4d69ac8b74800ce8cf8ab38d">HashTable</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;original, const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#adaad010e62109e9b9ad58ef3d9d1c147">~HashTable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a9273aac7e35b9164447ee4bd06fb9905">operator=</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a4b2d0837f045d05cf4c6fa165ce734f8">insert</a> (const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a2388bb4460b76912a71daab2e0e8050a">insert</a> (const SOURCE_TYPE &amp;value, <a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *hint)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a55ed694c2a21d05367dee017c0500bf4">insertIfMissing</a> (bool *isInsertedFlag, const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a3e4f6cdb2135640784a69d6dd3061d85">insertIfMissing</a> (bool *isInsertedFlag, const <a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#ae3c56e3ea3fc0017e85703ae6b99a43e">insertIfMissing</a> (const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a1ce78c8168d956298f1a25a104f998d3">rehashForNumBuckets</a> (<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> newNumBuckets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aa685fb6a44c04fb6ae62cf9ab58b0fe7">remove</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#afffb07f59df454ee2b4c5e1715f20a33">removeAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aa036505276fa2bba893faed0b91ec468">reserveForNumElements</a> (<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a21d2beaab71042fc239f982acce58e60">setMaxLoadFactor</a> (float newMaxLoadFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a2266a7d27b3062f662954969eadccf4b">swap</a> (<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a14bd5ea4c9036e7cc07e6dbd2052a70b">allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aeee49aabe8b5520d37fce4fab6da7b55">bucketAtIndex</a> (<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a265f8fe39b93361ad49fc955e67aeaa3">bucketIndexForKey</a> (const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const COMPARATOR &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aee72ed54311d229091d2ee1cff829f1d">comparator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a0a832a91848f46d46b08b73d45076dd5">countElementsInBucket</a> (<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a0048e907eba27fb3214e62dde3fc6e0e">elementListRoot</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a0e44ea833c36703b2365e905bc56a2ed">find</a> (const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#ad49180ddbef4d772672ee7d7ffce8dfe">findEndOfRange</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *first) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a2d96732e4f144e3bae3ed98ae88e5737">findRange</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> **first, <a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> **last, const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a81f2db5f7b1d834ae2b0a00dcda3342b">hasSameValue</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const HASHER &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#abb50661b1e2479fb6d078871e9455954">hasher</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a4a0fdbf6fa943b2a16d8122103b9aeed">loadFactor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#ac514b3479dfdd8c7d15e1b71a0f0471c">maxLoadFactor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a78d4960a36f7c8fa496850042fbbaf9b">maxNumBuckets</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a59b2de4faa950717a5f41dbee0d6377f">maxSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a23af09936478ee2a3c49b957952b310e">numBuckets</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#af319d605a8ccfefd1a5dc194bf1de14a">rehashThreshold</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a7ac0e7f04be89ec149a35bc128d22dc9">size</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt;<br/>
 class bslstl::HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;</h3>

<p>This class template implements a value-semantic container type holding an unordered sequence of (possibly duplicate) elements, that can be rapidly accessed using their key, with the constraint on the container that elements whose keys compare equal according to the specified <code>COMPARATOR</code> will be stored in a stable, contiguous sequence within the container. The value type and key type of the elements maintained by a <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> are determined by aliases provided through the (template parameter) type <code>KEY_CONFIG</code>. Elements in a <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> are stored in "nodes" that are allocated using an allocator of the specified <code>ALLOCATOR</code> type (rebound to the node type), and elements are constructed directly in the node using the allocator as described in the C++11 standard under the allocator-aware container requirements in ([container.requirements.general], C++11 23.2.1). The (template parameter) types <code>HASHER</code> and <code>COMPARATOR</code> shall be copy-constructible function-objects. <code>HASHER</code> shall support a function call operator compatible with the following statements: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      HASHER              hash;
      KEY_CONFIG::KeyType key;
      std::size_t result = hash(key);
</pre></div><p><br/>
<br/>
 where the definition of the called function meets the requirements of a hash function, as specified in <a href="group__bslstl__hash.html" class="el"><code>bslstl_hash</code></a>. <code>COMPARATOR</code> shall support the a function call operator compatible with the following statements: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      COMPARATOR          compare;
      KEY_CONFIG::KeyType key1, key2;
      <span class="keywordtype">bool</span> result = compare(key1, key2);
</pre></div><p><br/>
<br/>
 where the definition of the called function defines an equivalence relationship on keys that is both reflexive and transitive. The <code>HASHER</code> and <code>COMPARATOR</code> attributes of this class are further constrained, such for any two objects whose keys compare equal by the comparator, shall produce the same value from the hasher.</p>
<p>This class: </p>
<ul>
<li>
<p class="startli">supports a complete set of <em>value-semantic</em> operations</p>
<ul>
<li>
except for <code>bdex</code> serialization </li>
</ul>
<p class="endli"></p>
</li>
<li>
is <em>exception-neutral</em> (agnostic except for the <code>at</code> method)  </li>
<li>
is <em>alias-safe</em>  </li>
<li>
is <code>const</code> <em>thread-safe</em>  </li>
</ul>
<p>For terminology see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a1d065f7c792ed72c7a408fed3492dbfb"></a><!-- doxytag: member="bslstl::HashTable::AllocatorType" ref="a1d065f7c792ed72c7a408fed3492dbfb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html#a1d065f7c792ed72c7a408fed3492dbfb">AllocatorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53f7a06c05942466bae032b67d62265c"></a><!-- doxytag: member="bslstl::HashTable::AllocatorTraits" ref="a53f7a06c05942466bae032b67d62265c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt;<a class="el" href="classbslstl_1_1HashTable.html#a1d065f7c792ed72c7a408fed3492dbfb">AllocatorType</a>&gt; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="structbsl_1_1allocator__traits.html">AllocatorTraits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18d98e658d7de9f649ddbe490ee24738"></a><!-- doxytag: member="bslstl::HashTable::KeyType" ref="a18d98e658d7de9f649ddbe490ee24738" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY_CONFIG::KeyType <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aead7dae40f7e52cb760cbd9c68d33e42"></a><!-- doxytag: member="bslstl::HashTable::ValueType" ref="aead7dae40f7e52cb760cbd9c68d33e42" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY_CONFIG::ValueType <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0e8f9d9687085e2e6dd424c095509d45"></a><!-- doxytag: member="bslstl::HashTable::NodeType" ref="a0e8f9d9687085e2e6dd424c095509d45" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode</a>&lt;<a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a>&gt; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1BidirectionalNode.html">NodeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d5e7243cc034a19673909ac19ac6e7f"></a><!-- doxytag: member="bslstl::HashTable::SizeType" ref="a9d5e7243cc034a19673909ac19ac6e7f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__bslstl__allocatortraits.html#gae5fea114d04c6a2615a8c75e820f9364">AllocatorTraits::size_type</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac9f1d7328021a279c4df5fc955cba4b0"></a><!-- doxytag: member="bslstl::HashTable::HashTable" ref="ac9f1d7328021a279c4df5fc955cba4b0" args="(const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> object with a <code>maxLoadFactor</code> of 1.0. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. Use a default constructed object of the (template parameter) type <code>HASHER</code> and a default constructed object of the (template parameter) type <code>COMPARATOR</code> to organize elements in the table. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator will be used to supply memory. No memory will be allocated unless the <code>HASHER</code> or <code>COMPARATOR</code> types allocate memory in their default constructor. </p>

</div>
</div>
<a class="anchor" id="a4d842d4759aa4a79804c45c0dae1c5e4"></a><!-- doxytag: member="bslstl::HashTable::HashTable" ref="a4d842d4759aa4a79804c45c0dae1c5e4" args="(const HASHER &amp;hash, const COMPARATOR &amp;compare, SizeType initialNumBuckets, float initialMaxLoadFactor, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const HASHER &amp;&nbsp;</td>
          <td class="paramname"> <em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>initialNumBuckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>initialMaxLoadFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty hash-table using the specified <code>hash</code> and <code>compare</code> functors to organize elements in the table, which will initially have at least the specified <code>initialNumBuckets</code> and a <code>maxLoadFactor</code> of the specified <code>initialMaxLoadFactor</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator will be used to supply memory. If this constructor tries to allocate a number of buckets larger than can be represented by this hash-table's <code>SizeType</code>, a <code>std::length_error</code> exception will be thrown. The behavior is undefined unless <code>0 &lt; initialMaxLoadFactor</code>. Note that more than <code>initialNumBuckets</code> buckets may be created in order to preserve the bucket allocation strategy of the hash-table (but never fewer). </p>

</div>
</div>
<a class="anchor" id="afb3d75d57c8bb990c2e4c73406ea32c0"></a><!-- doxytag: member="bslstl::HashTable::HashTable" ref="afb3d75d57c8bb990c2e4c73406ea32c0" args="(const HashTable &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> having the same value as the specified <code>original</code>, and the same <code>maxLoadFactor</code>. Use a copy of <code>original.hasher()</code> and a copy of <code>original.comparator()</code> to organize elements in this hash-table. Use the allocator returned by 'bslallocator_traits&lt;ALLOCATOR&gt;:: select_on_container_copy_construction(original.allocator())' to allocate memory. If the type <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), the currently installed default allocator will be used to supply memory. Note that this hash-table may have fewer buckets than <code>original</code>, and a correspondingly higher <code>loadFactor</code>, so long as <code>maxLoadFactor</code> is not exceeded. Note that the created hash table may have a different <code>numBuckets</code> than <code>original</code>, and a correspondingly different <code>loadFactor</code>, as long as <code>maxLoadFactor</code> is not exceeded. </p>

</div>
</div>
<a class="anchor" id="affbe891c4d69ac8b74800ce8cf8ab38d"></a><!-- doxytag: member="bslstl::HashTable::HashTable" ref="affbe891c4d69ac8b74800ce8cf8ab38d" args="(const HashTable &amp;original, const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> having the same value and <code>maxLoadFactor</code> as the specified <code>original</code>, that will use the specified <code>allocator</code> to supply memory. Use a copy of <code>original.hasher()</code> and a copy of <code>original.comparator()</code> to organize elements in this hash- table. Note that this hash-table may have a different <code>numBuckets</code> than <code>original</code>, and a correspondingly different <code>loadFactor</code>, as long as <code>maxLoadFactor</code> is not exceeded. </p>

</div>
</div>
<a class="anchor" id="adaad010e62109e9b9ad58ef3d9d1c147"></a><!-- doxytag: member="bslstl::HashTable::~HashTable" ref="adaad010e62109e9b9ad58ef3d9d1c147" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::~<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9273aac7e35b9164447ee4bd06fb9905"></a><!-- doxytag: member="bslstl::HashTable::operator=" ref="a9273aac7e35b9164447ee4bd06fb9905" args="(const HashTable &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&amp; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value, hasher, comparator and <code>maxLoadFactor</code> of the specified <code>rhs</code> object, replace the allocator of this object with the allocator of <code>rhs</code> if the <code>ALLOCATOR</code> type has the trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. This method requires that the parameterized <code>HASHER</code> and <code>COMPARATOR</code> types be "copy-constructible", "copy-assignable" and "swappable" (see <a href="group__bslstl__hashtable.html#requirements_on_key_config" class="el">Requirements on <code>KEY_CONFIG</code></a>). Note that these requirements are modeled after the unordered container requirements table in the C++11 standard, which is imprecise on this operation. These requirements might simplify in the future, if the standard is updated. </p>

</div>
</div>
<a class="anchor" id="a4b2d0837f045d05cf4c6fa165ce734f8"></a><!-- doxytag: member="bslstl::HashTable::insert" ref="a4b2d0837f045d05cf4c6fa165ce734f8" args="(const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this hash-table, and return the address of the new node. If this hash-table already contains an element having the same key as <code>value</code> (according to this hash- table's <code>comparator</code>) then insert <code>value</code> immediately before the first element having the same key. Additional buckets will be allocated, as needed, to preserve the invariant <code>loadFactor &lt;= maxLoadFactor</code>. If this function tries to allocate a number of buckets larger than can be represented by this hash table's <code>SizeType</code>, a <code>std::length_error</code> exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a2388bb4460b76912a71daab2e0e8050a"></a><!-- doxytag: member="bslstl::HashTable::insert" ref="a2388bb4460b76912a71daab2e0e8050a" args="(const SOURCE_TYPE &amp;value, bslalg::BidirectionalLink *hint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>hint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this hash table, and return the address of the new node. If the element stored in the node pointer to by the specified <code>hint</code> has a key that compares equal to that of <code>value</code> then <code>value</code> will be inserted immediately preceding <code>hint</code> in the list of this hash table. Additional buckets will be allocated, as needed, to preserve the invariant <code>loadFactor &lt;= maxLoadFactor</code>. If this function tries to allocate a number of buckets larger than can be represented by this hash table's <code>SizeType</code>, a <code>std::length_error</code> exception will be thrown. The behavior is undefined unless <code>hint</code> points to a node in this hash table. </p>

</div>
</div>
<a class="anchor" id="a55ed694c2a21d05367dee017c0500bf4"></a><!-- doxytag: member="bslstl::HashTable::insertIfMissing" ref="a55ed694c2a21d05367dee017c0500bf4" args="(bool *isInsertedFlag, const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insertIfMissing </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>isInsertedFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e4f6cdb2135640784a69d6dd3061d85"></a><!-- doxytag: member="bslstl::HashTable::insertIfMissing" ref="a3e4f6cdb2135640784a69d6dd3061d85" args="(bool *isInsertedFlag, const ValueType &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insertIfMissing </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>isInsertedFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of an element in this hash table having a key that compares equal to the key of the specified <code>value</code> using the <code>comparator</code> functor of this hash-table. If no such element exists, insert a <code>value</code> into this hash-table and return the address of that newly inserted node. Load <code>true</code> into the specified <code>isInsertedFlag</code> if insertion is performed, and <code>false</code> if an existing element having a matching key was found. If this hash-table contains more than one element with a matching key, return the first such element (from the contiguous sequence of elements having a matching key). Additional buckets will be allocated, as needed, to preserve the invariant <code>loadFactor &lt;= maxLoadFactor</code>. If this function tries to allocate a number of buckets larger than can be represented by this hash table's <code>SizeType</code>, a <code>std::length_error</code> exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="ae3c56e3ea3fc0017e85703ae6b99a43e"></a><!-- doxytag: member="bslstl::HashTable::insertIfMissing" ref="ae3c56e3ea3fc0017e85703ae6b99a43e" args="(const KeyType &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insertIfMissing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a link holding an element whose key has the same value as the specified <code>key</code> (according to this hash-table's <code>comparator</code>), and, if no such link exists, insert a new link having a default value with a key that is the same as <code>key</code>. If this hash-table contains more than one element with the supplied <code>key</code>, return the first such element (from the contiguous sequence of elements having a matching key). Additional buckets will be allocated, as needed, to preserve the invariant <code>loadFactor &lt;= maxLoadFactor</code>. If this function tries to allocate a number of buckets larger than can be represented by this hash table's <code>SizeType</code>, a <code>std::length_error</code> exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a1ce78c8168d956298f1a25a104f998d3"></a><!-- doxytag: member="bslstl::HashTable::rehashForNumBuckets" ref="a1ce78c8168d956298f1a25a104f998d3" args="(SizeType newNumBuckets)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::rehashForNumBuckets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>newNumBuckets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Re-organize this hash-table to have at least the specified <code>newNumBuckets</code>, preserving the invariant <code>loadFactor &lt;= maxLoadFactor</code>. If this function tries to allocate a number of buckets larger than can be represented by this hash table's <code>SizeType</code>, a <code>std::length_error</code> exception will be thrown. This operation provides the strong exception guarantee (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) unless the <code>hasher</code> throws, in which case this operation provides the basic exception guarantee, leaving the hash-table in a valid, but otherwise unspecified (and potentially empty), state. Note that more buckets than requested may be allocated in order to preserve the bucket allocation strategy of the hash table (but never fewer). </p>

</div>
</div>
<a class="anchor" id="aa685fb6a44c04fb6ae62cf9ab58b0fe7"></a><!-- doxytag: member="bslstl::HashTable::remove" ref="aa685fb6a44c04fb6ae62cf9ab58b0fe7" args="(bslalg::BidirectionalLink *node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the specified <code>node</code> from this hash-table, and return the address of the node immediately after <code>node</code> this hash-table (prior to its removal), or a null pointer value if <code>node</code> is the last node in the table. The behavior is undefined unless <code>node</code> refers to a node in this hash-table. </p>

</div>
</div>
<a class="anchor" id="afffb07f59df454ee2b4c5e1715f20a33"></a><!-- doxytag: member="bslstl::HashTable::removeAll" ref="afffb07f59df454ee2b4c5e1715f20a33" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::removeAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the elements from this hash-table. Note that this hash-table is empty after this call, but allocated memory may be retained for future use. The destructor of each (non-trivial) element that is remove shall be run. </p>

</div>
</div>
<a class="anchor" id="aa036505276fa2bba893faed0b91ec468"></a><!-- doxytag: member="bslstl::HashTable::reserveForNumElements" ref="aa036505276fa2bba893faed0b91ec468" args="(SizeType numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::reserveForNumElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Re-organize this hash-table to have a sufficient number of buckets to accommodate at least the specified <code>numElements</code> without exceeding the <code>maxLoadFactor</code>, and ensure that that there are sufficient nodes pre-allocated in this object's node pool. If this function tries to allocate a number of buckets larger than can be represented by this hash table's <code>SizeType</code>, a <code>std::length_error</code> exception will be thrown. This operation provides the strong exception guarantee (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) unless the <code>hasher</code> throws, in which case this operation provides the basic exception guarantee, leaving the hash-table in a valid, but otherwise unspecified (and potentially empty), state. </p>

</div>
</div>
<a class="anchor" id="a21d2beaab71042fc239f982acce58e60"></a><!-- doxytag: member="bslstl::HashTable::setMaxLoadFactor" ref="a21d2beaab71042fc239f982acce58e60" args="(float newMaxLoadFactor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::setMaxLoadFactor </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newMaxLoadFactor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the maximum load factor permitted by this hash table to the specified <code>newMaxLoadFactor</code>, where load factor is the statistical mean number of elements per bucket. If 'newMaxLoadFactor &lt; loadFactor', allocate at least enough buckets to re-establish the invariant <code>loadFactor &lt;= maxLoadFactor</code>. If this function tries to allocate a number of buckets larger than can be represented by this hash table's <code>SizeType</code>, a <code>std::length_error</code> exception will be thrown. The behavior is undefined unless <code>0 &lt; maxLoadFactor</code>. </p>

</div>
</div>
<a class="anchor" id="a2266a7d27b3062f662954969eadccf4b"></a><!-- doxytag: member="bslstl::HashTable::swap" ref="a2266a7d27b3062f662954969eadccf4b" args="(HashTable &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object, its <code>comparator</code> functor, its <code>hasher</code> functor, and its <code>maxLoadFactor</code> with those of the specified <code>other</code> object. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee unless any of the <code>comparator</code> or <code>hasher</code> functors throw when swapped, leaving both objects in an safely destructible, but otherwise unusable, state. The operation guarantees O[1] complexity. The behavior is undefined unless either this object has an allocator that compares equal to the allocator of <code>other</code>, or the trait <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="a14bd5ea4c9036e7cc07e6dbd2052a70b"></a><!-- doxytag: member="bslstl::HashTable::allocator" ref="a14bd5ea4c9036e7cc07e6dbd2052a70b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ALLOCATOR <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a copy of the allocator used to construct this hash table. Note that this is not the allocator used to allocate elements for this hash table, which is instead a copy of that allocator rebound to allocate the nodes used by the internal data structure of this hash table. </p>

</div>
</div>
<a class="anchor" id="aeee49aabe8b5520d37fce4fab6da7b55"></a><!-- doxytag: member="bslstl::HashTable::bucketAtIndex" ref="aeee49aabe8b5520d37fce4fab6da7b55" args="(SizeType index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a>&amp; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::bucketAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference offering non-modifiable access to the <code>HashTableBucket</code> at the specified <code>index</code> position in the array of buckets of this table. The behavior is undefined unless 'index &lt; <a class="el" href="classbslstl_1_1HashTable.html#a23af09936478ee2a3c49b957952b310e">numBuckets()</a>'. </p>

</div>
</div>
<a class="anchor" id="a265f8fe39b93361ad49fc955e67aeaa3"></a><!-- doxytag: member="bslstl::HashTable::bucketIndexForKey" ref="a265f8fe39b93361ad49fc955e67aeaa3" args="(const KeyType &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::bucketIndexForKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the bucket that would contain all the elements having the specified <code>key</code>. </p>

</div>
</div>
<a class="anchor" id="aee72ed54311d229091d2ee1cff829f1d"></a><!-- doxytag: member="bslstl::HashTable::comparator" ref="aee72ed54311d229091d2ee1cff829f1d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const COMPARATOR&amp; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::comparator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the key-equality comparison functor used by this hash table. </p>

</div>
</div>
<a class="anchor" id="a0a832a91848f46d46b08b73d45076dd5"></a><!-- doxytag: member="bslstl::HashTable::countElementsInBucket" ref="a0a832a91848f46d46b08b73d45076dd5" args="(SizeType index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::countElementsInBucket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number elements contained in the bucket at the specified <code>index</code>. Note that this operation has linear run-time complexity with respect to the number of elements in the indexed bucket. </p>

</div>
</div>
<a class="anchor" id="a0048e907eba27fb3214e62dde3fc6e0e"></a><!-- doxytag: member="bslstl::HashTable::elementListRoot" ref="a0048e907eba27fb3214e62dde3fc6e0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::elementListRoot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the first element in this hash table, or a null pointer value if this hash table is empty. </p>

</div>
</div>
<a class="anchor" id="a0e44ea833c36703b2365e905bc56a2ed"></a><!-- doxytag: member="bslstl::HashTable::find" ref="a0e44ea833c36703b2365e905bc56a2ed" args="(const KeyType &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a link whose key has the same value as the specified <code>key</code> (according to this hash-table's <code>comparator</code>), and a null pointer value if no such link exists. If this hash-table contains more than one element having the supplied <code>key</code>, return the first such element (from the contiguous sequence of elements having the same key). </p>

</div>
</div>
<a class="anchor" id="ad49180ddbef4d772672ee7d7ffce8dfe"></a><!-- doxytag: member="bslstl::HashTable::findEndOfRange" ref="ad49180ddbef4d772672ee7d7ffce8dfe" args="(bslalg::BidirectionalLink *first) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::findEndOfRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>first</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the first node after any nodes holding a value having the same key as the specified <code>first</code> node (according to this hash-table's <code>comparator</code>), and a null pointer value if all nodes following <code>first</code> hold values with the same key as <code>first</code>. The behavior is undefined unless <code>first</code> is a link in this hash- table. Note that this hash-table ensures all elements having the same key form a contiguous sequence. </p>

</div>
</div>
<a class="anchor" id="a2d96732e4f144e3bae3ed98ae88e5737"></a><!-- doxytag: member="bslstl::HashTable::findRange" ref="a2d96732e4f144e3bae3ed98ae88e5737" args="(bslalg::BidirectionalLink **first, bslalg::BidirectionalLink **last, const KeyType &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::findRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> **&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> **&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>first</code> and <code>last</code> pointers the respective addresses of the first and last link (in the list of elements owned by this hash table) where the contained elements have a key that compares equal to the specified <code>key</code> using the <code>comparator</code> of this hash-table, and null pointers values if there are no elements matching <code>key</code>. Note that the output values will form a closed range, where both <code>first</code> and <code>last</code> point to links satisfying the predicate (rather than a semi-open range where <code>last</code> would point to the element following the range). Also note that this hash-table ensures all elements having the same key form a contiguous sequence. </p>

</div>
</div>
<a class="anchor" id="a81f2db5f7b1d834ae2b0a00dcda3342b"></a><!-- doxytag: member="bslstl::HashTable::hasSameValue" ref="a81f2db5f7b1d834ae2b0a00dcda3342b" args="(const HashTable &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::hasSameValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>other</code> has the same value as this object, and <code>false</code> otherwise. Two <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> objects have the same value if they have the same number of elements, and for every subset of elements in this object having keys that compare equal (according to that hash table's <code>comparator</code>), a corresponding subset of elements exists in the <code>other</code> object, having the same number of elements, where, for some permutation of the subset in this object, every element in that subset compares equal (using <code>operator==</code>) to the corresponding element in the <code>other</code> subset. This method requires that the <code>ValueType</code> of the parameterized <code>KEY_CONFIG</code> be <a href="group__bslstl__hashtable.html#requirements_on_key_config.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__hashtable.html#requirements_on_key_config" class="el">Requirements on <code>KEY_CONFIG</code></a>). The behavior is undefined unless both the <code>hasher</code> and <code>comparator</code> of this object and the <code>other</code> return the same value for every valid input. </p>

</div>
</div>
<a class="anchor" id="abb50661b1e2479fb6d078871e9455954"></a><!-- doxytag: member="bslstl::HashTable::hasher" ref="abb50661b1e2479fb6d078871e9455954" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const HASHER&amp; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::hasher </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the hash functor used by this hash-table. </p>

</div>
</div>
<a class="anchor" id="a4a0fdbf6fa943b2a16d8122103b9aeed"></a><!-- doxytag: member="bslstl::HashTable::loadFactor" ref="a4a0fdbf6fa943b2a16d8122103b9aeed" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::loadFactor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current load factor for this table. The load factor is the statistical mean number of elements per bucket. </p>

</div>
</div>
<a class="anchor" id="ac514b3479dfdd8c7d15e1b71a0f0471c"></a><!-- doxytag: member="bslstl::HashTable::maxLoadFactor" ref="ac514b3479dfdd8c7d15e1b71a0f0471c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::maxLoadFactor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum load factor permitted by this hash table object, where the load factor is the statistical mean number of elements per bucket. Note that this hash table will enforce the maximum load factor by rehashing into a larger array of buckets on any any insertion operation where a successful insertion would exceed the maximum load factor. The maximum load factor may actually be less than the current load factor if the maximum load factor has been reset, but no insert operations have yet occurred. </p>

</div>
</div>
<a class="anchor" id="a78d4960a36f7c8fa496850042fbbaf9b"></a><!-- doxytag: member="bslstl::HashTable::maxNumBuckets" ref="a78d4960a36f7c8fa496850042fbbaf9b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::maxNumBuckets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of buckets that this hash-table could possibly have. Note that there is no guarantee that the hash-table can successfully maintain that number of buckets, or even close to that number of buckets without running out of resources. </p>

</div>
</div>
<a class="anchor" id="a59b2de4faa950717a5f41dbee0d6377f"></a><!-- doxytag: member="bslstl::HashTable::maxSize" ref="a59b2de4faa950717a5f41dbee0d6377f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::maxSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that this hash-table could possibly hold. Note that there is no guarantee that the hash-table can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="a23af09936478ee2a3c49b957952b310e"></a><!-- doxytag: member="bslstl::HashTable::numBuckets" ref="a23af09936478ee2a3c49b957952b310e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::numBuckets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of buckets contained in this hash table. </p>

</div>
</div>
<a class="anchor" id="af319d605a8ccfefd1a5dc194bf1de14a"></a><!-- doxytag: member="bslstl::HashTable::rehashThreshold" ref="af319d605a8ccfefd1a5dc194bf1de14a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::rehashThreshold </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements this hash table can hold without requiring a rehash operation in order to respect the <code>maxLoadFactor</code>. </p>

</div>
</div>
<a class="anchor" id="a7ac0e7f04be89ec149a35bc128d22dc9"></a><!-- doxytag: member="bslstl::HashTable::size" ref="a7ac0e7f04be89ec149a35bc128d22dc9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this hash table. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslstl__hashtable_8h_source.html">bslstl_hashtable.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:44 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
