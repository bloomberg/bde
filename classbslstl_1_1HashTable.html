<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Class bslstl::HashTable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslstl.html">bslstl</a>      </li>
      <li><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslstl::HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslstl::HashTable" -->
<p><code>#include &lt;<a class="el" href="bslstl__hashtable_8h_source.html">bslstl_hashtable.h</a>&gt;</code></p>

<p><a href="classbslstl_1_1HashTable-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ImplParameters</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a1d065f7c792ed72c7a408fed3492dbfb">AllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classbslstl_1_1HashTable.html#a1d065f7c792ed72c7a408fed3492dbfb">AllocatorType</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a53f7a06c05942466bae032b67d62265c">AllocatorTraits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY_CONFIG::KeyType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY_CONFIG::ValueType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode</a><br class="typebreak"/>
&lt; <a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a0e8f9d9687085e2e6dd424c095509d45">NodeType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__bslstl__allocatortraits.html#gae5fea114d04c6a2615a8c75e820f9364">AllocatorTraits::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#ac9f1d7328021a279c4df5fc955cba4b0">HashTable</a> (const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#af3dd64dd570f78ee25977edf31c56048">HashTable</a> (const HASHER &amp;hash, const COMPARATOR &amp;compare, <a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> initialNumBuckets, const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#afb3d75d57c8bb990c2e4c73406ea32c0">HashTable</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#affbe891c4d69ac8b74800ce8cf8ab38d">HashTable</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;original, const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#adaad010e62109e9b9ad58ef3d9d1c147">~HashTable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a9273aac7e35b9164447ee4bd06fb9905">operator=</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a4b2d0837f045d05cf4c6fa165ce734f8">insert</a> (const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a2388bb4460b76912a71daab2e0e8050a">insert</a> (const SOURCE_TYPE &amp;value, <a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *hint)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a55ed694c2a21d05367dee017c0500bf4">insertIfMissing</a> (bool *isInsertedFlag, const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#ae3c56e3ea3fc0017e85703ae6b99a43e">insertIfMissing</a> (const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aa685fb6a44c04fb6ae62cf9ab58b0fe7">remove</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#afffb07f59df454ee2b4c5e1715f20a33">removeAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a1ce78c8168d956298f1a25a104f998d3">rehashForNumBuckets</a> (<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> newNumBuckets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a1be5c153b36484457546db3573099fc4">rehashForNumElements</a> (<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a09209c451d0c232a9e74ba23fd38047f">setMaxLoadFactor</a> (float loadFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a2266a7d27b3062f662954969eadccf4b">swap</a> (<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a14bd5ea4c9036e7cc07e6dbd2052a70b">allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const COMPARATOR &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aee72ed54311d229091d2ee1cff829f1d">comparator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const HASHER &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#abb50661b1e2479fb6d078871e9455954">hasher</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a7ac0e7f04be89ec149a35bc128d22dc9">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a59b2de4faa950717a5f41dbee0d6377f">maxSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a23af09936478ee2a3c49b957952b310e">numBuckets</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a78d4960a36f7c8fa496850042fbbaf9b">maxNumBuckets</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a4a0fdbf6fa943b2a16d8122103b9aeed">loadFactor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#ac514b3479dfdd8c7d15e1b71a0f0471c">maxLoadFactor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a0048e907eba27fb3214e62dde3fc6e0e">elementListRoot</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a0e44ea833c36703b2365e905bc56a2ed">find</a> (const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a2d96732e4f144e3bae3ed98ae88e5737">findRange</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> **first, <a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> **last, const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#ad49180ddbef4d772672ee7d7ffce8dfe">findEndOfRange</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *first) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a265f8fe39b93361ad49fc955e67aeaa3">bucketIndexForKey</a> (const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#aeee49aabe8b5520d37fce4fab6da7b55">bucketAtIndex</a> (<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html#a0a832a91848f46d46b08b73d45076dd5">countElementsInBucket</a> (<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> index) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class KEY_CONFIG, class HASHER, class COMPARATOR, class ALLOCATOR = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt;<br/>
 class bslstl::HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;</h3>

<p>This class template implements a value-semantic container type holding an unordered sequence of (possibly duplicate) elements, that can be rapidly accessed using their key, with the constraint on the container that elements whose keys compare equal according to the specified <code>COMPARATOR</code> will be stored in a stable, contiguous sequence within the container. The value type and key type of the elements maintained by a <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> are determined by aliases provided through the (template parameter) type <code>KEY_CONFIG</code>. Elements in a <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> are stored in "nodes" that are allocated using an allocator of the specified <code>ALLOCATOR</code> type (rebound to the node type), and elements are constructed directly in the node using the allocator as described in the C++11 standard under the allocator-aware container requirements in ([container.requirements.general], C++11 23.2.1). The (template parameter) types <code>HASHER</code> and <code>COMPARATOR</code> shall be copy-constructible function-objects. <code>HASHER</code> shall support a function call operator compatible with the following statements: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      HASHER              hash;
      KEY_CONFIG::KeyType key;
      std::size_t result = hash(key);
</pre></div><p><br/>
<br/>
 where the definition of the called function meets the requirements of a hash function, as specified in <a href="group__bslstl__hash.html" class="el"><code>bslstl_hash</code></a>. <code>COMPARATOR</code> shall support the a function call operator compatible with the following statements: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      COMPARATOR          compare;
      KEY_CONFIG::KeyType key1, key2;
      <span class="keywordtype">bool</span> result = compare(key1, key2);
</pre></div><p><br/>
<br/>
 where the definition of the called function defines an equivalence relationship on keys that is both reflexive and transitive. The <code>HASHER</code> and <code>COMPARATOR</code> attributes of this class are further constrained, such for any two objects whose keys compare equal by the comparator, shall produce the same value from the hasher.</p>
<p>This class: </p>
<ul>
<li>
<p class="startli">supports a complete set of <em>value-semantic</em> operations</p>
<ul>
<li>
except for <code>bdex</code> serialization </li>
</ul>
<p class="endli"></p>
</li>
<li>
is <em>exception-neutral</em> (agnostic except for the <code>at</code> method)  </li>
<li>
is <em>alias-safe</em>  </li>
<li>
is <code>const</code> <em>thread-safe</em>  </li>
</ul>
<p>For terminology see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a1d065f7c792ed72c7a408fed3492dbfb"></a><!-- doxytag: member="bslstl::HashTable::AllocatorType" ref="a1d065f7c792ed72c7a408fed3492dbfb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html#a1d065f7c792ed72c7a408fed3492dbfb">AllocatorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53f7a06c05942466bae032b67d62265c"></a><!-- doxytag: member="bslstl::HashTable::AllocatorTraits" ref="a53f7a06c05942466bae032b67d62265c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt;<a class="el" href="classbslstl_1_1HashTable.html#a1d065f7c792ed72c7a408fed3492dbfb">AllocatorType</a>&gt; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="structbsl_1_1allocator__traits.html">AllocatorTraits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18d98e658d7de9f649ddbe490ee24738"></a><!-- doxytag: member="bslstl::HashTable::KeyType" ref="a18d98e658d7de9f649ddbe490ee24738" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY_CONFIG::KeyType <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aead7dae40f7e52cb760cbd9c68d33e42"></a><!-- doxytag: member="bslstl::HashTable::ValueType" ref="aead7dae40f7e52cb760cbd9c68d33e42" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY_CONFIG::ValueType <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0e8f9d9687085e2e6dd424c095509d45"></a><!-- doxytag: member="bslstl::HashTable::NodeType" ref="a0e8f9d9687085e2e6dd424c095509d45" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode</a>&lt;<a class="el" href="classbslstl_1_1HashTable.html#aead7dae40f7e52cb760cbd9c68d33e42">ValueType</a>&gt; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1BidirectionalNode.html">NodeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d5e7243cc034a19673909ac19ac6e7f"></a><!-- doxytag: member="bslstl::HashTable::SizeType" ref="a9d5e7243cc034a19673909ac19ac6e7f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__bslstl__allocatortraits.html#gae5fea114d04c6a2615a8c75e820f9364">AllocatorTraits::size_type</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac9f1d7328021a279c4df5fc955cba4b0"></a><!-- doxytag: member="bslstl::HashTable::HashTable" ref="ac9f1d7328021a279c4df5fc955cba4b0" args="(const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> object. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. Use a default constructed object of the (template parameter) type <code>HASHER</code> and a default constructed object of the (template parameter) type <code>COMPARATOR</code> to organize elements in the table. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator will be used to supply memory. No memory will be allocated unless the parameterizing <code>HASHER</code> or <code>COMPARATOR</code> allocate memory in their default constructor. </p>

</div>
</div>
<a class="anchor" id="af3dd64dd570f78ee25977edf31c56048"></a><!-- doxytag: member="bslstl::HashTable::HashTable" ref="af3dd64dd570f78ee25977edf31c56048" args="(const HASHER &amp;hash, const COMPARATOR &amp;compare, SizeType initialNumBuckets, const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const HASHER &amp;&nbsp;</td>
          <td class="paramname"> <em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>initialNumBuckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty hash-table using the specified <code>hash</code> and <code>compare</code> functors to organize elements in the table, which will initially have at least the specified <code>initialNumBuckets</code>. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator will be used to supply memory. Note that more than <code>initialNumBuckets</code> buckets may be created in order to preserve the bucket allocation strategy of the hash-table (but never fewer). </p>

</div>
</div>
<a class="anchor" id="afb3d75d57c8bb990c2e4c73406ea32c0"></a><!-- doxytag: member="bslstl::HashTable::HashTable" ref="afb3d75d57c8bb990c2e4c73406ea32c0" args="(const HashTable &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> having the same value as the specified <code>original</code>. Use a copy of <code>original.hasher()</code> and a copy of <code>original.comparator()</code> to organize elements in this hash-table. Use the allocator returned by 'bslallocator_traits&lt;ALLOCATOR&gt;:: select_on_container_copy_construction(original.allocator())' to allocate memory. If the type <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), the currently installed default allocator will be used to supply memory. Note that this hash-table may have fewer buckets than <code>original</code>, and a correspondingly higher <code>loadFactor</code>, so long as <code>maxLoadFactor</code> is not exceeded. </p>

</div>
</div>
<a class="anchor" id="affbe891c4d69ac8b74800ce8cf8ab38d"></a><!-- doxytag: member="bslstl::HashTable::HashTable" ref="affbe891c4d69ac8b74800ce8cf8ab38d" args="(const HashTable &amp;original, const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> having the same value as the specified <code>original</code> that will use the specified <code>allocator</code> to supply memory if the (template parameter) type <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), and a default constructed <code>ALLOCATOR</code> object otherwise. Use a copy of <code>original.hasher()</code> and a copy of <code>original.comparator()</code> to organize elements in this hash-table. Note that this hash-table may have fewer buckets than <code>original</code>, and a correspondingly higher <code>loadFactor</code>, so long as <code>maxLoadFactor</code> is not exceeded. </p>

</div>
</div>
<a class="anchor" id="adaad010e62109e9b9ad58ef3d9d1c147"></a><!-- doxytag: member="bslstl::HashTable::~HashTable" ref="adaad010e62109e9b9ad58ef3d9d1c147" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::~<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9273aac7e35b9164447ee4bd06fb9905"></a><!-- doxytag: member="bslstl::HashTable::operator=" ref="a9273aac7e35b9164447ee4bd06fb9905" args="(const HashTable &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&amp; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value, hasher, and comparator of the specified <code>rhs</code> object, replace the allocator of this object with the allocator of <code>rhs</code> if the <code>ALLOCATOR</code> type has the trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. This method requires that the parameterized <code>HASHER</code> and <code>COMPARATOR</code> types be <a href="group__bslstl__hashtable.html#requirements_on_key_config.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__hashtable.html#requirements_on_key_config" class="el">Requirements on <code>KEY_CONFIG</code></a>). The behavior is undefined unless this object's allocator and the allocator of <code>rhs</code> have the same value, or the <code>ALLOCATOR</code> type has the trait <code>propagate_on_container_copy_assignment</code>. </p>

</div>
</div>
<a class="anchor" id="a4b2d0837f045d05cf4c6fa165ce734f8"></a><!-- doxytag: member="bslstl::HashTable::insert" ref="a4b2d0837f045d05cf4c6fa165ce734f8" args="(const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this hash-table, and return the address of the new node. If this hash-table already contains an element having the same key as <code>value</code> (according to this hash- table's <code>comparator</code>) then insert <code>value</code> immediately before the first element having the same key. </p>

</div>
</div>
<a class="anchor" id="a2388bb4460b76912a71daab2e0e8050a"></a><!-- doxytag: member="bslstl::HashTable::insert" ref="a2388bb4460b76912a71daab2e0e8050a" args="(const SOURCE_TYPE &amp;value, bslalg::BidirectionalLink *hint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>hint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this hash table, and return the address of the new node. If the element stored in the node pointer to by the specified <code>hint</code> has a key that compares equal to that of <code>value</code> then <code>value</code> will be inserted immediately preceding <code>hint</code> in the list of this hash table. The behavior is undefined unless <code>hint</code> points to a node in this hash table. </p>

</div>
</div>
<a class="anchor" id="a55ed694c2a21d05367dee017c0500bf4"></a><!-- doxytag: member="bslstl::HashTable::insertIfMissing" ref="a55ed694c2a21d05367dee017c0500bf4" args="(bool *isInsertedFlag, const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insertIfMissing </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>isInsertedFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of an element in this hash table having a key that compares equal to the key of the specified <code>value</code> using the <code>comparator</code> functor of this hash-table. If no such element exists, insert a <code>value</code> into this hash-table and return the address of that newly inserted node. Load <code>true</code> into the specified <code>isInsertedFlag</code> if insertion is performed, and <code>false</code> if an existing element having a matching key was found. If this hash-table contains more than one element with a matching key, return the first such element (from the contiguous sequence of elements having a matching key). </p>

</div>
</div>
<a class="anchor" id="ae3c56e3ea3fc0017e85703ae6b99a43e"></a><!-- doxytag: member="bslstl::HashTable::insertIfMissing" ref="ae3c56e3ea3fc0017e85703ae6b99a43e" args="(const KeyType &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::insertIfMissing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a link holding an element whose key has the same value as the specified <code>key</code> (according to this hash-table's <code>comparator</code>), and, if no such link exists, insert a new link having a default value with a key that is the same as <code>key</code>. If this hash-table contains more than one element with the supplied <code>key</code>, return the first such element (from the contiguous sequence of elements having a matching key). </p>

</div>
</div>
<a class="anchor" id="aa685fb6a44c04fb6ae62cf9ab58b0fe7"></a><!-- doxytag: member="bslstl::HashTable::remove" ref="aa685fb6a44c04fb6ae62cf9ab58b0fe7" args="(bslalg::BidirectionalLink *node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the specified <code>node</code> from this hash-table, and return the address of the node immediately after <code>node</code> this hash-table (prior to its removal), or a null pointer value if <code>node</code> is the last node in the table. The behavior is undefined unless <code>node</code> refers to a node in this hash-table. </p>

</div>
</div>
<a class="anchor" id="afffb07f59df454ee2b4c5e1715f20a33"></a><!-- doxytag: member="bslstl::HashTable::removeAll" ref="afffb07f59df454ee2b4c5e1715f20a33" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::removeAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the elements from this hash-table. Note that this hash-table is empty after this call, but allocated memory may be retained for future use. The destructor of each (non-trivial) element that is remove shall be run. </p>

</div>
</div>
<a class="anchor" id="a1ce78c8168d956298f1a25a104f998d3"></a><!-- doxytag: member="bslstl::HashTable::rehashForNumBuckets" ref="a1ce78c8168d956298f1a25a104f998d3" args="(SizeType newNumBuckets)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::rehashForNumBuckets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>newNumBuckets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Re-organize this hash-table to have at least the specified <code>newNumBuckets</code>. This operation provides the strong exception guarantee (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) unless either <code>hasher</code> or <code>comparator</code> throws, in which case this operation provides the basic exception guarantee, leaving the hash-table in a valid, but otherwise unspecified (and potentially empty), state. Note that more buckets than requested may be allocated in order to preserve the bucket allocation strategy of the hash table (but never fewer). </p>

</div>
</div>
<a class="anchor" id="a1be5c153b36484457546db3573099fc4"></a><!-- doxytag: member="bslstl::HashTable::rehashForNumElements" ref="a1be5c153b36484457546db3573099fc4" args="(SizeType numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::rehashForNumElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Re-organize this hash-table to have a sufficient number of buckets to accommodate the specified <code>numElements</code> without exceeding <code>maxLoadFactor</code>. This operation provides the strong exception guarantee (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) unless either <code>hasher</code> or <code>comparator</code> throws, in which case this operation provides the basic exception guarantee, leaving the hash-table in a valid, but otherwise unspecified (and potentially empty), state. </p>

</div>
</div>
<a class="anchor" id="a09209c451d0c232a9e74ba23fd38047f"></a><!-- doxytag: member="bslstl::HashTable::setMaxLoadFactor" ref="a09209c451d0c232a9e74ba23fd38047f" args="(float loadFactor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::setMaxLoadFactor </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>loadFactor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the maximum load factor permitted by this hash table to the specified <code>loadFactor</code>, where load factor is the statistical mean number of elements per bucket. This hash table will enforce the maximum load factor by rehashing into a larger array of buckets on any any insertion operation where a successful insertion would exceed the maximum load factor. The maximum load factor may actually be less than the current load factor after calling this method, until the next insertion operation is called. The behavior is undefined unless <code>0 &lt; loadFactor</code>. </p>

</div>
</div>
<a class="anchor" id="a2266a7d27b3062f662954969eadccf4b"></a><!-- doxytag: member="bslstl::HashTable::swap" ref="a2266a7d27b3062f662954969eadccf4b" args="(HashTable &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object, its <code>comparator</code> functor and its <code>hasher</code> function, with those of the specified <code>other</code> object. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee unless any of the <code>comparator</code> or <code>hasher</code> functors throw when swapped, leaving both objects in an safely destructible, but otherwise unusable, state. The operation guarantees O[1] complexity. The behavior is undefined unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="a14bd5ea4c9036e7cc07e6dbd2052a70b"></a><!-- doxytag: member="bslstl::HashTable::allocator" ref="a14bd5ea4c9036e7cc07e6dbd2052a70b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ALLOCATOR <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a copy of the allocator used to construct this hash table. Note that this is not the allocator used to allocate elements for this hash table, which is instead a copy of that allocator rebound to allocate the nodes used by the internal data structure of this hash table. </p>

</div>
</div>
<a class="anchor" id="aee72ed54311d229091d2ee1cff829f1d"></a><!-- doxytag: member="bslstl::HashTable::comparator" ref="aee72ed54311d229091d2ee1cff829f1d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const COMPARATOR&amp; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::comparator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the key-equality comparison functor used by this hash table. </p>

</div>
</div>
<a class="anchor" id="abb50661b1e2479fb6d078871e9455954"></a><!-- doxytag: member="bslstl::HashTable::hasher" ref="abb50661b1e2479fb6d078871e9455954" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const HASHER&amp; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::hasher </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the hash functor used by this hash-table. </p>

</div>
</div>
<a class="anchor" id="a7ac0e7f04be89ec149a35bc128d22dc9"></a><!-- doxytag: member="bslstl::HashTable::size" ref="a7ac0e7f04be89ec149a35bc128d22dc9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this hash table. </p>

</div>
</div>
<a class="anchor" id="a59b2de4faa950717a5f41dbee0d6377f"></a><!-- doxytag: member="bslstl::HashTable::maxSize" ref="a59b2de4faa950717a5f41dbee0d6377f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::maxSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that this hash-table could possibly hold. Note that there is no guarantee that the hash-table can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="a23af09936478ee2a3c49b957952b310e"></a><!-- doxytag: member="bslstl::HashTable::numBuckets" ref="a23af09936478ee2a3c49b957952b310e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::numBuckets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of buckets contained in this hash table. </p>

</div>
</div>
<a class="anchor" id="a78d4960a36f7c8fa496850042fbbaf9b"></a><!-- doxytag: member="bslstl::HashTable::maxNumBuckets" ref="a78d4960a36f7c8fa496850042fbbaf9b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::maxNumBuckets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of buckets that this hash-table could possibly have. Note that there is no guarantee that the hash-table can successfully maintain that number of buckets, or even close to that number of buckets without running out of resources. </p>

</div>
</div>
<a class="anchor" id="a4a0fdbf6fa943b2a16d8122103b9aeed"></a><!-- doxytag: member="bslstl::HashTable::loadFactor" ref="a4a0fdbf6fa943b2a16d8122103b9aeed" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::loadFactor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current load factor for this table. The load factor is the statical mean number of elements per bucket. </p>

</div>
</div>
<a class="anchor" id="ac514b3479dfdd8c7d15e1b71a0f0471c"></a><!-- doxytag: member="bslstl::HashTable::maxLoadFactor" ref="ac514b3479dfdd8c7d15e1b71a0f0471c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::maxLoadFactor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum load factor permitted by this hash table object, where the load factor is the statistical mean number of elements per bucket. Note that this hash table will enforce the maximum load factor by rehashing into a larger array of buckets on any any insertion operation where a successful insertion would exceed the maximum load factor. The maximum load factor may actually be less than the current load factor if the maximum load factor has been reset, but no insert operations have yet occurred. </p>

</div>
</div>
<a class="anchor" id="a0048e907eba27fb3214e62dde3fc6e0e"></a><!-- doxytag: member="bslstl::HashTable::elementListRoot" ref="a0048e907eba27fb3214e62dde3fc6e0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::elementListRoot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the first element in this hash table, or a null pointer value if this hash table is empty. </p>

</div>
</div>
<a class="anchor" id="a0e44ea833c36703b2365e905bc56a2ed"></a><!-- doxytag: member="bslstl::HashTable::find" ref="a0e44ea833c36703b2365e905bc56a2ed" args="(const KeyType &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a link whose key has the same value as the specified <code>key</code> (according to this hash-table's <code>comparator</code>), and a null pointer value if no such link exists. If this hash-table contains more than one element having the supplied <code>key</code>, return the first such element (from the contiguous sequence of elements having the same key). </p>

</div>
</div>
<a class="anchor" id="a2d96732e4f144e3bae3ed98ae88e5737"></a><!-- doxytag: member="bslstl::HashTable::findRange" ref="a2d96732e4f144e3bae3ed98ae88e5737" args="(bslalg::BidirectionalLink **first, bslalg::BidirectionalLink **last, const KeyType &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::findRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> **&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> **&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>first</code> and <code>last</code> pointers the respective addresses of the first and last link (in the list of elements owned by this hash table) where the contained elements have a key that compares equal to the specified <code>key</code> using the <code>comparator</code> of this hash-table, and null pointers values if there are no elements matching <code>key</code>. Note that the output values will form a closed range, where both <code>first</code> and <code>last</code> point to links satisfying the predicate (rather than a semi-open range where <code>last</code> would point to the element following the range). Also note that this hash-table ensures all elements having the same key form a contiguous sequence. </p>

</div>
</div>
<a class="anchor" id="ad49180ddbef4d772672ee7d7ffce8dfe"></a><!-- doxytag: member="bslstl::HashTable::findEndOfRange" ref="ad49180ddbef4d772672ee7d7ffce8dfe" args="(bslalg::BidirectionalLink *first) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::findEndOfRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>first</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the first node after any nodes holding a value having the same key as the specified <code>first</code> node (according to this hash-table's <code>comparator</code>), and a null pointer value if all nodes following <code>first</code> hold values with the same key as <code>first</code>. The behavior is undefined unless <code>first</code> is a link in this hash- table. Note that this hash-table ensures all elements having the same key form a contiguous sequence. </p>

</div>
</div>
<a class="anchor" id="a265f8fe39b93361ad49fc955e67aeaa3"></a><!-- doxytag: member="bslstl::HashTable::bucketIndexForKey" ref="a265f8fe39b93361ad49fc955e67aeaa3" args="(const KeyType &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::bucketIndexForKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1HashTable.html#a18d98e658d7de9f649ddbe490ee24738">KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the bucket that would contain all the elements having the specified <code>key</code>. </p>

</div>
</div>
<a class="anchor" id="aeee49aabe8b5520d37fce4fab6da7b55"></a><!-- doxytag: member="bslstl::HashTable::bucketAtIndex" ref="aeee49aabe8b5520d37fce4fab6da7b55" args="(SizeType index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a>&amp; <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::bucketAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-modifiable reference to the <code>HashTableBucket</code> at the specified <code>index</code> position in the array of buckets of this table. The behavior is undefined unless <code>index &lt; <a class="el" href="classbslstl_1_1HashTable.html#a23af09936478ee2a3c49b957952b310e">numBuckets()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a0a832a91848f46d46b08b73d45076dd5"></a><!-- doxytag: member="bslstl::HashTable::countElementsInBucket" ref="a0a832a91848f46d46b08b73d45076dd5" args="(SizeType index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR  = ::bsl::allocator&lt;typename KEY_CONFIG::ValueType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a> <a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt;::countElementsInBucket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1HashTable.html#a9d5e7243cc034a19673909ac19ac6e7f">SizeType</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number elements contained in the bucket at the specified <code>index</code>. Note that this operation has linear run-time complexity with respect to the number of elements in the indexed bucket. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslstl__hashtable_8h_source.html">bslstl_hashtable.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:20:06 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
