<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bdlma_localsequentialallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_localsequentialallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an efficient managed allocator using a local buffer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Recommended Usage</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an efficient managed allocator using a local buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1LocalSequentialAllocator.html">bdlma::LocalSequentialAllocator</a> </td><td>allocator using a local buffer  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__bufferedsequentialallocator.html" title="Provide an efficient managed allocator using an external buffer.">Component bdlma_bufferedsequentialallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a concrete mechanism, <code><a class="el" href="classbdlma_1_1LocalSequentialAllocator.html">bdlma::LocalSequentialAllocator</a></code>, that implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> protocol to very efficiently allocate heterogeneous memory blocks (of varying, user-specified sizes) from a local buffer. Note that it derives from <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code> so that the implementations of <code>allocate</code>, <code>deallocate</code>, and <code>release</code> don't need to be instantiated for each user-specified size. <br/>
<br/>
<div class="fragment"><pre class="fragment">    ,-------------------------------.
   ( <a class="code" href="classbdlma_1_1LocalSequentialAllocator.html">bdlma::LocalSequentialAllocator</a> )
    `-------------------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                    |        ctor</span>
<span class="stringliteral">                    V</span>
<span class="stringliteral">   ,----------------------------------.</span>
<span class="stringliteral">  ( bdlma::BufferedSequentialAllocator )</span>
<span class="stringliteral">   `----------------------------------&#39;</span>
                    |        ctor/dtor
                    |        allocate
                    |        deallocate
                    |        release
                    V
        ,-----------------------.
       ( <a class="code" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a> )
        `-----------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                    |        release = 0</span>
<span class="stringliteral">                    V</span>
<span class="stringliteral">           ,----------------.</span>
<span class="stringliteral">          ( bslma::Allocator )</span>
<span class="stringliteral">           `----------------&#39;</span>
                             allocate = 0
                             deallocate = 0
</pre></div><br/>
<br/>
 If an allocation request exceeds the remaining free memory space in the local buffer, the allocator will fall back to a sequence of dynamically-allocated buffers. The <code>release</code> method releases all memory allocated through the allocator, as does the destructor. Note that, even though a <code>deallocate</code> method is available, it has no effect: individually allocated memory blocks cannot be separately deallocated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlma_1_1LocalSequentialAllocator.html">bdlma::LocalSequentialAllocator</a></code> is typically used when users have a reasonable estimation of the amount of memory needed. This amount of memory would then be created directly on the program stack, and used as the local buffer by this allocator for very fast memory allocation. Whilst the buffer has sufficient capacity, memory allocations will not trigger <em>any</em> dynamic memory allocation, will have optimal locality of reference, and will not require deallocation upon destruction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once the local buffer is exhausted, subsequent allocation requests require dynamic memory allocation, and the performance of the allocator degrades. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The main difference between a <code><a class="el" href="classbdlma_1_1LocalSequentialAllocator.html">bdlma::LocalSequentialAllocator</a></code> and a <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code> is that this class internally maintains a buffer, rather than being given one at construction time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_recommended_usage"></a> <a class="anchor" id="usage.example_1~3A_recommended_usage"></a> <a class="anchor" id="description.usage.example_1~3A_recommended_usage"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Recommended Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have a function which takes a map of items to update in some database: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> DatabaseKey;
  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> DatabaseValue;

  <span class="keywordtype">void</span> updateRecords_1(<span class="keyword">const</span> <a class="code" href="classbsl_1_1map.html">bsl::map&lt;DatabaseKey, DatabaseValue&gt;</a>&amp; values)
  {
      <span class="keywordflow">for</span> (<a class="code" href="group__bslstl__map.html#ga22687147e65a99cca9f75f6b044171eb">bsl::map&lt;DatabaseKey, DatabaseValue&gt;::const_iterator</a>
               it = values.<a class="code" href="group__bslstl__map.html#ga001a280ed8a43774968446e80309d985">begin</a>(), end = values.<a class="code" href="group__bslstl__map.html#ga1c9f04a4a747e466cc3956bd5231f76f">end</a>();
           it != end;
           ++it) {
          <a class="code" href="classbsl_1_1basic__stringbuf.html">bsl::stringbuf</a> stringBuf;
          bsl::ostream   ostr(&amp;stringBuf);

          ostr &lt;&lt; <span class="stringliteral">&quot;UPDATE myTable SET myValue = &#39;&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot;&#39; WHERE &quot;</span>
                  <span class="stringliteral">&quot;myKey = &#39;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>;

          <span class="comment">// execute query using &#39;stringBuf.str()&#39;</span>
      }
  }
</pre></div><br/>
<br/>
 We call this method a lot, and after profiling, we notice that it's contributing a significant proportion of time, due to the allocations it is making. We decide to see whether a LocalSequentialAllocator would help. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, use a <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> to track the typical memory usage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> updateRecords_2(<span class="keyword">const</span> <a class="code" href="classbsl_1_1map.html">bsl::map&lt;DatabaseKey, DatabaseValue&gt;</a>&amp; values)
  {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta;

      <span class="keywordflow">for</span> (<a class="code" href="group__bslstl__map.html#ga22687147e65a99cca9f75f6b044171eb">bsl::map&lt;DatabaseKey, DatabaseValue&gt;::const_iterator</a>
               it = values.<a class="code" href="group__bslstl__map.html#ga001a280ed8a43774968446e80309d985">begin</a>(), end = values.<a class="code" href="group__bslstl__map.html#ga1c9f04a4a747e466cc3956bd5231f76f">end</a>();
           it != end;
           ++it) {
          <a class="code" href="classbsl_1_1basic__stringbuf.html">bsl::stringbuf</a> stringBuf(&amp;ta);
          bsl::ostream   ostr(&amp;stringBuf);

          ostr &lt;&lt; <span class="stringliteral">&quot;UPDATE myTable SET myValue = &#39;&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot;&#39; WHERE &quot;</span>
                  <span class="stringliteral">&quot;myKey = &#39;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>;

          <span class="comment">// execute query using &#39;stringBuf.str()&#39;</span>

          bsl::cout &lt;&lt; <span class="stringliteral">&quot;In use: &quot;</span> &lt;&lt; ta.<a class="code" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse</a>() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
      }

      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Max: &quot;</span> &lt;&lt; ta.<a class="code" href="classbslma_1_1TestAllocator.html#af2d1d3784de378c207cf12c71d92b338">numBytesMax</a>() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
  }
</pre></div><br/>
<br/>
 Then we run our program again, and observe the following output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  In use: 77
  In use: 77
  In use: 77
  In use: 77
  In use: 77
  Max: 129
</pre></div><br/>
<br/>
 It looks like 129 is a good choice for the size of our allocator, so we go with that: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> updateRecords_3(<span class="keyword">const</span> <a class="code" href="classbsl_1_1map.html">bsl::map&lt;DatabaseKey, DatabaseValue&gt;</a>&amp; values)
  {
      <a class="code" href="classbdlma_1_1LocalSequentialAllocator.html">bdlma::LocalSequentialAllocator&lt;129&gt;</a> lsa;

      <span class="keywordflow">for</span> (<a class="code" href="group__bslstl__map.html#ga22687147e65a99cca9f75f6b044171eb">bsl::map&lt;DatabaseKey, DatabaseValue&gt;::const_iterator</a>
               it = values.<a class="code" href="group__bslstl__map.html#ga001a280ed8a43774968446e80309d985">begin</a>(), end = values.<a class="code" href="group__bslstl__map.html#ga1c9f04a4a747e466cc3956bd5231f76f">end</a>();
           it != end;
           ++it) {
          lsa.<a class="code" href="classbdlma_1_1BufferedSequentialAllocator.html#a4669495cf776abdaee087303e07df7bb">release</a>();

          <a class="code" href="classbsl_1_1basic__stringbuf.html">bsl::stringbuf</a> stringBuf(&amp;lsa);
          bsl::ostream   ostr(&amp;stringBuf);

          ostr &lt;&lt; <span class="stringliteral">&quot;UPDATE myTable SET myValue = &#39;&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot;&#39; WHERE &quot;</span>
                  <span class="stringliteral">&quot;myKey = &#39;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>;

          <span class="comment">// execute query using &#39;stringBuf.str()&#39;</span>
      }
  }
</pre></div><br/>
<br/>
 Note that we release at the end of every iteration, as the deallocate method is a no-op, so without this, subsequent memory would be allocated from the default allocator (or the allocator passed to <code>bsa</code> at construction). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, we re-profile our code to determine whether the addition of a <code>LocalSequentialAllocator</code> helped. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:19 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
