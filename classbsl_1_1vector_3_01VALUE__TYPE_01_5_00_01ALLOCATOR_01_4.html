<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bsl::vector_3_01VALUE_TYPE_01_5_00_01ALLOCATOR_01_4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebsl.html">bsl</a>      </li>
      <li><a class="el" href="classbsl_1_1vector_3_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.html">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__bslstl__vector.html">Component bslstl_vector</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;" --><!-- doxytag: inherits="Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;" -->
<p><code>#include &lt;<a class="el" href="bslstl__vector_8h_source.html">bslstl_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbsl_1_1vector_3_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.png" usemap="#bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;_map" alt=""/>
  <map id="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;_map" name="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;_map">
<area href="classbsl_1_1Vector__Imp.html" alt="bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;" shape="rect" coords="220,56,651,80"/>
<area href="classbsl_1_1Vector__ImpBase.html" alt="bsl::Vector_ImpBase&lt; void * &gt;" shape="rect" coords="0,0,431,24"/>
<area href="classBloombergLP_1_1bslalg_1_1ContainerBase.html" alt="ContainerBase" shape="rect" coords="441,0,872,24"/>
</map>
</div>

<p><a href="classbsl_1_1vector_3_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga999efeb5f3915fb3501aad640cad4849">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabde26ba05b21196782157a1f8a76dabe">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1376a22b6e9b3c12f1e67dc5f3b1c2f8">allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7c87e3765a9fe91486ad51a3193bdf1e">pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga02cc4f8f85a558c7e6fa47050aa5df4e">const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac6e8391c59e60b5a4dfd48e956f3b1c9">reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadb78a996fed8af2d5899cca9dd1a9bc9">const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga24d7c145ce94bf2f3ae8068569c143b8">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga18f44f5ce10b93d15ea3def898eab913">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga354535932a26dcc4a3021a0db40529ff">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa738a4a015b0459014a402a11f434fa4">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga37a11cdffcc2935872a29b90a5b90f4b">reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga973722bc781447a95bbe3bad22bee7cd">const_reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabaf47fbdf5a80691a93069d8e5041e90">vector</a> (const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0c1cc0f422360c7d58dfcb64f79529c5">vector</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> n, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9ce6f8d6734545c00615962da7f39611">vector</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> n, VALUE_TYPE *value, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga60d71628e72898d8584e3378ed1dfe32">vector</a> (INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga152981423ce926f8024acbd0a976de11">vector</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga818a2d9d0fb6027b41f79612b6f979a1">vector</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a> &amp;original, const ALLOCATOR &amp;alloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6dcf3a85a5d8b27bda092b4a504cc6fa">~vector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1vector.html">vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad28e356adf09adaf80b1f800bcddd5a5">operator=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5de26b249081554ec1cb21b3f7b43df5">assign</a> (INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadefaed4ca7f4d26ff6ee384e0476b124">assign</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> numElements, VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga318ef936958ee98c2f298f1a31b922f7">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga55d52f185850254ecb4b6ec28b9f8d6d">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1b4b7957e130864312eca3df390fb785">rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4288784db009e96af1eff77d09b90fc1">rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae909e329344974ad7fb4e7b424878d36">operator[]</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8fdb6db1c20406556e29c11021c472bb">at</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga81f700b55078ee5468b96fa6ebea55ad">front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5338994a167c6bafe6bbccac8c514795">back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE_TYPE **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae08c76cfbf01f80e7380a994157df568">data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga61a91e79364592b47b626313c961a6e5">resize</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> newLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga23e40cd74587357f81715af062e2eaa9">resize</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> newLength, VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga728a77555f5235b5197ba697837c2cff">push_back</a> (VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae9352c4608b40e6c4230d245f68ae146">insert</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position, VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5a0e0e9d0944dc1ab7bb339c73463b06">insert</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position, <a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> numElements, VALUE_TYPE *value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga463c9e3a03f1a0aded9c067f41c0d06c">insert</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2f4211727f28143130412cdd04df0fb9">erase</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga56f6de18a557d17ee3d26bdd91ac3474">erase</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> first, <a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga1376a22b6e9b3c12f1e67dc5f3b1c2f8">allocator_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga87fc99fbeadf2f8b9e165eb363d1cc81">get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga066fbb8af43cfc8b0c1b86a2a69aad0b">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga60dd96d572ec3b5a62d87a19d4d48860">cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga56af29169db429fdadcf393a67b05045">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3a92029c5fa75db8d4025f90e61bab0e">cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac159e88612a81f0f7be8f213eb2fee03">rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7acd8f6ac7e55437aa76379e6bdf1361">crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga338ccdaed2d290b97203b32aaf928eec">rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga03dbba1d8ff19a8c45b3d617aad600ca">crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga308cd1b4084480a1241a8d47c23b9956">operator[]</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafb049517872ca58d40d1f436ba261203">at</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gacd47d558bbb42957c05d6388f63cd8a8">front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5aca08cd5fd53de3f530fbd9564ab001">back</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE_TYPE *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2f2d08ae008a632d57896127fc34b4b6">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga142315e14e55d68bb9edf0c9c227feb0">assign</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> numElements, const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac5203d4410a4c7c3d1d2014d5542e0d9">resize</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> newSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4fedf6842b169a88be67a5758b3aa229">resize</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> newSize, const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac931be06971aedc190c1191a00ee251a">reserve</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> newCapacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf5dd77d0be1e77193b7289fc08e828ec">shrink_to_fit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga332db0292e3c1107be19e02fd9f22299">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a> (const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8fbe1d9aac697597bce2b527b8208003">pop_back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadeebf7a713dc053843dee059e23e9375">emplace</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position, Args &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa856a23873fe4d5354e0d8b63f0b0659">insert</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position, const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf28f2fa76a6acfe212d1dee103c2dafe">insert</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position, <a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> numElements, const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadc116debf5b1eb8a37aa4d0bd85213b2">insert</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8398ddeb0509741ce8734bc4eb5d5654">erase</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga840ceb3ecb6c53492e8a5b73fbe7501d">erase</a> (<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> first, <a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac169aabe4c02a46527a12822254293ea">swap</a> (<a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae9fa4fec3242df3b8c6a70118726304d">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga66cf2ced34b3c15613d0ba2acc86f5c1">max_size</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0eb1a2336108dd9a87ba8682fe199837">begin</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4f6ee393ad3b6d9a72f13b15a95ea32a">end</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6080200616b755699e352155c7572d98">rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0dd4792a346dae5157c7f4a4f7ee25f9">rbegin</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafe52ce718a880c32d4bd69ed3bc65d3b">rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1f35ca07ac717fbc40e7cf3d755cc61f">rend</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaed1d2854dd5aaf5c0734202f5f43d42d">operator[]</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf92663fe0dfe8dd17097054a4c115626">operator[]</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> position) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gacd7de02bfa273ac7643909b55502e462">at</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf7db0521ebb67c49b5625972ebb0d944">at</a> (<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> position) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga547e809dc68789a250cd367760601d78">front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab884eb9fa93b6f6fb1e748978b6b7136">front</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad737a7196152ddb07b059506a070d149">back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga813678ea2bee5b416ffaae85b1005dd2">back</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad98d192f5ea0af3ec3c6b5dabca1faa3">data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae6c1ea9e07542194c9bd652087e49974">data</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0a53fc2c03dcc45dcba8fe6bf7298259">cbegin</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4a98f38e4458d7323fb526adf8c87da5">cend</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga259f561373a610c2accfdf2961596c7d">crbegin</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf7cd9b62a54f46268ef4d55c8358abbb">crend</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga22982ebdac58b9b9a89e339feeeb8eb6">capacity</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad77dd3f93b278367659e8d1489df4a86">empty</a> () const</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Vector__ImpBase.html#a6b6236ac7aa426aef856d09fe4aa30e2">d_dataBegin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4270c95067ff340ec7469d1411e252ac">d_dataEnd</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabb717a1693d469a315711bddc394a404">d_capacity</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class VALUE_TYPE, class ALLOCATOR&gt;<br/>
 class bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</h3>

<p>This partial specialization of <code>vector</code> for pointer types to a parameterized <code>T</code> type (not <code>const</code>) is implemented in terms of the <code><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt;void *&gt;</code> to reduce the amount of code generated. Note that this specialization rebinds the parameterized <code>ALLOCATOR</code> type to an allocator of <code>void *</code> so as to satisfy the invariant in <code><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a></code>. Also note that members which do not need to be redefined are inherited straightforwardly from the <code>Base</code>, although if an overloaded method needs to be redefined, then all its overloads need to be redefined. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="gac6e8391c59e60b5a4dfd48e956f3b1c9"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::reference" ref="gac6e8391c59e60b5a4dfd48e956f3b1c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void * &amp; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadb78a996fed8af2d5899cca9dd1a9bc9"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_reference" ref="gadb78a996fed8af2d5899cca9dd1a9bc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void *  const&amp; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga24d7c145ce94bf2f3ae8068569c143b8"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::iterator" ref="ga24d7c145ce94bf2f3ae8068569c143b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga18f44f5ce10b93d15ea3def898eab913"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_iterator" ref="ga18f44f5ce10b93d15ea3def898eab913" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void *  const* <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae247ca9f6b273a302bd925b3f0449c0d"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::size_type" ref="gae247ca9f6b273a302bd925b3f0449c0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga354535932a26dcc4a3021a0db40529ff"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::difference_type" ref="ga354535932a26dcc4a3021a0db40529ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga999efeb5f3915fb3501aad640cad4849">difference_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa738a4a015b0459014a402a11f434fa4"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::value_type" ref="gaa738a4a015b0459014a402a11f434fa4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void *  <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#gabde26ba05b21196782157a1f8a76dabe">value_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga37a11cdffcc2935872a29b90a5b90f4b"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::reverse_iterator" ref="ga37a11cdffcc2935872a29b90a5b90f4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;<a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a>&gt; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">reverse_iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga973722bc781447a95bbe3bad22bee7cd"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_reverse_iterator" ref="ga973722bc781447a95bbe3bad22bee7cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;<a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&gt; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ga142315e14e55d68bb9edf0c9c227feb0"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::assign" ref="ga142315e14e55d68bb9edf0c9c227feb0" args="(size_type numElements, const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this vector the value of the vector of the specified <code>numElements</code> size whose every elements equal the specified <code>value</code>. Note that this vector will be left in an empty state in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac5203d4410a4c7c3d1d2014d5542e0d9"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::resize" ref="gac5203d4410a4c7c3d1d2014d5542e0d9" args="(size_type newSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4fedf6842b169a88be67a5758b3aa229"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::resize" ref="ga4fedf6842b169a88be67a5758b3aa229" args="(size_type newSize, const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the size of this vector to the specified <code>newSize</code>, erasing elements at the end if <code>newSize &lt; size()</code> or appending the appropriate number of copies of the optionally specified <code>value</code> at the end if <code>size() &lt; newSize</code>. If <code>value</code> is not specified, a default-constructed value is used. Throw <code>std::length_error</code> if <code>newSize &gt; max_size()</code>. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be "copy-constructible" if <code>value</code> is specified and "default-constructible" otherwise (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac931be06971aedc190c1191a00ee251a"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::reserve" ref="gac931be06971aedc190c1191a00ee251a" args="(size_type newCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newCapacity</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the capacity of this vector to the specified <code>newCapacity</code>. Note that the capacity of a vector is the maximum number of elements it can accommodate without reallocation. The actual storage allocated may be higher. </p>

</div>
</div>
<a class="anchor" id="gaf5dd77d0be1e77193b7289fc08e828ec"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::shrink_to_fit" ref="gaf5dd77d0be1e77193b7289fc08e828ec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reduce the capacity of this vector to its size. The method has no effect if the capacity is equivalent to the size. </p>

</div>
</div>
<a class="anchor" id="ga332db0292e3c1107be19e02fd9f22299"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::emplace_back" ref="ga332db0292e3c1107be19e02fd9f22299" args="(Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a new element to the end of this vector, constructed directly in place from the specified <code>args</code>. The <code>args</code> are passed to the constructor using "perfect forwarding", meaning move semantics will be utilized for rvalued elements that implement them. The combination of constructing in place and "perfect forwarding" means that when move semantics are availible, elements in <code>args</code> will not be copied at all. When move semantics are not availible, elements in <code>args</code> will be copied only once. This method provides the strong exception safety guarentee, so the state of this object will not be changed if an exception is thrown (such as when allocating memory, or from operations of <code>VALUE_TYPE</code>). </p>

</div>
</div>
<a class="anchor" id="gaa1d6a35af66d87307ee9a48be96644a5"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::push_back" ref="gaa1d6a35af66d87307ee9a48be96644a5" args="(const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a copy of the specified <code>value</code> at the end of this vector. This method provides the strong exception safety guarantee, so the state of this object will not be changed if an exception is thrown (such as when allocating memory, or from operations of <code>VALUE_TYPE</code>). This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8fbe1d9aac697597bce2b527b8208003"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::pop_back" ref="ga8fbe1d9aac697597bce2b527b8208003" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase the last element from this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gadeebf7a713dc053843dee059e23e9375"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::emplace" ref="gadeebf7a713dc053843dee059e23e9375" args="(const_iterator position, Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * * <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa856a23873fe4d5354e0d8b63f0b0659"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gaa856a23873fe4d5354e0d8b63f0b0659" args="(const_iterator position, const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a> <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector a copy of the specified <code>value</code>, and return an iterator pointing to the newly inserted element. If <code>value</code> has move semantics, then its value is valid but unspecified upon returning from this function. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code> (both endpoints included). Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaf28f2fa76a6acfe212d1dee103c2dafe"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gaf28f2fa76a6acfe212d1dee103c2dafe" args="(const_iterator position, size_type numElements, const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector a number equal to the specified <code>numElements</code> of copies of the specified <code>value</code>. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code> (both endpoints included). Note that this method offers full guarantee of rollback in case an exception is throw is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gadc116debf5b1eb8a37aa4d0bd85213b2"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gadc116debf5b1eb8a37aa4d0bd85213b2" args="(const_iterator position, INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code> (both endpoints included). Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8398ddeb0509741ce8734bc4eb5d5654"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::erase" ref="ga8398ddeb0509741ce8734bc4eb5d5654" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a> <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this vector the element at the specified <code>position</code>, and return an iterator pointing to the element immediately following the removed element, or to the position returned by the <code>end</code> method if the removed element was the last in the sequence. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() )</code>. </p>

</div>
</div>
<a class="anchor" id="ga840ceb3ecb6c53492e8a5b73fbe7501d"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::erase" ref="ga840ceb3ecb6c53492e8a5b73fbe7501d" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a> <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this vector the elements starting at the specified <code>first</code> position that are before the specified <code>last</code> position, and return an iterator pointing to the element immediately following the last removed element, or the position returned by the method <code>end</code> if the removed elements were last in the sequence. The behavior is undefined unless <code>first</code> is an iterator in the range <code>[ begin(), end() ]</code> and <code>last</code> is an iterator in the range <code>[ first, end() ]</code> (both endpoints included). </p>

</div>
</div>
<a class="anchor" id="gac169aabe4c02a46527a12822254293ea"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::swap" ref="gac169aabe4c02a46527a12822254293ea" args="(Vector_Imp &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this vector with that of the specified <code>other</code> vector, such that each vector has, upon return, the value of the other vector prior to this call. This method does not throw or invalidate iterators if <code>get_allocator</code>, invoked on this vector and <code>other</code>, returns the same value. </p>

</div>
</div>
<a class="anchor" id="gae9fa4fec3242df3b8c6a70118726304d"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::clear" ref="gae9fa4fec3242df3b8c6a70118726304d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the elements from this vector. Note that this vector is empty after this call, but conserves the same capacity. </p>

</div>
</div>
<a class="anchor" id="ga66cf2ced34b3c15613d0ba2acc86f5c1"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::max_size" ref="ga66cf2ced34b3c15613d0ba2acc86f5c1" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; void * , ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum possible size for this vector. Note that requests to create a vector longer than this number of elements are guaranteed to raise a <code>std::length_error</code> exception. </p>

</div>
</div>
<a class="anchor" id="ga5b7f9c7b9b0be302ee1b7533b9764ef1"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::begin" ref="ga5b7f9c7b9b0be302ee1b7533b9764ef1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga0eb1a2336108dd9a87ba8682fe199837"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::begin" ref="ga0eb1a2336108dd9a87ba8682fe199837" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this non-modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga7eb9edf13eb71d39489477702fa09671"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::end" ref="ga7eb9edf13eb71d39489477702fa09671" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga4f6ee393ad3b6d9a72f13b15a95ea32a"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::end" ref="ga4f6ee393ad3b6d9a72f13b15a95ea32a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga6080200616b755699e352155c7572d98"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rbegin" ref="ga6080200616b755699e352155c7572d98" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga0dd4792a346dae5157c7f4a4f7ee25f9"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rbegin" ref="ga0dd4792a346dae5157c7f4a4f7ee25f9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this non-modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="gafe52ce718a880c32d4bd69ed3bc65d3b"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rend" ref="gafe52ce718a880c32d4bd69ed3bc65d3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga1f35ca07ac717fbc40e7cf3d755cc61f"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rend" ref="ga1f35ca07ac717fbc40e7cf3d755cc61f" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="gaed1d2854dd5aaf5c0734202f5f43d42d"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator[]" ref="gaed1d2854dd5aaf5c0734202f5f43d42d" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>position</code> in this vector. The behavior is undefined unless <code>0 &lt;= position &lt; size()</code>. </p>

</div>
</div>
<a class="anchor" id="gaf92663fe0dfe8dd17097054a4c115626"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator[]" ref="gaf92663fe0dfe8dd17097054a4c115626" args="(size_type position) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>position</code> in this vector. The behavior is undefined unless <code>0 &lt;= position &lt; size()</code>. </p>

</div>
</div>
<a class="anchor" id="gacd7de02bfa273ac7643909b55502e462"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::at" ref="gacd7de02bfa273ac7643909b55502e462" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>position</code> in this vector. Throws <code>std::out_of_range</code> if <code>position &gt;= size()</code>. </p>

</div>
</div>
<a class="anchor" id="gaf7db0521ebb67c49b5625972ebb0d944"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::at" ref="gaf7db0521ebb67c49b5625972ebb0d944" args="(size_type position) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>position</code>. Throws <code>std::out_of_range</code> if <code>position &gt;= size()</code>. </p>

</div>
</div>
<a class="anchor" id="ga547e809dc68789a250cd367760601d78"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::front" ref="ga547e809dc68789a250cd367760601d78" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the first position in this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gab884eb9fa93b6f6fb1e748978b6b7136"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::front" ref="gab884eb9fa93b6f6fb1e748978b6b7136" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the first position in this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gad737a7196152ddb07b059506a070d149"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::back" ref="gad737a7196152ddb07b059506a070d149" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the last position in this vector. The behavior is undefined if this vector is empty. Note that the last position is <code>size() - 1</code>. </p>

</div>
</div>
<a class="anchor" id="ga813678ea2bee5b416ffaae85b1005dd2"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::back" ref="ga813678ea2bee5b416ffaae85b1005dd2" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">const_reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the last position in this vector. The behavior is undefined if this vector is empty. Note that the last position is <code>size() - 1</code>. </p>

</div>
</div>
<a class="anchor" id="gad98d192f5ea0af3ec3c6b5dabca1faa3"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::data" ref="gad98d192f5ea0af3ec3c6b5dabca1faa3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable first element in this vector, or a valid, but non-dereferenceable pointer value if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gae6c1ea9e07542194c9bd652087e49974"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::data" ref="gae6c1ea9e07542194c9bd652087e49974" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the non-modifiable first element in this vector, or a valid, but non-dereferenceable pointer value if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="ga0a53fc2c03dcc45dcba8fe6bf7298259"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::cbegin" ref="ga0a53fc2c03dcc45dcba8fe6bf7298259" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this non-modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga4a98f38e4458d7323fb526adf8c87da5"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::cend" ref="ga4a98f38e4458d7323fb526adf8c87da5" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga259f561373a610c2accfdf2961596c7d"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::crbegin" ref="ga259f561373a610c2accfdf2961596c7d" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this non-modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="gaf7cd9b62a54f46268ef4d55c8358abbb"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::crend" ref="gaf7cd9b62a54f46268ef4d55c8358abbb" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">const_reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga6b5f3f3e0564b62536fd52679d99bdbd"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::size" ref="ga6b5f3f3e0564b62536fd52679d99bdbd" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this vector. </p>

</div>
</div>
<a class="anchor" id="ga22982ebdac58b9b9a89e339feeeb8eb6"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::capacity" ref="ga22982ebdac58b9b9a89e339feeeb8eb6" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the capacity of this vector, i.e., the maximum number of elements for which resizing is guaranteed not to trigger a reallocation. </p>

</div>
</div>
<a class="anchor" id="gad77dd3f93b278367659e8d1489df4a86"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::empty" ref="gad77dd3f93b278367659e8d1489df4a86" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this vector has size 0, and <code>false</code> otherwise. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a6b6236ac7aa426aef856d09fe4aa30e2"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::d_dataBegin" ref="a6b6236ac7aa426aef856d09fe4aa30e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="classbsl_1_1Vector__ImpBase.html#a6b6236ac7aa426aef856d09fe4aa30e2">d_dataBegin</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>beginning of data storage (owned) </p>

</div>
</div>
<a class="anchor" id="ga4270c95067ff340ec7469d1411e252ac"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::d_dataEnd" ref="ga4270c95067ff340ec7469d1411e252ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga4270c95067ff340ec7469d1411e252ac">d_dataEnd</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>end of data storage (owned) </p>

</div>
</div>
<a class="anchor" id="gabb717a1693d469a315711bddc394a404"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::d_capacity" ref="gabb717a1693d469a315711bddc394a404" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; void *  &gt;::<a class="el" href="group__bslstl__vector.html#gabb717a1693d469a315711bddc394a404">d_capacity</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>length of storage </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslstl__vector_8h_source.html">bslstl_vector.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:32 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
