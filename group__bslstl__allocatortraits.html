<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslstl_allocatortraits Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_allocatortraits<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a uniform interface to standard allocator types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits&lt; ALLOCATOR_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator__traits_1_1rebind__alloc.html">bsl::allocator_traits&lt; ALLOCATOR_TYPE &gt;::rebind_alloc&lt; ELEMENT_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator__traits_1_1rebind__traits.html">bsl::allocator_traits&lt; ALLOCATOR_TYPE &gt;::rebind_traits&lt; ELEMENT_TYPE &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga9bf18f601730a8241ff86258f0b764d2">bsl::allocator_traits::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR_TYPE::value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#gae9ec9e291313db9e563a104f00f563fb">bsl::allocator_traits::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR_TYPE::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga3d44e93fa9145da7fdd18502bed10e8f">bsl::allocator_traits::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
ALLOCATOR_TYPE::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga95b7e2cad4ba9ad489d11e4400e57987">bsl::allocator_traits::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga2cd84cbbf7d4e9599ca4619db75122c1">bsl::allocator_traits::void_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga2fdbd0a5f3b83c1cf5538a3a7390c360">bsl::allocator_traits::const_void_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
ALLOCATOR_TYPE::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga2c043fb992583ad40d8d1c1a3e1ecff1">bsl::allocator_traits::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR_TYPE::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#gae5fea114d04c6a2615a8c75e820f9364">bsl::allocator_traits::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef false_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga46a91d84c0ad7640ad0b72313a3fe745">bsl::allocator_traits::propagate_on_container_copy_assignment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef false_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga074746d112da9913e99896a4e342fabb">bsl::allocator_traits::propagate_on_container_move_assignment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef false_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga3e4cc6138c8cd5a05f7de602693f6c6a">bsl::allocator_traits::propagate_on_container_swap</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#gab8b0765f4c8aaab08a9f5f330183f042">bsl::allocator_traits::allocate</a> (ALLOCATOR_TYPE &amp;basicAllocator, size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga02722952476f936d64e76c2da3ca4ee0">bsl::allocator_traits::allocate</a> (ALLOCATOR_TYPE &amp;basicAllocator, size_type n, const_void_pointer hint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga1379f79e6549b07219ad9d358474ade0">bsl::allocator_traits::deallocate</a> (ALLOCATOR_TYPE &amp;basicAllocator, pointer elementAddr, size_type n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#gab1c6b0656d9734078a2f1ffe3afcb675">bsl::allocator_traits::construct</a> (ALLOCATOR_TYPE &amp;basicAllocator, ELEMENT_TYPE *elementAddr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class CTOR_ARGS_0 , class... CTOR_ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga9205e72e5182ead99085d2c7987de4f3">bsl::allocator_traits::construct</a> (ALLOCATOR_TYPE &amp;basicAllocator, ELEMENT_TYPE *elementAddr, CTOR_ARGS_0 &amp;&amp;ctorArgs_0, CTOR_ARGS &amp;&amp;...ctorArgs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga401ba399a2d92530a3af6d64e5934383">bsl::allocator_traits::destroy</a> (ALLOCATOR_TYPE &amp;basicAllocator, ELEMENT_TYPE *elementAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga151e0515a13e0e2d18d74f19badde71c">bsl::allocator_traits::max_size</a> (const ALLOCATOR_TYPE &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ALLOCATOR_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocatortraits.html#ga7434b6558162892c0e3a2a8b314be86b">bsl::allocator_traits::select_on_container_copy_construction</a> (const ALLOCATOR_TYPE &amp;rhs)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: A Container Class</a> </li>
<li>
<a href="#3.1.2">Example 2: bslma Allocator Propagation</a> </li>
<li>
<a href="#3.1.3">Example 3: C++03 Allocators</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a uniform interface to standard allocator types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a> </td><td>Uniform interface to standard allocator types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__allocator.html" title="Provide a pure abstract interface for memory-allocation mechanisms.">Component bslma_allocator</a>, <a class="el" href="group__bslstl__allocator.html" title="Provide an STL-compatible proxy for bslma::Allocator objects.">Component bslstl_allocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The standard <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> class template is defined in the C++11 standard ([allocator.traits]) as a uniform mechanism for accessing nested types within, and operations on, any standard-conforming allocator. An <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> specialization is stateless, and all of its member functions are static. In most cases, facilities of <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> are straight pass-throughs for the same facilities from the <code>ALLOC</code> template parameter. For example, <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a>&lt;X&gt;pointer</code> is the same as <code>X::pointer</code> and <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a>&lt;X&gt;allocate(x, n)</code> is the same as <code>x.allocate(n)</code>. The advantage of using <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> instead of directly using the allocator is that the <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> interface can supply parts of the interface that are missing from <code>ALLOC</code>. In fact, the most important purpose of <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> is to provide implementations of C++11 allocator features that were absent in C++03, thus allowing a C++03 allocator to work with C++11 containers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a full C++11 interface for <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code>, but constrains the set of allocator types on which it may be instantiated. Specifically, this implementation does not provide defaults for C++03 types and functions, and has hard-wired implementations of the new C++11 features. Thus, the <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> template cannot be instantiated on an allocator type that does not provide a full compliment of types and functions required by the C++03 standard, and it will ignore any special C++11 features specified in <code>ALLOC</code>. This limitation exists because Bloomberg does not need the full functionality of the C++11 model, but needs only to distinguish between C++03 allocators and allocators that implement the BSLMA allocator model (see <a href="group__bslstl__allocator.html" class="el"><code>bslstl_allocator</code></a>). The full feature set of <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> would require a lot of resources for implementation and (especially) testing. Moreover, a full implementation would require metaprogramming that is too advanced for the feature set of the compilers currently in use at Bloomberg. This interface is useful, however, as a way to future-proof containers against the eventual implementation of the full feature set, and to take advantage of the Bloomberg-specific features described below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two important (new) C++11 features provided by the <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> interface: the <code>construct</code> function having a variable-length argument list (limited to 5 constructor arguments on compilers that don't support variadic templates) and the allocator-propagation traits. The implementations of these features within this component are tuned to Bloomberg's needs. The <code>construct</code> member function will automatically forward the allocator to the constructed object iff the <code>ALLOC</code> parameter is convertible from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*</code> and the object being constructed has the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> type trait, as per standard Bloomberg practice. The <code>select_on_container_copy_construction</code> static member will return a default-constructed allocator iff <code>ALLOC</code> is convertible from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> because bslma allocators should not be copied when a container is copy-constructed; otherwise this function will return a copy of the allocator, as per C++03 container rules. The other propagation traits all have a <code>false</code> value, so allocators are not propagated on assignment or swap. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that use of this component will differ from a strict following of the C++03 standard, as the <code>construct</code> and <code>destroy</code> methods of the parameterized allocator type will not be called. Rather, the target object will always be constructed at the address specified by the user, by calling the constructor in-place. Similarly, the destructor will always be called directly, rather than using a parameterized allocator's <code>destroy</code> method. Otherwise, this implementation will fully support the C++03 model, including use of allocators returning "smart pointers" from <code>allocate</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_a_container_class"></a> <a class="anchor" id="usage.example_1~3A_a_container_class"></a> <a class="anchor" id="description.usage.example_1~3A_a_container_class"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: A Container Class: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates the intended use of <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> to implement a standard-conforming container class. First, we create a container class that holds a single object and which meets the requirements both of a standard container and of a Bloomberg container. I.e., when instantiated with an allocator argument it uses the standard allocator model; otherwise it uses the <code>bslma</code> model. We provide an alias, <code>AllocTraits</code>, to the specific <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> instantiation to simplify the implementation of each method that must allocate memory, or create or destroy elements. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="bslstl__allocatortraits_8h.html" title="Provide a uniform interface to standard allocator types.">bslstl_allocatortraits.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bslstl__allocator_8h.html" title="Provide an STL-compatible proxy for bslma::Allocator objects.">bslstl_allocator.h</a>&gt;</span>

  <span class="keyword">using namespace </span>BloombergLP;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> ALLOC = bsl::allocator&lt;TYPE&gt; &gt;
  <span class="keyword">class </span>MyContainer {
      <span class="comment">// This class provides a container that always holds exactly one</span>
      <span class="comment">// element, dynamically allocated using the specified allocator.</span>

      <span class="keyword">typedef</span> <a class="code" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits&lt;ALLOC&gt;</a> AllocTraits;
          <span class="comment">// Alias for the &#39;allocator_traits&#39; instantiation to use for</span>
          <span class="comment">// all memory management requests.</span>

      <span class="comment">// DATA</span>
      ALLOC  d_allocator;
      TYPE  *d_value_p;

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(MyContainer, <a class="code" href="structbslalg_1_1HasStlIterators.html">bslalg::HasStlIterators</a>);
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#afba4d34c00d363b3b83f2768fc5d0887">BSLMF_NESTED_TRAIT_DECLARATION_IF</a>(MyContainer,
                                        <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>,
                                        (<a class="code" href="structbsl_1_1is__convertible.html">bsl::is_convertible</a>&lt;Allocator*,
                                                             ALLOC&gt;::value));
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#afba4d34c00d363b3b83f2768fc5d0887">BSLMF_NESTED_TRAIT_DECLARATION_IF</a>(MyContainer,
                                     <a class="code" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>,
                                     <a class="code" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable&lt;ALLOC&gt;::value</a>);
          <span class="comment">// Declare nested type traits for this class.</span>

      <span class="keyword">typedef</span> TYPE  value_type;
      <span class="keyword">typedef</span> ALLOC allocator_type;
      <span class="comment">// etc.</span>

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyContainer(<span class="keyword">const</span> ALLOC&amp; a = ALLOC());
      <span class="keyword">explicit</span> MyContainer(<span class="keyword">const</span> TYPE&amp; v, <span class="keyword">const</span> ALLOC&amp; a = ALLOC());
      MyContainer(<span class="keyword">const</span> MyContainer&amp; other);
      MyContainer(<span class="keyword">const</span> MyContainer&amp; other, <span class="keyword">const</span> ALLOC&amp; a);
      ~MyContainer();

      <span class="comment">// MANIPULATORS</span>
      ALLOC get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_allocator; }

      <span class="comment">// ACCESSORS</span>
      TYPE&amp;       front()       { <span class="keywordflow">return</span> *d_value_p; }
      <span class="keyword">const</span> TYPE&amp; front()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *d_value_p; }
      <span class="comment">// etc.</span>
  };
</pre></div><br/>
<br/>
 Then we implement the constructors, which allocate memory and construct a <code>TYPE</code> object in the allocated memory. Because the allocation and construction are done in two separate steps, we need to create a proctor that will deallocate the allocated memory in case the constructor throws an exception. The proctor uses the uniform interface provided by <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> to access the <code>pointer</code> and <code>deallocate</code> members of <code>ALLOC</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ALLOC&gt;
  <span class="keyword">class </span>MyContainerProctor {
      <span class="comment">// This class implements a proctor to release memory allocated during</span>
      <span class="comment">// the construction of a &#39;MyContainer&#39; object if the constructor for</span>
      <span class="comment">// the container&#39;s data element throws an exception.  Such a proctor</span>
      <span class="comment">// should be &#39;release&#39;d once the element is safely constructed.</span>

      <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="group__bslstl__allocatortraits.html#ga3d44e93fa9145da7fdd18502bed10e8f">bsl::allocator_traits&lt;ALLOC&gt;::pointer</a> pointer;
      ALLOC   d_alloc;
      pointer d_data_p;

    <span class="keyword">public</span>:
      MyContainerProctor(<span class="keyword">const</span> ALLOC&amp; a, pointer p)
          : d_alloc(a), d_data_p(p) { }

      ~MyContainerProctor() {
          <span class="keywordflow">if</span> (d_data_p) {
              <a class="code" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits&lt;ALLOC&gt;::deallocate</a>(d_alloc, d_data_p, 1);
          }
      }

      <span class="keywordtype">void</span> release() { d_data_p = pointer(); }
  };
</pre></div><br/>
<br/>
 Next, we perform the actual allocation and construction using the <code>allocate</code> and <code>construct</code> members of <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code>, which provide the correct semantic for passing the allocator to the constructed object when appropriate: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> ALLOC&gt;
  MyContainer&lt;TYPE, ALLOC&gt;::MyContainer(<span class="keyword">const</span> ALLOC&amp; a)
      : d_allocator(a)
  {
      d_value_p = AllocTraits::allocate(d_allocator, 1);
      MyContainerProctor&lt;ALLOC&gt; proctor(a, d_value_p);
      <span class="comment">// Call &#39;construct&#39; with no constructor arguments</span>
      AllocTraits::construct(d_allocator, d_value_p);
      proctor.release();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> ALLOC&gt;
  MyContainer&lt;TYPE, ALLOC&gt;::MyContainer(<span class="keyword">const</span> TYPE&amp; v, <span class="keyword">const</span> ALLOC&amp; a)
      : d_allocator(a)
  {
      d_value_p = AllocTraits::allocate(d_allocator, 1);
      MyContainerProctor&lt;ALLOC&gt; proctor(a, d_value_p);
      <span class="comment">// Call &#39;construct&#39; with one constructor argument of type &#39;TYPE&#39;</span>
      AllocTraits::construct(d_allocator, d_value_p, v);
      proctor.release();
  }
</pre></div><br/>
<br/>
 Next, the copy constructor for <code>MyContainer</code> needs to conditionally copy the allocator from the <code>other</code> container. The copy constructor uses <code>allocator_traits::select_on_container_copy_construction</code> to decide whether to copy the <code>other</code> allocator (for non-bslma allocators) or to default-construct the allocator (for bslma allocators). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> ALLOC&gt;
  MyContainer&lt;TYPE, ALLOC&gt;::MyContainer(<span class="keyword">const</span> MyContainer&amp; other)
      : d_allocator(bsl::allocator_traits&lt;ALLOC&gt;::
                    select_on_container_copy_construction(other.d_allocator))
  {
      d_value_p = AllocTraits::allocate(d_allocator, 1);
      MyContainerProctor&lt;ALLOC&gt; proctor(d_allocator, d_value_p);
      AllocTraits::construct(d_allocator, d_value_p, *other.d_value_p);
      proctor.release();
  }
</pre></div><br/>
<br/>
 Now, the destructor uses <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></code> functions to destroy and deallocate the value object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> ALLOC&gt;
  MyContainer&lt;TYPE, ALLOC&gt;::~MyContainer()
  {
      AllocTraits::destroy(d_allocator, d_value_p);
      AllocTraits::deallocate(d_allocator, d_value_p, 1);
  }
</pre></div><br/>
<br/>
 Finally, we perform a simple test of <code>MyContainer</code>, instantiating it with element type <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample1()
  {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> testAlloc;
      MyContainer&lt;int&gt; C1(123, &amp;testAlloc);
      assert(C1.get_allocator() == <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;int&gt;</a>(&amp;testAlloc));
      assert(C1.front() == 123);

      MyContainer&lt;int&gt; C2(C1);
      assert(C2.get_allocator() == <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;int&gt;</a>());
      assert(C2.front() == 123);

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_bslma_allocator_propagation"></a> <a class="anchor" id="usage.example_2~3A_bslma_allocator_propagation"></a> <a class="anchor" id="description.usage.example_2~3A_bslma_allocator_propagation"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: bslma Allocator Propagation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>To exercise the propagation of the allocator of <code>MyContainer</code> to its elements, we first create a representative element class, <code>MyType</code>, that allocates memory using the bslma allocator protocol: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="bslma__default_8h.html" title="Provide utilities to set/fetch the default and global allocators.">bslma_default.h</a>&gt;</span>

  <span class="keyword">class </span>MyType {

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;
      <span class="comment">// etc.</span>
    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(MyType, <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyType(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>* basicAlloc = 0)
         : d_allocator_p(bslma::Default::allocator(basicAlloc)) { <span class="comment">/* ... */</span> }
      MyType(<span class="keyword">const</span> MyType&amp; other)
          : d_allocator_p(bslma::Default::allocator(0)) { <span class="comment">/* ... */</span> }
      MyType(<span class="keyword">const</span> MyType&amp; other, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>* basicAlloc)
         : d_allocator_p(bslma::Default::allocator(basicAlloc)) { <span class="comment">/* ... */</span> }
      <span class="comment">// etc.</span>

      <span class="comment">// ACCESSORS</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_allocator_p; }
      <span class="comment">// etc.</span>
  };
</pre></div><br/>
<br/>
 Finally, we instantiate <code>MyContainer</code> using <code>MyType</code> and verify that, when we provide a the address of an allocator to the constructor of the container, the same address is passed to the constructor of the container's element. We also verify that, when the container is copy-constructed, the copy uses the default allocator, not the allocator from the original; moreover, we verify that the element stored in the copy also uses the default allocator. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="bslmf__issame_8h.html" title="Provide a meta-function for testing if two types are the same.">bslmf_issame.h</a>&gt;</span>

  <span class="keywordtype">int</span> usageExample2()
  {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> testAlloc;
      MyContainer&lt;MyType&gt; C1(&amp;testAlloc);
      assert((<a class="code" href="structbsl_1_1is__same.html">bsl::is_same</a>&lt;MyContainer&lt;MyType&gt;::allocator_type,
              <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;MyType&gt;</a> &gt;::value));
      assert(C1.get_allocator() == <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;MyType&gt;</a>(&amp;testAlloc));
      assert(C1.front().allocator() == &amp;testAlloc);

      MyContainer&lt;MyType&gt; C2(C1);
      assert(C2.get_allocator() != C1.get_allocator());
      assert(C2.get_allocator() == <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;MyType&gt;</a>());
      assert(C2.front().allocator() != &amp;testAlloc);
      assert(C2.front().allocator() == <a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>());

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_c++03_allocators"></a> <a class="anchor" id="usage.example_3~3A_c++03_allocators"></a> <a class="anchor" id="description.usage.example_3~3A_c++03_allocators"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: C++03 Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example shows that when <code>MyContainer</code> is instantiated with a C++03 allocator, that the allocator is a) copied on copy construction and b) is not propagated from the container to its elements. First, we create a C++03-style allocator class template: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>MyCpp03Allocator {
      <span class="keywordtype">int</span> d_state;

    <span class="keyword">public</span>:
      <span class="keyword">typedef</span> TYPE        value_type;
      <span class="keyword">typedef</span> TYPE       *pointer;
      <span class="keyword">typedef</span> <span class="keyword">const</span> TYPE *const_pointer;
      <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span>    size_type;
      <span class="keyword">typedef</span> <span class="keywordtype">int</span>         difference_type;

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
      <span class="keyword">struct </span>rebind {
          <span class="keyword">typedef</span> MyCpp03Allocator&lt;U&gt; other;
      };

      <span class="keyword">explicit</span> MyCpp03Allocator(<span class="keywordtype">int</span> state = 0) : d_state(state) { }

      TYPE* allocate(size_type n, <span class="keyword">const</span> <span class="keywordtype">void</span>* = 0)
          { <span class="keywordflow">return</span> (TYPE*) ::operator <span class="keyword">new</span>(<span class="keyword">sizeof</span>(TYPE) * n); }

      <span class="keywordtype">void</span> deallocate(TYPE* p, size_type) { ::operator <span class="keyword">delete</span>(p); }

      <span class="keyword">static</span> size_type max_size() { <span class="keywordflow">return</span> UINT_MAX / <span class="keyword">sizeof</span>(TYPE); }

      <span class="keywordtype">void</span> construct(pointer p, <span class="keyword">const</span> TYPE&amp; value)
          { <span class="keyword">new</span>((<span class="keywordtype">void</span> *)p) TYPE(value); }

      <span class="keywordtype">void</span> destroy(pointer p) { p-&gt;~TYPE(); }

      <span class="keywordtype">int</span> state()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_state; }
  };

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE1, <span class="keyword">class</span> TYPE2&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> MyCpp03Allocator&lt;TYPE1&gt;&amp; lhs,
                  <span class="keyword">const</span> MyCpp03Allocator&lt;TYPE2&gt;&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.state() == rhs.state();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE1, <span class="keyword">class</span> TYPE2&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> MyCpp03Allocator&lt;TYPE1&gt;&amp; lhs,
                  <span class="keyword">const</span> MyCpp03Allocator&lt;TYPE2&gt;&amp; rhs)
  {
      <span class="keywordflow">return</span> ! (lhs == rhs);
  }
</pre></div><br/>
<br/>
 Finally we instantiate <code>MyContainer</code> using this allocator type and verify that elements are constructed using the default allocator (because the allocator is not propagated from the container). We also verify that the allocator is copied on copy-construction: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample3()
  {
      <span class="keyword">typedef</span> MyCpp03Allocator&lt;MyType&gt; MyTypeAlloc;
      MyContainer&lt;MyType, MyTypeAlloc&gt; C1(MyTypeAlloc(1));
      assert((<a class="code" href="structbsl_1_1is__same.html">bsl::is_same</a>&lt;MyContainer&lt;MyType, MyTypeAlloc&gt;::allocator_type,
                           MyTypeAlloc&gt;::value));
      assert(C1.get_allocator() == MyTypeAlloc(1));
      assert(C1.front().allocator() == <a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>());

      MyContainer&lt;MyType, MyTypeAlloc&gt; C2(C1);
      assert(C2.get_allocator() == C1.get_allocator());
      assert(C2.get_allocator() != MyTypeAlloc())
      assert(C2.front().allocator() == <a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>());

      <span class="keywordflow">return</span> 0;
   }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga9bf18f601730a8241ff86258f0b764d2"></a><!-- doxytag: member="bsl::allocator_traits::allocator_type" ref="ga9bf18f601730a8241ff86258f0b764d2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR_TYPE <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae9ec9e291313db9e563a104f00f563fb"></a><!-- doxytag: member="bsl::allocator_traits::value_type" ref="gae9ec9e291313db9e563a104f00f563fb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR_TYPE::value_type <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3d44e93fa9145da7fdd18502bed10e8f"></a><!-- doxytag: member="bsl::allocator_traits::pointer" ref="ga3d44e93fa9145da7fdd18502bed10e8f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR_TYPE::pointer <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga95b7e2cad4ba9ad489d11e4400e57987"></a><!-- doxytag: member="bsl::allocator_traits::const_pointer" ref="ga95b7e2cad4ba9ad489d11e4400e57987" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR_TYPE::const_pointer <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2cd84cbbf7d4e9599ca4619db75122c1"></a><!-- doxytag: member="bsl::allocator_traits::void_pointer" ref="ga2cd84cbbf7d4e9599ca4619db75122c1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::void_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2fdbd0a5f3b83c1cf5538a3a7390c360"></a><!-- doxytag: member="bsl::allocator_traits::const_void_pointer" ref="ga2fdbd0a5f3b83c1cf5538a3a7390c360" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void const* <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::const_void_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2c043fb992583ad40d8d1c1a3e1ecff1"></a><!-- doxytag: member="bsl::allocator_traits::difference_type" ref="ga2c043fb992583ad40d8d1c1a3e1ecff1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR_TYPE::difference_type <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae5fea114d04c6a2615a8c75e820f9364"></a><!-- doxytag: member="bsl::allocator_traits::size_type" ref="gae5fea114d04c6a2615a8c75e820f9364" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR_TYPE::size_type <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga46a91d84c0ad7640ad0b72313a3fe745"></a><!-- doxytag: member="bsl::allocator_traits::propagate_on_container_copy_assignment" ref="ga46a91d84c0ad7640ad0b72313a3fe745" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef false_type <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::propagate_on_container_copy_assignment<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga074746d112da9913e99896a4e342fabb"></a><!-- doxytag: member="bsl::allocator_traits::propagate_on_container_move_assignment" ref="ga074746d112da9913e99896a4e342fabb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef false_type <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::propagate_on_container_move_assignment<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3e4cc6138c8cd5a05f7de602693f6c6a"></a><!-- doxytag: member="bsl::allocator_traits::propagate_on_container_swap" ref="ga3e4cc6138c8cd5a05f7de602693f6c6a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef false_type <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::propagate_on_container_swap<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab8b0765f4c8aaab08a9f5f330183f042"></a><!-- doxytag: member="bsl::allocator_traits::allocate" ref="gab8b0765f4c8aaab08a9f5f330183f042" args="(ALLOCATOR_TYPE &amp;basicAllocator, size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static pointer <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocatortraits.html#gae5fea114d04c6a2615a8c75e820f9364">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>basicAllocator.allocate(n)</code>. </p>

</div>
</div>
<a class="anchor" id="ga02722952476f936d64e76c2da3ca4ee0"></a><!-- doxytag: member="bsl::allocator_traits::allocate" ref="ga02722952476f936d64e76c2da3ca4ee0" args="(ALLOCATOR_TYPE &amp;basicAllocator, size_type n, const_void_pointer hint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static pointer <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocatortraits.html#gae5fea114d04c6a2615a8c75e820f9364">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocatortraits.html#ga2fdbd0a5f3b83c1cf5538a3a7390c360">const_void_pointer</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>basicAllocator.allocate(n, hint)</code>. </p>

</div>
</div>
<a class="anchor" id="ga1379f79e6549b07219ad9d358474ade0"></a><!-- doxytag: member="bsl::allocator_traits::deallocate" ref="ga1379f79e6549b07219ad9d358474ade0" args="(ALLOCATOR_TYPE &amp;basicAllocator, pointer elementAddr, size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocatortraits.html#ga3d44e93fa9145da7fdd18502bed10e8f">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>elementAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocatortraits.html#gae5fea114d04c6a2615a8c75e820f9364">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke <code>basicAllocator.deallocate(elementAddr, n)</code>. The behavior is undefined unless the specified <code>elementAddr</code> was returned from a prior call to the <code>allocate</code> method of an allocator that compares equal to the specified <code>allocator</code>, and has not yet been passed to a <code>deallocate</code> call of such an allocator object. </p>

</div>
</div>
<a class="anchor" id="gab1c6b0656d9734078a2f1ffe3afcb675"></a><!-- doxytag: member="bsl::allocator_traits::construct" ref="gab1c6b0656d9734078a2f1ffe3afcb675" args="(ALLOCATOR_TYPE &amp;basicAllocator, ELEMENT_TYPE *elementAddr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>elementAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default construct an object of the parameterized <code>ELEMENT_TYPE</code> at the specified <code>elementAddr</code>. If the parameterized <code>ALLOCATOR_TYPE</code> is bslma-compatible and <code>ELEMENT_TYPE</code> has the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait, then pass the mechanism from the specified <code>basicAllocator</code> as an additional constructor argument (at the end of the argument list). The behavior is undefined unless <code>elementAddr</code> refers to valid, uninitialized storage. Note that this overload of <code>construct</code> is implemented using <code><a class="el" href="structbslalg_1_1ScalarPrimitives.html#a085932db0670470048dcfff9cb553e8c">bslalg::ScalarPrimitives::defaultConstruct</a></code> whereas those overloads that take at least one additional constructor argument are implemented in terms of <code><a class="el" href="structbslalg_1_1ScalarPrimitives.html#a2a589c408ae61aaf57853373a742c181">bslalg::ScalarPrimitives::construct</a></code> </p>

</div>
</div>
<a class="anchor" id="ga9205e72e5182ead99085d2c7987de4f3"></a><!-- doxytag: member="bsl::allocator_traits::construct" ref="ga9205e72e5182ead99085d2c7987de4f3" args="(ALLOCATOR_TYPE &amp;basicAllocator, ELEMENT_TYPE *elementAddr, CTOR_ARGS_0 &amp;&amp;ctorArgs_0, CTOR_ARGS &amp;&amp;...ctorArgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class CTOR_ARGS_0 , class... CTOR_ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>elementAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTOR_ARGS_0 &amp;&amp;&nbsp;</td>
          <td class="paramname"> <em>ctorArgs_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTOR_ARGS &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>ctorArgs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an object of the parameterized <code>ELEMENT_TYPE</code> at the specified <code>elementAddr</code> using a constructor argument list comprising the specified <code>ctorArgs_0</code> and <code>ctorArgs</code>. If the parameterized <code>ALLOCATOR_TYPE</code> is bslma-compatible and <code>ELEMENT_TYPE</code> has the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait, then pass the mechanism from the specified <code>basicAllocator</code> as an additional constructor argument (at the end of the argument list). The behavior is undefined unless <code>elementAddr</code> refers to valid, uninitialized storage. Note that this overload of <code>construct</code> takes at least one constructor argument in addition to the allocator argument. </p>

</div>
</div>
<a class="anchor" id="ga401ba399a2d92530a3af6d64e5934383"></a><!-- doxytag: member="bsl::allocator_traits::destroy" ref="ga401ba399a2d92530a3af6d64e5934383" args="(ALLOCATOR_TYPE &amp;basicAllocator, ELEMENT_TYPE *elementAddr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>elementAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke the destructor for the object at the specified <code>elementAddr</code>; the specified <code>basicAllocator</code> (of parameterized <code>ALLOCATOR_TYPE</code>) is ignored. The behavior is undefined unless <code>elementAddr</code> refers to a valid, constructed object. </p>

</div>
</div>
<a class="anchor" id="ga151e0515a13e0e2d18d74f19badde71c"></a><!-- doxytag: member="bsl::allocator_traits::max_size" ref="ga151e0515a13e0e2d18d74f19badde71c" args="(const ALLOCATOR_TYPE &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static size_type <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the largest number of <code>value_type</code> objects that could reasonably be returned by a single invocation of <code>allocate</code> for the specified <code>allocator</code>, i.e., <code>allocator.max_size()</code>. </p>

</div>
</div>
<a class="anchor" id="ga7434b6558162892c0e3a2a8b314be86b"></a><!-- doxytag: member="bsl::allocator_traits::select_on_container_copy_construction" ref="ga7434b6558162892c0e3a2a8b314be86b" args="(const ALLOCATOR_TYPE &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static ALLOCATOR_TYPE <a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt; ALLOCATOR_TYPE &gt;::select_on_container_copy_construction </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a copy of the allocator that should be used to copy- construct one container from another container whose allocator is the specified <code>rhs</code>. If the parameterized <code>ALLOCATOR_TYPE</code> is bslma-compatible, then return <code>ALLOCATOR_TYPE()</code> (i.e., do not copy the allocator to the newly-constructed container); otherwise, return <code>rhs</code> (i.e., do propagate the allocator to the newly-constructed container). </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:22 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
