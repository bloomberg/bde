<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlt_defaultcalendarcache.h                                        -*-C++-*-
#ifndef INCLUDED_BDLT_DEFAULTCALENDARCACHE
#define INCLUDED_BDLT_DEFAULTCALENDARCACHE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a process-wide default &#39;bdlt::CalendarCache&#39; object.
//
//@CLASSES:
//  bdlt::DefaultCalendarCache: namespace for managing a default calendar cache
//
//@SEE_ALSO: bdlt_calendarcache, bdlt_calendarloader
//
//@DESCRIPTION: This component provides a namespace,
// &#39;bdlt::DefaultCalendarCache&#39;, for utility functions that initialize, provide
// access to, and ultimately destroy, a default &#39;bdlt::CalendarCache&#39; object.
// The default cache is initialized by calling the (overloaded) &#39;initialize&#39;
// class method to which a concrete calendar loader and memory allocator must
// be supplied.  The cache is destroyed by the &#39;destroy&#39; class method.  Note
// that the calendar-naming convention in effect for the default cache is
// determined by the loader supplied to &#39;initialize&#39;.
//
// A timeout may be established for the default cache by supplying an optional
// &#39;bsls::TimeInterval&#39; value to &#39;initialize&#39;.  When a timeout is in effect for
// the default cache, a request for a calendar from the cache may incur the
// reloading of the calendar if the one in the cache has expired (i.e., the
// time interval defined by the timeout value has elapsed since the calendar
// was last loaded into the cache).  Calendars will not expire in this fashion
// if the default cache is not provided with a timeout at initialization.
//
// Although the cache may be initialized and destroyed multiple times during
// the lifetime of a process, the expected usage is that the cache would be
// initialized *once*, typically in &#39;main&#39; before other threads have been
// created, and destroyed just prior to program termination.  Regardless, the
// lifetimes of the calendar loader and memory allocator supplied to
// &#39;initialize&#39; must extend beyond the following (matching) call to &#39;destroy&#39;.
// While the default calendar cache is in the initialized state, the &#39;instance&#39;
// method returns an address providing modifiable access to the cache.
// Otherwise, &#39;instance&#39; returns 0.
//
// !WARNING!: Clients should be aware that the address returned by &#39;instance&#39;
// becomes invalid by a subsequent call to &#39;destroy&#39;.
//
///Thread Safety
///-------------
// The &#39;bdlt::DefaultCalendarCache&#39; class is fully thread-safe (see
// &#39;bsldoc_glossary&#39;) provided that the allocator supplied to &#39;initialize&#39; and
// the default allocator in effect during the lifetime of the default cache are
// both fully thread-safe.
//
///Usage
///-----
// The following example illustrates how to use &#39;bdlt::DefaultCalendarCache&#39;.
//
///Example 1: Using &#39;bdlt::DefaultCalendarCache&#39;
///- - - - - - - - - - - - - - - - - - - - - - -
// &#39;bdlt::DefaultCalendarCache&#39; has a particularly simple interface.  This
// example shows how to use each of its three methods.
//
// A hypothetical calendar loader is assumed, &#39;MyCalendarLoader&#39;, the details
// of which are not important other than that it supports calendars identified
// by &quot;DE&quot;, &quot;FR&quot;, and &quot;US&quot;, which nominally identify the major holidays in
// Germany, France, and the United States, respectively.  Furthermore, we cite
// two specific dates of interest: 2011/07/04, which was a holiday in the US
// (Independence Day), but not in France, and 2011/07/14, which was a holiday
// in France (Bastille Day), but not in the US.
//
// First, we create a calendar loader, an instance of &#39;MyCalendarLoader&#39;, and
// use it, in turn, to initialize the default calendar cache.  A memory
// allocator must also be explicitly supplied to the &#39;initialize&#39; method.  The
// global allocator is suitable in this case (see &#39;bslma_default&#39;):
//..
//  static MyCalendarLoader loader;
//
//  int rc = bdlt::DefaultCalendarCache::initialize(
//                                          &amp;loader,
//                                          bslma::Default::globalAllocator());
//  assert(!rc);
//..
// Note that declaring &#39;loader&#39; to be &#39;static&#39; ensures that it remains valid
// until the cache is destroyed.  Also note that initialization of the cache
// would typically be done in &#39;main&#39; before other threads have been created.
//
// Next, we obtain the address of the default calendar cache using the
// &#39;instance&#39; class method:
//..
//  bdlt::CalendarCache *cachePtr = bdlt::DefaultCalendarCache::instance();
//  assert(cachePtr);
//..
// Then, we retrieve the calendar identified by &quot;US&quot; from the default cache,
// and verify that 2011/07/04 is recognized as a holiday in the &quot;US&quot; calendar,
// whereas 2011/07/14 is not:
//..
//  bsl::shared_ptr&lt;const bdlt::Calendar&gt; us = cachePtr-&gt;getCalendar(&quot;US&quot;);
//  assert( us-&gt;isHoliday(bdlt::Date(2011, 7,  4)));
//  assert(!us-&gt;isHoliday(bdlt::Date(2011, 7, 14)));
//..
// Next, we fetch the calendar identified by &quot;FR&quot;, this time verifying that
// 2011/07/14 is recognized as a holiday in the &quot;FR&quot; calendar, but 2011/07/04
// is not:
//..
//  bsl::shared_ptr&lt;const bdlt::Calendar&gt; fr = cachePtr-&gt;getCalendar(&quot;FR&quot;);
//  assert(!fr-&gt;isHoliday(bdlt::Date(2011, 7,  4)));
//  assert( fr-&gt;isHoliday(bdlt::Date(2011, 7, 14)));
//..
// Finally, we destroy the default calendar cache:
//..
//  bdlt::DefaultCalendarCache::destroy();
//  assert(!bdlt::DefaultCalendarCache::instance());
//..
// Note that destruction of the default cache would typically be done in &#39;main&#39;
// just prior to program termination.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

namespace BloombergLP {

namespace bslma { class Allocator; }

namespace bdlt {

class CalendarCache;
class CalendarLoader;

                      // ==========================
                      // class DefaultCalendarCache
                      // ==========================

struct DefaultCalendarCache {
    // This &#39;struct&#39; provides a namespace for functions that manage the
    // lifetime of, and access to, a process-wide default &#39;bdlt::CalendarCache&#39;
    // object.  The default cache is initialized by an explicit call to the
    // &#39;initialize&#39; class method, and destroyed by the &#39;destroy&#39; class method.
    // The default cache may be initialized and destroyed multiple times during
    // the lifetime of a process.  The lifetimes of the calendar loader and
    // memory allocator supplied to &#39;initialize&#39; must extend beyond the
    // following (matching) call to &#39;destroy&#39;.
    //
    // All methods of this &#39;struct&#39; are fully thread-safe (see
    // &#39;bsldoc_glossary&#39;).

    // CLASS METHODS
    static void destroy();
        // Destroy the default &#39;CalendarCache&#39; object managed by this class.
        // If the default cache is not in the initialized state, this method
        // has no effect.  Note that all addresses returned by earlier calls to
        // &#39;instance&#39; are invalidated by this method.

    static int initialize(CalendarLoader   *loader,
                          bslma::Allocator *allocator);
        // Initialize the default &#39;CalendarCache&#39; object managed by this class
        // to use the specified &#39;loader&#39; to obtain calendars, to have no
        // timeout, and to use the specified &#39;allocator&#39; to supply memory.  If
        // the default cache is already in the initialized state, this method
        // has no effect.  Return 0 on success, and a non-zero value otherwise.
        // The behavior is undefined unless &#39;loader&#39; and &#39;allocator&#39; remain
        // valid until a subsequent call to &#39;destroy&#39;.

    static int initialize(CalendarLoader            *loader,
                          const bsls::TimeInterval&amp;  timeout,
                          bslma::Allocator          *allocator);
        // Initialize the default &#39;CalendarCache&#39; object managed by this class
        // to use the specified &#39;loader&#39; to obtain calendars, to have the
        // specified &#39;timeout&#39;, and to use the specified &#39;allocator&#39; to supply
        // memory.  If the default cache is already in the initialized state,
        // this method has no effect.  Return 0 on success, and a non-zero
        // value otherwise.  The behavior is undefined unless &#39;loader&#39; and
        // &#39;allocator&#39; remain valid until a subsequent call to &#39;destroy&#39;, and
        // &#39;bsls::TimeInterval(0) &lt;= timeout &lt;= bsls::TimeInterval(INT_MAX)&#39;.
        // Note that a &#39;timeout&#39; value of 0 indicates that a calendar will be
        // loaded into the default cache by *each* (successful) call to
        // &#39;CalendarCache::getCalendar&#39; on the cache returned by &#39;instance&#39;.

    static CalendarCache *instance();
        // Return an address providing modifiable access to the default
        // &#39;CalendarCache&#39; object managed by this class, if the default cache
        // is in the initialized state, and 0 otherwise.  The cache obtains
        // calendars using the loader that was supplied to the &#39;initialize&#39;
        // method.  Note that the returned address is invalidated by a
        // subsequent call to &#39;destroy&#39;.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
