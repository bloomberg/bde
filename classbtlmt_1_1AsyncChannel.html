<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlmt::AsyncChannel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlmt.html">btlmt</a>      </li>
      <li><a class="el" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlmt::AsyncChannel Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlmt::AsyncChannel" -->
<p><code>#include &lt;<a class="el" href="btlmt__asyncchannel_8h_source.html">btlmt_asyncchannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlmt::AsyncChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlmt_1_1AsyncChannel.png" usemap="#btlmt::AsyncChannel_map" alt=""/>
  <map id="btlmt::AsyncChannel_map" name="btlmt::AsyncChannel_map">
<area href="classbtlmt_1_1ChannelPoolChannel.html" alt="btlmt::ChannelPoolChannel" shape="rect" coords="0,56,162,80"/>
</map>
</div>

<p><a href="classbtlmt_1_1AsyncChannel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551f">ReadResult</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa5cba2d111aa63093d4e64191f1707d03">e_SUCCESS</a> =  0, 
<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa01f2e9ed90a39741ac081e5dce5a1759">e_TIMEOUT</a> =  1, 
<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fafa17e8cfc2c5c042da53507cfd1acb3e">e_CLOSED</a> =  2, 
<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa6f2b061c0524b51ad80ae1cd44e0b505">e_FAILURE</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fae89cb167dc0c7381d150577a6cfd96f4">e_CANCELED</a> =  4
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int, <br class="typebreak"/>
int *, <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> *, int)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> )</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#abf0f67228fe00352763cca946d19f69b">~AsyncChannel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#a40529f78e22d0f2cf68ffd3d25071e00">read</a> (int numBytes, const <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> &amp;readCallback)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#abda8c1b331e8dbfaa4759373f74cd58d">timedRead</a> (int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, const <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> &amp;readCallback)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#a66bb58eb273e0b4325c57f743feea7d4">write</a> (const <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> &amp;blob, int highWaterMark=INT_MAX)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#ab6fe7d9b78e55b1a894fbe91e472a08a">setSocketOption</a> (int option, int level, int value)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#a5675a6b49a9c262de4ea87914ae61437">cancelRead</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#af20340aa5d3fd2ed875533d12715acf5">close</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#a837e8ce93384cf3a52679bf2751ab482">localAddress</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#a82e42998d5636d66143b518a70e72973">peerAddress</a> () const =0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class defines a <em>pure</em> protocol for asynchronous IO operations. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a6fd18c091cdc0fe58b37bd0c18e2d19c"></a><!-- doxytag: member="btlmt::AsyncChannel::BlobBasedReadCallback" ref="a6fd18c091cdc0fe58b37bd0c18e2d19c" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int, int *, <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> *, int) <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">btlmt::AsyncChannel::BlobBasedReadCallback</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback of this type is invoked for <code>read</code> and <code>timeRead</code> when either the requested number of bytes are available, or an error occurs. The callback is invoked with four arguments: (1) an integer result code corresponding to <code>ReadResult</code> that indicates the result of the read operation, and if this code is equal to <code>e_SUCCESS</code>, (2) a pointer to an integer value where the callee can indicate how many more bytes are needed to complete the read operation, (3) a modifiable <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> object containing the payload. The caller is responsible for taking ownership of a certain number of bytes in the <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> and readjusting it appropriately. Note that the read operation is not considered completed until the callee indicates that zero more bytes are needed (argument 2), and (4) channel id. Also note that the last three arguments are ignored if the first argument is different from <code>e_SUCCESS</code>.</p>
<p>A typical function matching this interface might look as follows: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">void</span> myReadCallback(<span class="keywordtype">int</span>         result,
                              <span class="keywordtype">int</span>        *numNeeded,
                              <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *blob,
                              <span class="keywordtype">int</span>         channelId);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad108cc12b44c814135812903da49551f"></a><!-- doxytag: member="btlmt::AsyncChannel::ReadResult" ref="ad108cc12b44c814135812903da49551f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551f">btlmt::AsyncChannel::ReadResult</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fa5cba2d111aa63093d4e64191f1707d03"></a><!-- doxytag: member="e_SUCCESS" ref="ad108cc12b44c814135812903da49551fa5cba2d111aa63093d4e64191f1707d03" args="" -->e_SUCCESS</em>&nbsp;</td><td>
<p>The operation was successful. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fa01f2e9ed90a39741ac081e5dce5a1759"></a><!-- doxytag: member="e_TIMEOUT" ref="ad108cc12b44c814135812903da49551fa01f2e9ed90a39741ac081e5dce5a1759" args="" -->e_TIMEOUT</em>&nbsp;</td><td>
<p>The <code>timedRead</code> operation has timed out. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fafa17e8cfc2c5c042da53507cfd1acb3e"></a><!-- doxytag: member="e_CLOSED" ref="ad108cc12b44c814135812903da49551fafa17e8cfc2c5c042da53507cfd1acb3e" args="" -->e_CLOSED</em>&nbsp;</td><td>
<p>The underlying stream used by this channel </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fa6f2b061c0524b51ad80ae1cd44e0b505"></a><!-- doxytag: member="e_FAILURE" ref="ad108cc12b44c814135812903da49551fa6f2b061c0524b51ad80ae1cd44e0b505" args="" -->e_FAILURE</em>&nbsp;</td><td>
<p>An I/O error occurred during the read </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fae89cb167dc0c7381d150577a6cfd96f4"></a><!-- doxytag: member="e_CANCELED" ref="ad108cc12b44c814135812903da49551fae89cb167dc0c7381d150577a6cfd96f4" args="" -->e_CANCELED</em>&nbsp;</td><td>
<p>The asynchronous read request was canceled. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abf0f67228fe00352763cca946d19f69b"></a><!-- doxytag: member="btlmt::AsyncChannel::~AsyncChannel" ref="abf0f67228fe00352763cca946d19f69b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual btlmt::AsyncChannel::~AsyncChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this channel. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a40529f78e22d0f2cf68ffd3d25071e00"></a><!-- doxytag: member="btlmt::AsyncChannel::read" ref="a40529f78e22d0f2cf68ffd3d25071e00" args="(int numBytes, const BlobBasedReadCallback &amp;readCallback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::AsyncChannel::read </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate an asynchronous read operation on this channel, or append this request to the currently pending requests if an asynchronous read operation was already initiated. When at least the specified <code>numBytes</code> of data are available after all previous requests have been processed, if any, the specified <code>readCallback</code> will be invoked (with <code>e_SUCCESS</code>). Return 0 on success, and a non-zero value otherwise. On error, the return value <em>may</em> equal to one of the enumerators in <code><a class="el" href="structbtlmt_1_1ChannelStatus.html#a4352e4c5f1558a16a42bff85712fe3dc">ChannelStatus::Enum</a></code>. </p>

<p>Implemented in <a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#af20c03421e1b18118c1fcacad40f14db">btlmt::ChannelPoolChannel</a>.</p>

</div>
</div>
<a class="anchor" id="abda8c1b331e8dbfaa4759373f74cd58d"></a><!-- doxytag: member="btlmt::AsyncChannel::timedRead" ref="abda8c1b331e8dbfaa4759373f74cd58d" args="(int numBytes, const bsls::TimeInterval &amp;timeout, const BlobBasedReadCallback &amp;readCallback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::AsyncChannel::timedRead </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate an asynchronous timed read operation on this channel, or append this request to the currently pending requests if an asynchronous read operation was already initiated, with an associated specified absolute <code>timeOut</code>. When at least the specified <code>numBytes</code> of data are available after all previous requests have been processed, if any, or when the <code>timeOut</code> is reached, the specified <code>readCallback</code> will be invoked (with either <code>e_SUCCESS</code> or <code>e_TIMEOUT</code>, respectively). Return 0 on success, and a non-zero value otherwise. On error, the return value <em>may</em> equal to one of the enumerators in <code><a class="el" href="structbtlmt_1_1ChannelStatus.html#a4352e4c5f1558a16a42bff85712fe3dc">ChannelStatus::Enum</a></code>. </p>

<p>Implemented in <a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a2b6096061a2d3b6115ff463249c86417">btlmt::ChannelPoolChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a66bb58eb273e0b4325c57f743feea7d4"></a><!-- doxytag: member="btlmt::AsyncChannel::write" ref="a66bb58eb273e0b4325c57f743feea7d4" args="(const btlb::Blob &amp;blob, int highWaterMark=INT_MAX)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::AsyncChannel::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>highWaterMark</em> = <code>INT_MAX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue the specified <code>blob</code> message to be written to this channel. Optionally provide <code>highWaterMark</code> to specify the maximum data size that can be enqueued. If <code>highWaterMark</code> is not specified then <code>INT_MAX</code> is used. Return 0 on success, and a non-zero value otherwise. On error, the return value <em>may</em> equal to one of the enumerators in <code><a class="el" href="structbtlmt_1_1ChannelStatus.html#a4352e4c5f1558a16a42bff85712fe3dc">ChannelStatus::Enum</a></code>. Note that success does not imply that the data has been written or will be successfully written to the underlying stream used by this channel. Also note that in addition to <code>highWatermark</code> the enqueued portion must also be less than a high watermark value supplied at the construction of this channel for the write to succeed. </p>

<p>Implemented in <a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a5c23e590c1ed2f2cd812d30e2bb13bc3">btlmt::ChannelPoolChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ab6fe7d9b78e55b1a894fbe91e472a08a"></a><!-- doxytag: member="btlmt::AsyncChannel::setSocketOption" ref="ab6fe7d9b78e55b1a894fbe91e472a08a" args="(int option, int level, int value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::AsyncChannel::setSocketOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>option</code> (of the specified <code>level</code>) socket option on this channel to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. (See <code>btlso_socketoptutil</code> for the list of commonly supported options.) </p>

<p>Implemented in <a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a534fad974a90d0dc84573dee069de8ae">btlmt::ChannelPoolChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a5675a6b49a9c262de4ea87914ae61437"></a><!-- doxytag: member="btlmt::AsyncChannel::cancelRead" ref="a5675a6b49a9c262de4ea87914ae61437" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::AsyncChannel::cancelRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel all pending <code>read</code> or <code>timedRead</code> requests, and invoke their read callbacks with a <code>e_CANCELED</code> status. Note that if the channel has not been closed, the read callbacks are invoked in the thread in which the channel's data callbacks are invoked, else they are invoked in the thread calling <code>cancelRead</code>. </p>

<p>Implemented in <a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a453b1614cdac188b848be3053ccdae0d">btlmt::ChannelPoolChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af20340aa5d3fd2ed875533d12715acf5"></a><!-- doxytag: member="btlmt::AsyncChannel::close" ref="af20340aa5d3fd2ed875533d12715acf5" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::AsyncChannel::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shutdown this channel, and cancel all pending <code>read</code> or <code>timedRead</code> requests (but do not invoke them). </p>

<p>Implemented in <a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#adece697dec8b2e46a201a631549dce7f">btlmt::ChannelPoolChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a837e8ce93384cf3a52679bf2751ab482"></a><!-- doxytag: member="btlmt::AsyncChannel::localAddress" ref="a837e8ce93384cf3a52679bf2751ab482" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> btlmt::AsyncChannel::localAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the "local" end of this channel. </p>

<p>Implemented in <a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a0e7da2601843bc5df9b4c6814f61e8da">btlmt::ChannelPoolChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a82e42998d5636d66143b518a70e72973"></a><!-- doxytag: member="btlmt::AsyncChannel::peerAddress" ref="a82e42998d5636d66143b518a70e72973" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> btlmt::AsyncChannel::peerAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the "remote" end of this channel. </p>

<p>Implemented in <a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a1d068c796754864fd1e592ee55442812">btlmt::ChannelPoolChannel</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlmt__asyncchannel_8h_source.html">btlmt_asyncchannel.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:12 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
