<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BSL 2.20 OSS</title>
<html>
<pre>
// bdldfp_decimalimplutil.h                                           -*-C++-*-
#ifndef INCLUDED_BDLDFP_DECIMALIMPLUTIL
#define INCLUDED_BDLDFP_DECIMALIMPLUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$&quot;)

//@PURPOSE: Provide utilities to help implement decimal floating-point types.
//
//@CLASSES:
//  bdldfp::DecimalImplUtil: Namespace for decimal FP implementation functions
//
//@MACROS:
//  BDLDFP_DECIMALIMPLUTIL_DF: ValueType32  from literal
//  BDLDFP_DECIMALIMPLUTIL_DD: ValueType64  from literal
//  BDLDFP_DECIMALIMPLUTIL_DL: ValueType128 from literal
//
//@SEE ALSO: bdldfp_decimal, bdldfp_decimalplatform
//
//@DESCRIPTION:
// This component is for internal use only by the &#39;bdldfp_decimal*&#39; components.
// Direct use of any names declared in this component by any other code invokes
// undefined behavior.  In other words: this code may change, disappear, break,
// move without notice, and no support whatsoever will ever be provided for it.
//
// This component contains:
//
//: o portable decimal floating-point macros that create the implementation
//:   type (C99 or &#39;decNumber&#39; library)
//:
//: o the decimal floating-point environment/context for &#39;decNumber&#39; library
//:   (when it is used)
//:
//: o the definitions of the implementation types (to be used, e.g., as members
//:   in the &#39;DecimalN&#39; types)
//:
//: o the parsing functions that turn literals into values on platforms that do
//:   not yet support decimal floating-point literals, and possibly to use by
//:   stream input operators.
//
///Usage
///-----
// This section shows the intended use of this component.
//
///Example 1: Parse a decimal floating point literal
///- - - - - - - - - - - - - - - - - - - - - - - - -
// Decimal floating points are used to represent numbers for which the exact
// decimal representation is known and we wish to avoid rounding errors that
// are introduced when the number is represented in binary.  It is sometimes of
// interest to create a decimal floating point value from its string
// representation.  The functions of this component allow us to work with
// types for which we may create representations for 32-, 64-, and 128-bit
// decimal floating point values.
//
// As an example, one mile is equal to &#39;1.6093&#39; kilometers exactly.  First, we
// create the 64-bit pattern for the 64-bit decimal floating point value of
// &#39;1.6093&#39;.
//..
// BloombergLP::bdldfp::DecimalImplUtil::ValueType64 kilometersPerMile =
//     BloombergLP::bdldfp::DecimalImplUtil::parse64(&quot;1.6093&quot;);
//..
// Now, if a mantissa and an exponent within range of the decimal floating
// point type are given, we can also create the decimal floating point value of
// interest with the functions of &#39;&#39;makeDecimalRawXX.  For example, the 32-bit
// decimal floating point type can store 7 mantissa digits and has an exponent
// range of &#39;-101&#39; to &#39;90&#39; inclusive.  It therefore may fit a mantissa of
// &#39;16093&#39; and an exponent of &#39;-4&#39;, representing the value of &#39;1.6093&#39;
// (&#39;16093&#39; times ten to the power of &#39;-4&#39;).  We create this value using
// &#39;makeDecimalRaw32&#39;.
//..
// BloombergLP::bdldfp::DecimalImplUtil::ValueType32
//     kilometersPerMileMakeDecimal =
//         BloombergLP::bdldfp::DecimalImplUtil::makeDecimalRaw32(16093, -4);
//..
// Finally, we verify that we obtain the same result without introducing
// rounding errors with both implementations.
//..
// assert(BloombergLP::bdldfp::DecimalImplUtil::equals(kilometersPerMile,
//      kilometersPerMileMakeDecimal));
//..
//
///Example 2: Create a 64-bit decimal floating point with possible adjustment
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to create a &#39;bdldfp::Decimal64&#39;, but have a mantissa and/or
// the exponent that is out of the range that can be exactly represented by a
// 64-bit decimal floating point type.  Notice that a 64-bit decimal floating
// point value may represent a mantissa of up to 16 figures, and an exponent
// between &#39;-6176&#39; and &#39;6111&#39; inclusive.  For example, on February 13, 2014,
// the US National Debt in Japanese Yen is approximately
// &#39;1,765,002,361,949,679.79&#39; Japanese Yen.  This number can be represented
// with a mantissa of &#39;176500236194967979&#39; and an exponent of &#39;-2&#39;.  First, we
// create this number.
//..
// BloombergLP::bdldfp::DecimalImplUtil::ValueType64 usNationalDebtInJpy =
//     BloombergLP::bdldfp::DecimalImplUtil::makeDecimal64(
//         176500236194967979ull, -2);
//..
// Notice that &#39;176500236194967979&#39; contains 18 significant figures, more
// than can be represented by a 64-bit decimal floating point type.
//
// Now, the number can also be parsed as a string.
//..
// BloombergLP::bdldfp::DecimalImplUtil::ValueType64
//     usNationalDebtInJpyParse =
//        BloombergLP::bdldfp::DecimalImplUtil::parse64(&quot;1765002361949679.79&quot;);
//..
// Finally, we verify that we obtain the same result.
//..
// assert(BloombergLP::bdldfp::DecimalImplUtil::equals(usNationalDebtInJpy,
//      usNationalDebtInJpyParse));
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLDFP_DECIMALPLATFORM
#include &lt;bdldfp_decimalplatform.h&gt;
#endif

#if BDLDFP_DECIMALPLATFORM_C99_TR

        // Implementation when we have C DecFP support only (no C++)

#define BDLDFP_DECIMALIMPLUTIL_JOIN_(a,b) a##b
    // Helper macro to create floating-point decimal literals

               // Portable decimal floating-point literal support

#define BDLDFP_DECIMALIMPLUTIL_DF(lit) BDLDFP_DECIMALIMPLUTIL_JOIN_(lit,df)

#define BDLDFP_DECIMALIMPLUTIL_DD(lit) BDLDFP_DECIMALIMPLUTIL_JOIN_(lit,dd)

#define BDLDFP_DECIMALIMPLUTIL_DL(lit) BDLDFP_DECIMALIMPLUTIL_JOIN_(lit,dl)

#elif BDLDFP_DECIMALPLATFORM_DECNUMBER

    // Generic decimal floating-point implementation for compilers that do not
    // support the C _DecimalNN types follows; it uses the decNumber library.

#ifndef INCLUDED_DECSINGLE
   extern &quot;C&quot; {
#   include &lt;decSingle.h&gt;
   }
#  define INCLUDED_DECSINGLE
#endif

                // DECIMAL FLOATING-POINT LITERAL EMULATION

#define BDLDFP_DECIMALIMPLUTIL_DF(lit)                                        \
    BloombergLP::bdldfp::DecimalImplUtil::parse32(                            \
        (BloombergLP::bdldfp::DecimalImplUtil::checkLiteral(lit), #lit))

#define BDLDFP_DECIMALIMPLUTIL_DD(lit)                                        \
    BloombergLP::bdldfp::DecimalImplUtil::parse64(                            \
        (BloombergLP::bdldfp::DecimalImplUtil::checkLiteral(lit), #lit))

#define BDLDFP_DECIMALIMPLUTIL_DL(lit)                                        \
    BloombergLP::bdldfp::DecimalImplUtil::parse128(                           \
        (BloombergLP::bdldfp::DecimalImplUtil::checkLiteral(lit), #lit))

            // End of decNumber-base implementation specific area

#else
namespace BloombergLP {
namespace bdldfp {

struct DecimalImpl_Assert;
    // This &#39;struct&#39; is deliberately not defined, and is declared only to help
    // force a compilation error below, for badly configured builds.

#  error Unknown architecture, decimal floating-point not upported.
char die[sizeof(DecimalImpl_Assert)];     // if &#39;#error&#39; unsupported

}  // close package namespace
}  // close enterpise namespace
#endif

namespace BloombergLP {
namespace bdldfp {

                          // =====================
                          // class DecimalImplUtil
                          // =====================

struct DecimalImplUtil {
    // This &#39;struct&#39; provides a namespace for implementation functions that
    // work in terms of the underlying C-style decimal floating point
    // implementation (e.g., decNumber library or compiler implementation of
    // the C Decimal TR).

    // TYPES
#if BDLDFP_DECIMALPLATFORM_C99_TR

    typedef _Decimal32  ValueType32;
    typedef _Decimal64  ValueType64;
    typedef _Decimal128 ValueType128;

#elif BDLDFP_DECIMALPLATFORM_DECNUMBER

    typedef decSingle ValueType32;
    typedef decDouble ValueType64;
    typedef decQuad   ValueType128;

    // CLASS METHODS
    static decContext *getDecNumberContext();
        // Return a pointer providing modifiable access to the floating point
        // environment of the &#39;decNumber&#39; library.  This function exists on
        // certain supported platforms only.

    struct This_is_not_a_floating_point_literal {};
        // This &#39;struct&#39; is a helper type used togenerate error messages for
        // bad literals.

    template &lt;class T&gt;
    static void checkLiteral(const T&amp; t);
        // Generate an error for bad decimal floating-point literals

    static void checkLiteral(double);
        // Overload to avoid an error when the decimal floating-point literal
        // (without the suffix) can be interpreted as a &#39;double&#39; literal.
#endif

                      // Parsing and formatting

    // CLASS METHODS
    static ValueType32 parse32(const char *input);
        // Parse the specified &#39;input&#39; string as a 32 bit decimal floating-
        // point value and return the result.  The parsing is as specified for
        // the &#39;strtod32&#39; function in section 9.6 of the ISO/EIC TR 24732 C
        // Decimal Floating-Point Technical Report.  The behavior is undefined
        // unless &#39;input&#39; represents a valid 32 bit decimal floating-point
        // number in scientific or fixed notation, and no unrelated characters
        // precede (not even whitespace) that textual representation and a
        // terminating nul character immediately follows it.

    static ValueType64 parse64(const char *input);
        // Parse the specified &#39;input&#39; string as a 64 bit decimal floating-
        // point value and return the result.  The parsing is as specified for
        // the &#39;strtod64&#39; function in section 9.6 of the ISO/EIC TR 24732 C
        // Decimal Floating-Point Technical Report.  The behavior is undefined
        // unless &#39;input&#39; represents a valid 64 bit decimal floating-point
        // number in scientific or fixed notation, and no unrelated characters
        // precede (not even whitespace) that textual representation and a
        // terminating nul character immediately follows it.

    static ValueType128 parse128(const char *input);
        // Parse the specified &#39;input&#39; string as a 128 bit decimal floating-
        // point value and return the result.  The parsing is as specified for
        // the &#39;strtod128&#39; function in section 9.6 of the ISO/EIC TR 24732 C
        // Decimal Floating-Point Technical Report.  The behavior is undefined
        // unless &#39;input&#39; represents a valid 128 bit decimal floating-point
        // number in scientific or fixed notation, and no unrelated characters
        // precede (not even whitespace) that textual representation and a
        // terminating nul character immediately follows it.

    static ValueType32  convertToDecimal32 (const ValueType64&amp;  input);
    static ValueType64  convertToDecimal64 (const ValueType32&amp;  input);
    static ValueType64  convertToDecimal64 (const ValueType128&amp; input);
    static ValueType128 convertToDecimal128(const ValueType32&amp;  input);
    static ValueType128 convertToDecimal128(const ValueType64&amp;  input);
        // Convert the specified &#39;input&#39; to the indicated result type.  Note
        // that a conversion from &#39;ValueType128&#39; to &#39;ValueType32&#39; is not
        // provided (because such a conversion is not provided by the
        // &#39;decNumber&#39; library).  A conversion from 128-bit to 32-bit
        // representations is *not* identical to the composing the conversions
        // from 128-bit to 64-bit, and 64-bit to 32-bit representations,
        // because rounding should only be performed once.

    static ValueType32  makeDecimalRaw32(int          mantissa,
                                         int          exponent);
        // Create a &#39;ValueType32&#39; object representing a decimal floating point
        // number consisting of the specified &#39;mantissa&#39; and &#39;exponent&#39;, with
        // the sign given by the specified &#39;mantissa&#39;.  The behavior is
        // undefined unless &#39;abs(mantissa) &lt;= 9,999,999&#39; and
        // &#39;-101 &lt;= exponent &lt;= 90&#39;.

    static ValueType64  makeDecimalRaw64(unsigned long long mantissa,
                                         int                exponent);
    static ValueType64  makeDecimalRaw64(long long          mantissa,
                                         int                exponent);
    static ValueType64  makeDecimalRaw64(unsigned int       mantissa,
                                         int                exponent);
    static ValueType64  makeDecimalRaw64(int                mantissa,
                                         int                exponent);
        // Create a &#39;ValueType64&#39; object representing a decimal floating point
        // number consisting of the specified &#39;mantissa&#39; and &#39;exponent&#39;, with
        // the sign given by the specified &#39;mantissa&#39;.  The behavior is
        // undefined unless &#39;abs(mantissa) &lt;= 9,999,999,999,999,999&#39; and
        // &#39;-398 &lt;= exponent &lt;= 369&#39;.

    static ValueType128 makeDecimalRaw128(unsigned long long mantissa,
                                          int                exponent);
    static ValueType128 makeDecimalRaw128(long long          mantissa,
                                          int                exponent);
    static ValueType128 makeDecimalRaw128(unsigned int       mantissa,
                                          int                exponent);
    static ValueType128 makeDecimalRaw128(int                mantissa,
                                          int                exponent);
        // Create a &#39;ValueType128&#39; object representing a decimal floating
        // point number consisting of the specified &#39;mantissa&#39; and &#39;exponent&#39;,
        // with the sign given by the specified &#39;mantissa&#39;.  The behavior is
        // undefined unless &#39;-6176 &lt;= exponent &lt;= 6111&#39;.

    static ValueType64  makeDecimal64(unsigned long long mantissa,
                                      int                exponent);
    static ValueType64  makeDecimal64(long long          mantissa,
                                      int                exponent);
    static ValueType64  makeDecimal64(unsigned int       mantissa,
                                      int                exponent);
    static ValueType64  makeDecimal64(int                mantissa,
                                      int                exponent);
        // Create a &#39;ValueType64&#39; object representing a decimal floating point
        // number having the value given by the specified &#39;mantissa&#39; times ten
        // to the power of the specified &#39;exponent&#39;.  This function will return
        // &#39;inf&#39; with the sign of &#39;mantissa&#39; if this number has a magnitude too
        // great to be represented, and &#39;0&#39; if this number has a magnitude too
        // small to be represented.  In the event that
        // &#39;abs(mantissa) &lt;= 9,999,999,999,999,999&#39; and
        // &#39;-398 &lt;= exponent &lt;= 369&#39;, a &#39;ValueType64&#39; object representing a
        // decimal floating point value consisting of &#39;mantissa&#39; and
        // &#39;exponent&#39;, with the sign given by &#39;mantissa&#39;, is returned.
        // Otherwise, rounding will be performed.  The number closest to this
        // value that may be represented by a &#39;ValueType64&#39; is returned.  Note
        // that this function can never return &#39;NaN&#39;.  Also note that this
        // function may return +0, rather than -0 (as required by the IEEE
        // 754-2008 standard), for negative values whose magnitude is too small
        // to represented, this reflects the (non-conforming) behavior of the
        // the underlying &#39;decNumber&#39; library implementation.

        // Comparison functions.
    static bool equals(ValueType32  lhs, ValueType32  rhs);
    static bool equals(ValueType32  lhs, ValueType64  rhs);
    static bool equals(ValueType32  lhs, ValueType128 rhs);
    static bool equals(ValueType64  lhs, ValueType32  rhs);
    static bool equals(ValueType64  lhs, ValueType64  rhs);
    static bool equals(ValueType64  lhs, ValueType128 rhs);
    static bool equals(ValueType128 lhs, ValueType32  rhs);
    static bool equals(ValueType128 lhs, ValueType64  rhs);
    static bool equals(ValueType128 lhs, ValueType128 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value, and
    // &#39;false&#39; otherwise.  Two decimal objects have the same value if the
    // &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representations equal.  In
    // other words, two decimal objects have the same value if:
    //
    //: o both have a zero value (positive or negative), or
    //: o both have the same infinity value (both positive or negative), or
    //: o both have the value of a real number that are equal, even if they are
    //:   represented differently (cohorts have the same value)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.
};

#if BDLDFP_DECIMALPLATFORM_DECNUMBER

                          // ---------------------
                          // class DecimalImplUtil
                          // ---------------------

template &lt;class T&gt;
inline
void DecimalImplUtil::checkLiteral(const T&amp; t)
{
    (void)static_cast&lt;This_is_not_a_floating_point_literal&gt;(t);
}

inline
void DecimalImplUtil::checkLiteral(double)
{
}

#endif

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2014 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
