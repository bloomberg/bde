<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlb_bitstringimputil.h                                            -*-C++-*-
#ifndef INCLUDED_BDLB_BITSTRINGIMPUTIL
#define INCLUDED_BDLB_BITSTRINGIMPUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide functional bit-manipulation of &#39;uint64_t&#39; values.
//
//@CLASSES:
//  bdlb::BitStringImpUtil: namespace for &#39;uint64_t&#39; utilities
//
//@SEE_ALSO: bdlb_bitstringutil
//
//@DESCRIPTION: This component provides a utility &#39;struct&#39;,
// &#39;bdlb::BitStringImpUtil&#39;, that serves as a namespace for a collection of
// functions that provide bit-level operations on &#39;uint64_t&#39; values.  Some of
// these functions consist of a single bitwise logical operation.  The point of
// implementing them as functions is to facilitate providing these functions as
// arguments to templates in &#39;bdlb_bitstringutil&#39;.
//
// Note that no functions supporting &#39;uint32_t&#39; are provided here.  This
// component exists solely to support &#39;bdlb::BitStringUtil&#39;, which deals
// entirely in &#39;uint64_t&#39; values.
//
// Note that the &#39;find*&#39; functions defined here only find set bits -- there is
// never a context in &#39;bdlb_bitstringutil&#39; where a &#39;find*&#39; that found clear
// bits is needed.
//
///Usage
///-----
// This section illustrates the intended use of this component.
//
// Note that, in all of these examples, the low-order bit is considered bit 0
// and resides on the right edge of the bit string.
//
///Example 1: Manipulators
///- - - - - - - - - - - -
// This example demonstrates the &quot;manipulator&quot; static functions defined in this
// component, which can change the state of a &#39;uint64_t&#39;.
//
// The &#39;*EqBits&#39; functions (&#39;andEqBits&#39;, &#39;minusEqBits&#39;, &#39;orEqBits&#39;, and
// &#39;xorEqBits&#39;), have the following signature:
//..
//    void function(uint64_t *dstValue,
//                  int       dstIndex,
//                  uint64_t  srcValue,
//                  int       numBits);
//..
// First, we demonstrate the &#39;andEqBits&#39; function:
//..
// +--------------------------------------------------------------------------+
// | &#39;bdlb::BitStringImpUtil::andEqBits(&amp;dstValue, 8, 0, 8)&#39; in binary:       |
// |                                                                          |
// | &#39;dstValue&#39; before in binary:       0..00000000000000000011001100110011   |
// | &#39;srcValue == 0&#39; in binary:         0..00000000000000000000000000000000   |
// | &#39;srcValue&#39;, 0x00, at index 8:                         00000000           |
// | &#39;dstValue&#39; after in binary:        0..00000000000000000000000000110011   |
// +--------------------------------------------------------------------------+
//
//  uint64_t dstValue;
//
//  dstValue = 0x3333;
//  bdlb::BitStringImpUtil::andEqBits(&amp;dstValue, 8, 0, 8);
//  assert(static_cast&lt;uint64_t&gt;(0x33) == dstValue);
//..
// Then, we apply &#39;andEqBits&#39; with all bits set in the relevant part of
// &#39;srcValue, which has no effect:
//..
// +--------------------------------------------------------------------------+
// | &#39;bdlb::BitStringImpUtil::andEqBits(&amp;dstValue, 8, 0, 8)&#39; in binary:       |
// |                                                                          |
// | &#39;dstValue&#39; before in binary:       0..00000000000000000011001100110011   |
// | &#39;srcValue == 0xffff&#39; in binary:    0..00000000000000001111111111111111   |
// | &#39;srcValue&#39;, 0xff, at index 8:                         11111111           |
// | &#39;dstValue&#39; after in binary:        0..00000000000000000011001100110011   |
// +--------------------------------------------------------------------------+
//
//  dstValue = 0x3333;
//  bdlb::BitStringImpUtil::andEqBits(&amp;dstValue, 8, 0xffff, 8);
//  assert(static_cast&lt;uint64_t&gt;(0x3333) == dstValue);
//..
// Next, we demonstrate &#39;orEqBits&#39;, which takes low-order bits of a &#39;srcValue&#39;
// and bitwise ORs them with &#39;dstValue&#39;:
//..
// +--------------------------------------------------------------------------+
// | &#39;bdlb::BitStringImpUtil::orEqBits(&amp;dstValue, 16, 0xffff, 8)&#39; in binary:  |
// |                                                                          |
// | &#39;dstValue&#39; before in binary:       0..00110011001100110011001100110011   |
// | &#39;srcValue == 0xffff&#39; in binary:    0..00000000000000001111111111111111   |
// | &#39;srcValue&#39;, 0xff, at index 16:                11111111                   |
// | &#39;dstValue&#39; after in binary:        0..00110011111111110011001100110011   |
// +--------------------------------------------------------------------------+
//
//  dstValue = 0x33333333;
//  bdlb::BitStringImpUtil::orEqBits(&amp;dstValue, 16, 0xffff, 8);
//  assert(static_cast&lt;uint64_t&gt;(0x33ff3333) == dstValue);
//..
// Then, we demonstrate applying the same operation where &#39;*dstValue&#39; is
// initially 0:
//..
// +--------------------------------------------------------------------------+
// | &#39;bdlb::BitStringImpUtil::orEqBits(&amp;dstValue, 16, 0xffff, 8)&#39; in binary:  |
// |                                                                          |
// | &#39;dstValue&#39; before in binary:       0..00000000000000000000000000000000   |
// | &#39;srcValue == 0xffff&#39; in binary:    0..00000000000000001111111111111111   |
// | &#39;srcValue&#39;, 0xff, at index 16:                11111111                   |
// | &#39;dstValue&#39; after in binary:        0..00000000111111110000000000000000   |
// +--------------------------------------------------------------------------+
//
//  dstValue = 0;
//  bdlb::BitStringImpUtil::orEqBits(&amp;dstValue, 16, 0xffff, 8);
//  assert(static_cast&lt;uint64_t&gt;(0x00ff0000) == dstValue);
//..
// Now, we apply another function, &#39;xorEqBits&#39;, that takes the low-order bits
// of &#39;srcValue&#39; and bitwise XORs them with &#39;dstValue&#39;:
//..
// +--------------------------------------------------------------------------+
// | &#39;bdlb::BitStringImpUtil::xorEqBits(&amp;dstValue, 16, 0xffff, 8)&#39; in binary: |
// |                                                                          |
// | &#39;dstValue&#39; before in binary:       0..01110111011101110111011101110111   |
// | &#39;srcValue&#39;, 0xff, at index 16:                11111111                   |
// | &#39;dstValue&#39; after in binary:        0..01110111100010000111011101110111   |
// ----------------------------------------------------------------------------
//
//  dstValue = 0x77777777;
//  bdlb::BitStringImpUtil::xorEqBits(&amp;dstValue, 16, 0xffff, 8);
//  assert(static_cast&lt;uint64_t&gt;(0x77887777) == dstValue);
//..
// Finally, we apply the same function with a different value of &#39;srcValue&#39;
// and observe the result:
//..
// +--------------------------------------------------------------------------+
// | &#39;bdlb::BitStringImpUtil::xorEqBits(&amp;dstValue, 16, 0x5555, 8)&#39; in binary: |
// |                                                                          |
// | &#39;dstValue&#39; before in binary:       0..01110111011101110111011101110111   |
// | &#39;srcValue&#39;, 0x55, at index 16:                01010101                   |
// | &#39;dstValue&#39; after in binary:        0..01110111001000100111011101110111   |
// +--------------------------------------------------------------------------+
//
//  dstValue = 0x77777777;
//  bdlb::BitStringImpUtil::xorEqBits(&amp;dstValue, 16, 0x5555, 8);
//  assert(static_cast&lt;uint64_t&gt;(0x77227777) == dstValue);
//..
//
///Accessors
///- - - - -
// This example demonstrates the &quot;accessor&quot; static functions, which read, but
// do not modify, the state of a &#39;uint64_t&#39;.
//
// The &#39;find1At(Max,Min)IndexRaw&#39; routines are used for finding the
// highest-order (or lowest-order) set bit in a &#39;uint64_t&#39;.  These functions
// are &quot;raw&quot; because the behavior is undefined if they are passed 0.
//
// First, we apply &#39;find1AtMaxIndexRaw&#39;:
//..
// +--------------------------------------------------------------------------+
// | &#39;bdlb::BitStringImpUtil::find1AtMaxIndexRaw(0x10a)&#39; in binary:           |
// |                                                                          |
// | input:                             0..000000000000000000000000100001010  |
// | bit 8, highest bit set:                                       1          |
// +--------------------------------------------------------------------------+
//
//  assert(8 == bdlb::BitStringImpUtil::find1AtMaxIndexRaw(0x10a));
//..
// Finally, we apply &#39;find1AtMinIndexRaw&#39;:
//..
// +--------------------------------------------------------------------------+
// | &#39;bdlb::BitStringImpUtil::find1AtMinIndexRaw(0xffff0180)&#39; in binary:      |
// |                                                                          |
// | input:                             0..011111111111111110000000110000000  |
// | bit 7, lowest bit set:                                         1         |
// +--------------------------------------------------------------------------+
//
//  assert(7 == bdlb::BitStringImpUtil::find1AtMinIndexRaw(0xffff0180));
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLB_BITMASKUTIL
#include &lt;bdlb_bitmaskutil.h&gt;
#endif

#ifndef INCLUDED_BDLB_BITUTIL
#include &lt;bdlb_bitutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDINT
#include &lt;bsl_cstdint.h&gt;
#endif

namespace BloombergLP {
namespace bdlb {

                           // =======================
                           // struct BitStringImpUtil
                           // =======================

struct BitStringImpUtil {
    // This &#39;struct&#39; provides a namespace for static functions to be used
    // solely in the implementation of &#39;BitStringUtil&#39;.  The &quot;Manipulators&quot;
    // are intended to be provided as arguments to templates in
    // &#39;bdlb_bitstringutil&#39;, whereas the &quot;Accessors&quot; are to be called directly
    // within that component.

    // PUBLIC TYPES
    enum { k_BITS_PER_UINT64 = 64 };  // number of bits in &#39;uint64_t&#39;

    // CLASS METHODS

                                // Manipulators

    static void andEqBits(bsl::uint64_t *dstValue,
                          int            dstIndex,
                          bsl::uint64_t  srcValue,
                          int            numBits);
        // Bitwise AND the specified least-significant &#39;numBits&#39; in the
        // specified &#39;srcValue&#39; to those in the specified &#39;dstValue&#39; starting
        // at the specified &#39;dstIndex&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= dstIndex&#39;, &#39;0 &lt;= numBits&#39;, and
        // &#39;dstIndex + numBits &lt;= k_BITS_PER_UINT64&#39;.

    static void andEqWord(bsl::uint64_t *dstValue, bsl::uint64_t srcValue);
        // Assign to the specified &#39;*dstValue&#39; the value of &#39;*dstValue&#39; bitwise
        // AND-ed with the specified &#39;srcValue&#39;.

    static void minusEqBits(bsl::uint64_t *dstValue,
                            int            dstIndex,
                            bsl::uint64_t  srcValue,
                            int            numBits);
        // Bitwise MINUS the specified least-significant &#39;numBits&#39; in the
        // specified &#39;srcValue&#39; from those in the specified &#39;dstValue&#39; starting
        // at the specified &#39;dstIndex&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= dstIndex&#39;, &#39;0 &lt;= numBits&#39;, and
        // &#39;dstIndex + numBits &lt;= k_BITS_PER_UINT64&#39;.  Note that the bitwise
        // difference, &#39;a - b&#39;, is defined in C++ code as &#39;a &amp; ~b&#39;.

    static void minusEqWord(bsl::uint64_t *dstValue, bsl::uint64_t srcValue);
        // Assign to the specified &#39;*dstValue&#39; the value of &#39;*dstValue&#39; bitwise
        // AND-ed with the complement of the specified &#39;srcValue&#39;.

    static void orEqBits(bsl::uint64_t *dstValue,
                         int            dstIndex,
                         bsl::uint64_t  srcValue,
                         int            numBits);
        // Bitwise OR the specified least-significant &#39;numBits&#39; in the
        // specified &#39;srcValue&#39; to those in the specified &#39;dstValue&#39; starting
        // at the specified &#39;dstIndex&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= dstIndex&#39;, &#39;0 &lt;= numBits&#39;, and
        // &#39;dstIndex + numBits &lt;= k_BITS_PER_UINT64&#39;.

    static void orEqWord(bsl::uint64_t *dstValue, bsl::uint64_t srcValue);
        // Assign to the specified &#39;*dstValue&#39; the value of &#39;*dstValue&#39; bitwise
        // OR-ed with the specified &#39;srcValue&#39;.

    static void setEqBits(bsl::uint64_t *dstValue,
                          int            dstIndex,
                          bsl::uint64_t  srcValue,
                          int            numBits);
        // Replace the specified &#39;numBits&#39; in the specified &#39;dstValue&#39; starting
        // at the specified &#39;dstIndex&#39; with the least-significant &#39;numBits&#39; of
        // the specified &#39;srcValue&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= dstIndex&#39;, &#39;0 &lt;= numBits&#39;, and
        // &#39;dstIndex + numBits &lt;= k_BITS_PER_UINT64&#39;.

    static void setEqWord(bsl::uint64_t *dstValue, bsl::uint64_t srcValue);
        // Assign to the specified &#39;*dstValue&#39; the value of the specified
        // &#39;srcValue&#39;.

    static void xorEqBits(bsl::uint64_t *dstValue,
                          int            dstIndex,
                          bsl::uint64_t  srcValue,
                          int            numBits);
        // Bitwise XOR the specified least-significant &#39;numBits&#39; in the
        // specified &#39;srcValue&#39; to those in the specified &#39;dstValue&#39; starting
        // at the specified &#39;dstIndex&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= dstIndex&#39;, &#39;0 &lt;= numBits&#39;, and
        // &#39;dstIndex + numBits &lt;= k_BITS_PER_UINT64&#39;.

    static void xorEqWord(bsl::uint64_t *dstValue, bsl::uint64_t srcValue);
        // Assign to the specified &#39;*dstValue&#39; the value of &#39;*dstValue&#39; bitwise
        // XOR-ed with the specified &#39;srcValue&#39;.

                                // Accessors

    static int find1AtMaxIndexRaw(bsl::uint64_t value);
        // Return the index of the highest-order set bit in the specified
        // non-zero &#39;value&#39;.  The behavior is undefined unless &#39;0 != value&#39;.
        // Note that this method is &quot;raw&quot; due to the requirement that at least
        // one bit in &#39;value&#39; must be set.

    static int find1AtMinIndexRaw(bsl::uint64_t value);
        // Return the index of the lowest-order set bit in the specified
        // non-zero &#39;value&#39;.  The behavior is undefined unless &#39;0 != value&#39;.
        // Note that this method is &quot;raw&quot; due to the requirement that at least
        // one bit in &#39;value&#39; must be set.
};

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                           // -----------------------
                           // struct BitStringImpUtil
                           // -----------------------

                                // Manipulators

inline
void BitStringImpUtil::andEqBits(bsl::uint64_t *dstValue,
                                 int            dstIndex,
                                 bsl::uint64_t  srcValue,
                                 int            numBits)
{
    BSLS_ASSERT_SAFE(dstValue);
    BSLS_ASSERT_SAFE(                 0 &lt;= dstIndex);
    BSLS_ASSERT_SAFE(                 0 &lt;= numBits);
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= k_BITS_PER_UINT64);

    if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(dstIndex &lt; k_BITS_PER_UINT64)) {
        *dstValue &amp;= BitMaskUtil::zero64(dstIndex, numBits) |
                                                       (srcValue &lt;&lt; dstIndex);
    }
}

inline
void BitStringImpUtil::andEqWord(bsl::uint64_t *dstValue,
                                 bsl::uint64_t  srcValue)
{
    BSLS_ASSERT_SAFE(dstValue);

    *dstValue &amp;= srcValue;
}

inline
void BitStringImpUtil::minusEqBits(bsl::uint64_t *dstValue,
                                   int            dstIndex,
                                   bsl::uint64_t  srcValue,
                                   int            numBits)
{
    BSLS_ASSERT_SAFE(dstValue);
    BSLS_ASSERT_SAFE(                 0 &lt;= dstIndex);
    BSLS_ASSERT_SAFE(                 0 &lt;= numBits);
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= k_BITS_PER_UINT64);

    if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(dstIndex &lt; k_BITS_PER_UINT64)) {
        *dstValue &amp;= BitMaskUtil::zero64(dstIndex, numBits) |
                                                      (~srcValue &lt;&lt; dstIndex);
    }
}

inline
void BitStringImpUtil::minusEqWord(bsl::uint64_t *dstValue,
                                   bsl::uint64_t  srcValue)
{
    BSLS_ASSERT_SAFE(dstValue);

    *dstValue &amp;= ~srcValue;
}

inline
void BitStringImpUtil::orEqBits(bsl::uint64_t *dstValue,
                                int            dstIndex,
                                bsl::uint64_t  srcValue,
                                int            numBits)
{
    BSLS_ASSERT_SAFE(dstValue);
    BSLS_ASSERT_SAFE(                 0 &lt;= dstIndex);
    BSLS_ASSERT_SAFE(                 0 &lt;= numBits);
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= k_BITS_PER_UINT64);

    if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(dstIndex &lt; k_BITS_PER_UINT64)) {
        *dstValue |= (srcValue &amp; BitMaskUtil::lt64(numBits)) &lt;&lt; dstIndex;
    }
}

inline
void BitStringImpUtil::orEqWord(bsl::uint64_t *dstValue,
                                bsl::uint64_t  srcValue)
{
    BSLS_ASSERT_SAFE(dstValue);

    *dstValue |= srcValue;
}

inline
void BitStringImpUtil::setEqBits(bsl::uint64_t *dstValue,
                                 int            dstIndex,
                                 bsl::uint64_t  srcValue,
                                 int            numBits)
{
    BSLS_ASSERT_SAFE(dstValue);
    BSLS_ASSERT_SAFE(0                  &lt;= dstIndex);
    BSLS_ASSERT_SAFE(0                  &lt;= numBits);
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= k_BITS_PER_UINT64);

    if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(dstIndex &lt; k_BITS_PER_UINT64)) {
        const bsl::uint64_t mask = BitMaskUtil::lt64(numBits);

        *dstValue &amp;= ~(mask &lt;&lt; dstIndex);
        *dstValue |= (srcValue &amp; mask) &lt;&lt; dstIndex;
    }
}

inline
void BitStringImpUtil::setEqWord(bsl::uint64_t *dstValue,
                                 bsl::uint64_t  srcValue)
{
    BSLS_ASSERT_SAFE(dstValue);

    *dstValue = srcValue;
}

inline
void BitStringImpUtil::xorEqBits(bsl::uint64_t *dstValue,
                                 int            dstIndex,
                                 bsl::uint64_t  srcValue,
                                 int            numBits)
{
    BSLS_ASSERT_SAFE(dstValue);
    BSLS_ASSERT_SAFE(                 0 &lt;= dstIndex);
    BSLS_ASSERT_SAFE(                 0 &lt;= numBits);
    BSLS_ASSERT_SAFE(dstIndex + numBits &lt;= k_BITS_PER_UINT64);

    if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(dstIndex &lt; k_BITS_PER_UINT64)) {
        *dstValue ^= (srcValue &amp; BitMaskUtil::lt64(numBits)) &lt;&lt; dstIndex;
    }
}

inline
void BitStringImpUtil::xorEqWord(bsl::uint64_t *dstValue,
                                 bsl::uint64_t  srcValue)
{
    BSLS_ASSERT_SAFE(dstValue);

    *dstValue ^= srcValue;
}

                                // Accessors

inline
int BitStringImpUtil::find1AtMaxIndexRaw(bsl::uint64_t value)
{
    BSLS_ASSERT_SAFE(0 != value);

    return k_BITS_PER_UINT64 - 1 - BitUtil::numLeadingUnsetBits(value);
}

inline
int BitStringImpUtil::find1AtMinIndexRaw(bsl::uint64_t value)
{
    BSLS_ASSERT_SAFE(0 != value);

    return BitUtil::numTrailingUnsetBits(value);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
