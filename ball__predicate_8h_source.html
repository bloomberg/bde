<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// ball_predicate.h                                                   -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALL_PREDICATE
#define INCLUDED_BALL_PREDICATE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a predicate object that consists of a name/value pair.
//
//@CLASSES:
//  ball::Predicate: a predicate in the form of an attribute name/value pair
//
//@SEE_ALSO: ball_predicateset, ball_rule
//
//@DESCRIPTION: This component implements a value-semantic predicate object,
// &#39;ball::Predicate&#39;, that consists of a name and a value.  The value can be an
// &#39;int&#39;, a 64-bit integer, or a &#39;bsl::string&#39;.  Both the name and value are
// managed by this object.
//
///Usage
///-----
// The following code illustrates how to create predicates:
//..
//    ball::Predicate p1(&quot;uuid&quot;, 4044457);
//    ball::Predicate p2(&quot;name&quot;, &quot;Gang Chen&quot;);
//..
// The names of the predicates can be found by calling the &#39;name&#39; method:
//..
//    assert(0 == bsl::strcmp(&quot;uuid&quot;, p1.name()));
//    assert(0 == bsl::strcmp(&quot;name&quot;, p2.name()));
//..
// The &#39;value&#39; method returns a non-modifiable reference to the
// &#39;bdlb::Variant&#39; object that manages the value of the predicate:
//..
//    assert(true        == p1.value().is&lt;int&gt;());
//    assert(4044457     == p1.value().the&lt;int&gt;());
//    assert(true        == p2.value().is&lt;bsl::string&gt;());
//    assert(&quot;Gang Chen&quot; == p2.value().the&lt;bsl::string&gt;());
//..
// Note that the name string that is passed to the constructor of
// &#39;ball::Predicate&#39; can be safely modified or even destroyed after the
// &#39;ball::Predicate&#39; object is created.  In the next example, we create a
// temporary buffer to store the name string, and then use the buffer to
// create a predicate.  Once the predicate is created, the content of the
// buffer can be altered without affecting the name of the predicate:
//..
//    char buffer[] = &quot;Hello&quot;;
//    ball::Predicate p3(buffer, 1);
//    bsl::strcpy(buffer, &quot;World&quot;);
//    assert(0 == bsl::strcmp(&quot;Hello&quot;, p3.name()));
//..
// The &#39;ball::Attribute&#39; class also provides a constructor that takes a value
// of type &#39;ball::Attribute::Value&#39;:
//..
//    ball::Attribute::Value value;
//    value.assign&lt;int&gt;(4044457);
//
//    ball::Predicate p4(&quot;uuid&quot;, value);
//    assert(p4 == p1);
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALL_ATTRIBUTE
#include &lt;ball_attribute.h&gt;
#endif

#ifndef INCLUDED_BDLB_VARIANT
#include &lt;bdlb_variant.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

namespace BloombergLP {

namespace ball {
                         // ===============
                         // class Predicate
                         // ===============

class Predicate {
    // This class contains an attribute name and an attribute value, both of
    // which are managed.  A &#39;Predicate&#39; object contains a &#39;Attribute&#39;
    // subobject, so that an equivalent &#39;Attribute&#39; object can be obtained
    // without any overhead when needed.  Since the &#39;Attribute&#39; subobject does
    // not manage the attribute name, &#39;Predicate&#39; stores the attribute name in
    // another member variable.

    // DATA
    bsl::string d_nameStr;    // the attribute name

    Attribute   d_attribute;  // the &#39;Attribute&#39; subobject, whose attribute
                              // name points to &#39;d_nameStr&#39;

    // FRIENDS
    friend bool operator==(const Predicate&amp;, const Predicate&amp;);
    friend bool operator!=(const Predicate&amp;, const Predicate&amp;);
    friend bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;, const Predicate&amp;);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Predicate, bslma::UsesBslmaAllocator);

    // CLASS METHODS
    static int hash(const Predicate&amp; predicate, int size);
        // Return a hash value calculated from the specified &#39;predicate&#39; using
        // the specified &#39;size&#39; as the number of slots.  The hash value is
        // guaranteed to be in the range [0 .. size - 1].

    // CREATORS
    Predicate(const bslstl::StringRef&amp;  name,
              int                       value,
              bslma::Allocator         *basicAllocator = 0 );
        // Create a &#39;Predicate&#39; object having the specified &#39;name&#39; and 32-bit
        // integer &#39;value&#39;.  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    Predicate(const bslstl::StringRef&amp;  name,
              bsls::Types::Int64        value,
              bslma::Allocator         *basicAllocator = 0 );
        // Create a &#39;Predicate&#39; object having the specified &#39;name&#39; and 64-bit
        // integer &#39;value&#39;.  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    Predicate(const bslstl::StringRef&amp;  name,
              const char               *value,
              bslma::Allocator         *basicAllocator = 0 );
        // Create a &#39;Predicate&#39; object having the specified &#39;name&#39; and
        // character string &#39;value&#39;.  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.

    Predicate(const bslstl::StringRef&amp;  name,
              const Attribute::Value&amp;   value,
              bslma::Allocator         *basicAllocator = 0 );
        // Create a &#39;Attribute&#39; object having the specified (literal) &#39;name&#39;
        // and &#39;value&#39;.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    Predicate(const Predicate&amp;  original,
              bslma::Allocator *basicAllocator = 0);
        // Create a &#39;Predicate&#39; object having the same name and attribute
        // value as the specified &#39;original&#39; object.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    // MANIPULATORS
    Predicate&amp; operator=(const Predicate&amp; rhs);
        // Assign the value of the specified &#39;rhs&#39; object to this object.

    void setName(const bslstl::StringRef&amp; name);
        // Set the attribute name of this object to the specified (literal)
        // &#39;name&#39;.

    void setValue(const Attribute::Value&amp; value);
        // Set the attribute value of this object to the specified &#39;value&#39;.

    // ACCESSORS
    const char *name() const;
        // Return the name of this object.

    const Attribute::Value&amp; value() const;
        // Return a reference to the non-modifiable attribute value of this
        // object.

    const Attribute&amp; attribute() const;
        // Return a reference to the non-modifiable attribute managed by this
        // object.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // (absolute value of) the optionally specified indentation &#39;level&#39;
        // and return a reference to &#39;stream&#39;.  If &#39;level&#39; is specified,
        // optionally specify &#39;spacesPerLevel&#39;, the number of spaces per
        // indentation level for this and all of its nested objects.  If
        // &#39;level&#39; is negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // &#39;level&#39;).  If &#39;stream&#39; is not valid on entry, this operation has no
        // effect.

};

// FREE OPERATORS
bool operator==(const Predicate&amp; lhs, const Predicate&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Predicate&#39; objects have the same
    // value if they have the same name (but not necessarily the identical
    // representation in memory), the same attribute value type, and the same
    // attribute value.

bool operator!=(const Predicate&amp; lhs, const Predicate&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;Predicate&#39; objects do not have
    // the same value if any of their respective names (value, not address),
    // attribute value types, or attribute values differ.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;    stream,
                         const Predicate&amp; predicate);
    // Write the value of the specified &#39;predicate&#39; to the specified output
    // &#39;stream&#39;, and return a reference to the modifiable &#39;stream&#39;.

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                         // ---------------
                         // class Predicate
                         // ---------------

//CLASS METHODS
inline
int Predicate::hash(const Predicate&amp; predicate, int size)
{
    return Attribute::hash(predicate.d_attribute, size);
}

// CREATORS
inline
Predicate::Predicate(const bslstl::StringRef&amp;  name,
                     int                       value,
                     bslma::Allocator         *basicAllocator)
: d_nameStr(name.data(), name.length(), basicAllocator)
, d_attribute(d_nameStr.c_str(), value, basicAllocator)
{
}

inline
Predicate::Predicate(const bslstl::StringRef&amp;  name,
                     bsls::Types::Int64        value,
                     bslma::Allocator         *basicAllocator)
: d_nameStr(name.data(), name.length(), basicAllocator)
, d_attribute(d_nameStr.c_str(), value, basicAllocator)
{
}

inline
Predicate::Predicate(const bslstl::StringRef&amp;  name,
                     const char               *value,
                     bslma::Allocator         *basicAllocator)
: d_nameStr(name.data(), name.length(), basicAllocator)
, d_attribute(d_nameStr.c_str(), value, basicAllocator)
{
}

inline
Predicate::Predicate(const bslstl::StringRef&amp;  name,
                     const Attribute::Value&amp;   value,
                     bslma::Allocator         *basicAllocator)
: d_nameStr(name.data(), name.length(), basicAllocator)
, d_attribute(d_nameStr.c_str(), value, basicAllocator)
{
}

inline
Predicate::Predicate(const Predicate&amp;  original,
                     bslma::Allocator *basicAllocator)
: d_nameStr(original.d_nameStr, basicAllocator)
, d_attribute(d_nameStr.c_str(), original.d_attribute.value(), basicAllocator)
{
}

// MANIPULATORS
inline
Predicate&amp; Predicate::operator=(const Predicate&amp; rhs)
{
    d_nameStr   = rhs.d_nameStr;
    d_attribute = rhs.d_attribute;
    d_attribute.setName(d_nameStr.c_str());
    return *this;
}

inline
void Predicate::setName(const bslstl::StringRef&amp; name)
{
    d_nameStr.assign(name.data(), name.length());
    d_attribute.setName(d_nameStr.c_str());
}

inline
void Predicate::setValue(const Attribute::Value&amp; value)
{
    d_attribute.setValue(value);
}


// ACCESSORS
inline
const char *Predicate::name() const
{
    return d_attribute.name();
}

inline
const Attribute::Value&amp; Predicate::value() const
{
    return d_attribute.value();
}

inline
const Attribute&amp; Predicate::attribute() const
{
    return d_attribute;
}

}  // close package namespace

// FREE OPERATORS
inline
bool ball::operator==(const Predicate&amp; lhs, const Predicate&amp; rhs)
{
    return lhs.d_nameStr           == rhs.d_nameStr
        &amp;&amp; lhs.d_attribute.value() == rhs.d_attribute.value();
}

inline
bool ball::operator!=(const Predicate&amp; lhs, const Predicate&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; ball::operator&lt;&lt;(bsl::ostream&amp;    stream,
                               const Predicate&amp; predicate)
{
    return predicate.print(stream, 0, -1);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
