<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bdlma_managedallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_managedallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for memory allocators that support <code>release</code>.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Implementing the <code>bdlma::ManagedAllocator</code> Protocol</a> </li>
<li>
<a href="#3.1.2">Example 2: Using the <code>bdlma::ManagedAllocator</code> Protocol</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for memory allocators that support <code>release</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a> </td><td>protocol for allocators with <code>release</code> capability  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__bufferedsequentialallocator.html" title="Provide an efficient managed allocator using an external buffer.">Component bdlma_bufferedsequentialallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component extends the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol to allocators that support the ability to <code>release</code> all memory currently allocated through the protocol back to the memory supplier of the derived concrete allocator object. <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,-----------------------.
  ( <a class="code" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a> )
   `-----------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">               |        release</span>
<span class="stringliteral">               |</span>
<span class="stringliteral">               v</span>
<span class="stringliteral">       ,----------------.</span>
<span class="stringliteral">      ( bslma::Allocator )</span>
<span class="stringliteral">       `----------------&#39;</span>
                        allocate
                        deallocate
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_the_bdlma~3A~3Amanagedallocator_protocol"></a> <a class="anchor" id="usage.example_1~3A_implementing_the_bdlma~3A~3Amanagedallocator_protocol"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_the_bdlma~3A~3Amanagedallocator_protocol"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing the bdlma::ManagedAllocator Protocol: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> interface is especially useful for allocators that are based on an underlying pooling mechanism (e.g., <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code> or <code><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a></code>). In particular, such an allocator that implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> interface can release, via the <code>release</code> method, all outstanding (pooled) memory back to the underlying allocator making the memory available for subsequent reuse. Moreover, use of the <code>release</code> method can also often render superfluous the running of destructors on the objects making use of a managed allocator. In this first usage example, we define the <code>my_BufferAllocator</code> class, an allocator that implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> interface. <code>my_BufferAllocator</code> is a considerably pared down version of <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code>, and is intended for illustration purposes only. Please see the <code>bdlma_bufferedsequentialallocator</code> component for full documentation of <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code>, a managed allocator meant for production use. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the interface of the <code>my_BufferAllocator</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_bufferallocator.h</span>

  <span class="keyword">class </span>my_BufferAllocator : <span class="keyword">public</span> bdlma::ManagedAllocator {
      <span class="comment">// This &#39;class&#39; provides a concrete buffer allocator that implements</span>
      <span class="comment">// the &#39;bdlma::ManagedAllocator&#39; protocol.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> *d_buffer_p;    <span class="comment">// external buffer (held, not owned)</span>
      <span class="keywordtype">int</span>   d_bufferSize;  <span class="comment">// size (in bytes) of external buffer</span>
      <span class="keywordtype">int</span>   d_cursor;      <span class="comment">// offset to next available byte in buffer</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_BufferAllocator(<span class="keyword">const</span> my_BufferAllocator&amp;);
      my_BufferAllocator&amp; operator=(<span class="keyword">const</span> my_BufferAllocator&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_BufferAllocator(<span class="keywordtype">char</span> *buffer, size_type bufferSize);
          <span class="comment">// Create a buffer allocator for allocating maximally-aligned</span>
          <span class="comment">// memory blocks from the specified external &#39;buffer&#39; having the</span>
          <span class="comment">// specified &#39;bufferSize&#39; (in bytes).</span>

      ~my_BufferAllocator();
          <span class="comment">// Destroy this buffer allocator.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> *allocate(size_type size);
          <span class="comment">// Return the address of a maximally-aligned contiguous block of</span>
          <span class="comment">// memory of the specified &#39;size&#39; (in bytes) on success, and 0 if</span>
          <span class="comment">// the allocation request exceeds the remaining free memory space</span>
          <span class="comment">// in the external buffer.</span>

      <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
          <span class="comment">// This method has no effect for this buffer allocator.</span>

      <span class="keywordtype">void</span> release();
          <span class="comment">// Release all memory allocated through this object.  This</span>
          <span class="comment">// allocator is reset to the state it was in immediately following</span>
          <span class="comment">// construction.</span>
  };
</pre></div><br/>
<br/>
 Next, we define the <code>inline</code> methods of <code>my_BufferAllocator</code>. Note that the <code>release</code> method resets the internal cursor to 0, effectively making the memory from the entire external buffer supplied at construction available for subsequent allocations, but has no effect on the contents of the buffer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_BufferAllocator::my_BufferAllocator(<span class="keywordtype">char</span> *buffer, size_type bufferSize)
  : d_buffer_p(buffer)
  , d_bufferSize(static_cast&lt;int&gt;(bufferSize))
  , d_cursor(0)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_BufferAllocator::deallocate(<span class="keywordtype">void</span> *)
  {
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_BufferAllocator::release()
  {
      d_cursor = 0;
  }
</pre></div><br/>
<br/>
 Finally, we provide the implementation of the <code>my_BufferAllocator</code> methods that are defined in the <code>.cpp</code> file. A <code>static</code> helper function, <code>allocateFromBufferImp</code>, provides the bulk of the implementation of the <code>allocate</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_bufferallocator.cpp</span>
<span class="preprocessor">  #include &lt;my_bufferallocator.h&gt;</span>

  <span class="comment">// STATIC HELPER FUNCTIONS</span>
  <span class="keyword">static</span>
  <span class="keywordtype">void</span> *allocateFromBufferImp(<span class="keywordtype">int</span>  *cursor,
                              <span class="keywordtype">char</span> *buffer,
                              <span class="keywordtype">int</span>   bufferSize,
                              <span class="keywordtype">int</span>   size)
      <span class="comment">// Allocate a maximally-aligned memory block of the specified &#39;size&#39;</span>
      <span class="comment">// (in bytes) from the specified &#39;buffer&#39; having the specified</span>
      <span class="comment">// &#39;bufferSize&#39; (in bytes) at the specified &#39;cursor&#39; position.  Return</span>
      <span class="comment">// the address of the allocated memory block if &#39;buffer&#39; contains</span>
      <span class="comment">// sufficient available memory, and 0 otherwise.  The &#39;cursor&#39; is set</span>
      <span class="comment">// to the first byte position immediately after the allocated memory if</span>
      <span class="comment">// there is sufficient memory, and not modified otherwise.  The</span>
      <span class="comment">// behavior is undefined unless &#39;0 &lt;= bufferSize&#39;, &#39;0 &lt; size&#39;,</span>
      <span class="comment">// &#39;0 &lt;= *cursor&#39;, and &#39;*cursor &lt;= bufferSize&#39;.</span>

  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> offset = <a class="code" href="structbsls_1_1AlignmentUtil.html#a59020e97aa03ceafb15389eac50e01eb">bsls::AlignmentUtil::calculateAlignmentOffset</a>(
                                    buffer + *cursor,
                                    <a class="code" href="structbsls_1_1AlignmentUtil.html#aab13e853fd9dea2815d49d227ff9c502a74bef72781f251014a813e406edabedb">bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT</a>);

      <span class="keywordflow">if</span> (*cursor + offset + size &gt; bufferSize) {  <span class="comment">// insufficient space</span>
          <span class="keywordflow">return</span> 0;
      }

      <span class="keywordtype">void</span> *result = &amp;buffer[*cursor + offset];
      *cursor += offset + size;

      <span class="keywordflow">return</span> result;
  }

  <span class="comment">// CREATORS</span>
  my_BufferAllocator::~my_BufferAllocator()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> *my_BufferAllocator::allocate(size_type size)
  {
      <span class="keywordflow">return</span> 0 == size ? 0 : allocateFromBufferImp(&amp;d_cursor,
                                                   d_buffer_p,
                                                   d_bufferSize,
                                                   static_cast&lt;int&gt;(size));
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_the_bdlma~3A~3Amanagedallocator_protocol"></a> <a class="anchor" id="usage.example_2~3A_using_the_bdlma~3A~3Amanagedallocator_protocol"></a> <a class="anchor" id="description.usage.example_2~3A_using_the_bdlma~3A~3Amanagedallocator_protocol"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using the bdlma::ManagedAllocator Protocol: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this second usage example, we illustrate how the managed allocator that was defined in Example 1, <code>my_BufferAllocator</code>, may be used. Note that substantial portions of the sample implementation are elided as they would only add unnecessary complications to the usage example. The portions shown are sufficient to illustrate the use of <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The domain of our example is financial markets. Suppose that we are given a list of market indices (e.g., Dow Jones Industrial Average, S&amp;P 500, etc.), and we want to perform some computation on each index, in turn. In this example, the essential attributes of an index are held in a <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> consisting of the name of the index (e.g., "DJIA") and the number of securities that comprise the index (e.g., 30 in the case of the DJIA). The collection of market indices that we wish to process is given by a vector of such pairs. Thus, we make use of these types related to indices: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;const char *, int&gt;</a> IndexAttributes;
  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;IndexAttributes&gt;</a> IndexCollection;
</pre></div><br/>
<br/>
 In our example, a security is defined by the unconstrained attribute type <code>my_SecurityAttributes</code>, the interface and implementation of which is elided except we note that it uses <code>bslma</code> allocators: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_SecurityAttributes {
      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(my_SecurityAttributes,
                                     <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 For the collection of securities comprising an index we use a vector of <code>my_SecurityAttributes</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;my_SecurityAttributes&gt;</a> SecurityCollection;
</pre></div><br/>
<br/>
 Since some indices are quite large (e.g., Russell 3000, Wilshire 5000), for performance reasons it is advantageous for a <code>SecurityCollection</code> to use an efficient memory allocation strategy. This is where <code>my_BufferAllocator</code> comes into play, which we will see shortly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The top-level function in our example takes a <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a> *</code> and the collection of market indices that we wish to process: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span>
  <span class="keywordtype">void</span> processIndices(<a class="code" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a> *managedAllocator,
                      <span class="keyword">const</span> IndexCollection&amp;   indices);
      <span class="comment">// Process the specified market &#39;indices&#39; using the specified</span>
      <span class="comment">// &#39;managedAllocator&#39; to supply memory.</span>
</pre></div><br/>
<br/>
 <code>processIndices</code> makes use of two helper functions to process each index: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span>
  <span class="keywordtype">void</span> loadIndex(SecurityCollection      *securities,
                 <a class="code" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a> *managedAllocator,
                 <span class="keyword">const</span> IndexAttributes&amp;   index);
      <span class="comment">// Load into the specified collection of &#39;securities&#39; the attributes of</span>
      <span class="comment">// the securities comprising the specified market &#39;index&#39; using the</span>
      <span class="comment">// specified &#39;managedAllocator&#39; to supply memory.</span>

  <span class="keyword">static</span>
  <span class="keywordtype">void</span> processIndex(<span class="keyword">const</span> SecurityCollection&amp; securities,
                    <span class="keyword">const</span> IndexAttributes&amp;    index);
      <span class="comment">// Process the specified collection of &#39;securities&#39; that comprise the</span>
      <span class="comment">// specified market &#39;index&#39;.</span>
</pre></div><br/>
<br/>
 Since we plan to use <code>my_BufferAllocator</code> as our managed allocator, we need to supply it with an external buffer. The <code>calculateMaxBufferSize</code> function computes the size of the buffer required to store the <code>SecurityCollection</code> corresponding to the largest index to be processed by a given call to <code>processIndices</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> calculateMaxBufferSize(<span class="keyword">const</span> IndexCollection&amp; indices);
      <span class="comment">// Return the maximum buffer size (in bytes) required to process the</span>
      <span class="comment">// specified collection of market &#39;indices&#39;.</span>
</pre></div><br/>
<br/>
 Before showing the implementation of <code>processIndices</code>, where the most interesting use of our managed allocator takes place, we show the site of the call to <code>processIndices</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, assume that we have been given an <code>IndexCollection</code> that has been populated with one or more <code>IndexAttributes</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  IndexCollection indices;  <span class="comment">// assume populated</span>
</pre></div><br/>
<br/>
 Next, we calculate the size of the buffer that is needed, allocate the memory for the buffer from the default allocator, create our concrete managed allocator (namely, an instance of <code>my_BufferAllocator</code>), and call <code>processIndices</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">int</span> bufferSize = calculateMaxBufferSize(indices);

  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = <a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>();
  <span class="keywordtype">char</span> *buffer = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(allocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>(bufferSize));

  my_BufferAllocator bufferAllocator(buffer, bufferSize);

  processIndices(&amp;bufferAllocator, indices);
</pre></div><br/>
<br/>
 Next, we show the implementation of <code>processIndices</code>, within which we iterate over the market <code>indices</code> that are passed to it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span>
  <span class="keywordtype">void</span> processIndices(<a class="code" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a> *managedAllocator,
                      <span class="keyword">const</span> IndexCollection&amp;   indices)
      <span class="comment">// Process the specified market &#39;indices&#39; using the specified</span>
      <span class="comment">// &#39;managedAllocator&#39; to supply memory.</span>
  {
      <span class="keywordflow">for</span> (IndexCollection::const_iterator citer = indices.begin();
                                           citer != indices.end(); ++citer) {
</pre></div><br/>
<br/>
 For each index, the <code>SecurityCollection</code> comprising that index is created. All of the memory needs of the <code>SecurityCollection</code> are provided by the <code>managedAllocator</code>. Note that even the memory for the footprint of the collection comes from the <code>managedAllocator</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">          SecurityCollection *securities =
              <span class="keyword">new</span> (managedAllocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>(<span class="keyword">sizeof</span>(SecurityCollection)))
                                        SecurityCollection(managedAllocator);
</pre></div><br/>
<br/>
 Next, we call <code>loadIndex</code> to populate <code>securities</code>, followed by the call to <code>processIndex</code>. <code>loadIndex</code> also uses the <code>managedAllocator</code>, the details of which are not shown here: <br/>
<br/>
<div class="fragment"><pre class="fragment">          loadIndex(securities, managedAllocator, *citer);

          processIndex(*securities, *citer);
</pre></div><br/>
<br/>
 After the index is processed, <code>release</code> is called on the managed allocator making all of the buffer supplied to the allocator at construction available for reuse: <br/>
<br/>
<div class="fragment"><pre class="fragment">          managedAllocator-&gt;<a class="code" href="classbdlma_1_1ManagedAllocator.html#ad86110a47aaf5e53356c86b5fd240bfb">release</a>();
      }
</pre></div><br/>
<br/>
 Finally, we let the <code>SecurityCollection</code> used to process the index go out of scope intentionally without deleting <code>securities</code>. The call to <code>release</code> renders superfluous the need to call the <code>SecurityCollection</code> destructor as well as the destructor of the contained <code>my_SecurityAttributes</code> elements. <br/>
<br/>
<div class="fragment"><pre class="fragment">  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:19 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
