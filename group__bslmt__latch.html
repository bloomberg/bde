<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmt_latch Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmt_latch<br/>
<small>
[<a class="el" href="group__bslmt.html">Package bslmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a single-use mechanism for synchronizing on an event count.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Comparison to <code>bslmt::Barrier</code></a> </li>
<li>
<a href="#3.2">Comparison to <code>bslmt::Semaphore</code></a> </li>
<li>
<a href="#3.3">Undefined Behavior When Decrementing the Event Count</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Implementing a Parallelizable Algorithm</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a single-use mechanism for synchronizing on an event count. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslmt_1_1Latch.html">bslmt::Latch</a> </td><td>single-use synchronization mechanism on a count of events  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmt__barrier.html" title="Provide a thread barrier component.">Component bslmt_barrier</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a mechanism, <code><a class="el" href="classbslmt_1_1Latch.html">bslmt::Latch</a></code>, that allows one or more threads to wait until a certain number of operations have been performed by other threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A latch maintains a <code>currentCount</code> of operations that must be performed before threads waiting on the latch are released. The initial operation count for the latch is supplied at construction, and is decremented by calls to either <code>arrive</code>, <code>arriveAndWait</code>, or <code>countDown</code>. Threads may wait on a latch to be released by calling either <code>wait</code> or <code>arriveAndWait</code>, and threads calling those methods will block until the <code>currentCount</code> is 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>WARNING</em>: <code><a class="el" href="classbslmt_1_1Latch.html">bslmt::Latch</a></code> is <em>not</em> a reusable synchronization mechanism. The behavior is undefined when calling <code>countDown</code>, <code>arrive</code>, and <code>arriveAndWait</code> after the <code>currentCount</code> becomes 0 (the latch has been released). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="comparison_to_bslmt~3A~3Abarrier"></a> <a class="anchor" id="description.comparison_to_bslmt~3A~3Abarrier"></a> <a class="anchor" id="comparison_to_bslmt"></a> <a class="anchor" id="description.comparison_to_bslmt"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Comparison to bslmt::Barrier: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A latch provides a basic synchronization tool, similar to a barrier. A latch is distinct from a barrier in that: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
A latch is single-use only, whereas a barrier can be used multiple times.  </li>
<li>
Threads waiting on a barrier are blocked, whereas threads that <code>arrive</code> at a latch are not blocked (only waiting threads are blocked).  </li>
<li>
<code>wait</code> on a barrier always decrements the count of waiting threads by 1, whereas <code>countDown</code> on a latch can indicate multiple events.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>An example use of a barrier is to coordinate a set of threads working in lock-step to complete a multi-step operation. An example use of a latch is for one thread to coordinate the completion of a multi-step operation being performed by a set of "child" threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="comparison_to_bslmt~3A~3Asemaphore"></a> <a class="anchor" id="description.comparison_to_bslmt~3A~3Asemaphore"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Comparison to bslmt::Semaphore: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A latch is conceptually similar to a semaphore with a negative count. However, typically semaphore implementations (including <code><a class="el" href="classbslmt_1_1Semaphore.html">bslmt::Semaphore</a></code> and POSIX) do not allow for negative counts. Waiting on a latch configured for <code>N</code> events is cleaner than one thread calling <code>wait</code> on a semaphore <code>N</code> times in a loop. Furthermore, if the use case involves multiple threads waiting on a set of events, using a latch is cleaner than each thread waiting on a semaphore and then immediately calling <code>post</code> (to release the next waiting thread). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="undefined_behavior_when_decrementing_the_event_count"></a> <a class="anchor" id="description.undefined_behavior_when_decrementing_the_event_count"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Undefined Behavior When Decrementing the Event Count: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The methods <code>arrive</code>, <code>arriveAndWait</code>, and <code>countDown</code> all document that it is undefined behavior to decrement the event count below 0. Note that it isn't possible to use a latch's visible state to determine whether it is safe (i.e., not undefined behavior) to call <code>arrive</code>, <code>arriveAndWait</code>, or <code>countDown</code>. A limit on the number of times the event count is decremented must be imposed by the logic of the program. For example, in the usage example below a latch is created with an event count that matches the number of threads that will call <code>arrive</code> on that latch. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_parallelizable_algorithm"></a> <a class="anchor" id="usage.example_1~3A_implementing_a_parallelizable_algorithm"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_a_parallelizable_algorithm"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Parallelizable Algorithm: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following example we use a <code><a class="el" href="classbslmt_1_1Latch.html">bslmt::Latch</a></code> object to help implement an operation that can be parallelized across a series of sub-tasks (or "jobs"). The "parent" operation enqueue's the jobs and blocks on a thread pool, and uses the latch as a signaling mechanism to indicate when all of the jobs have been completed and return to the caller. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The use of a <code><a class="el" href="classbslmt_1_1Latch.html">bslmt::Latch</a></code>, rather than a <code><a class="el" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a></code>, is important to ensure that jobs in the thread pool do not block until the entire task is completed (preventing the thread pool from processing additional work). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose, for example, we want to provide a C++ type for computing a vector sum (vector in the mathematical sense). That is, for two input vectors, <code>A</code> and <code>B</code>, each of length <code>N</code>, the result is a vector, <code>R</code>, of length <code>N</code>, where each element at index <code>i</code> has the value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  R[i] = <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a>[i] + B[i];
</pre></div><br/>
<br/>
 This function can easily be computed in parallel because the value for each result index only depends on the input vectors. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, assume we have a class, <code>FixedThreadPool</code>, providing the following public interface (for brevity, the details have been elided; see <code>bdlmt_fixedthreadpool</code> or <code>bdlmt_threadpool</code> for examples of thread pools): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>FixedThreadPool {

    <span class="keyword">public</span>:
      <span class="comment">// ...</span>

      <span class="keywordtype">void</span> enqueueJob(<span class="keyword">const</span> bsl::function&lt;<span class="keywordtype">void</span>()&gt;&amp; job);
          <span class="comment">// Enqueue the specified &#39;job&#39; to be executed by the next available</span>
          <span class="comment">// thread.</span>
  };
</pre></div><br/>
<br/>
 Next, we declare the signature for our vector sum function, <code>parallelVectorSum</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> parallelVectorSum(<span class="keywordtype">double</span>          *result,
                         <span class="keyword">const</span> <span class="keywordtype">double</span>    *inputA,
                         <span class="keyword">const</span> <span class="keywordtype">double</span>    *inputB,
                         <span class="keywordtype">int</span>              numElements,
                         FixedThreadPool *threadPool,
                         <span class="keywordtype">int</span>              numJobs);
      <span class="comment">// Load the specified &#39;result&#39; array with the vector sum of the</span>
      <span class="comment">// specified &#39;inputA&#39; and &#39;inputB&#39;, each having at least the specified</span>
      <span class="comment">// &#39;numElements&#39;, using the specified &#39;threadPool&#39; to perform the</span>
      <span class="comment">// operation in parallel using the specified &#39;numJobs&#39; parallel jobs.</span>
      <span class="comment">// The behavior is undefined unless &#39;numElements &gt; 0&#39;, &#39;numJobs &gt; 0&#39;,</span>
      <span class="comment">// and &#39;result&#39;, &#39;inputA&#39;, and &#39;inputB&#39; each contain at least</span>
      <span class="comment">// &#39;numElements&#39;.</span>
</pre></div><br/>
<br/>
 Now, we declare a helper function, <code>vectorSumJob</code>, that will be used as a sub-task by <code>parallelVectorSum</code>. <code>vectorSumJob</code> computes a single-threaded vector sum and uses a <code><a class="el" href="classbslmt_1_1Latch.html">bslmt::Latch</a></code> object, <code>completionSignal</code>, to indicate to the parent task that the computation has been completed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> vectorSumJob(<span class="keywordtype">double</span>       *result,
                    <a class="code" href="classbslmt_1_1Latch.html">bslmt::Latch</a> *completionSignal,
                    <span class="keyword">const</span> <span class="keywordtype">double</span> *inputA,
                    <span class="keyword">const</span> <span class="keywordtype">double</span> *inputB,
                    <span class="keywordtype">int</span>           numElements)
      <span class="comment">// Load the specified &#39;result&#39; array with the vector sum of the</span>
      <span class="comment">// specified &#39;inputA&#39; and &#39;inputB&#39;, each having at least the specified</span>
      <span class="comment">// &#39;numElements&#39;, and when the operation is complete signal the</span>
      <span class="comment">// specified &#39;completionSignal&#39;.  The behavior is undefined unless</span>
      <span class="comment">// &#39;numElements &gt; 0&#39; and &#39;result&#39;, &#39;inputA&#39;, and &#39;inputB&#39; each contain</span>
      <span class="comment">// at least &#39;numElements&#39;.</span>
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numElements; ++i) {
          result[i] = inputA[i] + inputB[i];
      }

      completionSignal-&gt;<a class="code" href="classbslmt_1_1Latch.html#a88c453131df507676b888413cf9090dd">arrive</a>();
  }
</pre></div><br/>
<br/>
 Note that <code><a class="el" href="classbslmt_1_1Latch.html#a88c453131df507676b888413cf9090dd">bslmt::Latch::arrive</a></code> does not block the current thread (unlike <code><a class="el" href="classbslmt_1_1Barrier.html#a7df005643d9abf4691dc6deef4ca68bc">bslmt::Barrier::wait</a></code>), and within the context of a thread pool, this job will complete and the thread will be returned to the pool to accept more work. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we provide a rudimentary function argument binder (specific to this usage example) in view of the fact that such a facility is not available at this level in the BDE hierarchy: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>UsageBinder {
      <span class="comment">// This class provides an invokable that is tailored to bind the</span>
      <span class="comment">// &#39;vectorSumJob&#39; (defined above) to its requisite five arguments.</span>

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <span class="keywordtype">void</span> FREE_FUNCTION(<span class="keywordtype">double</span>       *,
                                 <a class="code" href="classbslmt_1_1Latch.html">bslmt::Latch</a> *,
                                 <span class="keyword">const</span> <span class="keywordtype">double</span> *,
                                 <span class="keyword">const</span> <span class="keywordtype">double</span> *,
                                 <span class="keywordtype">int</span>           );

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      FREE_FUNCTION *d_func_p;
      <span class="keywordtype">double</span>        *d_arg1_p;
      <a class="code" href="classbslmt_1_1Latch.html">bslmt::Latch</a>  *d_arg2_p;
      <span class="keyword">const</span> <span class="keywordtype">double</span>  *d_arg3_p;
      <span class="keyword">const</span> <span class="keywordtype">double</span>  *d_arg4_p;
      <span class="keywordtype">int</span>            d_arg5;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      UsageBinder(FREE_FUNCTION *functionPtr,
                  <span class="keywordtype">double</span>        *arg1Ptr,
                  <a class="code" href="classbslmt_1_1Latch.html">bslmt::Latch</a>  *arg2Ptr,
                  <span class="keyword">const</span> <span class="keywordtype">double</span>  *arg3Ptr,
                  <span class="keyword">const</span> <span class="keywordtype">double</span>  *arg4Ptr,
                  <span class="keywordtype">int</span>            arg5)
          <span class="comment">// Create a &#39;UsageBinder&#39; object that binds the specified</span>
          <span class="comment">// &#39;functionPtr&#39; to the specified &#39;arg1Ptr&#39;, &#39;arg2Ptr&#39;, &#39;arg3Ptr&#39;,</span>
          <span class="comment">// &#39;arg4Ptr&#39;, and &#39;arg5&#39; arguments.</span>
      : d_func_p(functionPtr)
      , d_arg1_p(arg1Ptr)
      , d_arg2_p(arg2Ptr)
      , d_arg3_p(arg3Ptr)
      , d_arg4_p(arg4Ptr)
      , d_arg5(arg5)
      {
      }

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> operator()()
          <span class="comment">// Invoke the function that was supplied at construction on the</span>
          <span class="comment">// arguments that were supplied at construction.</span>
      {
          (*d_func_p)(d_arg1_p, d_arg2_p, d_arg3_p, d_arg4_p, d_arg5);
      }
  };
</pre></div><br/>
<br/>
 Then, we define <code>parallelVectorSum</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> parallelVectorSum(<span class="keywordtype">double</span>          *result,
                         <span class="keyword">const</span> <span class="keywordtype">double</span>    *inputA,
                         <span class="keyword">const</span> <span class="keywordtype">double</span>    *inputB,
                         <span class="keywordtype">int</span>              numElements,
                         FixedThreadPool *threadPool,
                         <span class="keywordtype">int</span>              numJobs)
  {
      <span class="comment">// Ensure that there is at least 1 element per job.</span>

      <span class="keywordflow">if</span> (numElements &lt; numJobs) {
          numJobs = numElements;
      }

      <span class="keyword">const</span> <span class="keywordtype">int</span> jobSize = numElements / numJobs;
</pre></div><br/>
<br/>
 Now, we define a <code><a class="el" href="classbslmt_1_1Latch.html">bslmt::Latch</a></code> object, <code>completionSignal</code>, that we will use to track the completion of this work: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslmt_1_1Latch.html">bslmt::Latch</a> completionSignal(numJobs);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numJobs; ++i) {
          <span class="comment">// If &#39;numJobs&#39; doesn&#39;t evenly divide &#39;numElements&#39;, the last job</span>
          <span class="comment">// will process the remaining elements.  For simplicity, we have</span>
          <span class="comment">// chosen not distribute the elements between jobs as evenly as is</span>
          <span class="comment">// possible.</span>

          <span class="keywordtype">int</span> offset = i * jobSize;
          <span class="keywordtype">int</span> <a class="code" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size</a>   = (i == numJobs - 1) ? jobSize + numElements % numJobs
                                          : jobSize;
          assert(0 != size);

          threadPool-&gt;enqueueJob(UsageBinder(vectorSumJob,
                                             result + offset,
                                             &amp;completionSignal,
                                             inputA + offset,
                                             inputB + offset,
                                             size));
      }
</pre></div><br/>
<br/>
 Finally, calling <code>wait</code> on the latch will block this function from returning until all the queued jobs computing the vector sum have been completed: <br/>
<br/>
<div class="fragment"><pre class="fragment">      completionSignal.<a class="code" href="classbslmt_1_1Latch.html#ad7e8c31845429587e7ef7ca2fd3925be">wait</a>();
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:00 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
