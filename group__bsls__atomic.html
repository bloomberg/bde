<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_atomic Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_atomic<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide types with atomic operations.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Memory Order and Consistency Guarantees of Atomic Operations</a> <ul>
<li>
<a href="#3.1.1">Acquire and Release Memory Consistency Guarantees</a> </li>
<li>
<a href="#3.1.2">Sequential Consistency Memory Consistency Guarantee</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Usage Statistics on a Thread Pool</a> </li>
<li>
<a href="#3.2.2">Example 2: Thread-safe Counted Handle</a> <ul>
<li>
<a href="#3.2.2.1">Class <code>my_CountedHandleRep</code></a> </li>
<li>
<a href="#3.2.2.2">Class <code>my_CountedHandle</code></a> </li>
<li>
<a href="#3.2.2.3">Function Definitions for <code>my_CountedHandleRep</code></a> </li>
<li>
<a href="#3.2.2.4">Function Definitions for <code>my_CountedHandle</code></a> </li>
</ul>
</li>
<li>
<a href="#3.2.3">Example 3: Thread-Safe Lock-Free Singly-Linked List</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide types with atomic operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> </td><td>atomic 32-bit integer type  </td></tr>
<tr>
<td><a class="el" href="classbsls_1_1AtomicInt64.html">bsls::AtomicInt64</a> </td><td>atomic 64-bit integer types  </td></tr>
<tr>
<td><a class="el" href="classbsls_1_1AtomicPointer.html">bsls::AtomicPointer</a> </td><td>parameterized atomic pointer type  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bsls__atomicoperations.html" title="Provide platform-independent atomic operations.">Component bsls_atomicoperations</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides classes with atomic operations for <code>int</code>, <code>Int64</code>, and pointer types. These classes are based on atomic operations supplied by the <code>bsls_atomicoperations</code> component. The <code><a class="el" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a></code> and <code><a class="el" href="classbsls_1_1AtomicInt64.html">bsls::AtomicInt64</a></code> classes represent the corresponding atomic integer types, and provide overloaded operators and functions for common arithmetic operations. The <code><a class="el" href="classbsls_1_1AtomicPointer.html">bsls::AtomicPointer</a></code> class represents the atomic pointer type, and provides atomic operations to manipulate and dereference a pointer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_order_and_consistency_guarantees_of_atomic_operations"></a> <a class="anchor" id="description.memory_order_and_consistency_guarantees_of_atomic_operations"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Memory Order and Consistency Guarantees of Atomic Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Atomic operations provided by this component ensure various memory ordering consistency guarantees. Memory ordering guarantees of atomic operations are designed to ensure visibility and synchronization order of memory reads and writes between threads that perform atomic operations. The operations on objects of the provided classes ensure the most strict consistency guarantee, sequential consistency (described below), unless explicitly qualified with a less strict consistency guarantee (i.e., Acquire, Release, Acquire/Release or Relaxed). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements memory order and consistency guarantees as defined in the C++ 2011 Standard (sections: [intro.multithreaded], [atomics.order]). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following memory ordering guarantees are supported: <ul>
<li>
relaxed - the operation does not provide any memory consistency guarantee  </li>
<li>
release - the operation performs a release operation on the affected memory location, thus making preceding regular memory writes of the calling thread visible to other threads through the atomic variable to which it is applied (generally available for operations that write to a memory location).  </li>
<li>
acquire - the operation performs an acquire operation on the affected memory location, thus making regular memory writes in other threads released through the atomic variable to which it is applied visible to the current thread (generally available for operations that read from a memory location).  </li>
<li>
acquire/release - the operation has both acquire and release semantics (generally available for operations that both read and write a memory location).  </li>
<li>
sequential consistency - the operation has both acquire and release guarantees, and further guarantees that all sequentially consistent operations performed by the process will be observed to occur in a single global total order (regardless of the thread from which they are observed).  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="acquire_and_release_memory_consistency_guarantees"></a> <a class="anchor" id="memory_order_and_consistency_guarantees_of_atomic_operations.acquire_and_release_memory_consistency_guarantees"></a> <a class="anchor" id="description.memory_order_and_consistency_guarantees_of_atomic_operations.acquire_and_release_memory_consistency_guarantees"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Acquire and Release Memory Consistency Guarantees: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Operations providing acquire and release guarantees are essential to synchronizing the memory state between multiple threads. For example, consider two threads, A and B, that perform store and load operations to shared memory locations. Without any synchronization, store operations in thread A can be freely reordered with load operations in thread B, i.e, thread A can perform two store operations to two memory locations in a certain order and thread B can see those operations done in a different order due to such effects as: compiler or processor optimizations of store and load operations, and cache synchronization between processors and cores. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>However, stores in thread A can be ordered with loads in thread B using a combination of store-release and load-acquire operations. A store-release operations in thread A followed by a load-acquire operation in thread B to <em>the</em> <em>same</em> <em>memory</em> <em>location</em> guarantees that thread B sees all other stores done in thread A prior to the store-release operation. The store-release in thread A effectively synchronizes the memory state with the load-acquire in thread A. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An acquire-release operation is a load-modify-store operation that, if performed in both threads A and B on the same memory location, synchronizes stores and loads between threads A and B in both directions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="sequential_consistency_memory_consistency_guarantee"></a> <a class="anchor" id="memory_order_and_consistency_guarantees_of_atomic_operations.sequential_consistency_memory_consistency_guarantee"></a> <a class="anchor" id="description.memory_order_and_consistency_guarantees_of_atomic_operations.sequential_consistency_memory_consistency_guarantee"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Sequential Consistency Memory Consistency Guarantee: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, load and store operations with sequential consistency are guaranteed to performed in a global total order among all threads in the process. To illustrate the total order, let's consider the so-called "independent reads of independent writes" example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> x(0);
  <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> y(0);
  <span class="keywordtype">int</span> r1, r2, r3, r4;

  <span class="keywordtype">void</span> thread1() {
      x = 1;  <span class="comment">// sequential consistency store</span>
  }

  <span class="keywordtype">void</span> thread2() {
      y = 1;  <span class="comment">// sequential consistency store</span>
  }

  <span class="keywordtype">void</span> thread3() {
      r1 = x;  <span class="comment">// sequential consistency load</span>
      r2 = y;  <span class="comment">// sequential consistency load</span>
  }

  <span class="keywordtype">void</span> thread4() {
      r3 = y;  <span class="comment">// sequential consistency load</span>
      r4 = x;  <span class="comment">// sequential consistency load</span>
  }
</pre></div><br/>
<br/>
 Where <code>threadN</code> functions are executed concurrently by different threads (note that values <code>x</code> and <code>y</code> are written by independent threads). Sequential consistency guarantees that if <code>thread3</code> observes values <code>x</code> and <code>y</code> as <code>r1 == 1 &amp;&amp; r2 == 0</code>, then <code>thread4</code> can't observe values <code>x</code> and <code>y</code> in a different order, i.e., <code>r3 == 1 &amp;&amp; r4 == 0</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Usage Statistics on a Thread Pool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates a common use of atomic integer types for statistics counters. The program creates a series of threads to process transactions. As each thread completes a transaction, it atomically increments the transaction counters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For this example, we assume the existence of the functions <code>processNextTransaction</code>, <code>createWorkerThread</code>, and <code>waitAllThreads</code>. The function <code>createWorkerThread</code> spawns a new thread, which executes the <code>workerThread</code> function. <code>waitAllThreads</code> blocks until all the worker thread complete. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we declare the shared counters (note that, in contrast to the raw types defined in <code>bsls_atomicoperations</code>, these atomic types are zero-initialized at construction): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <a class="code" href="classbsls_1_1AtomicInt64.html">bsls::AtomicInt64</a> transactionCount;
  <span class="keyword">static</span> <a class="code" href="classbsls_1_1AtomicInt64.html">bsls::AtomicInt64</a> successCount;
  <span class="keyword">static</span> <a class="code" href="classbsls_1_1AtomicInt64.html">bsls::AtomicInt64</a> failureCount;
</pre></div><br/>
<br/>
 Next, for each transaction processed, we atomically increment either the success or the failure counter as well as the total transaction count: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> workerThread(<span class="keywordtype">int</span> *stop)
  {
      <span class="keywordflow">while</span> (!(*stop)) {
          <span class="keywordflow">if</span> (processNextTransaction()) {
              ++failureCount;
          } <span class="keywordflow">else</span> {
              ++successCount;
          }
          ++transactionCount;
      }
  }
</pre></div><br/>
<br/>
 Finally, we write function, <code>serverMain</code>, that provides the overall control logic for the server. This function spawns the threads and then waits for all work to be completed; when all of the threads have finished, this function returns normally: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> serverMain()
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> num_threads = 10;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_threads; ++i) {
          createWorkerThread();
      }
      waitAllThreads();
  }
</pre></div><br/>
<br/>
 Note that functions <code>createWorkerThread</code> and <code>waitAllThreads</code> can be implemented using any thread-support package. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Thread-safe Counted Handle: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates the use of atomic integer operations to implement a thread-safe ref-counted handle similar to a shared pointer. Each handle (of type <code>my_CountedHandle</code>) maintains a pointer to a representation object, <code>my_CountedHandleRep</code>, which in turn, stores both a pointer to the managed object and a reference counter. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Both the handle class and the representation class are template classes with two template parameters. The template parameter, <code>INSTANCE</code>, represents the type of the "instance", or managed object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A representation object can be shared by several handle objects. When a handle object is assigned to a second handle object, the address of the representation is copied to the second handle, and the reference count on the representation is atomically incremented. When a handle releases its reference to the representation, it atomically decrements the reference count. If the resulting reference count becomes 0 (and there are no more references to the object), the handle deletes the representation object and the representation object, in turn, deletes the managed object (<code>INSTANCE</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="class_my_countedhandlerep"></a> <a class="anchor" id="example_2.class_my_countedhandlerep"></a> <a class="anchor" id="usage.example_2.class_my_countedhandlerep"></a> <a class="anchor" id="description.usage.example_2.class_my_countedhandlerep"></a> <a class="anchor" id="3.2.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Class my_CountedHandleRep: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define class <code>my_CountedHandleRep</code>. This class manages a single <code>INSTANCE</code> object on behalf of multiple "handle" objects; since different "handle" objects may be active in different threads, class <code>my_CountedHandleRep</code> must be (fully) thread-safe. Specifically, methods <code>increment</code> and <code>decrement</code> must work atomically. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The class declaration for <code>my_CountedHandleRep</code> is identical to the same class in component <code>bsls_atomicoperations</code>, with a single exception: member <code>d_count</code> is of type <code><a class="el" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a></code>, rather than <code>bsls::AtomicOperations::Int</code>. Whereas <code>bsls::AtomicOperations::Int</code> is merely a <code>typedef</code> for a platform-specific data type to be used in atomic integer operations, <code><a class="el" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a></code> encapsulates those atomic operations as member functions and operator overloads. Class <code>my_CountedHandleRep</code> will benefit from this encapsulation: Its method implementations will be able to operate on <code>d_count</code> as if it were a standard integer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that, as in the example in component <code>bsls_atomicoperations</code>, this rep class is intended to be used only by class <code>my_CountedHandle</code>, and thus all methods of class <code>my_CountedHandleRep</code> are declared private, and <code>friend</code> status is granted to class <code>my_CountedHandle</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// =========================</span>
                          <span class="comment">// class my_CountedHandleRep</span>
                          <span class="comment">// =========================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">class </span>my_CountedHandle;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">class </span>my_CountedHandleRep {

      <span class="comment">// DATA</span>
      <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a>  d_count;        <span class="comment">// number of active references</span>
      INSTANCE        *d_instance_p;   <span class="comment">// address of managed instance</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keyword">class </span>my_CountedHandle&lt;INSTANCE&gt;;

      <span class="comment">// NOT IMPLEMENTED</span>
      my_CountedHandleRep(<span class="keyword">const</span> my_CountedHandleRep&amp;);
      my_CountedHandleRep&amp; operator=(<span class="keyword">const</span> my_CountedHandleRep&amp;);

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      deleteObject(my_CountedHandleRep&lt;INSTANCE&gt; *<span class="keywordtype">object</span>);

      <span class="comment">// PRIVATE CREATORS</span>
      my_CountedHandleRep(INSTANCE *instance);
      ~my_CountedHandleRep();

      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> increment();
      <span class="keywordtype">int</span> decrement();
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="class_my_countedhandle"></a> <a class="anchor" id="example_2.class_my_countedhandle"></a> <a class="anchor" id="usage.example_2.class_my_countedhandle"></a> <a class="anchor" id="description.usage.example_2.class_my_countedhandle"></a> <a class="anchor" id="3.2.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Class my_CountedHandle: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we create class <code>my_CountedHandle</code> that provides an individual handle to the shared, reference-counted object. Each <code>my_CountedHandle</code> object acts as a smart pointer, supplying an overloaded <code>operator-&gt;</code> that provides access to the underlying <code>INSTANCE</code> object via pointer semantics. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>my_CountedHandle</code> can also be copied freely; the copy constructor will use the <code>increment</code> method from <code>my_CountedHandleRep</code> to note the extra copy. Similarly, the destructor will call <code>my_CountedHandleRep::decrement</code> to note that there is one fewer handle the underlying <code>INSTANCE</code> has, and delete the "rep" object when its reference count is reduced to zero. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similar to <code>my_CountedHandleRep</code>, the class declaration for <code>my_CountedHandle</code> is identical to that in <code>bsls_atomicoperations</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ======================</span>
                          <span class="comment">// class my_CountedHandle</span>
                          <span class="comment">// ======================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">class </span>my_CountedHandle {

      <span class="comment">// DATA</span>
      my_CountedHandleRep&lt;INSTANCE&gt; *d_rep_p;  <span class="comment">// shared rep.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_CountedHandle();
      my_CountedHandle(INSTANCE        *instance);

      my_CountedHandle(<span class="keyword">const</span> my_CountedHandle&lt;INSTANCE&gt;&amp; other);

      ~my_CountedHandle();

      <span class="comment">// ACCESSORS</span>
      INSTANCE *operator-&gt;() <span class="keyword">const</span>;
      <span class="keywordtype">int</span> numReferences() <span class="keyword">const</span>;
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="function_definitions_for_my_countedhandlerep"></a> <a class="anchor" id="example_2.function_definitions_for_my_countedhandlerep"></a> <a class="anchor" id="usage.example_2.function_definitions_for_my_countedhandlerep"></a> <a class="anchor" id="description.usage.example_2.function_definitions_for_my_countedhandlerep"></a> <a class="anchor" id="3.2.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Function Definitions for my_CountedHandleRep: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we provide a definition for the <code>static</code> <code>deleteObject</code> method, which is called by the destructor for class <code>my_CountedHandle</code> for the last instance of <code>my_CountedHandle</code> using the given "rep" object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_CountedHandleRep&lt;INSTANCE&gt;::deleteObject(
                                       my_CountedHandleRep&lt;INSTANCE&gt; *<span class="keywordtype">object</span>)
  {
      <span class="keyword">delete</span> object;
  }
</pre></div><br/>
<br/>
 Then, we define the constructor for the <code>my_CountedHandleRep&lt;INSTANCE&gt;</code> class. Member <code>d_count</code> is initialized to 1, reflecting the fact that this constructor will be called by a new instance of <code>my_CountedHandle</code>, which instance is our first and only handle when this constructor is called: notice that <code>d_count</code> (of type <code><a class="el" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a></code>) is initialized as if it were a simple integer; its constructor guarantees that the initialization is done atomically. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandleRep&lt;INSTANCE&gt;:: my_CountedHandleRep(INSTANCE *instance)
  : d_instance_p(instance)
  , d_count(1)
  {
  }
</pre></div><br/>
<br/>
 Then, we define the destructor, which just deletes <code>my_CountedHandle</code> <code>d_instance_p</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandleRep&lt;INSTANCE&gt;::~my_CountedHandleRep()
  {
      <span class="keyword">delete</span> d_instance_p;
  }
</pre></div><br/>
<br/>
 Next, we define method <code>increment</code>, which is called by <code>my_CountedHandle</code> to add a new reference to the current "rep" object, which simply increments <code>d_count</code>, using the prefix <code>operator++</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_CountedHandleRep&lt;INSTANCE&gt;::increment()
  {
      ++d_count;
  }
</pre></div><br/>
<br/>
 The above operation must be done atomically in a multi-threaded context; class <code><a class="el" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a></code> provides this guarantee for all its overloaded operators, and <code>my_CountedHandleRep</code> relies upon this guarantee. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we implement method <code>decrement</code>, which is called by <code>my_CountedHandle</code> when a reference to the current "rep" object is being deleted: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_CountedHandleRep&lt;INSTANCE&gt;::decrement()
  {
      <span class="keywordflow">return</span> --d_count;
  }
</pre></div><br/>
<br/>
 This method atomically decrements the number of references to this <code>my_CountedHandleRep</code> and, once again, atomicity is guaranteed by the underlying type of <code>d_count</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="function_definitions_for_my_countedhandle"></a> <a class="anchor" id="example_2.function_definitions_for_my_countedhandle"></a> <a class="anchor" id="usage.example_2.function_definitions_for_my_countedhandle"></a> <a class="anchor" id="description.usage.example_2.function_definitions_for_my_countedhandle"></a> <a class="anchor" id="3.2.2.4"></a> </dd></dl>
<dl class="user"><dt><b>Function Definitions for my_CountedHandle: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we define the first constructor for <code>my_CountedHandle</code>, which is used when creating a handle for a new <code>INSTANCE</code>; note that the <code>INSTANCE</code> is constructed separately, and a pointer to that object is passed as the first argument (<code>object</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ----------------------</span>
                          <span class="comment">// class my_CountedHandle</span>
                          <span class="comment">// ----------------------</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandle&lt;INSTANCE&gt;::my_CountedHandle(INSTANCE *instance)
  {
      d_rep_p = <span class="keyword">new</span> my_CountedHandleRep&lt;INSTANCE&gt;(instance);
  }
</pre></div><br/>
<br/>
 Then, we define the copy constructor; the new object copies the underlying <code>my_CountedHandleRep</code> and then increments its counter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandle&lt;INSTANCE&gt;::my_CountedHandle(
                                     <span class="keyword">const</span> my_CountedHandle&lt;INSTANCE&gt;&amp; other)
  : d_rep_p(other.d_rep_p)
  {
      <span class="keywordflow">if</span> (d_rep_p) {
          d_rep_p-&gt;increment();
      }
  }
</pre></div><br/>
<br/>
 Next, we define the destructor which decrements the "rep" object's reference count using the <code>decrement</code> method. The <code>decrement</code> method returns the object's reference count after the decrement is completed, and <code>my_CountedHandle</code> uses this value to determine whether the "rep" object should be deleted: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandle&lt;INSTANCE&gt;::~my_CountedHandle()
  {
      <span class="keywordflow">if</span> (d_rep_p &amp;&amp; 0 == d_rep_p-&gt;decrement()) {
          my_CountedHandleRep&lt;INSTANCE&gt;::deleteObject(d_rep_p);
      }
  }
</pre></div><br/>
<br/>
 Now, we define member <code>operator-&gt;()</code>, which provides basic pointer semantics for <code>my_CountedHandle</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  INSTANCE *my_CountedHandle&lt;INSTANCE&gt;::operator-&gt;()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_rep_p-&gt;d_instance_p;
  }
</pre></div><br/>
<br/>
 Finally, we define method <code>numReferences</code>, which returns the value of the reference counter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_CountedHandle&lt;INSTANCE&gt;::numReferences()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_rep_p ? d_rep_p-&gt;d_count : 0;
  }
</pre></div><br/>
<br/>
 Note that, while class <code>my_CountedHandleRep</code> is itself fully thread-safe, it does not guarantee thread safety for the <code>INSTANCE</code> object. In order to provide thread safety for the <code>INSTANCE</code> in the general case, the "rep" would need to use a more general concurrency mechanism such as a mutex. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Thread-Safe Lock-Free Singly-Linked List: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates the use of atomic pointers to implement a fast and thread-aware, singly-linked list. The example class, <code>my_PtrStack</code>, is a templatized pointer stack, supporting <code>push</code> and <code>pop</code> methods. The class is implemented using a single-linked list. Nodes in the list are linked together using atomic operations. Instance of this structure are allocated using the provided allocator. When nodes are freed, they are cached on a free list. This free list is also implemented as a single-linked list, using atomic pointer operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example parallels the third usage example given for component <code>bsls_atomicoperations</code>, presenting a different implementation of <code>my_PtrStack&lt;T&gt;</code>, with an identical public interface. Note that, where the <code>bsls_atomicoperations</code> example uses the basic data type <code>bsls::AtomicOperations::AtomicTypes::Pointer</code> for members <code>d_list</code> and <code>d_freeList</code>, this implementation uses instead the higher-level type <code><a class="el" href="classbsls_1_1AtomicPointer.html">bsls::AtomicPointer</a>&lt;T&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create class template, <code>my_PtrStack</code>, parameterized by <code>TYPE</code>. Instances of this template maintain a list of nodes and a free-node list. Each node has a pointer to a data item, <code>d_item_p</code>, a link to the next node in the list, <code>d_next_p</code> and an atomic flag, <code>d_inUseFlag</code>, intended for lock-free list manipulation. The definition of the <code>my_PtrStack</code> class is provided below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>my_PtrStack {
      <span class="comment">// TYPES</span>
      <span class="keyword">struct </span>Node {
          TYPE                 *d_item_p;
          Node                 *d_next_p;
          <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a>       d_inUseFlag; <span class="comment">// used to lock this node</span>
      };

      <span class="comment">// DATA</span>
      <a class="code" href="classbsls_1_1AtomicPointer.html">bsls::AtomicPointer&lt;Node&gt;</a> d_list;
      <a class="code" href="classbsls_1_1AtomicPointer.html">bsls::AtomicPointer&lt;Node&gt;</a> d_freeList;

      <span class="comment">// PRIVATE MANIPULATORS</span>
      Node *allocateNode();
      <span class="keywordtype">void</span> freeNode(Node *node);
      <span class="keywordtype">void</span> deleteNodes(Node *node);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_PtrStack();
     ~my_PtrStack();

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> push(TYPE *item);
      TYPE *pop();
  };
</pre></div><br/>
<br/>
 Then, we write a constructor that default-initializes the stack. In the corresponding example in <code>bsls_atomicoperations</code>, the constructor must also initialize the atomic pointer <code>d_freeList</code>. Since this example uses the encapsulated type <code><a class="el" href="classbsls_1_1AtomicPointer.html">bsls::AtomicPointer</a></code>, initialization of these member variables is done in their default constructors. Hence, no explicit code is required in this constructor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> my_PtrStack&lt;TYPE&gt;::my_PtrStack()
  {
  }
</pre></div><br/>
<br/>
 Next, we define the <code>deleteNodes</code> and the destructor function to delete nodes that the <code>my_PtrStack</code> object owns. Note that we don't need to worry about the concurrent access to node lists in the destructor, as destructor can be executed in only a single thread: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> <span class="keywordtype">void</span> my_PtrStack&lt;TYPE&gt;::deleteNodes(Node *node)
  {
      <span class="keywordflow">while</span> (node) {
          Node *next = node-&gt;d_next_p;
          <span class="keyword">delete</span> node;
          node = next;
      }
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> my_PtrStack&lt;TYPE&gt;::~my_PtrStack()
  {
      deleteNodes(d_list);
      deleteNodes(d_freeList);
  }
</pre></div><br/>
<br/>
 Then, we define method <code>allocateNode</code> to get a node from the free list in the thread-safe manner by leveraging atomic operations to ensure proper thread synchronization: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">typename</span> my_PtrStack&lt;TYPE&gt;::Node *my_PtrStack&lt;TYPE&gt;::allocateNode()
  {
      Node *node;
      <span class="keywordflow">while</span> (1) {
          node = d_freeList; <span class="comment">// get the current head</span>
          <span class="keywordflow">if</span> (!node) {
              <span class="keywordflow">break</span>;
          }
</pre></div><br/>
<br/>
 Next, we try locking the node, and start over if locking fails: <br/>
<br/>
<div class="fragment"><pre class="fragment">          <span class="keywordflow">if</span> (node-&gt;d_inUseFlag.swapInt(1)) {
              <span class="keywordflow">continue</span>;
          }
</pre></div><br/>
<br/>
 Then, we atomically modify the head if it has not changed. <code>testAndSwap</code> compares <code>d_freeList</code> to <code>node</code>, replacing <code>node</code> with <code>node-&gt;d_next_p</code> only if it matches <code>d_freeList</code>. If <code>d_freeList</code> did not match <code>node</code>, then the free list has been changed on another thread, between its assignment to the <code>node</code> and the call to <code>testAndSwap</code>. If the list head has changed, then try again: <br/>
<br/>
<div class="fragment"><pre class="fragment">          <span class="keywordflow">if</span> (d_freeList.testAndSwap(node, node-&gt;d_next_p) == node) {
              <span class="keywordflow">break</span>;
          }

          <span class="comment">// Unlock the node.</span>
          node-&gt;d_inUseFlag = 0;
      }
</pre></div><br/>
<br/>
 Next, we allocate a new node if there were no nodes in the free node list: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (!node) {
          node = <span class="keyword">new</span> Node();  <span class="comment">// should allocate with &#39;d_allocator_p&#39;, but</span>
                              <span class="comment">// here we use &#39;new&#39; directly for simplicity</span>
          node-&gt;d_inUseFlag = 1;
      }

      <span class="keywordflow">return</span> node;
  }
</pre></div><br/>
<br/>
 Note that the <code>node</code> is returned in the locked state and remained locked until it is added to the free list. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we define the <code>freeNode</code> method to add a given <code>node</code> to the free list; <code>freeNode</code> also needs to be synchronized using atomic operations: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> <span class="keywordtype">void</span> my_PtrStack&lt;TYPE&gt;::freeNode(Node *node)
  {
      <span class="keywordflow">if</span> (!node) {
          <span class="keywordflow">return</span>;
      }

      <span class="keywordflow">while</span> (1) {
          node-&gt;d_next_p = d_freeList;
          <span class="comment">// Atomically test and swap the head of the list with the</span>
          <span class="comment">// new node.  If the list head has been changed (by another</span>
          <span class="comment">// thread), try again.</span>
          <span class="keywordflow">if</span> (d_freeList.testAndSwap(node-&gt;d_next_p, node) == node-&gt;d_next_p)
          {
              <span class="keywordflow">break</span>;
          }
      }

      <span class="comment">// unlock the &#39;node&#39;</span>
      node-&gt;d_inUseFlag = 0;
  }
</pre></div><br/>
<br/>
 Now, we begin to define the public "stack-like" interface for <code>my_PtrStack</code>. Note that the <code>push</code> method is similar to <code>freeNode</code>, except that it assigns an item value and operates on <code>d_list</code>, which maintains the list of active nodes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> my_PtrStack&lt;TYPE&gt;::push(TYPE *item)
  {
      Node *node = allocateNode();
      node-&gt;d_item_p = item;
      <span class="keywordflow">while</span> (1) {
          node-&gt;d_next_p = d_list;
          <span class="keywordflow">if</span> (d_list.testAndSwap(node-&gt;d_next_p, node) == node-&gt;d_next_p) {
              <span class="keywordflow">break</span>;
          }
      }

      node-&gt;d_inUseFlag = 0;
  }
</pre></div><br/>
<br/>
 Finally, we define the <code>pop</code> method which removes the node from the top of active node list, <code>d_list</code>, adds it to the free-node list, and returns the data item contained in the node to the caller: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  TYPE *my_PtrStack&lt;TYPE&gt;::pop()
  {
      Node *node;
      <span class="keywordflow">while</span> (1) {
          node = d_list;
          <span class="keywordflow">if</span> (!node) {
              <span class="keywordflow">break</span>;
          }

          <span class="keywordflow">if</span> (node-&gt;d_inUseFlag.swapInt(1)) {
              <span class="keywordflow">continue</span>;  <span class="comment">// node is locked</span>
          }

          <span class="keywordflow">if</span> (d_list.testAndSwap(node, node-&gt;d_next_p) == node) {
              <span class="keywordflow">break</span>;  <span class="comment">// node list is being modified in another thread</span>
          }

          node-&gt;d_inUseFlag = 0;
      }

      TYPE *item = node ? node-&gt;d_item_p : 0;
      <span class="keywordflow">if</span> (node) {
          freeNode(node);
      }
      <span class="keywordflow">return</span> item;
  }
</pre></div><br/>
<br/>
 Notice that if the stack was empty, a NULL pointer is returned. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
