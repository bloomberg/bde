<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslx_genericinstream Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslx_genericinstream<br/>
<small>
[<a class="el" href="group__bslx.html">Package bslx</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Unexternalization of fundamental types from a parameterized stream.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslx.html">bslx</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Generic Byte-Format Parser</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Basic Unexternalization</a> </li>
<li>
<a href="#3.2.2">Example 2: Sample <code>STREAMBUF</code> Implementation</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unexternalization of fundamental types from a parameterized stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a> </td><td>parameterized input stream for fundamental types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslx__streambufinstream.html" title="Unexternalization of fundamental types from a bsl::streambuf.">Component bslx_streambufinstream</a>, <a class="el" href="group__bslx__genericoutstream.html" title="Externalization of fundamental types to a parameterized stream.">Component bslx_genericoutstream</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a parameterized input stream class, <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a></code>, that provides platform-independent input methods ("unexternalization") on values, and arrays of values, of fundamental types, and on <code>bsl::string</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a></code> type reads from a compliant user-supplied buffer (see <a href="group__bslx__genericinstream.html#generic_byte-format_parser" class="el">Generic Byte-Format Parser</a>) directly, with no data copying or assumption of ownership. The user must therefore make sure that the lifetime and visibility of the buffer is sufficient to satisfy the needs of the input stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is intended to be used in conjunction with the <code>bslx_genericoutstream</code> "externalization" component. Each input method of <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a></code> reads either a value or a homogeneous array of values of a fundamental type, in a format that was written by the corresponding <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code> method. In general, the user of this component cannot rely on being able to read data that was written by any mechanism other than <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The supported types and required content are listed in the <code>bslx</code> package-level documentation under "Supported Types". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that input streams can be <em>invalidated</em> explicitly and queried for <em>validity</em>. Reading from an initially invalid stream has no effect. Attempting to read beyond the end of a stream will automatically invalidate the stream. Whenever an inconsistent value is detected, the stream should be invalidated explicitly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="generic_byte-format_parser"></a> <a class="anchor" id="description.generic_byte-format_parser"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Generic Byte-Format Parser: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The class <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a></code> is parameterized by a buffered stream class, <code>STREAMBUF</code>, which, given the declarations: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span>        c;
  <span class="keywordtype">int</span>         len;
  <span class="keyword">const</span> <span class="keywordtype">char</span> *s;
  STREAMBUF  *sb;
</pre></div><br/>
<br/>
 must make the following expressions syntactically valid, with the assert statements highlighting the expected return values: <br/>
<br/>
<div class="fragment"><pre class="fragment">  STREAMBUF::traits_type::int_type eof = STREAMBUF::traits_type::eof();
  assert(eof != sb-&gt;sbumpc());
  assert(eof != sb-&gt;sgetc());
  assert(len == sb-&gt;sgetn(s, len));
</pre></div><br/>
<br/>
 Suitable choices for <code>STREAMBUF</code> include any class that implements the <code>bsl::basic_streambuf</code> protocol. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The class <code><a class="el" href="namespacebslx.html#ad96b8bfa1bf847be59b697e36500d839">bslx::StreambufInStream</a></code> is a <code>typedef</code> for <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt;bsl::streambuf&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. The first example depicts usage with a <code>bsl::stringbuf</code>. The second example replaces the <code>bsl::stringbuf</code> with a user-defined <code>STREAMBUF</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_unexternalization"></a> <a class="anchor" id="usage.example_1~3A_basic_unexternalization"></a> <a class="anchor" id="description.usage.example_1~3A_basic_unexternalization"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Unexternalization: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to implement a (deliberately simple) <code>MyPerson</code> class as a value-semantic object that supports BDEX externalization and unexternalization. In addition to whatever data and methods that we choose to put into our design, we must supply three methods having specific names and signatures in order to comply with the BDEX protocol: a class method <code>maxSupportedBdexVersion</code>, an accessor (i.e., a <code>const</code> method) <code>bdexStreamOut</code>, and a manipulator (i.e., a non-'const' method) <code>bdexStreamIn</code>. This example shows how to implement those three methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we will not worry overly about "good design" of the <code>MyPerson</code> component, and we will declare but not implement illustrative methods and free operators, except for the three required BDEX methods, which are implemented in full. In particular, we will not make explicit use of <code>bslma</code> allocators; a more complete design would do so: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we implement <code>MyPerson</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyPerson {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_firstName;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_lastName;
      <span class="keywordtype">int</span>         d_age;

      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPerson&amp;, <span class="keyword">const</span> MyPerson&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> versionSelector);
          <span class="comment">// Return the maximum valid BDEX format version, as indicated by</span>
          <span class="comment">// the specified &#39;versionSelector&#39;, to be passed to the</span>
          <span class="comment">// &#39;bdexStreamOut&#39; method.  Note that it is highly recommended that</span>
          <span class="comment">// &#39;versionSelector&#39; be formatted as &quot;YYYYMMDD&quot;, a date</span>
          <span class="comment">// representation.  Also note that &#39;versionSelector&#39; should be a</span>
          <span class="comment">// *compile*-time-chosen value that selects a format version</span>
          <span class="comment">// supported by both externalizer and unexternalizer.  See the</span>
          <span class="comment">// &#39;bslx&#39; package-level documentation for more information on BDEX</span>
          <span class="comment">// streaming of value-semantic types and containers.</span>

      <span class="comment">// CREATORS</span>
      MyPerson();
          <span class="comment">// Create a default person.</span>

      MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age);
          <span class="comment">// Create a person having the specified &#39;firstName&#39;, &#39;lastName&#39;,</span>
          <span class="comment">// and &#39;age&#39;.</span>

      MyPerson(<span class="keyword">const</span> MyPerson&amp; original);
          <span class="comment">// Create a person having the value of the specified &#39;original&#39;</span>
          <span class="comment">// person.</span>

      ~MyPerson();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      MyPerson&amp; operator=(<span class="keyword">const</span> MyPerson&amp; rhs);
          <span class="comment">// Assign to this person the value of the specified &#39;rhs&#39; person,</span>
          <span class="comment">// and return a reference to this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated, but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>

      <span class="comment">//...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> age() <span class="keyword">const</span>;
          <span class="comment">// Return the age of this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write the value of this object, using the specified &#39;version&#39;</span>
          <span class="comment">// format, to the specified output &#39;stream&#39;, and return a reference</span>
          <span class="comment">// to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation</span>
          <span class="comment">// has no effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is</span>
          <span class="comment">// invalidated, but otherwise unmodified.  Note that &#39;version&#39; is</span>
          <span class="comment">// not written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level</span>
          <span class="comment">// documentation for more information on BDEX streaming of</span>
          <span class="comment">// value-semantic types and containers.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; firstName() <span class="keyword">const</span>;
          <span class="comment">// Return the first name of this person.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; lastName() <span class="keyword">const</span>;
          <span class="comment">// Return the last name of this person.</span>

      <span class="comment">//...</span>

  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two person objects have the</span>
      <span class="comment">// same value if they have the same first name, last name, and age.</span>

  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects do not</span>
      <span class="comment">// have the same value, and &#39;false&#39; otherwise.  Two person objects</span>
      <span class="comment">// differ in value if they differ in first name, last name, or age.</span>

  <span class="comment">// ========================================================================</span>
  <span class="comment">//                  INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">MyPerson::maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> <span class="comment">/* versionSelector */</span>) {
      <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyPerson::MyPerson()
  : d_firstName(<span class="stringliteral">&quot;&quot;</span>)
  , d_lastName(<span class="stringliteral">&quot;&quot;</span>)
  , d_age(0)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age)
  : d_firstName(firstName)
  , d_lastName(lastName)
  , d_age(age)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::~MyPerson()
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">MyPerson::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">if</span> (stream) {
          <span class="keywordflow">switch</span> (version) {  <span class="comment">// switch on the &#39;bslx&#39; version</span>
            <span class="keywordflow">case</span> 1: {
              stream.getString(d_firstName);
              <span class="keywordflow">if</span> (!stream) {
                  d_firstName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                 <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;                                    <span class="comment">// RETURN</span>
              }
              stream.getString(d_lastName);
              <span class="keywordflow">if</span> (!stream) {
                  d_lastName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;                                    <span class="comment">// RETURN</span>
              }
              stream.getInt32(d_age);
              <span class="keywordflow">if</span> (!stream) {
                  d_age = 999;     <span class="comment">// *might* be corrupted; value for testing</span>
                  <span class="keywordflow">return</span> stream;                                    <span class="comment">// RETURN</span>
              }
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>: {
              stream.invalidate();
            }
          }
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyPerson::age()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_age;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">MyPerson::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putString(d_firstName);
          stream.putString(d_lastName);
          stream.putInt32(d_age);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; MyPerson::firstName()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_firstName;
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; MyPerson::lastName()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_lastName;
  }

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_firstName == rhs.d_firstName &amp;&amp;
             lhs.d_lastName  == rhs.d_lastName  &amp;&amp;
             lhs.d_age       == rhs.d_age;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs)
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 Then, we can exercise the new <code>MyPerson</code> value-semantic class by externalizing and reconstituting an object. First, create a <code>MyPerson</code> <code>janeSmith1</code> and a <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code> <code>outStream1</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson                               janeSmith1(<span class="stringliteral">&quot;Jane&quot;</span>, <span class="stringliteral">&quot;Smith&quot;</span>, 42);
  <a class="code" href="classbsl_1_1basic__stringbuf.html">bsl::stringbuf</a>                         buffer1;
  <a class="code" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream&lt;bsl::stringbuf&gt;</a> outStream1(&amp;buffer1, 20131127);
  <span class="keyword">const</span> <span class="keywordtype">int</span>                              VERSION1 = 1;
  outStream1.putVersion(VERSION1);
  janeSmith1.bdexStreamOut(outStream1, VERSION1);
  assert(outStream1.isValid());
</pre></div><br/>
<br/>
 Next, create a <code>MyPerson</code> <code>janeCopy1</code> initialized to the default value, and assert that <code>janeCopy1</code> is different from <code>janeSmith1</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeCopy1;
  assert(janeCopy1 != janeSmith1);
</pre></div><br/>
<br/>
 Then, create a <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a></code> <code>inStream1</code> initialized with the buffer from the <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code> object <code>outStream1</code> and unexternalize this data into <code>janeCopy1</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream&lt;bsl::stringbuf&gt;</a> inStream1(&amp;buffer1);
  <span class="keywordtype">int</span>                                   version1;
  inStream1.getVersion(version1);
  janeCopy1.bdexStreamIn(inStream1, version1);
  assert(inStream1.isValid());
</pre></div><br/>
<br/>
 Finally, <code>assert</code> the obtained values are as expected and display the results to <code>bsl::stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(version1  == VERSION1);
  assert(janeCopy1 == janeSmith1);

  <span class="keywordflow">if</span> (janeCopy1 == janeSmith1) {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Successfully serialized and de-serialized Jane Smith:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy1.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy1.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy1.age() &lt;&lt; bsl::endl;
  }
  <span class="keywordflow">else</span> {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Serialization unsuccessful.  &#39;janeCopy1&#39; holds:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy1.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy1.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy1.age() &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_sample_streambuf_implementation"></a> <a class="anchor" id="usage.example_2~3A_sample_streambuf_implementation"></a> <a class="anchor" id="description.usage.example_2~3A_sample_streambuf_implementation"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Sample STREAMBUF Implementation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>For this example, we will implement <code>MyStreamBuf</code>, a minimal <code>STREAMBUF</code> to to be used with <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a></code> and <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code>. The implementation will consist of only what is required of the type. For comparison, we will reuse <code>MyPerson</code> and repeat part of <a href="group__bslx__genericinstream.html#example_1" class="el">Example 1</a> to demonstrate how to use <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we implement <code>MyStreamBuf</code> (which, for brevity, simply uses the default allocator): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyStreamBuf {
      <span class="comment">// This class implements a very basic stream buffer suitable for use in</span>
      <span class="comment">// &#39;bslx::GenericOutStream&#39; and &#39;bslx::GenericInStream&#39;.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1deque.html">bsl::deque&lt;char&gt;</a> d_buffer;  <span class="comment">// the input and output buffer</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      MyStreamBuf(<span class="keyword">const</span> MyStreamBuf&amp;);
      MyStreamBuf&amp; operator=(<span class="keyword">const</span> MyStreamBuf&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">struct </span>traits_type {
          <span class="keyword">static</span> <span class="keywordtype">int</span> eof() { <span class="keywordflow">return</span> -1; }
      };

      <span class="comment">// CREATORS</span>
      MyStreamBuf();
          <span class="comment">// Create an empty stream buffer.</span>

      ~MyStreamBuf();
          <span class="comment">// Destroy this stream buffer.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> pubsync();
          <span class="comment">// Return 0.</span>

      <span class="keywordtype">int</span> sbumpc();
          <span class="comment">// Read the next character in this buffer.  Return the value of the</span>
          <span class="comment">// character on success, and &#39;traits_type::eof()&#39; otherwise.</span>

      <span class="keywordtype">int</span> sgetc();
          <span class="comment">// Peek at the next character in this buffer.  Return the value of</span>
          <span class="comment">// the character on success, and &#39;traits_type::eof()&#39; otherwise.</span>

      bsl::streamsize sgetn(<span class="keywordtype">char</span> *s, bsl::streamsize length);
          <span class="comment">// Load the specified &#39;length&#39; characters into the specified</span>
          <span class="comment">// address &#39;s&#39;, and return the number of characters read.</span>

      <span class="keywordtype">int</span> sputc(<span class="keywordtype">char</span> c);
          <span class="comment">// Write the specified character &#39;c&#39; to this buffer.  Return &#39;c&#39; on</span>
          <span class="comment">// success, and &#39;traits_type::eof()&#39; otherwise.</span>

      bsl::streamsize sputn(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, bsl::streamsize length);
          <span class="comment">// Write the specified &#39;length&#39; characters at the specified address</span>
          <span class="comment">// &#39;s&#39; to this buffer, and return the number of characters written.</span>
  };

  <span class="comment">// ========================================================================</span>
  <span class="comment">//                  INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CREATORS</span>
  MyStreamBuf::MyStreamBuf()
  : d_buffer()
  {
  }

  MyStreamBuf::~MyStreamBuf()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">int</span> MyStreamBuf::pubsync()
  {
      <span class="comment">// In this implementation, there is nothing to be done except return</span>
      <span class="comment">// success.</span>

      <span class="keywordflow">return</span> 0;
  }

  <span class="keywordtype">int</span> MyStreamBuf::sbumpc()
  {
      <span class="keywordflow">if</span> (!d_buffer.empty()) {
          <span class="keyword">const</span> <span class="keywordtype">int</span> rv = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(d_buffer.front());
          d_buffer.pop_front();
          <span class="keywordflow">return</span> rv;                                                <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">return</span> traits_type::eof();
  }

  <span class="keywordtype">int</span> MyStreamBuf::sgetc()
  {
      <span class="keywordflow">if</span> (!d_buffer.empty()) {
          <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(d_buffer.front());                <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">return</span> traits_type::eof();
  }

  bsl::streamsize MyStreamBuf::sgetn(<span class="keywordtype">char</span> *s, bsl::streamsize length)
  {
      <span class="keywordflow">for</span> (bsl::streamsize i = 0; i &lt; length; ++i) {
          <span class="keywordflow">if</span> (d_buffer.empty()) {
              <span class="keywordflow">return</span> i;                                             <span class="comment">// RETURN</span>
          }
          s[i] = d_buffer.front();
          d_buffer.pop_front();
      }
      <span class="keywordflow">return</span> length;
  }

  <span class="keywordtype">int</span> MyStreamBuf::sputc(<span class="keywordtype">char</span> c)
  {
      d_buffer.push_back(c);
      <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(c);
  }

  bsl::streamsize MyStreamBuf::sputn(<span class="keyword">const</span> <span class="keywordtype">char</span>      *s,
                                     bsl::streamsize  length)
  {
      <span class="keywordflow">for</span> (bsl::streamsize i = 0; i &lt; length; ++i) {
          d_buffer.push_back(s[i]);
      }
      <span class="keywordflow">return</span> length;
  }
</pre></div><br/>
<br/>
 Then, we create a <code>MyPerson</code> <code>janeSmith2</code> and a <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code> <code>outStream2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson                               janeSmith2(<span class="stringliteral">&quot;Jane&quot;</span>, <span class="stringliteral">&quot;Smith&quot;</span>, 42);
  MyStreamBuf                            buffer2;
  <a class="code" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream&lt;MyStreamBuf&gt;</a>    outStream2(&amp;buffer2, 20131127);
  <span class="keyword">const</span> <span class="keywordtype">int</span>                              VERSION2 = 1;
  outStream2.putVersion(VERSION2);
  janeSmith2.bdexStreamOut(outStream2, VERSION2);
  assert(outStream2.isValid());
</pre></div><br/>
<br/>
 Next, create a <code>MyPerson</code> <code>janeCopy2</code> initialized to the default value, and assert that <code>janeCopy2</code> is different from <code>janeSmith2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeCopy2;
  assert(janeCopy2 != janeSmith2);
</pre></div><br/>
<br/>
 Then, create a <code><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a></code> <code>inStream2</code> initialized with the buffer from the <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code> object <code>outStream2</code> and unexternalize this data into <code>janeCopy2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream&lt;MyStreamBuf&gt;</a>    inStream2(&amp;buffer2);
  <span class="keywordtype">int</span>                                   version2;
  inStream2.getVersion(version2);
  janeCopy2.bdexStreamIn(inStream2, version2);
  assert(inStream2.isValid());
</pre></div><br/>
<br/>
 Finally, <code>assert</code> the obtained values are as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(version2  == VERSION2);
  assert(janeCopy2 == janeSmith2);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:12 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
