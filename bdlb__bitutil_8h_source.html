<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlb_bitutil.h                                                     -*-C++-*-
#ifndef INCLUDED_BDLB_BITUTIL
#define INCLUDED_BDLB_BITUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide efficient bit-manipulation of &#39;uint32_t&#39;/&#39;uint64_t&#39; values.
//
//@CLASSES:
//  bdlb::BitUtil: namespace for &#39;uint32_t&#39; and &#39;uint64_t&#39; bit-level operations
//
//@DESCRIPTION: This component provides a utility &#39;struct&#39;, &#39;bdlb::BitUtil&#39;,
// that serves as a namespace for a collection of efficient, bit-level
// procedures on &#39;uint32_t&#39; and &#39;uint64_t&#39;.  In particular, &#39;BitUtil&#39; supplies
// single bit manipulation, bit counting, and mathematical functions that can
// be optimized with bitwise operations.
//
// Some of the methods provided in &#39;BitUtil&#39; have other common names.  Below is
// a list of mappings from the name used in &#39;BitUtil&#39; to these related function
// names:
//
//: * numLeadingUnsetBits: cntlz, clz, ffs, ffo, nlz, ctlz
//:
//: * numTrailingUnsetBits: cnttz, ctz, ntz, cttz
//:
//: * numBitsSet: popcnt, popcount
//
///Usage
///-----
// The following usage examples illustrate how some of the methods provided by
// this component are used.  Note that, in all of these examples, the low-order
// bit is considered bit 0 and resides on the right edge of the bit string.
//
// First, we use &#39;withBitSet&#39; to demonstrate the ordering of bits:
//..
//  assert(static_cast&lt;uint32_t&gt;(0x00000001)
//                 == bdlb::BitUtil::withBitSet(static_cast&lt;uint32_t&gt;(0),  0));
//  assert(static_cast&lt;uint32_t&gt;(0x00000008)
//                 == bdlb::BitUtil::withBitSet(static_cast&lt;uint32_t&gt;(0),  3));
//  assert(static_cast&lt;uint32_t&gt;(0x00800000)
//                 == bdlb::BitUtil::withBitSet(static_cast&lt;uint32_t&gt;(0), 23));
//  assert(static_cast&lt;uint32_t&gt;(0x66676666)
//        == bdlb::BitUtil::withBitSet(static_cast&lt;uint32_t&gt;(0x66666666), 16));
//
//  /*------------------------------------------------------------------------+
//  | &#39;bdlb::BitUtil::withBitSet(0x66666666, 16)&#39; in binary:                  |
//  |                                                                         |
//  | input in binary:                       01100110011001100110011001100110 |
//  | set bit 16:                                           1                 |
//  | result:                                01100110011001110110011001100110 |
//  +------------------------------------------------------------------------*/
//..
// Then, we count the number of set bits in a value with &#39;numBitsSet&#39;:
//..
//  assert(0 == bdlb::BitUtil::numBitsSet(static_cast&lt;uint32_t&gt;(0x00000000)));
//  assert(2 == bdlb::BitUtil::numBitsSet(static_cast&lt;uint32_t&gt;(0x00101000)));
//  assert(8 == bdlb::BitUtil::numBitsSet(static_cast&lt;uint32_t&gt;(0x30071101)));
//
//  /*------------------------------------------------------------------------+
//  | &#39;bdlb::BitUtil::numBitsSet(0x30071101)&#39; in binary:                      |
//  |                                                                         |
//  | input in binary:                       00110000000001110001000100000001 |
//  | that has 8 bits set.  result: 8                                         |
//  +------------------------------------------------------------------------*/
//..
// Finally, we use &#39;numLeadingUnsetBits&#39; to determine the number of unset bits
// with a higher index than the first set bit:
//..
//  assert(32 ==
//      bdlb::BitUtil::numLeadingUnsetBits(static_cast&lt;uint32_t&gt;(0x00000000)));
//  assert(31 ==
//      bdlb::BitUtil::numLeadingUnsetBits(static_cast&lt;uint32_t&gt;(0x00000001)));
//  assert(7 ==
//      bdlb::BitUtil::numLeadingUnsetBits(static_cast&lt;uint32_t&gt;(0x01000000)));
//  assert(7 ==
//      bdlb::BitUtil::numLeadingUnsetBits(static_cast&lt;uint32_t&gt;(0x01620030)));
//
//  /*------------------------------------------------------------------------+
//  | &#39;bdlb::BitUtil::numLeadingUnsetBits(0x01620030)&#39; in binary:             |
//  |                                                                         |
//  | input in binary:                       00000001011000100000000000110000 |
//  | highest set bit:                              1                         |
//  | number of unset bits leading this set bit == 7                          |
//  +------------------------------------------------------------------------*/
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSL_CLIMITS
#include &lt;bsl_climits.h&gt;
#endif

#ifdef BSLS_PLATFORM_CMP_IBM
#ifndef INCLUDED_BUILTINS
#include &lt;builtins.h&gt;
#define INCLUDED_BUILTINS
#endif
#endif

#if defined(BSLS_PLATFORM_CMP_MSVC) &amp;&amp; BSLS_PLATFORM_CMP_VERSION &lt; 1600
// The Microsoft toolchains prior to VC2010 do not support the C99 &lt;stdint.h&gt;
#define BDLB_BITUTIL_NO_STDINT
#endif

#ifndef BDLB_BITUTIL_NO_STDINT

#ifndef INCLUDED_STDINT
#include &lt;stdint.h&gt;
#define INCLUDED_STDINT
#endif

#endif // BDLB_BITUTIL_NO_STDINT

namespace BloombergLP {
namespace bdlb {

                               // ==============
                               // struct BitUtil
                               // ==============

struct BitUtil {
    // This utility &#39;struct&#39; provides a namespace for a set of bit-level,
    // stateless functions that operate on the built-in 32- and 64-bit integer
    // types &#39;uint32_t&#39; and &#39;uint64_t&#39;, respectively.

  private:
    // PRIVATE CONSTANTS
    enum {
        k_BITS_PER_INT32 = 32,  // bits used to represent an &#39;int32_t&#39;
        k_BITS_PER_INT64 = 64   // bits used to represent an &#39;int64_t&#39;
    };

  public:
    // PUBLIC TYPE ALIASES (to support old toolchains)
#if defined(BDLB_BITUTIL_NO_STDINT)
    typedef unsigned int       uint32_t;
    typedef unsigned long long uint64_t;
#else
    typedef ::uint32_t uint32_t;
    typedef ::uint64_t uint64_t;
#endif

  private:
    // PRIVATE CLASS METHODS
    static int privateNumBitsSet(uint32_t value);
    static int privateNumBitsSet(uint64_t value);
        // Return the number of 1 bits in the specified &#39;value&#39;.

    static int privateNumLeadingUnsetBits(uint32_t value);
    static int privateNumLeadingUnsetBits(uint64_t value);
        // Return the number of consecutive 0 bits starting from the
        // most-significant bit in the specified &#39;value&#39;.

    static int privateNumTrailingUnsetBits(uint32_t value);
    static int privateNumTrailingUnsetBits(uint64_t value);
        // Return the number of consecutive 0 bits starting from the
        // least-significant bit in the specified &#39;value&#39;.

  public:
    // CLASS METHODS
    static bool isBitSet(uint32_t value, int index);
    static bool isBitSet(uint64_t value, int index);
        // Return &#39;true&#39; if the bit in the specified &#39;value&#39; at the specified
        // &#39;index&#39; is set to 1, and &#39;false&#39; otherwise.  The behavior is
        // undefined unless &#39;0 &lt;= index &lt; sizeInBits(value)&#39;.

    static int log2(uint32_t value);
    static int log2(uint64_t value);
        // Return the base-2 logarithm of the specified &#39;value&#39; rounded up to
        // the nearest integer.  The behavior is undefined unless &#39;0 &lt; value&#39;.

    static int numBitsSet(uint32_t value);
    static int numBitsSet(uint64_t value);
        // Return the number of 1 bits in the specified &#39;value&#39;.

    static int numLeadingUnsetBits(uint32_t value);
    static int numLeadingUnsetBits(uint64_t value);
        // Return the number of consecutive 0 bits starting from the
        // most-significant bit in the specified &#39;value&#39;.

    static int numTrailingUnsetBits(uint32_t value);
    static int numTrailingUnsetBits(uint64_t value);
        // Return the number of consecutive 0 bits starting from the
        // least-significant bit in the specified &#39;value&#39;.

    static uint32_t roundUp(uint32_t value, uint32_t boundary);
    static uint64_t roundUp(uint64_t value, uint64_t boundary);
        // Return the least multiple of the specified &#39;boundary&#39; that is
        // greater than or equal to the specified &#39;value&#39;, and 0 if
        // &#39;0 == value&#39; or the conversion was not successful.  The behavior is
        // undefined unless &#39;1 == numBitsSet(boundary)&#39;.  Note that the
        // conversion will succeed if and only if &#39;0 == value % boundary&#39; or
        // &#39;(1 &lt;&lt; sizeInBits(value)) &gt; (value / boundary + 1) * boundary&#39;.

    static uint32_t roundUpToBinaryPower(uint32_t value);
    static uint64_t roundUpToBinaryPower(uint64_t value);
        // Return the least power of 2 that is greater than or equal to the
        // specified &#39;value&#39;, and 0 if the conversion was not successful.  Note
        // that the conversion will succeed if and only if
        // &#39;0 &lt; value &lt;= (1 &lt;&lt; (sizeInBits(value) - 1))&#39;

    template &lt;class INTEGER&gt;
    static int sizeInBits(INTEGER value);
        // Return the number of bits in the specified &#39;value&#39; of the (template
        // parameter) type &#39;INTEGER&#39;.

    static uint32_t withBitCleared(uint32_t value, int index);
    static uint64_t withBitCleared(uint64_t value, int index);
        // Return the result of replacing the bit at the specified &#39;index&#39; in
        // the specified &#39;value&#39; with 0, transferring all other bits from
        // &#39;value&#39; unchanged.  The behavior is undefined unless
        // &#39;0 &lt;= index &lt; sizeInBits(value)&#39;.

    static uint32_t withBitSet(uint32_t value, int index);
    static uint64_t withBitSet(uint64_t value, int index);
        // Return the result of replacing the bit at the specified &#39;index&#39; in
        // the specified &#39;value&#39; with 1, transferring all other bits from
        // &#39;value&#39; unchanged.  The behavior is undefined unless
        // &#39;0 &lt;= index &lt; sizeInBits(value)&#39;.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                               // --------------
                               // struct BitUtil
                               // --------------

// CLASS METHODS
inline
bool BitUtil::isBitSet(uint32_t value, int index)
{
    BSLS_ASSERT_SAFE(    0 &lt;= index);
    BSLS_ASSERT_SAFE(index &lt;  k_BITS_PER_INT32);

    return (1 &lt;&lt; index) &amp; value;
}

inline
bool BitUtil::isBitSet(uint64_t value, int index)
{
    BSLS_ASSERT_SAFE(    0 &lt;= index);
    BSLS_ASSERT_SAFE(index &lt;  k_BITS_PER_INT64);

    return (static_cast&lt;uint64_t&gt;(1) &lt;&lt; index) &amp; value;
}

inline
int BitUtil::log2(uint32_t value)
{
    BSLS_ASSERT_SAFE(0 &lt; value);

    return k_BITS_PER_INT32 - numLeadingUnsetBits(value - 1);
}

inline
int BitUtil::log2(uint64_t value)
{
    BSLS_ASSERT_SAFE(0LL &lt; value);

    return k_BITS_PER_INT64 - numLeadingUnsetBits(value - 1);
}

inline
int BitUtil::numBitsSet(uint32_t value)
{
#if defined(BSLS_PLATFORM_CMP_IBM)
    return __popcnt4(value);
#elif defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
    return __builtin_popcount(value);
#else
    return privateNumBitsSet(value);
#endif
}

inline
int BitUtil::numBitsSet(uint64_t value)
{
#if defined(BSLS_PLATFORM_CMP_IBM)
    return __popcnt8(value);
#elif defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
    return __builtin_popcountll(value);
#else
    return privateNumBitsSet(value);
#endif
}

inline
int BitUtil::numLeadingUnsetBits(uint32_t value)
{
#if defined(BSLS_PLATFORM_CMP_IBM)
    return __cntlz4(value);
#elif defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
    // &#39;__builtin_clz(0)&#39; is undefined
    return __builtin_clz(value | 1) + static_cast&lt;int&gt;(!value);
#else
    return privateNumLeadingUnsetBits(value);
#endif
}

inline
int BitUtil::numLeadingUnsetBits(uint64_t value)
{
#if defined(BSLS_PLATFORM_CMP_IBM)
    return __cntlz8(value);
#elif defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
    // &#39;__builtin_clzll(0)&#39; is undefined
    return __builtin_clzll(value | 1) + static_cast&lt;int&gt;(!value);
#else
    return privateNumLeadingUnsetBits(value);
#endif
}

inline
int BitUtil::numTrailingUnsetBits(uint32_t value)
{
#if defined(BSLS_PLATFORM_CMP_IBM)
    return __cnttz4(value);
#elif defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
    enum {
        k_INT32_MASK = k_BITS_PER_INT32 - 1
    };
    const uint32_t a = __builtin_ffs(value) - 1;
    return (a &amp; k_INT32_MASK) + (a &gt;&gt; k_INT32_MASK);

    // Other possibility:
    //..
    //  return (__builtin_ffs(value) - 1) ^ ((-!value) &amp; ~k_BITS_PER_INT32);
    //..
#else
    return privateNumTrailingUnsetBits(value);
#endif
}

inline
int BitUtil::numTrailingUnsetBits(uint64_t value)
{
#if defined(BSLS_PLATFORM_CMP_IBM)
    return __cnttz8(value);
#elif defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
    enum {
        k_INT64_MASK = k_BITS_PER_INT64 - 1,
        k_INT32_MASK = k_BITS_PER_INT32 - 1
    };
    const uint32_t a = __builtin_ffsll(value) - 1;
    return (a &amp; k_INT64_MASK) + (a &gt;&gt; k_INT32_MASK);

    // Other possibility:
    //..
    //  return (__builtin_ffsll(value) - 1) ^ ((-!value) &amp; ~k_BITS_PER_INT64);
    //..
#else
    return privateNumTrailingUnsetBits(value);
#endif
}

inline
BitUtil::uint32_t BitUtil::roundUp(uint32_t value, uint32_t boundary)
{
    BSLS_ASSERT_SAFE(1 == numBitsSet(boundary));

    return ((value - 1) | (boundary - 1)) + 1;
}

inline
BitUtil::uint64_t BitUtil::roundUp(uint64_t value, uint64_t boundary)
{
    BSLS_ASSERT_SAFE(1 == numBitsSet(boundary));

    return ((value - 1) | (boundary - 1)) + 1;
}

inline
BitUtil::uint32_t BitUtil::roundUpToBinaryPower(uint32_t value)
{
    const int index = numLeadingUnsetBits(value - 1);
    return BSLS_PERFORMANCEHINT_PREDICT_LIKELY(0 &lt; index)
           ? static_cast&lt;uint32_t&gt;(1) &lt;&lt; (k_BITS_PER_INT32 - index)
           : 0;
}

inline
BitUtil::uint64_t BitUtil::roundUpToBinaryPower(uint64_t value)
{
    const int index = numLeadingUnsetBits(value - 1);
    return BSLS_PERFORMANCEHINT_PREDICT_LIKELY(0 &lt; index)
           ? static_cast&lt;uint64_t&gt;(1) &lt;&lt; (k_BITS_PER_INT64 - index)
           : 0;
}

template &lt;class TYPE&gt;
inline
int BitUtil::sizeInBits(TYPE)
{
    return static_cast&lt;int&gt;(CHAR_BIT * sizeof(TYPE));
}

inline
BitUtil::uint32_t BitUtil::withBitCleared(uint32_t value, int index)
{
    BSLS_ASSERT_SAFE(    0 &lt;= index);
    BSLS_ASSERT_SAFE(index &lt;  k_BITS_PER_INT32);

    return value &amp; ~(1 &lt;&lt; index);
}

inline
BitUtil::uint64_t BitUtil::withBitCleared(uint64_t value, int index)
{
    BSLS_ASSERT_SAFE(    0 &lt;= index);
    BSLS_ASSERT_SAFE(index &lt;  k_BITS_PER_INT64);

    return value &amp; ~(static_cast&lt;uint64_t&gt;(1) &lt;&lt; index);
}

inline
BitUtil::uint32_t BitUtil::withBitSet(uint32_t value, int index)
{
    BSLS_ASSERT_SAFE(    0 &lt;= index);
    BSLS_ASSERT_SAFE(index &lt;  k_BITS_PER_INT32);

    return value | (1 &lt;&lt; index);
}

inline
BitUtil::uint64_t BitUtil::withBitSet(uint64_t value, int index)
{
    BSLS_ASSERT_SAFE(    0 &lt;= index);
    BSLS_ASSERT_SAFE(index &lt;  k_BITS_PER_INT64);

    return value | (static_cast&lt;uint64_t&gt;(1) &lt;&lt; index);
}

}  // close package namespace
}  // close enterprise namespace

#if defined(BDLB_BITUTIL_NO_STDINT)
# undef BDLB_BITUTIL_NO_STDINT
#endif

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
