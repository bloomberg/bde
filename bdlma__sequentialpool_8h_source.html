<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlma_sequentialpool.h                                             -*-C++-*-
#ifndef INCLUDED_BDLMA_SEQUENTIALPOOL
#define INCLUDED_BDLMA_SEQUENTIALPOOL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide sequential memory using dynamically-allocated buffers.
//
//@CLASSES:
//   bdlma::SequentialPool: memory pool using dynamically-allocated buffers
//
//@SEE_ALSO: bdlma_infrequentdeleteblocklist, bdlma_sequentialallocator
//
//@DESCRIPTION: This component provides a fast sequential memory pool,
// &#39;bdlma::SequentialPool&#39;, that dispenses heterogeneous memory blocks (of
// varying, user-specified sizes) from a dynamically-allocated internal
// buffer.  If an allocation request exceeds the remaining free memory space in
// the internal buffer, the pool either replenishes its buffer with new memory
// to satisfy the request, or returns a separate memory block, depending on
// whether the request size exceeds an optionally-specified maximum buffer
// size.  The &#39;release&#39; method releases all memory allocated through the pool,
// as does the destructor.  Note that individually allocated memory blocks
// cannot be separately deallocated.
//
// A &#39;bdlma::SequentialPool&#39; is typically used when fast allocation and
// deallocation is needed, but the user does not know in advance the maximum
// amount of memory needed.
//
///Optional &#39;initialSize&#39; Parameter
///--------------------------------
// An optional &#39;initialSize&#39; parameter can be supplied at construction to
// specify the initial size of the internal buffer.  If &#39;initialSize&#39; is not
// supplied, an implementation-defined value is used for the initial internal
// size of the buffer.
//
///Optional &#39;maxBufferSize&#39; Parameter
/// - - - - - - - - - - - - - - - - -
// If &#39;initialSize&#39; is specified, an optional &#39;maxBufferSize&#39; parameter can be
// supplied at construction to specify the maximum buffer size for geometric
// growth.  Once the internal buffer grows up to the &#39;maxBufferSize&#39;, further
// requests that exceed this size will be served by a separate memory block
// instead of the internal buffer.  The behavior is undefined unless
// &#39;maxBufferSize &gt;= initialSize&#39;.  Note that &#39;reserveCapacity&#39; always ensures
// that the requested number of bytes is available (allocating a new internal
// buffer if necessary) regardless of whether the size of the request exceeds
// &#39;maxBufferSize&#39;.
//
///Optional &#39;growthStrategy&#39; Parameter
///-----------------------------------
// An optional &#39;growthStrategy&#39; parameter can be supplied at construction to
// specify the growth rate of the dynamically-allocated buffers.  The buffers
// can grow either geometrically or remain constant in size.  If
// &#39;growthStrategy&#39; is not specified, geometric growth is used.  See
// &#39;bsls_blockgrowth&#39; for more details.
//
///Optional &#39;alignmentStrategy&#39; Parameter
///--------------------------------------
// An optional &#39;alignmentStrategy&#39; parameter can be supplied at construction to
// specify the memory alignment strategy.  Allocated memory blocks can either
// follow maximum alignment, natural alignment, or 1-byte alignment.  If
// &#39;alignmentStrategy&#39; is not specified, natural alignment is used.  See
// &#39;bsls_alignment&#39; for more details.
//
///Usage
///-----
///Example 1: Using &#39;bdlma::SequentialPool&#39; for Efficient Allocations
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we define a container class, &#39;my_IntDoubleArray&#39;, that holds both
// &#39;int&#39; and &#39;double&#39; values.  The class can be implemented using two parallel
// arrays: one storing the type information, and the other storing pointers to
// the &#39;int&#39; and &#39;double&#39; values.  For efficient memory allocation, we can use
// a &#39;bdlma::SequentialPool&#39; for memory allocation:
//..
//  // my_intdoublearray.h
//
//  class my_IntDoubleArray {
//      // This class implements an efficient container for an array that
//      // stores both &#39;int&#39; and &#39;double&#39; values.
//
//      // DATA
//      char  *d_typeArray_p;   // array indicating the type of corresponding
//                              // values stored in &#39;d_valueArray_p&#39;
//
//      void **d_valueArray_p;  // array of pointers to the values stored
//
//      int    d_length;        // number of values stored
//
//      int    d_capacity;      // physical capacity of the type and value
//                              // arrays
//
//      bdlma::SequentialPool
//             d_pool;          // sequential memory pool used to supply memory
//
//    private:
//      // PRIVATE MANIPULATORS
//      void increaseSize();
//          // Increase the capacity of the internal arrays used to store
//          // elements added to this array by at least one element.
//
//    public:
//      // TYPES
//      enum Type { MY_INT, MY_DOUBLE };
//
//      // CREATORS
//      explicit my_IntDoubleArray(bslma::Allocator *basicAllocator = 0);
//          // Create an &#39;int&#39;-&#39;double&#39; array.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      ~my_IntDoubleArray();
//          // Destroy this array and all elements held by it.
//
//      // ...
//
//      // MANIPULATORS
//      void appendInt(int value);
//          // Append the specified &#39;int&#39; &#39;value&#39; to this array.
//
//      void appendDouble(double value);
//          // Append the specified &#39;double&#39; &#39;value&#39; to this array.
//
//      void removeAll();
//          // Remove all elements from this array.
//
//      // ...
//  };
//..
// The use of a sequential pool and the &#39;release&#39; method allows the &#39;removeAll&#39;
// method to quickly deallocate memory of all elements:
//..
//  // MANIPULATORS
//  inline
//  void my_IntDoubleArray::removeAll()
//  {
//      d_pool.release();
//      d_length = 0;
//  }
//..
// The sequential pool optimizes the allocation of memory by using
// dynamically-allocated buffers to supply memory.  This greatly reduces the
// amount of dynamic allocation needed:
//..
//  // my_intdoublearray.cpp
//  #include &lt;my_intdoublearray.h&gt;
//
//  enum { INITIAL_SIZE = 1, GROWTH_FACTOR = 2 };
//
//  // PRIVATE MANIPULATORS
//  void my_IntDoubleArray::increaseSize()
//  {
//      // Implementation elided.
//      // ...
//  }
//
//  // CREATORS
//  my_IntDoubleArray::my_IntDoubleArray(bslma::Allocator *basicAllocator)
//  : d_length(0)
//  , d_capacity(INITIAL_SIZE)
//  , d_pool(basicAllocator)
//  {
//      d_typeArray_p  = static_cast&lt;char *&gt;(
//                       d_pool.allocate(d_capacity * sizeof *d_typeArray_p));
//      d_valueArray_p = static_cast&lt;void **&gt;(
//                       d_pool.allocate(d_capacity * sizeof *d_valueArray_p));
//  }
//..
// Note that in the destructor, all outstanding memory blocks are deallocated
// automatically when &#39;d_pool&#39; is destroyed:
//..
//  my_IntDoubleArray::~my_IntDoubleArray()
//  {
//      assert(0 &lt;= d_length);
//      assert(0 &lt;= d_capacity);
//      assert(d_length &lt;= d_capacity);
//  }
//
//  // MANIPULATORS
//  void my_IntDoubleArray::appendInt(int value)
//  {
//      if (d_length &gt;= d_capacity) {
//          increaseSize();
//      }
//
//      int *item = static_cast&lt;int *&gt;(d_pool.allocate(sizeof *item));
//      *item = value;
//
//      d_typeArray_p[d_length]  = static_cast&lt;char&gt;(MY_INT);
//      d_valueArray_p[d_length] = item;
//
//      ++d_length;
//  }
//
//  void my_IntDoubleArray::appendDouble(double value)
//  {
//      if (d_length &gt;= d_capacity) {
//          increaseSize();
//      }
//
//      double *item = static_cast&lt;double *&gt;(d_pool.allocate(sizeof *item));
//      *item = value;
//
//      d_typeArray_p[d_length]  = static_cast&lt;char&gt;(MY_DOUBLE);
//      d_valueArray_p[d_length] = item;
//
//      ++d_length;
//  }
//..
///Example 2: Implementing an Allocator Using &#39;bdlma::SequentialPool&#39;
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// &#39;bslma::Allocator&#39; is used throughout the interfaces of BDE components.
// Suppose we would like to create a fast allocator, &#39;my_FastAllocator&#39;, that
// allocates memory from a buffer in a similar fashion to
// &#39;bdlma::SequentialPool&#39;.  &#39;bdlma::SequentialPool&#39; can be used directly to
// implement such an allocator.
//
// Note that the documentation for this class is simplified for this usage
// example.  Please see &#39;bdlma_sequentialallocator&#39; for full documentation of a
// similar class.
//..
//  class my_SequentialAllocator : public bslma::Allocator {
//      // This class implements the &#39;bslma::Allocator&#39; protocol to provide a
//      // fast allocator of heterogeneous blocks of memory (of varying,
//      // user-specified sizes) from dynamically-allocated internal buffers.
//
//      // DATA
//      bdlma::SequentialPool d_pool;  // memory manager for allocated memory
//                                     // blocks
//
//    public:
//      // CREATORS
//      explicit my_SequentialAllocator(bslma::Allocator *basicAllocator = 0);
//          // Create an allocator for allocating memory blocks from
//          // dynamically-allocated internal buffers.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      ~my_SequentialAllocator();
//          // Destroy this allocator.  All memory allocated from this
//          // allocator is released.
//
//      // MANIPULATORS
//      virtual void *allocate(size_type size);
//          // Return the address of a contiguous block of memory of the
//          // specified &#39;size&#39; (in bytes).
//
//      virtual void deallocate(void *address);
//          // This method has no effect on the memory block at the specified
//          // &#39;address&#39; as all memory allocated by this allocator is managed.
//          // The behavior is undefined unless &#39;address&#39; was allocated by this
//          // allocator, and has not already been deallocated.
//  };
//
//  // CREATORS
//  inline
//  my_SequentialAllocator::my_SequentialAllocator(
//                                            bslma::Allocator *basicAllocator)
//  : d_pool(basicAllocator)
//  {
//  }
//
//  inline
//  my_SequentialAllocator::~my_SequentialAllocator()
//  {
//      d_pool.release();
//  }
//
//  // MANIPULATORS
//  inline
//  void *my_SequentialAllocator::allocate(size_type size)
//  {
//      return d_pool.allocate(size);
//  }
//
//  inline
//  void my_SequentialAllocator::deallocate(void *)
//  {
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLMA_BUFFERMANAGER
#include &lt;bdlma_buffermanager.h&gt;
#endif

#ifndef INCLUDED_BDLMA_INFREQUENTDELETEBLOCKLIST
#include &lt;bdlma_infrequentdeleteblocklist.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENT
#include &lt;bsls_alignment.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_BLOCKGROWTH
#include &lt;bsls_blockgrowth.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;  // &#39;bsl::size_t&#39;
#endif

namespace BloombergLP {
namespace bdlma {

                        // ====================
                        // class SequentialPool
                        // ====================

class SequentialPool {
    // This class implements a fast memory pool that efficiently dispenses
    // heterogeneous blocks of memory (of varying, user-specified sizes) from
    // a sequence of dynamically-allocated internal buffers.  Memory for the
    // internal buffers is supplied by an (optional) allocator supplied
    // at construction; if no allocator is supplied, the currently installed
    // default allocator is used.  If an allocation exceeds the remaining
    // free memory space in the current buffer, the pool replenishes its
    // internal buffer with new memory to satisfy the request.  This class is
    // *exception* *neutral*: If memory cannot be allocated, the behavior is
    // defined by the (optional) allocator specified at construction.

    // DATA
    BufferManager       d_buffer;          // memory manager for current buffer

    bsls::BlockGrowth::Strategy
                        d_growthStrategy;  // growth strategy for block list

    int                 d_initialSize;     // initial internal buffer size

    int                 d_maxBufferSize;   // maximum internal buffer size

    InfrequentDeleteBlockList
                        d_blockList;       // memory manager used to supply
                                           // dynamically-allocated memory
                                           // blocks

  private:
    // NOT IMPLEMENTED
    SequentialPool(const SequentialPool&amp;);
    SequentialPool&amp; operator=(const SequentialPool&amp;);

  private:
    // PRIVATE ACCESSORS
    int calculateNextBufferSize(int size) const;
        // Return the next buffer size (in bytes) that is sufficiently large to
        // satisfy a memory allocation request of the specified &#39;size&#39; (in
        // bytes), or the maximum buffer size if the buffer can no longer grow.

  public:
    // CREATORS
    explicit
    SequentialPool(bslma::Allocator                *basicAllocator = 0);
    explicit
    SequentialPool(bsls::BlockGrowth::Strategy      growthStrategy,
                   bslma::Allocator                *basicAllocator = 0);
    explicit
    SequentialPool(bsls::Alignment::Strategy        alignmentStrategy,
                   bslma::Allocator                *basicAllocator = 0);
    SequentialPool(bsls::BlockGrowth::Strategy      growthStrategy,
                   bsls::Alignment::Strategy        alignmentStrategy,
                   bslma::Allocator                *basicAllocator = 0);
        // Create a sequential pool for allocating memory blocks from a
        // sequence of dynamically-allocated buffers.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory for the dynamically-allocated
        // buffers.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.  Optionally specify a &#39;growthStrategy&#39; used to
        // control buffer growth.  If no &#39;growthStrategy&#39; is specified,
        // geometric growth is used.  Optionally specify an &#39;alignmentStrategy&#39;
        // used to control alignment of allocated memory blocks.  If no
        // &#39;alignmentStrategy&#39; is specified, natural alignment is used.  An
        // implementation-defined value is used as the initial size of the
        // internal buffer.  Note that no limit is imposed on the size of the
        // internal buffers when geometric growth is used.  Also note that when
        // constant growth is used, the size of the internal buffers will
        // always be the same as the implementation-defined value.

    explicit
    SequentialPool(int                          initialSize,
                   bslma::Allocator            *basicAllocator = 0);
    SequentialPool(int                          initialSize,
                   bsls::BlockGrowth::Strategy  growthStrategy,
                   bslma::Allocator            *basicAllocator = 0);
    SequentialPool(int                          initialSize,
                   bsls::Alignment::Strategy    alignmentStrategy,
                   bslma::Allocator            *basicAllocator = 0);
    SequentialPool(int                          initialSize,
                   bsls::BlockGrowth::Strategy  growthStrategy,
                   bsls::Alignment::Strategy    alignmentStrategy,
                   bslma::Allocator            *basicAllocator = 0);
        // Create a sequential pool for allocating memory blocks from a
        // sequence of dynamically-allocated buffers, of which the initial
        // buffer has the specified &#39;initialSize&#39; (in bytes).  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory for the
        // dynamically-allocated buffers.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.  Optionally specify a
        // &#39;growthStrategy&#39; used to control buffer growth.  If no
        // &#39;growthStrategy&#39; is specified, geometric growth is used.  Optionally
        // specify an &#39;alignmentStrategy&#39; used to control alignment of
        // allocated memory blocks.  If no &#39;alignmentStrategy&#39; is specified,
        // natural alignment is used.  By specifying an &#39;initialSize&#39;, the
        // construction of a sequential pool will incur a memory allocation.
        // The behavior is undefined unless &#39;0 &lt; initialSize&#39;.  Note that no
        // limit is imposed on the size of the internal buffers when geometric
        // growth is used.  Also note that when constant growth is used, the
        // size of the internal buffers will always be the same as
        // &#39;initialSize&#39;.

    SequentialPool(int                          initialSize,
                   int                          maxBufferSize,
                   bslma::Allocator            *basicAllocator = 0);
    SequentialPool(int                          initialSize,
                   int                          maxBufferSize,
                   bsls::BlockGrowth::Strategy  growthStrategy,
                   bslma::Allocator            *basicAllocator = 0);
    SequentialPool(int                          initialSize,
                   int                          maxBufferSize,
                   bsls::Alignment::Strategy    alignmentStrategy,
                   bslma::Allocator            *basicAllocator = 0);
    SequentialPool(int                          initialSize,
                   int                          maxBufferSize,
                   bsls::BlockGrowth::Strategy  growthStrategy,
                   bsls::Alignment::Strategy    alignmentStrategy,
                   bslma::Allocator            *basicAllocator = 0);
        // Create a sequential pool for allocating memory blocks from a
        // sequence of dynamically-allocated buffers, of which the initial
        // buffer has the specified &#39;initialSize&#39; (in bytes), and the internal
        // buffer growth is limited to the specified &#39;maxBufferSize&#39;.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory for the
        // dynamically-allocated buffers.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.  Optionally specify a
        // &#39;growthStrategy&#39; used to control buffer growth.  If no
        // &#39;growthStrategy&#39; is specified, geometric growth is used.  Optionally
        // specify an &#39;alignmentStrategy&#39; used to control alignment of
        // allocated memory blocks.  If no &#39;alignmentStrategy&#39; is specified,
        // natural alignment is used.  The behavior is undefined unless
        // &#39;0 &lt; initialSize&#39; and &#39;initialSize &lt;= maxBufferSize&#39;.  Note that
        // when constant growth is used, the size of the internal buffers will
        // always be the same as &#39;initialSize&#39;.

    ~SequentialPool();
        // Destroy this sequential pool.  All memory allocated by this pool is
        // released.

    // MANIPULATORS
    void *allocate(bsls::Types::size_type size);
        // Return the address of a contiguous block of memory of the specified
        // &#39;size&#39; (in bytes) according to the alignment strategy specified at
        // construction.  If the allocation request exceeds the remaining
        // free memory space in the current internal buffer, use the allocator
        // supplied at construction to allocate a new internal buffer, then
        // allocate memory from the new buffer.  The behavior is undefined
        // unless &#39;0 &lt; size&#39;.

    void *allocateAndExpand(bsls::Types::size_type *size);
        // Return the address of a contiguous block of memory of at least the
        // specified &#39;*size&#39; (in bytes), and load the actual amount of memory
        // allocated in &#39;*size&#39;.  If the allocation request exceeds the
        // remaining free memory space in the current internal buffer, use the
        // allocator supplied at construction to allocate a new internal
        // buffer, then allocate memory from the new buffer.  The behavior is
        // undefined unless &#39;0 &lt; *size&#39;.

    template &lt;class TYPE&gt;
    void deleteObjectRaw(const TYPE *object);
        // Destroy the specified &#39;object&#39;.  Note that memory associated with
        // &#39;object&#39; is not deallocated because there is no &#39;deallocate&#39; method
        // in &#39;SequentialPool&#39;.

    template &lt;class TYPE&gt;
    void deleteObject(const TYPE *object);
        // Destroy the specified &#39;object&#39;.  Note that this method has the same
        // effect as the &#39;deleteObjectRaw&#39; method (since no deallocation is
        // involved), and exists for consistency across pools.

    void release();
        // Release all memory allocated through this pool.  The pool is reset
        // to its default-constructed state, retaining the alignment and
        // growth strategies, and the initial and maximum buffer sizes in
        // effect following construction.

    void reserveCapacity(int numBytes);
        // Reserve sufficient memory to satisfy allocation requests for at
        // least the specified &#39;numBytes&#39; without replenishment (i.e., without
        // dynamic allocation).  This method ignores &#39;maxBufferSize&#39; even if
        // it is supplied at construction.  The behavior is undefined unless
        // &#39;0 &lt; numBytes&#39;.  Note that, due to alignment effects, it is possible
        // that not all &#39;numBytes&#39; of memory will be used for allocation before
        // triggering dynamic allocation.

    int truncate(void *address, int originalSize, int newSize);
        // Reduce the amount of memory allocated at the specified &#39;address&#39;
        // of the specified &#39;originalSize&#39; (in bytes) to the specified
        // &#39;newSize&#39;.  Return &#39;newSize&#39; after truncating, or &#39;originalSize&#39; if
        // the memory block at &#39;address&#39; cannot be truncated.  This method can
        // only &#39;truncate&#39; the memory block returned by the most recent
        // &#39;allocate&#39; request from this memory pool, and otherwise has no
        // effect.  The behavior is undefined unless the memory at &#39;address&#39;
        // was originally allocated by this memory pool, the size of the memory
        // block at &#39;address&#39; is &#39;originalSize&#39;, &#39;newSize &lt;= originalSize&#39;,
        // &#39;0 &lt;= newSize&#39;, and &#39;release&#39; was not called after allocating the
        // memory block at &#39;address&#39;.
};

}  // close package namespace
}  // close enterprise namespace

// Note that the &#39;new&#39; and &#39;delete&#39; operators are declared outside the
// &#39;BloombergLP&#39; namespace so that they do not hide the standard placement
// &#39;new&#39; and &#39;delete&#39; operators (i.e.,
// &#39;void *operator new(bsl::size_t, void *)&#39; and
// &#39;void operator delete(void *)&#39;).
//
// Also note that only the scalar versions of operators &#39;new&#39; and &#39;delete&#39; are
// provided, because overloading &#39;new&#39; (and &#39;delete&#39;) with their array versions
// would cause dangerous ambiguity.  Consider what would have happened had we
// overloaded the array version of operator &#39;new&#39;:
//..
//   void *operator new[](bsl::size_t                         size,
//                        BloombergLP::bdlma::SequentialPool&amp; pool);
//..
// The user of the pool class would have expected to be able to use operator
// &#39;new&#39; as follows:
//..
//   new (*pool) my_Type[...];
//..
// The problem is that this expression returns an array that cannot be safely
// deallocated.  On the one hand, there is no syntax in C++ to invoke an
// overloaded &#39;operator delete&#39;; on the other hand, the pointer returned by
// operator &#39;new&#39; cannot be passed to the &#39;deallocate&#39; method directly
// because the pointer is different from the one returned by the &#39;allocate&#39;
// method.  The compiler offsets the value of this pointer by a header, which
// is used to maintain the number of objects in the array (so that the
// &#39;operator delete&#39; can destroy the right number of objects).

// FREE OPERATORS
void *operator new(bsl::size_t size, BloombergLP::bdlma::SequentialPool&amp; pool);
    // Return a block of memory of the specified &#39;size&#39; (in bytes) allocated
    // from the specified &#39;pool&#39;.  Note that an object may allocate additional
    // memory internally, requiring the allocator to be passed in as a
    // constructor argument:
    //..
    //  my_Type *newMyType(bdlma::SequentialPool *pool,
    //                     bslma::Allocator      *basicAllocator)
    //  {
    //      return new (*pool) my_Type(..., basicAllocator);
    //  }
    //..
    // Also note that the analogous version of operator &#39;delete&#39; should not be
    // called directly.  Instead, this component provides a static template
    // member function, &#39;deleteObject&#39;, parameterized by &#39;TYPE&#39; that performs
    // the following:
    //..
    //  void deleteMyType(bdlma::SequentialPool *pool, my_Type *t)
    //  {
    //      t-&gt;~my_Type();
    //  }
    //..

void operator delete(void *address, BloombergLP::bdlma::SequentialPool&amp; pool);
    // Use the specified &#39;pool&#39; to deallocate the memory at the specified
    // &#39;address&#39;.  The behavior is undefined unless &#39;address&#39; was allocated
    // using &#39;pool&#39; and has not already been deallocated.  This operator is
    // supplied solely to allow the compiler to arrange for it to be called in
    // case of an exception.

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

namespace BloombergLP {
namespace bdlma {

                        // --------------------
                        // class SequentialPool
                        // --------------------

// CREATORS
inline
SequentialPool::~SequentialPool()
{
    d_blockList.release();
}

// MANIPULATORS
template &lt;class TYPE&gt;
inline
void SequentialPool::deleteObjectRaw(const TYPE *object)
{
    if (0 != object) {
#ifndef BSLS_PLATFORM_CMP_SUN
        object-&gt;~TYPE();
#else
        const_cast&lt;TYPE *&gt;(object)-&gt;~TYPE();
#endif
    }
}

template &lt;class TYPE&gt;
inline
void SequentialPool::deleteObject(const TYPE *object)
{
    deleteObjectRaw(object);
}

inline
void SequentialPool::release()
{
    // &#39;BufferManager::release&#39; keeps the buffer and just resets the internal
    // cursor, so &#39;reset&#39; is used instead.

    d_buffer.reset();

    d_blockList.release();
}

inline
int SequentialPool::truncate(void *address, int originalSize, int newSize)
{
    BSLS_ASSERT_SAFE(address);
    BSLS_ASSERT_SAFE(0 &lt;= newSize);
    BSLS_ASSERT_SAFE(newSize &lt;= originalSize);

    return d_buffer.truncate(address, originalSize, newSize);
}

}  // close package namespace
}  // close enterprise namespace

// FREE OPERATORS
inline
void *operator new(bsl::size_t size, BloombergLP::bdlma::SequentialPool&amp; pool)
{
    return pool.allocate(size);
}

inline
void operator delete(void *, BloombergLP::bdlma::SequentialPool&amp;)
{
    // NOTE: there is no deallocation from this allocation mechanism.
}

#endif

// ----------------------------------------------------------------------------
// Copyright 2012 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
