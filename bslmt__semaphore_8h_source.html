<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmt_semaphore.h                                                  -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BSLMT_SEMAPHORE
#define INCLUDED_BSLMT_SEMAPHORE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a semaphore class.
//
//@CLASSES:
//  bslmt::Semaphore: semaphore class
//
//@SEE_ALSO: bslmt_timedsemaphore
//
//@DESCRIPTION: This component defines a portable and efficient thread
// synchronization primitive.  In particular, &#39;bslmt::Semaphore&#39; is an
// efficient synchronization primitive that enables sharing of a counted number
// of resources or exclusive access.  The usage model of this facility is
// modeled on POSIX semaphores and Windows semaphores.
//
///Usage
///-----
// This example illustrates a very simple queue where potential clients can
// push integers to a queue, and later retrieve the integer values from the
// queue in FIFO order.  It illustrates two potential uses of semaphores: to
// enforce exclusive access, and to allow resource sharing.
//..
//  class IntQueue {
//      // FIFO queue of integer values.
//
//      // DATA
//      bsl::deque&lt;int&gt; d_queue;        // underlying queue
//      bslmt::Semaphore d_mutexSem;     // mutual-access semaphore
//      bslmt::Semaphore d_resourceSem;  // resource-availability semaphore
//
//      // NOT IMPLEMENTED
//      IntQueue(const IntQueue&amp;);
//      IntQueue&amp; operator=(const IntQueue&amp;);
//
//    public:
//      // CREATORS
//      explicit IntQueue(bslma::Allocator *basicAllocator = 0);
//          // Create an &#39;IntQueue&#39; object.  Optionally specified a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      ~IntQueue();
//          // Destroy this &#39;IntQueue&#39; object.
//
//      // MANIPULATORS
//      int getInt();
//          // Retrieve an integer from this &#39;IntQueue&#39; object.  Integer values
//          // are obtained from the queue in FIFO order.
//
//      void pushInt(int value);
//          // Push the specified &#39;value&#39; to this &#39;IntQueue&#39; object.
//  };
//..
// Note that the &#39;IntQueue&#39; constructor increments the count of the semaphore
// to 1 so that values can be pushed into the queue immediately following
// construction:
//..
//  // CREATORS
//  IntQueue::IntQueue(bslma::Allocator *basicAllocator)
//  : d_queue(basicAllocator)
//  {
//      d_mutexSem.post();
//  }
//
//  IntQueue::~IntQueue()
//  {
//      d_mutexSem.wait();  // Wait for potential modifier.
//  }
//
//  // MANIPULATORS
//  int IntQueue::getInt()
//  {
//      // Waiting for resources.
//      d_resourceSem.wait();
//
//      // &#39;d_mutexSem&#39; is used for exclusive access.
//      d_mutexSem.wait();        // lock
//      const int ret = d_queue.back();
//      d_queue.pop_back();
//      d_mutexSem.post();        // unlock
//
//      return ret;
//  }
//
//  void IntQueue::pushInt(int value)
//  {
//      d_mutexSem.wait();
//      d_queue.push_front(value);
//      d_mutexSem.post();
//
//      d_resourceSem.post();  // Signal we have resources available.
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMT_SEMAPHOREIMPL_COUNTED
#include &lt;bslmt_semaphoreimpl_counted.h&gt;
#endif

#ifndef INCLUDED_BSLMT_SEMAPHOREIMPL_PTHREAD
#include &lt;bslmt_semaphoreimpl_pthread.h&gt;
#endif

#ifndef INCLUDED_BSLMT_SEMAPHOREIMPL_WIN32
#include &lt;bslmt_semaphoreimpl_win32.h&gt;
#endif

#ifndef INCLUDED_BSLMT_PLATFORM
#include &lt;bslmt_platform.h&gt;
#endif

namespace BloombergLP {
namespace bslmt {

template &lt;class SEMAPHORE_POLICY&gt;
class SemaphoreImpl;

                             // ===============
                             // class Semaphore
                             // ===============

class Semaphore {
    // This class implements a portable semaphore type for thread
    // synchronization.  It forwards all requests to an appropriate
    // platform-specific implementation.

    // DATA
    SemaphoreImpl&lt;Platform::SemaphorePolicy&gt; d_impl;  // platform-specific
                                                      // implementation

    // NOT IMPLEMENTED
    Semaphore(const Semaphore&amp;);
    Semaphore&amp; operator=(const Semaphore&amp;);

  public:
    // CREATORS
    Semaphore();
        // Create a semaphore initially having a count of 0.

    explicit
    Semaphore(int count);
        // Create a semaphore initially having the specified &#39;count&#39;.

    ~Semaphore();
        // Destroy this semaphore.

    // MANIPULATORS
    void post();
        // Atomically increment the count of this semaphore.

    void post(int value);
        // Atomically increase the count of this semaphore by the specified
        // &#39;value&#39;.  The behavior is undefined unless &#39;value &gt; 0&#39;.

    int tryWait();
        // If the count of this semaphore is positive, atomically decrement the
        // count and return 0; otherwise, return a non-zero value with no
        // effect on the count.

    void wait();
        // Block until the count of this semaphore is a positive value, then
        // atomically decrement the count and return.

    // ACCESSORS
    int getValue() const;
        // Return the value of the current count of this semaphore.
};

}  // close package namespace

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

                             // ---------------
                             // class Semaphore
                             // ---------------

// CREATORS
inline
bslmt::Semaphore::Semaphore()
: d_impl(0)
{
}

inline
bslmt::Semaphore::Semaphore(int count)
: d_impl(count)
{
}

inline
bslmt::Semaphore::~Semaphore()
{
}

inline
void bslmt::Semaphore::post()
{
    d_impl.post();
}

inline
void bslmt::Semaphore::post(int value)
{
    d_impl.post(value);
}

inline
int bslmt::Semaphore::tryWait()
{
    return d_impl.tryWait();
}

inline
void bslmt::Semaphore::wait()
{
    d_impl.wait();
}

// ACCESSORS
inline
int bslmt::Semaphore::getValue() const
{
    return d_impl.getValue();
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
