<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlmt::TimerEventScheduler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlmt.html">bdlmt</a>      </li>
      <li><a class="el" href="classbdlmt_1_1TimerEventScheduler.html">bdlmt::TimerEventScheduler</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bdlmt::TimerEventScheduler Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlmt::TimerEventScheduler" -->
<p><code>#include &lt;<a class="el" href="bdlmt__timereventscheduler_8h_source.html">bdlmt_timereventscheduler.h</a>&gt;</code></p>

<p><a href="classbdlmt_1_1TimerEventScheduler-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ClockData</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a3fa1404788ae8acbdae06607b39c9370a74de58efaf4a23d94626ddfaaf5d87e5">e_INVALID_HANDLE</a> =  -1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
bsl::function&lt; void()&gt; &amp;)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a><br class="typebreak"/>
&lt; bsl::function&lt; void()&gt;<br class="typebreak"/>
 &gt;::Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a0bcc942c1fa25c1a2f414852ff076e9a">EventKey</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a6ef1f3870909a0e46a8a7a23f2ce1e6b">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlmt_1_1TimerEventScheduler.html">TimerEventScheduler</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#ac64a9b30124cb808d777283da474ed7c">TimerEventScheduler</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a1810ad8315ec5eaa137cea951ffd1953">TimerEventScheduler</a> (<a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a> clockType, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#acce7ae280dbe47a6630e1bf11f61881e">TimerEventScheduler</a> (const <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a> &amp;dispatcherFunctor, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#ad44e473972e828ef02297cd07cd668f9">TimerEventScheduler</a> (const <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a> &amp;dispatcherFunctor, <a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a> clockType, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a661cf2f3972e97554ee4bc52d75fe87e">TimerEventScheduler</a> (int numEvents, int numClocks, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#af5e8513c1d9d3e63ab85617502b46c47">TimerEventScheduler</a> (int numEvents, int numClocks, <a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a> clockType, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a2c345a1f65414f0a474f99284b23251e">TimerEventScheduler</a> (int numEvents, int numClocks, const <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a> &amp;dispatcherFunctor, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a220913445ab2e7271eb463dec4dd12c8">TimerEventScheduler</a> (int numEvents, int numClocks, const <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a> &amp;dispatcherFunctor, <a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a> clockType, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#ab2be67f1e8493cb9ce40704d9ccf6dd7">~TimerEventScheduler</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a09ee79ad3449aa2be2c2fd8bb2fdb741">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#ae630bfce9fad021e5637d9434ddc90a2">start</a> (const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;threadAttributes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a665c1873e2192593fa56f5e9194bcdf7">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a9721242045a8c7db79df4ce3830aeb17">scheduleEvent</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;time, const bsl::function&lt; void()&gt; &amp;callback, const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">EventKey</a> &amp;key=<a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">EventKey</a>(0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a0a3ebc304bbd7f2069cee55ab5d131bd">rescheduleEvent</a> (<a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a> handle, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;newTime, bool wait=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a8d390290e9563e19ddfa4e6f9d110192">rescheduleEvent</a> (<a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a> handle, const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">EventKey</a> &amp;key, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;newTime, bool wait=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#ae8963f70ed5626081d7bd6546c8ebcaf">cancelEvent</a> (<a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a> handle, bool wait=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#ad8a563ad8f25de65141a40481569d459">cancelEvent</a> (<a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a> handle, const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">EventKey</a> &amp;key, bool wait=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a830fb5a510c0e22d76bfccba390d3917">cancelAllEvents</a> (bool wait=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a66dacc7808e906edd79f9087afc97d59">startClock</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, const bsl::function&lt; void()&gt; &amp;callback, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;startTime=<a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#adb0376a0b0123f54328339c9aea0ddc7">cancelClock</a> (<a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a> handle, bool wait=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a3cfb6059b287f1ebc1b40aadd73220cb">cancelAllClocks</a> (bool wait=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#ad367132660443e360b392f8bc69b893f">numClocks</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aba39879251646edfc5e692c5d1cabbbb">numEvents</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#ae9836678e9415dba2a04c1b37af3e9fa">TimerEventSchedulerDispatcher</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a thread-safe event scheduler. <code>scheduleEvent</code> schedules a non-recurring event, returning a handle of type <code><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">TimerEventScheduler::Handle</a></code>, which can be used to cancel the scheduled event by invoking <code>cancelEvent</code>. Similarly, <code>startClock</code> schedules a recurring event, returning a handle of type <code><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">TimerEventScheduler::Handle</a></code>, which can be used to cancel the clock by invoking <code>cancelClock</code>. <code>cancelAllEvents</code> cancels all the registered events and <code>cancelAllClocks</code> cancels all the registered clocks. The callbacks are processed by a separate thread (called dispatcher thread). By default the callbacks are executed in the dispatcher thread, but this behavior can be altered by providing a dispatcher functor at the creation time (see the section "The dispatcher thread and the dispatcher
     functor"). <code>start</code> must be invoked to start dispatching the callbacks. <code>stop</code> stops the dispatching of the callbacks without removing the pending events. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a04b1746361f1ab08e3b03c373e6d05de"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::Handle" ref="a04b1746361f1ab08e3b03c373e6d05de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">bdlmt::TimerEventScheduler::Handle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa6bb0800df47a7eccfd06dc238b681a1"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::Dispatcher" ref="aa6bb0800df47a7eccfd06dc238b681a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const bsl::function&lt;void()&gt;&amp;)&gt; <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">bdlmt::TimerEventScheduler::Dispatcher</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a type alias for the dispatcher functor type. </p>

</div>
</div>
<a class="anchor" id="a0bcc942c1fa25c1a2f414852ff076e9a"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::EventKey" ref="a0bcc942c1fa25c1a2f414852ff076e9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt;bsl::function&lt;void()&gt; &gt;::Key <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">bdlmt::TimerEventScheduler::EventKey</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a type alias for a user-supplied key for identifying events. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a3fa1404788ae8acbdae06607b39c9370"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::@217" ref="a3fa1404788ae8acbdae06607b39c9370" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3fa1404788ae8acbdae06607b39c9370a74de58efaf4a23d94626ddfaaf5d87e5"></a><!-- doxytag: member="e_INVALID_HANDLE" ref="a3fa1404788ae8acbdae06607b39c9370a74de58efaf4a23d94626ddfaaf5d87e5" args="" -->e_INVALID_HANDLE</em>&nbsp;</td><td>
<p>value of an invalid event or clock handle </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac64a9b30124cb808d777283da474ed7c"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventScheduler" ref="ac64a9b30124cb808d777283da474ed7c" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::TimerEventScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an event scheduler using the default dispatcher functor (see the "The dispatcher thread and the dispatcher functor" section in component-level doc) and use the realtime clock epoch for all time intervals (see <a href="group__bdlmt__timereventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a1810ad8315ec5eaa137cea951ffd1953"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventScheduler" ref="a1810ad8315ec5eaa137cea951ffd1953" args="(bsls::SystemClockType::Enum clockType, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::TimerEventScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>clockType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an event scheduler using the default dispatcher functor (see the "The dispatcher thread and the dispatcher functor" section in component-level doc) and use the specified <code>clockType</code> to indicate the epoch used for all time intervals (see <a href="group__bdlmt__timereventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="acce7ae280dbe47a6630e1bf11f61881e"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventScheduler" ref="acce7ae280dbe47a6630e1bf11f61881e" args="(const Dispatcher &amp;dispatcherFunctor, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::TimerEventScheduler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatcherFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an event scheduler using the specified <code>dispatcherFunctor</code> (see "The dispatcher thread and the dispatcher functor" section in component-level doc) and use the realtime clock epoch for all time intervals (see <a href="group__bdlmt__timereventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="ad44e473972e828ef02297cd07cd668f9"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventScheduler" ref="ad44e473972e828ef02297cd07cd668f9" args="(const Dispatcher &amp;dispatcherFunctor, bsls::SystemClockType::Enum clockType, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::TimerEventScheduler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatcherFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>clockType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an event scheduler using the specified <code>dispatcherFunctor</code> (see "The dispatcher thread and the dispatcher functor" section in component-level doc) and use the specified <code>clockType</code> to indicate the epoch used for all time intervals (see <a href="group__bdlmt__timereventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a661cf2f3972e97554ee4bc52d75fe87e"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventScheduler" ref="a661cf2f3972e97554ee4bc52d75fe87e" args="(int numEvents, int numClocks, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::TimerEventScheduler </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numClocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a timer event scheduler using the default dispatcher functor (see the "The dispatcher thread and the dispatcher functor" section in component level doc) that has the capability to concurrently schedule <em>at</em> <em>least</em> the specified <code>numEvents</code> and <code>numClocks</code> and use the realtime clock epoch for all time intervals (see <a href="group__bdlmt__timereventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt;= numEvents &lt; 2**24</code> and <code>0 &lt;= numClocks &lt; 2**24</code>. </p>

</div>
</div>
<a class="anchor" id="af5e8513c1d9d3e63ab85617502b46c47"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventScheduler" ref="af5e8513c1d9d3e63ab85617502b46c47" args="(int numEvents, int numClocks, bsls::SystemClockType::Enum clockType, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::TimerEventScheduler </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numClocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>clockType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a timer event scheduler using the default dispatcher functor (see the "The dispatcher thread and the dispatcher functor" section in component level doc) that has the capability to concurrently schedule <em>at</em> <em>least</em> the specified <code>numEvents</code> and <code>numClocks</code> and use the specified <code>clockType</code> to indicate the epoch used for all time intervals (see <a href="group__bdlmt__timereventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt;= numEvents &lt; 2**24</code> and <code>0 &lt;= numClocks &lt; 2**24</code>. </p>

</div>
</div>
<a class="anchor" id="a2c345a1f65414f0a474f99284b23251e"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventScheduler" ref="a2c345a1f65414f0a474f99284b23251e" args="(int numEvents, int numClocks, const Dispatcher &amp;dispatcherFunctor, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::TimerEventScheduler </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numClocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatcherFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a timer event scheduler using the specified <code>dispatcherFunctor</code> (see "The dispatcher thread and the dispatcher
         functor" section in component level doc) that has the capability to concurrently schedule <em>at</em> <em>least</em> the specified <code>numEvents</code> and <code>numClocks</code> and use the realtime clock epoch for all time intervals (see <a href="group__bdlmt__timereventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt;= numEvents &lt; 2**24</code> and <code>0 &lt;= numClocks &lt; 2**24</code>. </p>

</div>
</div>
<a class="anchor" id="a220913445ab2e7271eb463dec4dd12c8"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventScheduler" ref="a220913445ab2e7271eb463dec4dd12c8" args="(int numEvents, int numClocks, const Dispatcher &amp;dispatcherFunctor, bsls::SystemClockType::Enum clockType, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::TimerEventScheduler </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numClocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1TimerEventScheduler.html#aa6bb0800df47a7eccfd06dc238b681a1">Dispatcher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatcherFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>clockType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a timer event scheduler using the specified <code>dispatcherFunctor</code> (see "The dispatcher thread and the dispatcher
         functor" section in component level doc) that has the capability to concurrently schedule <em>at</em> <em>least</em> the specified <code>numEvents</code> and <code>numClocks</code> and use the specified <code>clockType</code> to indicate the epoch used for all time intervals (see <a href="group__bdlmt__timereventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt;= numEvents &lt; 2**24</code> and <code>0 &lt;= numClocks &lt; 2**24</code>. </p>

</div>
</div>
<a class="anchor" id="ab2be67f1e8493cb9ce40704d9ccf6dd7"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::~TimerEventScheduler" ref="ab2be67f1e8493cb9ce40704d9ccf6dd7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::~TimerEventScheduler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop this scheduler, discard all the unprocessed events and destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6ef1f3870909a0e46a8a7a23f2ce1e6b"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::BSLALG_DECLARE_NESTED_TRAITS" ref="a6ef1f3870909a0e46a8a7a23f2ce1e6b" args="(TimerEventScheduler, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::TimerEventScheduler::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html">TimerEventScheduler</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a09ee79ad3449aa2be2c2fd8bb2fdb741"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::start" ref="a09ee79ad3449aa2be2c2fd8bb2fdb741" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start dispatching events on this scheduler. The dispatcher thread will have default attributes. Return 0 on success, and a non-zero result otherwise. If this scheduler has already started then this invocation has no effect and 0 is returned. This scheduler can be stopped by invoking <code>stop</code>. Note that any event whose time has already passed is pending and will be dispatched immediately. </p>

</div>
</div>
<a class="anchor" id="ae630bfce9fad021e5637d9434ddc90a2"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::start" ref="ae630bfce9fad021e5637d9434ddc90a2" args="(const bslmt::ThreadAttributes &amp;threadAttributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threadAttributes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start dispatching events on this scheduler, using the specified <code>threadAttributes</code> for the dispatcher thread, except the DETACHED attribute will always be overridden to be joinable. Return 0 on success, and a non-zero result otherwise. If this scheduler has already started then this invocation has no effect and 0 is returned. This scheduler can be stopped by invoking <code>stop</code>. Note that any event whose time has already passed is pending and will be dispatched immediately. </p>

</div>
</div>
<a class="anchor" id="a665c1873e2192593fa56f5e9194bcdf7"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::stop" ref="a665c1873e2192593fa56f5e9194bcdf7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::TimerEventScheduler::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop dispatching events on this scheduler, but do not remove any pending event. Block until all pending jobs are finished, then terminate the dispatcher thread and return. If this scheduler is already stopped then this invocation has no effect. The behavior is undefined if this function is called by a job enqueued to the scheduler that is to be stopped. This scheduler can be restarted by invoking <code>start</code>. </p>

</div>
</div>
<a class="anchor" id="a9721242045a8c7db79df4ce3830aeb17"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::scheduleEvent" ref="a9721242045a8c7db79df4ce3830aeb17" args="(const bsls::TimeInterval &amp;time, const bsl::function&lt; void()&gt; &amp;callback, const EventKey &amp;key=EventKey(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a> bdlmt::TimerEventScheduler::scheduleEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">EventKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em> = <code><a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">EventKey</a>(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedule the specified <code>callback</code> to be dispatched at the specified <code>time</code> and return a handle that can be used to cancel the <code>callback</code> (by invoking <code>cancelEvent</code>). Optionally specify <code>key</code> to uniquely identify the event. The <code>time</code> is an absolute time represented as an interval from some epoch, which is detemined by the clock indicated at construction (see <a href="group__Supported Clock-Types.html" class="el"><code>Supported Clock-Types</code></a> in the component documentation). </p>

</div>
</div>
<a class="anchor" id="a0a3ebc304bbd7f2069cee55ab5d131bd"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::rescheduleEvent" ref="a0a3ebc304bbd7f2069cee55ab5d131bd" args="(Handle handle, const bsls::TimeInterval &amp;newTime, bool wait=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::rescheduleEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8d390290e9563e19ddfa4e6f9d110192"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::rescheduleEvent" ref="a8d390290e9563e19ddfa4e6f9d110192" args="(Handle handle, const EventKey &amp;key, const bsls::TimeInterval &amp;newTime, bool wait=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::rescheduleEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">EventKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8963f70ed5626081d7bd6546c8ebcaf"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::cancelEvent" ref="ae8963f70ed5626081d7bd6546c8ebcaf" args="(Handle handle, bool wait=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::cancelEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8a563ad8f25de65141a40481569d459"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::cancelEvent" ref="ad8a563ad8f25de65141a40481569d459" args="(Handle handle, const EventKey &amp;key, bool wait=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::cancelEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">EventKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the event having the specified <code>handle</code>. Optionally use the specified <code>key</code> to uniquely identify the event. If the optionally specified <code>wait</code> is true, then ensure that the dispatcher thread has resumed execution before returning. Return 0 on successful cancellation, and a non-zero value if the <code>handle</code> is invalid <em>or</em> if it is too late to cancel the event. If this method is being invoked from the dispatcher thread then the <code>wait</code> is ignored to avoid deadlock. </p>

</div>
</div>
<a class="anchor" id="a830fb5a510c0e22d76bfccba390d3917"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::cancelAllEvents" ref="a830fb5a510c0e22d76bfccba390d3917" args="(bool wait=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::TimerEventScheduler::cancelAllEvents </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel all the events. If the optionally specified <code>wait</code> is true, then ensure any event still in this scheduler is either cancelled or has been dispatched before this call returns. If this method is being invoked from the dispatcher thread then the <code>wait</code> is ignored to avoid deadlock. </p>

</div>
</div>
<a class="anchor" id="a66dacc7808e906edd79f9087afc97d59"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::startClock" ref="a66dacc7808e906edd79f9087afc97d59" args="(const bsls::TimeInterval &amp;interval, const bsl::function&lt; void()&gt; &amp;callback, const bsls::TimeInterval &amp;startTime=bsls::TimeInterval(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a> bdlmt::TimerEventScheduler::startClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>startTime</em> = <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedule a recurring event that invokes the specified <code>callback</code> at every specified <code>interval</code>, starting at the optionally specified <code>startTime</code>. Return an identifier that can be use to cancel the clock (by invoking <code>cancelClock</code>). If no start time is specified, it is assumed to be the <code>interval</code> time from now. The <code>startTime</code> is an absolute time represented as an interval from some epoch, which is detemined by the clock indicated at construction (see <a href="group__Supported Clock-Types.html" class="el"><code>Supported Clock-Types</code></a> in the component documentation). </p>

</div>
</div>
<a class="anchor" id="adb0376a0b0123f54328339c9aea0ddc7"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::cancelClock" ref="adb0376a0b0123f54328339c9aea0ddc7" args="(Handle handle, bool wait=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::cancelClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the clock having the specified <code>handle</code>. If the optionally specified <code>wait</code> is true, then ensure that any scheduled event for the clock having <code>handle</code> is either cancelled or has been dispatched before this call returns. Return 0 on success, and a non-zero value if the <code>handle</code> is invalid. If this method is being invoked from the dispatcher thread, then the <code>wait</code> is ignored to avoid deadlock. </p>

</div>
</div>
<a class="anchor" id="a3cfb6059b287f1ebc1b40aadd73220cb"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::cancelAllClocks" ref="a3cfb6059b287f1ebc1b40aadd73220cb" args="(bool wait=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::TimerEventScheduler::cancelAllClocks </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wait</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel all clocks. If the optionally specified <code>wait</code> is true, then ensure that any clock event still in this scheduler is either cancelled or has been dispatched before this call returns. If this method is being invoked from the dispatcher thread, then the <code>wait</code> is ignored to avoid deadlock. </p>

</div>
</div>
<a class="anchor" id="ad367132660443e360b392f8bc69b893f"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::numClocks" ref="ad367132660443e360b392f8bc69b893f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::numClocks </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <em>snapshot</em> of the number of registered clocks with this scheduler. </p>

</div>
</div>
<a class="anchor" id="aba39879251646edfc5e692c5d1cabbbb"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::numEvents" ref="aba39879251646edfc5e692c5d1cabbbb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::TimerEventScheduler::numEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <em>snapshot</em> of the number of pending events and events being dispatched in this scheduler. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ae9836678e9415dba2a04c1b37af3e9fa"></a><!-- doxytag: member="bdlmt::TimerEventScheduler::TimerEventSchedulerDispatcher" ref="ae9836678e9415dba2a04c1b37af3e9fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend struct TimerEventSchedulerDispatcher<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlmt__timereventscheduler_8h_source.html">bdlmt_timereventscheduler.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
