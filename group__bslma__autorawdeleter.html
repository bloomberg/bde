<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslma_autorawdeleter Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_autorawdeleter<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a range proctor to manage a sequence objects.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">"Raw" Warning</a> </li>
<li>
<a href="#3.2">Requirement</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a range proctor to manage a sequence objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a> </td><td>range proctor to manage a sequence of objects  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__rawdeleterproctor.html" title="Provide a proctor to conditionally manage an object.">Component bslma_rawdeleterproctor</a>, <a class="el" href="group__bslma__rawdeleterguard.html" title="Provide a guard to unconditionally manage an object.">Component bslma_rawdeleterguard</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a range proctor class template to manage a sequence of (otherwise-unmanaged) objects of parameterized <code>TYPE</code> supplied at construction. If not explicitly released, the sequence of managed objects are deleted automatically when the range proctor goes out of scope by iterating over each object, first calling the (managed) object's destructor, and then freeing its memory footprint by invoking the <code>deallocate</code> method of an allocator (or pool) of parameterized <code>ALLOCATOR</code> type also supplied at construction. Note that after a range proctor releases its sequence of managed objects, the same proctor can be reused to conditionally manage another sequence of objects (allocated from the same allocator or pool that was supplied at construction) by invoking the <code>reset</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="~22raw~22_warning"></a> <a class="anchor" id="description.~22raw~22_warning"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Raw</b></dt><dd>Warning:  </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that this component should be used only if we are sure that the supplied pointer is <b>not</b> of a type that is a secondary base class -- i.e., the (managed) object's address is (numerically) the same as when it was originally dispensed by <code>ALLOCATOR</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirement"></a> <a class="anchor" id="description.requirement"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Requirement: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The parameterized <code>ALLOCATOR</code> type of the <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code> class template must provide a (possibly <code>virtual</code>) method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
</pre></div><br/>
<br/>
 to deallocate memory at the specified <code>address</code> (originally supplied by the <code>ALLOCATOR</code> object). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code> proctor object can be used to preserve exception neutrality during manipulation of out-of-place arrays of user-defined-type objects. The following illustrates the insertion operation for an "out-of-place" string array. Assume that a string array initially contains the addresses of the following string objects as its elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">     0     1     2     3     4
   _____ _____ _____ _____ _____
  |  o  |  o  |  o  |  o  |  o  |
  `==|==^==|==^==|==^==|==^==|==<span class="stringliteral">&#39;</span>
<span class="stringliteral">    _V_   _V_   _V_   _V_   _V_</span>
<span class="stringliteral">   |&quot;A&quot;| |&quot;B&quot;| |&quot;C&quot;| |&quot;D&quot;| |&quot;E&quot;|</span>
<span class="stringliteral">   `===&#39;</span> `===<span class="stringliteral">&#39; `===&#39;</span> `===<span class="stringliteral">&#39; `===&#39;</span>
</pre></div><br/>
<br/>
 To insert two string objects with values "F" and "G" at index position 2, the array is first reallocated if it is not big enough, and then the existing elements at index positions 2, 3, and 4 are shifted: <br/>
<br/>
<div class="fragment"><pre class="fragment">     0     1     2     3     4     5     6
   _____ _____ _____ _____ _____ _____ _____
  |  o  |  o  |xxxxx|xxxxx|  o  |  o  |  o  |
  `==|==^==|==^=====^=====^==|==^==|==^==|==<span class="stringliteral">&#39;</span>
<span class="stringliteral">    _V_   _V_               _V_   _V_   _V_</span>
<span class="stringliteral">   |&quot;A&quot;| |&quot;B&quot;|             |&quot;C&quot;| |&quot;D&quot;| |&quot;E&quot;|</span>
<span class="stringliteral">   `===&#39;</span> `===<span class="stringliteral">&#39;             `===&#39;</span> `===<span class="stringliteral">&#39; `===&#39;</span>

  Note: <span class="stringliteral">&quot;xxxxx&quot;</span> denotes undefined value
</pre></div><br/>
<br/>
 Next, two new string objects must be created and initialized with string values "F" and "G", respectively. If, during creation, an allocation fails and an exception is thrown, the array will be left in an invalid state because the addresses contained at index positions 2 and 3 may be duplicates of those at index positions 4 and 5, or, if a resize occurred, invalid altogether. We can restore exception neutrality by setting the array's length to 2 before attempting to create the string objects, but there is still a problem: the string objects "C", "D", and "E" (at index positions 3, 4, and 5) are "orphaned" and will never be deleted -- a memory leak. To prevent this potential memory leak, we can additionally create a <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code> object to manage (temporarily) the elements at index positions 4, 5, and 6 prior to creating the new objects: <br/>
<br/>
<div class="fragment"><pre class="fragment">      0     1     2     3     4     5     6
    _____ _____ _____ _____ _____ _____ _____
   |  o  |  o  |xxxxx|xxxxx|  o  |  o  |  o  |
   `==|==^==|==^=====^=====^==|==^==|==^==|==<span class="stringliteral">&#39;</span>
<span class="stringliteral">     _V_   _V_               _V_   _V_   _V_</span>
<span class="stringliteral">    |&quot;A&quot;| |&quot;B&quot;|             |&quot;C&quot;| |&quot;D&quot;| |&quot;E&quot;|</span>
<span class="stringliteral">    `===&#39;</span> `===<span class="stringliteral">&#39;             `===&#39;</span> `===<span class="stringliteral">&#39; `===&#39;</span>
    my_StrArray2           ^-----------------<a class="code" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>
    (length = 2)                             (length = 3)

  Figure: Use of proctor <span class="keywordflow">for</span> my_StrArray2::insert
</pre></div><br/>
<br/>
 If an exception occurs, the array (now of length 2) is in a perfectly valid state, while the second proctor is responsible for deleting the orphaned elements at index positions 4, 5, and 6. If no exception is thrown, the elements at index positions 2 and 3 are set to new strings "F" and "G", the length of the first proctor is set to 7 and the second proctor's <code>release</code> method is called, releasing its control over the temporarily managed elements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates the use of <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code> in conjunction with <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code> to manage temporarily a templatized, "out-of-place" array of parameterized <code>TYPE</code> objects during the array's insertion operation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we define a <code>myArray</code> class which stores an array of parameterized <code>TYPE</code> objects: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>myArray {
      <span class="comment">// This class is a container that stores an array of objects of</span>
      <span class="comment">// parameterized &#39;TYPE&#39;.</span>

      <span class="comment">// DATA</span>
      TYPE              **d_array_p;       <span class="comment">// dynamically allocated array of</span>
                                           <span class="comment">// character sequence</span>

      <span class="keywordtype">int</span>                 d_length;        <span class="comment">// logical length of this array</span>

      <span class="keywordtype">int</span>                 d_size;          <span class="comment">// physical capacity of this array</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *d_allocator_p;   <span class="comment">// allocator (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      myArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;myArray&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      ~myArray();
          <span class="comment">// Destroy this &#39;myArray&#39; object and all elements currently stored.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> insert(<span class="keywordtype">int</span> dstIndex, <span class="keyword">const</span> myArray&amp; srcArray);
          <span class="comment">// Insert into this array at the specified &#39;dstIndex&#39;, the</span>
          <span class="comment">// character sequences in the specified &#39;srcArray&#39;.  All values</span>
          <span class="comment">// with initial indices at or above &#39;dstIndex&#39; are shifted up by</span>
          <span class="comment">// &#39;srcArray.length()&#39; index positions.  The behavior is undefined</span>
          <span class="comment">// unless &#39;0 &lt;= dstIndex&#39; and &#39;dstIndex &lt;= length()&#39;.</span>

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> length() <span class="keyword">const</span>;
          <span class="comment">// Return the logical length of this array.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Note that a <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code> is used to manage a block of memory allocated before invoking the constructor of <code>TYPE</code>. If the constructor of <code>TYPE</code> throws, the (managed) memory is automatically deallocated by <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code>s destructor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> myArray&lt;TYPE&gt;::insert(<span class="keywordtype">int</span> dstIndex, <span class="keyword">const</span> myArray&lt;TYPE&gt;&amp; srcArray)
  {
      <span class="keywordtype">int</span> srcLength  = srcArray.d_length;
      <span class="keywordtype">int</span> newLength  = d_length + srcLength;
      <span class="keywordtype">int</span> numShifted = d_length - dstIndex;

      <span class="keywordflow">if</span> (newLength &gt; d_size) {  <span class="comment">// need to resize</span>
          <span class="comment">// ...</span>
      }

      <span class="comment">// First shift the elements to the back of the array.</span>
      memmove(d_array_p + dstIndex + srcLength,
              d_array_p + dstIndex,
              numShifted * <span class="keyword">sizeof</span> *d_array_p);

      <span class="comment">// Shorten &#39;d_length&#39; and use &#39;bslma::AutoDeleter&#39; to proctor tail</span>
      <span class="comment">// elements.</span>
      d_length = dstIndex;

      <span class="comment">//*************************************************************</span>
      <span class="comment">// Note the use of auto raw deleter on tail elements (below). *</span>
      <span class="comment">//*************************************************************</span>

      <a class="code" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter&lt;TYPE, bslma::Allocator&gt;</a>
                                tailDeleter(d_array_p + dstIndex + srcLength,
                                            d_allocator_p,
                                            numShifted);
</pre></div><br/>
<br/>
 Now, if any allocation, either allocating memory for new elements or the constructor of the new element throws, the elements that had been moved to the end of the array will be deleted automatically by the <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// Used to temporarily proctor each new element&#39;s memory.</span>
      <a class="code" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor&lt;bslma::Allocator&gt;</a>
                                        elementDeallocator(0, d_allocator_p);

      <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;srcArray) {  <span class="comment">// no self-alias</span>

          <span class="comment">// Copy the objects one by one.</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; srcLength; ++i, ++d_length) {
              d_array_p[dstIndex + i] =
                        (TYPE *) d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span> **d_array_p);

              elementDeallocator.reset(d_array_p[dstIndex + i]);
              <span class="keyword">new</span>(d_array_p[dstIndex + i]) TYPE(*srcArray.d_array_p[i],
                                                d_allocator_p);
              elementDeallocator.release();
          }
      }
      <span class="keywordflow">else</span> {  <span class="comment">// self-alias</span>
          <span class="comment">// ...</span>
      }

      <span class="comment">//*********************************************</span>
      <span class="comment">// Note that the proctor is released (below). *</span>
      <span class="comment">//*********************************************</span>

      tailDeleter.release();
      d_length = newLength;
  }
</pre></div><br/>
<br/>
 Note that portions of the implementation are elided as it adds unnecessary complications to the usage example. The shown portion is sufficient to illustrate the use of <code>bslma_autorawdeleter</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The above method copies the source elements (visually) from left to right. Another (functionally equivalent) implementation copies the source elements from right to left, and makes use of the <code><a class="el" href="namespacebdlc.html#ac907e5780fc6951e1d99a105b1218fcb">operator--()</a></code> of the <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code> interface: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> myArray&lt;TYPE&gt;::insert(<span class="keywordtype">int</span> dstIndex, <span class="keyword">const</span> myStrArray&lt;TYPE&gt;&amp; srcArray)
  {
      <span class="keywordtype">int</span> srcLength  = srcArray.d_length;
      <span class="keywordtype">int</span> newLength  = d_length + srcLength;
      <span class="keywordtype">int</span> numShifted = d_length - dstIndex;

      <span class="keywordflow">if</span> (newLength &gt; d_size) {  <span class="comment">// need to resize</span>
          <span class="comment">// ...</span>
      }

      <span class="comment">// First shift the elements to the back of the array.</span>
      memmove(d_array_p + dstIndex + srcLength,
              d_array_p + dstIndex,
              numShifted * <span class="keyword">sizeof</span> *d_array_p);

      <span class="comment">// Shorten &#39;d_length&#39; and use &#39;bslma::AutoDeallocator&#39; to proctor the</span>
      <span class="comment">// memory shifted.</span>
      d_length = dst_Index;

      <span class="comment">//********************************************</span>
      <span class="comment">//* Note the use of auto raw deleter on tail *</span>
      <span class="comment">//* memory with negative length (below).     *</span>
      <span class="comment">//********************************************</span>

      <a class="code" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter&lt;TYPE, bslma::Allocator&gt;</a> tailDeleter(newLength,
                                                              d_allocator_p,
                                                              -numShifted);
</pre></div><br/>
<br/>
 Since we have decided to copy the source elements from right to left, we set the origin of the <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code> to the end of the array, and decrement the (signed) length on each copy to extend the proctor range by 1. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// Used to temporarily proctor each new element&#39;s memory.</span>
      <a class="code" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor&lt;bslma::Allocator&gt;</a>
                                        elementDeallocator(0, d_allocator_p);

      <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;srcArray) {  <span class="comment">// no self-alias</span>

          <span class="comment">// Copy the character sequences from the &#39;srcArray&#39;.  Note that the</span>
          <span class="comment">// &#39;tailDeleter&#39; has to be decremented to cover the newly</span>
          <span class="comment">// created object.</span>

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = srcLength - 1; i &gt;= 0; --i, --tailDeleter) {
              d_array_p[dstIndex + i] =
                        (TYPE *) d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span> **d_array_p);
              elementDeallocator.reset(d_array_p[dstIndex + i]);
              <span class="keyword">new</span>(d_array_p[dstIndex + i]) TYPE(*srcArray.d_array_p[i],
                                                d_allocator_p);
              elementDeallocator.release();
          }
      }
      <span class="keywordflow">else</span> {  <span class="comment">// self-alias</span>
          <span class="comment">// ...</span>
      }

      <span class="comment">//*********************************************</span>
      <span class="comment">// Note that the proctor is released (below). *</span>
      <span class="comment">//*********************************************</span>

      tailDeleter.release();
      d_length = newLength;
  }
</pre></div><br/>
<br/>
 Note that though the two implementations are functionally equivalent, they are logically different. First of all, the second implementation will be slightly slower because it is accessing memory backwards when compared to the normal forward sequential access. Secondly, in case of an exception, the first implementation will retain all the elements copied prior to the exception, whereas the second implementation will remove them. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:56 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
