<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlc::Queue</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlc.html">bdlc</a>      </li>
      <li><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue&lt; T &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlc::Queue&lt; T &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlc::Queue" -->
<p><code>#include &lt;<a class="el" href="bdlc__queue_8h_source.html">bdlc_queue.h</a>&gt;</code></p>

<p><a href="classbdlc_1_1Queue-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1Queue_1_1InitialCapacity.html">InitialCapacity</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a0a821ccc8bb148caf91eee3902fe7019">BSLALG_DECLARE_NESTED_TRAITS2</a> (<a class="el" href="classbdlc_1_1Queue.html">Queue</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>, <a class="el" href="structbdlb_1_1TypeTraitHasPrintMethod.html">bdlb::TypeTraitHasPrintMethod</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a4259d1a6ff66e55957c9b024453e1c00">Queue</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a64c2d6a2f91dc2f9b041264f5862b185">Queue</a> (unsigned int initialLength, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a0f686c2e3673e2be27495894dffa5dc7">Queue</a> (int initialLength, const T &amp;initialValue, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a55b52ad5c473ade4d7a415bb215753b2">Queue</a> (const <a class="el" href="structbdlc_1_1Queue_1_1InitialCapacity.html">InitialCapacity</a> &amp;numElements, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ada90c4ef7f50f17ca766adc9b8213290">Queue</a> (const T *srcArray, int numElements, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a9b9f29142cfa11501275a3b3e8e0bc41">Queue</a> (const <a class="el" href="classbdlc_1_1Queue.html">Queue</a> &amp;original, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ac1df6da7a9b3efbaf7e646a445707a51">~Queue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1Queue.html">Queue</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a493c8aa62d63f0ee647bd71102b3d1e8">operator=</a> (const <a class="el" href="classbdlc_1_1Queue.html">Queue</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ad04432d01f0c382f73bb7031065fd276">operator[]</a> (int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#af6dac14aff49a2d906ce7832089f6ab9">append</a> (const T &amp;item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a3036c54c95f7a46b268745655736cf77">append</a> (const <a class="el" href="classbdlc_1_1Queue.html">Queue</a> &amp;srcQueue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a73353576a5dec22033e1795f2553fc11">append</a> (const <a class="el" href="classbdlc_1_1Queue.html">Queue</a> &amp;srcQueue, int srcIndex, int numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a6596119eeb67ef808cf52ab98a906693">back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a> (int dstIndex, const T &amp;item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#af8a707b5cb74f03edd3f59c021f4ef5c">insert</a> (int dstIndex, const <a class="el" href="classbdlc_1_1Queue.html">Queue</a> &amp;srcQueue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a3b622d20d70fd9269fe11acd185b590d">insert</a> (int dstIndex, const <a class="el" href="classbdlc_1_1Queue.html">Queue</a> &amp;srcQueue, int srcIndex, int numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ab89dbf8bdc8bc2d15d27f51843e19ac2">popBack</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a69b2057cdc8eebc6a7b616ebfb8daadd">popFront</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a9172a19b3e9d34b5a82fdc1c7f77de2d">pushBack</a> (const T &amp;item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ae062b1d0a7f732e6cb97544781432e20">pushFront</a> (const T &amp;item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a83284e23c41b9dcb6301b5dafdc22ae6">remove</a> (int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ab0a6b793a60e71137fef9bfcf885fc79">remove</a> (int index, int numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#af72efa02b3bb0771bb6f561b227e262c">removeAll</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; T &gt; *buffer=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a73edfa536525bf7f83e221cb2034cc46">replace</a> (int dstIndex, const T &amp;item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ad964d579045a549ef98c3f5ccc4ea495">replace</a> (int dstIndex, const <a class="el" href="classbdlc_1_1Queue.html">Queue</a> &amp;srcQueue, int srcIndex, int numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ad6f0d2b7e39faafd732624c6a94036ce">reserveCapacity</a> (int numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#addb11a3b67cc3ee5d4c9b8f0154095bc">reserveCapacityRaw</a> (int numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a596122fa48f5f7d17df6b3e072faa5b7">setLength</a> (int newLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#acb953cfac4fc9d25b83d65d8d871fde8">setLength</a> (int newLength, const T &amp;initialValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a7c17858f2a3309608ca9e6e1c848af5a">setLengthRaw</a> (int newLength)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a822321c649e5f7d264b369f671075005">bdexStreamIn</a> (STREAM &amp;stream, int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a772fbff5f3cac49790a45db9503a392d">swap</a> (int index1, int index2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a43cd7900fbbee6410c30e31daaaf3adb">operator[]</a> (int index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a2e8223796ea14327aaa99967f1bb9e89">back</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a8bebe0156f1599a5048c88e802b85327">front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a16c32701cf711026a2a976eaa9c4df13">print</a> (bsl::ostream &amp;stream, int level, int spacesPerLevel) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#ac017ecf82b74d4a9ab12b3b6ffda319c">streamOut</a> (bsl::ostream &amp;stream) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a33e4fc22b7adde67446597733809c0cd">bdexStreamOut</a> (STREAM &amp;stream, int version) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html#a87f69918dc3cf87913eddcd790b2ffda">maxSupportedBdexVersion</a> (int versionSelector)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class bdlc::Queue&lt; T &gt;</h3>

<p>This class implements an efficient, in-place double-ended queue of values of parameterized type <code>T</code>. The physical capacity of this queue may grow, but never shrinks. Capacity may be reserved initially via a constructor, or at any time thereafter by using the <code>reserveCapacity</code> and <code>reserveCapacityRaw</code> methods. Note that there is no guarantee of contiguous storage of consecutive elements.</p>
<p>More generally, this container class supports a complete set of <em>value</em> <em>semantics</em> operations, including copy construction, assignment, equality comparison, <code>ostream</code> printing, and <code>bdex</code> serialization. (A precise operational definition of when two objects have the same value can be found in the description of <code>operator==</code> for the class.) This container is <em>exception</em> <em>neutral</em> with no guarantee of rollback: if an exception is thrown during the invocation of a method on a pre-existing object, the container is left in a valid state, but its value is undefined. In no event is memory leaked. Finally, <em>aliasing</em> (e.g., using all or part of an object as both source and destination) is supported in all cases. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4259d1a6ff66e55957c9b024453e1c00"></a><!-- doxytag: member="bdlc::Queue::Queue" ref="a4259d1a6ff66e55957c9b024453e1c00" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::<a class="el" href="classbdlc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a64c2d6a2f91dc2f9b041264f5862b185"></a><!-- doxytag: member="bdlc::Queue::Queue" ref="a64c2d6a2f91dc2f9b041264f5862b185" args="(unsigned int initialLength, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::<a class="el" href="classbdlc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>initialLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f686c2e3673e2be27495894dffa5dc7"></a><!-- doxytag: member="bdlc::Queue::Queue" ref="a0f686c2e3673e2be27495894dffa5dc7" args="(int initialLength, const T &amp;initialValue, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::<a class="el" href="classbdlc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an in-place queue. By default, the queue is empty. Optionally specify the <code>initialLength</code> of the queue. <a class="el" href="classbdlc_1_1Queue.html">Queue</a> elements are initialized with the specified <code>initialValue</code>, or to 0.0 if <code>initialValue</code> is not specified. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt;= initialLength</code>. </p>

</div>
</div>
<a class="anchor" id="a55b52ad5c473ade4d7a415bb215753b2"></a><!-- doxytag: member="bdlc::Queue::Queue" ref="a55b52ad5c473ade4d7a415bb215753b2" args="(const InitialCapacity &amp;numElements, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::<a class="el" href="classbdlc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlc_1_1Queue_1_1InitialCapacity.html">InitialCapacity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an in-place queue with sufficient initial capacity to accommodate up to the specified <code>numElements</code> values without subsequent reallocation. A valid reference returned by the <code>operator[]</code> method is guaranteed to remain valid unless the value returned by the <code>length</code> method exceeds <code>numElements</code> (which would potentially cause a reallocation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt;= numElements</code>. </p>

</div>
</div>
<a class="anchor" id="ada90c4ef7f50f17ca766adc9b8213290"></a><!-- doxytag: member="bdlc::Queue::Queue" ref="ada90c4ef7f50f17ca766adc9b8213290" args="(const T *srcArray, int numElements, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::<a class="el" href="classbdlc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>srcArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an in-place queue initialized with the specified <code>numElements</code> leading values from the specified <code>srcArray</code>. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt;= numElements</code>. Note that <code>srcArray</code> must refer to sufficient memory to hold <code>numElements</code> values. </p>

</div>
</div>
<a class="anchor" id="a9b9f29142cfa11501275a3b3e8e0bc41"></a><!-- doxytag: member="bdlc::Queue::Queue" ref="a9b9f29142cfa11501275a3b3e8e0bc41" args="(const Queue &amp;original, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::<a class="el" href="classbdlc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an in-place queue initialized to the value of the specified <code>original</code> queue. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="ac1df6da7a9b3efbaf7e646a445707a51"></a><!-- doxytag: member="bdlc::Queue::~Queue" ref="ac1df6da7a9b3efbaf7e646a445707a51" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::~<a class="el" href="classbdlc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0a821ccc8bb148caf91eee3902fe7019"></a><!-- doxytag: member="bdlc::Queue::BSLALG_DECLARE_NESTED_TRAITS2" ref="a0a821ccc8bb148caf91eee3902fe7019" args="(Queue, bslalg::TypeTraitUsesBslmaAllocator, bdlb::TypeTraitHasPrintMethod)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::BSLALG_DECLARE_NESTED_TRAITS2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlb_1_1TypeTraitHasPrintMethod.html">bdlb::TypeTraitHasPrintMethod</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a87f69918dc3cf87913eddcd790b2ffda"></a><!-- doxytag: member="bdlc::Queue::maxSupportedBdexVersion" ref="a87f69918dc3cf87913eddcd790b2ffda" args="(int versionSelector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::maxSupportedBdexVersion </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum valid BDEX format version, as indicated by the specified <code>versionSelector</code>, to be passed to the <code>bdexStreamOut</code> method. Note that it is highly recommended that <code>versionSelector</code> be formatted as "YYYYMMDD", a date representation. Also note that <code>versionSelector</code> should be a <em>compile</em>-time-chosen value that selects a format version supported by both externalizer and unexternalizer. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a493c8aa62d63f0ee647bd71102b3d1e8"></a><!-- doxytag: member="bdlc::Queue::operator=" ref="a493c8aa62d63f0ee647bd71102b3d1e8" args="(const Queue &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">Queue</a>&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this queue the value of the specified <code>rhs</code> queue and return a reference to this modifiable queue. </p>

</div>
</div>
<a class="anchor" id="ad04432d01f0c382f73bb7031065fd276"></a><!-- doxytag: member="bdlc::Queue::operator[]" ref="ad04432d01f0c382f73bb7031065fd276" args="(int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>index</code> position in this queue. The reference will remain valid as long as this queue is not destroyed or modified (e.g., via <code>insert</code>, <code>remove</code>, or <code>append</code>). The behavior is undefined unless <code>0 &lt;= index &lt; <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>. </p>

</div>
</div>
<a class="anchor" id="af6dac14aff49a2d906ce7832089f6ab9"></a><!-- doxytag: member="bdlc::Queue::append" ref="af6dac14aff49a2d906ce7832089f6ab9" args="(const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append to the end of this queue the value of the specified <code>item</code>. Note that this function is a synonym for <code>pushBack</code> and is logically equivalent to (but generally more efficient than): <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">           <a class="code" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a>(<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>(), item);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a3036c54c95f7a46b268745655736cf77"></a><!-- doxytag: member="bdlc::Queue::append" ref="a3036c54c95f7a46b268745655736cf77" args="(const Queue &amp;srcQueue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srcQueue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append to the end of this queue the sequence of values in the specified <code>srcQueue</code>. Note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">           <a class="code" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a>(<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>(), srcQueue);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a73353576a5dec22033e1795f2553fc11"></a><!-- doxytag: member="bdlc::Queue::append" ref="a73353576a5dec22033e1795f2553fc11" args="(const Queue &amp;srcQueue, int srcIndex, int numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srcQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append to the end of this queue the specified <code>numElements</code> value in the specified <code>srcQueue</code> starting at the specified index position <code>srcIndex</code>. Note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">           <a class="code" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a>(<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>(), srcQueue, srcIndex, numElements);
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>0 &lt;= srcIndex</code>, <code>0 &lt;= numElements</code>, and <code>srcIndex + numElements &lt;= srcQueue.length()</code>. </p>

</div>
</div>
<a class="anchor" id="a6596119eeb67ef808cf52ab98a906693"></a><!-- doxytag: member="bdlc::Queue::back" ref="a6596119eeb67ef808cf52ab98a906693" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable value at the back of this queue. The reference will remain valid as long as the queue is not destroyed or modified (e.g., via <code>insert</code>, <code>remove</code>, or <code>append</code>). The behavior is undefined if the queue is empty. Note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbdlc_1_1Queue.html#ad04432d01f0c382f73bb7031065fd276">operator[]</a>(<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>() - 1)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="aea0d9fe1ebd0a208ae2e159193bdba06"></a><!-- doxytag: member="bdlc::Queue::front" ref="aea0d9fe1ebd0a208ae2e159193bdba06" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable value at the front of this queue. The reference will remain valid as long as the queue is not destroyed or modified (e.g., via <code>insert</code>, <code>remove</code>, or <code>append</code>). The behavior is undefined if the queue is empty. Note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbdlc_1_1Queue.html#ad04432d01f0c382f73bb7031065fd276">operator[]</a>(0)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="acbf8e4df0a442b760d9970a780b5e3aa"></a><!-- doxytag: member="bdlc::Queue::insert" ref="acbf8e4df0a442b760d9970a780b5e3aa" args="(int dstIndex, const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>item</code> into this queue at the specified <code>dstIndex</code>. All current values with indices at or above <code>dstIndex</code> are shifted up by one index position. The behavior is undefined unless <code>0 &lt;= dstIndex &lt;= <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>. </p>

</div>
</div>
<a class="anchor" id="af8a707b5cb74f03edd3f59c021f4ef5c"></a><!-- doxytag: member="bdlc::Queue::insert" ref="af8a707b5cb74f03edd3f59c021f4ef5c" args="(int dstIndex, const Queue &amp;srcQueue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srcQueue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>srcQueue</code> into this queue at the specified <code>dstIndex</code>. All current values with indices at or above <code>dstIndex</code> are shifted up by <code>srcQueue.length()</code> index positions. The behavior is undefined unless <code>0 &lt;= dstIndex &lt;= <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3b622d20d70fd9269fe11acd185b590d"></a><!-- doxytag: member="bdlc::Queue::insert" ref="a3b622d20d70fd9269fe11acd185b590d" args="(int dstIndex, const Queue &amp;srcQueue, int srcIndex, int numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srcQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>numElements</code> values starting at the specified <code>srcIndex</code> position from the specified <code>srcQueue</code> into this queue at the specified <code>dstIndex</code>. All current values with indices at or above <code>dstIndex</code> are shifted up by <code>numElements</code> index positions. The behavior is undefined unless <code>0 &lt;= dstIndex &lt;= <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>, <code>0 &lt;= srcIndex</code>, <code>0 &lt;= numElements</code>, and <code>srcIndex + numElements &lt;= srcQueue.length()</code>. </p>

</div>
</div>
<a class="anchor" id="ab89dbf8bdc8bc2d15d27f51843e19ac2"></a><!-- doxytag: member="bdlc::Queue::popBack" ref="ab89dbf8bdc8bc2d15d27f51843e19ac2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::popBack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the value from the back of this queue efficiently (in O[1] time). The behavior is undefined if this queue is empty. Note that this function is logically equivalent to (but more efficient than): <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">            <span class="keyword">remove</span>(<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>() - 1)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a69b2057cdc8eebc6a7b616ebfb8daadd"></a><!-- doxytag: member="bdlc::Queue::popFront" ref="a69b2057cdc8eebc6a7b616ebfb8daadd" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::popFront </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the value from the front of this queue efficiently (in O[1] time). The behavior is undefined if this queue is empty. Note that this function is logically equivalent to (but more efficient than): <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">            <span class="keyword">remove</span>(0)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a9172a19b3e9d34b5a82fdc1c7f77de2d"></a><!-- doxytag: member="bdlc::Queue::pushBack" ref="a9172a19b3e9d34b5a82fdc1c7f77de2d" args="(const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::pushBack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>item</code> to the back of this queue efficiently (in O[1] time when memory reallocation is not required). Note that this function is logically equivalent to (but generally more efficient than): <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a>(<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>(), item);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ae062b1d0a7f732e6cb97544781432e20"></a><!-- doxytag: member="bdlc::Queue::pushFront" ref="ae062b1d0a7f732e6cb97544781432e20" args="(const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::pushFront </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>item</code> into the front of this queue efficiently (in O[1] time when memory reallocation is not required). Note that this function is logically equivalent to (but generally more efficient than): <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a>(0, item);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a83284e23c41b9dcb6301b5dafdc22ae6"></a><!-- doxytag: member="bdlc::Queue::remove" ref="a83284e23c41b9dcb6301b5dafdc22ae6" args="(int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this queue the value at the specified <code>index</code>. All values with initial indices above <code>index</code> are shifted down by one index position. The behavior is undefined unless <code>0 &lt;= index &lt; <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ab0a6b793a60e71137fef9bfcf885fc79"></a><!-- doxytag: member="bdlc::Queue::remove" ref="ab0a6b793a60e71137fef9bfcf885fc79" args="(int index, int numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this queue, beginning at the specified <code>index</code>, the specified <code>numElements</code> values. All values with initial indices at or above <code>index + numElements</code> are shifted down by <code>numElements</code> index positions. The behavior is undefined unless <code>0 &lt;= index</code>, <code>0 &lt;= numElements</code>, and <code>index + numElements &lt;= <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>. </p>

</div>
</div>
<a class="anchor" id="af72efa02b3bb0771bb6f561b227e262c"></a><!-- doxytag: member="bdlc::Queue::removeAll" ref="af72efa02b3bb0771bb6f561b227e262c" args="(bsl::vector&lt; T &gt; *buffer=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::removeAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; T &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all elements from this queue. If the optionally specified <code>buffer</code> is not 0, append to <code>buffer</code> a copy of each element removed (in front-to-back order of the elements in the queue prior to the invocation of this method). </p>

</div>
</div>
<a class="anchor" id="a73edfa536525bf7f83e221cb2034cc46"></a><!-- doxytag: member="bdlc::Queue::replace" ref="a73edfa536525bf7f83e221cb2034cc46" args="(int dstIndex, const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the element at the specified <code>dstIndex</code> in this queue with the specified <code>item</code>. The behavior is undefined unless <code>0 &lt;= dstIndex &lt; <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>. Note that this function is logically equivalent to (but more efficient than): <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a>(dstIndex, item);
            <span class="keyword">remove</span>(dstIndex + 1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ad964d579045a549ef98c3f5ccc4ea495"></a><!-- doxytag: member="bdlc::Queue::replace" ref="ad964d579045a549ef98c3f5ccc4ea495" args="(int dstIndex, const Queue &amp;srcQueue, int srcIndex, int numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srcQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the specified <code>numElements</code> values beginning at the specified <code>dstIndex</code> in this queue with values from the specified <code>srcQueue</code> beginning at the specified <code>srcIndex</code>. The behavior is undefined unless <code>0 &lt;= dstIndex, 0 &lt;= numElements</code>, <code>dstIndex + numElements &lt;= <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>, <code>0 &lt;= srcIndex</code>, and <code>srcIndex + numElements &lt;= srcQueue.length()</code>. Note that this function is logically equivalent to (but more efficient than): <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a>(dstIndex, srcQueue, srcIndex, numElements);
            <span class="keyword">remove</span>(dstIndex + numElements, numElements);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ad6f0d2b7e39faafd732624c6a94036ce"></a><!-- doxytag: member="bdlc::Queue::reserveCapacity" ref="ad6f0d2b7e39faafd732624c6a94036ce" args="(int numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve sufficient internal capacity to accommodate up to the specified <code>numElements</code> values without subsequent reallocation. Note that if <code>numElements &lt;= <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="addb11a3b67cc3ee5d4c9b8f0154095bc"></a><!-- doxytag: member="bdlc::Queue::reserveCapacityRaw" ref="addb11a3b67cc3ee5d4c9b8f0154095bc" args="(int numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::reserveCapacityRaw </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve sufficient and minimal internal capacity to accommodate up to the specified <code>numElements</code> values without subsequent reallocation. Beware, however, that repeated calls to this function may invalidate bounds on runtime complexity otherwise guaranteed by this container. Note that if <code>numElements &lt;= <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a596122fa48f5f7d17df6b3e072faa5b7"></a><!-- doxytag: member="bdlc::Queue::setLength" ref="a596122fa48f5f7d17df6b3e072faa5b7" args="(int newLength)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::setLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb953cfac4fc9d25b83d65d8d871fde8"></a><!-- doxytag: member="bdlc::Queue::setLength" ref="acb953cfac4fc9d25b83d65d8d871fde8" args="(int newLength, const T &amp;initialValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::setLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>initialValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the length of this queue to the specified <code>newLength</code>. If <code>newLength</code> is less than the current length, elements at index positions at or above <code>newLength</code> are removed. Otherwise any new elements (at or above the current length) are initialized to the specified <code>initialValue</code>, or to 0.0 if <code>initialValue</code> is not specified. The behavior is undefined unless <code>0 &lt;= newLength</code>. </p>

</div>
</div>
<a class="anchor" id="a7c17858f2a3309608ca9e6e1c848af5a"></a><!-- doxytag: member="bdlc::Queue::setLengthRaw" ref="a7c17858f2a3309608ca9e6e1c848af5a" args="(int newLength)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::setLengthRaw </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the length of this queue to the specified <code>newLength</code>. If <code>newLength</code> is less than the current length, elements at index positions at or above <code>newLength</code> are removed. If <code>newLength</code> is equal to the current length, this function has no effect. Otherwise new elements at or above the current length are not initialized to any value. </p>

</div>
</div>
<a class="anchor" id="a822321c649e5f7d264b369f671075005"></a><!-- doxytag: member="bdlc::Queue::bdexStreamIn" ref="a822321c649e5f7d264b369f671075005" args="(STREAM &amp;stream, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::bdexStreamIn </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value read from the specified input <code>stream</code> using the specified <code>version</code> format, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported, this object is unaltered and <code>stream</code> is invalidated, but otherwise unmodified. If <code>version</code> is supported but <code>stream</code> becomes invalid during this operation, this object has an undefined, but valid, state. Note that no version is read from <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a772fbff5f3cac49790a45db9503a392d"></a><!-- doxytag: member="bdlc::Queue::swap" ref="a772fbff5f3cac49790a45db9503a392d" args="(int index1, int index2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap efficiently the values at the specified indices <code>index1</code> and <code>index2</code>. The behavior is undefined unless <code>0 &lt;= index1 &lt; <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code> and <code>0 &lt;= index2 &lt; <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a43cd7900fbbee6410c30e31daaaf3adb"></a><!-- doxytag: member="bdlc::Queue::operator[]" ref="a43cd7900fbbee6410c30e31daaaf3adb" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>index</code> position in this queue. The reference will remain valid as long as this queue is not destroyed or modified (e.g., via <code>insert</code>, <code>remove</code>, or <code>append</code>). The behavior is undefined unless <code>0 &lt;= index &lt; <a class="el" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a2e8223796ea14327aaa99967f1bb9e89"></a><!-- doxytag: member="bdlc::Queue::back" ref="a2e8223796ea14327aaa99967f1bb9e89" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the back of this queue. The reference will remain valid as long as this queue is not destroyed or modified (e.g., via <code>insert</code>, <code>remove</code>, or <code>append</code>). The behavior is undefined if this queue is empty. Note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classbdlc_1_1Queue.html#ad04432d01f0c382f73bb7031065fd276">operator[]</a>(<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>() - 1)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a8bebe0156f1599a5048c88e802b85327"></a><!-- doxytag: member="bdlc::Queue::front" ref="a8bebe0156f1599a5048c88e802b85327" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the front of this queue. The reference will remain valid as long as this queue is not destroyed or modified (e.g., via <code>insert</code>, <code>remove</code>, or <code>append</code>). The behavior is undefined if this queue is empty. Note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classbdlc_1_1Queue.html#ad04432d01f0c382f73bb7031065fd276">operator[]</a>(0)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a33ccacc9417d42712b56ead0abf165a2"></a><!-- doxytag: member="bdlc::Queue::length" ref="a33ccacc9417d42712b56ead0abf165a2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this queue. </p>

<p>Referenced by <a class="el" href="classbdlc_1_1Queue.html#ac017ecf82b74d4a9ab12b3b6ffda319c">bdlc::Queue&lt; TcpTimerEventManager_Request * &gt;::streamOut()</a>.</p>

</div>
</div>
<a class="anchor" id="a16c32701cf711026a2a976eaa9c4df13"></a><!-- doxytag: member="bdlc::Queue::print" ref="a16c32701cf711026a2a976eaa9c4df13" args="(bsl::ostream &amp;stream, int level, int spacesPerLevel) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format this object to the specified output <code>stream</code> at the optionally specified indentation <code>level</code> and return a reference to the modifiable <code>stream</code>. If <code>level</code> is specified, optionally specify <code>spacesPerLevel</code>, the number of spaces per indentation level for this and all of its nested objects. Each line is indented by the absolute value of <code>level * spacesPerLevel</code>. If <code>level</code> is negative, suppress indentation of the first line. If <code>spacesPerLevel</code> is negative, suppress line breaks and format the entire output on one line. If <code>stream</code> is initially invalid, this operation has no effect. Note that a trailing newline is provided in multi-line mode only. </p>

</div>
</div>
<a class="anchor" id="ac017ecf82b74d4a9ab12b3b6ffda319c"></a><!-- doxytag: member="bdlc::Queue::streamOut" ref="ac017ecf82b74d4a9ab12b3b6ffda319c" args="(bsl::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::streamOut </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Write the elements of this queue out to the specified <code>stream</code>. Note that for this method to compile, <code>operator&lt;&lt;</code> has to be defined for arguments <code>stream</code> and type <code>T</code>. </p>

</div>
</div>
<a class="anchor" id="a33e4fc22b7adde67446597733809c0cd"></a><!-- doxytag: member="bdlc::Queue::bdexStreamOut" ref="a33e4fc22b7adde67446597733809c0cd" args="(STREAM &amp;stream, int version) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; T &gt;::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of this object, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported, <code>stream</code> is invalidated, but otherwise unmodified. Note that <code>version</code> is not written to <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlc__queue_8h_source.html">bdlc_queue.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:17 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
