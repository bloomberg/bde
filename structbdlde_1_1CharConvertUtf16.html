<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct bdlde::CharConvertUtf16</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlde.html">bdlde</a>      </li>
      <li><a class="el" href="structbdlde_1_1CharConvertUtf16.html">bdlde::CharConvertUtf16</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlde::CharConvertUtf16 Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlde::CharConvertUtf16" -->
<p><code>#include &lt;<a class="el" href="bdlde__charconvertutf16_8h_source.html">bdlde_charconvertutf16.h</a>&gt;</code></p>

<p><a href="structbdlde_1_1CharConvertUtf16-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#af8825cc14b50735cfba6a9e20dc7a3e1">utf8ToUtf16</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a> *dstWstring, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCodePointsWritten=0, wchar_t errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a4656d1b346f2fd29e96390e1fd178e10">utf8ToUtf16</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a> *dstWstring, const char *srcString, bsl::size_t *numCodePointsWritten=0, wchar_t errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a318c6bbdabbb983942fc041b5e686f26">utf8ToUtf16</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short &gt; *dstVector, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCodePointsWritten=0, unsigned short errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a1aefa99ef27e6dee33ce345342122a99">utf8ToUtf16</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short &gt; *dstVector, const char *srcString, bsl::size_t *numCodePointsWritten=0, unsigned short errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a684f8ee8fd5b9df945a1aaa3cd7686f3">utf8ToUtf16</a> (unsigned short *dstBuffer, bsl::size_t dstCapacity, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numWordsWritten=0, unsigned short errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#ae682084e6d2472ac6839b87fdc21995a">utf8ToUtf16</a> (unsigned short *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numWordsWritten=0, unsigned short errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a1bf7680ee726f0aefcb9c0b4d752808e">utf8ToUtf16</a> (wchar_t *dstBuffer, bsl::size_t dstCapacity, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numWordsWritten=0, wchar_t errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#afb548b09b7a5f0bb843e24dd0d522038">utf8ToUtf16</a> (wchar_t *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numWordsWritten=0, wchar_t errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#aa8d8dd56e976d2e44746bbe5025cf898">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *dstString, const unsigned short *srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#a08809165de4dd721ca3a30eb7d0ec154">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *dstString, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#ade4139a673a48eba79d8e5b96e5c0582">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *dstString, const wchar_t *srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#acd993b7ca479ea4110b25ca2d204c455">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *dstVector, const unsigned short *srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#aa7ad9e15aabaee13fb33aaf538f11750">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *dstVector, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#ae38b99068165102e37fbf40e221533ed">utf16ToUtf8</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *dstVector, const wchar_t *srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#aa6329e6a43e12b9ad2f69900718809e0">utf16ToUtf8</a> (char *dstBuffer, bsl::size_t dstCapacity, const unsigned short *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numBytesWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#ad9841685fcf73473d141dff63a61d625">utf16ToUtf8</a> (char *dstBuffer, bsl::size_t dstCapacity, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numBytesWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf16.html#aaa2e45681281708651b686d296aa2b06">utf16ToUtf8</a> (char *dstBuffer, bsl::size_t dstCapacity, const wchar_t *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numBytesWritten=0, char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of static functions to convert buffers or containers between UTF-8 and UTF-16. Note that Byte Order Mark (BOM) sequences are neither generated nor recognized as special. If a BOM is present in the input, it will be translated, whether correct (<code>0xfeff</code>) or incorrect (<code>0xfffe</code>), into the output without any special handling. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af8825cc14b50735cfba6a9e20dc7a3e1"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="af8825cc14b50735cfba6a9e20dc7a3e1" args="(bsl::wstring *dstWstring, const bslstl::StringRef &amp;srcString, bsl::size_t *numCodePointsWritten=0, wchar_t errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a> *&nbsp;</td>
          <td class="paramname"> <em>dstWstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4656d1b346f2fd29e96390e1fd178e10"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a4656d1b346f2fd29e96390e1fd178e10" args="(bsl::wstring *dstWstring, const char *srcString, bsl::size_t *numCodePointsWritten=0, wchar_t errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::wstring</a> *&nbsp;</td>
          <td class="paramname"> <em>dstWstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstWstring</code> the result of converting the specified UTF-8 <code>srcString</code> to its UTF-16 equivalent. Optionally specify <code>numCodePointsWritten</code>, which, if not 0, indicates the location of the modifiable variable into which the number of Unicode code points written, including the terminating null word, is to be loaded. Optionally specify an <code>errorWord</code> to be substituted, if not 0, for invalid encodings in the input string. Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> otherwise. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings of code points, or code points outside the ranges that UTF-16 can validly encode (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0x10ffff ]</code>). If <code>errorWord</code> is 0, invalid input code points are ignored (i.e., produce no corresponding output). The behavior is undefined unless <code>srcString</code> is null-terminated when specified as a <code>const char *</code>. Note that one code point can occupy multiple 16-bit words, and that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded null bytes that will be translated to null words embedded in the output. </p>

</div>
</div>
<a class="anchor" id="a318c6bbdabbb983942fc041b5e686f26"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a318c6bbdabbb983942fc041b5e686f26" args="(bsl::vector&lt; unsigned short &gt; *dstVector, const bslstl::StringRef &amp;srcString, bsl::size_t *numCodePointsWritten=0, unsigned short errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1aefa99ef27e6dee33ce345342122a99"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a1aefa99ef27e6dee33ce345342122a99" args="(bsl::vector&lt; unsigned short &gt; *dstVector, const char *srcString, bsl::size_t *numCodePointsWritten=0, unsigned short errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstVector</code> the result of converting the specified UTF-8 <code>srcString</code> to its UTF-16 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of UTF-16 code points (including the null terminator) written is to be loaded. Optionally specify an <code>errorWord</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings, or code points outside the ranges that UTF-16 can validly encode (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0x10ffff ]</code>). If <code>errorWord</code> is 0, invalid input is ignored (i.e., produces no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> otherwise. The behavior is undefined unless <code>errorWord</code> is either 0 or a valid single-word encoded UTF-16 code point (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0xffff ]</code>) and <code>srcString</code> is null-terminated when specified as a <code>const char *</code>. Note that one code point can occupy multiple 16-bit words. Also note that the size of the result vector is always fitted to the null-terminated result, including the terminating 0. Also note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded null bytes that will be translated to null words embedded in the output. </p>

</div>
</div>
<a class="anchor" id="a684f8ee8fd5b9df945a1aaa3cd7686f3"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a684f8ee8fd5b9df945a1aaa3cd7686f3" args="(unsigned short *dstBuffer, bsl::size_t dstCapacity, const bslstl::StringRef &amp;srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numWordsWritten=0, unsigned short errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numWordsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae682084e6d2472ac6839b87fdc21995a"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="ae682084e6d2472ac6839b87fdc21995a" args="(unsigned short *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numWordsWritten=0, unsigned short errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numWordsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified UTF-8 <code>srcString</code> to its UTF-16 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the variable into which the number of UTF-16 code points (including the null terminator) written is to be loaded. Optionally specify <code>numWordsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of <code>short</code> <em>memory words</em> written (including the null terminator) is to be loaded. Optionally specify an <code>errorWord</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings of code points, or code points outside the ranges that UTF-16 can validly encode (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0x10ffff ]</code>). If <code>errorWord</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. Return 0 on success and a bit-wise or of the bits specified by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise to indicate that there were invalid input sequences or if <code>dstCapacity</code> was inadequate to store the output. If <code>dstCapacity &gt; 0</code> yet <code>dstCapacity</code> specifies a buffer too small to hold the output, the maximal null-terminated prefix of the properly converted result string is loaded into <code>dstBuffer</code>. The behavior is undefined unless <code>dstBuffer</code> refers to an array of at least <code>dstCapacity</code> elements, <code>errorWord</code> is either 0 or a valid single-word encoded UTF-16 code point (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0xffff ]</code>), and <code>srcString</code> is null-terminated when supplied as a <code>const char *</code>. Note that if <code>dstCapacity</code> is 0, <code>*dstBuffer</code> is not modified and this function returns a value with <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> set and 0 is written into <code>*numCodePointsWritten</code> and <code>*numWordsWritten</code> (if those pointers are non-null), since there is insufficient space for even a null terminator alone. Also note that one code point can occupy multiple 16-bit <em>words</em>, so that <code>*numWordsWritten</code> may be greater than <code>*numCodePointsWritten</code>, and therefore that an input <code>srcString</code> of <code>dstCapacity</code> code points may not fit into <code>dstBuffer</code>, however, an input <code>srcString</code> of <code>dstCapacity</code> bytes (including null terminator, if present) will always fit (since the UTF-8 encoding of a code point requires at least as many bytes as the UTF-16 encoding requires words). Also note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded null bytes that will be translated to null words embedded in the output. </p>

</div>
</div>
<a class="anchor" id="a1bf7680ee726f0aefcb9c0b4d752808e"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="a1bf7680ee726f0aefcb9c0b4d752808e" args="(wchar_t *dstBuffer, bsl::size_t dstCapacity, const bslstl::StringRef &amp;srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numWordsWritten=0, wchar_t errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numWordsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb548b09b7a5f0bb843e24dd0d522038"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf8ToUtf16" ref="afb548b09b7a5f0bb843e24dd0d522038" args="(wchar_t *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numWordsWritten=0, wchar_t errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf8ToUtf16 </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numWordsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified UTF-8 <code>srcString</code> to its UTF-16 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the variable into which the number of UTF-16 code points (including the terminating 0) written is to be loaded. Optionally specify <code>numWordsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of <code>short</code> <em>memory words</em> written (including the null terminator) is to be loaded. Optionally specify an <code>errorWord</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings of code points, or code points outside the ranges that UTF-16 can validly encode (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xde00 .. 0x10ffff ]</code>). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. If <code>errorWord</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Return 0 on success and a bit-wise or of the bits specified by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise to indicate that there were invalid sequences or if <code>dstCapacity</code> was inadequate to store the output. If <code>dstCapacity &gt; 0</code> yet <code>dstCapacity</code> specifies a buffer too small to hold the output, the maximal null-terminated prefix of the properly converted result string is loaded into <code>dstBuffer</code>. The behavior is undefined unless <code>dstBuffer</code>, if specified, refers to an array of at least <code>dstCapacity</code> elements, <code>errorWord</code> is either 0 or a valid single-word encoded UTF-16 code point (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0xffff ]</code>), and <code>srcString</code> is null-terminated if supplied as a <code>const char *</code>. Note that if <code>dstCapacity</code> is 0, <code>*dstBuffer</code> is not modified and this function returns a value with <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> set and 0 is written into <code>*numCodePointsWritten</code> and <code>*numWordsWritten</code> (if those pointers are non-null), since there is insufficient space for even a null terminator alone. Also note that one code point can occupy multiple 16-bit words, so that <code>*numWordsWritten</code> may be greater than <code>*numCodePointsWritten</code>, and therefore that an input <code>srcString</code> of <code>dstCapacity</code> code points may not fit into <code>dstBuffer</code>. However, an input <code>srcString</code> of <code>dstCapacity</code> bytes (including terminating 0, if present) will always fit (since the UTF-8 encoding of a code point requires at least as many bytes as the UTF-16 encoding requires words). Also note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded null bytes that will be translated to null words embedded in the output. </p>

</div>
</div>
<a class="anchor" id="aa8d8dd56e976d2e44746bbe5025cf898"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="aa8d8dd56e976d2e44746bbe5025cf898" args="(bsl::string *dstString, const unsigned short *srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstString</code> the result of converting the specified null-terminated UTF-16 <code>*srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points written, including the null terminator, is to be loaded, where one code point may occupy multiple bytes. Optionally specify an <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorByte</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> if one or more invalid sequences were encountered in the input. The behavior is undefined unless <code>srcString</code> is null-terminated and <code>errorByte</code> is either 0 or a valid single-byte Unicode code point (<code>0 &lt; errorByte &lt; 0x80</code>). Note that the string length will be sized to the length of the output, such that <code>strlen(dstString-&gt;c_str()) == dstString-&gt;length()</code>. </p>

</div>
</div>
<a class="anchor" id="a08809165de4dd721ca3a30eb7d0ec154"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="a08809165de4dd721ca3a30eb7d0ec154" args="(bsl::string *dstString, const bslstl::StringRefWide &amp;srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ade4139a673a48eba79d8e5b96e5c0582"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="ade4139a673a48eba79d8e5b96e5c0582" args="(bsl::string *dstString, const wchar_t *srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstString</code> the result of converting the specified UTF-16 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points written, including the null terminator, is to be loaded, where one code point may occupy multiple bytes. Optionally specify an <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorByte</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Any previous contents of the destination are discarded. Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> if one or more invalid sequences were encountered in the input. The behavior is undefined unless <code>errorByte</code> is either 0 or a valid single-byte Unicode code point (<code>0 &lt; errorByte &lt; 0x80</code>) and <code>srcString</code> is null-terminated if supplied as a <code>const wchar_t *</code>. Note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#adb41ff59615d4ad2799e48a19ed5c1b1">bslstl::StringRefWide</a></code>, it may contain embedded 0 words that will be translated to null bytes embedded in the output. </p>

</div>
</div>
<a class="anchor" id="acd993b7ca479ea4110b25ca2d204c455"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="acd993b7ca479ea4110b25ca2d204c455" args="(bsl::vector&lt; char &gt; *dstVector, const unsigned short *srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstVector</code> the null-terminated result of converting the specified null-terminated UTF-16 <code>*srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points written, including the null terminator, is to be loaded, where one code point may occupy multiple bytes. Optionally specify an <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorByte</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> if one or more invalid sequences were encountered in the input. The behavior is undefined unless <code>srcString</code> is null-terminated and <code>errorByte</code> is either 0 or a valid single-byte Unicode code point (<code>0 &lt; errorByte &lt; 0x80</code>). </p>

</div>
</div>
<a class="anchor" id="aa7ad9e15aabaee13fb33aaf538f11750"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="aa7ad9e15aabaee13fb33aaf538f11750" args="(bsl::vector&lt; char &gt; *dstVector, const bslstl::StringRefWide &amp;srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae38b99068165102e37fbf40e221533ed"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="ae38b99068165102e37fbf40e221533ed" args="(bsl::vector&lt; char &gt; *dstVector, const wchar_t *srcString, bsl::size_t *numCodePointsWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstVector</code> the null-terminated result of converting the specified UTF-16 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points written, including the null terminator, is to be loaded, where one code point may occupy multiple bytes. Optionally specify an <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorByte</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> if one or more invalid sequences were encountered in the input. The behavior is undefined unless <code>errorByte</code> is either 0 or a valid single-byte Unicode code point (<code>0 &lt; errorByte &lt; 0x80</code>) and <code>srcString</code> is null-terminated if supplied as a <code>const wchar_t *</code>. Note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded 0 words that will be translated to null bytes embedded in the output. </p>

</div>
</div>
<a class="anchor" id="aa6329e6a43e12b9ad2f69900718809e0"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="aa6329e6a43e12b9ad2f69900718809e0" args="(char *dstBuffer, bsl::size_t dstCapacity, const unsigned short *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numBytesWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numBytesWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified null-terminated UTF-16 <code>*srcString</code> to its null-terminated UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points (including the terminating 0, if any) written is to be loaded, where one code point can occupy multiple bytes. Optionally specify <code>numBytesWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of bytes written (including the null terminator, if any) is to be loaded. Optionally specify an <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorByte</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Return 0 on success and a bitwise-or of the masks defined by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise, where <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> will be set if one or more invalid sequences were encountered in the input, and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> will be set if the output space was exhausted before conversion was complete. The behavior is undefined unless <code>dstBuffer</code> refers to an array of at least <code>dstCapacity</code> elements, <code>srcString</code> is null-terminated, and <code>errorByte</code> is either 0 or a valid single-byte Unicode code point (<code>0 &lt; errorByte &lt; 0x80</code>). Note that if <code>dstCapacity</code> is 0, this function returns <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> set and 0 is written into <code>*numCodePointsWritten</code> and <code>*numBytesWritten</code> (if those pointers are non-null), since there is insufficient space for even a null terminator alone. Also note that since UTF-8 is a variable-length encoding, <code>numBytesWritten</code> may be up to four times <code>numCodePointsWritten</code>, and therefore that an input <code>srcString</code> of <code>dstCapacity</code> words (including the terminating 0) may not fit into <code>dstBuffer</code>. A one-word (two-byte) UTF-16 code point will require one to three UTF-8 octets (bytes); a two-word (four-byte) UTF-16 code point will always require four UTF-8 octets. Also note that the amount of room needed will vary with the contents of the data and the language being translated, but never will the number of bytes output exceed three times the number of short words input. Also note that, if <code>dstCapacity &gt; 0</code>, then, after completion, <code>strlen(dstBuffer) + 1 == *numBytesWritten</code>. </p>

</div>
</div>
<a class="anchor" id="ad9841685fcf73473d141dff63a61d625"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="ad9841685fcf73473d141dff63a61d625" args="(char *dstBuffer, bsl::size_t dstCapacity, const bslstl::StringRefWide &amp;srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numBytesWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numBytesWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa2e45681281708651b686d296aa2b06"></a><!-- doxytag: member="bdlde::CharConvertUtf16::utf16ToUtf8" ref="aaa2e45681281708651b686d296aa2b06" args="(char *dstBuffer, bsl::size_t dstCapacity, const wchar_t *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numBytesWritten=0, char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf16::utf16ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numBytesWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified UTF-16 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points (including the terminating 0, if any) written is to be loaded, where one code point can occupy multiple bytes. Optionally specify <code>numBytesWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of bytes written (including the null terminator, if any) is to be loaded. Optionally specify an <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are incomplete multi-word encodings or parts of a two-word encoding out of their proper sequence. If <code>errorByte</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-16 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Return 0 on success and a bitwise-or of the flags defined by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise. <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> will be set if one or more invalid sequences were encountered in the input, and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> will be set if the output space was exhausted before conversion was complete. The behavior is undefined unless <code>dstBuffer</code> refers to an array of at least <code>dstCapacity</code> elements, <code>errorByte</code> is either 0 or a valid single-byte Unicode code point (<code>0 &lt; errorByte &lt; 0x80</code>), and <code>srcString</code> is null-terminated if supplied as a <code>const wchar_t *</code>. Note that if <code>dstCapacity</code> is 0, this function returns <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dae6f8411ab72425b19595c127aec9bc42">CharConvertStatus::k_OUT_OF_SPACE_BIT</a></code> set and 0 is written into <code>*numCodePointsWritten</code> and <code>*numBytesWritten</code> (if those pointers are non-null), since there is insufficient space for even a null terminator alone. Also note that since UTF-8 is a variable-length encoding, <code>numBytesWritten</code> may be up to four times <code>numCodePointsWritten</code>, and therefore that an input <code>srcString</code> of <code>dstCapacity</code> code points (including the terminating 0, if present) may not fit into <code>dstBuffer</code>. A one-word (two-byte) UTF-16 code point will require one to three UTF-8 octets (bytes); a two-word (four-byte) UTF-16 code point will always require four UTF-8 octets. Also note that the amount of room needed will vary with the contents of the data and the language being translated, but never will the number of bytes output exceed three times the number of words input. Also note that, if <code>dstCapacity &gt; 0</code>, then, after completion, <code>strlen(dstBuffer) + 1 == *numBytesWritten</code>. Also note that if <code>srcString</code> is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded 0 words that will be translated to null bytes embedded in the output. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bdlde__charconvertutf16_8h_source.html">bdlde_charconvertutf16.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:22 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
