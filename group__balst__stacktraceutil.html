<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: balst_stacktraceutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component balst_stacktraceutil<br/>
<small>
[<a class="el" href="group__balst.html">Package balst</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide low-level utilities for obtaining &amp; printing a stack-trace.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebalst.html">balst</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Loading Stack-Trace Directly from the Stack</a> </li>
<li>
<a href="#3.1.2">Example 2: Loading a Stack-Trace from an Array of Stack Addresses</a> </li>
<li>
<a href="#3.1.3">Example 3: Outputting a Hex Stack Trace</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide low-level utilities for obtaining &amp; printing a stack-trace. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbalst_1_1StackTraceUtil.html">balst::StackTraceUtil</a> </td><td>utilities for <code><a class="el" href="classbalst_1_1StackTrace.html">balst::StackTrace</a></code> objects  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__balst__stacktraceprintutil.html" title="Provide a single function to perform and print a stack trace.">Component balst_stacktraceprintutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a namespace for functions used in obtaining and printing a stack-trace. Note that clients interested in simply printing a stack-trace are encouraged to use the <code>balst_stacktraceprintutil</code> component instead. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage for this component. The following examples demonstrate two distinct ways to load and print a stack-trace with <code><a class="el" href="structbalst_1_1StackTraceUtil.html">balst::StackTraceUtil</a></code> using (1) <code>loadStackTraceFromStack</code> and (2) <code>loadStackTraceFromAddresses</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_loading_stack-trace_directly_from_the_stack"></a> <a class="anchor" id="usage.example_1~3A_loading_stack-trace_directly_from_the_stack"></a> <a class="anchor" id="description.usage.example_1~3A_loading_stack-trace_directly_from_the_stack"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Loading Stack-Trace Directly from the Stack: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We start by defining a routine, <code>recurseExample1</code>, that will recurse the specified <code>depth</code> times, then call <code>traceExample1</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> traceExample1();    <span class="comment">// forward declaration</span>

  <span class="keywordtype">void</span> recurseExample1(<span class="keywordtype">int</span> *depth)
      <span class="comment">// Recurse the specified &#39;depth&#39; number of times, then call</span>
      <span class="comment">// &#39;traceExample1&#39;.</span>
  {
      <span class="keywordflow">if</span> (--*depth &gt; 0) {
          recurseExample1(depth);
      }
      <span class="keywordflow">else</span> {
          traceExample1();
      }

      ++*depth;   <span class="comment">// Prevent compiler from optimizing tail recursion as a</span>
                  <span class="comment">// loop.</span>
  }
</pre></div><br/>
<br/>
 Then, we define the function <code>traceExample1</code>, that will print a stack-trace: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> traceExample1()
  {
</pre></div><br/>
<br/>
 Now, we create a <code><a class="el" href="classbalst_1_1StackTrace.html">balst::StackTrace</a></code> object and call <code>loadStackTraceFrameStack</code> to load the information from the stack of the current thread into the stack-trace object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this call to <code>loadStackTraceFromStack</code>, we use the default value of <code>maxFrames</code>, which is at least 1024 and the default value for <code>demanglingPreferredFlag</code>, which is <code>true</code>, meaning that the operation will attempt to demangle function names. Note that the object <code>stackTrace</code> takes very little room on the stack, and by default allocates most of its memory directly from virtual memory without going through the heap, minimizing potential complications due to stack-size limits and possible heap corruption. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbalst_1_1StackTrace.html">balst::StackTrace</a> stackTrace;
      <span class="keywordtype">int</span> rc = <a class="code" href="structbalst_1_1StackTraceUtil.html#ac630f9fbf11a4cecdd7b6133551731ca">balst::StackTraceUtil::loadStackTraceFromStack</a>(&amp;stackTrace);
      assert(0 == rc);
</pre></div><br/>
<br/>
 Finally, we use <code>printFormatted</code> to stream out the stack-trace, one frame per line, in a concise, human-readable format. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="structbalst_1_1StackTraceUtil.html#a0dc7ccd5a5b74571e5b015f6e32530e2">balst::StackTraceUtil::printFormatted</a>(bsl::cout, stackTrace);
  }
</pre></div><br/>
<br/>
 The output from the preceding example on Solaris is as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment"> (0): traceExample1()+0x28 at 0x327d0 in balst_stacktraceutil.t.dbg_exc_mt
 (1): recurseExample1(<span class="keywordtype">int</span>*)+0x54 at 0x32e30 in balst_stacktraceutil.t.dbg_exc
 (2): recurseExample1(<span class="keywordtype">int</span>*)+0x44 at 0x32e20 in balst_stacktraceutil.t.dbg_exc
 (3): recurseExample1(<span class="keywordtype">int</span>*)+0x44 at 0x32e20 in balst_stacktraceutil.t.dbg_exc
 (4): recurseExample1(<span class="keywordtype">int</span>*)+0x44 at 0x32e20 in balst_stacktraceutil.t.dbg_exc
 (5): recurseExample1(<span class="keywordtype">int</span>*)+0x44 at 0x32e20 in balst_stacktraceutil.t.dbg_exc
 (6): main+0x24c at 0x36c10 in balst_stacktraceutil.t.dbg_exc_mt
 (7): _start+0x5c at 0x31d4c in balst_stacktraceutil.t.dbg_exc_mt
</pre></div><br/>
<br/>
 Notice that the lines have been truncated to fit this 79 column source file, and that on AIX or Windows, source file name and line number information will also be displayed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_loading_a_stack-trace_from_an_array_of_stack_addresses"></a> <a class="anchor" id="usage.example_2~3A_loading_a_stack-trace_from_an_array_of_stack_addresses"></a> <a class="anchor" id="description.usage.example_2~3A_loading_a_stack-trace_from_an_array_of_stack_addresses"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Loading a Stack-Trace from an Array of Stack Addresses: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we demonstrate obtaining return addresses from the stack using <code><a class="el" href="structbalst_1_1StackAddressUtil.html">balst::StackAddressUtil</a></code>, and later using them to load a <code><a class="el" href="classbalst_1_1StackTrace.html">balst::StackTrace</a></code> object with a description of the stack. This approach may be desirable if one wants to quickly save the addresses that are the basis for a stack-trace, postponing the more time-consuming translation of those addresses to more human-readable debug information until later. To do this, we create an array of pointers to hold the return addresses from the stack, which may not be desirable if we are in a situation where there isn't much room on the stack. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a routine <code>recurseExample2</code> which will recurse the specified <code>depth</code> times, then call <code>traceExample2</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> traceExample2();    <span class="comment">// forward declaration</span>

  <span class="keyword">static</span> <span class="keywordtype">void</span> recurseExample2(<span class="keywordtype">int</span> *depth)
      <span class="comment">// Recurse the specified &#39;depth&#39; number of times, then call</span>
      <span class="comment">// &#39;traceExample2&#39;, which will print a stack-trace.</span>
  {
      <span class="keywordflow">if</span> (--*depth &gt; 0) {
          recurseExample2(depth);
      }
      <span class="keywordflow">else</span> {
          traceExample2();
      }

      ++*depth;   <span class="comment">// Prevent compiler from optimizing tail recursion as a</span>
                  <span class="comment">// loop.</span>
  }

  <span class="keywordtype">void</span> traceExample2()
  {
</pre></div><br/>
<br/>
 Then, within <code>traceExample2</code>, we create a stack-trace object and an array <code>addresses</code> to hold some addresses. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbalst_1_1StackTrace.html">balst::StackTrace</a> stackTrace;
      <span class="keyword">enum</span> { ARRAY_LENGTH = 50 };
      <span class="keywordtype">void</span> *addresses[ARRAY_LENGTH];
</pre></div><br/>
<br/>
 Next, we call <code><a class="el" href="structbalst_1_1StackAddressUtil.html#a31eb649ae00ae8153ef1439f7c5d58a0">balst::StackAddressUtil::getStackAddresses</a></code> to get the stored return addresses from the stack and load them into the array <code>addresses</code>. The call returns the number of addresses saved into the array, which will be less than or equal to <code>ARRAY_LENGTH</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">int</span> numAddresses = <a class="code" href="structbalst_1_1StackAddressUtil.html#a31eb649ae00ae8153ef1439f7c5d58a0">balst::StackAddressUtil::getStackAddresses</a>(
                                                           addresses,
                                                           ARRAY_LENGTH);
</pre></div><br/>
<br/>
 Then, we call <code>loadStackTraceFromAddressArray</code> to initialize the information in the stack-trace object, such as function names, source file names, and line numbers, if they are available. The optional argument, <code>demanglingPreferredFlag</code>, defaults to <code>true</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">int</span> rc = <a class="code" href="structbalst_1_1StackTraceUtil.html#a49aec9c2f714b82c32a79cd3aad65d7f">balst::StackTraceUtil::loadStackTraceFromAddressArray</a>(
                                                               &amp;stackTrace,
                                                               addresses,
                                                               numAddresses);
      assert(0 == rc);
</pre></div><br/>
<br/>
 Finally, we can print out the stack-trace object using <code>printFormatted</code>, or iterate through the stack-trace frames, printing them out one by one. In this example, we want instead to output only function names, and not line numbers, source file names, or library names, so we iterate through the stack-trace frames and print out only the properties we want. Note that if a string is unknown, it is represented as "", here we print it out as "--unknown--" to let the user see that the name was unresolved. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; stackTrace.<a class="code" href="classbalst_1_1StackTrace.html#a80c7ae5e281cc39bcec482d7f47fb974">length</a>(); ++i) {
          <span class="keyword">const</span> <a class="code" href="classbalst_1_1StackTraceFrame.html">balst::StackTraceFrame</a>&amp; frame = stackTrace[i];

          <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol = frame.<a class="code" href="classbalst_1_1StackTraceFrame.html#a4da2c3954739b6cf1092278027b78409">isSymbolNameKnown</a>()
                             ? frame.<a class="code" href="classbalst_1_1StackTraceFrame.html#ab2dcc44f1cefcc9eaee53504b72ff8f5">symbolName</a>().<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>()
                             : <span class="stringliteral">&quot;--unknown__&quot;</span>;
          bsl::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; symbol &lt;&lt; endl;
      }
  }
</pre></div><br/>
<br/>
 Running this example would produce the following output: <br/>
<br/>
<div class="fragment"><pre class="fragment"> (0): traceExample2()
 (1): recurseExample2(<span class="keywordtype">int</span>*)
 (2): recurseExample2(<span class="keywordtype">int</span>*)
 (3): recurseExample2(<span class="keywordtype">int</span>*)
 (4): recurseExample2(<span class="keywordtype">int</span>*)
 (5): recurseExample2(<span class="keywordtype">int</span>*)
 (6): main
 (7): _start
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_outputting_a_hex_stack_trace"></a> <a class="anchor" id="usage.example_3~3A_outputting_a_hex_stack_trace"></a> <a class="anchor" id="description.usage.example_3~3A_outputting_a_hex_stack_trace"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Outputting a Hex Stack Trace: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we demonstrate how to output return addresses from the stack to a stream in hex. Note that in this case the stack trace is never stored to a data object -- when the <code>operator&lt;&lt;</code> is passed a pointer to the <code>hexStackTrace</code> function, it calls the <code>hexStackTrace</code> function, which gathers the stack addresses and immediately streams them out. After the <code>operator&lt;&lt;</code> is finished, the stack addresses are no longer stored anywhere. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a routine <code>recurseExample3</code> which will recurse the specified <code>depth</code> times, then call <code>traceExample3</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> traceExample3();    <span class="comment">// forward declaration</span>

  <span class="keyword">static</span> <span class="keywordtype">void</span> recurseExample3(<span class="keywordtype">int</span> *depth)
      <span class="comment">// Recurse the specified &#39;depth&#39; number of times, then call</span>
      <span class="comment">// &#39;traceExample3&#39;, which will print a stack-trace.</span>
  {
      <span class="keywordflow">if</span> (--*depth &gt; 0) {
          recurseExample3(depth);
      }
      <span class="keywordflow">else</span> {
          traceExample3();
      }

      ++*depth;   <span class="comment">// Prevent compiler from optimizing tail recursion as a</span>
                  <span class="comment">// loop.</span>
  }

  <span class="keywordtype">void</span> traceExample3()
  {
</pre></div><br/>
<br/>
 Now, within <code>traceExample3</code>, we output the stack addresses in hex by streaming the function pointer <code>hexStackTrace</code> to <code>cout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      bsl::cout &lt;&lt; <a class="code" href="structbalst_1_1StackTraceUtil.html#af9a6cceea352c5fb34e85e24d5f9fa03">balst::StackTraceUtil::hexStackTrace</a> &lt;&lt; endl;
  }
</pre></div><br/>
<br/>
 Finally, the output appears as a collection of hex values streamed out separated by spaces, which can be translated to symbol names using tools outside of <code>balst</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"> 0x804f806 0x804f7dc 0x804f7d5 0x804f7d5 0x804f7d5 0x804fbea 0x341e9c
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:30 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
