<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlmt_sessionpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlmt_sessionpool<br/>
<small>
[<a class="el" href="group__btlmt.html">Package btlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide thread-enabled session-based IPv4 communication.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlmt.html">btlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Message Management and Delivery</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Implementing an Echo Server</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide thread-enabled session-based IPv4 communication </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlmt_1_1SessionPool.html">btlmt::SessionPool</a> </td><td>session manager  </td></tr>
<tr>
<td><a class="el" href="classbtlmt_1_1SessionPoolSessionIterator.html">btlmt::SessionPoolSessionIterator</a> </td><td>sessions iterator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlmt__session.html" title="Provide a pure protocol class for a session.">Component btlmt_session</a>, <a class="el" href="group__btlmt__asyncchannel.html" title="Provide a protocol for asynchronous IO operations.">Component btlmt_asyncchannel</a>, <a class="el" href="group__btlmt__channelpool.html" title="Provide thread-enabled stream-based IPv4 communication.">Component btlmt_channelpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-enabled asynchronous <code><a class="el" href="classbtlmt_1_1Session.html">btlmt::Session</a></code> manager of the IPV4-based byte stream communication sessions. The sessions are allocated automatically when the appropriate events occur, and destroyed based on user requests. A new session is allocated automatically when an incoming connection is accepted, by the <code><a class="el" href="classbtlmt_1_1SessionFactory.html">btlmt::SessionFactory</a></code> specified during the call to <code>listen</code>, or when a user explicitly requests a connection to a server, by a <code><a class="el" href="classbtlmt_1_1SessionFactory.html">btlmt::SessionFactory</a></code> specified during the call to <code>connect</code>. Session pool has both client-side (aka connector) and server-side (aka acceptor) facilities. The session pool manages efficient delivery of messages to/from the user based on configuration information supplied at construction. The states of individual messages are not reported; rather, session pool notifies the user when a session changes its state. It also notifies the user when the state of the pool is affected, and provides the classification of errors. The notification is done via asynchronous callbacks that can be invoked from any (managed) thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="message_management_and_delivery"></a> <a class="anchor" id="description.message_management_and_delivery"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Message Management and Delivery: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The session pool provides an efficient mechanism for the full-duplex delivery of messages trying to achieve fully parallel communication on a socket whenever possible. If a particular socket's system buffers are full, the messages are queued up to a certain (user-defined) limit, at which point an alert is generated and the user has the ability to explicitly clear the session's outgoing buffer or, by default, continue the transmission. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The session pool tries to achieve optimal performance by enabling zero-copy semantics whenever appropriate. On the read side, the message is either read into a local buffer (and subsequently copied by the user) or into a buffer that is subsequently handed to the user for accessing and subsequent deallocation. On the write side, if caching is needed, ownership of the message buffer is assumed and either the message is copied into the local buffer of the session or the address of the buffer is retained. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_an_echo_server"></a> <a class="anchor" id="usage.example_1~3A_implementing_an_echo_server"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_an_echo_server"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing an Echo Server: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example implements a simple echo server. This server accepts connections, reads what it receives right away from the network stream, sends it back and closes the connection. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To set up this server, users must create a concrete session class derived from <code><a class="el" href="classbtlmt_1_1Session.html">btlmt::Session</a></code> protocol, and a factory for creating instances of this concrete session type. <code>my_EchoSession</code> objects are created by a factory that must be derived from <code><a class="el" href="classbtlmt_1_1SessionFactory.html">btlmt::SessionFactory</a></code>. A <code>my_EchoSessionFactory</code> just allocates and deallocates sessions (with no pooling or allocation strategy). This is the simplest form of factory. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_echoserver.h</span>

                          <span class="comment">// ====================</span>
                          <span class="comment">// class my_EchoSession</span>
                          <span class="comment">// ====================</span>

 <span class="keyword">class </span>my_EchoSession : <span class="keyword">public</span> btlmt::Session {
     <span class="comment">// This class is a concrete implementation of the &#39;btlmt::Session&#39;</span>
     <span class="comment">// protocol to use along with &#39;my_EchoServer&#39; objects.</span>

     <span class="comment">// DATA</span>
     <a class="code" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a> *d_channel_p;<span class="comment">// underlying channel (held, not owned)</span>

     <span class="comment">// PRIVATE MANIPULATORS</span>
     <span class="keywordtype">void</span> readCb(<span class="keywordtype">int</span>         result,
                 <span class="keywordtype">int</span>        *numNeeded,
                 <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *blob,
                 <span class="keywordtype">int</span>         channelId);
         <span class="comment">// Read callback for session pool.</span>

   <span class="keyword">private</span>:
     <span class="comment">// NOT IMPLEMENTED</span>
     my_EchoSession(<span class="keyword">const</span> my_EchoSession&amp;);
     my_EchoSession&amp; operator=(<span class="keyword">const</span> my_EchoSession&amp;);

   <span class="keyword">public</span>:
     <span class="comment">// CREATORS</span>
     my_EchoSession(<a class="code" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a> *channel);
         <span class="comment">// Create a new &#39;my_EchoSession&#39; object for the specified &#39;channel&#39;.</span>

     ~my_EchoSession();
         <span class="comment">// Destroy this object.</span>

     <span class="comment">// MANIPULATORS</span>
     <span class="keyword">virtual</span> <span class="keywordtype">int</span> start();
         <span class="comment">// Begin the asynchronous operation of this session.</span>

     <span class="keyword">virtual</span> <span class="keywordtype">int</span> stop();
         <span class="comment">// Stop the operation of this session.</span>

     <span class="comment">// ACCESSORS</span>
     <span class="keyword">virtual</span> <a class="code" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a> *channel() <span class="keyword">const</span>;
         <span class="comment">// Return the channel associated with this session.</span>
  };

                      <span class="comment">// ===========================</span>
                      <span class="comment">// class my_EchoSessionFactory</span>
                      <span class="comment">// ===========================</span>

  <span class="keyword">class </span>my_EchoSessionFactory : <span class="keyword">public</span> btlmt::SessionFactory {
      <span class="comment">// This class is a concrete implementation of the</span>
      <span class="comment">// &#39;btlmt::SessionFactory&#39; that simply allocates &#39;my_EchoSession&#39;</span>
      <span class="comment">// objects.  No specific allocation strategy (such as pooling) is</span>
      <span class="comment">// implemented.</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p; <span class="comment">// memory allocator (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(my_EchoSessionFactory,
                                   <a class="code" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      my_EchoSessionFactory(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a new &#39;my_EchoSessionFactory&#39; object.  Optionally specify</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="keyword">virtual</span> ~my_EchoSessionFactory();
         <span class="comment">// Destroy this factory.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> allocate(<a class="code" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a>                    *channel,
                            <span class="keyword">const</span> <a class="code" href="classbtlmt_1_1SessionFactory.html#a3ee006af45b514cec8401775f28493b7">btlmt::SessionFactory::Callback</a>&amp;  cb);
         <span class="comment">// Asynchronously allocate a &#39;btlmt::Session&#39; object for the</span>
         <span class="comment">// specified &#39;channel&#39;, and invoke the specified &#39;cb&#39; with</span>
         <span class="comment">// this session.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<a class="code" href="classbtlmt_1_1Session.html">btlmt::Session</a> *session);
         <span class="comment">// Deallocate the specified &#39;session&#39;.</span>
  };
</pre></div><br/>
<br/>
 The implementations of those session and factory types are rather straightforward. <code>readCb</code> will be called when the first byte is received. It is in this method that the echo logic is implemented. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_echoserver.cpp</span>

                          <span class="comment">// --------------------</span>
                          <span class="comment">// class my_EchoSession</span>
                          <span class="comment">// --------------------</span>

  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keywordtype">void</span> my_EchoSession::readCb(<span class="keywordtype">int</span>         result,
                              <span class="keywordtype">int</span>        *numNeeded,
                              <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *blob,
                              <span class="keywordtype">int</span>         channelId)
  {
      <span class="keywordflow">if</span> (result) {
          d_channel_p-&gt;close();
          <span class="keywordflow">return</span>;
      }

      ASSERT(numNeeded);
      ASSERT(0 &lt; blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>());

      ASSERT(0 == d_channel_p-&gt;write(*blob));

      *numNeeded   = 1;
      <a class="code" href="structbtlb_1_1BlobUtil.html#ac9cdc28e292cb230241eb411ebff19f8">btlb::BlobUtil::erase</a>(blob, 0, blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>());

      d_channel_p-&gt;close(); <span class="comment">// close connection.</span>
  }

  <span class="comment">// CREATORS</span>
  my_EchoSession::my_EchoSession(<a class="code" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a> *channel)
  : d_channel_p(channel)
  {
  }

  my_EchoSession::~my_EchoSession()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">int</span> my_EchoSession::start()
  {
      <span class="keywordflow">return</span> d_channel_p-&gt;read(
                              1,
                              <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoSession::readCb,
                              <span class="keyword">this</span>));
  }

  <span class="keywordtype">int</span> my_EchoSession::stop()
  {
      d_channel_p-&gt;close();
      <span class="keywordflow">return</span> 0;
  }

  <span class="comment">// ACCESSORS</span>
  <a class="code" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a> *my_EchoSession::channel()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_channel_p;
  }

                      <span class="comment">// ---------------------------</span>
                      <span class="comment">// class my_EchoSessionFactory</span>
                      <span class="comment">// ---------------------------</span>

  <span class="comment">// CREATORS</span>
  my_EchoSessionFactory::my_EchoSessionFactory(
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
  }

  my_EchoSessionFactory::~my_EchoSessionFactory()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span>
  my_EchoSessionFactory::allocate(
                            <a class="code" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a>                    *channel,
                            <span class="keyword">const</span> <a class="code" href="classbtlmt_1_1SessionFactory.html#a3ee006af45b514cec8401775f28493b7">btlmt::SessionFactory::Callback</a>&amp;  callback)
  {
      my_EchoSession *session = <span class="keyword">new</span> (*d_allocator_p) my_EchoSession(channel);
      callback(0, session);
  }

  <span class="keywordtype">void</span>
  my_EchoSessionFactory::deallocate(<a class="code" href="classbtlmt_1_1Session.html">btlmt::Session</a> *session)
  {
      d_allocator_p-&gt;deleteObject(session);
  }
</pre></div><br/>
<br/>
 We now have all the pieces needed to design and implement our echo server. The server itself owns an instance of the above-defined factory. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_echoserver.h (continued)</span>

                      <span class="comment">// ===================</span>
                      <span class="comment">// class my_EchoServer</span>
                      <span class="comment">// ===================</span>

  <span class="keyword">class </span>my_EchoServer {
      <span class="comment">// This class implements a multi-user multi-threaded echo server.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbtlmt_1_1ChannelPoolConfiguration.html">btlmt::ChannelPoolConfiguration</a>  d_config;         <span class="comment">// pool</span>
                                                         <span class="comment">// configuration</span>

      <a class="code" href="classbtlmt_1_1SessionPool.html">btlmt::SessionPool</a>              *d_sessionPool_p;  <span class="comment">// managed pool</span>
                                                         <span class="comment">// (owned)</span>

      my_EchoSessionFactory            d_sessionFactory; <span class="comment">// my_EchoSession</span>
                                                         <span class="comment">// factory</span>

      <span class="keywordtype">int</span>                              d_portNumber;     <span class="comment">// port on which</span>
                                                         <span class="comment">// this server is</span>
                                                         <span class="comment">// listening</span>

      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>                    *d_coutLock_p;     <span class="comment">// mutex protecting</span>
                                                         <span class="comment">// bsl::cout</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                *d_allocator_p;    <span class="comment">// memory allocator</span>
                                                         <span class="comment">// (held)</span>

      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> poolStateCb(<span class="keywordtype">int</span> reason, <span class="keywordtype">int</span> source, <span class="keywordtype">void</span> *userData);
          <span class="comment">// Indicates the status of the whole pool.</span>

      <span class="keywordtype">void</span> sessionStateCb(<span class="keywordtype">int</span>             state,
                          <span class="keywordtype">int</span>             handle,
                          <a class="code" href="classbtlmt_1_1Session.html">btlmt::Session</a> *session,
                          <span class="keywordtype">void</span>           *userData);
          <span class="comment">// Per-session state.</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_EchoServer(<span class="keyword">const</span> my_EchoServer&amp; original);
      my_EchoServer&amp; operator=(<span class="keyword">const</span> my_EchoServer&amp; rhs);

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(my_EchoServer,
                                   <a class="code" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      my_EchoServer(<a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>     *coutLock,
                    <span class="keywordtype">int</span>               portNumber,
                    <span class="keywordtype">int</span>               numConnections,
                    <span class="keywordtype">bool</span>              reuseAddressFlag,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an echo server that listens for incoming connections on</span>
          <span class="comment">// the specified &#39;portNumber&#39; managing up to the specified</span>
          <span class="comment">// &#39;numConnections&#39; simultaneous connections.  Pass the specified</span>
          <span class="comment">// &#39;reuseAddressFlag&#39; to the set the &#39;REUSE_ADDRESS&#39; socket option</span>
          <span class="comment">// to the listening socket.  The echo server will use the</span>
          <span class="comment">// specified &#39;coutLock&#39; to synchronize access to the standard</span>
          <span class="comment">// output.  Optionally specify a &#39;basicAllocator&#39; used to supply</span>
          <span class="comment">// memory.  If &#39;basicAllocator&#39; is 0, the currently installed</span>
          <span class="comment">// default allocator is used.  The behavior is undefined if</span>
          <span class="comment">// &#39;coutLock&#39; is 0.</span>

      ~my_EchoServer();
          <span class="comment">// Destroy this server.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">const</span> <a class="code" href="classbtlmt_1_1SessionPool.html">btlmt::SessionPool</a>&amp; pool() <span class="keyword">const</span>;
          <span class="comment">// Return a non-modifiable reference to the session pool used by</span>
          <span class="comment">// this echo server.</span>

      <span class="keywordtype">int</span> portNumber() <span class="keyword">const</span>;
          <span class="comment">// Return the port number on which this server is listening.</span>
  };
</pre></div><br/>
<br/>
 Note that this example server prints information depending on implicitly-defined static variables and therefore must use a mutex to synchronize access to <code>bsl::cout</code>. A production application should use a proper logging mechanism instead such as the <code>bael</code> logger. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_echoserver.h (continued)</span>

                          <span class="comment">// -------------------</span>
                          <span class="comment">// class my_EchoServer</span>
                          <span class="comment">// -------------------</span>

  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keywordtype">void</span> my_EchoServer::poolStateCb(<span class="keywordtype">int</span> reason, <span class="keywordtype">int</span> source, <span class="keywordtype">void</span> *userData)
  {
      <span class="keywordflow">if</span> (veryVerbose) {
          d_coutLock_p-&gt;lock();
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Pool state changed: (&quot;</span> &lt;&lt; reason &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; source
                    &lt;&lt; <span class="stringliteral">&quot;) &quot;</span> &lt;&lt; bsl::endl;
          d_coutLock_p-&gt;unlock();
      }
  }

  <span class="keywordtype">void</span> my_EchoServer::sessionStateCb(<span class="keywordtype">int</span>             state,
                                     <span class="keywordtype">int</span>             handle,
                                     <a class="code" href="classbtlmt_1_1Session.html">btlmt::Session</a> *session,
                                     <span class="keywordtype">void</span>           *userData) {

      <span class="keywordflow">switch</span>(state) {
        <span class="keywordflow">case</span> btlmt::SessionPool::SESSION_DOWN: {
            <span class="keywordflow">if</span> (veryVerbose) {
                d_coutLock_p-&gt;lock();
                bsl::cout &lt;&lt; <span class="stringliteral">&quot;Client from &quot;</span>
                          &lt;&lt; session-&gt;<a class="code" href="classbtlmt_1_1Session.html#ae949c992b618b3884d55fbe6f8d3234e">channel</a>()-&gt;peerAddress()
                          &lt;&lt; <span class="stringliteral">&quot; has disconnected.&quot;</span>
                          &lt;&lt; bsl::endl;
                d_coutLock_p-&gt;unlock();
            }
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> btlmt::SessionPool::SESSION_UP: {
            <span class="keywordflow">if</span> (veryVerbose) {
                d_coutLock_p-&gt;lock();
                bsl::cout &lt;&lt; <span class="stringliteral">&quot;Client connected from &quot;</span>
                          &lt;&lt; session-&gt;<a class="code" href="classbtlmt_1_1Session.html#ae949c992b618b3884d55fbe6f8d3234e">channel</a>()-&gt;peerAddress()
                          &lt;&lt; bsl::endl;
                d_coutLock_p-&gt;unlock();
            }
        } <span class="keywordflow">break</span>;
      }
  }

  <span class="comment">// CREATORS</span>
  my_EchoServer::my_EchoServer(<a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>     *lock,
                               <span class="keywordtype">int</span>               portNumber,
                               <span class="keywordtype">int</span>               numConnections,
                               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_sessionFactory(basicAllocator)
  , d_coutLock_p(lock)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
      d_config.setMaxThreads(4);                  <span class="comment">// 4 I/O threads</span>
      d_config.setMaxConnections(numConnections);
      d_config.setMetricsInterval(10.0);          <span class="comment">// seconds</span>
      d_config.setWriteQueueWatermarks(0, 1&lt;&lt;10); <span class="comment">// 1Mb</span>
      d_config.setIncomingMessageSizes(1, 100, 1024);

      <span class="keyword">typedef</span> <a class="code" href="classbtlmt_1_1SessionPool.html#a99f7e1aac1e835c18b1ad25682c6ec75">btlmt::SessionPool::SessionPoolStateCallback</a> SessionStateCb;

      SessionStateCb poolStateCb = <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(
                                                 &amp;my_EchoServer::poolStateCb,
                                                 <span class="keyword">this</span>);

      d_sessionPool_p = <span class="keyword">new</span> (*d_allocator_p) <a class="code" href="classbtlmt_1_1SessionPool.html">btlmt::SessionPool</a>(
                                                             d_config,
                                                             poolStateCb,
                                                             basicAllocator);

      <a class="code" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">btlmt::SessionPool::SessionStateCallback</a> sessionStateCb =
                       <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoServer::sessionStateCb,
                                              <span class="keyword">this</span>);

      ASSERT(0 == d_sessionPool_p-&gt;start());
      <span class="keywordtype">int</span> handle;
      ASSERT(0 == d_sessionPool_p-&gt;listen(&amp;handle,
                                          sessionStateCb,
                                          portNumber,
                                          numConnections,
                                          &amp;d_sessionFactory));

      d_portNumber = d_sessionPool_p-&gt;portNumber(handle);
  }

  my_EchoServer::~my_EchoServer()
  {
      d_sessionPool_p-&gt;stop();
      d_allocator_p-&gt;deleteObject(d_sessionPool_p);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">const</span> <a class="code" href="classbtlmt_1_1SessionPool.html">btlmt::SessionPool</a>&amp; my_EchoServer::pool()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> *d_sessionPool_p;
  }

  <span class="keywordtype">int</span> my_EchoServer::portNumber()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_portNumber;
  }
</pre></div><br/>
<br/>
 We can implement a simple "Hello World!" example to exercise our echo server. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main() {

      <span class="keyword">enum</span> {
          BACKLOG = 5,
          REUSE   = 1
      };

      my_EchoServer echoServer(&amp;coutMutex, 0, BACKLOG, REUSE);

      <a class="code" href="classbtlso_1_1InetStreamSocketFactory.html">btlso::InetStreamSocketFactory&lt;btlso::IPv4Address&gt;</a> factory;
      <a class="code" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket&lt;btlso::IPv4Address&gt;</a> *socket = factory.<a class="code" href="classbtlso_1_1InetStreamSocketFactory.html#a8e5f246da87e0d1c34f9b287a0b11c54">allocate</a>();

      <span class="keyword">const</span> <span class="keywordtype">char</span> STRING[] = <span class="stringliteral">&quot;Hello World!&quot;</span>;

      <span class="keyword">const</span> <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> ADDRESS(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, echoServer.portNumber());
      assert(0 == socket-&gt;<a class="code" href="classbtlso_1_1StreamSocket.html#ab9ba5360e01c83b23deb820b22e83a80">connect</a>(ADDRESS));
      assert(<span class="keyword">sizeof</span>(STRING) == socket-&gt;<a class="code" href="classbtlso_1_1StreamSocket.html#ae37bd2f372b33e69824a67cc863ac4f0">write</a>(STRING, <span class="keyword">sizeof</span>(STRING)));

      <span class="keywordtype">char</span> readBuffer[<span class="keyword">sizeof</span>(STRING)];
      assert(<span class="keyword">sizeof</span>(STRING) == socket-&gt;<a class="code" href="classbtlso_1_1StreamSocket.html#aded1055cfd215bd6ae9cfd1723559a4a">read</a>(readBuffer, <span class="keyword">sizeof</span>(STRING)));
      assert(0 == bsl::strcmp(readBuffer, STRING));

      factory.<a class="code" href="classbtlso_1_1InetStreamSocketFactory.html#a0d04e0214dc3075539e9b318120274ca">deallocate</a>(socket);
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
