<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslalg_autoarraydestructor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_autoarraydestructor<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a proctor for destroying arrays.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Managing an Array Under Construction</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a proctor for destroying arrays. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslalg_1_1AutoArrayDestructor.html">bslalg::AutoArrayDestructor</a> </td><td>exception-neutrality proctor for arrays  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__autodestructor.html" title="Provide a range proctor to manage an array of objects.">Component bslma_autodestructor</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a proctor object to manage a contiguous (in-place) sequence of otherwise-unmanaged instances of a user-defined type. If not explicitly released, all objects managed by the proctor object are automatically destroyed by the proctor's destructor, using the <code>bslalg_arraydestructionprimitives</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In most instances, <code><a class="el" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor</a></code> can also be used, but this component is more useful in cases where it is simpler to think in terms of two pointers at the ends of the array being managed, rather than an origin and offset. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_managing_an_array_under_construction"></a> <a class="anchor" id="usage.example_1~3A_managing_an_array_under_construction"></a> <a class="anchor" id="description.usage.example_1~3A_managing_an_array_under_construction"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Managing an Array Under Construction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In most instances, the use of a <code><a class="el" href="classbslalg_1_1AutoArrayDestructor.html">bslalg::AutoArrayDestructor</a></code> could be handled by a <code><a class="el" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a></code>, but sometimes it is conceptually clearer to frame the problem in terms of a pair of pointers rather than a pointer and an offset. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have a class, <code>UsageType</code> that allocates a block of memory upon construction, and whose constructor takes a <code>char</code>. Suppose we want to create an array of elements of such objects in an exception-safe manner. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create the type <code>UsageType</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">                               <span class="comment">// ===============</span>
                               <span class="comment">// class UsageType</span>
                               <span class="comment">// ===============</span>

  <span class="keyword">class </span>UsageType {
      <span class="comment">// This test type contains a &#39;char&#39; in some allocated storage.  It has</span>
      <span class="comment">// no traits other than using a &#39;bslma&#39; allocator.</span>

      <span class="keywordtype">char</span>             *d_data_p;         <span class="comment">// managed single char</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;    <span class="comment">// allocator (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> UsageType(<span class="keywordtype">char</span> c, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_data_p(0)
      , d_allocator_p(bslma::Default::allocator(basicAllocator))
      {
          d_data_p  = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
          *d_data_p = c;
      }

      ~UsageType()
      {
          *d_data_p = <span class="charliteral">&#39;_&#39;</span>;
          d_allocator_p-&gt;deallocate(d_data_p);
          d_data_p = 0;
      }

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">char</span> datum()<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">return</span> *d_data_p;
      }
  };

  <span class="keyword">namespace </span>BloombergLP {
  <span class="keyword">namespace </span>bslma {

  <span class="keyword">template</span> &lt;&gt;
  <span class="keyword">struct </span>UsesBslmaAllocator&lt;UsageType&gt; : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> {};

  }  <span class="comment">// close package namespace</span>
  }  <span class="comment">// close enterprise namespace</span>
</pre></div><br/>
<br/>
 Then, in <code>main</code>, we create a <code>TestAllocator</code> to supply memory (and to verify that no memory is leaked): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta;
</pre></div><br/>
<br/>
 Next, we create the pointer for our array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  UsageType *array;
</pre></div><br/>
<br/>
 Then, we declare a string of characterss we will use to initialize the <code>UsageType</code> objects in our array. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span>   *DATA = <span class="stringliteral">&quot;Hello&quot;</span>;
  <span class="keyword">const</span> <span class="keywordtype">size_t</span>  DATA_LEN = std::strlen(DATA);
</pre></div><br/>
<br/>
 Next, we verify that even right after exceptions have been thrown and caught, no memory is outstanding: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == ta.<a class="code" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a>());
</pre></div><br/>
<br/>
 Then, we allocate our array and create a guard to free it if a subsequent allocation throws an exception: <br/>
<br/>
<div class="fragment"><pre class="fragment">  array = (UsageType *) ta.<a class="code" href="classbslma_1_1TestAllocator.html#adadeba443e1ea37730a9cf936a600e56">allocate</a>(DATA_LEN * <span class="keyword">sizeof</span>(UsageType));
  <a class="code" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor&lt;bslma::Allocator&gt;</a> arrayProctor(array, &amp;ta);
</pre></div><br/>
<br/>
 Next, we establish an <code>AutoArrayDestructor</code> on <code>array</code> to destroy any valid elements in <code>array</code> if an exception is thrown: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslalg_1_1AutoArrayDestructor.html">bslalg::AutoArrayDestructor&lt;UsageType&gt;</a> arrayElementProctor(array, array);
</pre></div><br/>
<br/>
 Notice that we pass <code>arrayElementProctor</code> pointers to the beginning and end of the range to be guarded (we start with an empty range since no elements have been constructed yet). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we iterate through the valid chars in <code>DATA</code> and use them to construct the elements of the array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  UsageType *resultElement = array;
  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *nextChar = DATA; *nextChar; ++nextChar) {
</pre></div><br/>
<br/>
 Next, construct the next element of <code>array</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">new</span> (resultElement++) UsageType(*nextChar, &amp;ta);
</pre></div><br/>
<br/>
 Now, move the end of <code>arrayElementProctor</code> to cover the most recently constructed element: <br/>
<br/>
<div class="fragment"><pre class="fragment">      arrayElementProctor.moveEnd(1);
  }
</pre></div><br/>
<br/>
 At this point, we have successfully created our array. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, release the guards so they won't destroy our work when they go out of scope: <br/>
<br/>
<div class="fragment"><pre class="fragment">  arrayProctor.release();
  arrayElementProctor.release();
</pre></div><br/>
<br/>
 Next, exit the exception testing block: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, verify that the array we have created is as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="charliteral">&#39;H&#39;</span> == array[0].datum());
  assert(<span class="charliteral">&#39;e&#39;</span> == array[1].datum());
  assert(<span class="charliteral">&#39;l&#39;</span> == array[2].datum());
  assert(<span class="charliteral">&#39;l&#39;</span> == array[3].datum());
  assert(<span class="charliteral">&#39;o&#39;</span> == array[4].datum());
</pre></div><br/>
<br/>
 Finally, destroy &amp; free our work and verify that no memory is leaked: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; DATA_LEN; ++i) {
      array[i].~UsageType();
  }
  ta.<a class="code" href="classbslma_1_1TestAllocator.html#aa3d86f105cc1a797cfa5ad9e2bbf6825">deallocate</a>(array);

  assert(0 == ta.<a class="code" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a>());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:51 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
