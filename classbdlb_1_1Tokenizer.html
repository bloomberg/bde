<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlb::Tokenizer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlb.html">bdlb</a>      </li>
      <li><a class="el" href="classbdlb_1_1Tokenizer.html">bdlb::Tokenizer</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlb::Tokenizer Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlb::Tokenizer" -->
<p><code>#include &lt;<a class="el" href="bdlb__tokenizer_8h_source.html">bdlb_tokenizer.h</a>&gt;</code></p>

<p><a href="classbdlb_1_1Tokenizer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a8695d2250cbcaa7ac9cc342df1db2085">iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a91fe46b31ea2d70222e3a694da17a56b">Tokenizer</a> (const char *input, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;soft)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#aa1334210891d08ac79e68de14f76baee">Tokenizer</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;input, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;soft)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a0f98a0827a3b270809ec1728e5e735f4">Tokenizer</a> (const char *input, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;soft, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;hard)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#aace902c791f6f77aaea01818fcc107ae">Tokenizer</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;input, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;soft, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;hard)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a1c611c2f22b33ccfcabfb93041b37aed">~Tokenizer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#ac5b03597dc90b606cb4198b1c25fdc57">operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#aea675a6c0c2fb74d82be22acb3b59305">reset</a> (const char *input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#ae337b46515da8970cf9abdeed012f8a5">reset</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#afd63343c7876cd62ed82e25194bd2023">hasPreviousSoft</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a96baa8f13310332451b777d12d61e2fb">hasTrailingSoft</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a67298b873c64e34d10c29d21ea2be165">isPreviousHard</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a3b164e1871365240c90806cb0a0784e5">isTrailingHard</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a88c5ab415a49919c25759edbd4226001">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a1d57905f53dd5a15d35b8fd6ba9ed682">previousDelimiter</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a7c145b83da76224398f295fa05ba547a">token</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a0c47e2f27bf45c6d470bdea4785407e3">trailingDelimiter</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1TokenizerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#a6ae1b2b27aea8269f0852c9bd1dea9a5">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1TokenizerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html#aa5fec07a745a6f7aa13fc6a7229e6e92">end</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides (read-only) sequential access to tokens delimited by two user-supplied character sets consisting, respectively, of <em>soft</em> and <em>hard</em> delimiters characters. Access to the previous and current (trailing) delimiter, as well as to the current token itself, is provided efficiently via <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a8695d2250cbcaa7ac9cc342df1db2085"></a><!-- doxytag: member="bdlb::Tokenizer::iterator" ref="a8695d2250cbcaa7ac9cc342df1db2085" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a> <a class="el" href="classbdlb_1_1TokenizerIterator.html">bdlb::Tokenizer::iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a91fe46b31ea2d70222e3a694da17a56b"></a><!-- doxytag: member="bdlb::Tokenizer::Tokenizer" ref="a91fe46b31ea2d70222e3a694da17a56b" args="(const char *input, const bslstl::StringRef &amp;soft)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlb::Tokenizer::Tokenizer </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>soft</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1334210891d08ac79e68de14f76baee"></a><!-- doxytag: member="bdlb::Tokenizer::Tokenizer" ref="aa1334210891d08ac79e68de14f76baee" args="(const bslstl::StringRef &amp;input, const bslstl::StringRef &amp;soft)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlb::Tokenizer::Tokenizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>soft</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f98a0827a3b270809ec1728e5e735f4"></a><!-- doxytag: member="bdlb::Tokenizer::Tokenizer" ref="a0f98a0827a3b270809ec1728e5e735f4" args="(const char *input, const bslstl::StringRef &amp;soft, const bslstl::StringRef &amp;hard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlb::Tokenizer::Tokenizer </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>soft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hard</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aace902c791f6f77aaea01818fcc107ae"></a><!-- doxytag: member="bdlb::Tokenizer::Tokenizer" ref="aace902c791f6f77aaea01818fcc107ae" args="(const bslstl::StringRef &amp;input, const bslstl::StringRef &amp;soft, const bslstl::StringRef &amp;hard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlb::Tokenizer::Tokenizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>soft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hard</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a></code> object bound to the specified sequence of <code>input</code> characters having the specified set of (unique) <code>soft</code> delimiter characters to be used to separate <em>tokens</em> (i.e., maximal sequence of non-delimiter characters) in <code>input</code>. Optionally specify a disjoint set of (unique) <code>hard</code> delimiter characters to be used to explicitly terminate tokens. Delimiters within <code>input</code> consist of a maximal sequence of one or more delimiter characters, at most one of which may be <em>hard</em>; when there is a contiguous sequence of delimiter characters containing two or more <em>hard</em> delimiter characters in <code>input</code>, any intervening <em>soft</em> delimiter characters are associated with the previous (<em>hard</em>) delimiter. Any leading soft delimiter characters -- i.e., those preceding the first <em>token</em> or <em>hard</em> delimiter character (referred to as the <em>leader</em>) -- are available immediately after construction via the <code>previousDelimiter</code> method. The behavior is undefined unless all supplied delimiter characters are unique. Note that the behavior is also undefined if this object is used in any way (other than to reset or destroy it) after its underlying <code>input</code> string is modified. Also note that the current token and (trailing) delimiter may be accessed only while this object is in the valid state; however, the previous delimiter (or <em>leader</em>) is always accessible. Finally note that all token and delimiter strings are returned as references into the underlying <code>input</code> string, and hence remain valid so long as that string is not modified or destroyed -- irrespective of the state (or even the existence) of this object. </p>

</div>
</div>
<a class="anchor" id="a1c611c2f22b33ccfcabfb93041b37aed"></a><!-- doxytag: member="bdlb::Tokenizer::~Tokenizer" ref="a1c611c2f22b33ccfcabfb93041b37aed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlb::Tokenizer::~Tokenizer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac5b03597dc90b606cb4198b1c25fdc57"></a><!-- doxytag: member="bdlb::Tokenizer::operator++" ref="ac5b03597dc90b606cb4198b1c25fdc57" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a>&amp; bdlb::Tokenizer::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the iteration state of this object to refer to the next sequence of previous delimiter, current token, and current (trailing) delimiter in the underlying input sequence, and return a reference providing modifiable access to this object. The current delimiter reference becomes the previous one. If there is another token remaining in the input, the current token and delimiter are updated to refer to the respective new token and (trailing) delimiter values -- either of which (but not both) might be empty. The behavior is undefined unless the iteration state of this object is initially valid, or if the underlying input has been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="aea675a6c0c2fb74d82be22acb3b59305"></a><!-- doxytag: member="bdlb::Tokenizer::reset" ref="aea675a6c0c2fb74d82be22acb3b59305" args="(const char *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlb::Tokenizer::reset </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae337b46515da8970cf9abdeed012f8a5"></a><!-- doxytag: member="bdlb::Tokenizer::reset" ref="ae337b46515da8970cf9abdeed012f8a5" args="(const bslstl::StringRef &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlb::Tokenizer::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rebind this object to refer to the specified sequence of <code>input</code> characters. The state of the tokenizer following this call is <em>as</em> <em>if</em> it had been constructed with <code>input</code> and its current sets of <em>soft</em> and <em>hard</em> delimiter characters. Note that the behavior is undefined if this object is used in any way (other than to reset or destroy it) after its underlying <code>input</code> string is modified. </p>

</div>
</div>
<a class="anchor" id="afd63343c7876cd62ed82e25194bd2023"></a><!-- doxytag: member="bdlb::Tokenizer::hasPreviousSoft" ref="afd63343c7876cd62ed82e25194bd2023" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::Tokenizer::hasPreviousSoft </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the previous delimiter (or <em>leader</em>) contains a <em>soft</em> delimiter character, and <code>false</code> otherwise. The behavior is undefined if the underlying input itself has been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="a96baa8f13310332451b777d12d61e2fb"></a><!-- doxytag: member="bdlb::Tokenizer::hasTrailingSoft" ref="a96baa8f13310332451b777d12d61e2fb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::Tokenizer::hasTrailingSoft </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the current (trailing) delimiter contains a <em>soft</em> delimiter character, and <code>false</code> otherwise. The behavior is undefined if the iteration state of this object is initially invalid, or if the underlying input itself has been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="a67298b873c64e34d10c29d21ea2be165"></a><!-- doxytag: member="bdlb::Tokenizer::isPreviousHard" ref="a67298b873c64e34d10c29d21ea2be165" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::Tokenizer::isPreviousHard </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the previous delimiter contains a <em>hard-delimiter</em> character, and <code>false</code> otherwise. The behavior is undefined if the underlying input itself has been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="a3b164e1871365240c90806cb0a0784e5"></a><!-- doxytag: member="bdlb::Tokenizer::isTrailingHard" ref="a3b164e1871365240c90806cb0a0784e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::Tokenizer::isTrailingHard </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the current (trailing) delimiter contains a <em>hard</em> delimiter character, and <code>false</code> otherwise. The behavior is undefined if the iteration state of this object is initially invalid, or if the underlying input itself has been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="a88c5ab415a49919c25759edbd4226001"></a><!-- doxytag: member="bdlb::Tokenizer::isValid" ref="a88c5ab415a49919c25759edbd4226001" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::Tokenizer::isValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the iteration state of this object is valid, and <code>false</code> otherwise. Note that the behavior of advancing the iteration state as well as accessing the current token or (trailing) delimiter is undefined unless the current iteration state of this object is valid. </p>

</div>
</div>
<a class="anchor" id="a1d57905f53dd5a15d35b8fd6ba9ed682"></a><!-- doxytag: member="bdlb::Tokenizer::previousDelimiter" ref="a1d57905f53dd5a15d35b8fd6ba9ed682" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> bdlb::Tokenizer::previousDelimiter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable previous delimiter (or <em>leader</em>) in the input string. The behavior is undefined unless the underlying input has been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="a7c145b83da76224398f295fa05ba547a"></a><!-- doxytag: member="bdlb::Tokenizer::token" ref="a7c145b83da76224398f295fa05ba547a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> bdlb::Tokenizer::token </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable current token (i.e., maximal sequence of non-delimiter characters) in the input string. The returned reference remains valid so long as the underlying input is not modified or destroyed -- irrespective of the state (or existence) of this object. The behavior is undefined unless the iteration state of this object is initially valid, or if the underlying input has been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="a0c47e2f27bf45c6d470bdea4785407e3"></a><!-- doxytag: member="bdlb::Tokenizer::trailingDelimiter" ref="a0c47e2f27bf45c6d470bdea4785407e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> bdlb::Tokenizer::trailingDelimiter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable current (trailing) delimiter (maximal sequence of one or more delimiter characters containing at most one <em>hard</em> delimiter character) in the input string. The returned reference remains valid so long as the underlying input is not modified or destroyed -- irrespective of the state (or existence) of this object. The behavior is undefined unless the iteration state of this object is initially valid, or if the underlying input has been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="a6ae1b2b27aea8269f0852c9bd1dea9a5"></a><!-- doxytag: member="bdlb::Tokenizer::begin" ref="a6ae1b2b27aea8269f0852c9bd1dea9a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1TokenizerIterator.html">iterator</a> bdlb::Tokenizer::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator referring to the first token in this object's input string (the past-the-end iterator if this object iteration state is initially invalid). This reference remains valid as long as the underlying input has not been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<a class="anchor" id="aa5fec07a745a6f7aa13fc6a7229e6e92"></a><!-- doxytag: member="bdlb::Tokenizer::end" ref="aa5fec07a745a6f7aa13fc6a7229e6e92" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1TokenizerIterator.html">iterator</a> bdlb::Tokenizer::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator referring to position beyond the last token in this object's input string. This reference remains valid as long as the underlying input has not been modified or destroyed since this object was most recently reset (or created). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlb__tokenizer_8h_source.html">bdlb_tokenizer.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:12 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
