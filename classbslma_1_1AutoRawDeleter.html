<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Class bslma::AutoRawDeleter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslma.html">bslma</a>      </li>
      <li><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter&lt; TYPE, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslma::AutoRawDeleter&lt; TYPE, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslma::AutoRawDeleter" -->
<p><code>#include &lt;<a class="el" href="bslma__autorawdeleter_8h_source.html">bslma_autorawdeleter.h</a>&gt;</code></p>

<p><a href="classbslma_1_1AutoRawDeleter-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1AutoRawDeleter.html#a21c29ed94cd9ec8a6102d15955a92f1e">AutoRawDeleter</a> (TYPE **origin, ALLOCATOR *allocator, int length=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1AutoRawDeleter.html#a1ea98415bb99ccfeae6c392b7cc22708">~AutoRawDeleter</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1AutoRawDeleter.html#a14ed55f483b1c6b28350df1f2b07a53d">operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1AutoRawDeleter.html#ad2c59bfc2d87ac6f8df490a83be46dea">operator--</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1AutoRawDeleter.html#ac9eba7f659e04b0140a2e621ea688618">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1AutoRawDeleter.html#a549f962b207498a850b5533a428a7ec9">reset</a> (TYPE **origin)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1AutoRawDeleter.html#abc5d649c34d52d3a491b3f86edfd0ae8">setLength</a> (int length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1AutoRawDeleter.html#a2c66f9fcb4dbc6c9eca7074ec673ff5d">length</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE, class ALLOCATOR&gt;<br/>
 class bslma::AutoRawDeleter&lt; TYPE, ALLOCATOR &gt;</h3>

<p>This class implements a range proctor that, unless its <code>release</code> method has previously been invoked, automatically deletes the contiguous sequence of managed objects upon destruction by iterating on each (managed) object, first invoking the object's destructor, and then free memory by invoking the <code>deallocate</code> method of an allocator (or pool) of parameterized <code>ALLOCATOR</code> type supplied to it at construction. The sequence of managed objects of parameterized <code>TYPE</code> must have been created using memory provided by this allocator (or pool), which must remain valid throughout the lifetime of this range proctor. Note that when the length of this object is non-zero, it must refer to a non-null array of objects. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a21c29ed94cd9ec8a6102d15955a92f1e"></a><!-- doxytag: member="bslma::AutoRawDeleter::AutoRawDeleter" ref="a21c29ed94cd9ec8a6102d15955a92f1e" args="(TYPE **origin, ALLOCATOR *allocator, int length=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>&lt; TYPE, ALLOCATOR &gt;::<a class="el" href="classbslma_1_1AutoRawDeleter.html">AutoRawDeleter</a> </td>
          <td>(</td>
          <td class="paramtype">TYPE **&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an auto raw deleter to manage an array of objects at the specified <code>origin</code>, and that uses the specified <code>allocator</code> to delete the sequence of objects managed by this range proctor (if not released -- see <code>release</code>) upon destruction. Optionally specify <code>length</code> to define its range, which by default is empty (i.e., <code>length = 0</code>). The sequence of objects may extend in either direction from <code>origin</code>. A positive <code>length</code> represents the sequence of objects starting at <code>origin</code> and extending "up" to <code>length</code> (<em>not</em> including the object at the index position <code>origin + length</code>). A negative <code>length</code> represents the sequence of objects starting at one position below <code>origin</code> and extending "down" to the absolute value of <code>length</code> (including the object at index position <code>origin + length</code>). If <code>length</code> is 0, then this range proctor manages no objects. If <code>origin</code> is non-zero, all objects within the proctored range (if any) must be constructed using memory supplied by <code>allocator</code>. The behavior is undefined unless <code>allocator</code> is non-zero, and, if <code>origin</code> is 0, 'length is also 0. Note that when <code>length</code> is non-positive, the object at the origin is <em>not</em> managed by this range proctor. For example, if <code>origin</code> is at the index position 2, a <code>length</code> of 2 signifies that the objects at positions 2 and 3 are managed, whereas a <code>length</code> of -2 signifies that the objects at positions 0 and 1 are managed: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">             length = -2                            length = 2
             |&lt;-----&gt;|                              |&lt;-----&gt;|
              ___ ___ ___ ___ ___            ___ ___ ___ ___ ___
             | 0 | 1 | 2 | 3 | 4 |          | 0 | 1 | 2 | 3 | 4 |
             `===^===^===^===^===<span class="stringliteral">&#39;          `===^===^===^===^===&#39;</span>
                     ^------------ origin           ^------------ origin
</pre></div><p><br/>
<br/>
 </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="a1ea98415bb99ccfeae6c392b7cc22708"></a><!-- doxytag: member="bslma::AutoRawDeleter::~AutoRawDeleter" ref="a1ea98415bb99ccfeae6c392b7cc22708" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>&lt; TYPE, ALLOCATOR &gt;::~<a class="el" href="classbslma_1_1AutoRawDeleter.html">AutoRawDeleter</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this range proctor and delete the contiguous sequence of objects it manages (if any) by iterating over each (managed) object, first invoking the object's destructor, and then freeing memory by invoking the <code>deallocate</code> method of the allocator (or pool) that was supplied with the sequence of (managed) objects at construction. Note that the order in which the managed objects are deleted is undefined. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>, and <a class="el" href="group__bsls__performancehint.html#gae9831919bd580f971e8bbc4eb8c2905e">BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a14ed55f483b1c6b28350df1f2b07a53d"></a><!-- doxytag: member="bslma::AutoRawDeleter::operator++" ref="a14ed55f483b1c6b28350df1f2b07a53d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>&lt; TYPE, ALLOCATOR &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increase by one the (signed) length of the sequence of objects managed by this range proctor. The behavior is undefined unless the origin of the sequence of objects managed by this proctor is non-zero. The behavior is undefined unless the origin or this range proctor is non-zero. Note that if the length of this proctor is currently negative, the number of managed objects will decrease by one, whereas if the length is non-negative, the number of managed objects will increase by one. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c59bfc2d87ac6f8df490a83be46dea"></a><!-- doxytag: member="bslma::AutoRawDeleter::operator&#45;&#45;" ref="ad2c59bfc2d87ac6f8df490a83be46dea" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>&lt; TYPE, ALLOCATOR &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrease by one the (signed) length of the sequence of objects managed by this range proctor. The behavior is undefined unless the origin of the sequence of objects managed by this proctor is non-zero. The behavior is undefined unless the origin or this range proctor is non-zero. Note that if the length of this proctor is currently positive, the number of managed objects will decrease by one, whereas if the length is non-positive, the number of managed objects will increase by one. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="ac9eba7f659e04b0140a2e621ea688618"></a><!-- doxytag: member="bslma::AutoRawDeleter::release" ref="ac9eba7f659e04b0140a2e621ea688618" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>&lt; TYPE, ALLOCATOR &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release from management the sequence of objects currently managed by this range proctor by setting the length of the managed sequence to 0. All objects currently under management will become unmanaged (i.e., when the proctor goes out of scope and it was not assigned another sequence of objects to manage by invoking <code>reset</code>, no objects will be deleted). If no objects are currently being managed, this method has no effect. Note that the origin is not affected. </p>

</div>
</div>
<a class="anchor" id="a549f962b207498a850b5533a428a7ec9"></a><!-- doxytag: member="bslma::AutoRawDeleter::reset" ref="a549f962b207498a850b5533a428a7ec9" args="(TYPE **origin)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>&lt; TYPE, ALLOCATOR &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">TYPE **&nbsp;</td>
          <td class="paramname"> <em>origin</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>origin</code> as the origin of the sequence of objects to be managed by this range proctor. The behavior is undefined unless <code>origin</code> is non-zero. Note that the length of the sequence of objects managed by this proctor is not affected, and <code>setLength</code> should be invoked if the managed range is different from the previously managed sequence of objects. Also note that this method releases any previously-managed objects from management (without deleting them), and so may be called with or without having called <code>release</code> when reusing this object. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="abc5d649c34d52d3a491b3f86edfd0ae8"></a><!-- doxytag: member="bslma::AutoRawDeleter::setLength" ref="abc5d649c34d52d3a491b3f86edfd0ae8" args="(int length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>&lt; TYPE, ALLOCATOR &gt;::setLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the (signed) length of the sequence of objects managed by this range proctor to the specified <code>length</code>. The behavior is undefined unless the origin of this range proctor is non-zero. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>.</p>

</div>
</div>
<a class="anchor" id="a2c66f9fcb4dbc6c9eca7074ec673ff5d"></a><!-- doxytag: member="bslma::AutoRawDeleter::length" ref="a2c66f9fcb4dbc6c9eca7074ec673ff5d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a>&lt; TYPE, ALLOCATOR &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (signed) length of the sequence of objects managed by this range proctor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslma__autorawdeleter_8h_source.html">bslma_autorawdeleter.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:53 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
