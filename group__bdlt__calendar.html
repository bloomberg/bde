<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlt_calendar Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlt_calendar<br/>
<small>
[<a class="el" href="group__bdlt.html">Package bdlt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide fast repository for accessing weekend/holiday information.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html">bdlt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Weekend Days and Weekend-Days Transitions</a> </li>
<li>
<a href="#3.2">Nested Iterators</a> </li>
<li>
<a href="#3.3">Iterator Invalidation</a> </li>
<li>
<a href="#3.4">Performance and Exception-Safety Guarantees</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Populating Calendars</a> </li>
<li>
<a href="#3.5.2">Example 2: Using Calendars</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide fast repository for accessing weekend/holiday information. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a> </td><td>fast repository for accessing weekend/holiday information  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlt__packedcalendar.html" title="Provide a compact repository for weekend/holiday information.">Component bdlt_packedcalendar</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a value-semantic class, <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code>, that represents weekend and holiday information over a <em>valid</em> <em>range</em> of dates. A <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> is an approximation to the same <em>mathematical</em> type, and is capable of representing the same subset of <em>mathematical</em> values, as a <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code>. A <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> object (representing the same <em>mathematical</em> value) can be constructed directly from a reference to a non-modifiable <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> object, and a reference to a non-modifiable <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> is readily accessible from any <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>But unlike <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code>, which is optimized for spatial efficiency, <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> is designed to be especially efficient at determining whether a given <code><a class="el" href="classbdlt_1_1Date.html">bdlt::Date</a></code> value (within the valid range for a particular <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> object) is a business day -- i.e., not a weekend day or holiday (see "Usage" below). For example, the cost of determining whether a given <code><a class="el" href="classbdlt_1_1Date.html">bdlt::Date</a></code> is a business day, as opposed to a weekend or holiday, consists of only a few constant-time operations, compared to a binary search in a <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> representing the same calendar value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Default-constructed calendars are empty, and have an empty valid range. Calendars can also be constructed with an initial (non-empty) valid range, implying that all dates within that range are business days. The <code>setValidRange</code> and <code>addDay</code> methods modify the valid range of a calendar, and a suite of "add" methods can be used to populate a calendar with weekend days and holidays. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>addHolidayCode</code> method associates an integer "holiday code" with a specific date, and can be called repeatedly with different integers and the same date to build up a set of holiday codes for that date. Note that holiday codes are unique integers that, from the perspective of the calendar, have no particular meaning. Typically, the user will choose holiday code values that are indices into an auxiliary collection (such as a <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;bsl::string&gt;</code>) to identify holiday names for end-user display. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once a calendar is populated, a rich set of accessor methods can be used to determine, e.g., if a given date is a business day, or the number of non-business days within some subrange of the calendar. The holidays within a calendar can be obtained in increasing (chronological) order using an iterator identified by the nested <code>HolidayConstIterator</code> <code>typedef</code>. The set of holiday codes associated with an arbitrary date in a <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> (or the current holiday referred to by a <code>HolidayConstIterator</code>) can be obtained in increasing (numerical) order using an iterator identified by the nested <code>HolidayCodeConstIterator</code> <code>typedef</code> (see below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Calendars are value-semantic objects, and, as such, necessarily support all of the standard value-semantic operations, such as default construction, copy construction and copy assignment, equality comparison, and externalization (BDEX streaming, in particular). Calendars also support the notions of both union and intersection merging operations, whereby a calendar can change its value to contain the union or intersection of its own contained weekend days, holidays, and holiday codes with those of another calendar object. Such merging operations will, in general, also alter the valid range of the resulting calendar. Note that merged calendars can be significantly more efficient for certain repeated "is-common-business-day" determinations among two or more calendars. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="weekend_days_and_weekend-days_transitions"></a> <a class="anchor" id="description.weekend_days_and_weekend-days_transitions"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Weekend Days and Weekend-Days Transitions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A calendar maintains a set of dates considered to be weekend days. Typically, a calendar's weekend days fall on the same days of the week for the entire range of a calendar. For example, the weekend for United States has consisted of Saturday and Sunday since the year 1940. The <code>addWeekendDay</code> and <code>addWeekendDays</code> methods can be used to specify the weekend days for these calendars. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>However, sometimes a calendar's weekend days changes over time. For example, Bangladesh's weekend consisted of Friday until June 1, 1997 when Bangladesh changed its weekends to contain both Friday and Saturday. Later, on October 1, 2001, Bangladesh reverted to a weekend of only Friday, until on September 9, 2009, Bangladesh again changed its weekends to include both Friday and Saturday. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To optimize for space allocation while supporting both consistent and changing weekend days, a calendar represents weekend information using a sequence of "weekend-days transitions", each of which comprises a date and a set of days of the week considered to be the weekend on and after that date. To represent the weekend days of Bangladesh, a calendar can use a sequence of four weekend-days transitions: (1) a transition on January 1, 0001 having a weekend day set containing only Friday, (2) a transition at June 1, 1997 having a weekend day set containing Friday and Saturday, (3) a transition at October 1, 2001 having a weekend day set containing only Friday, and (4) a transition at September 9, 2009 having a weekend day set containing Friday and Saturday. To represent the weekend days of the United States, a calendar having a range after 1940 can use a single weekend-days transition on January 1, 0001 containing Saturday and Sunday. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>On construction, a calendar does not contain any weekend-days transitions. The <code>addWeekendDaysTransition</code> method adds a new weekend-days transition or replaces an existing weekend-days transition. The <code>addWeekendDay</code> and <code>addWeekendDays</code> methods create a weekend-days transition at January 1, 0001, if one doesn't already exist, and update the set of weekend days for that transition. <code>addWeekendDay</code> and <code>addWeekendDays</code> should only be used for calendars having a consistent set of weekend days throughout their entire range. The use of <code>addWeekendDay</code> and <code>addWeekendDays</code> is intended to be <em>mutually</em> <em>exclusive</em> to the use of <code>addWeekendDaysTransition</code>. As such, the behavior of using these two methods together with <code>addWeekendDaysTransition</code> is undefined. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="nested_iterators"></a> <a class="anchor" id="description.nested_iterators"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Nested Iterators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Also provided are several STL-style <code>const</code> bidirectional iterators accessible as nested <code>typedef</code>s. <code>HolidayConstIterator</code>, <code>HolidayCodeConstIterator</code>, <code>WeekendDaysTransitionConstIterator</code>, and <code>BusinessDayConstIterator</code>, respectively, iterate over a chronologically ordered sequence of holidays, a numerically ordered sequence of holiday codes, a sequence of chronologically ordered weekend-days transitions, and a sequence of chronologically ordered business days. Reverse iterators are also provided for each of these (forward) iterators. As a general rule, calling a <code>const</code> method will not invalidate any iterators, and calling a non-'const' method might invalidate all of them; it is, however, guaranteed that attempting to add <em>duplicate</em> holidays or holiday codes will have no effect, and therefore will not invalidate any iterators. It is also guaranteed that adding a new code for an existing holiday will not invalidate any <code>HolidayConstIterator</code> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that these iterators do <em>not</em> meet the requirements for a <code>bsl::forward_iterator</code> and should not be used in standard algorithms (e.g., <code>bsl::lower_bound</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="iterator_invalidation"></a> <a class="anchor" id="description.iterator_invalidation"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Iterator Invalidation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The modification of a <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> will invalidate iterators referring to the calendar. The following table shows the relationship between a calendar manipulator and the types of iterators it will invalidate if the invocation of the manipulator modified the calendar (e.g., using <code>addHoliday</code> with a date that is not currently a holiday in the calendar): <br/>
<br/>
<div class="fragment"><pre class="fragment">          Manipulator                         Invalidates
    --------------------------            --------------------
    <span class="stringliteral">&#39;operator=&#39;</span>                           H    HC    WDT    BD
    <span class="stringliteral">&#39;addHoliday&#39;</span>                          H    HC           BD
    <span class="stringliteral">&#39;addHolidayCode&#39;</span>                           HC
    <span class="stringliteral">&#39;addHolidayCodeIfInRange&#39;</span>                  HC
    <span class="stringliteral">&#39;addHolidayIfInRange&#39;</span>                 H    HC           BD
    <span class="stringliteral">&#39;addWeekendDay&#39;</span>                                  WDT    BD
    <span class="stringliteral">&#39;addWeekendDays&#39;</span>                                 WDT    BD
    <span class="stringliteral">&#39;addWeekendDaysTransition&#39;</span>                       WDT    BD
    <span class="stringliteral">&#39;intersectBusinessDays&#39;</span>               H    HC    WDT    BD
    <span class="stringliteral">&#39;intersectNonBusinessDays&#39;</span>            H    HC    WDT    BD
    <span class="stringliteral">&#39;removeAll&#39;</span>                           H    HC    WDT    BD
    <span class="stringliteral">&#39;removeHoliday&#39;</span>                       H    HC           BD
    <span class="stringliteral">&#39;removeHolidayCode&#39;</span>                        HC
    <span class="stringliteral">&#39;setValidRange&#39;</span>                       H    HC           BD
    <span class="stringliteral">&#39;unionBusinessDays&#39;</span>                   H    HC    WDT    BD
    <span class="stringliteral">&#39;unionNonBusinessDays&#39;</span>                H    HC    WDT    BD

 where <span class="stringliteral">&quot;H&quot;</span> represents the holiday iterators (<span class="stringliteral">&#39;HolidayConstIterator&#39;</span> and
 <span class="stringliteral">&#39;HolidayConstReverseIterator&#39;</span>), <span class="stringliteral">&quot;HC&quot;</span> represents the holiday code iterators
 (<span class="stringliteral">&#39;HolidayCodeConstIterator&#39;</span> and <span class="stringliteral">&#39;HolidayCodeConstReverseIterator&#39;</span>), <span class="stringliteral">&quot;WDT&quot;</span>
 represents the weekend-days transition iterators
 (<span class="stringliteral">&#39;WeekendDaysTransitionConstIterator&#39;</span> and
 <span class="stringliteral">&#39;WeekendDaysTransitionConstReverseIterator&#39;</span>), and <span class="stringliteral">&quot;BD&quot;</span> represents the
 business day iterators (<span class="stringliteral">&#39;BusinessDayConstIterator&#39;</span> and
 <span class="stringliteral">&#39;BusinessDayConstReverseIterator&#39;</span>).
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance_and_exception-safety_guarantees"></a> <a class="anchor" id="description.performance_and_exception-safety_guarantees"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Performance and Exception-Safety Guarantees: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> supports <code>O[1]</code> (i.e., constant-time) determination of whether a given <code><a class="el" href="classbdlt_1_1Date.html">bdlt::Date</a></code> value is or is not a business day, which is accomplished by augmenting the implementation of a packed calendar with a supplementary cache. The invariant that this cache and the data represented in the underlying <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> be maintained in a consistent state may add significantly to the cost of performing many manipulator operations, especially those that affect the calendar's valid range and add a new weekend-days transition. Moreover, the cost of many of these operations will now be proportional to the length(s) of the valid range(s), as well as their respective numbers of holidays and associated holiday codes and weekend-days transitions. Hence, when populating a calendar, it is recommended that the desired value be captured first as a <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code>, which can then be used efficiently to <em>value-construct</em> the desired <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> object. See the component-level doc for <code>bdlt_packedcalendar</code> for its performance guarantees. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>All methods of the <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> are exception-safe, but in general provide only the basic guarantee (i.e., no guarantee of rollback): If an exception occurs (i.e., while attempting to allocate memory), the calendar object is left in a coherent state, but (unless otherwise specified) its <em>value</em> is undefined. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The two subsections below illustrate various aspects of populating and using calendars. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_populating_calendars"></a> <a class="anchor" id="usage.example_1~3A_populating_calendars"></a> <a class="anchor" id="description.usage.example_1~3A_populating_calendars"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Populating Calendars: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bdlt::Calendars</code> can be populated directly, but are often more efficiently created by first creating a corresponding <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code>, and then using that object to construct the calendar. As an example, suppose we want to provide efficient access to a (high-performance) <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> for a variety of locales, whose raw information comes from, say, a database. The latency associated with fetching data for individual calendars on demand from a typical database can be prohibitively expensive, so it may make sense to acquire data for all calendars in a single query at start-up. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we declare a <code>MyPackedCalendarCache</code> that, internally, is just a mapping from (typically short) character string names (such as "NYB", representing New York Bank settlement days) to <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> objects, containing densely packed calendar data: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyPackedCalendarCache {
      <span class="comment">// This class maintains a space-efficient repository of calendar data</span>
      <span class="comment">// associated with a (typically short) name.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1unordered__map.html">bsl::unordered_map&lt;bsl::string, bdlt::PackedCalendar&gt;</a>  d_map;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MyPackedCalendarCache(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;MyPackedCalendarCache&#39;.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> <a class="code" href="namespacebdlat__ValueTypeFunctions.html#a8878d14342c51302d88f1c2e8d242a5e">assign</a>(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;          name,
                  <span class="keyword">const</span> <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a>&amp; calendar);
          <span class="comment">// Associate the value of the specified &#39;calendar&#39; with the</span>
          <span class="comment">// specified &#39;name&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a> *lookup(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name) <span class="keyword">const</span>;
          <span class="comment">// Return the address of calendar data associated with the</span>
          <span class="comment">// specified &#39;name&#39;, or 0 if no such association exists.</span>
  };

  <span class="comment">// CREATORS</span>
  MyPackedCalendarCache::MyPackedCalendarCache(
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_map(basicAllocator)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> <a class="code" href="namespacebdlat__ValueTypeFunctions.html#a8878d14342c51302d88f1c2e8d242a5e">MyPackedCalendarCache::assign</a>(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;          name,
                                     <span class="keyword">const</span> <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a>&amp; calendar)
  {
      d_map[name] = calendar;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">const</span> <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a> *MyPackedCalendarCache::lookup(
                                               <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1unordered__map.html">bsl::unordered_map&lt;bsl::string, bdlt::PackedCalendar&gt;</a> Cache;
      Cache::const_iterator iter = d_map.find(name);

      <span class="keywordflow">if</span> (iter == d_map.end()) {
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">return</span> &amp;iter-&gt;second;
  }
</pre></div><br/>
<br/>
 Then, we define an application function, <code>loadMyPackedCalendarCache</code>, that takes the address of a <code>MyPackedCalendarCache</code> and populates it with up-to-date calendar data for all known locales (which, in the future, will be from a well-known database location): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> loadMyPackedCalendarCache(MyPackedCalendarCache *result)
      <span class="comment">// Load, into the specified &#39;result&#39;, up-to-date calendar information</span>
      <span class="comment">// for every known locale.  Return 0 on success, and a non-zero value</span>
      <span class="comment">// otherwise.</span>
  {
      <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a> calendar;
      calendar.<a class="code" href="classbdlt_1_1PackedCalendar.html#a3a6177f3a0c390fb8d3b0f8315ab8771">setValidRange</a>(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2000,  1,  1),
                             <a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2020, 12, 31));
      result-&gt;assign(<span class="stringliteral">&quot;NYB&quot;</span>, calendar);
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 We can imagine that there might be dozens, even hundreds of different locales, and that most applications will not need efficient access to calendar data from many, let alone every locale; however, many long-running applications may well need to obtain efficient access to the same calendar data repeatedly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we create a second-level of cache, <code>MyCalendarCache</code>, that maintains a repository of the more runtime-efficient, but also more space-intensive, <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> objects, which are instantiated on demand from a packed-calendar-based data source: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyCalendarCache {
      <span class="comment">// This class maintains a cache of runtime-efficient calendar objects</span>
      <span class="comment">// created on demand from a compact packed-calendar-based data source,</span>
      <span class="comment">// whose address is supplied at construction.</span>

      <span class="comment">// DATA</span>
      MyPackedCalendarCache                           *d_datasource_p;
      <a class="code" href="classbsl_1_1unordered__map.html">bsl::unordered_map&lt;bsl::string, bdlt::Calendar&gt;</a>  d_map;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MyCalendarCache(MyPackedCalendarCache *dataSource,
                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>      *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;MyCalendarCache&#39; associated with the specified</span>
          <span class="comment">// &#39;dataSource&#39;.  Optionally specify a &#39;basicAllocator&#39; used to</span>
          <span class="comment">// supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">const</span> <a class="code" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a> *lookup(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name);
          <span class="comment">// Return the address of calendar data associated with the</span>
          <span class="comment">// specified &#39;name&#39;, or 0 if no such association exists in the data</span>
          <span class="comment">// source whose address was supplied at construction.  Note that</span>
          <span class="comment">// this method may alter the physical state of this object (and is</span>
          <span class="comment">// therefore deliberately declared non-&#39;const&#39;).</span>
  };

  MyCalendarCache::MyCalendarCache(MyPackedCalendarCache *dataSource,
                                   <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>      *basicAllocator)
  : d_datasource_p(dataSource)
  , d_map(basicAllocator)
  {
  }

  <span class="keyword">const</span> <a class="code" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a> *MyCalendarCache::lookup(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name)
  {
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1unordered__map.html">bsl::unordered_map&lt;bsl::string, bdlt::Calendar&gt;</a> Cache;
      Cache::const_iterator iter = d_map.find(name);
      <span class="keywordflow">if</span> (iter == d_map.end()) {
          <span class="keyword">const</span> <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a> *pc = d_datasource_p-&gt;lookup(name);
          <span class="keywordflow">if</span> (!pc) {

              <span class="comment">// No such name in the data source.</span>

              <span class="keywordflow">return</span> 0;                                             <span class="comment">// RETURN</span>
          }

          <span class="comment">// Create new entry in calendar cache.</span>

          iter = d_map.insert(bsl::make_pair(name, *pc)).first;
      }

      <span class="comment">// An efficient calendar either already existed or was created.</span>

      <span class="keywordflow">return</span> &amp;iter-&gt;second;
   }
</pre></div><br/>
<br/>
 Now, we can create and populate the cache: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPackedCalendarCache packedCalendarCache;
  MyCalendarCache       calendarCache(&amp;packedCalendarCache);

  loadMyPackedCalendarCache(&amp;packedCalendarCache);
</pre></div><br/>
<br/>
 Finally, we request the "NYB" calendar and verify the returned value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a> *calendarPtr = calendarCache.lookup(<span class="stringliteral">&quot;NYB&quot;</span>);

  assert(calendarPtr-&gt;<a class="code" href="classbdlt_1_1Calendar.html#abb29ce322b3af9f146bec0942907d49b">firstDate</a>() == <a class="code" href="namespacebdet.html#afaf7185f28d8d6122ae4fe36a6b88ba5">bdlt::Date</a>(2000,  1,  1));
  assert(calendarPtr-&gt;<a class="code" href="classbdlt_1_1Calendar.html#a6e87e5dbfa1d31b6e107e95c689313c8">lastDate</a>()  == <a class="code" href="namespacebdet.html#afaf7185f28d8d6122ae4fe36a6b88ba5">bdlt::Date</a>(2020, 12, 31));
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_calendars"></a> <a class="anchor" id="usage.example_2~3A_using_calendars"></a> <a class="anchor" id="description.usage.example_2~3A_using_calendars"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.5.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using Calendars: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>What makes a <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> substantially different from a <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> is the speed with which the <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> can report whether a given date is or is not a business day. An important use of high-performance calendar objects in financial applications is to quickly determine the settlement date of a financial instrument. In some applications (e.g., those that explore the cross product of various portfolios over several horizons and scenarios), the settlement date may need to be calculated literally billions of times. The settlement date will often be determined from a periodic target date, such as the 15th or 30th of the month, which is then perturbed in some way to arrive at a valid settlement date. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>One very common algorithm a security may prescribe for finding a valid settlement date is known as <em>modified</em> <em>following</em>: Given a target day, the settlement date for that month is defined as the first valid business day at or after the given target day in the same month; if no such date exists, then the settlement date is the closest valid business day before the target day in that month. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a <code>struct</code>, <code>MyCalendarUtil</code>, that provides the <code>modifiedFollowing</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyCalendarUtil {

      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a> modifiedFollowing(<span class="keywordtype">int</span>                   targetDay,
                                          <span class="keywordtype">int</span>                   month,
                                          <span class="keywordtype">int</span>                   year,
                                          <span class="keyword">const</span> <a class="code" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a>&amp; calendar)
          <span class="comment">// Return the date of the first business day at or after the</span>
          <span class="comment">// specified &#39;targetDay&#39; in the specified &#39;month&#39; and &#39;year&#39;</span>
          <span class="comment">// according to the specified &#39;calendar&#39;, unless the resulting</span>
          <span class="comment">// date would not fall within &#39;month&#39;, in which case return</span>
          <span class="comment">// instead the date of the first business day before &#39;targetDay&#39;</span>
          <span class="comment">// in &#39;month&#39;.  The behavior is undefined unless all candidate</span>
          <span class="comment">// dates applied to &#39;calendar&#39; are within its valid range and</span>
          <span class="comment">// there exists at least one business day within &#39;month&#39;.</span>
      {
          <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(<a class="code" href="classbdlt_1_1Date.html#a1faa7073957a832565240d5f7b7821ec">bdlt::Date::isValidYearMonthDay</a>(year,
                                                      month,
                                                      targetDay));

          <span class="comment">// Efficiency is important so we will minimize the number of</span>
          <span class="comment">// conversions between year/month/day and &#39;bdlt::Date&#39; objects.</span>

          <a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a> date(year, month, targetDay);

          <span class="keywordflow">if</span> (0 == calendar.<a class="code" href="classbdlt_1_1Calendar.html#a81daee443f235ee089e8386644fe2265">getNextBusinessDay</a>(&amp;date, date - 1)
           &amp;&amp; month == date.month()) {
              <span class="keywordflow">return</span> date;                                          <span class="comment">// RETURN</span>
          }
          <span class="keywordflow">while</span> (calendar.<a class="code" href="classbdlt_1_1Calendar.html#a299ecb909bfb7742c83216aa05d101dd">isNonBusinessDay</a>(--date)) {
              <span class="comment">// empty</span>
          }
          <span class="keywordflow">return</span> date;
      }
  };
</pre></div><br/>
<br/>
 Then, we create and populate two calendars, <code>cal1</code> and <code>cal2</code>, for testing the <code>modifiedFollowing</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a> cal1(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 1, 1), <a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015,12, 31));
  cal1.addWeekendDay(<a class="code" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573a0a07aa0eef536b4f592832e5cb0e88fc">bdlt::DayOfWeek::e_SUN</a>);
  cal1.addWeekendDay(<a class="code" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573ac81b6ddce7c54c4bd9cd349d0f16be0d">bdlt::DayOfWeek::e_SAT</a>);
  cal1.addHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 7, 3));

  <a class="code" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a> cal2(cal1);
  cal2.addHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 7, 31));
</pre></div><br/>
<br/>
 Finally, we verify the <code>modifiedFollowing</code> functionality: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 7,  2) ==
                       MyCalendarUtil::modifiedFollowing( 2, 7, 2015, cal1));
  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 7,  6) ==
                       MyCalendarUtil::modifiedFollowing( 3, 7, 2015, cal1));
  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 7, 31) ==
                       MyCalendarUtil::modifiedFollowing(31, 7, 2015, cal1));

  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 7,  2) ==
                       MyCalendarUtil::modifiedFollowing( 2, 7, 2015, cal2));
  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 7,  6) ==
                       MyCalendarUtil::modifiedFollowing( 3, 7, 2015, cal2));
  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 7, 30) ==
                       MyCalendarUtil::modifiedFollowing(31, 7, 2015, cal2));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:48 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
