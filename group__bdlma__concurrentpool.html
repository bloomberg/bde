<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_concurrentpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_concurrentpool<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide thread-safe allocation of memory blocks of uniform size.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__concurrentpool.html#ga0f410f768c84deb5d4f0453dd2009814">operator new</a> (bsl::size_t size, BloombergLP::bdlma::ConcurrentPool &amp;pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__concurrentpool.html#ga5c16c91ce64114c0374cb0be1a059dad">operator delete</a> (void *address, BloombergLP::bdlma::ConcurrentPool &amp;pool)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Configuration at Construction</a> </li>
<li>
<a href="#3.2">Overloaded Global Operator <code>new</code></a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide thread-safe allocation of memory blocks of uniform size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a> </td><td>thread-safe memory manager that allocates blocks  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bdema_pool </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a memory pool, <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code>, that allocates and manages memory blocks of some uniform size specified at construction. A <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> object maintains an internal linked list of free memory blocks, and dispenses one block for each <code>allocate</code> method invocation. When a memory block is deallocated, it is returned to the free list for potential reuse. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Whenever the linked list of free memory blocks is depleted, the <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> replenishes the list by first allocating a large, contiguous "chunk" of memory, then splitting the chunk into multiple memory blocks. A chunk and its constituent memory blocks can be depicted visually: <br/>
<br/>
<div class="fragment"><pre class="fragment">     +-----+--- memory blocks of uniform size
     |     |
   ----- ----- ------------
  |     |     |     ...    |
   =====^=====^============

   \___________ __________/
               V
           a <span class="stringliteral">&quot;chunk&quot;</span>
</pre></div><br/>
<br/>
 Note that the size of the allocated chunk is determined by both the growth strategy and maximum blocks per chunk, either of which can be optionally specified at construction (see the "Configuration at Construction" section). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="configuration_at_construction"></a> <a class="anchor" id="description.configuration_at_construction"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Configuration at Construction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When creating a <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code>, clients must specify the specific block size managed and dispensed by the pool. Furthermore, clients can optionally configure: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
GROWTH STRATEGY -- geometrically growing chunk size starting from 1 (in terms of the number of memory blocks per chunk), or fixed chunk size. If the growth strategy is not specified, geometric growth is used.  </li>
<li>
MAX BLOCKS PER CHUNK -- the maximum number of memory blocks within a chunk. If the maximum blocks per chunk is not specified, an implementation-defined default value is used.  </li>
<li>
BASIC ALLOCATOR -- the allocator used to supply memory to replenish the internal pool. If not specified, the currently installed default allocator (see <code>bslma_default</code>) is used.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, if geometric growth is used and the maximum blocks per chunk is specified as 30, the chunk size grows geometrically, starting from 1, until the specified maximum blocks per chunk, as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  1, 2, 4, 8, 16, 30, 30, 30 ...
</pre></div><br/>
<br/>
 If constant growth is used, the chunk size is always the specified maximum blocks per chunk (or an implementation-defined value if the maximum blocks per chunk is not specified), for example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  30, 30, 30 ...
</pre></div><br/>
<br/>
 A default-constructed pool has an initial chunk size of 1 (i.e., the number of memory blocks of a given size allocated at once to replenish a pool's memory), and the pool's chunk size grows geometrically until it reaches an implementation-defined maximum, at which it is capped. Finally, unless otherwise specified, all memory comes from the allocator that was the currently installed default allocator at the time the <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> was created. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="overloaded_global_operator_new"></a> <a class="anchor" id="description.overloaded_global_operator_new"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Overloaded Global Operator new: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component overloads the global <code>operator new</code> to allow convenient syntax for the construction of objects using a <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code>. The <code>new</code> operator supplied in this component takes a <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> argument indicating the source of the memory. Consider the following use of standard placement <code>new</code> syntax (supplied by <code>bsl_new.h</code>) along with a <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> to allocate an object of type <code>T</code>. Note that the size of <code>T</code> must be the same or smaller than the <code>blockSize</code> with which the pool is constructed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> f(<a class="code" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a> *pool)
  {
      assert(pool-&gt;<a class="code" href="classbdlma_1_1ConcurrentPool.html#ae9f5e417431879bca2c69080778084ca">blockSize</a>() &gt;= <span class="keyword">sizeof</span>(T));

      T *t = <span class="keyword">new</span> (pool-&gt;<a class="code" href="classbdlma_1_1ConcurrentPool.html#aa1a5f8329b2644a304fdff79ee3563cd">allocate</a>()) T(...);

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 This usage style is not exception-safe. If the constructor of <code>T</code> throws an exception, <code>pool-&gt;deallocate</code> is never called. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Supplying an overloaded global <code>operator new</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  ::operator <span class="keyword">new</span>(bsl::size_t size, <a class="code" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a>&amp; pool);
</pre></div><br/>
<br/>
 allows for the following cleaner usage, which does not require the size calculation and guarantees that <code>pool-&gt;deallocate</code> <em>is</em> called in case of an exception: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> f(<a class="code" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a> *pool)
  {
      assert(pool-&gt;<a class="code" href="classbdlma_1_1ConcurrentPool.html#ae9f5e417431879bca2c69080778084ca">blockSize</a>() &gt;= <span class="keyword">sizeof</span>(T));

      T *t = <span class="keyword">new</span> (*pool) T(...);

      <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Also note that the analogous version of operator <code>delete</code> should <em>not</em> be called directly. Instead, this component provides a static template member function <code>deleteObject</code>, parameterized on <code>TYPE</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      pool-&gt;<a class="code" href="classbdlma_1_1ConcurrentPool.html#a1fc6d230de079c2c847c01a24e66190e">deleteObject</a>(t);
  }
</pre></div><br/>
<br/>
 The above <code>deleteObject</code> call is equivalent to performing the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  t-&gt;~TYPE();
  pool-&gt;<a class="code" href="classbdlma_1_1ConcurrentPool.html#a96a5049eba22d586d0b2285bf64875dc">deallocate</a>(t);
</pre></div><br/>
<br/>
 An overloaded operator <code>delete</code> is supplied solely to allow the compiler to arrange for it to be called in case of an exception. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> can be used by node-based containers (such as lists, trees, and hash tables that hold multiple elements of uniform size) for efficient memory allocation of new elements. The following container class, <code>my_PooledArray</code>, stores templatized values "out-of-place" as nodes in a <code>vector</code> of pointers. Since the size of each node is fixed and known <em>a priori</em>, the class uses a <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> to allocate memory for the nodes to improve memory allocation efficiency: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_poolarray.h</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">class </span>my_PooledArray {
      <span class="comment">// This class implements a container that stores &#39;double&#39; values</span>
      <span class="comment">// out-of-place.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;T *&gt;</a>      d_array_p;  <span class="comment">// array of pooled elements</span>
      <a class="code" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a> d_pool;     <span class="comment">// memory manager for array elements</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_PooledArray(<span class="keyword">const</span> my_PooledArray&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_PooledArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a pooled array that stores the parameterized values</span>
          <span class="comment">// &quot;out-of-place&quot;.  Optionally specify a &#39;basicAllocator&#39; used to</span>
          <span class="comment">// supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      ~my_PooledArray();
          <span class="comment">// Destroy this array and all elements held by it.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> append(<span class="keyword">const</span> T &amp;value);
          <span class="comment">// Append the specified &#39;value&#39; to this array.</span>

      <span class="keywordtype">void</span> removeAll();
          <span class="comment">// Remove all elements from this array.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> length() <span class="keyword">const</span>;
          <span class="comment">// Return the number of elements in this array.</span>

      <span class="keyword">const</span> T&amp; operator[](<span class="keywordtype">int</span> index) <span class="keyword">const</span>;
          <span class="comment">// Return a reference to the non-modifiable value at the specified</span>
          <span class="comment">// &#39;index&#39; in this array.  The behavior is undefined unless</span>
          <span class="comment">// &#39;0 &lt;= index &lt; length()&#39;.</span>
  };
</pre></div><br/>
<br/>
 In the <code>removeAll</code> method, all elements are deallocated by invoking the pool's <code>release</code> method. This technique implies significant performance gain when the array contains many elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_PooledArray&lt;T&gt;::removeAll()
  {
      d_array_p.clear();
      d_pool.<a class="code" href="classbdlma_1_1Pool.html#afd51c71be6e7ab898b79e8a0b61090b0">release</a>();
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_PooledArray&lt;T&gt;::length()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(d_array_p.size());
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">inline</span>
  <span class="keyword">const</span> T&amp; my_PooledArray&lt;T&gt;::operator[](<span class="keywordtype">int</span> index)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      assert(0 &lt;= index);
      assert(index &lt; length());

      <span class="keywordflow">return</span> *d_array_p[index];
  }
</pre></div><br/>
<br/>
 Note that the growth strategy and maximum chunk size of the pool is left as the default value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_poolarray.cpp</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  my_PooledArray&lt;T&gt;::my_PooledArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_array_p(basicAllocator)
  , d_pool(sizeof(T), basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Since all memory is managed by <code>d_pool</code>, we do not have to explicitly invoke <code>deleteObject</code> to reclaim outstanding memory. The destructor of the pool will automatically deallocate all array elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  my_PooledArray&lt;T&gt;::~my_PooledArray()
  {
      <span class="comment">// Elements are automatically deallocated when &#39;d_pool&#39; is destroyed.</span>
  }
</pre></div><br/>
<br/>
 Note that the overloaded "placement" <code>new</code> is used to allocate new nodes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  <span class="keywordtype">void</span> my_PooledArray&lt;T&gt;::append(<span class="keyword">const</span> T&amp; value)
  {
      T *tmp = <span class="keyword">new</span> (d_pool) T(value);
      d_array_p.push_back(tmp);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0f410f768c84deb5d4f0453dd2009814"></a><!-- doxytag: member="bdlma_concurrentpool.h::operator new" ref="ga0f410f768c84deb5d4f0453dd2009814" args="(bsl::size_t size, BloombergLP::bdlma::ConcurrentPool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::ConcurrentPool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a block of memory of the specified <code>size</code> (in bytes) allocated from the specified <code>pool</code>. The behavior is undefined unless <code>size</code> is the same or smaller than the <code>blockSize</code> with which <code>pool</code> was constructed. Note that an object may allocate additional memory </p>

</div>
</div>
<a class="anchor" id="ga5c16c91ce64114c0374cb0be1a059dad"></a><!-- doxytag: member="bdlma_concurrentpool.h::operator delete" ref="ga5c16c91ce64114c0374cb0be1a059dad" args="(void *address, BloombergLP::bdlma::ConcurrentPool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::ConcurrentPool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the specified <code>pool</code> to deallocate the memory at the specified <code>address</code>. The behavior is undefined unless <code>address</code> was allocated using <code>pool</code> and has not already been deallocated. This operator is supplied solely to allow the compiler to arrange for it to be called in case of an exception. Client code should not call it; use <code><a class="el" href="classbdlma_1_1ConcurrentPool.html#a1fc6d230de079c2c847c01a24e66190e">bdlma::ConcurrentPool::deleteObject()</a></code> instead. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:45 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
