<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdld_datum Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Component bdld_datum<br/>
<small>
[<a class="el" href="group__bdld.html">Package bdld</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a discriminated variant type with a small footprint.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
</table>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Notion of Value</a> </li>
<li>
<a href="#3.2">Memory Management</a> <ul>
<li>
<a href="#3.2.1">Analogy to Raw Pointers</a> </li>
<li>
<a href="#3.2.2">Creating a Datum that Requires No Allocation</a> </li>
<li>
<a href="#3.2.3">Creating a Datum that <em>May</em> Require Allocation</a> </li>
<li>
<a href="#3.2.4">Destroying a <code>Datum</code> Object</a> </li>
<li>
<a href="#3.2.5">References to External Strings and Arrays</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Supported Types</a> <ul>
<li>
<a href="#3.3.1">User Defined Data</a> </li>
</ul>
</li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Basic Use of <code>bdld::Datum</code></a> </li>
<li>
<a href="#3.4.2">Example 2: Creating <code>Datum</code> Referring to the Array of <code>Datum</code> objects</a> </li>
<li>
<a href="#3.4.3">Example 3: Creating the <code>Datum</code> having the array value.</a> </li>
<li>
<a href="#3.4.4">Example 4: Creating the <code>Datum</code> having the map value</a> </li>
<li>
<a href="#3.4.5">Example 5: Mass Destruction</a> </li>
<li>
<a href="#3.4.6">Example 6: User-defined, error and binary types</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a discriminated variant type with a small footprint. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bdld::Datum </td><td>POD type representing general-purpose values  </td></tr>
<tr>
<td>bdld::DatumArrayRef </td><td>type for const ref to array of datums  </td></tr>
<tr>
<td>bdld::DatumMapEntry </td><td>type for entry inside map of datums  </td></tr>
<tr>
<td>bdld::DatumMapRef </td><td>type for const ref to map of datums  </td></tr>
<tr>
<td>bdld::DatumMutableArrayRef </td><td>type for mutable ref to array of datums  </td></tr>
<tr>
<td>bdld::DatumMutableMapRef </td><td>type for mutable ref to a map of datums  </td></tr>
<tr>
<td>bdld::DatumMutableMapOwningKeysRef </td><td>mutable ref to a map owning keys  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdld__datumerror.html" title="Provide a type for an error code with an optional error message.">Component bdld_datumerror</a>, <a class="el" href="group__bdld__datumudt.html" title="Provide a type to represent a user-defined type.">Component bdld_datumudt</a>, <a class="el" href="group__bdld__datumbinaryref.html" title="Provide a type to represent binary data and its size.">Component bdld_datumbinaryref</a>, <a class="el" href="group__bdld__manageddatum.html" title="Provide a smart-pointer like manager for a Datum object.">Component bdld_manageddatum</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a mechanism, <code>bdld::Datum</code>, that provides a space-efficient discriminated union (i.e., a variant) that holds the value of either a scalar type (e.g., <code>int</code>, <code>double</code>, <code>Date</code>) or an aggregate (i.e., array or map) of <code>Datum</code> objects. The set of possible types that a datum may hold is described in the <code>Supported Types</code> section. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>Datum</code> class is implemented as a POD-type, such that instances of the class are bitwise copyable and have trivial initialization, assignment and destruction. The <code>Datum</code> class is also (primarily) designed to be compact, especially on a 32-bit platform. Being a compact POD type, <code>Datum</code> is ideal for applications creating and copying very large numbers of variant values (the canonical use-case is for the values in a spreadsheet). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>However, not all representable values can be stored in-line in footprint of a <code>Datum</code> object itself. Those types may require memory be allocated for storage. In order to keep the footprint of a <code>Datum</code> object as small as possible, a <code>Datum</code> object does not hold a reference to an allocator, and so memory must be explicitly managed by the user of <code>Datum</code>. See 'Memory Management' for more details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="notion_of_value"></a> <a class="anchor" id="description.notion_of_value"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Notion of Value: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>Datum</code> has a notion of value, but is neither a value-semantic type, nor is it an in-core value-semantic type (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>). A consequence of the <code>Datum</code> class's space-efficient design is that it does not fall neatly into any of the standard BDE type-classifications. The <code>Datum</code> type's notion of value is expressed by its equality-operator -- notice, in particular, that two <code>Datum</code> objects compare equal if the values they refer to are the same. However, <code>Datum</code>, as a POD, has compiler supplied copy and assignment operators that do not copy any of the storage a <code>Datum</code> may be pointing to, and only copy the address to which the <code>Datum</code> is pointing. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Notice that the differing treatment of references to external data between the equality comparison and the copy and assignment operations violates a couple properties required of a value-semantic type, most obviously: "The value of an object of the type is independent of any modifiable state that is not owned exclusively by that object." (See &lt;A CLASS="el" HREF="group__bsldoc__glossary.html"&gt;<code>bsldoc_glossary</code>.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_management"></a> <a class="anchor" id="description.memory_management"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Memory Management: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A primary design goal for <code>Datum</code> is space-efficiency, particularly on 32-bit platforms. In order to minimize the foot-print (i.e., the <code>sizeof</code>) of a <code>Datum</code> object, <code>Datum</code> does not hold a reference to the allocator that was used to allocate its contents. Therefore any allocated memory referred to by a <code>Datum</code> must be <em>externally</em> <em>managed</em>. The <code>bdld</code> package, and this component, provide tools to simplify the process of managing the memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="analogy_to_raw_pointers"></a> <a class="anchor" id="memory_management.analogy_to_raw_pointers"></a> <a class="anchor" id="description.memory_management.analogy_to_raw_pointers"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Analogy to Raw Pointers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A good way to understand the model for a <code>Datum</code> object's relationship to its data is by analogy: The relationship between a <code>Datum</code> object and the memory to which it refers is analogous to that of a raw-pointer and the data to which it points. Where <code>new</code> and <code>delete</code> are used allocate and free memory a that a pointer points to, the static class methods <code>Datum::create*</code> and <code>Datum::destroy</code> are used to allocate and release the memory a <code>Datum</code> refers to. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to create a <code>Datum</code> object a client calls one of the <code>create*</code> static methods on the <code>Datum</code> class. In order to release the data a <code>Datum</code> holds, a client calls <code>destroy</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creating_a_datum_that_requires_no_allocation"></a> <a class="anchor" id="memory_management.creating_a_datum_that_requires_no_allocation"></a> <a class="anchor" id="description.memory_management.creating_a_datum_that_requires_no_allocation"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Creating a Datum that Requires No Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Datum's containing certain types of scalar values do not require any memory allocation, so their factory functions do <em>not</em> take an allocator. These values are small enough that they can always fit inside of the footprint of the <code>Datum</code> object itself. <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum <span class="keywordtype">boolean</span> = Datum::createBoolean(<span class="keyword">true</span>);   <span class="comment">// Create a boolean datum</span>
  Datum integer = Datum::createInteger(7);      <span class="comment">// Create a integer</span>
  Datum    real = Datum::createDouble(2.0);     <span class="comment">// Create a double</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creating_a_datum_that_may_require_allocation"></a> <a class="anchor" id="memory_management.creating_a_datum_that_may_require_allocation"></a> <a class="anchor" id="description.memory_management.creating_a_datum_that_may_require_allocation"></a> <a class="anchor" id="3.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Creating a Datum that May Require Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Datum objects containing certain types <em>may</em> (or <em>may</em>-*not*!) require memory allocation, so their creation functions <em>require</em> an allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = <a class="code" href="structbslma_1_1Default.html">bslma::Default</a>(0);
  Datum datetime = Datum::createDatetime(<a class="code" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a>(), allocator);
  Datum int64    = Datum::createInteger64(1LL, allocator);
</pre></div><br/>
<br/>
 In the example above, <code>createDatetime</code> takes an allocator, but may not allocate memory. Depending on the value of the <code>Datetime</code>, a <code>Datum</code> might either store the value within the footprint of the <code>Datum</code> (requiring no allocation) or allocate external storage. The situations in which creation functions taking an allocator do, and do not, actually allocate memory is <em>implementation</em>-*defined*. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Clients of <code>Datum</code> should treat any creation function taking an allocator <em>as-if</em> it allocated memory, and eventually call <code>Datum::destroy</code> on the resulting <code>Datum</code>, even though in some instances memory allocation may not be required. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="destroying_a_datum_object"></a> <a class="anchor" id="memory_management.destroying_a_datum_object"></a> <a class="anchor" id="description.memory_management.destroying_a_datum_object"></a> <a class="anchor" id="3.2.4"></a> </dd></dl>
<dl class="user"><dt><b>Destroying a Datum Object: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The contents of a <code>Datum</code> object are destroyed using the static method <code>destroy</code>. For example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = <a class="code" href="structbslma_1_1Default.html">bslma::Default</a>(0);
  Datum datetime = Datum::createDatetime(<a class="code" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a>(), allocator);

  Datume::destroy(datetime, allocator);
     <span class="comment">// &#39;datetime&#39; now refers to deallocated memory.  It cannot be used</span>
     <span class="comment">// used unless it is assigned a new value.</span>
</pre></div><br/>
<br/>
 Notice that the destroyed <code>Datum</code> again behaves similar to a raw-pointer that has been deallocated: the destroyed <code>Datum</code> refers to garbage and must be assigned a new value before it can be used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For aggregate types -- i.e., maps and arrays -- <code>destroy</code> will recursively call <code>destroy</code> on the <code>Datum</code> objects that compose the aggregate. The exception to this is references to external arrays (discussed below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="references_to_external_strings_and_arrays"></a> <a class="anchor" id="memory_management.references_to_external_strings_and_arrays"></a> <a class="anchor" id="description.memory_management.references_to_external_strings_and_arrays"></a> <a class="anchor" id="3.2.5"></a> </dd></dl>
<dl class="user"><dt><b>References to External Strings and Arrays: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although a <code>Datum</code> does not own memory in the traditional sense, a call to <code>Datum::destroy</code> will release the memory to which that <code>Datum</code> refers. However, a <code>Datum</code> object also allows a user to create a <code>Datum</code> referring to an externally managed array or string. For a <code>Datum</code> having a reference to an external string or array, the <code>isExternalReference</code> method will return <code>true</code> and <code>Datum::destroy</code> will not deallocate memory for the data; otherwise, <code>isExternalReference</code> will return <code>false</code> and <code>Datum::destroy</code> will deallocate memory for the data. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, to create a <code>Datum</code> for an externally managed string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum externalStringRef = Datum::createStringRef(<span class="stringliteral">&quot;text&quot;</span>, allocator);
</pre></div><br/>
<br/>
 Notice that the supplied <code>allocator</code> is <em>not</em> used to allocate memory in order copy the contents of the string, but <em>may</em> (or <em>may</em>-*not*) be used to allocate meta-data that the <code>Datum</code> stores about the string (e.g., the string's length). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To create a <code>Datum</code> that is responsible for the memory of a string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum managedString = Datum::copyString(<span class="stringliteral">&quot;text&quot;</span>, allocator);
</pre></div><br/>
<br/>
 Here the contents of the string are copied and managed by the created datum, and later released by <code>Datum::destroy</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>External references to arrays and strings are important for efficiently handling memory allocations in situations where a string or array is externally supplied (e.g., as input to a function) and will clearly outlive the <code>Datum</code> object being created (e.g., a <code>Datum</code> variable within the scope of that function). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In general factory methods of the form <code>create*Ref</code> create a reference to external data that the <code>Datum</code> is not responsible for, while <code>copy*</code> methods copy the data and the resulting <code>Datum</code> is responsible for the allocated memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="supported_types"></a> <a class="anchor" id="description.supported_types"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Supported Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The table below describes the set of types that a <code>Datum</code> may be. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">                        external   requires
  dataType              reference  allocation  Description
  --------              ---------  ----------  -----------
  e_NIL                 no         no          null value
  e_INTEGER             no         no          integer value
  e_REAL                no         no          <span class="keywordtype">double</span> value
  e_STRING              maybe      maybe       <span class="keywordtype">string</span> value
  e_BOOLEAN             no         no          <span class="keywordtype">boolean</span> value
  e_ERROR               no         maybe       error value
  e_DATE                no         no          date value
  e_TIME                no         no          time value
  e_DATETIME            no         maybe       date+time value
  e_DATETIME_INTERVAL   no         maybe       date+time interval value
  e_INTEGER64           no         maybe       64-bit integer value
  e_USERDEFINED         always     maybe       pointer to a user-defined obj
  e_BINARY              no         maybe       binary data
  e_DECIMAL64           no         maybe       <a class="code" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">Decimal64</a>

                        external   requires
  dataType              reference  allocation  Description
  --------              ---------  ----------  -----------
  e_ARRAY               maybe      maybe       array
  e_MAP                 no         maybe       map keyed by <span class="keywordtype">string</span> values
</pre></div><br/>
<br/>
 <ul>
<li>
<em>dataType</em> - the value returned by the <code>type()</code>  </li>
<li>
<em>external-reference</em> - whether <code>isExternalReference</code> will return <code>true</code>, in which case <code>Datum::destroy</code> will not release the externally referenced data (see <code>References to External Strings and Arrays</code>})  </li>
<li>
<em>requires-allocation</em> - whether a <code>Datum</code> refering to this type requires memory allocation. Note that for externally represented string or arrays, meta-data may still need to be allocated.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="user_defined_data"></a> <a class="anchor" id="supported_types.user_defined_data"></a> <a class="anchor" id="description.supported_types.user_defined_data"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>User Defined Data: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>Datum</code> exposes a type <code>DatumUdt</code> with which a user can arbitrarily expand the set of types a <code>Datum</code> can support. A <code>DatumUdt</code> object hold a void pointer, and an an integer identifying the type. A <code>DatumUdt</code> object is always treated as an external reference, and the memory it refers to is not released by <code>Datum::destroy</code>. The meaning of the integer type identifier is determined by the application, which is responsible for ensuring the set of "user-defined" type identifiers remains unique. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_use_of_bdld~3A~3Adatum"></a> <a class="anchor" id="usage.example_1~3A_basic_use_of_bdld~3A~3Adatum"></a> <a class="anchor" id="description.usage.example_1~3A_basic_use_of_bdld~3A~3Adatum"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Use of bdld::Datum: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example illustrates the construction, manipulation and lifecycle of datums. Datums are created via a set of static methods called <code>createTYPE</code>, <code>copyTYPE</code> or <code>adoptTYPE</code> where TYPE is one of the supported types. The creation methods take a value and sometimes an allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create an allocator that will supply dynamic memory needed for the <code>Datum</code> objects being created: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> oa(<span class="stringliteral">&quot;object&quot;</span>);
</pre></div><br/>
<br/>
 Then, we create a <code>Datum</code>, <code>number</code>, having an integer value of <code>3</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum number = Datum::createInteger(3);
</pre></div><br/>
<br/>
 Next, we verify that the created object actually represents an integer value and verify that the value was set correctly: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == number.isInteger());
  assert(3    == number.theInteger());
</pre></div><br/>
<br/>
 Note that this object does not allocate any dynamic memory on any supported platforms and thus we do not need to explicitly destroy this object to release any dynamic memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we create a <code>Datum</code>, <code>cityName</code>, having the string value "Boston": <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum cityName = Datum::copyString(<span class="stringliteral">&quot;Boston&quot;</span>, strlen(<span class="stringliteral">&quot;Boston&quot;</span>), &amp;oa);
</pre></div><br/>
<br/>
 Note, that the <code>copyString</code> makes a copy of the specified string and will allocate memory to hold the copy. Whether the copy is stored in the object internal storage buffer or in memory obtained from the allocator depends on the length of the string and the platform. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we verify that the created object actually represents a string value and verify that the value was set correctly: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span>     == cityName.isString());
  assert(<span class="stringliteral">&quot;Boston&quot;</span> == cityName.theString());
</pre></div><br/>
<br/>
 Finally, we destroy the <code>cityName</code> object to deallocate memory used to hold string value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum::destroy(cityName, &amp;oa);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_creating_datum_referring_to_the_array_of_datum_objects"></a> <a class="anchor" id="usage.example_2~3A_creating_datum_referring_to_the_array_of_datum_objects"></a> <a class="anchor" id="description.usage.example_2~3A_creating_datum_referring_to_the_array_of_datum_objects"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Creating Datum Referring to the Array of Datum objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates the construction of the <code>Datum</code> object referring to an existing array of <code>Datum</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create array of the <code>Datum</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> theDay[] = <span class="stringliteral">&quot;Birthday&quot;</span>;
  <span class="keyword">const</span> Datum array[2] = { Datum::createDate(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 10, 15)),
                           Datum::createStringRef(<a class="code" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">StringRef</a>(theDay), &amp;oa) };
</pre></div><br/>
<br/>
 Note, that in this case, the second element of the array does not make a copy of the string, but represents a string reference. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we create a <code>Datum</code> that refers to the array of Datums: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> Datum arrayRef = Datum::createArrayReference(array, 2, &amp;oa);
</pre></div><br/>
<br/>
 Next, we verify that the created <code>Datum</code> represents the array value and that elements of this array can be accessed. We also verify that the object refers to external data: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == arrayRef.isArray());
  assert(<span class="keyword">true</span> == arrayRef.isExternalReference());
  assert(2    == arrayRef.theArray().length());
  assert(array[0] == arrayRef.theArray().data()[0]);
  assert(array[1] == arrayRef.theArray().data()[1]);
</pre></div><br/>
<br/>
 Then, we call <code>destroy</code> on <code>arrayRef</code>, releasing any memory it may have allocated, and verify that the external array is intact: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum::destroy(arrayRef, &amp;oa);

  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2015, 10, 15) == array[0].theDate());
  assert(<span class="stringliteral">&quot;Birthday&quot;</span>               == array[1].theString());
</pre></div><br/>
<br/>
 Finally, we need to deallocate memory that was potentially allocated for the (external) <code>Datum</code> string in the external <code>array</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum::destroy(array[1], &amp;oa);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_creating_the_datum_having_the_array_value."></a> <a class="anchor" id="usage.example_3~3A_creating_the_datum_having_the_array_value."></a> <a class="anchor" id="description.usage.example_3~3A_creating_the_datum_having_the_array_value."></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Creating the Datum having the array value.: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates the construction of an owned array of datums. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>WARNING</em>: Using corresponding builder components is a preferred way of constructing <code>Datum</code> array objects. This example shows how a user-facing builder component might use the primitives provided in <code>bdld_datum</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we create an array of datums: <br/>
<br/>
<div class="fragment"><pre class="fragment">  DatumMutableArrayRef bartArray;
  Datum::createUninitializedArray(&amp;bartArray, 3, &amp;oa);
  bartArray.data()[0] = Datum::createStringRef(<span class="stringliteral">&quot;Bart&quot;</span>, &amp;oa);
  bartArray.data()[1] = Datum::createStringRef(<span class="stringliteral">&quot;Simpson&quot;</span>, &amp;oa);
  bartArray.data()[2] = Datum::createInteger(10);
  *bartArray.length() = 3;
</pre></div><br/>
<br/>
 Then, we construct the Datum that holds the array itself: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum bart = Datum::adoptArray(bartArray);
</pre></div><br/>
<br/>
 Note that after the <code>bartArray</code> has been adopted, the <code>bartArray</code> object can be destroyed without invalidating the array contained in the datum. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A DatumArray may be adopted by only one datum. If the DatumArray is not adopted, it must be destroyed via <code>disposeUnitializedArray</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we can access the contents of the array through the datum: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(3      == bart.theArray().length());
  assert(<span class="stringliteral">&quot;Bart&quot;</span> == bart.theArray()[0].theString());
</pre></div><br/>
<br/>
 Finally, we destroy the datum, which releases all memory associated with the array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum::destroy(bart, &amp;oa);
</pre></div><br/>
<br/>
 Note that the same allocator must be used to create the array, the elements, and to destroy the datum. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_4~3A_creating_the_datum_having_the_map_value"></a> <a class="anchor" id="usage.example_4~3A_creating_the_datum_having_the_map_value"></a> <a class="anchor" id="description.usage.example_4~3A_creating_the_datum_having_the_map_value"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="usage.example_4"></a> <a class="anchor" id="description.usage.example_4"></a> <a class="anchor" id="3.4.4"></a> </dd></dl>
<dl class="user"><dt><b>Example 4: Creating the Datum having the map value: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates the construction of a map of datums indexed by string keys. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>WARNING</em>: Using corresponding builder components is a preferred way of constructing <code>Datum</code> map objects. This example shows how a user-facing builder component might use the primitives provided in <code>bdld_datum</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we create a map of datums: <br/>
<br/>
<div class="fragment"><pre class="fragment">  DatumMutableMapRef lisaMap;
  Datum::createUninitializedMap(&amp;lisaMap, 3, &amp;oa);
  lisaMap.data()[0] = DatumMapEntry(<a class="code" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">StringRef</a>(<span class="stringliteral">&quot;firstName&quot;</span>),
                                    Datum::createStringRef(<span class="stringliteral">&quot;Lisa&quot;</span>, &amp;oa));
  lisaMap.data()[1] = DatumMapEntry(<a class="code" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">StringRef</a>(<span class="stringliteral">&quot;lastName&quot;</span>),
                                    Datum::createStringRef(<span class="stringliteral">&quot;Simpson&quot;</span>, &amp;oa));
  lisaMap.data()[2] = DatumMapEntry(<a class="code" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">StringRef</a>(<span class="stringliteral">&quot;age&quot;</span>),
                                    Datum::createInteger(8));
  *lisaMap.size() = 3;
</pre></div><br/>
<br/>
 Then, we construct the Datum that holds the map itself: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum lisa = Datum::adoptMap(lisaMap);
</pre></div><br/>
<br/>
 Note that after the <code>lisaMap</code> has been adopted, the <code>lisaMap</code> object can be destroyed without invalidating the map contained in the datum. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>DatumMutableMapRef</code> may be adopted by only one datum. If the <code>DatumMutableMapRef</code> is not adopted, it must be destroyed via <code>disposeUninitializedMap</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we can access the contents of the map through the datum: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(3      == lisa.theMap().size());
  assert(<span class="stringliteral">&quot;Lisa&quot;</span> == lisa.theMap().find(<span class="stringliteral">&quot;firstName&quot;</span>)-&gt;theString());
</pre></div><br/>
<br/>
 Finally, we destroy the datum, which releases all memory associated with the array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Datum::destroy(lisa, &amp;oa);
</pre></div><br/>
<br/>
 Note that the same allocator must be used to create the map, the elements, and to destroy the datum. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_5~3A_mass_destruction"></a> <a class="anchor" id="usage.example_5~3A_mass_destruction"></a> <a class="anchor" id="description.usage.example_5~3A_mass_destruction"></a> <a class="anchor" id="example_5"></a> <a class="anchor" id="usage.example_5"></a> <a class="anchor" id="description.usage.example_5"></a> <a class="anchor" id="3.4.5"></a> </dd></dl>
<dl class="user"><dt><b>Example 5: Mass Destruction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates an important idiom: the en masse destruction of a series of datums allocated in an arena. <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <span class="comment">// scope</span>
      <a class="code" href="classbsls_1_1AlignedBuffer.html">bsls::AlignedBuffer&lt;200&gt;</a> bufferStorage;
      <a class="code" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a> arena(bufferStorage.<a class="code" href="classbsls_1_1AlignedBuffer.html#a46dbd83076424915a6cab625e2088ca4">buffer</a>(), 200);

      Datum patty = Datum::copyString(<span class="stringliteral">&quot;Patty Bouvier&quot;</span>,
                                      strlen(<span class="stringliteral">&quot;Patty Bouvier&quot;</span>),
                                      &amp;arena);

      Datum selma = Datum::copyString(<span class="stringliteral">&quot;Selma Bouvier&quot;</span>,
                                      strlen(<span class="stringliteral">&quot;Selma Bouvier&quot;</span>),
                                      &amp;arena);
      DatumMutableArrayRef maggieArray;
      Datum::createUninitializedArray(&amp;maggieArray, 2, &amp;arena);
      maggieArray.data()[0] = Datum::createStringRef(<span class="stringliteral">&quot;Maggie&quot;</span>, &amp;arena);
      maggieArray.data()[1] = Datum::createStringRef(<span class="stringliteral">&quot;Simpson&quot;</span>, &amp;arena);
      *maggieArray.length() = 2;
      Datum maggie = Datum::adoptArray(maggieArray);
  } <span class="comment">// end of scope</span>
</pre></div><br/>
<br/>
 Here all the allocated memory is lodged in the <code>arena</code> allocator. At the end of the scope the memory is freed in a single step. Calling <code>destroy</code> for each datum individually is neither necessary nor permitted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_6~3A_user-defined,_error_and_binary_types"></a> <a class="anchor" id="usage.example_6~3A_user-defined,_error_and_binary_types"></a> <a class="anchor" id="description.usage.example_6~3A_user-defined,_error_and_binary_types"></a> <a class="anchor" id="example_6"></a> <a class="anchor" id="usage.example_6"></a> <a class="anchor" id="description.usage.example_6"></a> <a class="anchor" id="3.4.6"></a> </dd></dl>
<dl class="user"><dt><b>Example 6: User-defined, error and binary types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Imagine we are using <code>Datum</code> within an expression evaluation subsystem. Within that subsystem, along with the set of types defined by <code>Datum::DataType</code> we also need to hold <code>Sequence</code> and <code>Choice</code> types within <code>Datum</code> values (which are not natively represented by <code>Datum</code>). First, we define the set of types used by our subsystem that are an extension to the types in <code>DatumType</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Sequence {
      <span class="keyword">struct </span>Sequence *d_next_p;
      <span class="keywordtype">int</span>              d_value;
  };

  <span class="keyword">enum</span> ExtraExpressionTypes {
      e_SEQUENCE = 5,
      e_CHOICE = 6
  };
</pre></div><br/>
<br/>
 Notice that the numeric values will be provided as the <code>type</code> attribute when constructing <code>Datum</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then we create a <code>Sequence</code> object, and create a <code>Datum</code> to hold it (note that we've created the object on the stack for clarity): <br/>
<br/>
<div class="fragment"><pre class="fragment">  Sequence sequence;
  <span class="keyword">const</span> Datum datumS0 = Datum::createUdt(&amp;sequence, e_SEQUENCE);
  assert(<span class="keyword">true</span> == datumS0.isUdt());
</pre></div><br/>
<br/>
 Next, we verify that the <code>datumS0</code> refers to the external <code>Sequence</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdld_1_1DatumUdt.html">bdld::DatumUdt</a> udt = datumS0.theUdt();
  assert(e_SEQUENCE == udt.<a class="code" href="classbdld_1_1DatumUdt.html#ad5a383f628512553f6cdf5e8e3a0d586">type</a>());
  assert(&amp;sequence  == udt.<a class="code" href="classbdld_1_1DatumUdt.html#affb054e85791d6e0485e9875f94c164c">data</a>());
</pre></div><br/>
<br/>
 Then, we create a <code>Datum</code> to hold a <code>DatumError</code>, consisting of an error code and an error description message: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { e_FATAL_ERROR = 100 };
  Datum datumError = Datum::createError(e_FATAL_ERROR, <span class="stringliteral">&quot;Fatal error.&quot;</span>, &amp;oa);
  assert(<span class="keyword">true</span> == datumError.isError());
  DatumError error = datumError.theError();
  assert(e_FATAL_ERROR == error.code());
  assert(<span class="stringliteral">&quot;Fatal error.&quot;</span> == error.message());
  Datum::destroy(datumError, &amp;oa);
</pre></div><br/>
<br/>
 Finally, we create a <code>Datum</code> that holds an arbitrary binary data: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> buffer[] = { 1, 2, 3 };
  Datum datumBlob = Datum::copyBinary(buffer, <span class="keyword">sizeof</span>(buffer), &amp;oa);
  buffer[2] = 666;
  assert(<span class="keyword">true</span> == datumBlob.isBinary());
  DatumBinaryRef blob = datumBlob.theBinary();
  assert(blob.size() == 3 * <span class="keyword">sizeof</span>(int));
  assert(reinterpret_cast&lt;const int*&gt;(blob.data())[2] == 3);
  Datum::destroy(datumBlob, &amp;oa);
</pre></div><br/>
<br/>
 Note, that the bytes have been copied. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
