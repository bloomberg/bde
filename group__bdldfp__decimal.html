<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bdldfp_decimal Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdldfp_decimal<br/>
<small>
[<a class="el" href="group__bdldfp.html">Package bdldfp</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide IEEE-754 decimal floating-point types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html">bdldfp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestd.html">std</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Floating-Point Primer</a> <ul>
<li>
<a href="#4.1.1">Floating-Point Peculiarities</a> </li>
<li>
<a href="#4.1.2">Floating-Point Environment</a> <ul>
<li>
<a href="#4.1.2.1">Rounding Direction in The Environment</a> </li>
<li>
<a href="#4.1.2.2">Status Flags</a> </li>
<li>
<a href="#4.1.2.3">Floating-Point Traps</a> </li>
</ul>
</li>
<li>
<a href="#4.1.3">Floating-Point Terminology</a> </li>
</ul>
</li>
<li>
<a href="#4.2">Decimal Floating-Point</a> <ul>
<li>
<a href="#4.2.1"><em>WARNING</em>: Conversions from <code>float</code> and <code>double</code></a> </li>
<li>
<a href="#4.2.2">Cohorts</a> </li>
</ul>
</li>
<li>
<a href="#4.3">Standards Conformance</a> <ul>
<li>
<a href="#4.3.1">No Namespace Level Named Functions</a> </li>
<li>
<a href="#4.3.2">All Converting Constructors From Integer Types Are Explicit</a> </li>
<li>
<a href="#4.3.3">No Heterogeneous Comparisons Without Casting</a> </li>
<li>
<a href="#4.3.4">No Arithmetic Or Computing Support For <code>Decimal32</code></a> </li>
<li>
<a href="#4.3.5">Non-Standard Member Functions</a> </li>
</ul>
</li>
<li>
<a href="#4.4"><code>Decimal32</code> Type</a> </li>
<li>
<a href="#4.5"><code>Decimal64</code> Type</a> </li>
<li>
<a href="#4.6"><code>Decimal128</code> Type</a> </li>
<li>
<a href="#4.7">Decimal Number Formatting</a> </li>
<li>
<a href="#4.8">Preliminary Release - Known Bugs</a> </li>
<li>
<a href="#4.9">Usage</a> <ul>
<li>
<a href="#4.9.1">Example 1: Portable Initialization of Non-Integer, Constant Values</a> </li>
<li>
<a href="#4.9.2">Example 2: Precise Calculations with Decimal Values</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide IEEE-754 decimal floating-point types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="namespacebdldfp.html#a43ae56bdb8dbe611c06497965d404ccf">bdldfp::Decimal32</a> </td><td>32bit IEEE-754 decimal floating-point type  </td></tr>
<tr>
<td><a class="el" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">bdldfp::Decimal64</a> </td><td>64bit IEEE-754 decimal floating-point type  </td></tr>
<tr>
<td><a class="el" href="namespacebdldfp.html#a09749072ea49a21ac8b190a712f99dd5">bdldfp::Decimal128</a> </td><td>128bit IEEE-754 decimal floating-point type  </td></tr>
<tr>
<td><a class="el" href="classbdldfp_1_1DecimalNumGet.html">bdldfp::DecimalNumGet</a> </td><td>Stream Input Facet  </td></tr>
<tr>
<td><a class="el" href="classbdldfp_1_1DecimalNumPut.html">bdldfp::DecimalNumPut</a> </td><td>Stream Output Facet  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BDLDFP_DECIMAL_DF </td><td>Portable Decimal32 literal macro  </td></tr>
<tr>
<td>BDLDFP_DECIMAL_DD </td><td>Portable Decimal64 literal macro  </td></tr>
<tr>
<td>BDLDFP_DECIMAL_DL </td><td>Portable Decimal128 literal macro  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdldfp__decimalutil.html" title="Provide utilities dealing with floating point decimal objects.">Component bdldfp_decimalutil</a>, <a class="el" href="group__bdldfp__decimalconvertutil.html" title="Provide decimal floating-point conversion functions.">Component bdldfp_decimalconvertutil</a>, <a class="el" href="group__bdldfp__decimalplatform.html" title="Provide decimal floating-point platform information macros.">Component bdldfp_decimalplatform</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides classes that implement decimal floating-point types that conform in layout, encoding and operations to the IEEE-754 2008 standard. This component also provides two facets to support standard C++ streaming operators as specified by ISO/IEC TR-24733:2009. These classes are <code><a class="el" href="namespacebdldfp.html#a43ae56bdb8dbe611c06497965d404ccf">bdldfp::Decimal32</a></code> for 32-bit Decimal floating point numbers, <code><a class="el" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">bdldfp::Decimal64</a></code> for 64-bit Decimal floating point numbers, and <code><a class="el" href="namespacebdldfp.html#a09749072ea49a21ac8b190a712f99dd5">bdldfp::Decimal128</a></code> for 128-bit decimal floating point numbers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Decimal encoded floating-point numbers are important where exact representation of decimal fractions is required, such as in financial transactions. Binary encoded floating-point numbers are generally optimal for complex computation but cannot exactly represent commonly encountered numbers such as 0.1, 0.2, and 0.99. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The BDE decimal floating-point system has been designed from the ground up to be portable and support writing portable decimal floating-point user code, even for systems that do not have compiler or native library support for it; while taking advantage of native support (such as ISO/IEC TR 24732 - C99 decimal TR) when available. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdldfp_1_1DecimalNumGet.html">bdldfp::DecimalNumGet</a></code> and <code><a class="el" href="classbdldfp_1_1DecimalNumPut.html">bdldfp::DecimalNumPut</a></code> are IO stream facets. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="floating-point_primer"></a> <a class="anchor" id="description.floating-point_primer"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Floating-Point Primer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are several ways of represent numbers when using digital computers. The simplest would be an integer format, however such a format severely limits the range of numbers that can be represented; and it cannot represent real (non-integer) numbers directly at all. Integers might be used to represent real numbers of limited precision by treating them as a multiple of the real value being represented; these are often known as fixed-point numbers. However general computations require higher precision and a larger range than integer and fixed point types are able to efficiently provide. Floating-point numbers provide what integers cannot. They are able to represent a large range of real values (although not precisely) while using a fixed (and reasonable) amount of storage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Floating-point numbers are constructed from a set of significant digits of a radix on a sliding scale, where their position is determined by an exponent over the same radix. For example let's see some 32bit decimal (radix 10) floating-point numbers that have maximum 7 significant digits (significand): <br/>
<br/>
<div class="fragment"><pre class="fragment">   Significand | Exponent | Value        |
  -------------+----------+--------------+  In the Value column you may
       1234567 |        0 |   1234567.0  |  observer how the decimal point
       1234567 |        1 |  12345670.0  |  is <span class="stringliteral">&quot;floating&quot;</span> about the digits
       1234567 |        2 | 123456700.0  |  of the significand.
       1234567 |       -1 |    123456.7  |
       1234567 |       -2 |     12345.67 |
</pre></div><br/>
<br/>
 Floating-point numbers are standardized by IEEE-754 2008, in two major flavors: binary and decimal. Binary floating-point numbers are supported by most computer systems in the forms of the <code>float</code>, <code>double</code> and <code>long double</code> fundamental data types. While they are not required to be binary that is almost always the choice on modern binary computer architectures. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="floating-point_peculiarities"></a> <a class="anchor" id="floating-point_primer.floating-point_peculiarities"></a> <a class="anchor" id="description.floating-point_primer.floating-point_peculiarities"></a> <a class="anchor" id="4.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Floating-Point Peculiarities: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Floating-point approximation of real numbers creates a deliberate illusion. While it looks like we are working with real numbers, floating-point encodings are not able to represent real numbers precisely since they have a restricted number of digits in the significand. In fact, a 64 bit floating-point type can represent fewer distinct values than a 64 bit binary integer. Yet, because floating-point encodings can represent numbers over a much larger range, including extremely small (fractional) numbers, they are useful in practice. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Floating-point peculiarities may be split into three categories: those that are due to the (binary) radix/base, those that are inherent properties of any floating-point representation and finally those that are introduced by the IEEE-754 2008 standard. Decimal floating-point addresses the first set of surprises only; so users still need to be aware of the rest. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Floating-point types cannot exactly represent every number in their range. The consequences are surprising and unexpected for the newcomer. For example: when using binary floating-point numbers, the following expression is typically <em>false</em>: <code>0.1 + 0.2 == 0.3</code>. The problem is not limited to binary floating-point. Decimal floating-point cannot represent the value of one third exactly.  </li>
<li>
Unlike with real numbers, the order of operations on floating-point numbers is significant, due to accumulation of round off errors. Therefore floating-point arithmetic is neither commutative nor transitive. E.g., 2e-30 + 1e30 - 1e-30 - 1e30 will typically produce 0 (unless your significand can hold 60 decimal digits). Alternatively, 1e30 - 1e30 + 2e-30 - 1e-30 will typically produce 1e-30.  </li>
<li>
IEEE floating-point types can have special values: negative zero, negative and positive infinity; and they can be NaN (Not a Number, in two variants: quiet or signaling). A NaN (any variant) is never equal to anything else - including NaN or itself!  </li>
<li>
In IEEE floating-point there are at least two representations of 0, the positive zero and negative zero. Consequently unary - operators change the sign of the value 0; therefore leading to surprising results: if <code>f == 0.0</code> then <code>0 - f</code> and <code>-f</code> will not result in the same value, because <code>0 - f</code> will be +0.0' while <code>-f</code> will be -0.0. ** HERE WE ARE **  </li>
<li>
Most IEEE floating-point operations (like arithmetic) have implicit input parameters and output parameters (that do not show up in function signatures. The implicit input parameters are called <em>attributes</em> by IEEE while the outputs are called status flags. The C/C++ programming language defines a so-called floating-point environment that contains those attributes and flags (<code>&lt;fenv.h&gt;</code> C and <code>&lt;cfenv&gt;</code> C++ headers). To learn more about the floating point environment read the subsection of the same title, but first make sure you read the next point as well.  </li>
<li>
IEEE floating-points overloads some very common programming language terms: <em>exception</em>, <em>signal</em> and <em>handler</em> with IEEE floating-point specific meanings that are not to be confused with C or C++ or Posix terms of the same spelling. Floating-point exceptions are events that occur when a floating-point operations on the specified operands is unable to produce a perfect outcome; such as when the result of an operation is inexact. When a floating point exception occurs the (floating-point) - and reporting it is requested by a so-called trap attribute - the implementation signals the user(*) by invoking a default or a user-defined handler. None of the words <em>exception</em>, <em>signal</em>, and <em>handler</em> used above have nothing to do with C++ exceptions, Posix signals and the handlers of those. (To complicate matters more, C and Posix has decided to implement IEEE floating-point exception reporting as C/Posix signals - and therefore rendered them mostly useless.)  </li>
<li>
While a 32bit integer is a quite useful type for (integer) calculations, a 32bit floating-point type has such low accuracy (its significand is so short) that it is all but useless for calculation. Such types are called "interchange formats" by the IEEE standard and should not be used for calculations. (Except in special circumstances and by floating-point experts. Even a 16 bit binary floating-point type can be useful for an expert in special circumstances, for example in graphics acceleration hardware.)  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Notes: (*) IEEE Floating-point user is any person, hardware or software that uses the IEEE floating-point implementation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="floating-point_environment"></a> <a class="anchor" id="floating-point_primer.floating-point_environment"></a> <a class="anchor" id="description.floating-point_primer.floating-point_environment"></a> <a class="anchor" id="4.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Floating-Point Environment: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>NOTE: We currently do not give access to the user to the floating-point environment used by our decimal system, so description of it here is preliminary and generic. Note that since compilers and the C library already provides a (possibly binary floating-point only) environment and we cannot change that, our decimal floating-point environment implementation cannot conform to the C and C++ TRs (because those require extending the existing standard C library functions). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The floating-point environment provides implicit input and output parameters to floating-point operations (that are defined to use them). IEEE defined those parameters in principle, but how they are provided is left up to be designed/defined by the implementors of the programming languages. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>C (and consequently C++) decided to provide a so-called floating-point environment that has "thread storage duration", meaning that each thread of a multi-threaded program will have its own distinct floating-point environment. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The C/C++ floating-point environment consists of 3 major parts: the rounding mode, the traps and the status flags. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="rounding_direction_in_the_environment"></a> <a class="anchor" id="floating-point_environment.rounding_direction_in_the_environment"></a> <a class="anchor" id="floating-point_primer.floating-point_environment.rounding_direction_in_the_environment"></a> <a class="anchor" id="description.floating-point_primer.floating-point_environment.rounding_direction_in_the_environment"></a> <a class="anchor" id="4.1.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Rounding Direction in The Environment: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A floating-point <em>rounding direction</em> determines how is the significand of a higher (or infinite) precision number get rounded to fit into the limited number of significant digits (significand) of the floating-point representation that needs to store it as a result of an operation. Note that the rounding is done in the radix of the representation, so binary floating-point will do binary rounding while decimal floating-point will do decimal rounding - and not all rounding modes are useful with all radixes. An example of a generally applicable rounding mode would be <code>FE_TOWARDZERO</code> (round towards zero). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Most floating point operations in C and C++ do not take a rounding direction parameter (and the ones that are implemented as operators simply could not). When such operations (that do not have an explicit rounding direction parameter) need to do rounding, they use the rounding direction set in the floating-point environment (of their thread of execution). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="status_flags"></a> <a class="anchor" id="floating-point_environment.status_flags"></a> <a class="anchor" id="floating-point_primer.floating-point_environment.status_flags"></a> <a class="anchor" id="description.floating-point_primer.floating-point_environment.status_flags"></a> <a class="anchor" id="4.1.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Status Flags: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Floating point operations in C and C++ do not take a status flag output parameter. They report an important events (such as underflow, overflow or in inexact (rounded) result) by setting the appropriate status flag in the floating-point environment (of their thread of execution). (Note that this is very similar to how flags work in CPUs, and that is not a coincidence.) The flags work much like individual, boolean <code>errno</code> values. Operations may set them to true. Users may examine them (when interested) and also reset them (set them to 0) before an operation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="floating-point_traps"></a> <a class="anchor" id="floating-point_environment.floating-point_traps"></a> <a class="anchor" id="floating-point_primer.floating-point_environment.floating-point_traps"></a> <a class="anchor" id="description.floating-point_primer.floating-point_environment.floating-point_traps"></a> <a class="anchor" id="4.1.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Floating-Point Traps: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>IEEE says that certain floating-point events are floating-point exceptions and they result in invoking a handler. It may be a default handler (set a status flag and continue) or a user defined handler. Floating point traps are a C invention to enable "sort-of handlers" for floating point exceptions, but unfortunately they all go to the same handler: the <code>SIGFPE</code> handler. To add insult to injury, setting what traps are active (what will) cause a <code>SIGFPE</code>) is not standardized. So floating-point exceptions and handlers are considered pretty much useless in C. (All is not lost, since we do have the status flags. An application that wants to know about floating-point events can clear the flags prior to an operation and check their values afterwards.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="floating-point_terminology"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology"></a> <a class="anchor" id="4.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Floating-Point Terminology: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A floating-point representation of a number is defined as follows: <code>sign * significand * BASE^exponent</code>, where sign is -1 or +1, significand is an integer, BASE is a positive integer (but usually 2 or 10) and exponent is a negative or positive integer. Concrete examples of (decimal) numbers in the so-called scientific notation are: 123.4567 is 1.234567e2, while -0.000000000000000000000000000000000000001234567 would be -1.234567e-41. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="base"></a> <a class="anchor" id="floating-point_terminology.base"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.base"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.base"></a> <em>base</em>: <br/>
 the number base of the scaling used by the exponent; and by the significand</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="bias"></a> <a class="anchor" id="floating-point_terminology.bias"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.bias"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.bias"></a> <em>bias</em>: <br/>
 the number added to the exponent before it is stored in memory; 101, 398 and 6176 for the 32, 64 and 128 bit types respectively.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="exponent"></a> <a class="anchor" id="floating-point_terminology.exponent"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.exponent"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.exponent"></a> <em>exponent</em>: <br/>
 the scaling applied to the significand is calculated by raising the base to the exponent (which may be also negative)</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="quantum"></a> <a class="anchor" id="floating-point_terminology.quantum"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.quantum"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.quantum"></a> <em>quantum</em>: <br/>
 (IEEE-754) the value of one unit at the last significant digit position; in other words the smallest difference that can be represented by a floating-point number without changing its exponent. </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <div class="unhanging"> <ul>
<li>
Note that the C++ Decimal TR uses a different, not-specified, and not very useful definition, which we chose to ignore here. </li>
</ul>
</div></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"><div class="unhanging"> </div></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="mantissa"></a> <a class="anchor" id="floating-point_terminology.mantissa"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.mantissa"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.mantissa"></a> <em>mantissa</em>: <br/>
 the old name for the significand</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="radix"></a> <a class="anchor" id="floating-point_terminology.radix"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.radix"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.radix"></a> <em>radix</em>: <br/>
 another name for base</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="sign"></a> <a class="anchor" id="floating-point_terminology.sign"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.sign"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.sign"></a> <em>sign</em>: <br/>
 +1 or -1, determines if the number is positive or negative. It is normally represented by a single sign bit.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="significand"></a> <a class="anchor" id="floating-point_terminology.significand"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.significand"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.significand"></a> <em>significand</em>: <br/>
 the significant digits of the floating-point number; the value of the number is: <code>sign * significand * base^exponent</code></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="precision"></a> <a class="anchor" id="floating-point_terminology.precision"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.precision"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.precision"></a> <em>precision</em>: <br/>
 the significant digits of the floating-point type in its base</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="decimal_precision"></a> <a class="anchor" id="floating-point_terminology.decimal_precision"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.decimal_precision"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.decimal_precision"></a> <em>decimal precision</em>: <br/>
 the maximum significant decimal digits of the floating-point type</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="range"></a> <a class="anchor" id="floating-point_terminology.range"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.range"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.range"></a> <em>range</em>: <br/>
 the smallest and largest number the type can represent. Note that for floating-point types there are at least <em>two</em> interpretations of minimum. It may be the largest negative number <em>or</em> the smallest number in absolute value) that can be represented.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="normalized_number"></a> <a class="anchor" id="floating-point_terminology.normalized_number"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.normalized_number"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.normalized_number"></a> <em>normalized number</em>: <br/>
 <code>1 &lt;= significand &lt;= base</code></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="normalization"></a> <a class="anchor" id="floating-point_terminology.normalization"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.normalization"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.normalization"></a> <em>normalization</em>: <br/>
 finding the exponent such as <code>1 &lt;= significand &lt;= base</code></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="denormal_number"></a> <a class="anchor" id="floating-point_terminology.denormal_number"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.denormal_number"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.denormal_number"></a> <em>denormal number</em>: <br/>
 <code>significand &lt; 1</code></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="densely_packed_decimal"></a> <a class="anchor" id="floating-point_terminology.densely_packed_decimal"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.densely_packed_decimal"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.densely_packed_decimal"></a> <em>densely packed decimal</em>: <br/>
 one of the two IEEE significand encoding schemes</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="binary_integer_significand"></a> <a class="anchor" id="floating-point_terminology.binary_integer_significand"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.binary_integer_significand"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.binary_integer_significand"></a> <em>binary integer significand</em>: <br/>
 one of the two IEEE significand encoding schemes</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="cohorts"></a> <a class="anchor" id="floating-point_terminology.cohorts"></a> <a class="anchor" id="floating-point_primer.floating-point_terminology.cohorts"></a> <a class="anchor" id="description.floating-point_primer.floating-point_terminology.cohorts"></a> <em>cohorts</em>: <br/>
 equal numbers encoded using different exponents (to signify accuracy)</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="decimal_floating-point"></a> <a class="anchor" id="description.decimal_floating-point"></a> <a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>Decimal Floating-Point: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Binary floating-point formats give best accuracy, they are the fastest (on binary computers), and were carefully designed by IEEE to minimize rounding errors (errors due to the inherent imprecision of floating-point types) during a lengthy calculation. This makes them the best solution for and serious scientific computation. However, they have a fatal flow when it comes to numbers and calculations that involve humans. Humans think in base 10 - decimal. And as the example has shown earlier, binary floating-point formats are unable to precisely represent very common decimal real numbers; with binary floating-point <code>0.1 + 0.2 != 0.3</code>. (Why? Because none of the three numbers in that expression have an exact binary floating-point representation.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Financial calculations are governed by laws and expectations that are based on decimal (10 based) thinking. Due to the inherent limitations of the binary floating-point format, doing such decimal based calculations and algorithms using binary floating-point numbers is so involved and hard that that it is considered not feasible. The IEEE-754 committee have recognized the issue and added specifications for 3 decimal floating-point types into their 2008 standard: the 32, 64 and 128 bits decimal floating-point formats. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Floating-point types are carefully designed trade-offs between saving space (in memory), CPU cycles (for calculations) and still provide useful accuracy for computations. Decimal floating-point types represent further compromises (compared to binary floating-points) in being able to represent less numbers (than their binary counterpats) and being slower, but providing exact representations for the numbers humans care about. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In decimal floating-point world <code>0.1 + 0.2 == 0.3</code>, as humans expect; because each of those 3 numbers can be represented <em>exactly</em> in a decimal floating-point format. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="warning~3A_conversions_from_float_and_double"></a> <a class="anchor" id="decimal_floating-point.warning~3A_conversions_from_float_and_double"></a> <a class="anchor" id="description.decimal_floating-point.warning~3A_conversions_from_float_and_double"></a> <a class="anchor" id="warning"></a> <a class="anchor" id="decimal_floating-point.warning"></a> <a class="anchor" id="description.decimal_floating-point.warning"></a> <a class="anchor" id="4.2.1"></a> </dd></dl>
<dl class="user"><dt><b>WARNING: Conversions from float and double: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Clients should <em>be</em> <em>careful</em> when using the conversions from <code>float</code> and <code>double</code> provided by this component. In situations where a <code>float</code> or <code>double</code> was originally obtained from a decimal floating point representation (e.g., a <code>bdldfp::Decimal</code>, or a string, like "4.1"), the conversions in <code>bdldfp_decimalconvertutil</code> will provide the correct conversion back to a decimal floating point value. The conversions in this component provide the closest decimal floating point value to the supplied binary floating point representation, which may replicate imprecisions required to initially approximate the value in a binary representation. The conversions in this component are typically useful when converting binary floating point values that have undergone mathematical operations that require rounding (so they are already in-exact approximations). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="decimal_floating-point.cohorts"></a> <a class="anchor" id="description.decimal_floating-point.cohorts"></a> <a class="anchor" id="4.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Cohorts: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the binary floating-point world the formats are optimized for the highest precision, range and speed. They are stored normalized and therefore store no information about their accuracy. In finances, the area that decimal floating-point types target, accuracy of a number is usually very important. We may have a number that is 1, but we know it may be 1.001 or 1.002 etc. And we may have another number 1, which we know to be accurate to 6 significant digits. We would display the former number as <code>1.00</code> and the latter number as <code>1.00000</code>. The decimal floating-point types are able to store both numbers <em>and</em> their precision using so call cohorts. The <code>1.00</code> will be stored as <code>100e-2</code> while <code>1.00000</code> will be stored as 100000e-5. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Cohorts compare equal, and mostly behave the same way in calculation except when it comes to the accuracy of the result. If I have a number that is accurate to 5 digits only, it would be a mistake to try to expect more than 5 digits accuracy from a calculation involving it. The IEEE-754 rules of cohorts (in calculations) ensures that results will be a cohort that indicates the proper expected accuracy. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="standards_conformance"></a> <a class="anchor" id="description.standards_conformance"></a> <a class="anchor" id="4.3"></a> </dd></dl>
<dl class="user"><dt><b>Standards Conformance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The component has also been designed to resemble the C++ Decimal Floating-Point Technical Report ISO/IEC TR-24733 of 2009 and its C++11 updates of ISO/IEC JTC1 SC22 WG21 N3407=12-0097 of 2012 as much as it is possible with C++03 compilers and environments that do not provide decimal floating-point support in any form. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>At the time of writing there is just one standard about decimal-floating point, the IEEE-754 2008 standard and the content of this component conforms to it. The component does not fully implement all required IEEE-754 functionality because due to our architectural design guidelines some of these must go into a separate so-called utility component.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The component uses the ISO/IEC TR 24732 - the C Decimal Floating-Point TR - in its implementation where it is available. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The component closely resembles ISO/IEC TR 24733 - the C++ Decimal Floating-Point TR - but does not fully conform to it for several reasons. The major reasons are: it is well known that TR 24733 has to change before it is included into the C++ standard; the TR would require us to change system header files we do not have access to. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following subsections the differences to the C++ technical report are explained in detail, including a short rationale. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="no_namespace_level_named_functions"></a> <a class="anchor" id="standards_conformance.no_namespace_level_named_functions"></a> <a class="anchor" id="description.standards_conformance.no_namespace_level_named_functions"></a> <a class="anchor" id="4.3.1"></a> </dd></dl>
<dl class="user"><dt><b>No Namespace Level Named Functions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>BDE design guidelines do not allow namespace level functions other than operators and aspects. According to BDE design principles all such functions are placed into a utility component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="all_converting_constructors_from_integer_types_are_explicit"></a> <a class="anchor" id="standards_conformance.all_converting_constructors_from_integer_types_are_explicit"></a> <a class="anchor" id="description.standards_conformance.all_converting_constructors_from_integer_types_are_explicit"></a> <a class="anchor" id="4.3.2"></a> </dd></dl>
<dl class="user"><dt><b>All Converting Constructors From Integer Types Are Explicit: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This change is necessary to disable the use of comparison operators without explicit casting. See No Heterogeneous Comparisons Without Casting. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="no_heterogeneous_comparisons_without_casting"></a> <a class="anchor" id="standards_conformance.no_heterogeneous_comparisons_without_casting"></a> <a class="anchor" id="description.standards_conformance.no_heterogeneous_comparisons_without_casting"></a> <a class="anchor" id="4.3.3"></a> </dd></dl>
<dl class="user"><dt><b>No Heterogeneous Comparisons Without Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The C and C++ Decimal TRs refer to IEEE-754 for specifications of the heterogeneous comparison operators (comparing decimal floating-point types to binary floating-point types and integer types); however IEEE-754 does <em>not</em> specify such operations - leaving them unspecified. To make matters worse, there are two possible ways to implement those operators (convert the decimal to the other type, or convert the other type to decimal first) and depending on which one is chosen, the result of the operator will be different. Also, the C committee is considering the removal of those operators. We have removed them until we know how to implement them. Comparing decimal types to those other types is still possible, it just requires explicit casting/conversion from the user code. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="no_arithmetic_or_computing_support_for_decimal32"></a> <a class="anchor" id="standards_conformance.no_arithmetic_or_computing_support_for_decimal32"></a> <a class="anchor" id="description.standards_conformance.no_arithmetic_or_computing_support_for_decimal32"></a> <a class="anchor" id="4.3.4"></a> </dd></dl>
<dl class="user"><dt><b>No Arithmetic Or Computing Support For Decimal32: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>IEEE-754 designates the 32 bit floating-point types "interchange formats" and does not require or recommend arithmetic or computing support of any kind for them. The C (and consequently the C++) TR goes against the IEEE design and requires <code>_Decimal32</code> (and <code>std::decimal32</code>) to provide computing support, however, in a twist, allows it to be performed using one of the larger types (64 or 128 bits). The rationale from the C committee is that small embedded systems may need to do their calculations using the small type (so they have made it mandatory for everyone). Industry experience with the <code>float</code> C type (32bit floating-point type, usually binary) has shown that enabling computing using small floating-point types are a mistake that causes novice programmers to write calculations that are very slow and inaccurate. There we have decided that unless a compelling use case presents itself we are not going to make it easy to write slow and inaccurate programs using our implementation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We recommend what IEEE recommends: convert your 32 bit types on receipt to a type with higher precision (usually 64 bit will suffice), so you calculations using that larger type, and convert it back to 32 bit type only if your output interchange format requires it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="non-standard_member_functions"></a> <a class="anchor" id="standards_conformance.non-standard_member_functions"></a> <a class="anchor" id="description.standards_conformance.non-standard_member_functions"></a> <a class="anchor" id="4.3.5"></a> </dd></dl>
<dl class="user"><dt><b>Non-Standard Member Functions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to BDE rules of design and some implementation needs we have extended the C++ TR mandated interface of the decimal floating-point types to include support for accessing the underlying data (type), to parse literals for the portable literal support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that using any of these public member functions will render your code non-portable to non-BDE (but standards conforming) implementations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="decimal32_type"></a> <a class="anchor" id="description.decimal32_type"></a> <a class="anchor" id="4.4"></a> </dd></dl>
<dl class="user"><dt><b>Decimal32 Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An interchange format type that supports input, output, relational operators construction from the TR mandates data types but no arithmetic or other computing operations. The type has the size of exactly 32 bits. It supports 7 significant decimal digits and an exponent range of -95 to 96. The smallest non-zero value that can be represented is 1e-101. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Portable <code>Decimal32</code> literals are created using the <code>BDLDFP_DECIMAL_DF</code> macro. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="decimal64_type"></a> <a class="anchor" id="description.decimal64_type"></a> <a class="anchor" id="4.5"></a> </dd></dl>
<dl class="user"><dt><b>Decimal64 Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An basic format type that supports input, output, relational operators construction from the TR mandates data types and arithmetic or operations. The type has the size of exactly 64 bits. It supports 16 significant decimal digits and an exponent range of -383 to 384. The smallest non-zero value that can be represented is 1e-398. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Portable <code>Decimal64</code> literals are created using the <code>BDLDFP_DECIMAL_DD</code> macro. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="decimal128_type"></a> <a class="anchor" id="description.decimal128_type"></a> <a class="anchor" id="4.6"></a> </dd></dl>
<dl class="user"><dt><b>Decimal128 Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An basic format type that supports input, output, relational operators construction from the TR mandates data types and arithmetic or operations. The type has the size of exactly 128 bits. It supports 34 significant decimal digits and an exponent range of -6143 to 6144. The smallest non-zero value that can be represented is 1e-6176. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Portable <code>Decimal128</code> literals are created using the <code>BDLDFP_DECIMAL_DL</code> macro. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="decimal_number_formatting"></a> <a class="anchor" id="description.decimal_number_formatting"></a> <a class="anchor" id="4.7"></a> </dd></dl>
<dl class="user"><dt><b>Decimal Number Formatting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Streaming decimal floating point nubmers to an output stream currently supports formatting flags for width, capitalization, and justification. Because of potential for future improvements in format handling, the operations should not be used for serialization. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="preliminary_release_-_known_bugs"></a> <a class="anchor" id="description.preliminary_release_-_known_bugs"></a> <a class="anchor" id="4.8"></a> </dd></dl>
<dl class="user"><dt><b>Preliminary Release - Known Bugs: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Stream output operators do not obey formatting flags or the precision algorithm as required by the TR; they instead print all significant digits all the time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.9"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section, we show the intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_portable_initialization_of_non-integer,_constant_values"></a> <a class="anchor" id="usage.example_1~3A_portable_initialization_of_non-integer,_constant_values"></a> <a class="anchor" id="description.usage.example_1~3A_portable_initialization_of_non-integer,_constant_values"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="4.9.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Portable Initialization of Non-Integer, Constant Values: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If your compiler does not support the C Decimal TR, it does not support decimal floating-point literals, only binary floating-point literals. The problem with binary floating-point literals is the same as with binary floating-point numbers in general: they cannot represent the decimal numbers we care about. To solve this problem there are 3 macros provided by this component that can be used to initialize decimal floating-point types with non-integer values, precisely. These macros will evaluate to real, C language literals where those are supported and to a runtime-parsed solution otherwise. The following code demonstrates the use of these macros as well as mixed-type arithmetics and comparisons: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdldfp_1_1Decimal__Type32.html">bdldfp::Decimal32</a>  d32( <a class="code" href="bdldfp__decimal_8h.html#a2ee321cfb5b9c905cfffa9d2d82ccaa2">BDLDFP_DECIMAL_DF</a>(0.1));
  <a class="code" href="classbdldfp_1_1Decimal__Type64.html">bdldfp::Decimal64</a>  d64( <a class="code" href="bdldfp__decimal_8h.html#a81f966a197ae358644d447b8ff347cb4">BDLDFP_DECIMAL_DD</a>(0.2));
  <a class="code" href="classbdldfp_1_1Decimal__Type128.html">bdldfp::Decimal128</a> d128(<a class="code" href="bdldfp__decimal_8h.html#afc7ee3348bf7ce0b6b28ad011e1f48db">BDLDFP_DECIMAL_DL</a>(0.3));

  assert(d32 + d64 == d128);
  assert(<a class="code" href="classbdldfp_1_1Decimal__Type64.html">bdldfp::Decimal64</a>(d32)  * 10 == <a class="code" href="classbdldfp_1_1Decimal__Type64.html">bdldfp::Decimal64</a>(1));
  assert(d64  * 10 == <a class="code" href="classbdldfp_1_1Decimal__Type64.html">bdldfp::Decimal64</a>(2));
  assert(d128 * 10 == <a class="code" href="classbdldfp_1_1Decimal__Type128.html">bdldfp::Decimal128</a>(3));
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_precise_calculations_with_decimal_values"></a> <a class="anchor" id="usage.example_2~3A_precise_calculations_with_decimal_values"></a> <a class="anchor" id="description.usage.example_2~3A_precise_calculations_with_decimal_values"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="4.9.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Precise Calculations with Decimal Values: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we need to add two (decimal) numbers and then tell if the result is a particular decimal number or not. That can get difficult with binary floating-point, but easy with decimal: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (std::numeric_limits&lt;double&gt;::radix == 2) {
    assert(.1 + .2 != .3);
  }
  assert(<a class="code" href="bdldfp__decimal_8h.html#a81f966a197ae358644d447b8ff347cb4">BDLDFP_DECIMAL_DD</a>(0.1) + <a class="code" href="bdldfp__decimal_8h.html#a81f966a197ae358644d447b8ff347cb4">BDLDFP_DECIMAL_DD</a>(0.2)
      == <a class="code" href="bdldfp__decimal_8h.html#a81f966a197ae358644d447b8ff347cb4">BDLDFP_DECIMAL_DD</a>(0.3));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:19 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
