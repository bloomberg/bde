<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlt_prolepticdateimputil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlt_prolepticdateimputil<br/>
<small>
[<a class="el" href="group__bdlt.html">Package bdlt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide low-level support functions for date-value manipulation.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html">bdlt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Representations, Valid Dates, and Leap Years</a> </li>
<li>
<a href="#3.2">Caching</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Use as a General Purpose Utility</a> </li>
<li>
<a href="#3.3.2">Example 2: Implement a Value-Semantic Date Type</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide low-level support functions for date-value manipulation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlt_1_1ProlepticDateImpUtil.html">bdlt::ProlepticDateImpUtil</a> </td><td>low-level date-related stateless functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlt__date.html" title="Provide a value-semantic type to represent dates.">Component bdlt_date</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a utility <code>struct</code>, <code><a class="el" href="structbdlt_1_1ProlepticDateImpUtil.html">bdlt::ProlepticDateImpUtil</a></code>, that defines a suite of low-level, date-related functions, which can be used to validate, manipulate, and convert among values in three different formats: <br/>
<br/>
<div class="fragment"><pre class="fragment">  YMD: year/month/day date
   YD: year/day-of-year date
    S: serial date
</pre></div><br/>
<br/>
 The supplied functionality can also be used (e.g.) for determining leap years, finding the last day in a given month, and for determining the day of the week for a given date. Note that in this component a "date" is understood to represent a valid day in the (YMD) range <code>0001/01/01</code> to <code>9999/12/31</code> according to the <em>proleptic</em> <em>Gregorian</em> <em>calendar</em>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  http:<span class="comment">//en.wikipedia.org/wiki/Proleptic_Gregorian_calendar</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="representations,_valid_dates,_and_leap_years"></a> <a class="anchor" id="description.representations,_valid_dates,_and_leap_years"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Representations, Valid Dates, and Leap Years: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "Calendar Date", or "year-month-day (ymd)", is the canonical representation and is denoted as "YYYY/MM/DD", with valid years being in the range <code>[1 .. 9999]</code>. Within a valid year, valid months and valid days are confined to the respective ranges <code>[1 .. 12]</code> and <code>[1 .. 31]</code>. Valid dates in this representation range from <code>0001/01/01</code> to <code>9999/12/31</code>, governed by the proleptic Gregorian calendar. Specifically, within the 4th, 6th, 9th, and 11th months (respectively, April, June, September, and November) of any year, valid days are in the range <code>[1 .. 30]</code>. Valid days for all other months of any year, with exception of the 2nd month (February), are in the range <code>[1 .. 31]</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In a <em>leap</em> <em>year</em>, February has 29 days instead of the usual 28. Thus, the range of valid days for February in a leap year is <code>[1 .. 29]</code>; otherwise, the range of valid days for February is <code>[1 .. 28]</code>. The proleptic Gregorian calendar retroactively applies the leap year rules instituted by the Gregorian Reformation to all years. In particular, a year in the range <code>[1 .. 9999]</code> is a leap year if it is divisible by 4, but <em>not</em> divisible by 100, <em>unless</em> it is <em>also</em> divisible by 400. (Expressed conversely, all years <em>not</em> divisible by 4 are non-leap years, as are all century years <em>not</em> divisible by 400 (e.g., 1900). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "Day-Of-Year Date", or "year-day (yd)" representation, denoted by "YYYY/DDD", represents dates by their year (again, in the range <code>[1 .. 9999]</code>) and the day of year, in the range <code>[1 .. 366]</code>. Valid date values in this representation range from <code>0001/001</code> to <code>9999/365</code>, with a day-of-year value of 366 permitted for leap years only. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "Serial Date" representation depicts dates as consecutive integers beginning with 1 (representing <code>0001/01/01</code>). In this representation, valid date values are in the range <code>[1 .. 3652059]</code>, with 3652059 representing <code>9999/12/31</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="caching"></a> <a class="anchor" id="description.caching"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Caching: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>To achieve maximal runtime performance, several of the functions in this component reserve the right to be implemented using statically cached (i.e., tabulated, pre-calculated) values (which is inherently thread-safe). For all functions where a cache may be used, <code><a class="el" href="structbdlt_1_1ProlepticDateImpUtil.html">bdlt::ProlepticDateImpUtil</a></code> also explicitly provides a <code>NoCache</code> version (e.g., <code>ymdToSerialNoCache</code>) that is guaranteed NOT to use a cache. Although the "normal" (potentially cached) functions typically gain huge performance advantages, the <code>NoCache</code> versions may conceivably be preferred by the performance-minded user who is <em>reasonably</em> <em>certain</em> that the vast majority of date values of interest will miss the cache (thus incurring a small, but unnecessary overhead for the cache-hit tests). Note, however, that the <code>NoCache</code> function variants are provided primarily for testing and for generating the cache in the first place (see this component's test driver). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_use_as_a_general_purpose_utility"></a> <a class="anchor" id="usage.example_1~3A_use_as_a_general_purpose_utility"></a> <a class="anchor" id="description.usage.example_1~3A_use_as_a_general_purpose_utility"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Use as a General Purpose Utility: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The primary purpose of this component is to support the implementation of a general-purpose, value-semantic (vocabulary) "Date" type. However, it also provides many low-level utility functions suitable for direct use by other clients. In this example we employ several of the functions from this component to ask questions about particular dates in one of the three supported formats. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, what day of the week was January 3, 2010? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(2 == <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a8115fbf0ecae1a35abc2ae4fca4511a0">bdlt::ProlepticDateImpUtil::ymdToDayOfWeek</a>(2010, 3, 1));
                                                           <span class="comment">// 2 means Monday.</span>
</pre></div><br/>
<br/>
 Then, was the year 2000 a leap year? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a1fecbcdbe7e66b17dbbf6a1544d3105e">bdlt::ProlepticDateImpUtil::isLeapYear</a>(2000));
                                                           <span class="comment">// Yes, it was.</span>
</pre></div><br/>
<br/>
 Next, was February 29, 1900 a valid date in history? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">false</span> == <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a99f9b08ec8469dbdac0f89d5bec7a546">bdlt::ProlepticDateImpUtil::isValidYearMonthDay</a>(1900,
                                                                     2,
                                                                    29));
                                                           <span class="comment">// No, it was not.</span>
</pre></div><br/>
<br/>
 Then, what was the last day of February in 1600? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(29 == <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a5bd1639e3dab126d3b2bddd5790c942c">bdlt::ProlepticDateImpUtil::lastDayOfMonth</a>(1600, 2));
                                                           <span class="comment">// The 29th.</span>
</pre></div><br/>
<br/>
 Next, how many leap years occurred from 1959 to 2012, inclusive? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(14 == <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a084fa1b686b2ba0e924823c3d9de3dc5">bdlt::ProlepticDateImpUtil::numLeapYears</a>(1959, 2012));
                                                           <span class="comment">// There were 14.</span>
</pre></div><br/>
<br/>
 Now, on what day of the year will February 29, 2020 fall? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(60 == <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a4f1d5e799aadacc19a83d7d3e8cb549e">bdlt::ProlepticDateImpUtil::ymdToDayOfYear</a>(2020, 2, 29));
                                                           <span class="comment">// The 60th one.</span>
</pre></div><br/>
<br/>
 Finally, in what month did the 120th day of 2011 fall? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(4 == <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a4f9a99f627b75258482447a0252d0a21">bdlt::ProlepticDateImpUtil::ydToMonth</a>(2011, 120));
                                                           <span class="comment">// 4 means April.</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_implement_a_value-semantic_date_type"></a> <a class="anchor" id="usage.example_2~3A_implement_a_value-semantic_date_type"></a> <a class="anchor" id="description.usage.example_2~3A_implement_a_value-semantic_date_type"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Implement a Value-Semantic Date Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using the functions supplied in this component, we can easily implement a C++ class that represents abstract (<em>mathematical</em>) date values and performs common operations on them. The internal representation could be any of the three supported by this component. In this example, we choose to represent the date value internally as a "serial date". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a partial interface of our date class, <code>MyDate</code>, omitting many methods, free operators, and <code>friend</code> declarations that do not contribute substantively to illustrating use of this component: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyDate {
      <span class="comment">// This class represents a valid date, in the proleptic Gregorian</span>
      <span class="comment">// calendar, in the range &#39;[0001/01/01 .. 9999/12/31]&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_serialDate;  <span class="comment">// 1 = 0001/01/01, 2 = 0001/01/02, etc.</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyDate&amp;, <span class="keyword">const</span> MyDate&amp;);
      <span class="comment">// ...</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE CREATORS</span>
      <span class="keyword">explicit</span> MyDate(<span class="keywordtype">int</span> serialDate);
          <span class="comment">// Create a &#39;MyDate&#39; object initialized with the value indicated by</span>
          <span class="comment">// the specified &#39;serialDate&#39;.  The behavior is undefined unless</span>
          <span class="comment">// &#39;serialDate&#39; represents a valid &#39;MyDate&#39; value.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">bool</span> isValid(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day);
          <span class="comment">// Return &#39;true&#39; if the specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;</span>
          <span class="comment">// represent a valid value for a &#39;MyDate&#39; object, and &#39;false&#39;</span>
          <span class="comment">// otherwise.</span>

      <span class="comment">// CREATORS</span>
      MyDate();
          <span class="comment">// Create a &#39;MyDate&#39; object having the earliest supported valid</span>
          <span class="comment">// date value, i.e., &quot;0001/01/01&quot;.</span>

      MyDate(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day);
          <span class="comment">// Create a &#39;MyDate&#39; object having the value represented by the</span>
          <span class="comment">// specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;.  The behavior is undefined</span>
          <span class="comment">// unless &#39;isValid(year, month, day)&#39; returns &#39;true&#39;.</span>

      <span class="comment">// ...</span>

      <span class="comment">// MANIPULATORS</span>

      <span class="comment">// ...</span>

      <span class="keywordtype">void</span> setYearMonthDay(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day);
          <span class="comment">// Set this &#39;MyDate&#39; object to have the value represented by the</span>
          <span class="comment">// specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;.  The behavior is undefined</span>
          <span class="comment">// unless &#39;isValid(year, month, day)&#39; returns &#39;true&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">void</span> getYearMonthDay(<span class="keywordtype">int</span> *year, <span class="keywordtype">int</span> *month, <span class="keywordtype">int</span> *day) <span class="keyword">const</span>;
          <span class="comment">// Load, into the specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;, the</span>
          <span class="comment">// individual attribute values of this &#39;MyDate&#39; object.</span>

      <span class="keywordtype">int</span> day() <span class="keyword">const</span>;
          <span class="comment">// Return the day of the month in the range &#39;[1 .. 31]&#39; of this</span>
          <span class="comment">// &#39;MyDate&#39; object.</span>

      <span class="keywordtype">int</span> month() <span class="keyword">const</span>;
          <span class="comment">// Return the month of the year in the range &#39;[1 .. 12]&#39; of this</span>
          <span class="comment">// &#39;MyDate&#39; object.</span>

      <span class="keywordtype">int</span> year() <span class="keyword">const</span>;
          <span class="comment">// Return the year in the range &#39;[1 .. 9999]&#39; of this &#39;MyDate&#39;</span>
          <span class="comment">// object.</span>

      <span class="comment">// ...</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;MyDate&#39; objects have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two dates have the same</span>
      <span class="comment">// value if each of the corresponding &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;</span>
      <span class="comment">// attributes respectively have the same value.</span>

  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Then, we provide an implementation of the <code>MyDate</code> methods and associated free operators declared above, using <code>bsls_assert</code> to identify preconditions and invariants where appropriate. Note the use of various <code><a class="el" href="structbdlt_1_1ProlepticDateImpUtil.html">bdlt::ProlepticDateImpUtil</a></code> functions in the code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// PRIVATE CREATORS</span>
  <span class="keyword">inline</span>
  MyDate::MyDate(<span class="keywordtype">int</span> serialDate)
  : d_serialDate(serialDate)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(<a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a37fb7b0653c3ae5242ab111f2c78e712">bdlt::ProlepticDateImpUtil::isValidSerial</a>(
                                                              d_serialDate));
  }

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> MyDate::isValid(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day)
  {
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a99f9b08ec8469dbdac0f89d5bec7a546">bdlt::ProlepticDateImpUtil::isValidYearMonthDay</a>(year,
                                                             month,
                                                             day);
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyDate::MyDate()
  : d_serialDate(1)
  {
  }

  <span class="keyword">inline</span>
  MyDate::MyDate(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day)
  : d_serialDate(bdlt::ProlepticDateImpUtil::ymdToSerial(year, month, day))
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(isValid(year, month, day));
  }

  <span class="comment">// ...</span>

  <span class="comment">// MANIPULATORS</span>

  <span class="comment">// ...</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> MyDate::setYearMonthDay(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(isValid(year, month, day));

      d_serialDate = <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#ab77b0c599f921525edb9e5f8979df9eb">bdlt::ProlepticDateImpUtil::ymdToSerial</a>(year,
                                                             month,
                                                             day);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> MyDate::getYearMonthDay(<span class="keywordtype">int</span> *year, <span class="keywordtype">int</span> *month, <span class="keywordtype">int</span> *day)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(year);
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(month);
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(day);

      <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a9271a95abc0decbe35ddf712570bd427">bdlt::ProlepticDateImpUtil::serialToYmd</a>(year,
                                              month,
                                              day,
                                              d_serialDate);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyDate::day()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#aba055385f0fb41b78b7ab43abfd0a267">bdlt::ProlepticDateImpUtil::serialToDay</a>(d_serialDate);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyDate::month()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a8ad810ebf9d6ac2e4aaef9b377779cbf">bdlt::ProlepticDateImpUtil::serialToMonth</a>(d_serialDate);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyDate::year()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1ProlepticDateImpUtil.html#a566c41cf76022c6279ea847c00de31f2">bdlt::ProlepticDateImpUtil::serialToYear</a>(d_serialDate);
  }

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_serialDate == rhs.d_serialDate;
  }
</pre></div><br/>
<br/>
 Next, we illustrate basic use of our <code>MyDate</code> class, starting with the creation of a default object, <code>d1</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyDate d1;                        assert(   1 == d1.year());
                                    assert(   1 == d1.month());
                                    assert(   1 == d1.day());
</pre></div><br/>
<br/>
 Now, we set <code>d1</code> to July 4, 1776 via the <code>setYearMonthDay</code> method, but we first verify that it is a valid date using <code>isValid</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">                                    assert(MyDate::isValid(1776, 7, 4));
  d1.setYearMonthDay(1776, 7, 4);   assert(1776 == d1.year());
                                    assert(   7 == d1.month());
                                    assert(   4 == d1.day());
</pre></div><br/>
<br/>
 Finally, using the value constructor, we create <code>d2</code> to have the same value as <code>d1</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyDate d2(1776, 7, 4);            assert(1776 == d2.year());
                                    assert(   7 == d2.month());
                                    assert(   4 == d2.day());
                                    assert(  d1 == d2);
</pre></div><br/>
<br/>
 Note that equality comparison of <code>MyDate</code> objects is very efficient, being comprised of a comparison of two <code>int</code> values. Similarly, the <code>MyDate</code> methods and free operators (not shown) that add a (signed) number of days to a date are also very efficient. However, one of the trade-offs of storing a date internally as a serial value is that operations involving conversion among the serial value and one or more of the <code>year</code>, <code>month</code>, and <code>day</code> attributes (e.g., <code>setYearMonthDay</code>, <code>getYearMonthDay</code>) entail considerably more computation. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:51 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
