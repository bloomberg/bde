<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlma_pool.h                                                       -*-C++-*-
#ifndef INCLUDED_BDLMA_POOL
#define INCLUDED_BDLMA_POOL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide efficient allocation of memory blocks of uniform size.
//
//@CLASSES:
//  bdlma::Pool: memory manager that allocates memory blocks of uniform size
//
//@DESCRIPTION: This component implements a memory pool, &#39;bdlma::Pool&#39;, that
// allocates and manages maximally-aligned memory blocks of some uniform size
// specified at construction.  A &#39;bdlma::Pool&#39; object maintains an internal
// linked list of free memory blocks, and dispenses one block for each
// &#39;allocate&#39; method invocation.  When a memory block is deallocated, it is
// returned to the free list for potential reuse.
//
// Whenever the linked list of free memory blocks is depleted, the
// &#39;bdlma::Pool&#39; replenishes the list by first allocating a large, contiguous
// &quot;chunk&quot; of memory, then splitting the chunk into multiple memory blocks.  A
// chunk and its constituent memory blocks can be depicted visually:
//..
//     +-----+--- memory blocks of uniform size
//     |     |
//   ----- ----- ------------
//  |     |     |     ...    |
//   =====^=====^============
//
//   \___________ __________/
//               V
//           a &quot;chunk&quot;
//..
// Note that the size of the allocated chunk is determined by both the growth
// strategy and maximum blocks per chunk, either of which can be optionally
// specified at construction (see the &quot;Configuration at Construction&quot; section).
//
///Configuration at Construction
///-----------------------------
// When creating a &#39;bdlma::Pool&#39;, clients must specify the specific block size
// managed and dispensed by the pool.  Furthermore, clients can optionally
// configure:
//
//: 1 GROWTH STRATEGY -- geometrically growing chunk size starting from 1 (in
//:   terms of the number of memory blocks per chunk), or fixed chunk size.  If
//:   the growth strategy is not specified, geometric growth is used.
//: 2 MAX BLOCKS PER CHUNK -- the maximum number of memory blocks within a
//:   chunk.  If the maximum blocks per chunk is not specified, an
//:   implementation-defined default value is used.
//: 3 BASIC ALLOCATOR -- the allocator used to supply memory to replenish the
//:   internal pool.  If not specified, the currently installed default
//:   allocator is used (see &#39;bslma_default&#39;).
//
// For example, if geometric growth is used and the maximum blocks per chunk is
// specified as 30, the chunk size grows geometrically, starting from 1, until
// the specified maximum blocks per chunk, as follows:
//..
//  1, 2, 4, 8, 16, 30, 30, 30 ...
//..
// If constant growth is used, the chunk size is always the specified maximum
// blocks per chunk (or an implementation-defined value if the maximum blocks
// per chunk is not specified), for example:
//..
//  30, 30, 30 ...
//..
// A default-constructed pool has an initial chunk size of 1 (i.e., the number
// of memory blocks of a given size allocated at once to replenish a pool&#39;s
// memory), and the pool&#39;s chunk size grows geometrically until it reaches an
// implementation-defined maximum, at which it is capped.  Finally, unless
// otherwise specified, all memory comes from the allocator that was the
// currently installed default allocator at the time the &#39;bdlma::Pool&#39; was
// created.
//
///Overloaded Global Operator &#39;new&#39;
///--------------------------------
// This component overloads the global &#39;operator new&#39; to allow convenient
// syntax for the construction of objects using a &#39;bdlma::Pool&#39;.  The &#39;new&#39;
// operator supplied in this component takes a &#39;bdlma::Pool&#39; argument
// indicating the source of the memory.  Consider the following use of standard
// placement &#39;new&#39; syntax (supplied by &#39;bsl_new.h&#39;) along with a &#39;bdlma::Pool&#39;
// to allocate an object of type &#39;T&#39;.  Note that the size of &#39;T&#39; must be the
// same or smaller than the &#39;blockSize&#39; with which the pool is constructed:
//..
//  void f(bdlma::Pool *pool)
//  {
//      assert(pool-&gt;blockSize() &gt;= sizeof(T));
//
//      T *t = new (pool-&gt;allocate()) T(...);
//
//      // ...
//  }
//..
// This usage style is not exception-safe.  If the constructor of &#39;T&#39; throws an
// exception, &#39;pool-&gt;deallocate&#39; is never called.
//
// Supplying an overloaded global &#39;operator new&#39;:
//..
//  ::operator new(bsl::size_t size, BloombergLP::bdlma::Pool&amp; pool);
//..
// allows for the following cleaner usage, which does not require the size
// calculation and guarantees that &#39;pool-&gt;deallocate&#39; *is* called in the case
// of an exception:
//..
//  void f(bdlma::Pool *pool)
//  {
//      assert(pool-&gt;blockSize() &gt;= sizeof(T));
//
//      T *t = new (*pool) T(...);
//
//      // ...
//..
// Also note that the analogous version of operator &#39;delete&#39; should *not* be
// called directly.  Instead, this component provides a static template member
// function &#39;deleteObject&#39;, parameterized on &#39;TYPE&#39;:
//..
//      pool-&gt;deleteObject(t);
//  }
//..
// The above &#39;deleteObject&#39; call is equivalent to performing the following:
//..
//  t-&gt;~TYPE();
//  pool-&gt;deallocate(t);
//..
// An overloaded operator &#39;delete&#39; is supplied solely to allow the compiler to
// arrange for it to be called in case of an exception.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Using a &#39;bdlma::Pool&#39; for Efficient Memory Allocation
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// A &#39;bdlma::Pool&#39; can be used by node-based containers (such as lists, trees,
// and hash tables that hold multiple elements of uniform size) for efficient
// memory allocation of new elements.  The following container template class,
// &#39;my_PooledArray&#39;, stores values of (template parameter) &#39;TYPE&#39;
// &quot;out-of-place&quot; as nodes in a &#39;vector&#39; of pointers.  Since the size of each
// node is fixed and known *a priori*, the class uses a &#39;bdlma::Pool&#39; to
// allocate memory for the nodes to improve memory allocation efficiency.  Note
// that for simplicity, we assume that &#39;TYPE&#39; does not require an allocator,
// and that calls to the destructor of &#39;TYPE&#39; can be elided.
//
// First, we define the interface of our &#39;my_PooledArray&#39; template class:
//..
//  // my_poolarray.h
//
//  template &lt;class TYPE&gt;
//  class my_PooledArray {
//      // This class implements a container that stores values of (template
//      // parameter) &#39;TYPE&#39; out-of-place.  It is assumed that &#39;TYPE&#39; does not
//      // require an allocator, and that calls to the destructor of &#39;TYPE&#39; can
//      // be elided.
//
//      // DATA
//      bsl::vector&lt;TYPE *&gt; d_array_p;  // array of pooled elements
//      bdlma::Pool         d_pool;     // memory manager for array elements
//
//    private:
//      // Not implemented:
//      my_PooledArray(const my_PooledArray&amp;);
//
//    public:
//      // CREATORS
//      explicit my_PooledArray(bslma::Allocator *basicAllocator = 0);
//          // Create a pooled array that stores the &#39;TYPE&#39; element values
//          // &quot;out-of-place&quot;.  Optionally specify a &#39;basicAllocator&#39; used to
//          // supply memory.  If &#39;basicAllocator&#39; is 0, the currently
//          // installed default allocator is used.
//
//      ~my_PooledArray();
//          // Destroy this array and all elements held by it.
//
//      // MANIPULATORS
//      void append(const TYPE&amp; value);
//          // Append the specified &#39;value&#39; to this array.
//
//      void removeAll();
//          // Remove all elements from this array.
//
//      // ACCESSORS
//      bsl::size_t length() const;
//          // Return the number of elements in this array.
//
//      const TYPE&amp; operator[](int index) const;
//          // Return a reference providing non-modifiable access to the value
//          // at the specified &#39;index&#39; in this array.  The behavior is
//          // undefined unless &#39;0 &lt;= index &lt; length()&#39;.
//  };
//..
// Next, we provide the implementation of the &#39;my_PooledArray&#39; methods that are
// defined &#39;inline&#39;.
//
// Note that in the &#39;removeAll&#39; method, all elements are deallocated by simply
// invoking the pool&#39;s &#39;release&#39; method.  This technique implies significant
// performance gain when the array contains many elements:
//..
//  // MANIPULATORS
//  template &lt;class TYPE&gt;
//  inline
//  void my_PooledArray&lt;TYPE&gt;::removeAll()
//  {
//      d_array_p.clear();
//      d_pool.release();
//  }
//
//  // ACCESSORS
//  template &lt;class TYPE&gt;
//  inline
//  bsl::size_t my_PooledArray&lt;TYPE&gt;::length() const
//  {
//      return d_array_p.size();
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  const TYPE&amp; my_PooledArray&lt;TYPE&gt;::operator[](int index) const
//  {
//      assert(0     &lt;= index);
//      assert(index &lt;  static_cast&lt;int&gt;(length()));
//
//      return *d_array_p[index];
//  }
//..
// Next, we provide the implementation of the &#39;my_PooledArray&#39; methods that are
// defined in the &#39;.cpp&#39; file.
//
// Note that the growth strategy and maximum chunk size of the pool defaults to
// those provided by &#39;bdlma::Pool&#39;:
//..
//  // my_poolarray.cpp
//
//  // CREATORS
//  template &lt;class TYPE&gt;
//  my_PooledArray&lt;TYPE&gt;::my_PooledArray(bslma::Allocator *basicAllocator)
//  : d_array_p(basicAllocator)
//  , d_pool(sizeof(TYPE), basicAllocator)
//  {
//  }
//..
// Since all memory is managed by &#39;d_pool&#39;, we do not have to explicitly invoke
// &#39;deleteObject&#39; to reclaim outstanding memory.  The destructor of the pool
// will automatically deallocate all array elements:
//..
//  template &lt;class TYPE&gt;
//  my_PooledArray&lt;TYPE&gt;::~my_PooledArray()
//  {
//      // Elements are automatically deallocated when &#39;d_pool&#39; is destroyed.
//  }
//..
// Finally, note that the overloaded &quot;placement&quot; &#39;new&#39; is used to allocate new
// nodes in the &#39;append&#39; method:
//..
//  // MANIPULATORS
//  template &lt;class TYPE&gt;
//  void my_PooledArray&lt;TYPE&gt;::append(const TYPE&amp; value)
//  {
//      TYPE *tmp = new (d_pool) TYPE(value);
//      d_array_p.push_back(tmp);
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLMA_INFREQUENTDELETEBLOCKLIST
#include &lt;bdlma_infrequentdeleteblocklist.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DELETERHELPER
#include &lt;bslma_deleterhelper.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTUTIL
#include &lt;bsls_alignmentutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_BLOCKGROWTH
#include &lt;bsls_blockgrowth.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                                // ==========
                                // class Pool
                                // ==========

class Pool {
    // This class implements a memory pool that allocates and manages memory
    // blocks of some uniform size specified at construction.  This memory pool
    // maintains an internal linked list of free memory blocks, and dispenses
    // one block for each &#39;allocate&#39; method invocation.  When a memory block is
    // deallocated, it is returned to the free list for potential reuse.

    // PRIVATE TYPES
    struct Link {
        // This &#39;struct&#39; implements a link data structure that stores the
        // address of the next link, and is used to implement the internal
        // linked list of free memory blocks.  Note that this type is
        // replicated in &#39;bdlma_pool.cpp&#39; to provide access to a compatible
        // type from static methods defined in &#39;bdlma_pool.cpp&#39;.

        Link *d_next_p;  // pointer to next link
    };

    // DATA
    int   d_blockSize;          // size (in bytes) of each allocated memory
                                // block returned to client

    int   d_internalBlockSize;  // actual size of each block maintained on free
                                // list (contains overhead for &#39;Link&#39;)

    int   d_chunkSize;          // current chunk size (in blocks-per-chunk)

    int   d_maxBlocksPerChunk;  // maximum chunk size (in blocks-per-chunk)

    bsls::BlockGrowth::Strategy
          d_growthStrategy;     // growth strategy of the chunk size

    Link *d_freeList_p;         // linked list of free memory blocks

    InfrequentDeleteBlockList
          d_blockList;          // memory manager for allocated memory

    char *d_begin_p;            // start of a contiguous group of memory blocks

    char *d_end_p;              // end of a contiguous group of memory blocks

  private:
    // PRIVATE MANIPULATORS
    void replenish();
        // Dynamically allocate a new chunk using this pool&#39;s underlying growth
        // strategy.

  private:
    // NOT IMPLEMENTED
    Pool(const Pool&amp;);
    Pool&amp; operator=(const Pool&amp;);

  public:
    // CREATORS
    explicit
    Pool(int blockSize, bslma::Allocator *basicAllocator = 0);
    Pool(int                          blockSize,
         bsls::BlockGrowth::Strategy  growthStrategy,
         bslma::Allocator            *basicAllocator = 0);
    Pool(int                          blockSize,
         bsls::BlockGrowth::Strategy  growthStrategy,
         int                          maxBlocksPerChunk,
         bslma::Allocator            *basicAllocator = 0);
        // Create a memory pool that returns blocks of contiguous memory of the
        // specified &#39;blockSize&#39; (in bytes) for each &#39;allocate&#39; method
        // invocation.  Optionally specify a &#39;growthStrategy&#39; used to control
        // the growth of internal memory chunks (from which memory blocks are
        // dispensed).  If &#39;growthStrategy&#39; is not specified, geometric growth
        // is used.  Optionally specify &#39;maxBlocksPerChunk&#39; as the maximum
        // chunk size if &#39;growthStrategy&#39; is specified.  If geometric growth is
        // used, the chunk size grows starting at &#39;blockSize&#39;, doubling in size
        // until the size is exactly &#39;blockSize * maxBlocksPerChunk&#39;.  If
        // constant growth is used, the chunk size is always
        // &#39;blockSize * maxBlocksPerChunk&#39;.  If &#39;maxBlocksPerChunk&#39; is not
        // specified, an implementation-defined value is used.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  The behavior is undefined unless &#39;1 &lt;= blockSize&#39; and
        // &#39;1 &lt;= maxBlocksPerChunk&#39;.

    ~Pool();
        // Destroy this pool, releasing all associated memory back to the
        // underlying allocator.

    // MANIPULATORS
    void *allocate();
        // Return the address of a contiguous block of maximally-aligned memory
        // having the fixed block size specified at construction.

    void deallocate(void *address);
        // Relinquish the memory block at the specified &#39;address&#39; back to this
        // pool object for reuse.  The behavior is undefined unless &#39;address&#39;
        // is non-zero, was allocated by this pool, and has not already been
        // deallocated.

    template &lt;class TYPE&gt;
    void deleteObject(const TYPE *object);
        // Destroy the specified &#39;object&#39; based on its dynamic type and then
        // use this pool to deallocate its memory footprint.  This method has
        // no effect if &#39;object&#39; is 0.  The behavior is undefined unless
        // &#39;object&#39;, when cast appropriately to &#39;void *&#39;, was allocated using
        // this pool and has not already been deallocated.  Note that
        // &#39;dynamic_cast&lt;void *&gt;(object)&#39; is applied if &#39;TYPE&#39; is polymorphic,
        // and &#39;static_cast&lt;void *&gt;(object)&#39; is applied otherwise.

    template &lt;class TYPE&gt;
    void deleteObjectRaw(const TYPE *object);
        // Destroy the specified &#39;object&#39; and then use this pool to deallocate
        // its memory footprint.  This method has no effect if &#39;object&#39; is 0.
        // The behavior is undefined unless &#39;object&#39; is !not! a secondary base
        // class pointer (i.e., the address is (numerically) the same as when
        // it was originally dispensed by this pool), was allocated using this
        // pool, and has not already been deallocated.

    void release();
        // Relinquish all memory currently allocated via this pool object.

    void reserveCapacity(int numBlocks);
        // Reserve memory from this pool to satisfy memory requests for at
        // least the specified &#39;numBlocks&#39; before the pool replenishes.  The
        // behavior is undefined unless &#39;0 &lt;= numBlocks&#39;.

    // ACCESSORS
    int blockSize() const;
        // Return the size (in bytes) of the memory blocks allocated from this
        // pool object.  Note that all blocks dispensed by this pool have the
        // same size.
};

}  // close package namespace
}  // close enterprise namespace

// Note that the &#39;new&#39; and &#39;delete&#39; operators are declared outside the
// &#39;BloombergLP&#39; namespace so that they do not hide the standard placement
// &#39;new&#39; and &#39;delete&#39; operators (i.e.,
// &#39;void *operator new(bsl::size_t, void *)&#39; and
// &#39;void operator delete(void *)&#39;).
//
// Also note that only the scalar versions of operators &#39;new&#39; and &#39;delete&#39; are
// provided, because overloading &#39;new&#39; (and &#39;delete&#39;) with their array versions
// would cause dangerous ambiguity.  Consider what would have happened had we
// overloaded the array version of &#39;operator new&#39;:
//..
//  void *operator new[](bsl::size_t size, BloombergLP::bdlma::Pool&amp; pool);
//..
// A user of &#39;bdlma::Pool&#39; may expect to be able to use array &#39;operator new&#39; as
// follows:
//..
//   new (*pool) my_Type[...];
//..
// The problem is that this expression returns an array that cannot be safely
// deallocated.  On the one hand, there is no syntax in C++ to invoke an
// overloaded &#39;operator delete&#39;; on the other hand, the pointer returned by
// &#39;operator new&#39; cannot be passed to the &#39;deallocate&#39; method directly because
// the pointer is different from the one returned by the &#39;allocate&#39; method.
// The compiler offsets the value of this pointer by a header, which is used to
// maintain the number of objects in the array (so that &#39;operator delete&#39; can
// destroy the right number of objects).

// FREE OPERATORS
void *operator new(bsl::size_t size, BloombergLP::bdlma::Pool&amp; pool);
    // Return a block of memory of the specified &#39;size&#39; (in bytes) allocated
    // from the specified &#39;pool&#39;.  The behavior is undefined unless &#39;size&#39; is
    // the same or smaller than the &#39;blockSize&#39; with which &#39;pool&#39; was
    // constructed.  Note that an object may allocate additional memory
    // internally, requiring the allocator to be passed in as a constructor
    // argument:
    //..
    //  my_Type *newMyType(bdlma::Pool *pool, bslma::Allocator *basicAllocator)
    //  {
    //      return new (*pool) my_Type(..., basicAllocator);
    //  }
    //..
    // Also note that the analogous version of &#39;operator delete&#39; should not be
    // called directly.  Instead, this component provides a static template
    // member function, &#39;deleteObject&#39;, parameterized by &#39;TYPE&#39;:
    //..
    //  void deleteMyType(my_Type *t, bdlma::Pool *pool)
    //  {
    //      pool-&gt;deleteObject(t);
    //  }
    //..
    // &#39;deleteObject&#39; performs the following:
    //..
    //  t-&gt;~my_Type();
    //  pool-&gt;deallocate(t);
    //..

void operator delete(void *address, BloombergLP::bdlma::Pool&amp; pool);
    // Use the specified &#39;pool&#39; to deallocate the memory at the specified
    // &#39;address&#39;.  The behavior is undefined unless &#39;address&#39; is non-zero, was
    // allocated using &#39;pool&#39;, and has not already been deallocated.  Note that
    // this operator is supplied solely to allow the compiler to arrange for it
    // to be called in the case of an exception.

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

namespace BloombergLP {
namespace bdlma {

                                // ----------
                                // class Pool
                                // ----------

// MANIPULATORS
inline
void *Pool::allocate()
{
    if (d_begin_p == d_end_p) {
        if (d_freeList_p) {
            Link *p      = d_freeList_p;
            d_freeList_p = p-&gt;d_next_p;
            return p;                                                 // RETURN
        }

        replenish();
    }

    char *p = d_begin_p;
    d_begin_p += d_internalBlockSize;
    return p;
}

inline
void Pool::deallocate(void *address)
{
    BSLS_ASSERT_SAFE(address);

    static_cast&lt;Link *&gt;(address)-&gt;d_next_p = d_freeList_p;
    d_freeList_p = static_cast&lt;Link *&gt;(address);
}

template &lt;class TYPE&gt;
inline
void Pool::deleteObject(const TYPE *object)
{
    bslma::DeleterHelper::deleteObject(object, this);
}

template &lt;class TYPE&gt;
inline
void Pool::deleteObjectRaw(const TYPE *object)
{
    bslma::DeleterHelper::deleteObjectRaw(object, this);
}

inline
void Pool::release()
{
    d_blockList.release();
    d_freeList_p = 0;
    d_begin_p = 0;
    d_end_p = 0;
}

// ACCESSORS
inline
int Pool::blockSize() const
{
    return d_blockSize;
}

}  // close package namespace
}  // close enterprise namespace

// FREE OPERATORS
inline
void *operator new(bsl::size_t size, BloombergLP::bdlma::Pool&amp; pool)
{
    using namespace BloombergLP;

    BSLS_ASSERT_SAFE(
        static_cast&lt;int&gt;(size) &lt;= pool.blockSize() &amp;&amp;
        bsls::AlignmentUtil::calculateAlignmentFromSize(size)
         &lt;= bsls::AlignmentUtil::calculateAlignmentFromSize(pool.blockSize()));

    static_cast&lt;void&gt;(size);  // suppress &quot;unused parameter&quot; warnings
    return pool.allocate();
}

inline
void operator delete(void *address, BloombergLP::bdlma::Pool&amp; pool)
{
    BSLS_ASSERT_SAFE(address);

    pool.deallocate(address);
}

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
