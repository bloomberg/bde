<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslx_instreamfunctions.h                                           -*-C++-*-
#ifndef INCLUDED_BSLX_INSTREAMFUNCTIONS
#define INCLUDED_BSLX_INSTREAMFUNCTIONS

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Facilitate uniform unexternalization of user and fundamental types.
//
//@CLASSES:
//  bslx::InStreamFunctions: namespace for BDEX unexternalization functions
//
//@SEE_ALSO: bslx_outstreamfunctions, bslx_versionfunctions
//
//@DESCRIPTION: This component provides a namespace, &#39;bslx::InStreamFunctions&#39;,
// that facilitates uniform support for BDEX unexternalization across all
// BDEX-compliant user-defined types, including template types and containers,
// as well as those fundamental types (and &#39;bsl::string&#39; and &#39;bsl::vector&#39;) for
// which the BDEX protocol provides direct support.
//
// The namespace &#39;bslx::InStreamFunctions&#39; facilitates client unexternalization
// of objects in a uniform, type-independent manner.  It contains the
// &#39;bdexStreamIn&#39; function that unexternalizes objects of all BDEX-compliant
// types.  This function unexternalizes the specified &#39;object&#39; in the specified
// &#39;version&#39; or the &#39;version&#39; read from the input stream as required by the
// BDEX protocol.  The &#39;bdexStreamIn&#39; function is overloaded for fundamental
// types, enumeration types, &#39;bsl::string&#39;, and &#39;bsl::vector&#39;.  Note that,
// excluding &#39;bsl::vector&#39;, version information is never read from the stream
// while unexternalizing these types.
//
// By default, objects of enumeration type are streamed in as 32-bit &#39;int&#39;
// values.  Users can override this behavior by providing overloads of the
// &#39;InStreamFunctions::bdexStreamIn&#39; function in the enumeration&#39;s namespace
// for their enumeration types.  The general form of this overload is:
//..
//  template &lt;class STREAM&gt;
//  STREAM&amp; bdexStreamIn(STREAM&amp; stream, MyEnum&amp; variable, int version)
//  {
//      using bslx::InStreamFunctions::bdexStreamIn;
//
//      // Code to stream in objects of &#39;MyEnum&#39; type.
//
//      return stream;
//  }
//..
// For value-semantic types that support the BDEX protocol, the free function
// &#39;bdexStreamIn&#39; calls the &#39;bdexStreamIn&#39; member function for that type.
//
///Component Design, Anticipated Usage, and the BDEX Contract
///----------------------------------------------------------
// &#39;bslx_instreamfunctions&#39; is an integral part of the BDEX unexternalization
// contract.  The BDEX contract is at least in part &quot;collaborative&quot;, which is
// to say that each developer of a given *kind* of component (e.g., a stream or
// a value-semantic container) must comply with the relevant portions of the
// contract to ensure that the &quot;system as a whole&quot; works for everybody.
// &#39;bslx_instreamfunctions&#39; plays several related but different roles in
// helping various developers to produce BDEX-compliant components.  In this
// section we briefly highlight how and why &#39;bslx_instreamfunctions&#39; is helpful
// (or required) for these different developers.  By discussing different
// aspects of usage, we convey the general design goals of this component, and,
// to a certain extent, the overall BDEX contract.  See the &#39;bslx&#39;
// package-level documentation for a full specification of the BDEX contract.
//
///Implementing BDEX Streaming in Value-Semantic Template Classes
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// The author of a non-template value-semantic type has full knowledge of the
// details of the &quot;value&quot; of that type, and may choose to use the appropriate
// input stream &#39;get&#39; methods directly when implementing the required
// &#39;bdexStreamIn&#39; method for that type.  However, if one or more aspects of the
// value are of template parameter type, then the author cannot in general know
// how to stream the value using the &#39;get&#39; methods.  For example, if a type has
// as its value one &#39;int&#39; data member:
//..
//  int d_value;
//..
// then the implementation of the &#39;bdexStreamIn&#39; method can contain:
//..
//  stream.getInt32(d_value);
//..
// However, if the data member is of (template parameter) &#39;TYPE&#39;:
//..
//  TYPE d_value;
//..
// then the implementation of the &#39;bdexStreamIn&#39; method must rely on the
// &#39;bslx::InStreamFunctions&#39; implementation to input the value:
//..
//  using bslx::InStreamFunctions::bdexStreamIn;
//  bdexStreamIn(stream, d_value, 1);
//..
// This call will resolve to the correct sequence of &#39;get&#39; calls no matter
// whether &#39;TYPE&#39; is a fundamental type, a BDEX-compliant &#39;enum&#39;, or a proper
// BDEX-compliant class.  In the latter two cases, the explicit specification
// of the version format (in this case, 1) guarantees the stable operation of
// this method whether or not &#39;TYPE&#39; is provided additional version formats.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Using &#39;bslx::InStreamFunctions&#39; to Unexternalize Data
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In this example we illustrate the primary intended use of the parameterized
// methods of this component, as well as a few trivial invocations just to show
// the syntax clearly.  To accomplish this, we exhibit three separate example
// &quot;components&quot;: an &#39;enum&#39;, a value-semantic point object, and an input stream.
// In all cases, the component designs are very simple, with much of the
// implied functionality omitted, in order to focus attention on the key
// aspects of the functionality of *this* component.
//
// First, consider an &#39;enum&#39; &#39;Color&#39; that enumerates a set of colors:
//..
//  enum Color {
//      RED   = 0,
//      GREEN = 1,
//      BLUE  = 2
//  };
//..
// Next, we consider a very special-purpose point that has as a data member its
// color.  Such a point provides an excellent opportunity for factoring, but
// since we are interested in highlighting BDEX streaming of various types, we
// will present a simple and unfactored design here.  In a real-world problem,
// the &#39;mypoint&#39; component would be implemented differently.
//
// Note that the &#39;MyPoint&#39; class in this example represents its coordinates as
// &#39;short&#39; integer values; this is done to make the BDEX stream input byte
// pattern somewhat easier for the reader of this example to recognize when the
// input buffer is printed.
//..
//  // mypoint.h
//
//  class MyPoint {
//      // This class provides a geometric point having integer coordinates and
//      // an enumerated color property.
//
//      short d_x;      // x coordinate
//      short d_y;      // y coordinate
//      Color d_color;  // enumerated color property
//
//    public:
//      // CLASS METHODS
//      // ...
//
//      // CREATORS
//      MyPoint();
//          // Create a default point.
//
//      MyPoint(short x, short y, Color color);
//          // Create a point having the specified &#39;x&#39; and &#39;y&#39; coordinates
//          // and the specified &#39;color&#39;.
//
//      ~MyPoint();
//          // Destroy this point.
//
//      // MANIPULATORS
//      // ...
//
//      // ACCESSORS
//      short x() const;
//          // Return the x coordinate of this point.
//
//      short y() const;
//          // Return the y coordinate of this point.
//
//      Color color() const;
//          // Return the enumerated color of this point.
//
//      template &lt;class STREAM&gt;
//      STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
//          // Assign to this object the value read from the specified input
//          // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
//          // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
//          // operation has no effect.  If &#39;version&#39; is not supported, this
//          // object is unaltered and &#39;stream&#39; is invalidated, but otherwise
//          // unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes
//          // invalid during this operation, this object has an undefined, but
//          // valid, state.  Note that no version is read from &#39;stream&#39;.  See
//          // the &#39;bslx&#39; package-level documentation for more information on
//          // BDEX streaming of value-semantic types and containers.
//  };
//
//  // FREE OPERATORS
//  inline
//  bool operator==(const MyPoint&amp; lhs, const MyPoint&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; points have the same
//      // value, and &#39;false&#39; otherwise.  Two points have the same value if
//      // they have the same x and y coordinates and the same color.
//..
// Representative (inline) implementations of these methods are shown below:
//..
//  // ========================================================================
//  //                      INLINE FUNCTION DEFINITIONS
//  // ========================================================================
//
//  // CREATORS
//  inline
//  MyPoint::MyPoint()
//  {
//  }
//
//  inline
//  MyPoint::MyPoint(short x, short y, Color color)
//  : d_x(x)
//  , d_y(y)
//  , d_color(color)
//  {
//  }
//
//  inline
//  MyPoint::~MyPoint()
//  {
//  }
//
//  // ...
//
//  // MANIPULATORS
//  // ...
//
//  // ACCESSORS
//  inline
//  Color MyPoint::color() const
//  {
//      return d_color;
//  }
//
//  inline
//  short MyPoint::x() const
//  {
//      return d_x;
//  }
//
//  inline
//  short MyPoint::y() const
//  {
//      return d_y;
//  }
//  // ...
//
//  template &lt;class STREAM&gt;
//  STREAM&amp; MyPoint::bdexStreamIn(STREAM&amp; stream, int version)
//  {
//      switch (version) {
//        case 1: {
//          stream.getInt16(d_x);           // input the x coordinate
//          stream.getInt16(d_y);           // input the y coordinate
//          char color;
//          stream.getInt8(color);          // input the color enum as one byte
//          d_color = static_cast&lt;Color&gt;(color);
//        } break;
//        default: {
//          stream.invalidate();
//        } break;
//      }
//      return stream;
//  }
//
//  // FREE OPERATORS
//  inline
//  bool operator==(const MyPoint&amp; lhs, const MyPoint&amp; rhs)
//  {
//      return lhs.x()     == rhs.x()
//          &amp;&amp; lhs.y()     == rhs.y()
//          &amp;&amp; lhs.color() == rhs.color();
//  }
//..
// Then, we will implement an extremely simple input stream that supports the
// BDEX documentation-only protocol.  For simplicity, we will use an externally
// managed buffer, and will only show a few methods needed for this example.
//..
//  // myinstream.h
//  // ...
//
// class MyInStream {
//     // This class implements a limited-size fixed-buffer input stream that
//     // partially conforms to the BDEX protocol for input streams.  This
//     // class is suitable for demonstration purposes only.
//
//     const char *d_buffer;  // input buffer, held but not owned
//     int         d_length;  // length of &#39;d_buffer&#39; (bytes)
//     int         d_cursor;  // cursor (index into &#39;d_buffer&#39;)
//
//   public:
//     // CREATORS
//     MyInStream(const char *buffer, int length);
//         // Create an input stream using the specified &#39;buffer&#39; having the
//         // specified &#39;length&#39; (in bytes).
//
//     ~MyInStream();
//         // Destroy this input byte stream.
//
//     // MANIPULATORS
//     MyInStream&amp; getVersion(int&amp; version);
//         // Consume a version value from this input stream, store that value
//         // in the specified &#39;version&#39;, and return a reference to this
//         // stream.  ...
//
//     MyInStream&amp; getInt32(int&amp; value);
//         // Consume a 32-bit signed integer value from this input stream,
//         // store that value in the specified &#39;value&#39;, and return a reference
//         // to this stream.  ...
//
//     MyInStream&amp; getInt16(short&amp; value);
//         // Consume a 16-bit signed integer value from this input stream,
//         // store that value in the specified &#39;value&#39;, and return a reference
//         // to this stream.  ...
//
//     MyInStream&amp; getInt8(char&amp; value);
//         // Consume an 8-bit signed integer value from this input stream,
//         // store that value in the specified &#39;value&#39;, and return a reference
//         // to this stream.  ...
//
//     void invalidate();
//         // Put this input stream in an invalid state.  ...
//
//     // ACCESSORS
//     operator const void *() const;
//         // Return a non-zero value if this stream is valid, and 0
//         // otherwise.  An invalid stream is a stream in which insufficient
//         // or invalid data was detected during an extraction operation.
//         // Note that an empty stream will be valid unless an extraction
//         // attempt or explicit invalidation causes it to be otherwise.
//
//     int cursor() const;
//         // Return the index of the next byte to be extracted from this
//         // stream.
//
//     bool isEmpty() const;
//          // Return &#39;true&#39; if this stream is empty, and &#39;false&#39; otherwise.
//          // Note that this function enables higher-level types to verify
//          // that, after successfully reading all expected data, no data
//          // remains.
//
//     int length() const;
//         // Return the total number of bytes stored in this stream.
// };
//
//..
// The relevant (inline) implementations are as follows.
//..
//  // ========================================================================
//  //                      INLINE FUNCTION DEFINITIONS
//  // ========================================================================
//
//  // CREATORS
//  inline
//  MyInStream::MyInStream(const char *buffer, int length)
//  : d_buffer(buffer)
//  , d_length(length)
//  , d_cursor(0)
//  {
//  }
//
//  inline
//  MyInStream::~MyInStream()
//  {
//  }
//
//  // MANIPULATORS
//
//  inline
//  MyInStream&amp; MyInStream::getVersion(int&amp; value)
//  {
//      value = static_cast&lt;unsigned char&gt;(d_buffer[d_cursor++]);
//      return *this;
//  }
//
//  inline
//  MyInStream&amp; MyInStream::getInt32(int&amp; value)
//  {
//      const unsigned char *buffer =
//                           reinterpret_cast&lt;const unsigned char *&gt;(d_buffer);
//      value = static_cast&lt;int&gt;((buffer[d_cursor    ] &lt;&lt; 24U) |
//                               (buffer[d_cursor + 1] &lt;&lt; 16U) |
//                               (buffer[d_cursor + 2] &lt;&lt;  8U) |
//                               (buffer[d_cursor + 3]       ));
//      d_cursor += 4;
//      return *this;
//  }
//
//  inline
//  MyInStream&amp; MyInStream::getInt16(short&amp; value)
//  {
//      const unsigned char *buffer =
//                           reinterpret_cast&lt;const unsigned char *&gt;(d_buffer);
//      value = static_cast&lt;short&gt;((buffer[d_cursor    ] &lt;&lt;  8) |
//                                 (buffer[d_cursor + 1]      ));
//      d_cursor += 2;
//      return *this;
//   }
//
//  inline
//  MyInStream&amp; MyInStream::getInt8(char&amp; value)
//  {
//      value = d_buffer[d_cursor];
//      d_cursor += 1;
//      return *this;
//  }
//
//  inline
//  void MyInStream::invalidate()
//  {
//      d_buffer = 0;
//  }
//
//  // ACCESSORS
//  inline
//  MyInStream::operator const void *() const
//  {
//      return d_cursor &lt;= d_length ? d_buffer : 0;
//  }
//
//  inline
//  int MyInStream::cursor() const
//  {
//      return d_cursor;
//  }
//
//  inline
//  bool MyInStream::isEmpty() const
//  {
//      return d_cursor &gt;= d_length;
//  }
//
//  inline
//  int MyInStream::length() const
//  {
//      return d_length;
//  }
//..
// Finally, use the above &#39;enum&#39;, point class, and input stream to illustrate
// &#39;bslx::InStreamFunctions&#39; functionality.  This test code does not attempt to
// do anything more useful than reading values from a stream whose buffer was
// written &quot;by hand&quot; and confirming that the expected values were read
// correctly from the known byte pattern in the buffer.
//..
//  using bslx::InStreamFunctions::bdexStreamIn;
//
//  {
//      const int  EXP       = 0x0A0B0C0D;
//      const char buffer[4] = { 0xA, 0xB, 0xC, 0xD };  // &#39;int&#39; (no version)
//      int        i         = 0;
//
//      MyInStream in1(buffer, 4);  // use the one buffer
//      bdexStreamIn(in1, i, 1);
//      assert(in1);  assert(EXP == i);
//
//      i = 0;                      // reset &#39;i&#39;
//      MyInStream in2(buffer, 4);  // re-use &#39;buffer (no version)
//      bdexStreamIn(in2, i, 0);
//      assert(in2);  assert(EXP == i);
//  }
//
//  {
//      const MyPoint EXP(0, -1, BLUE);
//      const char buffer1[5] = { 0, 0, -1, -1, 2 };     // &#39;MyPoint&#39; (no ver)
//      const char buffer2[6] = { 1, 0, 0, -1, -1, 2 };  // version, &#39;MyPoint&#39;
//      MyPoint p1, p2;  // two default points
//
//      MyInStream in1(buffer1, 5);  // &#39;buffer1&#39; has no version byte
//      bdexStreamIn(in1, p1, 1);
//      assert(in1);  assert(EXP == p1);
//
//      MyInStream in2(buffer2, 6);  // &#39;buffer2&#39; *has* a version
//      int version;
//      in2.getVersion(version);
//      assert(1 == version);
//      bdexStreamIn(in2, p2, version);
//      assert(in2);  assert(EXP == p2);
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLX_VERSIONFUNCTIONS
#include &lt;bslx_versionfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLMF_IF
#include &lt;bslmf_if.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISENUM
#include &lt;bslmf_isenum.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace bslx {

                         // ===========================
                         // namespace InStreamFunctions
                         // ===========================

namespace InStreamFunctions {
    // This namespace facilitates unexternalization of all BDEX-compliant types
    // in a type-independent manner.  The unexternalization functions are
    // overloaded for fundamental types, enumeration types, &#39;bsl::string&#39;, and
    // &#39;bsl::vector&#39;.  A compilation error will occur if the (template
    // parameter) &#39;TYPE&#39; of a non-overloaded method of
    // &#39;bslx::InStreamFunctions&#39; does not support &#39;bdexStreamIn&#39; (with the
    // appropriate signature).

                         // =================
                         // struct IsEnumType
                         // =================

    struct IsEnumType {
        // This &#39;struct&#39;, together with &#39;IsNotEnumType&#39; (below), is used to
        // distinguish enumeration types from other types in function overload
        // resolution.  This &#39;struct&#39; contains no interface or implementation
        // by design, and is meant for internal use only.
    };

                         // ====================
                         // struct IsNotEnumType
                         // ====================

    struct IsNotEnumType {
        // This &#39;struct&#39;, together with &#39;IsEnumType&#39; (above), is used to
        // distinguish enumeration types from other types in function overload
        // resolution.  This &#39;struct&#39; contains no interface or implementation
        // by design, and is meant for internal use only.
    };

    // PRIVATE CLASS METHODS
    template &lt;class STREAM, class TYPE&gt;
    STREAM&amp; bdexStreamInImp(STREAM&amp;           stream,
                            TYPE&amp;             variable,
                            int               version,
                            const IsEnumType&amp;);
        // Assign to the specified &#39;variable&#39; the &#39;TYPE&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  If &#39;version&#39; is not supported by
        // &#39;TYPE&#39;, &#39;variable&#39; is unaltered and &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  If &#39;version&#39; is supported but &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  Note that this function is called only for
        // enumeration types and that this function is for internal use only.
        // See the &#39;bslx&#39; package-level documentation for more information on
        // BDEX streaming of value-semantic types and containers.

    template &lt;class STREAM, class TYPE&gt;
    STREAM&amp; bdexStreamInImp(STREAM&amp;              stream,
                            TYPE&amp;                variable,
                            int                  version,
                            const IsNotEnumType&amp;);
        // Assign to the specified &#39;variable&#39; the &#39;TYPE&#39; value read from the
        // specified input &#39;stream&#39; using the specified &#39;version&#39; format, and
        // return a reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  If &#39;version&#39; is not supported by
        // &#39;TYPE&#39;, &#39;variable&#39; is unaltered and &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  If &#39;version&#39; is supported but &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  Note that this function is for internal use only.
        // See the &#39;bslx&#39; package-level documentation for more information on
        // BDEX streaming of value-semantic types and containers.

    // CLASS METHODS
    template &lt;class STREAM, class TYPE&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, TYPE&amp; variable);
        // Assign to the specified &#39;variable&#39; the &#39;TYPE&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // needed, first read the version information from the &#39;stream&#39; and if
        // this version is not supported by &#39;TYPE&#39;, &#39;stream&#39; is invalidated,
        // but otherwise unmodified.  If &#39;stream&#39; becomes invalid during this
        // operation, &#39;variable&#39; has an undefined, but valid, state.  Note that
        // the version is only needed when the (template parameter) &#39;TYPE&#39; is a
        // &#39;bsl::vector&#39; or a user-defined type.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class TYPE&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, TYPE&amp; variable, int version);
        // Assign to the specified &#39;variable&#39; the &#39;TYPE&#39; value read from the
        // specified input &#39;stream&#39; using the specified &#39;version&#39; format, and
        // return a reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  If &#39;version&#39; is not supported by
        // &#39;TYPE&#39;, &#39;variable&#39; is unaltered and &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  If &#39;version&#39; is supported but &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

                       /* overloads */

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, bool&amp; variable, int version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;bool&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  If &#39;stream&#39; becomes invalid
        // during this operation, &#39;variable&#39; has an undefined, but valid,
        // state.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, char&amp; variable, int version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;char&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  If &#39;stream&#39; becomes invalid
        // during this operation, &#39;variable&#39; has an undefined, but valid,
        // state.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;      stream,
                         signed char&amp; variable,
                         int          version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;signed char&#39; value read from
        // the specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.
        // The optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  If &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;        stream,
                         unsigned char&amp; variable,
                         int            version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;unsigned char&#39; value read
        // from the specified input &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  The optionally specified &#39;version&#39; is ignored.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;stream&#39; becomes invalid during this operation, &#39;variable&#39; has an
        // undefined, but valid, state.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, short&amp; variable, int version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;short&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  If &#39;stream&#39; becomes invalid
        // during this operation, &#39;variable&#39; has an undefined, but valid,
        // state.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;         stream,
                         unsigned short&amp; variable,
                         int             version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;unsigned short&#39; value read
        // from the specified input &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  The optionally specified &#39;version&#39; is ignored.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;stream&#39; becomes invalid during this operation, &#39;variable&#39; has an
        // undefined, but valid, state.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int&amp; variable, int version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;int&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  If &#39;stream&#39; becomes invalid
        // during this operation, &#39;variable&#39; has an undefined, but valid,
        // state.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;       stream,
                         unsigned int&amp; variable,
                         int           version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;unsigned int&#39; value read
        // from the specified input &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  The optionally specified &#39;version&#39; is ignored.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;stream&#39; becomes invalid during this operation, &#39;variable&#39; has an
        // undefined, but valid, state.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, long&amp; variable, int version = 0);
        // Assign to the specified &#39;variable&#39; the 32-bit &#39;int&#39; value read from
        // the specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.
        // The optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  If &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;        stream,
                         unsigned long&amp; variable,
                         int            version = 0);
        // Assign to the specified &#39;variable&#39; the 32-bit &#39;unsigned int&#39; value
        // read from the specified input &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  The optionally specified &#39;version&#39; is ignored.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;stream&#39; becomes invalid during this operation, &#39;variable&#39; has an
        // undefined, but valid, state.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;             stream,
                         bsls::Types::Int64&amp; variable,
                         int                 version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;bsls::Types::Int64&#39; value
        // read from the specified input &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  The optionally specified &#39;version&#39; is ignored.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;stream&#39; becomes invalid during this operation, &#39;variable&#39; has an
        // undefined, but valid, state.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;              stream,
                         bsls::Types::Uint64&amp; variable,
                         int                  version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;bsls::Types::Uint64&#39; value
        // read from the specified input &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  The optionally specified &#39;version&#39; is ignored.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;stream&#39; becomes invalid during this operation, &#39;variable&#39; has an
        // undefined, but valid, state.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, float&amp; variable, int version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;float&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  If &#39;stream&#39; becomes invalid
        // during this operation, &#39;variable&#39; has an undefined, but valid,
        // state.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, double&amp; variable, int version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;double&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  If &#39;stream&#39; becomes invalid
        // during this operation, &#39;variable&#39; has an undefined, but valid,
        // state.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;      stream,
                         bsl::string&amp; variable,
                         int          version = 0);
        // Assign to the specified &#39;variable&#39; the &#39;bsl::string&#39; value read from
        // the specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.
        // The optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  If &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                   stream,
                         bsl::vector&lt;char, ALLOC&gt;&amp; variable,
                         int                       version);
        // Assign to the specified &#39;variable&#39; the &#39;bsl::vector&lt;char, ALLOC&gt;&#39;
        // value read from the specified input &#39;stream&#39;, and return a reference
        // to &#39;stream&#39;.  The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  If &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                          stream,
                         bsl::vector&lt;signed char, ALLOC&gt;&amp; variable,
                         int                              version);
        // Assign to the specified &#39;variable&#39; the
        // &#39;bsl::vector&lt;signed char, ALLOC&gt;&#39; value read from the specified
        // input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The specified
        // &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;stream&#39; becomes invalid during this
        // operation, &#39;variable&#39; has an undefined, but valid, state.  See the
        // &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                            stream,
                         bsl::vector&lt;unsigned char, ALLOC&gt;&amp; variable,
                         int                                version);
        // Assign to the specified &#39;variable&#39; the
        // &#39;bsl::vector&lt;unsigned char, ALLOC&gt;&#39; value read from the specified
        // input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The specified
        // &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;stream&#39; becomes invalid during this
        // operation, &#39;variable&#39; has an undefined, but valid, state.  See the
        // &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                    stream,
                         bsl::vector&lt;short, ALLOC&gt;&amp; variable,
                         int                        version);
        // Assign to the specified &#39;variable&#39; the &#39;bsl::vector&lt;short, ALLOC&gt;&#39;
        // value read from the specified input &#39;stream&#39;, and return a reference
        // to &#39;stream&#39;.  The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  If &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                             stream,
                         bsl::vector&lt;unsigned short, ALLOC&gt;&amp; variable,
                         int                                 version);
        // Assign to the specified &#39;variable&#39; the
        // &#39;bsl::vector&lt;unsigned short, ALLOC&gt;&#39; value read from the specified
        // input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The specified
        // &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;stream&#39; becomes invalid during this
        // operation, &#39;variable&#39; has an undefined, but valid, state.  See the
        // &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                  stream,
                         bsl::vector&lt;int, ALLOC&gt;&amp; variable,
                         int                      version);
        // Assign to the specified &#39;variable&#39; the &#39;bsl::vector&lt;int, ALLOC&gt;&#39;
        // value read from the specified input &#39;stream&#39;, and return a reference
        // to &#39;stream&#39;.  The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  If &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                           stream,
                         bsl::vector&lt;unsigned int, ALLOC&gt;&amp; variable,
                         int                               version);
        // Assign to the specified &#39;variable&#39; the
        // &#39;bsl::vector&lt;unsigned int, ALLOC&gt;&#39; value read from the specified
        // input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The specified
        // &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;stream&#39; becomes invalid during this
        // operation, &#39;variable&#39; has an undefined, but valid, state.  See the
        // &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                                 stream,
                         bsl::vector&lt;bsls::Types::Int64, ALLOC&gt;&amp; variable,
                         int                                     version);
        // Assign to the specified &#39;variable&#39; the
        // &#39;bsl::vector&lt;bsls::Types::Int64, ALLOC&gt;&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  If &#39;stream&#39; becomes invalid during
        // this operation, &#39;variable&#39; has an undefined, but valid, state.  See
        // the &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                                  stream,
                         bsl::vector&lt;bsls::Types::Uint64, ALLOC&gt;&amp; variable,
                         int                                      version);
        // Assign to the specified &#39;variable&#39; the
        // &#39;bsl::vector&lt;bsls::Types::Uint64, ALLOC&gt;&#39; value read from the
        // specified input &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  If &#39;stream&#39; becomes invalid during
        // this operation, &#39;variable&#39; has an undefined, but valid, state.  See
        // the &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                    stream,
                         bsl::vector&lt;float, ALLOC&gt;&amp; variable,
                         int                        version);
        // Assign to the specified &#39;variable&#39; the &#39;bsl::vector&lt;float, ALLOC&gt;&#39;
        // value read from the specified input &#39;stream&#39;, and return a reference
        // to &#39;stream&#39;.  The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  If &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                     stream,
                         bsl::vector&lt;double, ALLOC&gt;&amp; variable,
                         int                         version);
        // Assign to the specified &#39;variable&#39; the &#39;bsl::vector&lt;double, ALLOC&gt;&#39;
        // value read from the specified input &#39;stream&#39;, and return a reference
        // to &#39;stream&#39;.  The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  If &#39;stream&#39;
        // becomes invalid during this operation, &#39;variable&#39; has an undefined,
        // but valid, state.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM, class TYPE, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                   stream,
                         bsl::vector&lt;TYPE, ALLOC&gt;&amp; variable);
        // Assign to the specified &#39;variable&#39; the &#39;bsl::vector&lt;TYPE, ALLOC&gt;&#39;
        // value read from the specified input &#39;stream&#39;, and return a reference
        // to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has
        // no effect.  First read the version information from the &#39;stream&#39; and
        // if this version is not supported by &#39;TYPE&#39; and the vector is not
        // empty, &#39;stream&#39; is invalidated, but otherwise unmodified.  If
        // &#39;stream&#39; becomes invalid during this operation, &#39;variable&#39; has an
        // undefined, but valid, state.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class TYPE, class ALLOC&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp;                   stream,
                         bsl::vector&lt;TYPE, ALLOC&gt;&amp; variable,
                         int                       version);
        // Assign to the specified &#39;variable&#39; the &#39;bsl::vector&lt;TYPE, ALLOC&gt;&#39;
        // value read from the specified input &#39;stream&#39; using the specified
        // &#39;version&#39; format, and return a reference to &#39;stream&#39;.  If &#39;stream&#39;
        // is initially invalid, this operation has no effect.  If &#39;version&#39; is
        // not supported by &#39;TYPE&#39; and the vector is not empty, &#39;stream&#39; is
        // invalidated, but otherwise unmodified.  If &#39;stream&#39; becomes invalid
        // during this operation, &#39;variable&#39; has an undefined, but valid,
        // state.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

}  // close InStreamFunctions namespace

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

                         // ---------------------------
                         // namespace InStreamFunctions
                         // ---------------------------

template &lt;class STREAM, class TYPE&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamInImp(STREAM&amp;           stream,
                                           TYPE&amp;             variable,
                                           int            /* version */,
                                           const IsEnumType&amp;)
{
    int enumVariable = 0;
    stream.getInt32(enumVariable);

    if (stream) {
        variable = static_cast&lt;TYPE&gt;(enumVariable);
    }
    return stream;
}

template &lt;class STREAM, class TYPE&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamInImp(STREAM&amp;              stream,
                                           TYPE&amp;                variable,
                                           int                  version,
                                           const IsNotEnumType&amp;)
{
    // A compilation error indicating the next line of code implies the class
    // of &#39;TYPE&#39; does not support the &#39;bdexStreamIn&#39; method.

    return variable.bdexStreamIn(stream, version);
}

template &lt;class STREAM, class TYPE&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream, TYPE&amp; variable)
{
    using VersionFunctions::maxSupportedBdexVersion;

    // Determine if the &#39;TYPE&#39; requires a version to be externalized using an
    // arbitrary value for &#39;versionSelector&#39;.

    int version = maxSupportedBdexVersion(&amp;variable, 0);
    if (VersionFunctions::k_NO_VERSION != version) {
        stream.getVersion(version);

        if (!stream) {
            return stream;
        }
    }

    return bdexStreamIn(stream, variable, version);
}

template &lt;class STREAM, class TYPE&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream,
                                        TYPE&amp;   variable,
                                        int     version)
{
    typedef typename bslmf::If&lt;bslmf::IsEnum&lt;TYPE&gt;::value,
                               IsEnumType,
                               IsNotEnumType&gt;::Type dummyType;
    return bdexStreamInImp(stream, variable, version, dummyType());
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream,
                                        bool&amp;   variable,
                                        int  /* version */)
{
    char temp = 0;

    stream.getInt8(temp);
    variable = static_cast&lt;bool&gt;(temp);

    return stream;
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream,
                                        char&amp;   variable,
                                        int  /* version */)
{
    return stream.getInt8(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;      stream,
                                        signed char&amp; variable,
                                        int       /* version */)
{
    return stream.getInt8(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;        stream,
                                        unsigned char&amp; variable,
                                        int         /* version */)
{
    return stream.getUint8(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream,
                                        short&amp;  variable,
                                        int  /* version */)
{
    return stream.getInt16(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;         stream,
                                        unsigned short&amp; variable,
                                        int          /* version */)
{
    return stream.getUint16(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream,
                                        int&amp;    variable,
                                        int  /* version */)
{
    return stream.getInt32(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;       stream,
                                        unsigned int&amp; variable,
                                        int        /* version */)
{
    return stream.getUint32(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream,
                                        long&amp;   variable,
                                        int  /* version */)
{
    int temp = 0;  // &#39;long&#39; and &#39;int&#39; may not be the same size.
    stream.getInt32(temp);
    variable = temp;
    return stream;
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;        stream,
                                        unsigned long&amp; variable,
                                        int         /* version */)
{
    unsigned int temp = 0;  // &#39;unsigned long&#39; and &#39;unsigned int&#39; may not be
                            // the same size.
    stream.getUint32(temp);
    variable = temp;
    return stream;
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;             stream,
                                        bsls::Types::Int64&amp; variable,
                                        int              /* version */)
{
    return stream.getInt64(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;              stream,
                                        bsls::Types::Uint64&amp; variable,
                                        int               /* version */)
{
    return stream.getUint64(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream,
                                        float&amp;  variable,
                                        int  /* version */)
{
    return stream.getFloat32(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp; stream,
                                        double&amp; variable,
                                        int  /* version */)
{
    return stream.getFloat64(variable);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;      stream,
                                        bsl::string&amp; variable,
                                        int       /* version */)
{
    return stream.getString(variable);
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;                   stream,
                                        bsl::vector&lt;char, ALLOC&gt;&amp; variable,
                                        int                    /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayInt8(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(
                                   STREAM&amp;                          stream,
                                   bsl::vector&lt;signed char, ALLOC&gt;&amp; variable,
                                   int                           /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayInt8(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(
                                 STREAM&amp;                            stream,
                                 bsl::vector&lt;unsigned char, ALLOC&gt;&amp; variable,
                                 int                             /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayUint8(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;                    stream,
                                        bsl::vector&lt;short, ALLOC&gt;&amp; variable,
                                        int                     /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayInt16(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(
                                STREAM&amp;                             stream,
                                bsl::vector&lt;unsigned short, ALLOC&gt;&amp; variable,
                                int                              /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayUint16(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;                  stream,
                                        bsl::vector&lt;int, ALLOC&gt;&amp; variable,
                                        int                   /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayInt32(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(
                                  STREAM&amp;                           stream,
                                  bsl::vector&lt;unsigned int, ALLOC&gt;&amp; variable,
                                  int                            /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayUint32(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(
                            STREAM&amp;                                 stream,
                            bsl::vector&lt;bsls::Types::Int64, ALLOC&gt;&amp; variable,
                            int                                  /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayInt64(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(
                           STREAM&amp;                                  stream,
                           bsl::vector&lt;bsls::Types::Uint64, ALLOC&gt;&amp; variable,
                           int                                   /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayUint64(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;                    stream,
                                        bsl::vector&lt;float, ALLOC&gt;&amp; variable,
                                        int                     /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayFloat32(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;                     stream,
                                        bsl::vector&lt;double, ALLOC&gt;&amp; variable,
                                        int                      /* version */)
{
    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    return 0 &lt; length ? stream.getArrayFloat64(&amp;variable[0], length) : stream;
}

template &lt;class STREAM, class TYPE, class ALLOC&gt;
inline
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;                   stream,
                                        bsl::vector&lt;TYPE, ALLOC&gt;&amp; variable)
{
    int version = 0;
    stream.getVersion(version);

    if (!stream) {
        return stream;
    }

    return bdexStreamIn(stream, variable, version);
}

template &lt;class STREAM, class TYPE, class ALLOC&gt;
STREAM&amp; InStreamFunctions::bdexStreamIn(STREAM&amp;                   stream,
                                        bsl::vector&lt;TYPE, ALLOC&gt;&amp; variable,
                                        int                       version)
{
    typedef typename bsl::vector&lt;TYPE, ALLOC&gt;::iterator Iterator;

    int length = 0;
    stream.getLength(length);

    if (!stream) {
        return stream;
    }

    variable.resize(length);

    for (Iterator it = variable.begin(); it != variable.end(); ++it) {

        bdexStreamIn(stream, *it, version);

        if (!stream) {
            return stream;
        }
    }

    return stream;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
