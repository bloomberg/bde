<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bsls_cpp11 Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Component bsls_cpp11<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide macros for C++11 forward compatibility.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
</table>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Macro Summary</a> </li>
<li>
<a href="#4.2">USAGE</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide macros for C++11 forward compatibility. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BSLS_CPP11_EXPLICIT </td><td>C++11 <code>explicit</code> for conversion operators  </td></tr>
<tr>
<td>BSLS_CPP11_FINAL </td><td>C++11 <code>final</code> keyword  </td></tr>
<tr>
<td>BSLS_CPP11_OVERRIDE </td><td>C++11 <code>override</code> keyword  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides definitions to use C++11 features in both C++03 and C++11 without using conditional compilation where the features are used. The goal is to allow implementation of components such that they can take advantage of some C++11 features when compiled with C++11 mode enabled while also correctly compiling in C++03 mode. The functionality of the respective features won't be avaiable in C++03 mode. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macro_summary"></a> <a class="anchor" id="description.macro_summary"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Macro Summary: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following are the macros provided by this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>BSLS_CPP11_EXPLICIT</code> This macro inserts the keyword <code>explicit</code> when compiling with C++11 mode and inserts nothing when compiling with C++03 mode. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>BSLS_CPP11_FINAL</code> This macro inserts the keyword <code>final</code> when compiling with C++11 mode and inserts nothing when compiling with C++03 mode. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>BSLS_CPP11_OVERRIDE</code> This macro inserts the keyword <code>override</code> when compiling with C++11 mode and inserts nothing when compiling with C++03 mode. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>USAGE: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>To use these macros, simply insert them where the corresponding C++11 keyword would go. When compiling with C++03 mode there will be no effect but when compiling with C++11 mode additional restrictions will apply. When compiling with C++11 mode the restriction will be checked providing some additional checking over what is done with C++11. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>C++ uses the <code>explicit</code> keyword to indicate that constructors taking just one argument are not considered for implicit conversions. Instead, they can only be used for explicit conversions. C++ also provides the ability to define conversion operators but prior to C++11 these conversion operators are considered for implicit conversion. C++11 allows the use of the <code>explicit</code> keyword with conversion operators to avoid its use for implicit conversions. The macro <code>BSLS_CPP11_EXPLICIT</code> can be used to mark conversions as explicit conversions which will be checked when compiling with C++11 mode. For example, an <code>Optional</code> type may have an explicit conversion to <code>bool</code> to indicate that the value is set (note the conversion operator): <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
 <span class="keyword">class </span>Optional
 {
     TYPE* d_value;
 <span class="keyword">public</span>:
     Optional(): d_value() {}
     <span class="keyword">explicit</span> Optional(<span class="keyword">const</span> TYPE&amp; value): d_value(new TYPE(value)) {}
     ~Optional() { <span class="keyword">delete</span> d_value; }
     <span class="comment">// ...</span>

     <a class="code" href="bsls__cpp11_8h.html#aa017466452a1da889c8aa33a12c448d1">BSLS_CPP11_EXPLICIT</a> operator bool()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
 };
</pre></div><br/>
<br/>
 When using an object of the <code>Optional</code> class in a condition it is desirable that it converts to a <code>bool</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Optional&lt;int&gt; value;
 <span class="keywordflow">if</span> (value) { <span class="comment">/*... */</span> }
</pre></div><br/>
<br/>
 In places where an implicit conversion takes place it is not desirable that the conversion is used. When compiling with C++11 mode the conversion operator will not be used, e.g., the following code will result in an error: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> flag = value;
</pre></div><br/>
<br/>
 When defining conversion operators to <code>bool</code> for code which needs to compile with C++03 mode the conversion operator should convert to a member pointer type instead: doing so has a similar effect to making the conversion operator <code>explicit</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Some classes are not intended for use as a base class. To clearly label these classes and enforce that they can't be derived from C++11 allows using the <code>final</code> keyword after the class name in the class definition to label classes which are not intended to be derived from. The macro <code>BSLS_CPP11_FINAL</code> is replaced by <code>final</code> when compiling with C++11 causing the compiler to enforce that a class can't be further derived. The code below defines a class which can't be derived from: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>FinalClass <a class="code" href="bsls__cpp11_8h.html#a9d2a22bbd07d9c0bdcbb527b0277d847">BSLS_CPP11_FINAL</a>
 {
     <span class="keywordtype">int</span> d_value;
 <span class="keyword">public</span>:
     <span class="keyword">explicit</span> FinalClass(<span class="keywordtype">int</span> value = 0): d_value(value) {}
     <span class="keywordtype">int</span> value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
 };
</pre></div><br/>
<br/>
 An attempt to derive from this class will fail when compiling with C++11 mode: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>FinalClassDerived: <span class="keyword">public</span> FinalClass {
     <span class="keywordtype">int</span> d_anotherValue;
 <span class="keyword">public</span>:
     <span class="keyword">explicit</span> FinalClassDerived(<span class="keywordtype">int</span> value)
         : d_anotherValue(2 * value) {
     }
     <span class="keywordtype">int</span> anotherValue()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_anotherValue; }
 };
</pre></div><br/>
<br/>
 The code will compile successfully when using C++03 mode. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Sometime it is useful to declare that an overriding function is the final overriding function and further derived classes won't be allowed to furhter override the function. One use of this feature could be informing the compiler that it won't need to use virtual dispatch when calling this function on a pointer or a reference of the corresponding type. C++11 allows marking functions as the final overrider using the keyword <code>final</code>. The macro <code>BSLS_CPP11_FINAL</code> can also be used for this purpose. To demonstrate the use of this keyword first a base class with a <code>virtual</code> function is defined: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>FinalFunctionBase
 {
     <span class="keyword">virtual</span> <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 0; }
 };
</pre></div><br/>
<br/>
 When defining a derived class this function <code>f</code> can be marked as the final overrider using <code>BSLS_CPP11_FINAL</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>FinalFunctionDerived: FinalFunctionBase
 {
     <span class="keywordtype">int</span> f() <a class="code" href="bsls__cpp11_8h.html#a9d2a22bbd07d9c0bdcbb527b0277d847">BSLS_CPP11_FINAL</a> { <span class="keywordflow">return</span> 1; }
 };
</pre></div><br/>
<br/>
 The semantics of the overriding function aren't changed but a further derived class can't override the function <code>f</code>, i.e., the following code will result in an error when compiling with C++11 mode: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>FinalFunctionFailure: FinalFunctionDerived
 {
     <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 2; }
 };
</pre></div><br/>
<br/>
 With C++03 mode the code will successfully compile. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The C++11 keyword <code>override</code> is used to identify functions overriding a <code>virtual</code> function from a base class. If a function identified as <code>override</code> does not override a <code>virtual</code> function from a base class the compilation results in an error. The macro <code>BSLS_CPP11_OVERRIDE</code> is used to insert the <code>override</code> keyword when compiling with C++11 mode. When compiling with C++03 mode it has no effect but it both cases it documents that a function is overriding a <code>virtual</code> function from a base class. To demonstrate the use of the <code>BSLS_CPP11_OVERRIDE</code> macro first a base class is defined: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>OverrideBase
 {
     <span class="keyword">virtual</span> <span class="keywordtype">int</span> f()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
 };
</pre></div><br/>
<br/>
 When overriding <code>OverrideBase::f</code> in a derived class the <code>BSLS_CPP11_OVERRIDE</code> macro should be used to ascertain that the function in the derived class is indeed overriding a <code>virtual</code> function: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>OverrideSuccess: OverrideBase
 {
     <span class="keywordtype">int</span> f() const <a class="code" href="bsls__cpp11_8h.html#a6a7c3b5529349198834f94e095c88baf">BSLS_CPP11_OVERRIDE</a> { <span class="keywordflow">return</span> 1; }
 };
</pre></div><br/>
<br/>
 The above code compiles successfully with both C++03 mode and C++11. When the function meant to be an override actually isn't overriding any function the compilation will fail when using C++11 mode as is demonstrated by the following example (note the missing <code>const</code> in the function declaration): <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>OverrideFailure: OverrideBase
 {
     <span class="keywordtype">int</span> f() <a class="code" href="bsls__cpp11_8h.html#a6a7c3b5529349198834f94e095c88baf">BSLS_CPP11_OVERRIDE</a> { <span class="keywordflow">return</span> 2; }
 };
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:22 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
