<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslstl_multimap Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_multimap<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant multimap class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::DataWrapper</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1multimap_1_1value__compare.html">bsl::multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">bsl::multimap::key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gad2e0ce43e810181fb47558266aaa1a14">bsl::multimap::mapped_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; const KEY, <br class="typebreak"/>
VALUE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaa8edb2c67cabd9263eb0546a3b265e41">bsl::multimap::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef COMPARATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga381ca5a36e4bb990365cfd14840c1f02">bsl::multimap::key_compare</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga8196c57a81b7b18f4f0bc8b0a3648046">bsl::multimap::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gadaf32f24f68dee29abb6bef5cc5ba706">bsl::multimap::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga3721cc1d82ecfd184541c8e509442caf">bsl::multimap::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga41e4f8a3ad77732f3902850e45e50c2d">bsl::multimap::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga12dc12efe15876e1a232ea3689dcd2cc">bsl::multimap::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga8e2d0f94e6882a79d5e9baa62dccfa30">bsl::multimap::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga417da259eb597f81782501c45c0a3760">bsl::multimap::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::TreeIterator<br class="typebreak"/>
&lt; value_type, Node, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga57e4cc9a0c5075a89ba36ccb2da8e9ee">bsl::multimap::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::TreeIterator<br class="typebreak"/>
&lt; const value_type, Node, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga49dcf0f8b2254731f05bfff5ac556d9a">bsl::multimap::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga6f2b631c20e2946a39199e6e00a53fe6">bsl::multimap::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga280fc515bd1ffe533d96f9f6cf3ba67c">bsl::multimap::const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gadee89f11ce50c5b5352c243329e34f06">bsl::multimap::value_compare::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga98ac0be244d8b31e1c58e7a000343fad">bsl::multimap::value_compare::first_argument_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaed17751ca4d7e54bdf0439174a3fd4af">bsl::multimap::value_compare::second_argument_type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaf848a5966d4218b9e14194f91076883b">bsl::multimap::DataWrapper::DataWrapper</a> (const COMPARATOR &amp;comparator, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga5d5ed3e963f8491c5dee420c06c4cca9">bsl::multimap::value_compare::value_compare</a> (COMPARATOR c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga1c7c709746e806fc198d1223fdb877f8">bsl::multimap::value_compare::operator()</a> (const value_type &amp;x, const value_type &amp;y) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga6812eeb1a292a5d191e47838e1754e08">bsl::multimap::multimap</a> (const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga102c0d80a7852d2e4f38ffffc96c0db1">bsl::multimap::multimap</a> (const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga69275d4770ac3dea65f4a451fc8ca2d3">bsl::multimap::multimap</a> (const multimap &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gac6b4032af51ca846f5117ed1a5d573f9">bsl::multimap::multimap</a> (const multimap &amp;original, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaf01e9a7c316c3aba2f1e4e378eca6f69">bsl::multimap::multimap</a> (INPUT_ITERATOR first, INPUT_ITERATOR last, const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga89896a7dd4fd1a35bf327adb707cabdc">bsl::multimap::~multimap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">multimap &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga655f05ba15c1da49a46dd756a67b4fb8">bsl::multimap::operator=</a> (const multimap &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga140ee9333b49f4b1e707a6c6a11a438a">bsl::multimap::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaf6f8ae0a84399602772f8b7a17529467">bsl::multimap::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gac27a5c5554a15de224ae518e0044cb58">bsl::multimap::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaa96e4d4a288aad17c385c284b1ead6b2">bsl::multimap::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gac19b65e2712a7b6734b7600c3967f3c5">bsl::multimap::insert</a> (const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaf6c14fe381e67abba8a1d33cfb0521c3">bsl::multimap::insert</a> (const_iterator hint, const value_type &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga41407f84e1f7f32522a15e3687f9c741">bsl::multimap::insert</a> (INPUT_ITERATOR first, INPUT_ITERATOR last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga1dfafb0e35f64c67089fccb7b72e035f">bsl::multimap::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga9df6993fe62b4a88427e22f754f8d553">bsl::multimap::erase</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gab84e313355df3bef4e6ba04abe40b5f0">bsl::multimap::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga2a5b63bc2a7a2553aac2812cfe786a3d">bsl::multimap::swap</a> (multimap &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga725d6c92a56d461ac05d92807fcdd9e3">bsl::multimap::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaba8153e6008d2b181899391f1de75aef">bsl::multimap::find</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga9972e29c155617882ce1f522dfdf8386">bsl::multimap::lower_bound</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gad841c0a375de8e6a63caced8d73e2cd2">bsl::multimap::upper_bound</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaf38aff817813298d162c52f6b830b92d">bsl::multimap::equal_range</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gacbc93157666d0148fa83893a23ec2ef8">bsl::multimap::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga56cb6563136e9cccdedca848cd3f339f">bsl::multimap::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaf01381f49ca53e56ae54423dbda4c909">bsl::multimap::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga89aca99a2627ee61333330de150692ca">bsl::multimap::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga67cd0f116cefd14b5df6c4b01ab3243c">bsl::multimap::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga6e25db411efcd4a52f79da7408bb6b9e">bsl::multimap::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga23292ff5a01daff91924fa78bf3f6aff">bsl::multimap::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gab48e9b44197d1db572b77cc781f6aa96">bsl::multimap::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaaad5c8bceb989a22d727fbcfeffb3d8d">bsl::multimap::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga1bf9a278d113eb00c63792d72237f3b5">bsl::multimap::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga6abffff8fcef3234b8b4152d0651e141">bsl::multimap::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga6b6ddf88ef6da89acd5508a0c098bcb0">bsl::multimap::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">key_compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gab0a289d5c15e831d88fe959dd4cfcb41">bsl::multimap::key_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">value_compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga3a7ddd65ee1ab00b925909255df68e85">bsl::multimap::value_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga8d84de3ebe9fe12eeb5d7c791e8dd74b">bsl::multimap::find</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gadf3c410ea2d36df8a944b0ab962bbdd4">bsl::multimap::count</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gaa1d6e5f0835935d0e303ce0798bd7440">bsl::multimap::lower_bound</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga5ae39fe1fdb7c3a000378a51e5234d89">bsl::multimap::upper_bound</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga7d85487a916f1bd551e78438b9570c24">bsl::multimap::equal_range</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gae27bff9d448ee8c63a9171d2a395720b">bsl::operator==</a> (const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga4fc52a0082eb837264b9de4d1d92db60">bsl::operator!=</a> (const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gac9b2f689b4da8f5b466377d30fe65d96">bsl::operator&lt;</a> (const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga94a2b9a893c655bcd903fd31f0ef14cb">bsl::operator&gt;</a> (const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga4efa7f5e34b40ac39190468e744f969a">bsl::operator&lt;=</a> (const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gad512a2f22b260bcb81daf71a51c63c37">bsl::operator&gt;=</a> (const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga153c934515e350c6786edec5a81b7be5">bsl::swap</a> (multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;a, multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">COMPARATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga023433abc85bf2e4f3df3492f76351da">bsl::multimap::value_compare::comp</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on <code>KEY</code> and <code>VALUE</code></a> </li>
<li>
<a href="#3.2">Memory Allocation</a> <ul>
<li>
<a href="#3.2.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Operations</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Creating a Phone Book</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant multimap class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a> </td><td>STL-compatible multimap template  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__map.html" title="Provide an STL-compliant map class.">Component bslstl_map</a>, <a class="el" href="group__bslstl__multiset.html" title="Provide an STL-compliant multiset class.">Component bslstl_multiset</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template <code><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a></code>, implementing the standard container holding an ordered sequence of key-value pairs (possibly having duplicate keys), and presenting a mapping from the keys (of a template parameter type, <code>KEY</code>) to their associated values (of another template parameter type, <code>VALUE</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>multimap</code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of key-value pairs) and the ordered sequence of key-value pairs the multimap contains. If <code>multimap</code> is instantiated with either a key type or mapped-value type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if a either the key or value type cannot be tested for equality, then a <code>multimap</code> containing that type cannot be tested for equality. It is even possible to instantiate <code>multimap</code> with a key or mapped-value type that does not have a copy-constructor, in which case the <code>multimap</code> will not be copyable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>multimap</code> meets the requirements of an associative container with bidirectional iterators in the C++11 standard [23.2.4]. The <code>multimap</code> implemented here adheres to the C++11 standard, except that it does not have interfaces that take rvalue references, <code>initializer_lists</code>, <code>emplace</code>, or operations taking a variadic number of template parameters. Note that excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_key_and_value"></a> <a class="anchor" id="description.requirements_on_key_and_value"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on KEY and VALUE: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>multimap</code> is a fully <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the supplied <code>KEY</code> and <code>VALUE</code> template parameters are themselves fully value-semantic. It is possible to instantiate a <code>multimap</code> with <code>KEY</code> and <code>VALUE</code> parameter arguments that do not provide a full set of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code>multimap</code> to describe a function's requirements for the <code>KEY</code> and <code>VALUE</code> template parameters. These terms are also defined in section [17.6.3.1] of the C++11 standard. Note that, in the context of a <code>multimap</code> instantiation, the requirements apply specifically to the multimap's entry type, <code>value_type</code>, which is an alias for 'bslpair&lt;KEY, VALUE&gt;'. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_key_and_value.default-constructible"></a> <a class="anchor" id="description.requirements_on_key_and_value.default-constructible"></a> <em>default-constructible</em>: The type provides a default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_key_and_value.copy-constructible"></a> <a class="anchor" id="description.requirements_on_key_and_value.copy-constructible"></a> <em>copy-constructible</em>: The type provides a copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_key_and_value.equality-comparable"></a> <a class="anchor" id="description.requirements_on_key_and_value.equality-comparable"></a> <em>equality-comparable</em>: The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="less-than-comparable"></a> <a class="anchor" id="requirements_on_key_and_value.less-than-comparable"></a> <a class="anchor" id="description.requirements_on_key_and_value.less-than-comparable"></a> <em>less-than-comparable</em>: The type provides a less-than operator, which defines a strict weak ordering relation on values of the type.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a multimap's <code>ALLOCATOR</code> template parameter determines how that multimap will allocate memory. The <code>multimap</code> template supports allocators meeting the requirements of the C++11 standard [17.6.3.5], in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the (template parameter) type <code>ALLOCATOR</code> of an <code>multimap</code> instantiation' is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that multimap type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a multimap accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it will be used to supply memory for the <code>multimap</code> throughout its lifetime; otherwise, the multimap will use the default allocator installed at the time of the multimap's construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, a multimap supplies that allocator's address to the constructors of contained objects of the (template parameter) types <code>KEY</code> and <code>VALUE</code>, if respectively, the types define the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code>multimap</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;K&#39;</span>             - (<span class="keyword">template</span> parameter) type <span class="stringliteral">&#39;KEY&#39;</span> of the <span class="stringliteral">&#39;multimap&#39;</span>
  <span class="charliteral">&#39;V&#39;</span>             - (<span class="keyword">template</span> parameter) type &#39;VALUE&#39; of the &#39;multimap&#39;
  &#39;a&#39;, &#39;b&#39;        - two distinct objects of type &#39;multimap&lt;K, V&gt;&#39;
  &#39;n&#39;, &#39;m&#39;        - number of elements in &#39;a&#39; and &#39;b&#39; respectively
  &#39;value_type&#39;    - &#39;multimap&lt;K, V&gt;::value_type&#39;
  &#39;c&#39;             - comparator providing an ordering for objects of type &#39;K&#39;
  &#39;al             - an STL-style memory allocator
  &#39;i1&#39;, &#39;i2&#39;      - two iterators defining a sequence of &#39;value_type&#39; objects
  &#39;k&#39;             - an <span class="keywordtype">object</span> of type &#39;K&#39;
  &#39;v&#39;             - an <span class="keywordtype">object</span> of type &#39;V&#39;
  &#39;p1&#39;, &#39;p2&#39;      - two iterators belonging to &#39;a&#39;
  distance(i1,i2) - the number of elements in the range [i1, i2)

  +----------------------------------------------------+--------------------+
  | Operation                                          | Complexity         |
  +====================================================+====================+
  | multimap&lt;K, V&gt; a;    (default construction)        | O[1]               |
  | multimap&lt;K, V&gt; a(al);                              |                    |
  | multimap&lt;K, V&gt; a(c, al);                           |                    |
  +----------------------------------------------------+--------------------+
  | multimap&lt;K, V&gt; a(b); (copy construction)           | O[n]               |
  | multimap&lt;K, V&gt; a(b, al);                           |                    |
  +----------------------------------------------------+--------------------+
  | multimap&lt;K, V&gt; a(i1, i2);                          | O[N] if [i1, i2)   |
  | multimap&lt;K, V&gt; a(i1, i2, al);                      | is sorted with     |
  | multimap&lt;K, V&gt; a(i1, i2, c, al);                   | &#39;a.value_comp()&#39;,  |
  |                                                    | O[N * log(N)]      |
  |                                                    | otherwise, where N |
  |                                                    | is distance(i1,i2) |
  +----------------------------------------------------+--------------------+
  | a.~multimap&lt;K, V&gt;(); (destruction)                 | O[n]               |
  +----------------------------------------------------+--------------------+
  | a = b;          (assignment)                       | O[n]               |
  +----------------------------------------------------+--------------------+
  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |
  | a.rbegin(), a.rend(), a.crbegin(), a.crend()       |                    |
  +----------------------------------------------------+--------------------+
  | a == b, a != b                                     | O[n]               |
  +----------------------------------------------------+--------------------+
  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b                       | O[n]               |
  +----------------------------------------------------+--------------------+
  | a.<a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(b), <a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(a,b)                               | O[1] if &#39;a&#39; and    |
  |                                                    | &#39;b&#39; use the same   |
  |                                                    | allocator,         |
  |                                                    | O[n + m] otherwise |
  +----------------------------------------------------+--------------------+
  | a.size()                                           | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.max_size()                                       | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.empty()                                          | O[1]               |
  +----------------------------------------------------+--------------------+
  | get_allocator()                                    | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.insert(value_type(k, v))                         | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.insert(p1, value_type(k, v))                     | amortized constant |
  |                                                    | if the value is    |
  |                                                    | inserted right     |
  |                                                    | before p1,         |
  |                                                    | O[log(n)]          |
  |                                                    | otherwise          |
  +----------------------------------------------------+--------------------+
  | a.insert(i1, i2)                                   | O[log(N) *         |
  |                                                    |   distance(i1,i2)] |
  |                                                    |                    |
  |                                                    | where N is         |
  |                                                    | n + distance(i1,i2)|
  +----------------------------------------------------+--------------------+
  | a.erase(p1)                                        | amortized constant |
  +----------------------------------------------------+--------------------+
  | a.erase(k)                                         | O[log(n) +         |
  |                                                    | a.count(k)]        |
  +----------------------------------------------------+--------------------+
  | a.erase(p1, p2)                                    | O[log(n) +         |
  |                                                    | distance(p1, p2)]  |
  +----------------------------------------------------+--------------------+
  | a.erase(p1, p2)                                    | O[log(n) +         |
  |                                                    | distance(p1, p2)]  |
  +----------------------------------------------------+--------------------+
  | a.clear()                                          | O[n]               |
  +----------------------------------------------------+--------------------+
  | a.key_comp()                                       | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.value_comp()                                     | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.find(k)                                          | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.count(k)                                         | O[log(n) +         |
  |                                                    | a.count(k)]        |
  +----------------------------------------------------+--------------------+
  | a.lower_bound(k)                                   | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.upper_bound(k)                                   | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.equal_range(k)                                   | O[log(n)]          |
  +----------------------------------------------------+--------------------+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_phone_book"></a> <a class="anchor" id="usage.example_1~3A_creating_a_phone_book"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_phone_book"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Phone Book: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will define a class <code>PhoneBook</code>, that provides a mapping of names to phone numbers. The <code>PhoneBook</code> class will be implemented using a <code><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a></code>, and will supply manipulators, allowing a client to add or remove entries from the phone book, as well as accessors, allowing clients to efficiently lookup entries by name, and to iterate over the entries in the phone book in sorted order. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that this example uses a type <code>string</code> that is based on the standard type <code>string</code> (see <code>bslstl_string</code>). For the sake of brevity, the implementation of <code>string</code> is not explored here. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define an alias for a pair of <code>string</code> objects that we will use to represent names in the phone book: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;string, string&gt;</a> FirstAndLastName;
      <span class="comment">// This &#39;typedef&#39; provides an alias for a pair of &#39;string&#39; objects,</span>
      <span class="comment">// whose &#39;first&#39; and &#39;second&#39; elements refer to the first and last</span>
      <span class="comment">// names of a person, respectively.</span>
</pre></div><br/>
<br/>
 Then, we define a comparison functor for <code>FirstAndLastName</code> objects (note that this comparator is required because we intend for the last name to take precedence over the first name in the ordering of entries maintained by the phone book, which differs from the behavior supplied by <code>operator&lt;</code> for <code>pair</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>FirstAndLastNameLess {
      <span class="comment">// This &#39;struct&#39; defines an ordering on &#39;FirstAndLastName&#39; values,</span>
      <span class="comment">// allowing them to be included in sorted containers such as</span>
      <span class="comment">// &#39;bsl::multimap&#39;.  Note that last name (the &#39;second&#39; member of a</span>
      <span class="comment">// &#39;FirstAndLastName&#39; value) takes precedence over first name in the</span>
      <span class="comment">// ordering defined by this functor.</span>

      <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> FirstAndLastName&amp; lhs,
                      <span class="keyword">const</span> FirstAndLastName&amp; rhs) <span class="keyword">const</span>
          <span class="comment">// Return &#39;true&#39; if the value of the specified &#39;lhs&#39; is less than</span>
          <span class="comment">// (ordered before) the value of the specified &#39;rhs&#39;, and &#39;false&#39;</span>
          <span class="comment">// otherwise.  The &#39;lhs&#39; value is considered less than the &#39;rhs&#39;</span>
          <span class="comment">// value if the second value in the &#39;lhs&#39; pair (the last name) is</span>
          <span class="comment">// less than the second value in the &#39;rhs&#39; pair or, if the second</span>
          <span class="comment">// values are equal, if the first value in the &#39;lhs&#39; pair (the</span>
          <span class="comment">// first name) is less than the first value in the &#39;rhs&#39; pair.</span>
      {
          <span class="keywordtype">int</span> cmp = std::strcmp(lhs.second.c_str(), rhs.second.c_str());
          <span class="keywordflow">if</span> (0 == cmp) {
              cmp = std::strcmp(lhs.first.c_str(), rhs.first.c_str());
          }
          <span class="keywordflow">return</span> cmp &lt; 0;
      }
  };
</pre></div><br/>
<br/>
 Next, we define the public interface for <code>PhoneBook</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>PhoneBook {
      <span class="comment">// This class provides a mapping of a person&#39;s name to their phone</span>
      <span class="comment">// number.  Names within a &#39;Phonebook&#39; are represented using a using</span>
      <span class="comment">// &#39;FirstAndLastName&#39; object, and phone numbers are represented using a</span>
      <span class="comment">// &#39;bsls::Types::Uint64&#39; value.</span>
</pre></div><br/>
<br/>
 Here, we create a type alias, <code>NameToNumberMap</code>, for a <code><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a></code> that will serve as the data member for a <code>PhoneBook</code>. A <code>NameToNumberMap</code> has keys of type <code>FirstAndLastName</code>, mapped-values of type <code><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a></code>, and a comparator of type <code>FirstAndLastNameLess</code>. We use the default <code>ALLOCATOR</code> template parameter as we intend to use <code>PhoneBook</code> with <code>bslma</code> style allocators: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt;FirstAndLastName,
                            bsls::Types::Uint64,
                            FirstAndLastNameLess&gt; NameToNumberMap;
          <span class="comment">// This &#39;typedef&#39; is an alias for a mapping between names and phone</span>
          <span class="comment">// numbers.</span>

      <span class="comment">// DATA</span>
      NameToNumberMap d_nameToNumber;  <span class="comment">// mapping of names to phone numbers</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> PhoneBook&amp; lhs, <span class="keyword">const</span> PhoneBook&amp; rhs);

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> bsls::Types::Uint64 PhoneNumber;
          <span class="comment">// This &#39;typedef&#39; provides an alias for the type of an unsigned</span>
          <span class="comment">// integers used to represent phone-numbers in a &#39;PhoneBook&#39;.</span>

      <span class="keyword">typedef</span> NameToNumberMap::const_iterator ConstIterator;
          <span class="comment">// This &#39;typedef&#39; provides an alias for the type of an iterator</span>
          <span class="comment">// providing non-modifiable access to the entries in a &#39;PhoneBook&#39;.</span>

      <span class="comment">// CREATORS</span>
      PhoneBook(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;PhoneBook&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      PhoneBook(<span class="keyword">const</span> PhoneBook&amp;  original,
                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>  *basicAllocator = 0);
          <span class="comment">// Create a &#39;PhoneBook&#39; object having the same value as the</span>
          <span class="comment">// specified &#39;original&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      PhoneBook&amp; operator=(<span class="keyword">const</span> PhoneBook&amp; rhs);
          <span class="comment">// Assign to this object the value of the specified &#39;rhs&#39; object,</span>
          <span class="comment">// and return a reference providing modifiable access to this</span>
          <span class="comment">// object.</span>

      <span class="keywordtype">void</span> addEntry(<span class="keyword">const</span> FirstAndLastName&amp; name, PhoneNumber number);
          <span class="comment">// Add an entry to this phone book having the specified &#39;name&#39; and</span>
          <span class="comment">// &#39;number&#39;.  The behavior is undefined unless &#39;name.first&#39; and</span>
          <span class="comment">// &#39;name.end&#39; are non-empty strings.</span>

      <span class="keywordtype">int</span> removeEntry(<span class="keyword">const</span> FirstAndLastName&amp; name, PhoneNumber number);
          <span class="comment">// Remove the entries from this phone book having the specified</span>
          <span class="comment">// &#39;name&#39; and &#39;number&#39;, if they exists, and return the number of</span>
          <span class="comment">// removed entries; otherwise, return 0 with no other effects.</span>

      <span class="comment">// ACCESSORS</span>
      <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;ConstIterator, ConstIterator&gt;</a> lookupByName(
                                         <span class="keyword">const</span> FirstAndLastName&amp; name) <span class="keyword">const</span>;
          <span class="comment">// Return a pair of iterators to the ordered sequence of entries</span>
          <span class="comment">// held in this phone book having the specified &#39;name&#39;, where the</span>
          <span class="comment">// first iterator is position at the start of the sequence, and the</span>
          <span class="comment">// second is positioned one past the last entry in the sequence.</span>
          <span class="comment">// If &#39;name&#39; does not exist in this phone book, then the two</span>
          <span class="comment">// returned iterators will have the same value.</span>

      ConstIterator begin() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the first</span>
          <span class="comment">// entry in the ordered sequence of entries held in this phone</span>
          <span class="comment">// book, or the past-the-end iterator if this phone book is empty.</span>

      ConstIterator end() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// past-the-end entry in the ordered sequence of entries maintained</span>
          <span class="comment">// by this phone book.</span>

      <span class="keywordtype">int</span> numEntries() <span class="keyword">const</span>;
          <span class="comment">// Return the number of entries contained in this phone book.</span>
  };
</pre></div><br/>
<br/>
 Then, we declare the free operators for <code>PhoneBook</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> PhoneBook&amp; lhs, <span class="keyword">const</span> PhoneBook&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two &#39;PhoneBook&#39; objects have the</span>
      <span class="comment">// same value if they have the same number of entries, and each</span>
      <span class="comment">// corresponding entry, in their respective ordered sequence of</span>
      <span class="comment">// entries, is the same.</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> PhoneBook&amp; lhs, <span class="keyword">const</span> PhoneBook&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;PhoneBook&#39; objects do</span>
      <span class="comment">// not have the same value if they either differ in their number of</span>
      <span class="comment">// contained entries, or if any of the corresponding entries, in their</span>
      <span class="comment">// respective ordered sequences of entries, is not the same.</span>
</pre></div><br/>
<br/>
 Now, we define the implementations methods of the <code>PhoneBook</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  PhoneBook::PhoneBook(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_nameToNumber(FirstAndLastNameLess(), basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Notice that, on construction, we pass the contained <code><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a></code> (<code>d_nameToNumber</code>), a default constructed <code>FirstAndLastNameLess</code> object that it will use to perform comparisons, and the allocator supplied to <code>PhoneBook</code> at construction'. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  PhoneBook::PhoneBook(<span class="keyword">const</span> PhoneBook&amp;   original,
                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>  *basicAllocator)
  : d_nameToNumber(original.d_nameToNumber, basicAllocator)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  PhoneBook&amp; PhoneBook::operator=(<span class="keyword">const</span> PhoneBook&amp; rhs)
  {
      d_nameToNumber = rhs.d_nameToNumber;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> PhoneBook::addEntry(<span class="keyword">const</span> FirstAndLastName&amp; name, PhoneNumber number)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(!name.first.empty());
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(!name.second.empty());

      d_nameToNumber.insert(NameToNumberMap::value_type(name, number));
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> PhoneBook::removeEntry(<span class="keyword">const</span> FirstAndLastName&amp; name,
                             PhoneNumber             number)
  {

      <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;NameToNumberMap::iterator, NameToNumberMap::iterator&gt;</a> range =
                                            d_nameToNumber.equal_range(name);

      NameToNumberMap::iterator itr = range.<a class="code" href="group__bslstl__pair.html#gafff8113b0b2f4bbe5df93ce0ba30fad8">first</a>;
      <span class="keywordtype">int</span> numRemovedEntries = 0;

      <span class="keywordflow">while</span> (itr != range.<a class="code" href="group__bslstl__pair.html#gaf89d2b38598dfb6fa42775f2e135f1d8">second</a>) {
          <span class="keywordflow">if</span> (itr-&gt;second == number) {
              itr = d_nameToNumber.erase(itr);
              ++numRemovedEntries;
          }
          <span class="keywordflow">else</span> {
              ++itr;
          }
      }

      <span class="keywordflow">return</span> numRemovedEntries;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;PhoneBook::ConstIterator, PhoneBook::ConstIterator&gt;</a>
  PhoneBook::lookupByName(<span class="keyword">const</span> FirstAndLastName&amp;  name)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_nameToNumber.equal_range(name);
  }

  <span class="keyword">inline</span>
  PhoneBook::ConstIterator PhoneBook::begin()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_nameToNumber.begin();
  }

  <span class="keyword">inline</span>
  PhoneBook::ConstIterator PhoneBook::end()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_nameToNumber.end();
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> PhoneBook::numEntries()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_nameToNumber.size();
  }
</pre></div><br/>
<br/>
 Finally, we implement the free operators for <code>PhoneBook</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> PhoneBook&amp; lhs, <span class="keyword">const</span> PhoneBook&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_nameToNumber == rhs.d_nameToNumber;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> PhoneBook&amp; lhs, <span class="keyword">const</span> PhoneBook&amp; rhs)
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gad7afc1729b7c01609e6d7544e87a4286"></a><!-- doxytag: member="bsl::multimap::key_type" ref="gad7afc1729b7c01609e6d7544e87a4286" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::key_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad2e0ce43e810181fb47558266aaa1a14"></a><!-- doxytag: member="bsl::multimap::mapped_type" ref="gad2e0ce43e810181fb47558266aaa1a14" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::mapped_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa8edb2c67cabd9263eb0546a3b265e41"></a><!-- doxytag: member="bsl::multimap::value_type" ref="gaa8edb2c67cabd9263eb0546a3b265e41" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;const KEY, VALUE&gt; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga381ca5a36e4bb990365cfd14840c1f02"></a><!-- doxytag: member="bsl::multimap::key_compare" ref="ga381ca5a36e4bb990365cfd14840c1f02" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef COMPARATOR <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::key_compare<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8196c57a81b7b18f4f0bc8b0a3648046"></a><!-- doxytag: member="bsl::multimap::allocator_type" ref="ga8196c57a81b7b18f4f0bc8b0a3648046" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadaf32f24f68dee29abb6bef5cc5ba706"></a><!-- doxytag: member="bsl::multimap::reference" ref="gadaf32f24f68dee29abb6bef5cc5ba706" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type&amp; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3721cc1d82ecfd184541c8e509442caf"></a><!-- doxytag: member="bsl::multimap::const_reference" ref="ga3721cc1d82ecfd184541c8e509442caf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const value_type&amp; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga41e4f8a3ad77732f3902850e45e50c2d"></a><!-- doxytag: member="bsl::multimap::size_type" ref="ga41e4f8a3ad77732f3902850e45e50c2d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::size_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga12dc12efe15876e1a232ea3689dcd2cc"></a><!-- doxytag: member="bsl::multimap::difference_type" ref="ga12dc12efe15876e1a232ea3689dcd2cc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::difference_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8e2d0f94e6882a79d5e9baa62dccfa30"></a><!-- doxytag: member="bsl::multimap::pointer" ref="ga8e2d0f94e6882a79d5e9baa62dccfa30" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::pointer <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga417da259eb597f81782501c45c0a3760"></a><!-- doxytag: member="bsl::multimap::const_pointer" ref="ga417da259eb597f81782501c45c0a3760" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::const_pointer <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga57e4cc9a0c5075a89ba36ccb2da8e9ee"></a><!-- doxytag: member="bsl::multimap::iterator" ref="ga57e4cc9a0c5075a89ba36ccb2da8e9ee" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::TreeIterator&lt;value_type, Node, difference_type&gt; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga49dcf0f8b2254731f05bfff5ac556d9a"></a><!-- doxytag: member="bsl::multimap::const_iterator" ref="ga49dcf0f8b2254731f05bfff5ac556d9a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::TreeIterator&lt;const value_type, Node, difference_type&gt; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6f2b631c20e2946a39199e6e00a53fe6"></a><!-- doxytag: member="bsl::multimap::reverse_iterator" ref="ga6f2b631c20e2946a39199e6e00a53fe6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga280fc515bd1ffe533d96f9f6cf3ba67c"></a><!-- doxytag: member="bsl::multimap::const_reverse_iterator" ref="ga280fc515bd1ffe533d96f9f6cf3ba67c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadee89f11ce50c5b5352c243329e34f06"></a><!-- doxytag: member="bsl::multimap::value_compare::result_type" ref="gadee89f11ce50c5b5352c243329e34f06" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga98ac0be244d8b31e1c58e7a000343fad"></a><!-- doxytag: member="bsl::multimap::value_compare::first_argument_type" ref="ga98ac0be244d8b31e1c58e7a000343fad" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::first_argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaed17751ca4d7e54bdf0439174a3fd4af"></a><!-- doxytag: member="bsl::multimap::value_compare::second_argument_type" ref="gaed17751ca4d7e54bdf0439174a3fd4af" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::second_argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf848a5966d4218b9e14194f91076883b"></a><!-- doxytag: member="bsl::multimap::DataWrapper::DataWrapper" ref="gaf848a5966d4218b9e14194f91076883b" args="(const COMPARATOR &amp;comparator, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::DataWrapper::DataWrapper </td>
          <td>(</td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>DataWrapper</code> object with the specified <code>comparator</code> and <code>basicAllocator</code>. </p>

</div>
</div>
<a class="anchor" id="ga5d5ed3e963f8491c5dee420c06c4cca9"></a><!-- doxytag: member="bsl::multimap::value_compare::value_compare" ref="ga5d5ed3e963f8491c5dee420c06c4cca9" args="(COMPARATOR c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::value_compare </td>
          <td>(</td>
          <td class="paramtype">COMPARATOR&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a <code><a class="el" href="classbsl_1_1multimap_1_1value__compare.html">value_compare</a></code> object that will delegate to the specified <code>comparator</code> for comparisons. </p>

</div>
</div>
<a class="anchor" id="ga1c7c709746e806fc198d1223fdb877f8"></a><!-- doxytag: member="bsl::multimap::value_compare::operator()" ref="ga1c7c709746e806fc198d1223fdb877f8" args="(const value_type &amp;x, const value_type &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>x</code> object is ordered before the specified <code>y</code> object, as determined by the comparator supplied at construction. </p>

</div>
</div>
<a class="anchor" id="ga6812eeb1a292a5d191e47838e1754e08"></a><!-- doxytag: member="bsl::multimap::multimap" ref="ga6812eeb1a292a5d191e47838e1754e08" args="(const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::multimap </td>
          <td>(</td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em> = <code>COMPARATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicAllocator</em>&nbsp;</td><td>Construct an empty multimap. Optionally specify a <code>comparator</code> used to order key-value pairs contained in this object. If <code>comparator</code> is not supplied, a default-constructed object of the (template parameter) type <code>COMPARATOR</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type ALLOCATOR' is used. If the <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator will be used to supply memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga102c0d80a7852d2e4f38ffffc96c0db1"></a><!-- doxytag: member="bsl::multimap::multimap" ref="ga102c0d80a7852d2e4f38ffffc96c0db1" args="(const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::multimap </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty multimap that will use the specified <code>basicAllocator</code> to supply memory. Use a default-constructed object of the (template parameter) type <code>COMPARATOR</code> to order the key-value pairs contained in this multimap. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default) then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="ga69275d4770ac3dea65f4a451fc8ca2d3"></a><!-- doxytag: member="bsl::multimap::multimap" ref="ga69275d4770ac3dea65f4a451fc8ca2d3" args="(const multimap &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a multimap having the same value as the specified <code>original</code>. Use a copy of <code>original.key_comp()</code> to order the key-value pairs contained in this multimap. Use the allocator returned by 'bslallocator_traits&lt;ALLOCATOR&gt;:: select_on_container_copy_construction(original.allocator())' to allocate memory. If the (template parameter) type <code>ALLOCATOR</code> is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), the currently installed default allocator will be used to supply memory. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac6b4032af51ca846f5117ed1a5d573f9"></a><!-- doxytag: member="bsl::multimap::multimap" ref="gac6b4032af51ca846f5117ed1a5d573f9" args="(const multimap &amp;original, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a multimap having the same value as that of the specified <code>original</code> that will use the specified <code>basicAllocator</code> to supply memory. Use a copy of <code>original.key_comp()</code> to order the key-value pairs contained in this multimap. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default) then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaf01e9a7c316c3aba2f1e4e378eca6f69"></a><!-- doxytag: member="bsl::multimap::multimap" ref="gaf01e9a7c316c3aba2f1e4e378eca6f69" args="(INPUT_ITERATOR first, INPUT_ITERATOR last, const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::multimap </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em> = <code>COMPARATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a multimap, and insert each <code>value_type</code> object in the sequence starting at the specified <code>first</code> element, and ending immediately before the specified <code>last</code> element, ignoring those pairs having a key that appears earlier in the sequence. Optionally specify a <code>comparator</code> used to order key-value pairs contained in this object. If <code>comparator</code> is not supplied, a default-constructed object of the (template parameter) type <code>COMPARATOR</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default) then <code>basicAllocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator will be used to supply memory. If the sequence <code>first</code> and <code>last</code> is ordered according to the identified <code>comparator</code> then this operation will have O[N] complexity, where N is the number of elements between <code>first</code> and <code>last</code>, otherwise this operation will have O[N * log(N)] complexity. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga89896a7dd4fd1a35bf327adb707cabdc"></a><!-- doxytag: member="bsl::multimap::~multimap" ref="ga89896a7dd4fd1a35bf327adb707cabdc" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::~multimap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object; </p>

</div>
</div>
<a class="anchor" id="ga655f05ba15c1da49a46dd756a67b4fb8"></a><!-- doxytag: member="bsl::multimap::operator=" ref="ga655f05ba15c1da49a46dd756a67b4fb8" args="(const multimap &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">multimap&amp; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value and comparator of the specified <code>rhs</code> object, propagate to this object the allocator of <code>rhs</code> if the <code>ALLOCATOR</code> type has trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga140ee9333b49f4b1e707a6c6a11a438a"></a><!-- doxytag: member="bsl::multimap::begin" ref="ga140ee9333b49f4b1e707a6c6a11a438a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multimap, or the <code>end</code> iterator if this multimap is empty. </p>

</div>
</div>
<a class="anchor" id="gaf6f8ae0a84399602772f8b7a17529467"></a><!-- doxytag: member="bsl::multimap::end" ref="gaf6f8ae0a84399602772f8b7a17529467" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this multimap. </p>

</div>
</div>
<a class="anchor" id="gac27a5c5554a15de224ae518e0044cb58"></a><!-- doxytag: member="bsl::multimap::rbegin" ref="gac27a5c5554a15de224ae518e0044cb58" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multimap, or <code>rend</code> if this multimap is empty. </p>

</div>
</div>
<a class="anchor" id="gaa96e4d4a288aad17c385c284b1ead6b2"></a><!-- doxytag: member="bsl::multimap::rend" ref="gaa96e4d4a288aad17c385c284b1ead6b2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this multimap. </p>

</div>
</div>
<a class="anchor" id="gac19b65e2712a7b6734b7600c3967f3c5"></a><!-- doxytag: member="bsl::multimap::insert" ref="gac19b65e2712a7b6734b7600c3967f3c5" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this multimap. If a range containing elements equivalent to <code>value</code> already exist, insert <code>value</code> at the end of that range. Return an iterator referring to the newly inserted <code>value_type</code> object. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaf6c14fe381e67abba8a1d33cfb0521c3"></a><!-- doxytag: member="bsl::multimap::insert" ref="gaf6c14fe381e67abba8a1d33cfb0521c3" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__multimap.html#ga49dcf0f8b2254731f05bfff5ac556d9a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this multimap as close as possible to the position just prior to the specified <code>hint</code> (in amortized constant time if the <code>hint</code> is a valid immediate successor to the key of <code>value</code>). If <code>hint</code> is not a valid immediate successor to the key of <code>value</code>, this operation will have O[log(N)] complexity, where <code>N</code> is the size of this multimap. The behavior is undefined unless <code>hint</code> is a valid iterator into this multimap. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga41407f84e1f7f32522a15e3687f9c741"></a><!-- doxytag: member="bsl::multimap::insert" ref="ga41407f84e1f7f32522a15e3687f9c741" args="(INPUT_ITERATOR first, INPUT_ITERATOR last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert into this multimap the value of each <code>value_type</code> object in the range starting at the specified <code>first</code> iterator and ending immediately before the specified <code>last</code> iterator. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga1dfafb0e35f64c67089fccb7b72e035f"></a><!-- doxytag: member="bsl::multimap::erase" ref="ga1dfafb0e35f64c67089fccb7b72e035f" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__multimap.html#ga49dcf0f8b2254731f05bfff5ac556d9a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this multimap the <code>value_type</code> object at the specified <code>position</code>, and return an iterator referring to the element immediately following the removed element, or to the past-the-end position if the removed element was the last element in the sequence of elements maintained by this multimap. The behavior is undefined unless <code>position</code> refers to a <code>value_type</code> object in this multimap. </p>

</div>
</div>
<a class="anchor" id="ga9df6993fe62b4a88427e22f754f8d553"></a><!-- doxytag: member="bsl::multimap::erase" ref="ga9df6993fe62b4a88427e22f754f8d553" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remote from this multimap all <code>value_type</code> objects having the specified <code>key</code>, if they exist, and return the number of erased objects; otherwise, if there is no <code>value_type</code> objects having <code>key</code>, return 0 with no other effect. </p>

</div>
</div>
<a class="anchor" id="gab84e313355df3bef4e6ba04abe40b5f0"></a><!-- doxytag: member="bsl::multimap::erase" ref="gab84e313355df3bef4e6ba04abe40b5f0" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__multimap.html#ga49dcf0f8b2254731f05bfff5ac556d9a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__multimap.html#ga49dcf0f8b2254731f05bfff5ac556d9a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this multimap the <code>value_type</code> objects starting at the specified <code>first</code> position up to, but including the specified <code>last</code> position, and return <code>last</code>. The behavior is undefined unless <code>first</code> and <code>last</code> either refer to elements in this multimap or are the <code>end</code> iterator, and the <code>first</code> position is at or before the <code>last</code> position in the ordered sequence provided by this container. </p>

</div>
</div>
<a class="anchor" id="ga2a5b63bc2a7a2553aac2812cfe786a3d"></a><!-- doxytag: member="bsl::multimap::swap" ref="ga2a5b63bc2a7a2553aac2812cfe786a3d" args="(multimap &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object as well as its comparator with those of the specified <code>other</code> object. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees O[1] complexity. The behavior is undefined is unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="ga725d6c92a56d461ac05d92807fcdd9e3"></a><!-- doxytag: member="bsl::multimap::clear" ref="ga725d6c92a56d461ac05d92807fcdd9e3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all entries from this multimap. Note that the multimap is empty after this call, but allocated memory may be retained for future use. </p>

</div>
</div>
<a class="anchor" id="gaba8153e6008d2b181899391f1de75aef"></a><!-- doxytag: member="bsl::multimap::find" ref="gaba8153e6008d2b181899391f1de75aef" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object having the specified <code>key</code> in ordered sequence maintained by this multimap, if such an object exists; otherwise, return the past-the-end (<code>end</code>) iterator. </p>

</div>
</div>
<a class="anchor" id="ga9972e29c155617882ce1f522dfdf8386"></a><!-- doxytag: member="bsl::multimap::lower_bound" ref="ga9972e29c155617882ce1f522dfdf8386" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this multimap whose key is greater-than or equal-to the specified <code>key</code>, and the past-the-end iterator if this multimap does not contain a <code>value_type</code> object whose key is greater-than or equal-to <code>key</code>. Note that this function returns the <em>first</em> position before which a <code>value_type</code> object having <code>key</code> could be inserted into the ordered sequence maintained by this multimap, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="gad841c0a375de8e6a63caced8d73e2cd2"></a><!-- doxytag: member="bsl::multimap::upper_bound" ref="gad841c0a375de8e6a63caced8d73e2cd2" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this multimap whose key is greater than the specified <code>key</code>, and the past-the-end iterator if this multimap does not contain a <code>value_type</code> object whose key is greater-than <code>key</code>. Note that this function returns the <em>last</em> position before which a <code>value_type</code> object having <code>key</code> could be inserted into the ordered sequence maintained by this multimap, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="gaf38aff817813298d162c52f6b830b92d"></a><!-- doxytag: member="bsl::multimap::equal_range" ref="gaf38aff817813298d162c52f6b830b92d" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;iterator,iterator&gt; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing modifiable access to the sequence of <code>value_type</code> objects in this multimap having the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. The first returned iterator will be <code>lower_bound(key)</code>; the second returned iterator will be <code>upper_bound(key)</code>; and, if this multimap contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. </p>

</div>
</div>
<a class="anchor" id="gacbc93157666d0148fa83893a23ec2ef8"></a><!-- doxytag: member="bsl::multimap::get_allocator" ref="gacbc93157666d0148fa83893a23ec2ef8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the allocator used for memory allocation by this multimap. </p>

</div>
</div>
<a class="anchor" id="ga56cb6563136e9cccdedca848cd3f339f"></a><!-- doxytag: member="bsl::multimap::begin" ref="ga56cb6563136e9cccdedca848cd3f339f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multimap, or the <code>end</code> iterator if this multimap is empty. </p>

</div>
</div>
<a class="anchor" id="gaf01381f49ca53e56ae54423dbda4c909"></a><!-- doxytag: member="bsl::multimap::end" ref="gaf01381f49ca53e56ae54423dbda4c909" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this multimap. </p>

</div>
</div>
<a class="anchor" id="ga89aca99a2627ee61333330de150692ca"></a><!-- doxytag: member="bsl::multimap::rbegin" ref="ga89aca99a2627ee61333330de150692ca" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multimap, or <code>rend</code> if this multimap is empty. </p>

</div>
</div>
<a class="anchor" id="ga67cd0f116cefd14b5df6c4b01ab3243c"></a><!-- doxytag: member="bsl::multimap::rend" ref="ga67cd0f116cefd14b5df6c4b01ab3243c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this multimap. </p>

</div>
</div>
<a class="anchor" id="ga6e25db411efcd4a52f79da7408bb6b9e"></a><!-- doxytag: member="bsl::multimap::cbegin" ref="ga6e25db411efcd4a52f79da7408bb6b9e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multimap, or the <code>cend</code> iterator if this multimap is empty. </p>

</div>
</div>
<a class="anchor" id="ga23292ff5a01daff91924fa78bf3f6aff"></a><!-- doxytag: member="bsl::multimap::cend" ref="ga23292ff5a01daff91924fa78bf3f6aff" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this multimap. </p>

</div>
</div>
<a class="anchor" id="gab48e9b44197d1db572b77cc781f6aa96"></a><!-- doxytag: member="bsl::multimap::crbegin" ref="gab48e9b44197d1db572b77cc781f6aa96" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multimap, or <code>rend</code> if this multimap is empty. </p>

</div>
</div>
<a class="anchor" id="gaaad5c8bceb989a22d727fbcfeffb3d8d"></a><!-- doxytag: member="bsl::multimap::crend" ref="gaaad5c8bceb989a22d727fbcfeffb3d8d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this multimap. </p>

</div>
</div>
<a class="anchor" id="ga1bf9a278d113eb00c63792d72237f3b5"></a><!-- doxytag: member="bsl::multimap::empty" ref="ga1bf9a278d113eb00c63792d72237f3b5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this multimap contains no elements, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga6abffff8fcef3234b8b4152d0651e141"></a><!-- doxytag: member="bsl::multimap::size" ref="ga6abffff8fcef3234b8b4152d0651e141" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this multimap. </p>

</div>
</div>
<a class="anchor" id="ga6b6ddf88ef6da89acd5508a0c098bcb0"></a><!-- doxytag: member="bsl::multimap::max_size" ref="ga6b6ddf88ef6da89acd5508a0c098bcb0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that this multimap could possibly hold. Note that there is no guarantee that the multimap can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="gab0a289d5c15e831d88fe959dd4cfcb41"></a><!-- doxytag: member="bsl::multimap::key_comp" ref="gab0a289d5c15e831d88fe959dd4cfcb41" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">key_compare <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the key-comparison functor (or function pointer) used by this multimap; if a comparator was supplied at construction, return its value, otherwise return a default constructed <code>key_compare</code> object. Note that this comparator compares objects of type <code>KEY</code>, which is the key part of the <code>value_type</code> objects contained in this multimap. </p>

</div>
</div>
<a class="anchor" id="ga3a7ddd65ee1ab00b925909255df68e85"></a><!-- doxytag: member="bsl::multimap::value_comp" ref="ga3a7ddd65ee1ab00b925909255df68e85" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_compare <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a functor for comparing two <code>value_type</code> objects by comparing their respective keys using <code>key_comp()</code>. Note that this comparator compares objects of type <code>value_type</code> (i.e., <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;KEY, VALUE&gt;</code>). </p>

</div>
</div>
<a class="anchor" id="ga8d84de3ebe9fe12eeb5d7c791e8dd74b"></a><!-- doxytag: member="bsl::multimap::find" ref="ga8d84de3ebe9fe12eeb5d7c791e8dd74b" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object having the specified <code>key</code> in ordered sequence maintained by this multimap, if such an object exists; otherwise, return the past-the-end (<code>end</code>) iterator. </p>

</div>
</div>
<a class="anchor" id="gadf3c410ea2d36df8a944b0ab962bbdd4"></a><!-- doxytag: member="bsl::multimap::count" ref="gadf3c410ea2d36df8a944b0ab962bbdd4" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of <code>value_type</code> objects within this multimap having the specified <code>key</code>. </p>

</div>
</div>
<a class="anchor" id="gaa1d6e5f0835935d0e303ce0798bd7440"></a><!-- doxytag: member="bsl::multimap::lower_bound" ref="gaa1d6e5f0835935d0e303ce0798bd7440" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this multimap whose key is greater-than or equal-to the specified <code>key</code>, and the past-the-end iterator if this multimap does not contain a <code>value_type</code> object whose key is greater-than or equal-to <code>key</code>. Note that this function returns the <em>first</em> position before which a <code>value_type</code> object having <code>key</code> could be inserted into the ordered sequence maintained by this multimap, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga5ae39fe1fdb7c3a000378a51e5234d89"></a><!-- doxytag: member="bsl::multimap::upper_bound" ref="ga5ae39fe1fdb7c3a000378a51e5234d89" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this multimap whose key is greater than the specified <code>key</code>, and the past-the-end iterator if this multimap does not contain a <code>value_type</code> object whose key is greater-than <code>key</code>. Note that this function returns the <em>last</em> position before which a <code>value_type</code> object having <code>key</code> could be inserted into the ordered sequence maintained by this multimap, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga7d85487a916f1bd551e78438b9570c24"></a><!-- doxytag: member="bsl::multimap::equal_range" ref="ga7d85487a916f1bd551e78438b9570c24" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;const_iterator,const_iterator&gt; <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multimap.html#gad7afc1729b7c01609e6d7544e87a4286">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing non-modifiable access to the sequence of <code>value_type</code> objects in this multimap having the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. The first returned iterator will be <code>lower_bound(key)</code>; the second returned iterator will be <code>upper_bound(key)</code>; and, if this multimap contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. </p>

</div>
</div>
<a class="anchor" id="gae27bff9d448ee8c63a9171d2a395720b"></a><!-- doxytag: member="bsl::operator==" ref="gae27bff9d448ee8c63a9171d2a395720b" args="(const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code>multimap</code> objects have the same value if they have the same number of key-value pairs, and each key-value pair that is contained in one of the objects is also contained in the other object. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga4fc52a0082eb837264b9de4d1d92db60"></a><!-- doxytag: member="bsl::operator!=" ref="ga4fc52a0082eb837264b9de4d1d92db60" args="(const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code>multimap</code> objects do not have the same value if they do not have the same number of key-value pairs, or some key-value pair that is contained in one of the objects is not also contained in the other object. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> types both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac9b2f689b4da8f5b466377d30fe65d96"></a><!-- doxytag: member="bsl::operator&lt;" ref="gac9b2f689b4da8f5b466377d30fe65d96" args="(const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is less than the specified <code>rhs</code> value, and <code>false</code> otherwise. A multimap, <code>lhs</code>, has a value that is less than that of <code>rhs</code>, if, for the first non-equal corresponding key-value pairs in their respective sequences, the <code>lhs</code> key-value pair is less than the <code>rhs</code> pair, or, if the keys of all of their corresponding key-value pairs compare equal, <code>lhs</code> has fewer key-value pairs than <code>rhs</code>. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> types both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga94a2b9a893c655bcd903fd31f0ef14cb"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga94a2b9a893c655bcd903fd31f0ef14cb" args="(const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is greater than the specified <code>rhs</code> value, and <code>false</code> otherwise. A multimap, <code>lhs</code>, has a value that is greater than that of <code>rhs</code>, if, for the first non-equal corresponding key-value pairs in their respective sequences, the <code>lhs</code> key-value pair is greater than the <code>rhs</code> pair, or, if the keys of all of their corresponding key-value pairs compare equal, <code>lhs</code> has more key-value pairs than <code>rhs</code>. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga4efa7f5e34b40ac39190468e744f969a"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga4efa7f5e34b40ac39190468e744f969a" args="(const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is less-than or equal-to the specified <code>rhs</code> value, and <code>false</code> otherwise. A multimap, <code>lhs</code>, has a value that is less-than or equal-to that of <code>rhs</code>, if, for the first non-equal corresponding key-value pairs in their respective sequences, the <code>lhs</code> key-value pair is less than the <code>rhs</code> pair, or, if the keys of all of their corresponding key-value pairs compare equal, <code>lhs</code> has less-than or equal number of key-value pairs as <code>rhs</code>. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gad512a2f22b260bcb81daf71a51c63c37"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gad512a2f22b260bcb81daf71a51c63c37" args="(const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is greater-than or equal-to the specified <code>rhs</code> value, and <code>false</code> otherwise. A multimap, <code>lhs</code>, has a value that is greater-than or equal-to that of <code>rhs</code>, if, for the first non-equal corresponding key-value pairs in their respective sequences, the <code>lhs</code> key-value pair is greater than the <code>rhs</code> pair, or, if the keys of all of their corresponding key-value pairs compare equal, <code>lhs</code> has greater-than or equal number of key-value pairs as <code>rhs</code>. This method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> types both be <a href="group__bslstl__multimap.html#requirements_on_key_and_value.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__multimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga153c934515e350c6786edec5a81b7be5"></a><!-- doxytag: member="bsl::swap" ref="ga153c934515e350c6786edec5a81b7be5" args="(multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;a, multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">multimap&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap both the value and the comparator of the specified <code>a</code> object with the value and comparator of the specified <code>b</code> object. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of <code>a</code> with that of <code>b</code>, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees O[1] complexity. The behavior is undefined is unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga023433abc85bf2e4f3df3492f76351da"></a><!-- doxytag: member="bsl::multimap::value_compare::comp" ref="ga023433abc85bf2e4f3df3492f76351da" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">COMPARATOR <a class="el" href="classbsl_1_1multimap.html">bsl::multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::comp<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>we would not have elected to make this data </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:23 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
