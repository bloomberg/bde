<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_autodeallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_autodeallocator<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a range proctor to managed a block of memory.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirement</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a range proctor to managed a block of memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a> </td><td>range proctor to manage a block of memory  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__deallocatorguard.html" title="Provide a guard to unconditionally manage a block of memory.">Component bslma_deallocatorguard</a>, <a class="el" href="group__bslma__deallocatorproctor.html" title="Provide a proctor to conditionally manage a block memory.">Component bslma_deallocatorproctor</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a range proctor class template to manage a sequence of blocks of (otherwise-unmanaged) memory of parameterized <code>TYPE</code> supplied at construction. If not explicitly released, the sequence of managed memory blocks are deallocated automatically when the range proctor goes out of scope by freeing the memory using the parameterized <code>ALLOCATOR</code> (allocator or pool) supplied at construction. Note that after a range proctor releases its managed sequence of memory, the same proctor can be reused to conditionally manage another sequence of memory (allocated from the same allocator or pool that was supplied at construction) by invoking the <code>reset</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirement"></a> <a class="anchor" id="description.requirement"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirement: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The parameterized <code>ALLOCATOR</code> type of the <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code> class template must provide a (possibly <code>virtual</code>) method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
</pre></div><br/>
<br/>
 to deallocate memory at the specified <code>address</code> (originally supplied by the <code>ALLOCATOR</code> object). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a></code> proctor object can be used to achieve <em>exception</em> <em>safety</em> in an <em>exception</em> <em>neutral</em> way during manipulation of "out-of-place" arrays of raw resources or memory. Since there are no destructor calls, this component is more efficient compared to the <code><a class="el" href="classbslma_1_1AutoRawDeleter.html">bslma::AutoRawDeleter</a></code>. The following illustrates the insertion operation for an "out-of-place" array of raw character sequences. Assume that an array initially contains 5 character sequences as its elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">     0     1     2     3     4
   _____ _____ _____ _____ _____
  |  o  |  o  |  o  |  o  |  o  |
  `==|==^==|==^==|==^==|==^==|==<span class="stringliteral">&#39;</span>
<span class="stringliteral">     |    _V___  |   __V___  |</span>
<span class="stringliteral">     |   |&quot;Bye&quot;| |  |&quot;berg&quot;| |</span>
<span class="stringliteral">     |   `=====&#39;</span> |  `======<span class="stringliteral">&#39; |</span>
<span class="stringliteral">    _V_____     _V_____     _V__</span>
<span class="stringliteral">   |&quot;Hello&quot;|   |&quot;Bloom&quot;|   |&quot;LP&quot;|</span>
<span class="stringliteral">   `=======&#39;</span>   `=======<span class="stringliteral">&#39;   `====&#39;</span>
</pre></div><br/>
<br/>
 To insert two more character sequences at index position 2, the array is first reallocated if it is not big enough, and then the existing elements at index positions 2, 3, and 4 are shifted: <br/>
<br/>
<div class="fragment"><pre class="fragment">     0     1     2     3     4     5     6
   _____ _____ _____ _____ _____ _____ _____
  |  o  |  o  |xxxxx|xxxxx|  o  |  o  |  o  |
  `==|==^==|==^=====^=====^==|==^==|==^==|==<span class="stringliteral">&#39;</span>
<span class="stringliteral">     |    _V___              |   __V___  |</span>
<span class="stringliteral">     |   |&quot;Bye&quot;|             |  |&quot;berg&quot;| |</span>
<span class="stringliteral">     |   `=====&#39;</span>             |  `======<span class="stringliteral">&#39; |</span>
<span class="stringliteral">    _V_____                 _V_____     _V__</span>
<span class="stringliteral">   |&quot;Hello&quot;|               |&quot;Bloom&quot;|   |&quot;LP&quot;|</span>
<span class="stringliteral">   `=======&#39;</span>               `=======<span class="stringliteral">&#39;   `====&#39;</span>

  Note: <span class="stringliteral">&quot;xxxxx&quot;</span> denotes undefined value.
</pre></div><br/>
<br/>
 Next, two new memory blocks must be allocated to position 2 and 3. If, one of the two allocations fails and an exception is thrown, the array will be left in an invalid state because the addresses contained at index positions 2 and 3 may be duplicates of those at index positions 4 and 5, or, if a resize occurred, invalid altogether. We can restore exception neutrality by setting the array's length to 2 before attempting to create the string objects, but there is still a problem: the character sequences "Bloom", "berg", and "LP" (at index positions 4, 5, and 6) are "orphaned" and will never be deallocated -- a memory leak. To prevent this potential memory leak, we can additionally create a <code><a class="el" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a></code> object to manage (temporarily) the memory at index positions 4, 5, and 6 prior to allocating the new memory: <br/>
<br/>
<div class="fragment"><pre class="fragment">      0     1     2     3     4     5     6
    _____ _____ _____ _____ _____ _____ _____
   |  o  |  o  |xxxxx|xxxxx|  o  |  o  |  o  |
   `==|==^==|==^=====^=====^==|==^==|==^==|==<span class="stringliteral">&#39;</span>
<span class="stringliteral">      |    _V___              |   __V___  |</span>
<span class="stringliteral">      |   |&quot;Bye&quot;|             |  |&quot;berg&quot;| |</span>
<span class="stringliteral">      |   `=====&#39;</span>             |  `======<span class="stringliteral">&#39; |</span>
<span class="stringliteral">     _V_____                 _V_____     _V__</span>
<span class="stringliteral">    |&quot;Hello&quot;|               |&quot;Bloom&quot;|   |&quot;LP&quot;|</span>
<span class="stringliteral">    `=======&#39;</span>               `=======<span class="stringliteral">&#39;   `====&#39;</span>
   my_StrArray              ^---------------<a class="code" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a>
   (length = 2)                          (origin = 4, length = 3)

  Note: Configuration after initializing the proctor.
</pre></div><br/>
<br/>
 If an exception occurs, the array (now of length 2) is in a perfectly valid state, while the proctor is responsible for deallocating the orphaned memory at index positions 4, 5, and 6. If no exception is thrown, the length is set to 7 and the proctor's <code>release</code> method is called, releasing its control over the (temporarily) managed memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates the use of <code><a class="el" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a></code> to manage temporarily an "out-of-place" array of character sequences during the array's insertion operation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we define a <code>my_StrArray</code> class which stores an array of character sequences. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_strarray.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">class </span>my_StrArray {
      <span class="comment">// This class is a container that stores an array of character</span>
      <span class="comment">// sequences.  Memory will be supplied by the parameterized &#39;ALLOCATOR&#39;</span>
      <span class="comment">// type provided at construction (which must remain valid throughout</span>
      <span class="comment">// the lifetime of this guard object).  Note that memory is managed by</span>
      <span class="comment">// a parameterized &#39;ALLOCATOR&#39; type, instead of a &#39;bslma::Allocator&#39;, to</span>
      <span class="comment">// enable clients to pass in a pool (such as a sequential pool)</span>
      <span class="comment">// optimized for allocations of character sequences.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span>      **d_array_p;      <span class="comment">// dynamically allocated array of character</span>
                                  <span class="comment">// sequence</span>

      <span class="keywordtype">int</span>         d_length;       <span class="comment">// logical length of this array</span>

      <span class="keywordtype">int</span>         d_size;         <span class="comment">// physical capacity of this array</span>

      ALLOCATOR  *d_allocator_p;  <span class="comment">// allocator or pool (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_StrArray(ALLOCATOR *basicAllocator);
          <span class="comment">// Create a &#39;my_StrArray&#39; object using the specified</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.</span>

      ~my_StrArray();
          <span class="comment">// Destroy this &#39;my_StrArray&#39; object and all elements currently</span>
          <span class="comment">// stored.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> append(<span class="keyword">const</span> <span class="keywordtype">char</span> *src);
          <span class="comment">// Append to this array the string &#39;src&#39;.</span>

      <span class="keywordtype">void</span> insert(<span class="keywordtype">int</span> dstIndex, <span class="keyword">const</span> my_StrArray&amp; srcArray);
          <span class="comment">// Insert into this array at the specified &#39;dstIndex&#39;, the</span>
          <span class="comment">// character sequences in the specified &#39;srcArray&#39;.  All values</span>
          <span class="comment">// with initial indices at or above &#39;dstIndex&#39; are shifted up by</span>
          <span class="comment">// unless &#39;0 &lt;= dstIndex&#39; and &#39;dstIndex &lt;= length()&#39;.  Note that</span>
          <span class="comment">// this method is functionally the same as &#39;insert2&#39;, but has a</span>
          <span class="comment">// different implementation to facilitate the usage example.</span>

      <span class="keywordtype">void</span> insert2(<span class="keywordtype">int</span> dstIndex, <span class="keyword">const</span> my_StrArray&amp; srcArray);
          <span class="comment">// Insert into this array at the specified &#39;dstIndex&#39;, the</span>
          <span class="comment">// character sequences in the specified &#39;srcArray&#39;.  All values</span>
          <span class="comment">// with initial indices at or above &#39;dstIndex&#39; are shifted up by</span>
          <span class="comment">// unless &#39;0 &lt;= dstIndex&#39; and &#39;dstIndex &lt;= length()&#39;.  Note that</span>
          <span class="comment">// this method is functionally the same as &#39;insert&#39;, but has a</span>
          <span class="comment">// different implementation to facilitate the usage example.</span>

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> length() <span class="keyword">const</span>;
          <span class="comment">// Return the logical length of this array.</span>

      <span class="keyword">const</span> <span class="keywordtype">char</span> *operator[](<span class="keywordtype">int</span> index) <span class="keyword">const</span>;
          <span class="comment">// Return a pointer to the &#39;index&#39;th string in the array.  Note</span>
          <span class="comment">// the pointer is returned by value, it is not a reference to a</span>
          <span class="comment">// pointer.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Next, we define the <code>insert</code> method of <code>my_StrArray</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keywordtype">void</span> my_StrArray&lt;ALLOCATOR&gt;::insert(<span class="keywordtype">int</span>                           dstIndex,
                                      <span class="keyword">const</span> my_StrArray&lt;ALLOCATOR&gt;&amp; srcArray)
  {
      <span class="keywordtype">int</span> srcLength  = srcArray.d_length;
      <span class="keywordtype">int</span> newLength  = d_length + srcLength;
      <span class="keywordtype">int</span> numShifted = d_length - dstIndex;

      <span class="keywordflow">if</span> (newLength &gt; d_size) {
          <span class="keywordflow">while</span> (d_size &lt; newLength) {
              d_size = ! d_size ? 1 : 2 * d_size;
          }

          <span class="keywordtype">char</span> ** newArray =
                  (<span class="keywordtype">char</span> **) d_allocator_p-&gt;allocate(d_size * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
          memcpy(newArray, d_array_p, d_length * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
          <span class="keywordflow">if</span> (d_array_p) {
              d_allocator_p-&gt;deallocate(d_array_p);
          }
          d_array_p = newArray;
      }

      <span class="keywordtype">char</span> **tmpSrc = srcArray.d_array_p;
      <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;srcArray) {
          <span class="comment">// self-alias</span>
          <span class="keywordtype">int</span> size = srcLength * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *);
          tmpSrc = (<span class="keywordtype">char</span> **) d_allocator_p-&gt;allocate(size);
          memcpy(tmpSrc, d_array_p, size);
      }
      <a class="code" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor&lt;ALLOCATOR&gt;</a> proctor(
                                              <span class="keyword">this</span> == &amp;srcArray ? tmpSrc : 0,
                                              d_allocator_p);

      <span class="comment">// First shift the elements to the back of the array.</span>
      memmove(d_array_p + dstIndex + srcLength,
              d_array_p + dstIndex,
              numShifted * <span class="keyword">sizeof</span> *d_array_p);

      <span class="comment">// Shorten &#39;d_length&#39; and use &#39;bslma::AutoDeallocator&#39; to proctor the</span>
      <span class="comment">// memory shifted.</span>
      d_length = dstIndex;

      <span class="comment">//*******************************************************</span>
      <span class="comment">// Note use of auto deallocator on tail memory (below). *</span>
      <span class="comment">//*******************************************************</span>

      <a class="code" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator&lt;ALLOCATOR&gt;</a> tailDeallocator(
                                  (<span class="keywordtype">void</span> **) d_array_p + dstIndex + srcLength,
                                  d_allocator_p,
                                  numShifted);
</pre></div><br/>
<br/>
 Now, if any allocation for the inserted character sequences throws, the memory used for the character sequences that had been moved to the end of array will be deallocated automatically by the <code><a class="el" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// Copy the character sequences from the &#39;srcArray&#39;.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; srcLength; ++i, ++d_length) {
          std::size_t size = std::strlen(tmpSrc[i]) + 1;
          d_array_p[dstIndex + i] = (<span class="keywordtype">char</span> *) d_allocator_p-&gt;allocate(size);
          memcpy(d_array_p[dstIndex + i], tmpSrc[i], size);
      }

      <span class="comment">//*********************************************</span>
      <span class="comment">// Note that the proctor is released (below). *</span>
      <span class="comment">//*********************************************</span>

      tailDeallocator.release();
      d_length = newLength;
  }
</pre></div><br/>
<br/>
 The above method copies the source elements (visually) from left to right. Another (functionally equivalent) implementation copies the source elements from right to left, and makes use of the <code><a class="el" href="namespacebslstl.html#a7d3362e2ffdbd7358a6d1b82f3a52ca1">operator--()</a></code> of the <code><a class="el" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a></code> interface: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keywordtype">void</span> my_StrArray&lt;ALLOCATOR&gt;::insert2(<span class="keywordtype">int</span>                          dstIndex,
                                      <span class="keyword">const</span> my_StrArray&lt;ALLOCATOR&gt;&amp; srcArray)
  {
      <span class="keywordtype">int</span> srcLength  = srcArray.d_length;
      <span class="keywordtype">int</span> newLength  = d_length + srcLength;
      <span class="keywordtype">int</span> numShifted = d_length - dstIndex;

      <span class="keywordflow">if</span> (newLength &gt; d_size) {
          <span class="keywordflow">while</span> (d_size &lt; newLength) {
              d_size = ! d_size ? 1 : 2 * d_size;
          }

          <span class="keywordtype">char</span> ** newArray =
                  (<span class="keywordtype">char</span> **) d_allocator_p-&gt;allocate(d_size * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
          memcpy(newArray, d_array_p, d_length * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
          <span class="keywordflow">if</span> (d_array_p) {
              d_allocator_p-&gt;deallocate(d_array_p);
          }
          d_array_p = newArray;
      }

      <span class="keywordtype">char</span> **tmpSrc = srcArray.d_array_p;
      <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;srcArray) {
          <span class="comment">// self-alias</span>
          <span class="keywordtype">int</span> size = srcLength * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *);
          tmpSrc = (<span class="keywordtype">char</span> **) d_allocator_p-&gt;allocate(size);
          memcpy(tmpSrc, d_array_p, size);
      }
      <a class="code" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor&lt;ALLOCATOR&gt;</a> proctor(
                                              <span class="keyword">this</span> == &amp;srcArray ? tmpSrc : 0,
                                              d_allocator_p);

      <span class="comment">// First shift the elements to the back of the array.</span>
      memmove(d_array_p + dstIndex + srcLength,
              d_array_p + dstIndex,
              numShifted * <span class="keyword">sizeof</span> *d_array_p);

      <span class="comment">// Shorten &#39;d_length&#39; and use &#39;bslma::AutoDeallocator&#39; to proctor the</span>
      <span class="comment">// memory shifted.</span>
      d_length = dstIndex;

      <span class="comment">//********************************************</span>
      <span class="comment">//* Note the use of auto deallocator on tail *</span>
      <span class="comment">//* memory with negative length (below).     *</span>
      <span class="comment">//********************************************</span>

      <a class="code" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator&lt;ALLOCATOR&gt;</a> tailDeallocator(
                     (<span class="keywordtype">void</span> **) d_array_p + d_length + srcLength + numShifted,
                     d_allocator_p,
                     -numShifted);
</pre></div><br/>
<br/>
 Since we have decided to copy the source elements from right to left, we set the origin of the <code><a class="el" href="classbslma_1_1AutoDeallocator.html">bslma::AutoDeallocator</a></code> to the end of the array, and decrement the (signed) length on each copy to extend the proctor range by 1. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// Copy the character sequences from the &#39;srcArray&#39;.  Note that the</span>
      <span class="comment">// &#39;tailDeallocator&#39; has to be decremented to cover the newly</span>
      <span class="comment">// created object.</span>

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = srcLength - 1; i &gt;= 0; --i, --tailDeallocator) {
          std::size_t size = std::strlen(tmpSrc[i]) + 1;
          d_array_p[dstIndex + i] = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(size);
          memcpy(d_array_p[dstIndex + i], tmpSrc[i], size);
      }

      <span class="comment">//*********************************************</span>
      <span class="comment">// Note that the proctor is released (below). *</span>
      <span class="comment">//*********************************************</span>

      tailDeallocator.release();
      d_length = newLength;
  }
</pre></div><br/>
<br/>
 Note that though the two implementations are functionally equivalent, they are logically different. First of all, the second implementation will be slightly slower because it is accessing memory backwards when compared to the normal forward sequential access. Secondly, in case of an exception, the first implementation will retain all the elements copied prior to the exception, whereas the second implementation will remove them. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
