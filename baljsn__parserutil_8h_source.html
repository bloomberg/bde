<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// baljsn_parserutil.h                                                -*-C++-*-
#ifndef INCLUDED_BALJSN_PARSERUTIL
#define INCLUDED_BALJSN_PARSERUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a utility for decoding JSON data into simple types.
//
//@CLASSES:
//  baljsn::ParserUtil: utility for parsing JSON data into simple types
//
//@SEE_ALSO: baljsn_decoder, baljsn_printutil
//
//@DESCRIPTION: This component provides a &#39;struct&#39; of utility functions,
// &#39;baljsn::ParserUtil&#39;, for decoding data in the JSON format into a &#39;bdeat&#39;
// Simple type.  The primary method is &#39;getValue&#39;, which decodes into a
// specified object and is overloaded for all &#39;bdeat&#39; Simple types.  The
// following table describes the format in which various Simple types are
// decoded.
//..
//  Simple Type          JSON Type  Notes
//  -----------          ---------  -----
//  char                 number
//  unsigned char        number
//  int                  number
//  unsigned int         number
//  bsls::Types::Int64   number
//  bsls::Types::Uint64  number
//  float                number
//  double               number
//  char *               string
//  bsl::string          string
//  bdlt::Date            string     ISO 8601 format
//  bdlt::DateTz          string     ISO 8601 format
//  bdlt::Time            string     ISO 8601 format
//  bdlt::TimeTz          string     ISO 8601 format
//  bdlt::DatetimeTz      string     ISO 8601 format
//  bdlt::DatetimeTz      string     ISO 8601 format
//..
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Decoding into a Simple &#39;struct&#39; from JSON data
///---------------------------------------------------------
// Suppose we want to de-serialize some JSON data into an object.
//
// First, we define a struct, &#39;Employee&#39;, to contain the data:
//..
//  struct Employee {
//      bsl::string d_name;
//      bdlt::Date   d_date;
//      int         d_age;
//  };
//..
// Then, we create an &#39;Employee&#39; object:
//..
//  Employee employee;
//..
// Next, we specify the string values in JSON format used to represent the
// object data.  Note that the birth date is specified in the ISO 8601 format:
//..
//  const char *name = &quot;\&quot;John Smith\&quot;&quot;;
//  const char *date = &quot;\&quot;1985-06-24\&quot;&quot;;
//  const char *age  = &quot;21&quot;;
//
//  bslstl::StringRef nameRef(name);
//  bslstl::StringRef dateRef(date);
//  bslstl::StringRef ageRef(age);
//..
// Now, we use the created string refs to populate the employee object:
//..
//  assert(0 == baljsn::ParserUtil::getValue(&amp;employee.d_name, nameRef));
//  assert(0 == baljsn::ParserUtil::getValue(&amp;employee.d_date, dateRef));
//  assert(0 == baljsn::ParserUtil::getValue(&amp;employee.d_age, ageRef));
//..
// Finally, we will verify that the values are as expected:
//..
//  assert(&quot;John Smith&quot;            == employee.d_name);
//  assert(bdlt::Date(1985, 06, 24) == employee.d_date);
//  assert(21                      == employee.d_age);
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLT_ISO8601UTIL
#include &lt;bdlt_iso8601util.h&gt;
#endif

#ifndef INCLUDED_BSL_LIMITS
#include &lt;bsl_limits.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BDLDFP_DECIMAL
#include &lt;bdldfp_decimal.h&gt;
#endif

namespace BloombergLP {
namespace baljsn {

                             // =================
                             // struct ParserUtil
                             // =================

struct ParserUtil {
    //This class provides utility functions for decoding data in the JSON
    //format into a &#39;bdeat&#39; Simple type.  The primary method is &#39;getValue&#39;,
    //which decodes into a specified object and is overloaded for all &#39;bdeat&#39;
    //Simple types.

  private:
    // PRIVATE CLASS METHODS
    template &lt;class TYPE&gt;
    static int getDateAndTimeValue(TYPE              *value,
                                   bslstl::StringRef  data,
                                   int                maxLength);
        // Load into the specified &#39;value&#39; the date or time value represented
        // as a string in the ISO 8601 format in the specified &#39;data&#39; and
        // having a maximum data length of the specified &#39;maxLength&#39;.  Return 0
        // on success and a non-zero value otherwise.  Note that an error is
        // returned if &#39;data.length() &gt; maxLength&#39;.  Also note that &#39;TYPE&#39; is
        // expected to be one of &#39;bdlt::Date&#39;, &#39;bdlt::Time&#39;, bdlt::Datetime&#39;,
        // &#39;bdlt::DateTz&#39;, &#39;bdlt::TimeTz&#39;, or &#39;bdlt::DatetimeTz&#39;.

    template &lt;class TYPE&gt;
    static int getIntegralValue(TYPE *value, bslstl::StringRef data);
        // Load into the specified &#39;value&#39; the integer value in the specified
        // &#39;data&#39;.  Return 0 on success and a non-zero value otherwise.  Note
        // that &#39;TYPE&#39; is expected to be a *signed* integral type.

    template &lt;class TYPE&gt;
    static int getUnsignedIntegralValue(TYPE *value, bslstl::StringRef data);
        // Load into the specified &#39;value&#39; the unsigned integer value in the
        // specified &#39;data&#39;.  Return 0 on success and a non-zero value
        // otherwise.  Note that &#39;TYPE&#39; is expected to be a *unsigned* integral
        // type.

    static int getUint64(bsls::Types::Uint64 *value, bslstl::StringRef data);
        // Load into the specified &#39;value&#39; the value in the specified &#39;data&#39;.
        // Return 0 on success and a non-zero value otherwise.

    static int getString(bsl::string *value, bslstl::StringRef data);
        // Load into the specified &#39;value&#39; the string value in the specified
        // &#39;data&#39;.  Return 0 on success and a non-zero value otherwise.

  public:
    // CLASS METHODS
    static int getValue(bool                *value, bslstl::StringRef data);
    static int getValue(char                *value, bslstl::StringRef data);
    static int getValue(unsigned char       *value, bslstl::StringRef data);
    static int getValue(signed char         *value, bslstl::StringRef data);
    static int getValue(short               *value, bslstl::StringRef data);
    static int getValue(unsigned short      *value, bslstl::StringRef data);
    static int getValue(int                 *value, bslstl::StringRef data);
    static int getValue(unsigned int        *value, bslstl::StringRef data);
    static int getValue(bsls::Types::Int64  *value, bslstl::StringRef data);
    static int getValue(bsls::Types::Uint64 *value, bslstl::StringRef data);
    static int getValue(float               *value, bslstl::StringRef data);
    static int getValue(double              *value, bslstl::StringRef data);
    static int getValue(bdldfp::Decimal64   *value, bslstl::StringRef data);
    static int getValue(bsl::string         *value, bslstl::StringRef data);
    static int getValue(bdlt::Date          *value, bslstl::StringRef data);
    static int getValue(bdlt::Datetime      *value, bslstl::StringRef data);
    static int getValue(bdlt::DatetimeTz    *value, bslstl::StringRef data);
    static int getValue(bdlt::DateTz        *value, bslstl::StringRef data);
    static int getValue(bdlt::Time          *value, bslstl::StringRef data);
    static int getValue(bdlt::TimeTz        *value, bslstl::StringRef data);
    static int getValue(bsl::vector&lt;char&gt;   *value, bslstl::StringRef data);
        // Load into the specified &#39;value&#39; the characters read from the
        // specified &#39;data&#39;.  Return 0 on success or a non-zero value on
        // failure.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                             // -----------------
                             // struct ParserUtil
                             // -----------------

// CLASS METHODS
template &lt;class TYPE&gt;
int ParserUtil::getUnsignedIntegralValue(TYPE *value, bslstl::StringRef data)
{
    if (0 == data.length()) {
        return -1;                                                    // RETURN
    }

    bsls::Types::Uint64 tmp;
    int rc = getUint64(&amp;tmp, data);
    if (rc) {
        return -1;                                                    // RETURN
    }

    if (tmp &gt;
          static_cast&lt;bsls::Types::Uint64&gt;(bsl::numeric_limits&lt;TYPE&gt;::max())) {
        return -1;                                                    // RETURN
    }

    *value = static_cast&lt;TYPE&gt;(tmp);
    return 0;
}

template &lt;class TYPE&gt;
int ParserUtil::getIntegralValue(TYPE *value, bslstl::StringRef data)
{
    if (0 == data.length()) {
        return -1;                                                    // RETURN
    }

    bool isNegative;
    if (&#39;-&#39; == data[0]) {
        isNegative = true;
        data.assign(data.begin() + 1, data.end());
    }
    else {
        isNegative = false;
    }

    bsls::Types::Uint64 tmp;
    const int rc = getUint64(&amp;tmp, data);
    if (rc) {
        return -1;                                                    // RETURN
    }

    bsls::Types::Uint64 maxValue = static_cast&lt;bsls::Types::Uint64&gt;(
                                             bsl::numeric_limits&lt;TYPE&gt;::max());

    if (isNegative &amp;&amp; tmp &lt;= maxValue + 1) {
        *value = static_cast&lt;TYPE&gt;(tmp * -1);
    }
    else if (tmp &lt;= maxValue) {
        *value = static_cast&lt;TYPE&gt;(tmp);
    }
    else {
        return -1;                                                    // RETURN
    }

    return 0;
}

template &lt;class TYPE&gt;
int ParserUtil::getDateAndTimeValue(TYPE              *value,
                                    bslstl::StringRef  data,
                                    int                maxLength)
{
    enum { k_STRING_LENGTH_WITH_QUOTES = 2 };

    if (data.length()  &lt; k_STRING_LENGTH_WITH_QUOTES
     || &#39;&quot;&#39;           != *data.begin()
     || &#39;&quot;&#39;           != *(data.end() - 1)
     || data.length()  &gt; static_cast&lt;unsigned int&gt;(maxLength)
                                          + k_STRING_LENGTH_WITH_QUOTES) {
        return -1;                                                    // RETURN
    }

    return bdlt::Iso8601Util::parse(
           value,
           data.data() + 1,
           static_cast&lt;int&gt;(data.length() - k_STRING_LENGTH_WITH_QUOTES));
}

inline
int ParserUtil::getValue(char *value, bslstl::StringRef data)
{
    signed char tmp;  // Note that &#39;char&#39; is unsigned on IBM.

    const int rc = getIntegralValue(&amp;tmp, data);
    if (!rc) {
        *value = tmp;
    }
    return rc;
}

inline
int ParserUtil::getValue(unsigned char *value, bslstl::StringRef data)
{
    return getUnsignedIntegralValue(value, data);
}

inline
int ParserUtil::getValue(signed char *value, bslstl::StringRef data)
{
    return getValue((char *) value, data);
}

inline
int ParserUtil::getValue(short *value, bslstl::StringRef data)
{
    return getIntegralValue(value, data);
}

inline
int ParserUtil::getValue(unsigned short *value, bslstl::StringRef data)
{
    return getUnsignedIntegralValue(value, data);
}

inline
int ParserUtil::getValue(int *value, bslstl::StringRef data)
{
    return getIntegralValue(value, data);
}

inline
int ParserUtil::getValue(unsigned int *value, bslstl::StringRef data)
{
    return getUnsignedIntegralValue(value, data);
}

inline
int ParserUtil::getValue(bsls::Types::Int64 *value, bslstl::StringRef data)
{
    return getIntegralValue(value, data);
}

inline
int ParserUtil::getValue(bsls::Types::Uint64 *value, bslstl::StringRef data)
{
    return getUnsignedIntegralValue(value, data);
}

inline
int ParserUtil::getValue(float *value, bslstl::StringRef data)
{
    double tmp;
    const int rc = getValue(&amp;tmp, data);
    if (!rc) {
        *value = static_cast&lt;float&gt;(tmp);
    }
    return rc;
}

inline
int ParserUtil::getValue(bsl::string *value, bslstl::StringRef data)
{
    return getString(value, data);
}

inline
int ParserUtil::getValue(bdlt::Date *value, bslstl::StringRef data)
{
    return getDateAndTimeValue(value, data, bdlt::Iso8601Util::k_DATE_STRLEN);
}

inline
int ParserUtil::getValue(bdlt::Datetime *value, bslstl::StringRef data)
{
    return getDateAndTimeValue(value,
                               data,
                               bdlt::Iso8601Util::k_DATETIME_STRLEN);
}

inline
int ParserUtil::getValue(bdlt::DatetimeTz *value, bslstl::StringRef data)
{
    return getDateAndTimeValue(value,
                               data,
                               bdlt::Iso8601Util::k_DATETIMETZ_STRLEN);
}

inline
int ParserUtil::getValue(bdlt::DateTz *value, bslstl::StringRef data)
{
    return getDateAndTimeValue(value,
                               data,
                               bdlt::Iso8601Util::k_DATETZ_STRLEN);
}

inline
int ParserUtil::getValue(bdlt::Time *value, bslstl::StringRef data)
{
    return getDateAndTimeValue(value, data, bdlt::Iso8601Util::k_TIME_STRLEN);
}

inline
int ParserUtil::getValue(bdlt::TimeTz *value, bslstl::StringRef data)
{
    return getDateAndTimeValue(value,
                               data,
                               bdlt::Iso8601Util::k_TIMETZ_STRLEN);
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
