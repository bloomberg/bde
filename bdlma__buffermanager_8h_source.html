<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlma_buffermanager.h                                              -*-C++-*-
#ifndef INCLUDED_BDLMA_BUFFERMANAGER
#define INCLUDED_BDLMA_BUFFERMANAGER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a memory manager that manages an external buffer.
//
//@CLASSES:
//  bdlma::BufferManager: memory manager that manages an external buffer
//
//@SEE_ALSO: bdlma_bufferimputil, bdlma_bufferedsequentialallocator
//
//@DESCRIPTION: This component provides a memory manager (&quot;buffer manager&quot;),
// &#39;bdlma::BufferManager&#39;, that dispenses heterogeneous memory blocks (of
// varying, user-specified sizes) from an external buffer.  A &#39;BufferManager&#39;
// has a similar interface to a sequential pool in that the two methods
// &#39;allocate&#39; and &#39;release&#39; are provided.
//
// In addition to the &#39;allocate&#39; method, a less safe but faster variation,
// &#39;allocateRaw&#39;, is provided to support memory allocation: If there is
// insufficient memory remaining in the buffer to satisfy an allocation
// request, &#39;allocate&#39; will return 0 while &#39;allocateRaw&#39; will result in
// undefined behavior.
//
// The behavior of &#39;allocate&#39; and &#39;allocateRaw&#39; illustrates the main difference
// between this buffer manager and a sequential pool.  Once the external buffer
// runs out of memory, the buffer manager does not self-replenish, whereas a
// sequential pool will do so.
//
// The &#39;release&#39; method resets the buffer manager such that the memory within
// the entire external buffer will be made available for subsequent
// allocations.  Note that individually allocated memory blocks cannot be
// separately deallocated.
//
// &#39;bdlma::BufferManager&#39; is typically used for fast and efficient memory
// allocation, when the user knows in advance the maximum amount of memory
// needed.
//
///Usage
///-----
// Suppose that we need to detect whether there are at least &#39;n&#39; duplicates
// within an array of integers.  Furthermore, suppose that speed is a concern
// and we need the fastest possible implementation.  A natural solution will be
// to use a hash table.  To further optimize for speed, we can use a custom
// memory manager, such as &#39;bdlma::BufferManager&#39;, to speed up memory
// allocations.
//
// First, let&#39;s define the structure of a node inside our custom hash table
// structure:
//..
//  struct my_Node {
//      // This struct represents a node within a hash table.
//
//      // DATA
//      int      d_value;   // integer value this node holds
//      int      d_count;   // number of occurrences of this integer value
//      my_Node *d_next_p;  // pointer to the next node
//
//      // CREATORS
//      my_Node(int value, my_Node *next);
//          // Create a node having the specified &#39;value&#39; that refers to the
//          // specified &#39;next&#39; node.
//  };
//
//  // CREATORS
//  my_Node::my_Node(int value, my_Node *next)
//  : d_value(value)
//  , d_count(1)
//  , d_next_p(next)
//  {
//  }
//..
// Note that &#39;sizeof(my_Node) == 12&#39; when compiled in 32-bit mode, and
// &#39;sizeof(my_Node) == 16&#39; when compiled in 64-bit mode.  This difference
// affects the amount of memory used under different alignment strategies (see
// &#39;bsls_alignment&#39; for more details on alignment strategies).
//
// We can then define the structure of our specialized hash table used for
// integer counting:
//..
//  class my_IntegerCountingHashTable {
//      // This class represents a hash table that is used to keep track of the
//      // number of occurrences of various integers.  Note that this is a
//      // highly specialized class that uses a &#39;bdlma::BufferManager&#39; with
//      // sufficient memory for memory allocations.
//
//      // DATA
//      my_Node              **d_nodeArray;  // array of &#39;my_Node&#39; pointers
//
//      int                    d_size;       // size of the node array
//
//      bdlma::BufferManager  *d_buffer;     // buffer manager (held, not
//                                           // owned)
//
//    public:
//      // CLASS METHODS
//      static int calculateBufferSize(int tableLength, int numNodes);
//          // Return the memory required by a &#39;my_IntegerCountingHashTable&#39;
//          // that has the specified &#39;tableLength&#39; and &#39;numNodes&#39;.
//
//      // CREATORS
//      my_IntegerCountingHashTable(int size, bdlma::BufferManager *buffer);
//          // Create a hash table of the specified &#39;size&#39;, using the specified
//          // &#39;buffer&#39; to supply memory.  The behavior is undefined unless
//          // &#39;0 &lt; size&#39;, &#39;buffer&#39; is non-zero, and &#39;buffer&#39; has sufficient
//          // memory to support all memory allocations required.
//
//      // ...
//
//      // MANIPULATORS
//      int insert(int value);
//          // Insert the specified &#39;value&#39; with a count of 1 into this hash
//          // table if &#39;value&#39; does not currently exist in the hash table, and
//          // increment the count for &#39;value&#39; otherwise.  Return the number of
//          // occurrences of &#39;value&#39; in this hash table.
//
//      // ...
//  };
//..
// The implementation of the rest of &#39;my_IntegerCountingHashTable&#39; is elided as
// the class method &#39;calculateBufferSize&#39;, constructor, and the &#39;insert&#39; method
// alone are sufficient to illustrate the use of &#39;bdlma::BufferManager&#39;:
//..
//  // CLASS METHODS
//  int my_IntegerCountingHashTable::calculateBufferSize(int tableLength,
//                                                       int numNodes)
//  {
//      return tableLength * sizeof(my_Node *) + numNodes * sizeof(my_Node)
//                                   + bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT;
//  }
//..
// Note that, in case the allocated buffer is not aligned, the size calculation
// includes a &quot;fudge&quot; factor equivalent to the maximum alignment requirement of
// the platform.
//..
//  // CREATORS
//  my_IntegerCountingHashTable::my_IntegerCountingHashTable(
//                                                int                   size,
//                                                bdlma::BufferManager *buffer)
//  : d_size(size)
//  , d_buffer(buffer)
//  {
//      // &#39;d_buffer&#39; must have sufficient memory to satisfy the allocation
//      // request (as specified by the constructor&#39;s contract).
//
//      d_nodeArray = static_cast&lt;my_Node **&gt;(
//                             d_buffer-&gt;allocate(d_size * sizeof(my_Node *)));
//
//      bsl::memset(d_nodeArray, 0, d_size * sizeof(my_Node *));
//  }
//
//  // MANIPULATORS
//  int my_IntegerCountingHashTable::insert(int value)
//  {
//      // Naive hash function using only mod.
//
//      const int hashValue = value % d_size;
//      my_Node **tmp       = &amp;d_nodeArray[hashValue];
//
//      while (*tmp) {
//          if ((*tmp)-&gt;d_value != value) {
//              tmp = &amp;((*tmp)-&gt;d_next_p);
//          }
//          else {
//              return ++((*tmp)-&gt;d_count);
//          }
//      }
//
//      // &#39;allocate&#39; does not trigger dynamic memory allocation.  Therefore,
//      // we don&#39;t have to worry about exceptions and can use placement &#39;new&#39;
//      // directly with &#39;allocate&#39;.  &#39;d_buffer&#39; must have sufficient memory to
//      // satisfy the allocation request (as specified by the constructor&#39;s
//      // contract).
//
//      *tmp = new(d_buffer-&gt;allocate(sizeof(my_Node))) my_Node(value, *tmp);
//
//      return 1;
//  }
//..
// Note that &#39;bdlma::BufferManager&#39; is used to allocate memory blocks of
// heterogeneous sizes.  In the constructor, memory is allocated for the node
// array.  In &#39;insert&#39;, memory is allocated for the nodes.
//
// Finally, in the following &#39;detectNOccurrences&#39; function, we can use the hash
// table class to detect whether any integer value occurs at least &#39;n&#39; times
// within a specified array:
//..
//  bool detectNOccurrences(int n, const int *array, int length)
//      // Return &#39;true&#39; if any integer value in the specified &#39;array&#39; having
//      // the specified &#39;length&#39; appears at least the specified &#39;n&#39; times, and
//      // &#39;false&#39; otherwise.
//  {
//      const int MAX_SIZE = my_IntegerCountingHashTable::
//                                         calculateBufferSize(length, length);
//..
//
// We then allocate an external buffer to be used by &#39;bdlma::BufferManager&#39;.
// Normally, this buffer will be created on the program stack if we know the
// length in advance (for example, if we specify in the contract of this
// function that we only handle arrays having a length of up to 10,000
// integers).  However, to make this function more general, we decide to
// allocate the memory dynamically.  This approach is still much more efficient
// than using the default allocator, say, to allocate memory for individual
// nodes within &#39;insert&#39;, since we need only a single dynamic allocation,
// versus separate dynamic allocations for every single node:
//..
//      bslma::Allocator *allocator = bslma::Default::defaultAllocator();
//      char *buffer = static_cast&lt;char *&gt;(allocator-&gt;allocate(MAX_SIZE));
//..
// We use a &#39;bslma::DeallocatorGuard&#39; to automatically deallocate the buffer
// when the function ends:
//..
//      bslma::DeallocatorGuard&lt;bslma::Allocator&gt; guard(buffer, allocator);
//
//      bdlma::BufferManager bufferManager(buffer, MAX_SIZE);
//      my_IntegerCountingHashTable table(length, &amp;bufferManager);
//
//      while (--length &gt;= 0) {
//          if (n == table.insert(array[length])) {
//              return true;                                          // RETURN
//          }
//      }
//
//      return false;
//  }
//..
// Note that the calculation of &#39;MAX_SIZE&#39; assumes natural alignment.  If
// maximum alignment is used instead, a larger buffer is needed since each node
// object will then be maximally aligned, which takes up 16 bytes each instead
// of 12 bytes on a 32-bit architecture.  On a 64-bit architecture, there will
// be no savings using natural alignment since the size of a node will be 16
// bytes regardless.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENT
#include &lt;bsls_alignment.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                        // ===================
                        // class BufferManager
                        // ===================

class BufferManager {
    // This class implements a buffer manager that dispenses heterogeneous
    // blocks of memory (of varying, user-specified sizes) from an external
    // buffer whose address and size are optionally supplied at construction.
    // If an allocation request exceeds the remaining free memory space in the
    // external buffer, the allocation request returns 0 if &#39;allocate&#39; is used,
    // or results in undefined behavior if &#39;allocateRaw&#39; is used.  Note that in
    // no event will the buffer manager attempt to deallocate the external
    // buffer.

    // DATA
    char   *d_buffer_p;    // external buffer (held, not owned)

    int     d_bufferSize;  // size (in bytes) of external buffer

    int     d_cursor;      // offset to next available byte in buffer

    void *(*d_allocate_p)(int *, char *, int, int);
                           // address of non-raw &#39;Alignment::Strategy&#39;-specific
                           // method from &#39;bdlma::BufferImpUtil&#39;

    void *(*d_allocateRaw_p)(int *, char *, int);
                           // address of raw &#39;Alignment::Strategy&#39;-specific
                           // method from &#39;bdlma::BufferImpUtil&#39;

  private:
    // NOT IMPLEMENTED
    BufferManager(const BufferManager&amp;);
    BufferManager&amp; operator=(const BufferManager&amp;);

  private:
    // PRIVATE MANIPULATORS
    void init(bsls::Alignment::Strategy strategy);
        // Initialize this object to use the specified alignment &#39;strategy&#39;.

  public:
    // CREATORS
    explicit
    BufferManager(bsls::Alignment::Strategy strategy =
                                                bsls::Alignment::BSLS_NATURAL);
        // Create a buffer manager for allocating memory blocks.  Optionally
        // specify an alignment &#39;strategy&#39; used to align allocated memory
        // blocks.  If &#39;strategy&#39; is not specified, natural alignment is used.
        // A default constructed buffer manager is unable to allocate any
        // memory until an external buffer is provided by calling the
        // &#39;replaceBuffer&#39; method.

    BufferManager(char                      *buffer,
                  int                        bufferSize,
                  bsls::Alignment::Strategy  strategy
                                              = bsls::Alignment::BSLS_NATURAL);
        // Create a buffer manager for allocating memory blocks from the
        // specified external &#39;buffer&#39; having the specified &#39;bufferSize&#39; (in
        // bytes).  Optionally specify an alignment &#39;strategy&#39; used to align
        // allocated memory blocks.  If &#39;strategy&#39; is not specified, natural
        // alignment is used.  The behavior is undefined unless
        // &#39;0 &lt; bufferSize&#39; and &#39;buffer&#39; has at least &#39;bufferSize&#39; bytes.

    ~BufferManager();
        // Destroy this buffer manager.

    // MANIPULATORS
    void *allocate(bsls::Types::size_type size);
        // Return the address of a contiguous block of memory of the specified
        // &#39;size&#39; (in bytes) on success, according to the alignment strategy
        // specified at construction, and 0 if the allocation request
        // exceeds the remaining free memory space in the external buffer.  The
        // behavior is undefined unless &#39;0 &lt; size&#39; and this object is currently
        // managing a buffer.

    void *allocateRaw(int size);
        // Return the address of a contiguous block of memory of the specified
        // &#39;size&#39; (in bytes) according to the alignment strategy specified at
        // construction.  The behavior is undefined unless the allocation
        // request does not exceed the remaining free memory space in the
        // external buffer, &#39;0 &lt; size&#39;, and this object is currently managing
        // a buffer.

    template &lt;class TYPE&gt;
    void deleteObjectRaw(const TYPE *object);
        // Destroy the specified &#39;object&#39;.  Note that memory associated with
        // &#39;object&#39; is not deallocated because there is no &#39;deallocate&#39; method
        // in &#39;BufferManager&#39;.

    template &lt;class TYPE&gt;
    void deleteObject(const TYPE *object);
        // Destroy the specified &#39;object&#39;.  Note that this method has the same
        // effect as the &#39;deleteObjectRaw&#39; method (since no deallocation is
        // involved), and exists for consistency with a pool interface.

    int expand(void *address, int size);
        // Increase the amount of memory allocated at the specified &#39;address&#39;
        // from the original &#39;size&#39; (in bytes) to also include the maximum
        // amount remaining in the buffer.  Return the amount of memory
        // available at &#39;address&#39; after expanding, or &#39;size&#39; if the memory at
        // &#39;address&#39; cannot be expanded.  This method can only &#39;expand&#39; the
        // memory block returned by the most recent &#39;allocate&#39; or &#39;allocateRaw&#39;
        // request from this buffer manager, and otherwise has no effect.  The
        // behavior is undefined unless the memory at &#39;address&#39; was originally
        // allocated by this buffer manager, the size of the memory at
        // &#39;address&#39; is &#39;size&#39;, and &#39;release&#39; was not called after allocating
        // the memory at &#39;address&#39;.

    char *replaceBuffer(char *newBuffer, int newBufferSize);
        // Replace the buffer currently managed by this object with the
        // specified &#39;newBuffer&#39; of the specified &#39;newBufferSize&#39; (in bytes);
        // return the address of the previously held buffer, or 0 if this
        // object currently manages no buffer.  The replaced buffer (if any)
        // is removed from the management of this object with no effect on the
        // outstanding allocated memory blocks.  Subsequent allocations will
        // allocate memory from the beginning of the new external buffer.  The
        // behavior is undefined unless &#39;0 &lt; newBufferSize&#39; and &#39;newBuffer&#39; has
        // at least &#39;newBufferSize&#39; bytes.

    void release();
        // Release all memory currently allocated through this buffer manager.
        // After this call, the external buffer managed by this object is
        // retained.  Subsequent allocations will allocate memory from the
        // beginning of the external buffer (if any).

    void reset();
        // Reset this buffer manager to its default constructed state, except
        // retain the alignment strategy in effect at the time of construction.
        // The currently managed buffer (if any) is removed from the management
        // of this object with no effect on the outstanding allocated memory
        // blocks.

    int truncate(void *address, int originalSize, int newSize);
        // Reduce the amount of memory allocated at the specified &#39;address&#39;
        // of the specified &#39;originalSize&#39; (in bytes) to the specified
        // &#39;newSize&#39; (in bytes).  Return &#39;newSize&#39; after truncating, or
        // &#39;originalSize&#39; if the memory at &#39;address&#39; cannot be truncated.  This
        // method can only &#39;truncate&#39; the memory block returned by the most
        // recent &#39;allocate&#39; or &#39;allocateRaw&#39; request from this object, and
        // otherwise has no effect.  The behavior is undefined unless the
        // memory at &#39;address&#39; was originally allocated by this buffer manager,
        // the size of the memory at &#39;address&#39; is &#39;originalSize&#39;,
        // &#39;newSize &lt;= originalSize&#39;, &#39;0 &lt;= newSize&#39;, and &#39;release&#39; was not
        // called after allocating the memory at &#39;address&#39;.

    // ACCESSORS
    char *buffer() const;
        // Return an address providing modifiable access to the buffer
        // currently managed by this object, or 0 if this object currently
        // manages no buffer.

    int bufferSize() const;
        // Return the size (in bytes) of the buffer currently managed by this
        // object, or 0 if this object currently manages no buffer.

    bool hasSufficientCapacity(int size) const;
        // Return &#39;true&#39; if there is sufficient memory space in the buffer to
        // allocate a contiguous memory block of the specified &#39;size&#39; (in
        // bytes) after taking the alignment strategy into consideration, and
        // &#39;false&#39; otherwise.  The behavior is undefined unless &#39;0 &lt; size&#39;, and
        // this object is currently managing a buffer.
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // ------------
                        // class Buffer
                        // ------------

// CREATORS
inline
BufferManager::BufferManager(bsls::Alignment::Strategy strategy)
: d_buffer_p(0)
, d_bufferSize(0)
, d_cursor(0)
{
    init(strategy);
}

inline
BufferManager::BufferManager(char                      *buffer,
                             int                        bufferSize,
                             bsls::Alignment::Strategy  strategy)
: d_buffer_p(buffer)
, d_bufferSize(bufferSize)
, d_cursor(0)
{
    BSLS_ASSERT_SAFE(buffer);
    BSLS_ASSERT_SAFE(0 &lt; bufferSize);

    init(strategy);
}

inline
BufferManager::~BufferManager()
{
    BSLS_ASSERT_SAFE(0 &lt;= d_cursor);
    BSLS_ASSERT_SAFE(d_cursor &lt;= d_bufferSize);
    BSLS_ASSERT_SAFE((0 != d_buffer_p &amp;&amp; 0 &lt;  d_bufferSize)
                  || (0 == d_buffer_p &amp;&amp; 0 == d_bufferSize));
}

// MANIPULATORS
inline
void *BufferManager::allocate(bsls::Types::size_type size)
{
    BSLS_ASSERT_SAFE(0 &lt; size);
    BSLS_ASSERT_SAFE(d_buffer_p);
    BSLS_ASSERT_SAFE(0 &lt;= d_cursor);
    BSLS_ASSERT_SAFE(d_cursor &lt;= d_bufferSize);

    return (*d_allocate_p)(&amp;d_cursor,
                           d_buffer_p,
                           d_bufferSize,
                           static_cast&lt;int&gt;(size));
}

inline
void *BufferManager::allocateRaw(int size)
{
    BSLS_ASSERT_SAFE(0 &lt; size);
    BSLS_ASSERT_SAFE(d_buffer_p);
    BSLS_ASSERT_SAFE(0 &lt;= d_cursor);
    BSLS_ASSERT_SAFE(d_cursor &lt;= d_bufferSize);

    return (*d_allocateRaw_p)(&amp;d_cursor, d_buffer_p, size);
}

template &lt;class TYPE&gt;
inline
void BufferManager::deleteObjectRaw(const TYPE *object)
{
    if (0 != object) {
#ifndef BSLS_PLATFORM_CMP_SUN
        object-&gt;~TYPE();
#else
        const_cast&lt;TYPE *&gt;(object)-&gt;~TYPE();
#endif
    }
}

template &lt;class TYPE&gt;
inline
void BufferManager::deleteObject(const TYPE *object)
{
    deleteObjectRaw(object);
}

inline
char *BufferManager::replaceBuffer(char *newBuffer, int newBufferSize)
{
    BSLS_ASSERT_SAFE(newBuffer);
    BSLS_ASSERT_SAFE(0 &lt; newBufferSize);

    char *oldBuffer = d_buffer_p;
    d_buffer_p      = newBuffer;
    d_bufferSize    = newBufferSize;
    d_cursor        = 0;

    return oldBuffer;
}

inline
void BufferManager::release()
{
    d_cursor = 0;
}

inline
void BufferManager::reset()
{
    d_buffer_p   = 0;
    d_bufferSize = 0;
    d_cursor     = 0;
}

// ACCESSORS
inline
char *BufferManager::buffer() const
{
    return d_buffer_p;
}

inline
int BufferManager::bufferSize() const
{
    return d_bufferSize;
}

inline
bool BufferManager::hasSufficientCapacity(int size) const
{
    BSLS_ASSERT_SAFE(0 &lt; size);
    BSLS_ASSERT_SAFE(d_buffer_p);
    BSLS_ASSERT_SAFE(0 &lt;= d_cursor);
    BSLS_ASSERT_SAFE(d_cursor &lt;= d_bufferSize);

    int cursorTmp = d_cursor;
    return 0 != (*d_allocate_p)(&amp;cursorTmp, d_buffer_p, d_bufferSize, size);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2012 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
