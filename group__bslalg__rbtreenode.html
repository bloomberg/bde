<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslalg_rbtreenode Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_rbtreenode<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a base class for a red-black binary tree node.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Storing Color Information</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Creating a Function to Print a Red Black Tree</a> </li>
<li>
<a href="#3.2.2">Example 2: Creating a Simple Red-Black Tree</a> </li>
<li>
<a href="#3.2.3">Example 3: Creating a Function To Validate a Red-Black Tree</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a base class for a red-black binary tree node. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslalg_1_1RbTreeNode.html">bslalg::RbTreeNode</a> </td><td>base class for a red-black binary tree node  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__rbtreeutil.html" title="Provide a suite of primitive algorithms on red-black trees.">Component bslalg_rbtreeutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a single POD-like class, <code>RbTreeNode</code>, used to represent a node in a red-black binary search tree. An <code>RbTreeNode</code> provides the address to its parent, left-child, and right-child nodes, as well as providing a "color" (red or black). <code>RbTreeNode</code> does not, however, contain "payload" data (e.g., a value), as it is intended to work with generalized tree operations (see <code>bslalg_rbtreenodeutil</code>). Clients creating a red-black binary search tree must define their own node type that incorporates <code>RbTreeNode</code> (generally via inheritance), and that maintains the "key" value and any associated data. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="storing_color_information"></a> <a class="anchor" id="description.storing_color_information"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Storing Color Information: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>To reduce the memory footprint of the <code>RbTreeNode</code>, the color information is stored at the least-significant-bit (LSB) of the parent node. The address of the parent node and the color can be accessed through bit-wise operations. This is possible because all memory addresses are at least 4-bytes aligned, therefore, the 2 LSB of any pointer are always 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Function to Print a Red Black Tree: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates creating a function that prints, to a <code>FILE</code>, a tree of <code>RbTreeNode</code> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the signature of a function, <code>printTree</code>, that accepts, in addition to an output file and root node, a function pointer argument (supplied by clients) used to print each node's value, note that a node's value is not accessible through <code>RbTreeNode</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> printTree(FILE             *output,
                 <span class="keyword">const</span> RbTreeNode *rootNode,
                 <span class="keywordtype">void</span> (*printNodeValueCallback)(FILE *, <span class="keyword">const</span> RbTreeNode *))
  {
</pre></div><br/>
<br/>
 Now, we define the body of <code>printTree</code>, which is a recursive function that performs a prefix traversal of the supplied binary tree, printing the value and color of <code>rootNode</code> before recursively printing its left and then right sub-trees. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (0 == rootNode) {
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      fprintf(output, <span class="stringliteral">&quot; [ &quot;</span>);

      <span class="comment">// Print the value and color of &#39;rootNode&#39;.</span>

      printNodeValueCallback(output, rootNode);
      fprintf(output,
              <span class="stringliteral">&quot;: %s&quot;</span>,
              rootNode-&gt;color() == RbTreeNode::BSLALG_RED ? <span class="stringliteral">&quot;RED&quot;</span> : <span class="stringliteral">&quot;BLACK&quot;</span>);

      <span class="comment">// Recursively call &#39;printTree&#39; on the left and right sub-trees.</span>

      printTree(output, rootNode-&gt;leftChild(), printNodeValueCallback);
      printTree(output, rootNode-&gt;rightChild(), printNodeValueCallback);
      fprintf(output, <span class="stringliteral">&quot; ]&quot;</span>);
  }
</pre></div><br/>
<br/>
 Notice that we use <code>FILE</code> in the context of this usage example to avoid a dependency of standard library streams. Finally, we will use <code>printTree</code> to print a description of a tree in the next example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Creating a Simple Red-Black Tree: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates creating a simple tree of integer values using <code>RbTreeNode</code>. Note that, in practice, clients should use associated utilities to manage such a tree (see <code>bslalg_rbtreenodeutil</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a node-type, <code>IntTreeNode</code>, that inherits from <code>RbTreeNode</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>IntTreeNode : <span class="keyword">public</span> RbTreeNode {
      <span class="comment">// A red-black tree node containing an integer data-value.</span>

      <span class="keywordtype">int</span> d_value;  <span class="comment">// &quot;payload&quot; value represented by the node</span>
  };
</pre></div><br/>
<br/>
 Then, we define a function <code>printIntNodeValue</code> to print the value of an integer node. Note that this function's signature matches that required by <code>printTree</code> (defined in the preceding example): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> printIntTreeNodeValue(FILE *output, <span class="keyword">const</span> RbTreeNode *node)
  {
     <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 != node);

     fprintf(output, <span class="stringliteral">&quot;%d&quot;</span>, static_cast&lt;const IntTreeNode*&gt;(node)-&gt;d_value);
  }
</pre></div><br/>
<br/>
 Next, we define <code>main</code> for our test, and create three nodes that we'll use to construct a tree: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
  {
      IntTreeNode A, B, C;
</pre></div><br/>
<br/>
 Then, we describe the structure of the tree we wish to construct. <br/>
<br/>
<div class="fragment"><pre class="fragment">                A (value: 2, BLACK)
              /       \.
             /         \.
  B (value: 1, RED)   C ( value: 3, RED )
</pre></div><br/>
<br/>
 Now, we set the properties for the nodes <code>A</code>, <code>B</code>, and <code>C</code> to form a valid tree whose structure matches that description: <br/>
<br/>
<div class="fragment"><pre class="fragment">      A.d_value = 2;
      A.setColor(RbTreeNode::BSLALG_BLACK);
      A.setParent(0);
      A.setLeftChild(&amp;B);
      A.setRightChild(&amp;C);

      B.d_value = 1;
      B.setColor(RbTreeNode::BSLALG_RED);
      B.setParent(&amp;A);
      B.setLeftChild(0);
      B.setRightChild(0);

      C.d_value = 3;
      C.setColor(RbTreeNode::BSLALG_RED);
      C.setParent(&amp;A);
      C.setLeftChild(0);
      C.setRightChild(0);
</pre></div><br/>
<br/>
 Finally, we use the <code>printTree</code> function with the <code>printIntTreeNodeValue</code> function to print the structure of our tree to <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      printTree(stdout, &amp;A, printIntTreeNodeValue);
  }
</pre></div><br/>
<br/>
 Resulting in a single line of console output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  [ 2: BLACK [ 1: RED ] [ 3: RED ] ]
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Creating a Function To Validate a Red-Black Tree: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates creating a function to validate the properties of a red-black tree. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we declare the signature of a function <code>validateRbTree</code>, which takes two arguments: (1) the address to the root node of a tree, and (2) a comparator function, which is used to compare the payload values of the tree nodes. Note that the parameterized comparator is needed because a node's value is not accessible through the supplied <code>RbTreeNode</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> NODE_COMPARATOR&gt;
  <span class="keywordtype">int</span> validateRbTree(<span class="keyword">const</span> RbTreeNode       *rootNode,
                     <span class="keyword">const</span> NODE_COMPARATOR&amp;  comparator);
      <span class="comment">// Return the uniform number of black nodes between every leaf node in</span>
      <span class="comment">// the tree and the specified &#39;rootNode&#39;, 0 if &#39;rootNode&#39; is 0, and a</span>
      <span class="comment">// negative value if &#39;rootNode&#39; does not refer to a valid red-black</span>
      <span class="comment">// binary-search tree that is ordered according to the specified</span>
      <span class="comment">// &#39;comparator&#39;.  &#39;rootNode&#39; is considered a valid red-black binary</span>
      <span class="comment">// search-tree if it obeys the following rules:</span>
      <span class="comment">//</span>
      <span class="comment">//: 1 All nodes in the left sub-tree of &#39;rootNode&#39; are ordered at or</span>
      <span class="comment">//:   before &#39;rootNode&#39; (as determined by &#39;comparator&#39;), and all nodes</span>
      <span class="comment">//:   in the right sub-tree are ordered at or after &#39;rootNode&#39;.</span>
      <span class="comment">//:</span>
      <span class="comment">//: 2 Both children of &#39;rootNode&#39; refer to &#39;rootNode&#39; as a parent.</span>
      <span class="comment">//:</span>
      <span class="comment">//: 3 If &#39;rootNode&#39; is red, its children are either black or 0.</span>
      <span class="comment">//:</span>
      <span class="comment">//: 4 Every path from &#39;rootNode&#39; to a leaf contains the same number of</span>
      <span class="comment">//:   black nodes (the uniform number of black nodes in every path is</span>
      <span class="comment">//:   returned by this function if valid).</span>
      <span class="comment">//:</span>
      <span class="comment">//: 5 Rules (1-4) are obeyed, recursively, by the left and right</span>
      <span class="comment">//:   sub-trees of &#39;rootNode&#39;.</span>
      <span class="comment">//</span>
      <span class="comment">// Note that this particular specification of the constraints of a</span>
      <span class="comment">// red-black tree does not require the presense of black-colored NIL</span>
      <span class="comment">// leaf-nodes; instead NULL children are implicitly assumed to be NIL</span>
      <span class="comment">// leaf-nodes (as is typically the case for C/C++ implementations).</span>
      <span class="comment">// This specification also does not require the root node to be</span>
      <span class="comment">// colored black, as there&#39;s no practical benefit to enforcing that</span>
      <span class="comment">// constraint.</span>
</pre></div><br/>
<br/>
 Then, we declare the signature for an auxiliary function, <code>validateRbTreeRaw</code>, that accepts, additionally, the address of minimum and maximum value nodes, and is needed to recursively apply rule 1: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> NODE_COMPARATOR&gt;
  <span class="keywordtype">int</span> validateRbTreeRaw(<span class="keyword">const</span> RbTreeNode *rootNode,
                        <span class="keyword">const</span> RbTreeNode *minNodeValue,
                        <span class="keyword">const</span> RbTreeNode *maxNodeValue,
                        NODE_COMPARATOR   comparator);

      <span class="comment">// Return the uniform number of black nodes between every leaf node in</span>
      <span class="comment">// the tree and the specified &#39;rootNode&#39;, 0 if &#39;rootNode&#39; is 0, and a</span>
      <span class="comment">// negative value if (1) &#39;rootNode&#39; does not refer to a valid red-black</span>
      <span class="comment">// binary search tree that is ordered according to the specified</span>
      <span class="comment">// &#39;comparator&#39;, (2) the specified &#39;minNodeValue&#39; is not 0 and there is</span>
      <span class="comment">// at least 1 node in the tree ordered before &#39;minNodeValue&#39;, or (3)</span>
      <span class="comment">// the specified &#39;maxNodeValue&#39; is not 0 and there is at least 1 node</span>
      <span class="comment">// in the tree ordered after &#39;maxNodeValue&#39;.</span>
</pre></div><br/>
<br/>
 Now, we define the implementation of <code>validateRbTree</code>, which simply delegates to <code>validateRbTreeRaw</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> NODE_COMPARATOR&gt;
  <span class="keywordtype">int</span> validateRbTree(<span class="keyword">const</span> RbTreeNode *rootNode,
                     NODE_COMPARATOR   comparator)
  {
      <span class="keywordflow">return</span> validateRbTreeRaw(rootNode, 0, 0, comparator);
  }
</pre></div><br/>
<br/>
 Finally, we define the implementation of <code>validateRbTreeRaw</code>, which tests if <code>rootNode</code> violates any of the rules defined in the <code>validateRbTree</code> method documentation, and then recursively calls <code>validateRbTreeRaw</code> on the left and right sub-trees or <code>rootNode</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> NODE_COMPARATOR&gt;
  <span class="keywordtype">int</span> validateRbTreeRaw(<span class="keyword">const</span> RbTreeNode *rootNode,
                        <span class="keyword">const</span> RbTreeNode *minNodeValue,
                        <span class="keyword">const</span> RbTreeNode *maxNodeValue,
                        NODE_COMPARATOR   comparator)
  {
      <span class="keyword">enum</span> { INVALID_RBTREE = -1 };

      <span class="comment">// The black-height of a empty tree is considered 0.</span>

      <span class="keywordflow">if</span> (0 == rootNode) {
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }

      <span class="comment">// Rule 1.</span>

      <span class="keywordflow">if</span> ((minNodeValue &amp;&amp; comparator(*rootNode, *minNodeValue)) ||
          (maxNodeValue &amp;&amp; comparator(*maxNodeValue, *rootNode))) {
          <span class="keywordflow">return</span> INVALID_RBTREE;                                    <span class="comment">// RETURN</span>
      }

      <span class="comment">// Rule 2.</span>

      <span class="keyword">const</span> RbTreeNode *left  = rootNode-&gt;leftChild();
      <span class="keyword">const</span> RbTreeNode *right = rootNode-&gt;rightChild();
      <span class="keywordflow">if</span> ((left  &amp;&amp; left-&gt;parent()  != rootNode) ||
          (right &amp;&amp; right-&gt;parent() != rootNode)) {
          <span class="keywordflow">return</span> INVALID_RBTREE;                                    <span class="comment">// RETURN</span>
      }

      <span class="comment">// Rule 3.</span>

      <span class="keywordflow">if</span> (RbTreeNode::BSLALG_RED == rootNode-&gt;color()) {
          <span class="keywordflow">if</span> ((left  &amp;&amp; left-&gt;color()  != RbTreeNode::BSLALG_BLACK) ||
              (right &amp;&amp; right-&gt;color() != RbTreeNode::BSLALG_BLACK)) {
              <span class="keywordflow">return</span> INVALID_RBTREE;                                <span class="comment">// RETURN</span>
          }
      }

      <span class="comment">// Recursively validate the left and right sub-tree&#39;s and obtain their</span>
      <span class="comment">// black-height in order to apply rule 5.</span>

      <span class="keywordtype">int</span> leftDepth  = validateRbTreeRaw(rootNode-&gt;leftChild(),
                                         minNodeValue,
                                         rootNode,
                                         comparator);

      <span class="keywordtype">int</span> rightDepth = validateRbTreeRaw(rootNode-&gt;rightChild(),
                                         rootNode,
                                         maxNodeValue,
                                         comparator);

      <span class="keywordflow">if</span> (leftDepth &lt; 0 || rightDepth &lt; 0) {
          <span class="keywordflow">return</span> INVALID_RBTREE;                                    <span class="comment">// RETURN</span>
      }

      <span class="comment">// Rule 4.</span>

      <span class="keywordflow">if</span> (leftDepth != rightDepth) {
          <span class="keywordflow">return</span> INVALID_RBTREE;                                    <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">return</span> (rootNode-&gt;color() == RbTreeNode::BSLALG_BLACK)
          ? leftDepth + 1
          : leftDepth;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
