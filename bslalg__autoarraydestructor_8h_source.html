<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslalg_autoarraydestructor.h                                       -*-C++-*-
#ifndef INCLUDED_BSLALG_AUTOARRAYDESTRUCTOR
#define INCLUDED_BSLALG_AUTOARRAYDESTRUCTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a proctor for destroying arrays.
//
//@CLASSES:
//  bslalg::AutoArrayDestructor: exception-neutrality proctor for arrays
//
//@SEE_ALSO: bslma_autodestructor
//
//@DESCRIPTION: This component provides a proctor object to manage a contiguous
// (in-place) sequence of otherwise-unmanaged instances of a user-defined type.
// If not explicitly released, all objects managed by the proctor object are
// automatically destroyed by the proctor&#39;s destructor, using the
// &#39;bslalg_arraydestructionprimitives&#39;.
//
// In most instances, &#39;bslma::AutoDestructor&#39; can also be used, but this
// component is more useful in cases where it is simpler to think in terms of
// two pointers at the ends of the array being managed, rather than an origin
// and offset.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Managing an Array Under Construction
///- - - - - - - - - - - - - - - - - - - - - - - -
// In most instances, the use of a &#39;bslalg::AutoArrayDestructor&#39; could be
// handled by a &#39;bslma::AutoDeallocator&#39;, but sometimes it is conceptually
// clearer to frame the problem in terms of a pair of pointers rather than a
// pointer and an offset.
//
// Suppose we have a class, &#39;UsageType&#39; that allocates a block of memory upon
// construction, and whose constructor takes a &#39;char&#39;.  Suppose we want to
// create an array of elements of such objects in an exception-safe manner.
//
// First, we create the type &#39;UsageType&#39;:
//..
//                               // ===============
//                               // class UsageType
//                               // ===============
//
//  class UsageType {
//      // This test type contains a &#39;char&#39; in some allocated storage.  It has
//      // no traits other than using a &#39;bslma&#39; allocator.
//
//      char             *d_data_p;         // managed single char
//      bslma::Allocator *d_allocator_p;    // allocator (held, not owned)
//
//    public:
//      // CREATORS
//      explicit UsageType(char c, bslma::Allocator *basicAllocator = 0)
//      : d_data_p(0)
//      , d_allocator_p(bslma::Default::allocator(basicAllocator))
//      {
//          d_data_p  = (char *)d_allocator_p-&gt;allocate(sizeof(char));
//          *d_data_p = c;
//      }
//
//      ~UsageType()
//      {
//          *d_data_p = &#39;_&#39;;
//          d_allocator_p-&gt;deallocate(d_data_p);
//          d_data_p = 0;
//      }
//
//      // ACCESSORS
//      char datum() const
//      {
//          return *d_data_p;
//      }
//  };
//
//  namespace BloombergLP {
//  namespace bslma {
//
//  template &lt;&gt;
//  struct UsesBslmaAllocator&lt;UsageType&gt; : bsl::true_type {};
//
//  }  // close package namespace
//  }  // close enterprise namespace
//..
// Then, in &#39;main&#39;, we create a &#39;TestAllocator&#39; to supply memory (and to verify
// that no memory is leaked):
//..
//  bslma::TestAllocator ta;
//..
// Next, we create the pointer for our array:
//..
//  UsageType *array;
//..
// Then, we declare a string of characterss we will use to initialize the
// &#39;UsageType&#39; objects in our array.
//..
//  const char   *DATA = &quot;Hello&quot;;
//  const size_t  DATA_LEN = std::strlen(DATA);
//..
// Next, we verify that even right after exceptions have been thrown and
// caught, no memory is outstanding:
//..
//  assert(0 == ta.numBlocksInUse());
//..
// Then, we allocate our array and create a guard to free it if a subsequent
// allocation throws an exception:
//..
//  array = (UsageType *) ta.allocate(DATA_LEN * sizeof(UsageType));
//  bslma::DeallocatorProctor&lt;bslma::Allocator&gt; arrayProctor(array, &amp;ta);
//..
// Next, we establish an &#39;AutoArrayDestructor&#39; on &#39;array&#39; to destroy any valid
// elements in &#39;array&#39; if an exception is thrown:
//..
//  bslalg::AutoArrayDestructor&lt;UsageType&gt; arrayElementProctor(array, array);
//..
// Notice that we pass &#39;arrayElementProctor&#39; pointers to the beginning and end
// of the range to be guarded (we start with an empty range since no elements
// have been constructed yet).
//
// Then, we iterate through the valid chars in &#39;DATA&#39; and use them to construct
// the elements of the array:
//..
//  UsageType *resultElement = array;
//  for (const char *nextChar = DATA; *nextChar; ++nextChar) {
//..
// Next, construct the next element of &#39;array&#39;:
//..
//      new (resultElement++) UsageType(*nextChar, &amp;ta);
//..
// Now, move the end of &#39;arrayElementProctor&#39; to cover the most recently
// constructed element:
//..
//      arrayElementProctor.moveEnd(1);
//  }
//..
// At this point, we have successfully created our array.
//
// Then, release the guards so they won&#39;t destroy our work when they go out of
// scope:
//..
//  arrayProctor.release();
//  arrayElementProctor.release();
//..
// Next, exit the exception testing block:
//
// Then, verify that the array we have created is as expected:
//..
//  assert(&#39;H&#39; == array[0].datum());
//  assert(&#39;e&#39; == array[1].datum());
//  assert(&#39;l&#39; == array[2].datum());
//  assert(&#39;l&#39; == array[3].datum());
//  assert(&#39;o&#39; == array[4].datum());
//..
// Finally, destroy &amp; free our work and verify that no memory is leaked:
//..
//  for (size_t i = 0; i &lt; DATA_LEN; ++i) {
//      array[i].~UsageType();
//  }
//  ta.deallocate(array);
//
//  assert(0 == ta.numBlocksInUse());
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_ARRAYDESTRUCTIONPRIMITIVES
#include &lt;bslalg_arraydestructionprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;  // size_t
#define INCLUDED_CSTDDEF
#endif

namespace BloombergLP {

namespace bslalg {

                        // =========================
                        // class AutoArrayDestructor
                        // =========================

template &lt;class OBJECT_TYPE&gt;
class AutoArrayDestructor {
    // This &#39;class&#39; provides a specialized proctor object that, upon
    // destruction and unless the &#39;release&#39; method has been called, destroys
    // the elements in a segment of an array of parameterized type
    // &#39;OBJECT_TYPE&#39;.  The elements destroyed are delimited by the &quot;guarded&quot;
    // range &#39;[ begin(), end() )&#39;.

    // DATA
    OBJECT_TYPE *d_begin_p;  // address of first element in guarded range

    OBJECT_TYPE *d_end_p;    // first address beyond last element in guarded
                             // range

  private:
    // NOT IMPLEMENTED
    AutoArrayDestructor(const AutoArrayDestructor&amp;);
    AutoArrayDestructor&amp; operator=(const AutoArrayDestructor&amp;);

  public:
    // TYPES
    typedef std::ptrdiff_t difference_type;

    // CREATORS
    AutoArrayDestructor(OBJECT_TYPE *begin, OBJECT_TYPE *end);
        // Create an array exception guard object for the sequence of elements
        // of the parameterized &#39;OBJECT_TYPE&#39; delimited by the range specified
        // by &#39;[ begin, end )&#39;.  The behavior is undefined unless
        // &#39;begin &lt;= end&#39; and each element in the range &#39;[ begin, end )&#39; has
        // been initialized.

    ~AutoArrayDestructor();
        // Call the destructor on each of the elements of the parameterized
        // &#39;OBJECT_TYPE&#39; delimited by the range &#39;[ begin(), end() )&#39; and
        // destroy this array exception guard.

    // MANIPULATORS
    OBJECT_TYPE *moveBegin(difference_type offset = -1);
        // Move the begin pointer by the specified &#39;offset&#39;, and return the new
        // begin pointer.

    OBJECT_TYPE *moveEnd(difference_type offset = 1);
        // Move the end pointer by the specified &#39;offset&#39;, and return the new
        // end pointer.

    void release();
        // Set the range of elements guarded by this object to be empty.  Note
        // that &#39;begin() == end()&#39; following this operation, but the specific
        // value is unspecified.
};

// ===========================================================================
//                          INLINE FUNCTION DEFINITIONS
// ===========================================================================

                      // -------------------------
                      // class AutoArrayDestructor
                      // -------------------------

// CREATORS
template &lt;class OBJECT_TYPE&gt;
inline
AutoArrayDestructor&lt;OBJECT_TYPE&gt;::AutoArrayDestructor(OBJECT_TYPE *begin,
                                                      OBJECT_TYPE *end)
: d_begin_p(begin)
, d_end_p(end)
{
    BSLS_ASSERT_SAFE(!begin == !end);
    BSLS_ASSERT_SAFE(begin &lt;= end);
}

template &lt;class OBJECT_TYPE&gt;
inline
AutoArrayDestructor&lt;OBJECT_TYPE&gt;::~AutoArrayDestructor()
{
    BSLS_ASSERT_SAFE(!d_begin_p == !d_end_p);
    BSLS_ASSERT_SAFE(d_begin_p &lt;= d_end_p);

    ArrayDestructionPrimitives::destroy(d_begin_p, d_end_p);
}

// MANIPULATORS
template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayDestructor&lt;OBJECT_TYPE&gt;::moveBegin(
                                                        difference_type offset)
{
    BSLS_ASSERT_SAFE(d_begin_p || 0 == offset);
    BSLS_ASSERT_SAFE(d_end_p - d_begin_p &gt;= offset);

    d_begin_p += offset;
    return d_begin_p;
}

template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayDestructor&lt;OBJECT_TYPE&gt;::moveEnd(difference_type offset)
{
    BSLS_ASSERT_SAFE(d_end_p || 0 == offset);
    BSLS_ASSERT_SAFE(d_end_p - d_begin_p &gt;= -offset);

    d_end_p += offset;
    return d_end_p;
}

template &lt;class OBJECT_TYPE&gt;
inline
void AutoArrayDestructor&lt;OBJECT_TYPE&gt;::release()
{
    d_begin_p = d_end_p;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
