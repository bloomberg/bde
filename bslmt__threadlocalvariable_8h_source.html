<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmt_threadlocalvariable.h                                        -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BSLMT_THREADLOCALVARIABLE
#define INCLUDED_BSLMT_THREADLOCALVARIABLE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a macro to declare a thread-local variable.
//
//@CLASSES:
//   BSLMT_THREAD_LOCAL_VARIABLE: macro to declare a thread-local variable
//
//@SEE_ALSO:
//
//@DESCRIPTION: This component should *not* be used outside of the &#39;bce&#39;
// package at this time.
//
// This component defines a macro for declaring a &#39;static&#39; thread-local
// variable.  Where a normal static variable is located at the same memory
// location for all threads within a process, a thread-local static variable
// has a different memory location for each thread in the process:
//..
//  BSLMT_THREAD_LOCAL_VARIABLE(BASIC_TYPE, VARIABLE_NAME, INITIAL_VALUE)
//      Declare, at function or namespace scope, a thread-local &#39;static&#39;
//      variable having the specified &#39;VARIABLE_NAME&#39; of the specified
//      &#39;BASIC_TYPE&#39; in the current context and initialize it with the
//      specified &#39;INITIAL_VALUE&#39;.  The &#39;BASIC_TYPE&#39; must be a valid
//      typename, and that typename must represent either a fundamental or a
//      pointer type.  The specified &#39;VARIABLE_NAME&#39; must be a valid variable
//      name in the scope in which the macro is employed.  The specified
//      &#39;INITIAL_VALUE&#39; must evaluate to a *compile-time* *constant* *value*
//      of type &#39;BASIC_TYPE&#39;.  If &#39;VARIABLE_NAME&#39; is not a valid variable
//      name, or the type of &#39;INITIAL_VALUE&#39; is not convertible to type
//      &#39;BASIC_TYPE&#39;, the instantiation will result in a *compile* *time*
//      error.  The behavior is undefined unless this macro is instantiated
//      within a function or at file (or namespace) scope (i.e., *not* at
//      class scope), and &#39;INITIAL_VALUE&#39; is a *compile-time* constant.  Note
//      that the instantiation of this macro is similar to the declaration:
//      &#39;static BASIC_TYPE VARIABLE_NAME = INITIAL_VALUE;&#39;
//      except that the declared variable, &#39;VARIABLE_NAME&#39;, refers to a
//      different memory location for each thread in the process.
//..
// Note that, &#39;BSLMT_THREAD_LOCAL_VARIABLE&#39; should *not* be instantiated at
// class scope.
//
///Platform Notes
///--------------
// Since the C++ standard does not define a thread-local storage specifier,
// support varies between platforms and compilers.  Moreover, thread-local
// variables are *not* supported on (1) Solaris with gcc or (2) Windows due to
// compiler or runtime limitations.  See the following table for details.
//..
// +----------+----------------------------------------------------------------
// | Platform |  Note
// |----------+----------------------------------------------------------------
// |  AIX     |  o A bug in the AIX compiler prevents compiling translation
// |          |    units with more than 10 thread-local variables with debug
// |          |    symbols.  This has been fixed in xlC8 (internal ticket
// |          |    DRQS 13819416), but has not yet been fixed for xlC10.
// |          |
// |          |  o xlC8 does not support class scoped thread-local variables.
// |----------+----------------------------------------------------------------
// | Solaris  |  o Thread local variables are not currently supported due to a
// |  gcc     |    run-time failure (on thread-exit) for tasks using
// |          |    thread-local variables.  Note that both the Solaris native
// |          |    compiler, and gcc on Linux do support thread-local
// |          |    variables.
// +----------+----------------------------------------------------------------
// | Windows/ |  o Thread local variables cause run-time errors when used
// | MSVC     |    inside a dynamic-library (.dll) that is loaded at runtime
// |          |    using &#39;LoadLibrary&#39; or &#39;LoadLibraryEx&#39; on versions of
// |          |    Windows prior to Vista (e.g., XP).  The problem is noted
// |          |    here:
// |          |    http://support.microsoft.com/kb/118816
// +----------+----------------------------------------------------------------
//..
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: A Service Request Processor with Thread Local Context
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In the following example we create a &#39;RequestProcessor&#39; that places context
// information for the current request in a thread-local variable.
//
// First, we define a trivial structure for a request context.
//..
//  // requestprocessor.h
//
//  struct RequestContext {
//
//      // DATA
//      int d_userId;       // BB user id
//      int d_workstation;  // BB LUW
//  };
//..
// Next, we create a trivial &#39;RequestProcessor&#39; that provides a &#39;static&#39; class
// method that returns the &#39;RequestContext&#39; for the current thread, or 0 if the
// current thread is not processing a request.
//..
//  class RequestProcessor {
//      // This class implements an &quot;example&quot; request processor.
//
//      // NOT IMPLEMENTED
//      RequestProcessor(const RequestProcessor&amp;);
//      RequestProcessor&amp; operator=(const RequestProcessor&amp;);
//
//      // PRIVATE CLASS METHODS
//      static const RequestContext *&amp;contextReference();
//          // Return a reference to a *modifiable* thread-local pointer to the
//          // non-modifiable request context for this thread.  Note that this
//          // method explicitly allows the pointer (but not the
//          // &#39;RequestContext&#39; object) to be modified by the caller to allow
//          // other methods to assign the thread-local context pointer to a
//          // new address.
//
//    public:
//
//      // CLASS METHODS
//      static const RequestContext *requestContext();
//          // Return the address of the non-modifiable, request context for
//          // this thread, or 0 if none has been set.
//
//      // CREATORS
//      RequestProcessor() {}
//          // Create a &#39;RequestProcessor&#39;.
//
//      ~RequestProcessor() {}
//          // Destroy this request processor.
//
//      // MANIPULATORS
//      void processRequest(int userId, int workstation, const char *request);
//          // Process (in the caller&#39;s thread) the specified &#39;request&#39; for
//          // the specified &#39;userId&#39; and &#39;workstation&#39;.
//  };
//
//  // requestprocessor.cpp
//
//  // PRIVATE CLASS METHODS
//..
// Now, we define the &#39;contextReference&#39; method, which defines a thread-local
// &#39;RequestContext&#39; pointer, &#39;context&#39;, initialized to 0, and returns a
// reference providing modifiable access to that pointer.
//..
//  const RequestContext *&amp;RequestProcessor::contextReference()
//  {
//      BSLMT_THREAD_LOCAL_VARIABLE(const RequestContext *, context, 0);
//      return context;
//  }
//
//  // CLASS METHODS
//  const RequestContext *RequestProcessor::requestContext()
//  {
//      return contextReference();
//  }
//
//  // MANIPULATORS
//..
// Then, we define the &#39;processRequest&#39; method, which first sets the
// thread-local pointer containing the request context, and then processes the
// &#39;request&#39;.
//..
//  void RequestProcessor::processRequest(int         userId,
//                                        int         workstation,
//                                        const char *request)
//  {
//      RequestContext currentContext = {userId, workstation};
//
//      contextReference() = &amp;currentContext;
//
//      // Process the request.
//
//      contextReference() = 0;
//  }
//..
// Finally, we define a separate function &#39;myFunction&#39; that uses the
// &#39;RequestProcessor&#39; class to access the &#39;RequestContext&#39; for the current
// thread.
//..
//  void myFunction()
//  {
//      const RequestContext *context = RequestProcessor::requestContext();
//
//      // Perform some task that makes use of this threads &#39;requestContext&#39;.
//      // ...
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

                            // =================
                            // Macro Definitions
                            // =================

#if defined(BSLS_PLATFORM_CMP_SUN)                                            \
 || (defined(BSLS_PLATFORM_CMP_GNU) &amp;&amp; !(defined(BSLS_PLATFORM_CPU_SPARC)))   \
 || (defined(BSLS_PLATFORM_CMP_CLANG) &amp;&amp; !(defined(BSLS_PLATFORM_CPU_SPARC)))
#define BSLMT_THREAD_LOCAL_VARIABLE(BASIC_TYPE, VARIABLE_NAME, INITIAL_VALUE) \
static BSLMT_THREAD_LOCAL_KEYWORD BASIC_TYPE VARIABLE_NAME = INITIAL_VALUE;
    // This macro should *not* be used by clients outside of the &#39;bce&#39;
    // package-group at this time.
    //
    // On IBM, the introduction of thread-local storage causes static
    // initializers for shared objects to stop running.  This problem is
    // described in DRQS 16438026.  Therefore, even though thread-local storage
    // is supported by xlC10, it is explicitly not used here.
    //
    // On Windows/MSVC, compiler-based thread-local storage may cause a crash
    // at runtime when used from a DLL on Windows versions below Vista.
    // Therefore, it is explicitly not used here.
    //
    // Define, at function or namespace scope, a thread-local &#39;static&#39; variable
    // having the specified &#39;VARIABLE_NAME&#39; of the specified &#39;BASIC_TYPE&#39;,
    // initialized with the specified &#39;INITIAL_VALUE&#39;.  If &#39;VARIABLE_NAME&#39; is
    // not a valid variable name, or &#39;INITIAL_VALUE&#39; is not convertible to the
    // type &#39;BASIC_TYPE&#39;, the instantiation of this macro will result in a
    // compile time error.  The behavior is undefined unless &#39;INITIAL_VALUE&#39; is
    // a *compile* *time* constant value.
#endif

#if defined(BSLS_PLATFORM_CMP_SUN)                                            \
 || (defined(BSLS_PLATFORM_CMP_GNU) &amp;&amp; !(defined(BSLS_PLATFORM_CPU_SPARC)))   \
 || (defined(BSLS_PLATFORM_CMP_CLANG) &amp;&amp; !(defined(BSLS_PLATFORM_CPU_SPARC)))
#define BSLMT_THREAD_LOCAL_KEYWORD __thread
#endif

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
