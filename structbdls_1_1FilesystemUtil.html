<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct bdls::FilesystemUtil</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdls.html">bdls</a>      </li>
      <li><a class="el" href="structbdls_1_1FilesystemUtil.html">bdls::FilesystemUtil</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>bdls::FilesystemUtil Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdls::FilesystemUtil" -->
<p><code>#include &lt;<a class="el" href="bdls__filesystemutil_8h_source.html">bdls_filesystemutil.h</a>&gt;</code></p>

<p><a href="structbdls_1_1FilesystemUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58">Whence</a> { <a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58a66812b6ca9deb161d284d1c0b79623d5">e_SEEK_FROM_BEGINNING</a> =  0, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58a205150e726a7864811d00d41b8a7aad9">e_SEEK_FROM_CURRENT</a> =  1, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58a1ce8f2d753a1b90f618d33cd16faf79b">e_SEEK_FROM_END</a> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structbdls_1_1FilesystemUtil.html#a7d5f214f2b8a0388b37e0f7fc96dac12a4c737ba4540e64b6f23c0a5e97b8b8b0">k_DEFAULT_FILE_GROWTH_INCREMENT</a> =  0x10000
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structbdls_1_1FilesystemUtil.html#a0de0c4ea532b059fc0a04b291ebd4ab6a9caf9d8808fff857e210fb698a84164f">k_ERROR_LOCKING_CONFLICT</a> =  1, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a0de0c4ea532b059fc0a04b291ebd4ab6ae1be6386de6f2a42d2f43691aaa5c98b">k_ERROR_LOCKING_INTERRUPTED</a> =  2, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a0de0c4ea532b059fc0a04b291ebd4ab6a2102f87be97d5f80fc942329c2eeaaa4">k_BAD_FILE_DESCRIPTOR</a> =  -1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a> { <a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3ba7114b36af4dfaace24aa27a575b1d7d1">e_OPEN</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3ba5f3858914719d2049f7b07b7bd2933fb">e_CREATE</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3ba23961f75d1abf61be4dae930303482a6">e_CREATE_PRIVATE</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3baba2fe73a44186f61aff5f6c4fded38ba">e_OPEN_OR_CREATE</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a> { <br/>
&nbsp;&nbsp;<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a2731e60ab78302664a9bb939282f2f7d">e_READ_ONLY</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a6ec4f46eed129ea073804985cdcf78ae">e_WRITE_ONLY</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a698c0294cc81e95320fabf4ecbdb93d9">e_APPEND_ONLY</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a2ffe2d27677b466194b884c43690fa56">e_READ_WRITE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908abb3f4c66dcdae74a34dca657522a33e7">e_READ_APPEND</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a> { <a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27a655b834e46a2587a51933afdf5c89ad3">e_TRUNCATE</a>, 
<a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27aac93bd7d2d50a9b48d8d6c38bdac53ea">e_KEEP</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef off64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ac68835c410c78ead136a647058738062">open</a> (const char *path, <a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a> openPolicy, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a> ioPolicy, <a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a> truncatePolicy=e_KEEP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a9fcd2d3f34f074b3b7be5623eb3203af">open</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, <a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a> openPolicy, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a> ioPolicy, <a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a> truncatePolicy=e_KEEP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a9857925958dae54768746c017ea35d3f">close</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a478afba224e4ccf6a17fb8041dfc9268">getWorkingDirectory</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a6447c46c773acef5c45f893be7130d43">setWorkingDirectory</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a07cf457be848ba3095a387ee56a77e77">setWorkingDirectory</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a6a5769072861d4afd4d279377cfbeaf9">exists</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a9c02c1ff06ffb8f48bafaf3bc3d05bb1">exists</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ac810127967fda609116beb43189135a5">isRegularFile</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, bool followLinksFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a299e4b323bf4ce59cc05f8e060b2bc09">isRegularFile</a> (const char *path, bool followLinksFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8fbf125093c50c3fd71d5efe00621843">isDirectory</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, bool followLinksFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aaa85f39d76a05927a03d2ab9a4c060b7">isDirectory</a> (const char *path, bool followLinksFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a92ecfdd7a6fbecaabb7a4ff218058b9b">getLastModificationTime</a> (<a class="el" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> *time, const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ac3144f9ffdb5975a7c442345d8a33286">getLastModificationTime</a> (<a class="el" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> *time, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#acee8e6117d6907d4fd6f2725e098f9ae">createDirectories</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, bool isLeafDirectoryFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a20d68d8eb8c6b5cab43754d3d0606932">createDirectories</a> (const char *path, bool isLeafDirectoryFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a17aa19c48b57f1b1df9a5ebf68f9c154">createPrivateDirectory</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ae9a635878b67dc8d8cd3a10a029e76c3">createTemporaryFile</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *outPath, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a3b7129e9b10564eaf0576e336ed0558d">createTemporaryDirectory</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *outPath, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a7a2d9d6a74b4adbeb36697f142ae18d9">makeUnsafeTemporaryFilename</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *outPath, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ac2624b29e9562de9b813e432d35ab1cc">visitPaths</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a68525ed232c20371319d1abd46a330d7">visitPaths</a> (const char *pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a117e54c713fa55a8b6eafe44f798ff8f">visitTree</a> (const char *root, const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor, bool sortFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ae51eb97e04d6aa084ac9986da4d660fc">visitTree</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;root, const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor, bool sortFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aeaff1fd7c247091e669bfdb6f0654c4f">findMatchingPaths</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &gt; *result, const char *pattern)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a88bb46abc6dd65ed3d5bb42c997b614c">getAvailableSpace</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8c6cfe997793e8dca74ead92307f72f9">getAvailableSpace</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a905d89507296e671d83736fd1e68b04a">getAvailableSpace</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a2fd441b1e0edbb5f31cd2259559d8607">getFileSize</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#abfd91f2cc2315d5a5f3130dad6212627">getFileSize</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a9e1cdfc1d899b484b0a851d3b58f8056">getFileSizeLimit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a5aefcccfd061efa182d86cae61ba8cac">lock</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, bool lockWriteFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#acef17924a4a6bd1600dd7a1cef9f3ec8">tryLock</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, bool lockWriteFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ad6cc8d4dfa44a8a5ccb95e8b60b112a4">unlock</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a4c0cfd2fd52c49393845a87932ab7e86">map</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, void **address, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> offset, int size, int mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a103e4024d8f8091b0c563416980d1ab4">unmap</a> (void *address, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aa858002e1614eb830f1c78cfc8a3b1c6">sync</a> (char *address, int numBytes, bool syncFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab26712088ebce2519f7b5e7396e1436a">seek</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> offset, int whence)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a160d397df5ff5df49fd93a8560acbf99">read</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, void *buffer, int numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aec68946bf27cba1c0aadf32b9e47fd4f">remove</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, bool recursiveFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#afb060aeb3b2c9776bdf3412c860341a9">remove</a> (const char *path, bool recursiveFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a095e12d100d235c503f242e38632c793">rollFileChain</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;path, int maxSuffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a5a7ba7c7fc6ed2ac6eeb728067493b89">rollFileChain</a> (const char *path, int maxSuffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a67adb857280699a27c26153b9146e702">move</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;oldPath, const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;newPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#ad804cd9857919e82d9dded54e6dfefc2">move</a> (const char *oldPath, const char *newPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#abc5fe7e103cd5035f4e2cd2d71f51676">write</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, const void *buffer, int numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#aec34a82f2a4824a17e0728450e6578e6">growFile</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> descriptor, <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> size, bool reserveFlag=false, bsl::size_t increment=k_DEFAULT_FILE_GROWTH_INCREMENT)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a20f0a6a45e778c787ea12fb5f5b140c9">k_OFFSET_MAX</a> = (0x7FFFFFFFFFFFFFFFLL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#a750eef508b438afee8674462c7612a29">k_OFFSET_MIN</a> = (-0x7FFFFFFFFFFFFFFFLL-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">k_INVALID_FD</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for utility functions dealing with platform-independent filesystem access. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="af177603b027970757c45b67984235d36"></a><!-- doxytag: member="bdls::FilesystemUtil::FileDescriptor" ref="af177603b027970757c45b67984235d36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">bdls::FilesystemUtil::FileDescriptor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab783252d8c9d7d97680f2a371e402acc"></a><!-- doxytag: member="bdls::FilesystemUtil::Offset" ref="ab783252d8c9d7d97680f2a371e402acc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef off64_t <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">bdls::FilesystemUtil::Offset</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a58bf107a8193356bdedef8cd4f113c58"></a><!-- doxytag: member="bdls::FilesystemUtil::Whence" ref="a58bf107a8193356bdedef8cd4f113c58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbdls_1_1FilesystemUtil.html#a58bf107a8193356bdedef8cd4f113c58">bdls::FilesystemUtil::Whence</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration used to distinguish among different starting points for a seek operation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a58bf107a8193356bdedef8cd4f113c58a66812b6ca9deb161d284d1c0b79623d5"></a><!-- doxytag: member="e_SEEK_FROM_BEGINNING" ref="a58bf107a8193356bdedef8cd4f113c58a66812b6ca9deb161d284d1c0b79623d5" args="" -->e_SEEK_FROM_BEGINNING</em>&nbsp;</td><td>
<p>Seek from beginning of file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a58bf107a8193356bdedef8cd4f113c58a205150e726a7864811d00d41b8a7aad9"></a><!-- doxytag: member="e_SEEK_FROM_CURRENT" ref="a58bf107a8193356bdedef8cd4f113c58a205150e726a7864811d00d41b8a7aad9" args="" -->e_SEEK_FROM_CURRENT</em>&nbsp;</td><td>
<p>Seek from current position. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a58bf107a8193356bdedef8cd4f113c58a1ce8f2d753a1b90f618d33cd16faf79b"></a><!-- doxytag: member="e_SEEK_FROM_END" ref="a58bf107a8193356bdedef8cd4f113c58a1ce8f2d753a1b90f618d33cd16faf79b" args="" -->e_SEEK_FROM_END</em>&nbsp;</td><td>
<p>Seek from end of file. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d5f214f2b8a0388b37e0f7fc96dac12"></a><!-- doxytag: member="bdls::FilesystemUtil::@212" ref="a7d5f214f2b8a0388b37e0f7fc96dac12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7d5f214f2b8a0388b37e0f7fc96dac12a4c737ba4540e64b6f23c0a5e97b8b8b0"></a><!-- doxytag: member="k_DEFAULT_FILE_GROWTH_INCREMENT" ref="a7d5f214f2b8a0388b37e0f7fc96dac12a4c737ba4540e64b6f23c0a5e97b8b8b0" args="" -->k_DEFAULT_FILE_GROWTH_INCREMENT</em>&nbsp;</td><td>
<p>default block size to grow files by </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a0de0c4ea532b059fc0a04b291ebd4ab6"></a><!-- doxytag: member="bdls::FilesystemUtil::@213" ref="a0de0c4ea532b059fc0a04b291ebd4ab6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0de0c4ea532b059fc0a04b291ebd4ab6a9caf9d8808fff857e210fb698a84164f"></a><!-- doxytag: member="k_ERROR_LOCKING_CONFLICT" ref="a0de0c4ea532b059fc0a04b291ebd4ab6a9caf9d8808fff857e210fb698a84164f" args="" -->k_ERROR_LOCKING_CONFLICT</em>&nbsp;</td><td>
<p>value representing a failure to obtain a lock on a file </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0de0c4ea532b059fc0a04b291ebd4ab6ae1be6386de6f2a42d2f43691aaa5c98b"></a><!-- doxytag: member="k_ERROR_LOCKING_INTERRUPTED" ref="a0de0c4ea532b059fc0a04b291ebd4ab6ae1be6386de6f2a42d2f43691aaa5c98b" args="" -->k_ERROR_LOCKING_INTERRUPTED</em>&nbsp;</td><td>
<p>value representing a failure to obtain a lock on a file due to interruption by a signal </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0de0c4ea532b059fc0a04b291ebd4ab6a2102f87be97d5f80fc942329c2eeaaa4"></a><!-- doxytag: member="k_BAD_FILE_DESCRIPTOR" ref="a0de0c4ea532b059fc0a04b291ebd4ab6a2102f87be97d5f80fc942329c2eeaaa4" args="" -->k_BAD_FILE_DESCRIPTOR</em>&nbsp;</td><td>
<p>value indicating a bad file descriptor was supplied </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3b"></a><!-- doxytag: member="bdls::FilesystemUtil::FileOpenPolicy" ref="aaf288297e2a9b65fdcdd18c2aec66c3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">bdls::FilesystemUtil::FileOpenPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration used to determine whether <code>open</code> should open an existing file, or create a new file. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3ba7114b36af4dfaace24aa27a575b1d7d1"></a><!-- doxytag: member="e_OPEN" ref="aaf288297e2a9b65fdcdd18c2aec66c3ba7114b36af4dfaace24aa27a575b1d7d1" args="" -->e_OPEN</em>&nbsp;</td><td>
<p>Open a file if it exists, and fail otherwise. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3ba5f3858914719d2049f7b07b7bd2933fb"></a><!-- doxytag: member="e_CREATE" ref="aaf288297e2a9b65fdcdd18c2aec66c3ba5f3858914719d2049f7b07b7bd2933fb" args="" -->e_CREATE</em>&nbsp;</td><td>
<p>Create a new file, and fail if the file already exists. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3ba23961f75d1abf61be4dae930303482a6"></a><!-- doxytag: member="e_CREATE_PRIVATE" ref="aaf288297e2a9b65fdcdd18c2aec66c3ba23961f75d1abf61be4dae930303482a6" args="" -->e_CREATE_PRIVATE</em>&nbsp;</td><td>
<p>Create a new file with access restricted to the creating userid, where supported, and fail if the file already exists. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aaf288297e2a9b65fdcdd18c2aec66c3baba2fe73a44186f61aff5f6c4fded38ba"></a><!-- doxytag: member="e_OPEN_OR_CREATE" ref="aaf288297e2a9b65fdcdd18c2aec66c3baba2fe73a44186f61aff5f6c4fded38ba" args="" -->e_OPEN_OR_CREATE</em>&nbsp;</td><td>
<p>Open a file if it exists, and create a new file otherwise. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ab79b11034df3e25311be375da986b908"></a><!-- doxytag: member="bdls::FilesystemUtil::FileIOPolicy" ref="ab79b11034df3e25311be375da986b908" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">bdls::FilesystemUtil::FileIOPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration used to distinguish between different sets of actions permitted on an open file descriptor. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908a2731e60ab78302664a9bb939282f2f7d"></a><!-- doxytag: member="e_READ_ONLY" ref="ab79b11034df3e25311be375da986b908a2731e60ab78302664a9bb939282f2f7d" args="" -->e_READ_ONLY</em>&nbsp;</td><td>
<p>Allow reading only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908a6ec4f46eed129ea073804985cdcf78ae"></a><!-- doxytag: member="e_WRITE_ONLY" ref="ab79b11034df3e25311be375da986b908a6ec4f46eed129ea073804985cdcf78ae" args="" -->e_WRITE_ONLY</em>&nbsp;</td><td>
<p>Allow writing only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908a698c0294cc81e95320fabf4ecbdb93d9"></a><!-- doxytag: member="e_APPEND_ONLY" ref="ab79b11034df3e25311be375da986b908a698c0294cc81e95320fabf4ecbdb93d9" args="" -->e_APPEND_ONLY</em>&nbsp;</td><td>
<p>Allow appending to end-of-file only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908a2ffe2d27677b466194b884c43690fa56"></a><!-- doxytag: member="e_READ_WRITE" ref="ab79b11034df3e25311be375da986b908a2ffe2d27677b466194b884c43690fa56" args="" -->e_READ_WRITE</em>&nbsp;</td><td>
<p>Allow both reading and writing. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab79b11034df3e25311be375da986b908abb3f4c66dcdae74a34dca657522a33e7"></a><!-- doxytag: member="e_READ_APPEND" ref="ab79b11034df3e25311be375da986b908abb3f4c66dcdae74a34dca657522a33e7" args="" -->e_READ_APPEND</em>&nbsp;</td><td>
<p>Allow both reading and appending to end-of-file. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c2d86c5eb644a39e3a40cc5594b3b27"></a><!-- doxytag: member="bdls::FilesystemUtil::FileTruncatePolicy" ref="a8c2d86c5eb644a39e3a40cc5594b3b27" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">bdls::FilesystemUtil::FileTruncatePolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration used to distinguish between different ways to handle the contents, if any, of an existing file immediately upon opening the file. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8c2d86c5eb644a39e3a40cc5594b3b27a655b834e46a2587a51933afdf5c89ad3"></a><!-- doxytag: member="e_TRUNCATE" ref="a8c2d86c5eb644a39e3a40cc5594b3b27a655b834e46a2587a51933afdf5c89ad3" args="" -->e_TRUNCATE</em>&nbsp;</td><td>
<p>Delete the file's contents on open. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8c2d86c5eb644a39e3a40cc5594b3b27aac93bd7d2d50a9b48d8d6c38bdac53ea"></a><!-- doxytag: member="e_KEEP" ref="a8c2d86c5eb644a39e3a40cc5594b3b27aac93bd7d2d50a9b48d8d6c38bdac53ea" args="" -->e_KEEP</em>&nbsp;</td><td>
<p>Keep the file's contents. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac68835c410c78ead136a647058738062"></a><!-- doxytag: member="bdls::FilesystemUtil::open" ref="ac68835c410c78ead136a647058738062" args="(const char *path, FileOpenPolicy openPolicy, FileIOPolicy ioPolicy, FileTruncatePolicy truncatePolicy=e_KEEP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> bdls::FilesystemUtil::open </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>openPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ioPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a>&nbsp;</td>
          <td class="paramname"> <em>truncatePolicy</em> = <code>e_KEEP</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9fcd2d3f34f074b3b7be5623eb3203af"></a><!-- doxytag: member="bdls::FilesystemUtil::open" ref="a9fcd2d3f34f074b3b7be5623eb3203af" args="(const bsl::string &amp;path, FileOpenPolicy openPolicy, FileIOPolicy ioPolicy, FileTruncatePolicy truncatePolicy=e_KEEP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> bdls::FilesystemUtil::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3b">FileOpenPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>openPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908">FileIOPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>ioPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#a8c2d86c5eb644a39e3a40cc5594b3b27">FileTruncatePolicy</a>&nbsp;</td>
          <td class="paramname"> <em>truncatePolicy</em> = <code>e_KEEP</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open the file at the specified <code>path</code>, using the specified <code>openPolicy</code> to determine whether to open an existing file or create a new file, and using the specified <code>ioPolicy</code> to determine whether the file will be opened for reading, writing, or both. Optionally specify a <code>truncatePolicy</code> to determine whether any contents of the file will be deleted before <code>open</code> returns. If <code>truncatePolicy</code> is not supplied, the value <code>e_KEEP</code> will be used. Return a valid <code>FileDescriptor</code> for the file on success, or <code>k_INVALID_FD</code> otherwise. If <code>openPolicy</code> is <code>e_OPEN</code>, the file will be opened if it exists, and <code>open</code> will fail otherwise. If <code>openPolicy</code> is <code>e_CREATE</code> or <code>e_CREATE_PRIVATE</code>, and no file exists at <code>path</code>, a new file will be created, and <code>open</code> will fail otherwise. If <code>openPolicy</code> is <code>e_CREATE_PRIVATE</code>, the file will be created with access restricted to the same userid as the caller in environments where that is supported (which does not necessarily include Windows) otherwise the system default access policy is used (e.g. '0777 &amp; ~umask'). If <code>openPolicy</code> is <code>e_OPEN_OR_CREATE</code>, the file will be opened if it exists, and a new file will be created otherwise. If <code>ioPolicy</code> is <code>e_READ_ONLY</code>, the returned <code>FileDescriptor</code> will allow only read operations on the file. If <code>ioPolicy</code> is <code>e_WRITE_ONLY</code> or <code>e_APPEND_ONLY</code>, the returned <code>FileDescriptor</code> will allow only write operations on the file. If <code>ioPolicy</code> is <code>e_READ_WRITE</code> or <code>e_READ_APPEND</code>, the returned <code>FileDescriptor</code> will allow both read and write operations on the file. Additionally, if <code>ioPolicy</code> is <code>e_APPEND_ONLY</code> or <code>e_READ_APPEND</code> all writes will be made to the end of the file ("append mode"). If <code>truncatePolicy</code> is <code>e_TRUNCATE</code>, the file will have zero length when <code>open</code> returns. If <code>truncatePolicy</code> is <code>e_KEEP</code>, the file will be opened with its existing contents, if any. Note that when a file is opened in <code>append</code> mode, all writes will go to the end of the file, even if there has been seeking on the file descriptor or another process has changed the length of the file. Append-mode writes are not atomic except in limited cases; another thread, or even another process, operating on the file may cause output not to be written, unbroken, to the end of the file. (Unix environments writing to local file systems may promise more.) Note that <code>open</code> will fail to open a file with a <code>truncatePolicy</code> of <code>e_TRUNCATE</code> unless at least one of the following policies is specified for <code>openPolicy</code> or <code>ioPolicy</code>: </p>
<ul>
<li>
<code>e_CREATE</code>  </li>
<li>
<code>e_CREATE_PRIVATE</code>  </li>
<li>
<code>e_OPEN_OR_CREATE</code>  </li>
<li>
'e_WRITE_ONLY  </li>
<li>
<code>e_READ_WRITE</code>  </li>
</ul>

</div>
</div>
<a class="anchor" id="a9857925958dae54768746c017ea35d3f"></a><!-- doxytag: member="bdls::FilesystemUtil::close" ref="a9857925958dae54768746c017ea35d3f" args="(FileDescriptor descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the specified <code>descriptor</code>. Return 0 on success and a non-zero value otherwise. A return value of <code>k_BAD_FILE_DESCRIPTOR</code> indicates that the supplied <code>descriptor</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a478afba224e4ccf6a17fb8041dfc9268"></a><!-- doxytag: member="bdls::FilesystemUtil::getWorkingDirectory" ref="a478afba224e4ccf6a17fb8041dfc9268" args="(bsl::string *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::getWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>path</code> the absolute pathname of the current working directory. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a6447c46c773acef5c45f893be7130d43"></a><!-- doxytag: member="bdls::FilesystemUtil::setWorkingDirectory" ref="a6447c46c773acef5c45f893be7130d43" args="(const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::setWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a07cf457be848ba3095a387ee56a77e77"></a><!-- doxytag: member="bdls::FilesystemUtil::setWorkingDirectory" ref="a07cf457be848ba3095a387ee56a77e77" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::setWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the working directory of the current process to the specified <code>path</code>. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a6a5769072861d4afd4d279377cfbeaf9"></a><!-- doxytag: member="bdls::FilesystemUtil::exists" ref="a6a5769072861d4afd4d279377cfbeaf9" args="(const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c02c1ff06ffb8f48bafaf3bc3d05bb1"></a><!-- doxytag: member="bdls::FilesystemUtil::exists" ref="a9c02c1ff06ffb8f48bafaf3bc3d05bb1" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::exists </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there currently exists a file or directory at the specified <code>path</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac810127967fda609116beb43189135a5"></a><!-- doxytag: member="bdls::FilesystemUtil::isRegularFile" ref="ac810127967fda609116beb43189135a5" args="(const bsl::string &amp;path, bool followLinksFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::isRegularFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>followLinksFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a299e4b323bf4ce59cc05f8e060b2bc09"></a><!-- doxytag: member="bdls::FilesystemUtil::isRegularFile" ref="a299e4b323bf4ce59cc05f8e060b2bc09" args="(const char *path, bool followLinksFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::isRegularFile </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>followLinksFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there currently exists a regular file at the specified <code>path</code>, and <code>false</code> otherwise. If there is a symbolic link at <code>path</code>, follow it only if the optionally specified <code>followLinksFlag</code> is <code>true</code> (otherwise, return <code>false</code> as the symbolic link itself is not a regular file irrespective of the file to which it points). Platform-specific note: On POSIX, this is a positive test on the "regular file" mode; on Windows, this is a negative test on the "directory" attribute, i.e., on Windows, everything that exists and is not a directory is a regular file. </p>

</div>
</div>
<a class="anchor" id="a8fbf125093c50c3fd71d5efe00621843"></a><!-- doxytag: member="bdls::FilesystemUtil::isDirectory" ref="a8fbf125093c50c3fd71d5efe00621843" args="(const bsl::string &amp;path, bool followLinksFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::isDirectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>followLinksFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa85f39d76a05927a03d2ab9a4c060b7"></a><!-- doxytag: member="bdls::FilesystemUtil::isDirectory" ref="aaa85f39d76a05927a03d2ab9a4c060b7" args="(const char *path, bool followLinksFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdls::FilesystemUtil::isDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>followLinksFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there currently exists a directory at the specified <code>path</code>, and <code>false</code> otherwise. If there is a symbolic link at <code>path</code>, follow it only if the optionally specified <code>followLinksFlag</code> is <code>true</code> (otherwise return <code>false</code>). Platform-specific note: On Windows, a "shortcut" is not a symbolic link. </p>

</div>
</div>
<a class="anchor" id="a92ecfdd7a6fbecaabb7a4ff218058b9b"></a><!-- doxytag: member="bdls::FilesystemUtil::getLastModificationTime" ref="a92ecfdd7a6fbecaabb7a4ff218058b9b" args="(bdlt::Datetime *time, const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::getLastModificationTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac3144f9ffdb5975a7c442345d8a33286"></a><!-- doxytag: member="bdls::FilesystemUtil::getLastModificationTime" ref="ac3144f9ffdb5975a7c442345d8a33286" args="(bdlt::Datetime *time, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::getLastModificationTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>time</code> the last modification time of the file at the specified <code>path</code>, as reported by the filesystem. Return 0 on success, and a non-zero value otherwise. Note that the time is reported in UTC. </p>

</div>
</div>
<a class="anchor" id="acee8e6117d6907d4fd6f2725e098f9ae"></a><!-- doxytag: member="bdls::FilesystemUtil::createDirectories" ref="acee8e6117d6907d4fd6f2725e098f9ae" args="(const bsl::string &amp;path, bool isLeafDirectoryFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::createDirectories </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isLeafDirectoryFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a20d68d8eb8c6b5cab43754d3d0606932"></a><!-- doxytag: member="bdls::FilesystemUtil::createDirectories" ref="a20d68d8eb8c6b5cab43754d3d0606932" args="(const char *path, bool isLeafDirectoryFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::createDirectories </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isLeafDirectoryFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create any directories in the specified <code>path</code> that do not exist. If the optionally specified <code>isLeafDirectoryFlag</code> is <code>true</code>, treat the final name component in <code>path</code> as a directory name, and create it. Otherwise, create only the directories leading up to the final name component. Return 0 on success, and a non-zero value if any needed directories in <code>path</code> could not be created. </p>

</div>
</div>
<a class="anchor" id="a17aa19c48b57f1b1df9a5ebf68f9c154"></a><!-- doxytag: member="bdls::FilesystemUtil::createPrivateDirectory" ref="a17aa19c48b57f1b1df9a5ebf68f9c154" args="(const bslstl::StringRef &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::createPrivateDirectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a private directory with the specified <code>path</code>. Return 0 on success, and a non-zero value if the directory could not be created. The directory is created with permissions restricting access, as closely as possible, to the caller's userid only. If the directory already exists, the function reports success but the directory's permissions are not changed. Note that directories created on Microsoft Windows may receive default, not restricted permissions. </p>

</div>
</div>
<a class="anchor" id="ae9a635878b67dc8d8cd3a10a029e76c3"></a><!-- doxytag: member="bdls::FilesystemUtil::createTemporaryFile" ref="ae9a635878b67dc8d8cd3a10a029e76c3" args="(bsl::string *outPath, const bslstl::StringRef &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> bdls::FilesystemUtil::createTemporaryFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>outPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create and open a new file with a name constructed by appending an automatically-generated suffix to the specified <code>prefix</code>, and return its file descriptor open for reading and writing. A return value of <code>k_INVALID_FD</code> indicates that no such file could be created; otherwise, the name of the file created is assigned to the specified <code>outPath</code>. The file is created with permissions restricted, as closely as possible, to the caller's userid only. If the prefix is a relative path, the file is created relative to the process current directory. Responsibility for deleting the file is left to the caller. Note that on Posix systems, if <code>outPath</code> is unlinked immediately, the file will remain usable until its descriptor is closed. Note that files created on Microsoft Windows may receive default, not restricted permissions. </p>

</div>
</div>
<a class="anchor" id="a3b7129e9b10564eaf0576e336ed0558d"></a><!-- doxytag: member="bdls::FilesystemUtil::createTemporaryDirectory" ref="a3b7129e9b10564eaf0576e336ed0558d" args="(bsl::string *outPath, const bslstl::StringRef &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::createTemporaryDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>outPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new directory with a name constructed by appending an automatically-generated suffix to the specified <code>prefix</code>. A non-zero return value indicates that no such directory could be created; otherwise the name of the directory created is assigned to the specified <code>outPath</code>. The directory is created with permissions restricted, as closely as possible, to the caller only. If the prefix is a relative path, the directory is created relative to the process current directory. Responsibility for deleting the directory (and any files subsequently created in it) is left to the caller. </p>

</div>
</div>
<a class="anchor" id="a7a2d9d6a74b4adbeb36697f142ae18d9"></a><!-- doxytag: member="bdls::FilesystemUtil::makeUnsafeTemporaryFilename" ref="a7a2d9d6a74b4adbeb36697f142ae18d9" args="(bsl::string *outPath, const bslstl::StringRef &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdls::FilesystemUtil::makeUnsafeTemporaryFilename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>outPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a file name by appending an automatically-generated suffix to the specified <code>prefix</code>. The file name constructed is assigned to the specified <code>outPath</code>. Note that this function is called "unsafe" because a file with the resulting name may be created by another program before the caller has opportunity to use the name, which could be a security vulnerability, and a file with the given name may already exist where you mean to put it. Note that the suffix is hashed from environmental details, including any pre-existing value of <code>outPath</code> so that if a resulting name is unsuitable (e.g. the file exists) this function may simply be called again, pointing to its previous result, to get a new, probably different name. </p>

</div>
</div>
<a class="anchor" id="ac2624b29e9562de9b813e432d35ab1cc"></a><!-- doxytag: member="bdls::FilesystemUtil::visitPaths" ref="ac2624b29e9562de9b813e432d35ab1cc" args="(const bsl::string &amp;pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdls::FilesystemUtil::visitPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void(const char *path)&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68525ed232c20371319d1abd46a330d7"></a><!-- doxytag: member="bdls::FilesystemUtil::visitPaths" ref="a68525ed232c20371319d1abd46a330d7" args="(const char *pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdls::FilesystemUtil::visitPaths </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void(const char *path)&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call the specified <code>visitor</code> function object for each path in the filesystem matching the specified <code>pattern</code>. Note that if <code>visitor</code> deletes files or directories during the search, <code>visitor</code> may subsequently be called with paths which have already been deleted, so must be prepared for this event. See <code>findMatchingPaths</code> for a discussion of how <code>pattern</code> is interpreted. </p>

</div>
</div>
<a class="anchor" id="a117e54c713fa55a8b6eafe44f798ff8f"></a><!-- doxytag: member="bdls::FilesystemUtil::visitTree" ref="a117e54c713fa55a8b6eafe44f798ff8f" args="(const char *root, const bsl::string &amp;pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor, bool sortFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::visitTree </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void(const char *path)&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sortFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae51eb97e04d6aa084ac9986da4d660fc"></a><!-- doxytag: member="bdls::FilesystemUtil::visitTree" ref="ae51eb97e04d6aa084ac9986da4d660fc" args="(const bsl::string &amp;root, const bsl::string &amp;pattern, const bsl::function&lt; void(const char *path)&gt; &amp;visitor, bool sortFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::visitTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void(const char *path)&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sortFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Recursively traverse the directory tree starting at the specified <code>root</code> for files whose leaf names match the specified <code>pattern</code>, and run the specified function <code>visitor</code>, passing it the full path starting with <code>root</code> to each pattern matching file. See <code>findMatchingPaths</code> for a discussion of how <code>pattern</code> is interpreted. If the specified <code>sortFlag</code> is <code>true</code>, traverse the files in the tree in sorted order, sorted by the full path name, otherwise the order in which the files will be visited is unspecified. UTF-8 paths will be sorted by <code>strcmp</code>, which sorts by <code>char</code>s, not unicode code points. Found <code>.</code> and <code>..</code> directories are ignored, except that <code>root</code> may be <code>.</code> or <code>..</code>. Return 0 on success, and a non-zero value otherwise. This function will fail if <code>root</code> does not specify a directory, of if <code>pattern</code> contains <code>/</code> on Unix or <code>\</code> on Windows. Note that both directories and plain files whose names match <code>pattern</code> will be visited, while other files such as symlinks will not be visited or followed. No file or directory that is not matched will be visited. All directories are traversed, regardless of whether they are matched. If a directory is matched and <code>sortFlag</code> is <code>true</code>, it is visited immediately before it is traversed. Also note that <code>root</code> is never visited, even if it matches <code>pattern</code>. Also note that no pattern matching is done on <code>root</code> -- if it contains wildcards, they are not interpreted as such and must exactly match the characters in the name of the directory. </p>

</div>
</div>
<a class="anchor" id="aeaff1fd7c247091e669bfdb6f0654c4f"></a><!-- doxytag: member="bdls::FilesystemUtil::findMatchingPaths" ref="aeaff1fd7c247091e669bfdb6f0654c4f" args="(bsl::vector&lt; bsl::string &gt; *result, const char *pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdls::FilesystemUtil::findMatchingPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> vector all paths in the filesystem matching the specified <code>pattern</code>. The <code>*</code> character will match any number of characters in a filename; however, this matching will not span a directory separator (e.g., "logs/m*.txt" will not match "logs/march/001.txt"). <code>?</code> will match any one character. <code>*</code> and <code>?</code> may be used any number of times in the pattern. The special directories "." and ".." will not be matched against any pattern. Note that any initial contents of <code>result</code> will be erased, and that the paths in <code>result</code> will not be in any particular guaranteed order.</p>
<p>WINDOWS-SPECIFIC NOTE: To support DOS idioms, the OS-provided search function has behavior that we have chosen not to work around: an extension consisting of wild-card characters (<code>?</code>, <code>*</code>) can match an extension or <em>no</em> extension. E.g., "file.?" matches "file.z", but not "file.txt"; however, it also matches "file" (without any extension). Likewise, "*.*" matches any filename, including filenames having no extension. </p>

</div>
</div>
<a class="anchor" id="a88bb46abc6dd65ed3d5bb42c997b614c"></a><!-- doxytag: member="bdls::FilesystemUtil::getAvailableSpace" ref="a88bb46abc6dd65ed3d5bb42c997b614c" args="(const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getAvailableSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c6cfe997793e8dca74ead92307f72f9"></a><!-- doxytag: member="bdls::FilesystemUtil::getAvailableSpace" ref="a8c6cfe997793e8dca74ead92307f72f9" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getAvailableSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes available for allocation in the file system where the file or directory with the specified <code>path</code> resides, or a negative value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="a905d89507296e671d83736fd1e68b04a"></a><!-- doxytag: member="bdls::FilesystemUtil::getAvailableSpace" ref="a905d89507296e671d83736fd1e68b04a" args="(FileDescriptor descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getAvailableSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes available for allocation in the file system where the file with the specified <code>descriptor</code> resides, or a negative value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="a2fd441b1e0edbb5f31cd2259559d8607"></a><!-- doxytag: member="bdls::FilesystemUtil::getFileSize" ref="a2fd441b1e0edbb5f31cd2259559d8607" args="(const bsl::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getFileSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abfd91f2cc2315d5a5f3130dad6212627"></a><!-- doxytag: member="bdls::FilesystemUtil::getFileSize" ref="abfd91f2cc2315d5a5f3130dad6212627" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getFileSize </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size, in bytes, of the file or directory at the specified <code>path</code>, or a negative value if an error occurs. Note that the size of a symbolic link is the size of the file or directory to which it points. </p>

</div>
</div>
<a class="anchor" id="a9e1cdfc1d899b484b0a851d3b58f8056"></a><!-- doxytag: member="bdls::FilesystemUtil::getFileSizeLimit" ref="a9e1cdfc1d899b484b0a851d3b58f8056" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::getFileSizeLimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the file size limit for this process, <code>k_OFFSET_MAX</code> if no limit is set, or a negative value if an error occurs. Note that if you are doing any calculations involving the returned value, it is recommended to check for <code>k_OFFSET_MAX</code> specifically to avoid integer overflow in your calculations. </p>

</div>
</div>
<a class="anchor" id="a5aefcccfd061efa182d86cae61ba8cac"></a><!-- doxytag: member="bdls::FilesystemUtil::lock" ref="a5aefcccfd061efa182d86cae61ba8cac" args="(FileDescriptor descriptor, bool lockWriteFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lockWriteFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire a lock for the file with the specified <code>descriptor</code>. If <code>lockWriteFlag</code> is true, acquire an exclusive write lock; otherwise acquire a (possibly) shared read lock. The calling thread will block until the lock is acquired. Return 0 on success, and a non-zero value otherwise. Note that this operation locks the indicated file for use by the current <em>process</em>, but the behavior is unspecified (and platform-dependent) when either attempting to lock <code>descriptor</code> multiple times, or attempting to lock another descriptor referring to the same file, within a single process. </p>

</div>
</div>
<a class="anchor" id="acef17924a4a6bd1600dd7a1cef9f3ec8"></a><!-- doxytag: member="bdls::FilesystemUtil::tryLock" ref="acef17924a4a6bd1600dd7a1cef9f3ec8" args="(FileDescriptor descriptor, bool lockWriteFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::tryLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lockWriteFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire a lock for the file with the specified <code>descriptor</code> if it is currently available. If the specified <code>lockWriteFlag</code> is true, acquire an exclusive write lock unless another process has any type of lock on the file. If <code>lockWriteFlag</code> is false, acquire a shared read lock unless a process has a write lock. This method will not block. Return 0 on success, <code>k_ERROR_LOCKING_CONFLICT</code> if the platform reports the lock could not be acquired because another process holds a conflicting lock, and a negative value for any other kind of error. Note that this operation locks the indicated file for the current <em>process</em>, but the behavior is unspecified (and platform-dependent) when either attempting to lock <code>descriptor</code> multiple times, or attempting to lock another descriptor referring to the same file, within a single process. </p>

</div>
</div>
<a class="anchor" id="ad6cc8d4dfa44a8a5ccb95e8b60b112a4"></a><!-- doxytag: member="bdls::FilesystemUtil::unlock" ref="ad6cc8d4dfa44a8a5ccb95e8b60b112a4" args="(FileDescriptor descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release any lock this process holds on the file with the specified <code>descriptor</code>. Return 0 on success, and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a4c0cfd2fd52c49393845a87932ab7e86"></a><!-- doxytag: member="bdls::FilesystemUtil::map" ref="a4c0cfd2fd52c49393845a87932ab7e86" args="(FileDescriptor descriptor, void **address, Offset offset, int size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Map the region of the specified <code>size</code> bytes, starting at the specified <code>offset</code> bytes into the file with the specified <code>descriptor</code> to memory, and load into the specified <code>address</code> of the mapped area. Return 0 on success, and a non-zero value otherwise. The access permissions for mapping memory are defined by the specified <code>mode</code>, which may be a combination of <code><a class="el" href="structbdls_1_1MemoryUtil.html#a7367de98ca1d46c39f33eb99e3157bd3a487a5baded9415448e805f78ed74f31d">MemoryUtil::k_ACCESS_READ</a></code>, <code><a class="el" href="structbdls_1_1MemoryUtil.html#a7367de98ca1d46c39f33eb99e3157bd3aafbc14902cb796205b602885220a81bb">MemoryUtil::k_ACCESS_WRITE</a></code> and <code><a class="el" href="structbdls_1_1MemoryUtil.html#a7367de98ca1d46c39f33eb99e3157bd3a5235425b6994824cad7d4669618a1192">MemoryUtil::k_ACCESS_EXECUTE</a></code>. Note that on failure, the value of <code>address</code> is undefined. Also note that mapping will succeed even if there are fewer than <code>offset + size</code> bytes in the specified file, and an attempt to access the mapped memory beyond the end of the file will result in undefined behavior (i.e., this function does not grow the file to guarantee it can accommodate the mapped region). </p>

</div>
</div>
<a class="anchor" id="a103e4024d8f8091b0c563416980d1ab4"></a><!-- doxytag: member="bdls::FilesystemUtil::unmap" ref="a103e4024d8f8091b0c563416980d1ab4" args="(void *address, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::unmap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unmap the memory mapping with the specified base <code>address</code> and specified <code>size</code>. Return 0 on success, and a non-zero value otherwise. The behavior is undefined unless this area with <code>address</code> and <code>size</code> was previously mapped with a <code>map</code> call. </p>

</div>
</div>
<a class="anchor" id="aa858002e1614eb830f1c78cfc8a3b1c6"></a><!-- doxytag: member="bdls::FilesystemUtil::sync" ref="aa858002e1614eb830f1c78cfc8a3b1c6" args="(char *address, int numBytes, bool syncFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::sync </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>syncFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronize the contents of the specified <code>numBytes</code> of mapped memory beginning at the specified <code>address</code> with the underlying file on disk. If the specified <code>syncFlag</code> is true, block until all writes to nonvolatile media have actually completed, otherwise, return once they have been scheduled. Return 0 on success, and a non-zero value otherwise. The behavior is undefined unless <code>address</code> is aligned on a page boundary, <code>numBytes</code> is a multiple of <code>pageSize()</code>, and <code>0 &lt;= numBytes</code>. </p>

</div>
</div>
<a class="anchor" id="ab26712088ebce2519f7b5e7396e1436a"></a><!-- doxytag: member="bdls::FilesystemUtil::seek" ref="ab26712088ebce2519f7b5e7396e1436a" args="(FileDescriptor descriptor, Offset offset, int whence)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> bdls::FilesystemUtil::seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>whence</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the file pointer associated with the specified <code>descriptor</code> (used by calls to the <code>read</code> and <code>write</code> system calls) according to the specified <code>whence</code> behavior: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment"> If <span class="stringliteral">&#39;whence&#39;</span> is e_SEEK_FROM_BEGINNING, <span class="keyword">set</span> the pointer to
             <span class="stringliteral">&#39;offset&#39;</span> bytes from the beginning of the file.
 If <span class="stringliteral">&#39;whence&#39;</span> is e_SEEK_FROM_CURRENT, advance the pointer by
             <span class="stringliteral">&#39;offset&#39;</span> bytes
 If <span class="stringliteral">&#39;whence&#39;</span> is e_SEEK_FROM_END, <span class="keyword">set</span> the pointer to <span class="stringliteral">&#39;offset&#39;</span>
             bytes beyond the end of the file.
</pre></div><p><br/>
<br/>
 Return the new location of the file pointer, in bytes from the beginning of the file, on success; and -1 otherwise. The effect on the file pointer is undefined unless the file is on a device capable of seeking. Note that <code>seek</code> does not change the size of the file if the pointer advances beyond the end of the file; instead, the next write at the pointer will increase the file size. </p>

</div>
</div>
<a class="anchor" id="a160d397df5ff5df49fd93a8560acbf99"></a><!-- doxytag: member="bdls::FilesystemUtil::read" ref="a160d397df5ff5df49fd93a8560acbf99" args="(FileDescriptor descriptor, void *buffer, int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the specified <code>numBytes</code> bytes beginning at the file pointer of the file with the specified <code>descriptor</code> into the specified <code>bufffer</code>. Return <code>numBytes</code> on success; the number of bytes read if there were not enough available; or a negative number on some other error. </p>

</div>
</div>
<a class="anchor" id="aec68946bf27cba1c0aadf32b9e47fd4f"></a><!-- doxytag: member="bdls::FilesystemUtil::remove" ref="aec68946bf27cba1c0aadf32b9e47fd4f" args="(const bsl::string &amp;path, bool recursiveFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>recursiveFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb060aeb3b2c9776bdf3412c860341a9"></a><!-- doxytag: member="bdls::FilesystemUtil::remove" ref="afb060aeb3b2c9776bdf3412c860341a9" args="(const char *path, bool recursiveFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::remove </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>recursiveFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the file or directory at the specified <code>path</code>. If the <code>path</code> refers to a directory and the optionally specified <code>recursiveFlag</code> is <code>true</code>, recursively remove all files and directories within the specified directory before removing the directory itself. Return 0 on success and a non-zero value otherwise. Note that if <code>path</code> is a directory, and the directory is not empty, and recursive is <code>false</code>, this method will fail. Also note that if the function fails when <code>recursive</code> is <code>true</code>, it may or may not have removed <em>some</em> files or directories before failing. </p>

</div>
</div>
<a class="anchor" id="a095e12d100d235c503f242e38632c793"></a><!-- doxytag: member="bdls::FilesystemUtil::rollFileChain" ref="a095e12d100d235c503f242e38632c793" args="(const bsl::string &amp;path, int maxSuffix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::rollFileChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSuffix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5a7ba7c7fc6ed2ac6eeb728067493b89"></a><!-- doxytag: member="bdls::FilesystemUtil::rollFileChain" ref="a5a7ba7c7fc6ed2ac6eeb728067493b89" args="(const char *path, int maxSuffix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::rollFileChain </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSuffix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the file at the specified <code>path</code> appended with the specified <code>maxSuffix</code> using a <code>.</code> as a separator. Then move the files with the suffixes <code>.1</code> to <code>.maxSuffix-1</code> so they have new suffixes from <code>.2</code> to <code>.maxSuffix</code>. Finally, move <code>path</code> to <code>path</code> with a <code>.1</code> suffix. Return 0 on success, and non-zero otherwise. </p>

</div>
</div>
<a class="anchor" id="a67adb857280699a27c26153b9146e702"></a><!-- doxytag: member="bdls::FilesystemUtil::move" ref="a67adb857280699a27c26153b9146e702" args="(const bsl::string &amp;oldPath, const bsl::string &amp;newPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad804cd9857919e82d9dded54e6dfefc2"></a><!-- doxytag: member="bdls::FilesystemUtil::move" ref="ad804cd9857919e82d9dded54e6dfefc2" args="(const char *oldPath, const char *newPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::move </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the file or directory at the specified <code>oldPath</code> to the specified <code>newPath</code>. If there is a file or directory at <code>newPath</code>, it will be removed and replaced. In that case, <code>newPath</code> must refer to the same type of filesystem item as <code>oldPath</code> - that is, they must both be directories or both be files. Return 0 on success, and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="abc5fe7e103cd5035f4e2cd2d71f51676"></a><!-- doxytag: member="bdls::FilesystemUtil::write" ref="abc5fe7e103cd5035f4e2cd2d71f51676" args="(FileDescriptor descriptor, const void *buffer, int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>numBytes</code> from the specified <code>buffer</code> address to the file with the specified <code>descriptor</code>. Return <code>numBytes</code> on success; the number of bytes written if space was exhausted; or a negative value on some other error. </p>

</div>
</div>
<a class="anchor" id="aec34a82f2a4824a17e0728450e6578e6"></a><!-- doxytag: member="bdls::FilesystemUtil::growFile" ref="aec34a82f2a4824a17e0728450e6578e6" args="(FileDescriptor descriptor, Offset size, bool reserveFlag=false, bsl::size_t increment=k_DEFAULT_FILE_GROWTH_INCREMENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdls::FilesystemUtil::growFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reserveFlag</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>increment</em> = <code>k_DEFAULT_FILE_GROWTH_INCREMENT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Grow the file with the specified <code>descriptor</code> to the size of at least the specified <code>size</code> bytes. Return 0 on success, and a non-zero value otherwise. If the optionally specified <code>reserveFlag</code> is true, make sure the space on disk is preallocated and not allocated on demand, preventing a possible out-of-disk-space error when accessing the data on file systems with sparse file support. Preallocation is done by writing unspecified data to file in blocks of the optionally specified <code>increment</code>. Note that if the size of the file is greater than or equal to <code>size</code>, this function has no effect. Also note that the contents of the newly grown portion of the file is undefined. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a20f0a6a45e778c787ea12fb5f5b140c9"></a><!-- doxytag: member="bdls::FilesystemUtil::k_OFFSET_MAX" ref="a20f0a6a45e778c787ea12fb5f5b140c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> <a class="el" href="structbdls_1_1FilesystemUtil.html#a20f0a6a45e778c787ea12fb5f5b140c9">bdls::FilesystemUtil::k_OFFSET_MAX</a> = (0x7FFFFFFFFFFFFFFFLL)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>maximum representable file offset value </p>

</div>
</div>
<a class="anchor" id="a750eef508b438afee8674462c7612a29"></a><!-- doxytag: member="bdls::FilesystemUtil::k_OFFSET_MIN" ref="a750eef508b438afee8674462c7612a29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbdls_1_1FilesystemUtil.html#ab783252d8c9d7d97680f2a371e402acc">Offset</a> <a class="el" href="structbdls_1_1FilesystemUtil.html#a750eef508b438afee8674462c7612a29">bdls::FilesystemUtil::k_OFFSET_MIN</a> = (-0x7FFFFFFFFFFFFFFFLL-1)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minimum representable file offset value </p>

</div>
</div>
<a class="anchor" id="af6eb8fae5d490a49997d7e4fc59ae467"></a><!-- doxytag: member="bdls::FilesystemUtil::k_INVALID_FD" ref="af6eb8fae5d490a49997d7e4fc59ae467" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FileDescriptor</a> <a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">bdls::FilesystemUtil::k_INVALID_FD</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>FileDescriptor</code> value </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bdls__filesystemutil_8h_source.html">bdls_filesystemutil.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:33 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
