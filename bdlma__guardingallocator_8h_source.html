<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlma_guardingallocator.h                                          -*-C++-*-
#ifndef INCLUDED_BDLMA_GUARDINGALLOCATOR
#define INCLUDED_BDLMA_GUARDINGALLOCATOR

//@PURPOSE: Provide a memory allocator that guards against buffer overruns.
//
//@CLASSES:
//  bdlma::GuardingAllocator: memory allocator that detects buffer overruns
//
//@SEE_ALSO: bslma_allocator, bslma_testallocator
//
//@DESCRIPTION: This component provides a concrete allocation mechanism,
// &#39;bdlma::GuardingAllocator&#39;, that implements the &#39;bslma::Allocator&#39; protocol
// and adjoins a read/write protected guard page to each block of memory
// returned by the &#39;allocate&#39; method.  The guard page is located immediately
// following or immediately preceding the block returned from &#39;allocate&#39;
// according to an optionally-supplied constructor argument:
//..
//   ,------------------------.
//  ( bdlma::GuardingAllocator )
//   `------------------------&#39;
//               |         ctor/dtor
//               V
//      ,----------------.
//     ( bslma::Allocator )
//      `----------------&#39;
//                         allocate
//                         deallocate
//..
// *WARNING*: Note that this allocator should *not* be used for production use;
// it is intended for debugging purposes only.  In particular, clients should
// be aware that a multiple of the page size is allocated for *each* &#39;allocate&#39;
// invocation (unless the size of the request is 0).
//
// Also note that, unlike many other BDE allocators, a &#39;bslma::Allocator *&#39;
// cannot be (optionally) supplied upon construction of a counting allocator;
// instead, a system facility is used that allocates blocks of memory in
// multiples of the system page size.
//
///Guard Pages
///-----------
// A &#39;GuardingAllocator&#39; may be used to debug buffer overflow (or underflow) by
// protecting a memory page after (or before) each block of memory returned
// from &#39;allocate&#39;.  Consequently, certain memory access outside the block
// returned to the client will trigger a memory protection fault.
//
// A constructor argument of type &#39;GuardingAllocator::GuardPageLocation&#39;,
// an enumeration, determines whether guard pages are located following
// (&#39;e_AFTER_USER_BLOCK&#39;) or preceding (&#39;e_BEFORE_USER_BLOCK&#39;) the user block.
// If no value is supplied at construction, &#39;e_AFTER_USER_BLOCK&#39; is assumed.
//
// To illustrate, the following diagram shows the memory layout resulting from
// an &#39;N&#39;-byte allocation request from a guarding allocator, where &#39;N&#39; is
// assumed to be less than or equal to the size of a memory page.  Note that
// two pages of memory are consumed for each such allocation request:
//..
//  N` - N rounded up to the least multiple of the maximum alignment
//  A  - address of (2-page) block of memory returned by system allocator
//  U  - address returned from &#39;allocate&#39; to user
//  G  - address of the guard page
//  PS - page size (in bytes)
//
//                          e_AFTER_USER_BLOCK
//                          ------------------
//
//      [ - - - one memory page  - - - | - - - one memory page  - - - ]
//      ---------------------------------------------------------------
//      |                 |  N` bytes  | ******* R/W protected ****** |
//      ---------------------------------------------------------------
//      ^                 ^            ^
//      A                 U == G - N`  G == A + PS
//
//
//                          e_BEFORE_USER_BLOCK
//                          -------------------
//
//      ---------------------------------------------------------------
//      | ******* R/W protected ****** |  N` bytes  |                 |
//      ---------------------------------------------------------------
//      ^                              ^
//      A == G                         U == A + PS
//..
///Thread Safety
///-------------
// The &#39;bdlma::GuardingAllocator&#39; class is fully thread-safe (see
// &#39;bsldoc_glossary&#39;).
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Diagnosing Buffer Overflow
///- - - - - - - - - - - - - - - - - - -
// Use of a &#39;bdlma::GuardingAllocator&#39; is indicated, for example, if some code
// under development is suspected of having a buffer overrun (or underrun) bug,
// and more sophisticated tools that detect such conditions are either not
// available, or are inconvenient to apply to the situation at hand.
//
// This usage example illustrates a guarding allocator being brought to bear on
// a buffer overrun bug.  The bug in question arises in the context of an
// artificial data handling class, &#39;my_DataHandler&#39;.  This class makes use of a
// (similarly artificial) data translation utility that translates chunks of
// data among various data styles.  In our idealized example, we assume that
// the length of the output resulting from some data translation is precisely
// determinable from the length of the input data and the respective styles of
// the input and the (desired) output.  For simplicity, we also assume that
// input data comes from a trusted source.
//
// First, we define an enumeration of data styles:
//..
//  enum my_DataStyle {
//      e_STYLE_NONE = 0
//    , e_STYLE_A    = 1  // default style
//    , e_STYLE_AA   = 2  // style exactly twice as verbose as &#39;e_STYLE_A&#39;
//    // etc.
//  };
//..
// Next, we define the (elided) interface of our data translation utility:
//..
//  struct my_DataTranslationUtil {
//      // This &#39;struct&#39; provides a namespace for data translation utilities.
//
//      // CLASS METHODS
//      static int outputSize(my_DataStyle outputStyle,
//                            my_DataStyle inputStyle,
//                            int          inputLength);
//         // Return the buffer size (in bytes) required to store the result of
//         // converting input data of the specified &#39;inputLength&#39; (in bytes),
//         // in the specified &#39;inputStyle&#39;, into the specified &#39;outputStyle&#39;.
//         // The behavior is undefined unless &#39;0 &lt;= inputLength&#39;.
//
//      static int translate(      char *output, my_DataStyle outputStyle,
//                           const char *input,  my_DataStyle inputStyle);
//          // Load into the specified &#39;output&#39; buffer the result of converting
//          // the specified &#39;input&#39; data, in the specified &#39;inputStyle&#39;, into
//          // the specified &#39;outputStyle&#39;.  Return 0 on success, and a
//          // non-zero value otherwise.  The behavior is undefined unless
//          // &#39;output&#39; has sufficient capacity to hold the translated result.
//          // Note that this method assumes that &#39;input&#39; originated from a
//          // trusted source.
//  };
//..
// Next, we define &#39;my_DataHandler&#39;, a simple class that makes use of
// &#39;my_DataTranslationUtil&#39;:
//..
//  class my_DataHandler {
//      // This &#39;class&#39; provides a basic data handler.
//
//      // DATA
//      my_DataStyle      d_inStyle;     // style of &#39;d_inBuffer&#39; contents
//      char             *d_inBuffer;    // input supplied at construction
//      int               d_inCapacity;  // capacity (in bytes) of &#39;d_inBuffer&#39;
//      my_DataStyle      d_altStyle;    // alternative style (if requested)
//      char             *d_altBuffer;   // buffer for alternative style
//      bslma::Allocator *d_allocator_p; // memory allocator (held, not owned)
//
//    public:
//      // CREATORS
//      my_DataHandler(const char       *input,
//                     int               inputLength,
//                     my_DataStyle      inputStyle,
//                     bslma::Allocator *basicAllocator = 0);
//          // Create a data handler for the specified &#39;input&#39; data, in the
//          // specified &#39;inputStyle&#39;, having the specified &#39;inputLength&#39; (in
//          // bytes).  Optionally specify a &#39;basicAllocator&#39; used to supply
//          // memory.  If &#39;basicAllocator&#39; is 0, the currently installed
//          // default allocator is used.  The behavior is undefined unless
//          // &#39;0 &lt;= inputLength&#39;.
//
//      ~my_DataHandler();
//          // Destroy this data handler.
//
//      // ...
//
//      // MANIPULATORS
//      int generateAlternate(my_DataStyle alternateStyle);
//          // Generate data for this data handler in the specified
//          // &#39;alternateStyle&#39;.  Return 0 on success, and a non-zero value
//          // otherwise.  If &#39;alternateStyle&#39; is the same as the style of data
//          // supplied at construction, this method returns 0 with no effect.
//
//      // ...
//  };
//..
// Next, we show the definition of the &#39;my_DataHandler&#39; constructor:
//..
//  my_DataHandler::my_DataHandler(const char       *input,
//                                 int               inputLength,
//                                 my_DataStyle      inputStyle,
//                                 bslma::Allocator *basicAllocator)
//  : d_inStyle(inputStyle)
//  , d_inBuffer(0)
//  , d_inCapacity(inputLength)
//  , d_altStyle(e_STYLE_NONE)
//  , d_altBuffer(0)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//      BSLS_ASSERT(0 &lt;= inputLength);
//
//      void *tmp = d_allocator_p-&gt;allocate(inputLength);
//      bsl::memcpy(tmp, input, inputLength);
//      d_inBuffer = static_cast&lt;char *&gt;(tmp);
//  }
//..
// Next, we show the definition of the &#39;generateAlternate&#39; manipulator.  Note
// that we have deliberately introduced a bug in &#39;generateAlternate&#39; to cause
// buffer overrun:
//..
//  int my_DataHandler::generateAlternate(my_DataStyle alternateStyle)
//  {
//      if (alternateStyle == d_inStyle) {
//          return 0;                                                 // RETURN
//      }
//
//      int altLength = my_DataTranslationUtil::outputSize(alternateStyle,
//                                                         d_inStyle,
//                                                         d_inCapacity);
//
//      // Oops!  Should have used &#39;altLength&#39;.
//      char *tmpAltBuffer = (char *)d_allocator_p-&gt;allocate(d_inCapacity);
//      int rc = my_DataTranslationUtil::translate(tmpAltBuffer,
//                                                 alternateStyle,
//                                                 d_inBuffer,
//                                                 d_inStyle);
//
//      if (rc) {
//          d_allocator_p-&gt;deallocate(tmpAltBuffer);
//          return rc;                                                // RETURN
//      }
//
//      d_altStyle  = alternateStyle;
//      d_altBuffer = tmpAltBuffer;
//
//      return 0;
//  }
//..
// Next, we define some data (in &#39;e_STYLE_A&#39;) and define a &#39;my_DataHandler&#39;
// object, &#39;handler&#39;, to process that data.  Note that our &#39;handler&#39; object
// uses the default allocator:
//..
//  const char *input = &quot;AAAAAAAAAAAAAAA@&quot;;  // data always terminated with &#39;@&#39;
//
//  my_DataHandler handler(input, 16, e_STYLE_A);
//..
// Next, we request that an alternate data style, &#39;e_STYLE_AA&#39;, be generated by
// &#39;handler&#39;.  Unfortunately, data in style &#39;e_STYLE_AA&#39; is twice as large as
// that in style &#39;e_STYLE_A&#39; making it a virtual certainty that the program
// will crash due to the insufficiently sized buffer that is allocated in the
// &#39;generateAlternate&#39; method to accommodate the &#39;e_STYLE_AA&#39; data:
//..
//  int rc = handler.generateAlternate(e_STYLE_AA);
//  if (!rc) {
//      // use data in alternate style
//  }
//..
// Suppose that after performing a brief post mortem on the resulting core
// file, we strongly suspect that a buffer overrun is the root cause, but the
// program crashed in a context far removed from that of the source of the
// problem (which is often the case with buffer overrun issues).
//
// Consequently, we modify the code to supply a guarding allocator to the
// &#39;handler&#39; object, then rebuild and rerun the program.  We have configured
// the guarding allocator (below) to place guard pages *after* user blocks.
// Note that &#39;e_AFTER_USER_BLOCK&#39; is the default, so it need not be specified
// at construction as we have (pedantically) done here:
//..
//  typedef bdlma::GuardingAllocator GA;
//  GA guard(GA::e_AFTER_USER_BLOCK);
//
//  my_DataHandler handler(input, 16, e_STYLE_A, &amp;guard);
//..
// With a guarding allocator now in place, a memory fault is triggered when a
// guard page is overwritten as a result of the buffer overrun bug.  Hence, the
// program will dump core in a context that is more proximate to the buggy
// code, resulting in a core file that will be more amenable to revealing the
// issue when analyzed in a debugger.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                         // -----------------------
                         // class GuardingAllocator
                         // -----------------------

class GuardingAllocator : public bslma::Allocator {
    // This class defines a concrete thread-safe &quot;guarding&quot; allocator mechanism
    // that implements the &#39;bslma::Allocator&#39; protocol, and adjoins a
    // read/write protected guard page to each block of memory returned by the
    // &#39;allocate&#39; method.  The guard page is placed immediately before or
    // immediately following the block returned from &#39;allocate&#39; according to
    // the &#39;GuardPageLocation&#39; enumerator value (optionally) supplied at
    // construction.  Note that, unlike many other allocators, an allocator
    // cannot be (optionally) supplied at construction; instead, a system
    // facility is used that allocates blocks of memory in multiples of the
    // system page size.  Also note that this allocator is intended for
    // debugging purposes *only*.

  public:
    // TYPES
    enum GuardPageLocation {
        // Enumerate the configuration options for &#39;GuardingAllocator&#39; that may
        // be (optionally) supplied at construction.

        e_AFTER_USER_BLOCK,  // locate the guard page after the user block
        e_BEFORE_USER_BLOCK  // locate the guard page before the user block
    };

  private:
    // DATA
    GuardPageLocation d_guardPageLocation;  // if &#39;e_AFTER_USER_BLOCK&#39;, place
                                            // the read/write protected guard
                                            // page after the user block;
                                            // otherwise, place it before the
                                            // block (&#39;e_BEFORE_USER_BLOCK&#39;)

  private:
    // NOT IMPLEMENTED
    GuardingAllocator(const GuardingAllocator&amp;);
    GuardingAllocator&amp; operator=(const GuardingAllocator&amp;);

  public:
    // CREATORS
    explicit
    GuardingAllocator(GuardPageLocation guardLocation = e_AFTER_USER_BLOCK);
        // Create a guarding allocator.  Optionally specify a &#39;guardLocation&#39;
        // indicating where read/write protected guard pages should be placed
        // with respect to the memory blocks returned by the &#39;allocate&#39; method.
        // If &#39;guardLocation&#39; is not specified, guard pages are placed
        // immediately following the memory blocks returned by &#39;allocate&#39;.

    virtual ~GuardingAllocator();
        // Destroy this allocator object.  Note that destroying this allocator
        // has no effect on any outstanding allocated memory.

    // MANIPULATORS
    virtual void *allocate(size_type size);
        // Return a newly-allocated maximally-aligned block of memory of the
        // specified &#39;size&#39; (in bytes) that has a read/write protected guard
        // page located immediately before or after it according to the
        // &#39;GuardPageLocation&#39; indicated at construction.  If &#39;size&#39; is 0, no
        // memory is allocated and 0 is returned.  Note that a multiple of the
        // platform&#39;s memory page size is allocated for *every* call to this
        // method.

    virtual void deallocate(void *address);
        // Return the memory block at the specified &#39;address&#39; back to this
        // allocator.  If &#39;address&#39; is 0, this method has no effect.
        // Otherwise, the guard page associated with &#39;address&#39; is unprotected
        // and also deallocated.  The behavior is undefined unless &#39;address&#39;
        // was returned by &#39;allocate&#39; and has not already been deallocated.
};

// ============================================================================
//                         INLINE FUNCTION DEFINITIONS
// ============================================================================

                         // -----------------------
                         // class GuardingAllocator
                         // -----------------------

// CREATORS
inline
GuardingAllocator::GuardingAllocator(GuardPageLocation guardLocation)
: d_guardPageLocation(guardLocation)
{
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
