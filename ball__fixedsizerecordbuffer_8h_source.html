<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// ball_fixedsizerecordbuffer.h                                       -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALL_FIXEDSIZERECORDBUFFER
#define INCLUDED_BALL_FIXEDSIZERECORDBUFFER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a thread-safe fixed-size buffer of record handles.
//
//@CLASSES:
//  ball::FixedSizeRecordBuffer: thread-safe fixed-size buffer of records
//
//@SEE_ALSO: ball_recordbuffer
//
//@DESCRIPTION: This component provides a concrete thread-safe implementation
// of the &#39;ball::RecordBuffer&#39; protocol.  The sum of sizes of all records
// contained in a &#39;ball::FixedSizeRecordBuffer&#39; object *plus* the amount of
// memory allocated by the &#39;ball::FixedSizeRecordBuffer&#39; object itself is
// guaranteed to be less than or equal to an upper bound specified at creation.
//..
//              ( ball::FixedSizeRecordBuffer )
//                            |              ctor
//                            V
//                  ( ball::RecordBuffer )
//                                           dtor
//                                           beginSequence
//                                           endSequence
//                                           popBack
//                                           popFront
//                                           pushBack
//                                           pushFront
//                                           removeAll
//                                           length
//                                           back
//                                           front
//..
// The thread-safe class &#39;ball::FixedSizeRecordBuffer&#39; manages record handles
// (specifically, the instances of &#39;bsl::shared_ptr&lt;ball::Record&gt;&#39;) in a
// double-ended buffer.  At any time, the sum of sizes of all records contained
// in a &#39;ball::FixedSizeRecordBuffer&#39; object *plus* the amount of memory
// allocated by the &#39;ball::FixedSizeRecordBuffer&#39; object itself is guaranteed
// to be less than or equal to an upper bound specified at creation.  In order
// to accommodate a record, existing records may be removed from the buffer
// (see below).  The &#39;ball::FixedSizeRecordBuffer&#39; class provides methods to
// push a record handle into either end (back or front) of the buffer
// (&#39;pushBack&#39; and &#39;pushFront&#39;), to obtain read-only access to the log record
// positioned at either end (&#39;back&#39; and &#39;front&#39;) and to remove the record
// positioned at either end (&#39;popBack&#39; and &#39;popFront&#39;).  In order to
// accommodate a &#39;pushBack&#39; request, the records from the front end of the
// buffer may be removed.  Similarly, in order to accommodate a &#39;pushFront&#39;
// request, the records from the back end of the buffer may be removed.  If a
// record can not be accommodated in the buffer, it is silently (but otherwise
// safely) discarded.
//
///Usage
///-----
// In the following example we demonstrate creation of a limited record buffer
// followed by concurrent access to it by multiple threads.
//..
//    enum {
//        KILO_BYTE      = 1024,   // one kilo is (2^10) bytes
//        MAX_TOTAL_SIZE = 32 * K, // &#39;maxTotalSize&#39; parameter
//        NUM_ITERATIONS = 1000,   // number of iterations
//        NUM_THREADS    = 4       // number of threads
//    };
//    bslma::Allocator *basicAllocator = bslma::Default::defaultAllocator();
//..
// First we create a record buffer.
//..
//    bdlmca::DefaultDeleter&lt;ball::Record&gt; recordDeleter(basicAllocator);
//    ball::FixedSizeRecordBuffer recordBuffer(MAX_TOTAL_SIZE, basicAllocator);
//..
// Note that since the record buffer will contain shared pointers to the
// records, &#39;recordDeleter&#39; must be created before &#39;recordBuffer&#39; to ensure
// that the former has the longer lifetime.
//
// Now we create several threads each of which repeatedly performs the
// following operations in a tight loop;
//  (1) create a record;
//  (2) build a message and store it into the record;
//  (3) create a record handle;
//  (4) push this record handle at the back end of of the record buffer
//
//..
//    void *workerThread(void *arg)
//    {
//        int id = (int)arg; // thread id
//        for(int i = 0; i &lt; NUM_ITERATIONS; ++i){
//            ball::Record *record =
//                          new (*basicAllocator) ball::Record(basicAllocator);
//
//            // build a message
//            enum { MAX_SIZE = 100 };
//            char msg[MAX_SIZE];
//            sprintf(msg, &quot;message no. %d from thread no. %d&quot;, i, id);
//
//            record-&gt;getFixedFields().setMessage(msg);
//
//            bsl::shared_ptr&lt;ball::Record&gt;
//              handle(record, &amp;recordDeleter, basicAllocator);
//
//            recordBuffer.pushBack(handle);
//        }
//..
// After completing the loop each thread iterates, in LIFO order, over all of
// the records contained in record buffer.
//..
//        // print messages in LIFO order
//        recordBuffer.beginSequence();
//        while (recordBuffer.length()) {
//            const ball::Record &amp;rec = recordBuffer.back();
//            bsl::cout &lt;&lt; rec.getFixedFields().message() &lt;&lt; bsl::endl;
//            recordBuffer.popBack();
//        }
//        recordBuffer.endSequence();
//
//        return NULL;
//    }
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALL_COUNTINGALLOCATOR
#include &lt;ball_countingallocator.h&gt;
#endif

#ifndef INCLUDED_BALL_RECORD
#include &lt;ball_record.h&gt;
#endif

#ifndef INCLUDED_BALL_RECORDBUFFER
#include &lt;ball_recordbuffer.h&gt;
#endif

#ifndef INCLUDED_BSLMT_LOCKGUARD
#include &lt;bslmt_lockguard.h&gt;
#endif

#ifndef INCLUDED_BSLMT_RECURSIVEMUTEX
#include &lt;bslmt_recursivemutex.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_DEQUE
#include &lt;bsl_deque.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

namespace BloombergLP {

namespace ball {
                          // ===========================
                          // class FixedSizeRecordBuffer
                          // ===========================

class FixedSizeRecordBuffer: public RecordBuffer {
    // This class provides a concrete, thread-safe implementation of the
    // &#39;RecordBuffer&#39; protocol.  This class is a mechanism.  At any time, the
    // sum of sizes of all records contained in a &#39;FixedSizeRecordBuffer&#39;
    // object *plus* the amount of memory allocated by the
    // &#39;FixedSizeRecordBuffer&#39; object itself is guaranteed to be less than or
    // equal to an upper bound specified at creation.  The class is
    // thread-safe, except that the methods &#39;front&#39; and &#39;back&#39; must be called
    // after locking the buffer by invoking &#39;beginSequence&#39;.  In order to
    // accommodate a &#39;pushBack&#39; request, the records from the front end of the
    // buffer may be removed.  Similarly, in order to accommodate a &#39;pushFront&#39;
    // request, the records from the back end of the buffer may be removed.  If
    // a record can not accommodate in the buffer, it is silently (but
    // otherwise safely) discarded.

    // DATA
    mutable bslmt::RecursiveMutex d_mutex;       // synchronizes access to the
                                                 // buffer

    int                           d_maxTotalSize;
                                                 // maximum possible sum of
                                                 // sizes of contained records

    int                           d_currentTotalSize;
                                                 // current sum of sizes of
                                                 // contained records

    // Implementation note:  The order of the following data members is
    // required to enusre proper intialization order.

    CountingAllocator             d_allocator;   // allocator for &#39;d_deque&#39;

    bsl::deque&lt;bsl::shared_ptr&lt;Record&gt; &gt;
                                  d_deque;       // deque of record handles



    // NOT IMPLEMENTED
    FixedSizeRecordBuffer(const FixedSizeRecordBuffer&amp;);
    FixedSizeRecordBuffer&amp; operator=(const FixedSizeRecordBuffer&amp;);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(FixedSizeRecordBuffer,
                                   bslma::UsesBslmaAllocator);

    // CREATORS
    FixedSizeRecordBuffer(int               maxTotalSize,
                          bslma::Allocator *basicAllocator = 0);
        // Create a limited record buffer such that at any time the sum of
        // sizes of all records contained *plus* the amount of memory allocated
        // by this object is guaranteed to be less than or equal to the
        // specified &#39;maxTotalSize&#39;.  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.  The behavior is undefined
        // unless &#39;maxTotalSize &gt; 0&#39;.

    virtual ~FixedSizeRecordBuffer();
        // Remove all record handles from this record buffer and destroy this
        // record buffer.

    // MANIPULATORS
    virtual void beginSequence();
        // *Lock* this record buffer so that a sequence of method invocations
        // on this record buffer can occur uninterrupted by other threads.  The
        // buffer will remain *locked* until &#39;endSequence&#39; is called.  It is
        // valid to invoke other methods on this record buffer between the
        // calls to &#39;beginSequence&#39; and &#39;endSequence&#39; (the implementation
        // guarantees this by employing a recursive mutex).

    virtual void endSequence();
        // *Unlock* this record buffer, thus allowing other threads to access
        // it.  The behavior is undefined unless the buffer is already *locked*
        // by &#39;beginSequence&#39;.

    virtual void popBack();
        // Remove from this record buffer the record handle positioned at the
        // back end of the buffer.  The behavior is undefined unless
        // &#39;0 &lt; length()&#39;.

    virtual void popFront();
        // Remove from this record buffer the record handle positioned at the
        // front end of the buffer.  The behavior is undefined unless
        // &#39;0 &lt; length()&#39;.

    virtual int pushBack(const bsl::shared_ptr&lt;Record&gt;&amp; handle);
        // Push the specified &#39;handle&#39; at the back end of this record buffer.
        // Return 0 on success, and a non-zero value otherwise.  In order to
        // accommodate a record, the records from the front end of the buffer
        // may be removed.  If a record can not be accommodated in the buffer,
        // it is silently discarded.

    virtual int pushFront(const bsl::shared_ptr&lt;Record&gt;&amp; handle);
        // Push the specified &#39;handle&#39; at the front end of this record buffer.
        // Return 0 on success, and a non-zero value otherwise.  In order to
        // accommodate a record, the records from the end end of the buffer may
        // be removed.  If a record can not be accommodated in the buffer, it
        // is silently discarded.

    virtual void removeAll();
        // Remove all record handles stored in this record buffer.  Note that
        // &#39;length()&#39; is now 0.

    // ACCESSORS
    virtual const bsl::shared_ptr&lt;Record&gt;&amp; back() const;
        // Return a reference of the shared pointer referring to the record
        // positioned at the back end of this record buffer.  The behavior is
        // undefined unless this record buffer has been locked by the
        // &#39;beginSequence&#39; method and unless &#39;0 &lt; length()&#39;.

    virtual const bsl::shared_ptr&lt;Record&gt;&amp; front() const;
        // Return a reference of the shared pointer referring to the record
        // positioned at the front end of this record buffer.  The behavior is
        // undefined unless this record buffer has been locked by the
        // &#39;beginSequence&#39; method and unless &#39;0 &lt; length()&#39;.

    virtual int length() const;
        // Return the number of record handles in this record buffer.
};

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                          // ---------------------------
                          // class FixedSizeRecordBuffer
                          // ---------------------------

// CREATORS
inline
FixedSizeRecordBuffer::FixedSizeRecordBuffer(int               maxTotalSize,
                                             bslma::Allocator *basicAllocator)
: d_maxTotalSize(maxTotalSize)
, d_currentTotalSize(0)
, d_allocator(basicAllocator)
, d_deque(&amp;d_allocator)
{
}

// MANIPULATORS
inline
void FixedSizeRecordBuffer::beginSequence()
{
    d_mutex.lock();
}

inline
void FixedSizeRecordBuffer::endSequence()
{
    d_mutex.unlock();
}

inline
void FixedSizeRecordBuffer::removeAll()
{
    bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
    d_deque.clear();
    d_currentTotalSize = 0;
}

// ACCESSORS
inline
const bsl::shared_ptr&lt;Record&gt;&amp; FixedSizeRecordBuffer::back() const
{
    bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
    return d_deque.back();
}

inline
const bsl::shared_ptr&lt;Record&gt;&amp; FixedSizeRecordBuffer::front() const
{
    bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
    return d_deque.front();
}

inline
int FixedSizeRecordBuffer::length() const
{
    bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
    return static_cast&lt;int&gt;(d_deque.size());
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
