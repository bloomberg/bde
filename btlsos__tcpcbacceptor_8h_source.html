<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlsos_tcpcbacceptor.h                                             -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLSOS_TCPCBACCEPTOR
#define INCLUDED_BTLSOS_TCPCBACCEPTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a non-blocking acceptor of TCP connections.
//
//@CLASSES:
//  btlsos::TcpCbAcceptor: non-blocking channel allocator
//
//@SEE_ALSO: btlsos_tcptimedcbchannel btlso_tcptimereventmanager
//           btlsos_tcpcbconnector btlsos_tcpcbchannel
//           btlso_socketoptutil btesos_streamsocketfactory
//
//@DESCRIPTION: This component provides a non-blocking single-port acceptor of
// TCP connections, &#39;btlsos::TcpCbAcceptor&#39;, with the capability that adheres
// to the &#39;btlsc::CbChannelAllocator&#39; protocol.  Both timed and non-timed
// (callback) channels can be allocated in a non-timed fashion as indicated by
// the following table:
//
// Allocations follow the asynchronous (callback-based) nature of the &#39;btesc&#39;
// protocol; the callbacks are invoked when an allocation succeeds or an error
// occurs.  The acceptor uses the user-installed socket event manager in order
// to monitor (in a non-blocking fashion) the listening socket for incoming
// connection requests.
//
// The acceptor has the flexibility of opening and closing a listening socket
// with no effect on any existing channels managed by this object.  The
// enqueued (i.e., not-yet-completed) allocation requests will, however, fail
// (without invalidating the allocator) and the associated callbacks will be
// invoked when the listening port is closed.
//
///Thread Safety
///-------------
// The acceptor is *thread* *safe*, meaning that any operation can be called on
// *distinct instances* from different threads without any side-effects (which,
// generally speaking, means that there is no &#39;static&#39; data), but not *thread*
// *enabled* (i.e., two threads cannot safely call methods on the *same*
// *instance* without external synchronization).  This acceptor is not
// *async-safe*, meaning that one or more functions cannot be invoked safely
// from a signal handler.  Note that the thread safety of the acceptor is
// subject to the thread safety of the supplied socket event manager.  If
// distinct instances of acceptor use the *same* instance of a socket event
// manager, both acceptors are thread-safe if and only if that socket event
// manager is *THREAD* *ENABLED*.
//
///Usage
///-----
// The following usage example shows a possible implementation of a multi-user
// echo server.  An echo server accepts connections and, for every connection,
// sends any received data back to the client (until the connection is
// terminated).  This server requires that data is read from an accepted
// connection within a certain time interval or else the connection is dropped
// on timeout.  The echo server is implemented as a separate class
// (&#39;my_EchoServer&#39;) that owns the timed callback acceptor.  Various
// configuration parameters such as the timeout values, the queue size and
// input buffer size, and the default port number (as mandated by RFC 862) are
// constants within this class.
//..
//  class my_EchoServer {
//      // This class implements a simple multi-user echo server as specified
//      // by the RFC 862.
//
//      enum {
//          k_READ_SIZE           =  200,  // The number of bytes to be read
//                                         // can be changed, but a larger
//                                         // &#39;k_READ_SIZE&#39; will require the
//                                         // client to input more data to be
//                                         // echoed.
//          k_DEFAULT_PORT_NUMBER = 9234,  // As specified by the RFC 862
//          k_QUEUE_SIZE          =   16
//      };
//
//      btlsos::TcpCbAcceptor  d_allocator;
//      bsls::TimeInterval     d_acceptTimeout;
//      bsls::TimeInterval     d_readTimeout;
//      bsls::TimeInterval     d_writeTimeout;
//
//      bsl::function&lt;void(btlsc::TimedCbChannel*, int)&gt;
//                             d_allocateFunctor;
//                                         // Cached callback functor.
//
//      bslma::Allocator      *d_allocator_p;
//      char                   d_buffer[k_READ_SIZE];
//
//    private:
//      // Callbacks
//      void allocateCb(btlsc::TimedCbChannel *channel, int status);
//          // Invoked from the socket event manager when a connection is
//          // allocated (i.e., accepted) or an error occurs when allocating.
//          // [...]
//
//      void bufferedReadCb(const char            *buffer,
//                          int                    status,
//                          int                    asyncStatus,
//                          btlsc::TimedCbChannel *channel);
//          // Invoked from the socket event manager when data is read.  [...]
//
//      void readCb(int                    status,
//                  int                    asyncStatus,
//                  btlsc::TimedCbChannel *channel);
//          // Invoked from the socket event manager when data is read.  [...]
//
//      void writeCb(int                    status,
//                   int                    asyncStatus,
//                   btlsc::TimedCbChannel *channel,
//                   int                    numBytes);
//          // Invoked from the socket event manager when data is written.
//          // [...]
//
//    private:
//      // Not implemented:
//      my_EchoServer(const my_EchoServer&amp;);
//      my_EchoServer&amp; operator=(const my_EchoServer&amp;);
//
//    public:
//      // CREATORS
//      my_EchoServer(
//             btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
//             btlso::TimerEventManager                       *manager,
//             bslma::Allocator                               *basicAllocator);
//          // Create an echo server that uses the specified stream socket
//          // &#39;factory&#39; for the system sockets and the specified socket event
//          // &#39;manager&#39; to multiplex the events on these sockets.  The
//          // behavior is undefined if either &#39;factory&#39; or &#39;manager&#39; is 0.
//
//      ~my_EchoServer();
//          // Destroy this server.  The behavior is undefined unless the
//          // server is shut down properly (i.e., via &#39;close&#39;).
//
//      // MANIPULATORS
//      int open(int portNumber = k_DEFAULT_PORT_NUMBER);
//          // Establish a listening socket on the optionally specified
//          // &#39;portNumber&#39;; return 0 on success, and a non-zero value
//          // otherwise.  The behavior is undefined unless &#39;0 &lt;= portNumber&#39;
//          // and the listening port is not currently open.
//
//      int close();
//          // Close the listening socket; return 0 on success and a non-zero
//          // value otherwise.  The behavior is undefined unless the listening
//          // socket is currently open.
//  };
//..
// The implementation of the public methods of &#39;my_EchoServer&#39; is trivial.  For
// the constructor, the socket factory and socket event manager are passed to
// the acceptor, and the allocate callback and (three) event timeouts are
// initialized.  The &#39;open&#39; and &#39;close&#39; methods just invoke appropriate methods
// of the acceptor.  The destructor ensures that the state of the acceptor is
// valid:
//..
//  // CREATORS
//  my_EchoServer::my_EchoServer(
//              btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
//              btlso::TimerEventManager                       *manager,
//              bslma::Allocator                               *basicAllocator)
//  : d_allocator(factory, manager, basicAllocator)
//  , d_acceptTimeout(120, 0)
//  , d_readTimeout(5, 0)
//  , d_writeTimeout(5.0)
//  , d_allocator_p(basicAllocator)
//  {
//      assert(factory);
//      assert(manager);
//      d_allocateFunctor = bsl::function&lt;void(btlsc::TimedCbChannel *, int)&gt;(
//          bsl::allocator_arg_t(),
//          bsl::allocator&lt;bsl::function&lt;void(btlsc::TimedCbChannel *, int)&gt; &gt;(
//              basicAllocator),
//          bdlf::MemFnUtil::memFn(&amp;my_EchoServer::allocateCb, this));
//  }
//
//  my_EchoServer::~my_EchoServer() {
//  }
//
//  // MANIPULATORS
//  int my_EchoServer::open(int portNumber) {
//      btlso::IPv4Address serverAddress;
//      serverAddress.setPortNumber(portNumber);
//      int s = d_allocator.open(serverAddress, k_QUEUE_SIZE);
//      if (s) {
//          cout &lt;&lt; &quot;Failed to open listening port.&quot; &lt;&lt; endl;
//          return s;                                                 // RETURN
//      }
//      cout &lt;&lt; &quot;server&#39;s socket: &quot; &lt;&lt; d_allocator.address() &lt;&lt; endl;
//      assert(0 == d_allocator.isInvalid());
//      s = d_allocator.allocateTimed(d_allocateFunctor);
//      if (s) {
//          cout &lt;&lt; &quot;Can&#39;t enqueue an allocation request.&quot; &lt;&lt; endl;
//          assert(d_allocator.isInvalid());
//          d_allocator.close();
//          return s;                                                 // RETURN
//      }
//      return 0;
//  }
//
//  int my_EchoServer::close() {
//      return d_allocator.close();
//  }
//..
// All the work of accepting connections and reading/writing the data is done
// in the (private) callback methods of &#39;my_EchoServer&#39;.  When the connection
// is established and the &#39;allocateCb&#39; method is invoked, the buffered read
// with timeout is initiated on the channel and another allocation request is
// enqueued.  If any error occurs while allocating, the acceptor is shut down.
// If any error, including timeout, occurs while reading or writing data, the
// channel is shut down.  Note that the allocation functor is cached to improve
// performance:
//..
//  void my_EchoServer::allocateCb(btlsc::TimedCbChannel *channel,
//                                 int                    status) {
//      if (channel) {
//          // Accepted a connection.  Issue a read raw request.
//          bsl::function&lt;void(int, int)&gt; callback(bdlf::BindUtil::bindA(
//                        d_allocator_p,
//                        bdlf::MemFnUtil::memFn(&amp;my_EchoServer::readCb, this),
//                        _1,
//                        _2,
//                        channel));
//
//          if (channel-&gt;timedReadRaw(d_buffer,
//                                    k_READ_SIZE,
//                                    bdlt::CurrentTime::now()
//                                                + d_readTimeout, callback)) {
//              cout &lt;&lt; &quot;Failed to enqueue buffered read request.&quot; &lt;&lt; endl;
//              d_allocator.deallocate(channel);
//          }
//          if (d_allocator.allocateTimed(d_allocateFunctor)) {
//              d_allocator.close();
//          }
//          return;                                                   // RETURN
//      }
//      assert(0 &gt;= status);    // Interrupts are not enabled.
//      if (0 == status) {
//          // Re-register the functor
//          if (d_allocator.allocateTimed(d_allocateFunctor)) {
//              d_allocator.close();
//          }
//      }
//      else if (-1 == status) {
//          cout &lt;&lt; &quot;Allocation request was dequeued.&quot; &lt;&lt; endl;
//      }
//      else {
//          // Hard-error accepting a connection, invalidate the allocator.
//          cout &lt;&lt; &quot;Hard error while accepting a connection: &quot; &lt;&lt; status
//               &lt;&lt; endl;
//          d_allocator.invalidate();
//      }
//  }
//
//  void my_EchoServer::bufferedReadCb(const char            *buffer,
//                                     int                    status,
//                                     int                    asyncStatus,
//                                     btlsc::TimedCbChannel *channel)
//  {
//      cout &lt;&lt; &quot;my_EchoServer::bufferedReadCb: &quot;
//           &lt;&lt; &quot; read &quot; &lt;&lt; status &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;
//      assert(channel);
//      if (0 &lt; status) {
//          bsl::function&lt;void(int, int)&gt; callback(bdlf::BindUtil::bindA(
//                       d_allocator_p,
//                       bdlf::MemFnUtil::memFn(&amp;my_EchoServer::writeCb, this),
//                       _1,
//                       _2,
//                       channel,
//                       status));
//
//          if (channel-&gt;timedBufferedWrite(buffer,
//                                          status,
//                                          bdlt::CurrentTime::now()
//                                               + d_writeTimeout, callback)) {
//              cout &lt;&lt; &quot;Failed to enqueue write request&quot; &lt;&lt; endl;
//              d_allocator.deallocate(channel);
//              return;                                               // RETURN
//          }
//          // Re-register read request
//          bsl::function&lt;void(const char *, int, int)&gt; readCallback(
//              bdlf::BindUtil::bindA(
//                       d_allocator_p,
//                       bdlf::MemFnUtil::memFn(&amp;my_EchoServer::bufferedReadCb,
//                                              this),
//                       _1,
//                       _2,
//                       _3,
//                       channel));
//
//          if (channel-&gt;timedBufferedRead(k_READ_SIZE,
//                   bdlt::CurrentTime::now() + d_readTimeout, readCallback)) {
//              cout &lt;&lt; &quot;Failed to enqueue read request.&quot; &lt;&lt; endl;
//              d_allocator.deallocate(channel);
//          }
//      }
//      else if (0 == status) {
//          if (0 &gt; asyncStatus) {
//              cout &lt;&lt; &quot;Callback dequeued&quot; &lt;&lt; endl;
//          }
//          else {
//              cout &lt;&lt; &quot;Timed out on read&quot; &lt;&lt; endl;
//              d_allocator.deallocate(channel);
//          }
//      }
//      else {
//          // Either time out or an error on the channel
//          cout &lt;&lt; &quot;Failed to read data.&quot; &lt;&lt; endl;
//          d_allocator.deallocate(channel);
//      }
//  }
//
//  void my_EchoServer::readCb(int                    status,
//                             int                    asyncStatus,
//                             btlsc::TimedCbChannel *channel)
//  {
//      cout &lt;&lt; &quot;my_EchoServer::readCb: &quot;
//           &lt;&lt; &quot; read &quot; &lt;&lt; status &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;
//      assert(channel);
//      if (0 &lt; status) {
//          bsl::function&lt;void(int, int)&gt; callback(
//              bdlf::BindUtil::bindA(
//                       d_allocator_p,
//                       bdlf::MemFnUtil::memFn(&amp;my_EchoServer::writeCb, this),
//                       _1,
//                       _2,
//                       channel,
//                       status));
//
//          if (channel-&gt;timedBufferedWrite(d_buffer,
//                                          status,
//                                          bdlt::CurrentTime::now()
//                                                 + d_writeTimeout, callback))
//              {
//                  cout &lt;&lt; &quot;Failed to enqueue write request&quot; &lt;&lt; endl;
//                  d_allocator.deallocate(channel);
//                  return;                                           // RETURN
//              }
//          // Re-register read request
//          bsl::function&lt;void(int, int)&gt; readCallback(
//                bdlf::BindUtil::bindA(
//                        d_allocator_p,
//                        bdlf::MemFnUtil::memFn(&amp;my_EchoServer::readCb, this),
//                        _1,
//                        _2,
//                        channel));
//
//          if (channel-&gt;timedReadRaw(d_buffer, k_READ_SIZE,
//                                    bdlt::CurrentTime::now()
//                                            + d_readTimeout, readCallback)) {
//              cout &lt;&lt; &quot;Failed to enqueue read request.&quot; &lt;&lt; endl;
//              d_allocator.deallocate(channel);
//          }
//      }
//      else if (0 == status) {
//          if (0 &gt; asyncStatus) {
//              cout &lt;&lt; &quot;Callback dequeued&quot; &lt;&lt; endl;
//          }
//          else {
//              cout &lt;&lt; &quot;Timed out on read&quot; &lt;&lt; endl;
//              d_allocator.deallocate(channel);
//          }
//      }
//      else {
//          // Either time out or an error on the channel
//          cout &lt;&lt; &quot;Failed to read data.&quot; &lt;&lt; endl;
//          d_allocator.deallocate(channel);
//      }
//  }
//
//  void my_EchoServer::writeCb(int                    status,
//                              int                    asyncStatus,
//                              btlsc::TimedCbChannel *channel,
//                              int                    numBytes)
//  {
//      (void)asyncStatus;
//      if (status != numBytes) {
//          cout &lt;&lt; &quot;Failed to send data.&quot; &lt;&lt; endl;
//          channel-&gt;invalidate();
//          d_allocator.deallocate(channel);
//      }
//  }
//..
// Finally, we define the &#39;main&#39; function, which will create the concrete
// socket factory and concrete socket event manager, create &#39;my_EchoServer&#39; as
// required, and go into &quot;infinite&quot; loop dispatching registered callbacks:
//..
//  bslma::TestAllocator testAllocator;
//  testAllocator.setNoAbort(1);
//
//  btlso::InetStreamSocketFactory&lt;btlso::IPv4Address&gt; factory(&amp;testAllocator);
//
//  btlso::TcpTimerEventManager::Hint hint
//                                = btlso::TcpTimerEventManager::e_NO_HINT;
//
//  btlso::TcpTimerEventManager manager(hint, &amp;testAllocator);
//  my_EchoServer               echoServer(&amp;factory, &amp;manager, &amp;testAllocator);
//
//  if (echoServer.open()) {
//      cout &lt;&lt; &quot;Can&#39;t open listening socket.&quot; &lt;&lt; endl;
//      break; // return -1;
//  }
//
//  for (int i = 0; i &lt; 100; ++i) {
//      // Do it for the finite number of times.
//      int cbs = manager.dispatch(0);
//      assert(0 &lt; cbs);
//  }
//  echoServer.close();
//  // We need another round of dispatch for cleaning things up.
//  int cbs = manager.dispatch(0);
//  assert(0 &lt; cbs);
//  assert(0 == testAllocator.numMismatches());
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLSC_CBCHANNELALLOCATOR
#include &lt;btlsc_cbchannelallocator.h&gt;
#endif

#ifndef INCLUDED_BTLSO_IPV4ADDRESS
#include &lt;btlso_ipv4address.h&gt;
#endif

#ifndef INCLUDED_BDLMA_POOL
#include &lt;bdlma_pool.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSL_DEQUE
#include &lt;bsl_deque.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace btlso { template&lt;class ADDRESS&gt; class StreamSocketFactory; }
namespace btlso { template&lt;class ADDRESS&gt; class StreamSocket; }
namespace btlso { class TimerEventManager; }
namespace btlsos {class TcpCbAcceptor_Reg; // component-local class declaration

                           // ===================
                           // class TcpCbAcceptor
                           // ===================

class TcpCbAcceptor : public btlsc::CbChannelAllocator {
    // This class implements a &#39;btesc&#39;-style callback-based channel allocator
    // for a single server-side (i.e., listening) TCP/IPv4 socket.  The
    // allocation requests&#39; callbacks are queued and invoked as appropriate.
    // The status supplied to the callback is negative for failure and positive
    // for a (restartable) interruption on an underlying system call.  A status
    // value of -1 indicates an allocation attempt on an uninitialized acceptor
    // (i.e., no listening socket is established), and a status value of -2
    // indicates failure due to the listening socket being closed.  The
    // acceptor provides a &quot;delayed open&quot; (where a listening socket is
    // established at some point after construction), and allows the listening
    // socket to be closed (and opened again) with no effect on the state of
    // any other channel currently managed by this acceptor.

    bdlma::Pool          d_callbackPool;     // memory pool for registrations
    bdlma::Pool          d_channelPool;      // memory pool for channels

    bsl::deque&lt;TcpCbAcceptor_Reg *&gt;
                         d_callbacks;        // registered callbacks

    bsl::vector&lt;btlsc::CbChannel*&gt;
                         d_channels;         // managed channels

    btlso::TimerEventManager
                        *d_manager_p;

    btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;
                        *d_factory_p;        // factory used to supply sockets

    btlso::StreamSocket&lt;btlso::IPv4Address&gt;
                        *d_serverSocket_p;   // listening socket

    btlso::IPv4Address   d_serverAddress;    // address of listening socket

    int                  d_isInvalidFlag;    // set if acceptor is invalid

    bsl::function&lt;void()&gt;
                         d_acceptFunctor;    // cached callbacks

    TcpCbAcceptor_Reg   *d_currentRequest_p; // address of the current request

    bslma::Allocator    *d_allocator_p;

  private:
    // Callbacks for socket event manager

    void acceptCb();
        // Invoked from socket event manager when an event occurs on the
        // listening socket.

    void deallocateCb(btlsc::CbChannel *channel);
        // Deallocate resources used by the specified &#39;channel&#39;.  Invoked from
        // timer event manager.

  private:
    // Not implemented:
    TcpCbAcceptor(const TcpCbAcceptor&amp;);
    TcpCbAcceptor&amp; operator=(const TcpCbAcceptor&amp;);

  public:
    // CREATORS
    TcpCbAcceptor(
           btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
           btlso::TimerEventManager                       *manager,
           bslma::Allocator                               *basicAllocator = 0);
        // Create a callback acceptor that uses the specified &#39;factory&#39; (to
        // create stream sockets) and the specified &#39;manager&#39; (to monitor for
        // incoming connections).  Optionally specify a &#39;basicAllocator&#39; used
        // to supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.  The behavior is undefined if either
        // &#39;factory&#39; or &#39;manager&#39; is 0.  Note that the acceptor is created in a
        // valid state (as reported by the &#39;isInvalid&#39; method) and subsequent
        // allocation requests will be enqueued successfully, but that such
        // allocations will fail with a status of -1 until the listening socket
        // is created (using &#39;open&#39;).

    TcpCbAcceptor(
           btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
           btlso::TimerEventManager                       *manager,
           int                                             numElements,
           bslma::Allocator                               *basicAllocator = 0);
        // Create a callback acceptor, with enough internal capacity to
        // accommodate up to the specified &#39;numElements&#39; channels without
        // reallocation, that uses the specified &#39;factory&#39; to create stream
        // sockets and the specified &#39;manager&#39; to monitor for incoming
        // connections.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.  &#39;delete&#39; are used.  The behavior is undefined if
        // either &#39;factory&#39; or &#39;manager&#39; is 0 and unless &#39;0 &lt; numElements&#39;.
        // Note that the acceptor is created in a valid state (as reported by
        // the &#39;isInvalid&#39; method) and that subsequent allocation requests will
        // be enqueued successfully, but the allocations will fail with a
        // status of -1 until the listening socket is created (using &#39;open&#39;).

    ~TcpCbAcceptor();
        // Invalidate this allocator, close the listening socket, invoke all
        // pending callbacks, destroy all managed channels, and destroy this
        // allocator.

    // MANIPULATORS
    virtual int allocate(const Callback&amp; callback, int flags = 0);
        // Initiate a non-blocking operation to allocate a callback channel;
        // execute the specified &#39;callback&#39; functor after the allocation
        // operation terminates.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt the allocation; by default, such events
        // are ignored.  Return 0 on successful initiation, and a non-zero
        // value otherwise (in which case &#39;callback&#39; will not be invoked).
        //
        // When invoked, &#39;callback&#39; is passed the (possibly null) address of a
        // callback channel and an integer &quot;status&quot;.  If that address is not 0,
        // the allocation succeeded and status has no meaning; a non-null
        // channel address will remain valid until deallocated explicitly (see
        // &#39;deallocate&#39;).  If the address is 0, a positive status indicates an
        // interruption due to an asynchronous event; subsequent allocation
        // attempts may succeed.  A status of -1 implies that the allocation
        // operation was &quot;canceled&quot; (synchronously) by the caller (see
        // &#39;cancelAll&#39;) and, often, may be retried successfully.  A status less
        // than -1 indicates a more persistent error, but not necessarily a
        // permanent one; the allocator itself may still be valid (see
        // &#39;isInvalid&#39;).  The behavior is undefined unless &#39;callback&#39; is valid.

    int allocateTimed(const TimedCallback&amp; timedCallback, int flags = 0);
        // Initiate a non-blocking operation to allocate a timed callback
        // channel; execute the specified &#39;timedCallback&#39; functor after the
        // allocation operation terminates.  If the optionally specified
        // &#39;flags&#39; incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous
        // events&quot; are permitted to interrupt the allocation; by default, such
        // events are ignored.  Return 0 on successful initiation, and a
        // non-zero value otherwise (in which case &#39;timedCallback&#39; will not be
        // invoked).
        //
        // When invoked, &#39;timedCallback&#39; is passed the (possibly null) address
        // of a timed callback channel and an integer &quot;status&quot;.  If that
        // address is not 0, the allocation succeeded and status has no
        // meaning; a non-null channel address will remain valid until
        // deallocated explicitly (see &#39;deallocate&#39;).  If the address is 0, a
        // positive status indicates an interruption due to an asynchronous
        // event; subsequent allocation attempts may succeed.  A status of -1
        // implies that the allocation operation was &quot;canceled&quot; (synchronously)
        // by the caller (see &#39;cancelAll&#39;) and, often, may be retried
        // successfully.  A status less than -1 indicates a more persistent
        // error, but not necessarily a permanent one; the allocator itself may
        // still be valid (see &#39;isInvalid&#39;).  The behavior is undefined unless
        // &#39;callback&#39; is valid.

    virtual void cancelAll();
        // Immediately cancel all pending operations on this allocator,
        // invoking each registered allocation callback in turn.  Each callback
        // will be invoked with a null channel and a status of -1.  This method
        // may be invoked successfully on an invalid allocator; however,
        // calling the method does not invalidate the allocator.  Note that
        // calling &#39;cancelAll&#39; from a callback that has itself been canceled
        // simply extends the set of canceled operations to include any new
        // ones initiated since the previous &#39;cancelAll&#39; was invoked.

    int close();
        // Close the listening socket and invoke all enqueued callbacks with a
        // status of -2.  Return 0 on success, and a non-zero value otherwise.
        // A listening socket yields a non-zero server address (see &#39;address&#39;).
        // The behavior is undefined unless the listening socket is
        // successfully established.  Note that closing a listening port has no
        // effect on any other channel managed by this allocator.

    virtual void deallocate(btlsc::CbChannel *channel);
        // Terminate all operations on the specified &#39;channel&#39;, invoke each
        // pending callback with the appropriate status, and reclaim all
        // afforded channel services.  The behavior is undefined unless
        // &#39;channel&#39; is currently allocated from this allocator, (i.e., was
        // previously obtained from this instance and has not subsequently been
        // deallocated).  Note that this method can never block.

    virtual void invalidate();
        // Place this allocator in a permanently invalid state.  No subsequent
        // allocations will succeed.  Note that invalidating this allocator has
        // no effect on the state of any channel managed by it nor on the
        // listening socket, which, if established, must be closed explicitly
        // (using the &#39;close&#39; method).

    int open(const btlso::IPv4Address&amp; endpoint,
             int                       queueSize,
             int                       reuseAddress = 1);
        // Establish a listening socket having the specified &#39;queueSize&#39;
        // maximum number of pending connections on the specified &#39;endpoint&#39;.
        // Optionally specify a &#39;reuseAddress&#39; value to be used for setting
        // &#39;REUSEADDRESS&#39; option.  If &#39;reuseAddress&#39; is not specified, 1 (i.e.,
        // if the REUSEADDRESS option is enabled) is used.  Return 0 on
        // success, and a non-zero value otherwise.  The behavior is undefined
        // unless &#39;0 &lt; queueSize&#39; and the listening socket is closed.

    int setOption(int level, int option, int value);
        // Set the specified socket &#39;option&#39; having the specified &#39;level&#39; on
        // the listening socket to the specified &#39;value&#39;.  Return 0 on success
        // and a non-zero value otherwise.  (The list of commonly supported
        // options is available in &#39;btlso_socketoptutil&#39;.)  The behavior is
        // undefined unless the listening socket is established.  Note that all
        // sockets allocated from this acceptor will inherit the options&#39;
        // values set on the listening socket.

    // ACCESSORS
    const btlso::IPv4Address&amp; address() const;
        // Return the (fully qualified) address of the listening socket, or an
        // invalid address &#39;(ANY_ADDRESS, ANY_PORT)&#39; if the server is not
        // established (see &#39;btlso_ipv4address&#39;).

    int getOption(int *result, int level, int option) const;
        // Load into the specified &#39;result&#39; the current value of the specified
        // &#39;option&#39; of the specified &#39;level&#39; set on the listening socket.
        // Return 0 on success and a non-zero value otherwise.  The list of
        // commonly supported options (and levels) is enumerated in
        // &#39;btlso_socketoptutil&#39;.  The behavior is undefined if &#39;result&#39; is 0
        // and unless the listening socket has been established.

    virtual int isInvalid() const;
        // Return 1 if this channel allocator is *permanently* invalid (i.e.,
        // no subsequent allocation requests will succeed).

    int numChannels() const;
        // Return the number of channels currently allocated from this
        // acceptor.
};

// ----------------------------------------------------------------------------
//                             INLINE DEFINITIONS
// ----------------------------------------------------------------------------

inline
const btlso::IPv4Address&amp; TcpCbAcceptor::address() const
{
    return d_serverAddress;
}

inline
int TcpCbAcceptor::numChannels() const
{
    return static_cast&lt;int&gt;(d_channels.size());
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
