<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlmt_tcptimereventmanager Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlmt_tcptimereventmanager<br/>
<small>
[<a class="el" href="group__btlmt.html">Package btlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-enabled multiplexor of socket events and timers.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlmt.html">btlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Performance</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Basic Syntax</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-enabled multiplexor of socket events and timers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html">btlmt::TcpTimerEventManager</a> </td><td>thread-enabled socket event/timer multiplexor  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlmt__channelpool.html" title="Provide thread-enabled stream-based IPv4 communication.">Component btlmt_channelpool</a> <a class="el" href="group__bdlmt__threadpool.html" title="Provide portable implementation for a dynamic pool of threads.">Component bdlmt_threadpool</a> <a class="el" href="group__bslmt__threadutil.html" title="Provide platform-independent utilities related to threading.">Component bslmt_threadutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a concrete implementation of a thread-enabled multiplexer for socket events and timers. An interested party can register a callback to be invoked whenever a particular event occurs on a particular socket, or when a timer expires. Socket events have a permanent semantics (i.e., once registered, a callback is invoked until it is explicitly deregistered). Timers have "one-time" semantics (i.e., a timer callback is invoked at most once). Registering the same socket handle and the same event with different instances of this event manager may result in undefined behavior. The timers are unstable with respect to registration; that is, if two timer callbacks are registered with the same time, they maybe invoked in an order different from the order of registration. Socket events take priority over timers; if a socket event and a timer occur at the same time, a socket event callback is invoked first. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>All registered callbacks are invoked from an internal thread managed by <code>this</code> event manager if its underlying thread is enabled (see below). If the thread is disabled, the queries and registrations are processed (in a thread-safe fashion) but no callbacks are invoked. On UNIX platforms all signals are disabled for this thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An event manager can optimize its performance based on a hint provided at construction. Generally speaking, a particular usage falls into two categories: socket events are registered: 1)frequently, and 2)infrequently. On some platforms, a significant performance improvement can be achieved if the registrations are infrequent. For this situation, the appropriate hint should be provided to this event manager at construction for optimal performance. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This event manager is <em>thread</em> <em>safe</em>, i.e., operations can be invoked simultaneously on a single instance of this event manager from multiple threads without undesirable side-effects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To the extent that this component uses local synchronization primitives internally to protect access to different pieces of private data, and to maximize the ability of different threads to operate concurrently on a single instance of this component, it is <em>thread</em> <em>enabled</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is not <em>async-safe</em>, i.e., one or more methods cannot be invoked safely from a signal handler. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance"></a> <a class="anchor" id="description.performance"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Performance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component minimizes the number of system calls for the set of callbacks. A significant performance improvement can be achieved if an appropriate registration frequency "hint" is provided. Supplying a false hint (e.g., indicating infrequent registration when the reverse is true) may result in significant performance degradation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Given that T is the number of timers registered and S is the number of socket events registered, the following complexity is guaranteed by this component: <br/>
<br/>
<div class="fragment"><pre class="fragment">  NOTE: The following table is a place holder and needs to be rethought.
  +========================================================================+
  |        FUNCTION          | EXPECTED COMPLEXITY | WORST CASE COMPLEXITY |
  +------------------------------------------------------------------------+
  | registerTimer            |      O(log[T])      |      O(log[T])        |
  +------------------------------------------------------------------------+
  | deregisterTimer          |        O(T)         |        O(T)           |
  +------------------------------------------------------------------------+
  | registerSocketEvent      |        O(1)         |        O(S)           |
  +------------------------------------------------------------------------+
  | deregisterSocketEvent    |        O(1)         |        O(S)           |
  +------------------------------------------------------------------------+
  | isRegistered             |        O(1)         |        O(S)           |
  +------------------------------------------------------------------------+
  | deregisterSocket         |        O(1)         |        O(S)           |
  +------------------------------------------------------------------------+
  | deregisterAllSocketEvents|        O(S)         |        O(S)           |
  +------------------------------------------------------------------------+
  | deregisterAllTimers      |        O(T)         |        O(T)           |
  +------------------------------------------------------------------------+
  | deregisterAll            |       O(S+T)        |       O(S+T)          |
  +------------------------------------------------------------------------+
  | numEvents                |        O(1)         |        O(1)           |
  +------------------------------------------------------------------------+
  | numTimers                |        O(1)         |        O(1)           |
  +------------------------------------------------------------------------+
  | numSocketEvents          |        O(1)         |        O(S)           |
  +========================================================================+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_syntax"></a> <a class="anchor" id="usage.example_1~3A_basic_syntax"></a> <a class="anchor" id="description.usage.example_1~3A_basic_syntax"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Syntax: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following usage example, we demonstrate how to use timer functionality provided by <code><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html">btlmt::TcpTimerEventManager</a></code>. For simplicity, we simulate enqueueing a job to a queue periodically. Let's assume that a job is represented by an integer. First, let's implement a function that enqueues a job to a given queue. This function will also re-register the "next" timer with the event manager since timers have "one-time" semantics. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> producer(<a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;int&gt;</a>           *workQueue,
                       <a class="code" href="classbtlmt_1_1TcpTimerEventManager.html">btlmt::TcpTimerEventManager</a> *manager,
                       <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>           nextTime)
      <span class="comment">// Enqueue a work item onto the specified &#39;workQueue&#39; and register</span>
      <span class="comment">// this function with the specified &#39;manager&#39; to be invoked after</span>
      <span class="comment">// the specified &#39;nextTime&#39; absolute time interval.</span>
  {
      assert(workQueue);
      assert(manager);

      <span class="keyword">enum</span> { TIME_OFFSET = 50 };   <span class="comment">// invoke timer every 50 milliseconds</span>

      <span class="keywordtype">int</span> item = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>().<a class="code" href="classbsls_1_1TimeInterval.html#a6a37e5f3c58f4e02724d5fc6321d4d08">nanoseconds</a>() / 1000;
      workQueue-&gt;<a class="code" href="classbdlcc_1_1Queue.html#a7835a8aad26ca5685dae884a0bc19d46">pushBack</a>(item);

      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> nextNextTime(nextTime);
      nextNextTime.addMilliseconds(TIME_OFFSET);
      bsl::function&lt;void()&gt; callback(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;producer,
                                                          workQueue,
                                                          manager,
                                                          nextNextTime));

      <span class="keywordtype">void</span> *timerId = manager-&gt;<a class="code" href="classbtlmt_1_1TcpTimerEventManager.html#a1453c33da941f40b7213eb92620cd2ce">registerTimer</a>(nextTime, callback);
      assert(timerId);
  }
</pre></div><br/>
<br/>
 Second, implement the main function. In main, create a work queue and a timer event manager, register with the event manager an initial timer with its callback and begin monitoring the work queue: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main() {
      <span class="keyword">enum</span> {
          TIME_OFFSET         = 50, <span class="comment">// milliseconds</span>
          INITIAL_TIME_OFFSET = 10  <span class="comment">// milliseconds</span>
      };

      <a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;int&gt;</a> workQueue(&amp;testAllocator);;
      <a class="code" href="classbtlmt_1_1TcpTimerEventManager.html">btlmt::TcpTimerEventManager</a> manager(&amp;testAllocator);;

      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> now = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();
      now.<a class="code" href="classbsls_1_1TimeInterval.html#a3a9b0877a484895dedd181d7ae10e83c">addMilliseconds</a>(INITIAL_TIME_OFFSET);
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> nextTime(now);
      nextTime.<a class="code" href="classbsls_1_1TimeInterval.html#a3a9b0877a484895dedd181d7ae10e83c">addMilliseconds</a>(TIME_OFFSET);

      bsl::function&lt;void()&gt; callback(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;producer,
                                                          &amp;workQueue,
                                                          &amp;manager,
                                                          nextNextTime));

      <span class="keywordtype">void</span> *timerId = manager.<a class="code" href="classbtlmt_1_1TcpTimerEventManager.html#a1453c33da941f40b7213eb92620cd2ce">registerTimer</a>(now, callback);
      assert(timerId);
      <span class="keywordtype">int</span> rc = manager.<a class="code" href="classbtlmt_1_1TcpTimerEventManager.html#af5aadadedc8858fc4f7594d66154c800">enable</a>();
      assert(0 == rc);
      <span class="keywordflow">while</span>(1) {
          <span class="comment">// Monitor &#39;workQueue&#39; here</span>
          <span class="comment">// ...</span>
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
