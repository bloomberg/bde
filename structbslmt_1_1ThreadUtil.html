<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct bslmt::ThreadUtil</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslmt.html">bslmt</a>      </li>
      <li><a class="el" href="structbslmt_1_1ThreadUtil.html">bslmt::ThreadUtil</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslmt::ThreadUtil Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslmt::ThreadUtil" -->
<p><code>#include &lt;<a class="el" href="bslmt__threadutil_8h_source.html">bslmt_threadutil.h</a>&gt;</code></p>

<p><a href="structbslmt_1_1ThreadUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ThreadUtilImpl<br class="typebreak"/>
&lt; Platform::ThreadPolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#ab7d80aa5995e15e90e47f61d1f8ecb4d">Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Imp::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Imp::NativeHandle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a7756e09e893350902e8f1a1f74d4b853">NativeHandle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Imp::Id&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__bslmt__threadutil.html#ga6d94665750b795929138ed7eb7f88b56">bslmt_ThreadFunction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a01c7a6983e80799b2f5ed11471543dd1">ThreadFunction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Imp::Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__bslmt__threadutil.html#ga730bddcc94d1a3cebc745dd23111f235">bslmt_KeyDestructorFunction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#aaa38422e3560c6f0ea68bdb595348ffd">Destructor</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#abf87f34e8ce727a1342f05476a42427b">convertToSchedulingPriority</a> (<a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a> policy, double normalizedSchedulingPriority)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">create</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *handle, <a class="el" href="structbslmt_1_1ThreadUtil.html#a01c7a6983e80799b2f5ed11471543dd1">ThreadFunction</a> function, void *userData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a16179b7ad42be172edfecac4cac93287">create</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *handle, const <a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a> &amp;attributes, <a class="el" href="structbslmt_1_1ThreadUtil.html#a01c7a6983e80799b2f5ed11471543dd1">ThreadFunction</a> function, void *userData)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INVOKABLE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a6dd3dd9d6a00474655d6d054850802d2">create</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *handle, const INVOKABLE &amp;function)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INVOKABLE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#adbdebc8b1f70acfd6de3c433ec2b7435">create</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *handle, const <a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a> &amp;attributes, const INVOKABLE &amp;function)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INVOKABLE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#ab70c3d5765f9fec97cd20589c3da23dd">createWithAllocator</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *handle, const INVOKABLE &amp;function, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INVOKABLE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a7881184fbe7910c15638c884a6a386ca">createWithAllocator</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *handle, const <a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a> &amp;attributes, const INVOKABLE &amp;function, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a99ced7f499d10d60fa0e59777a133bf1">detach</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#afd42ef584d5994983a02dee43b94e0a8">exit</a> (void *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a9c4ca1b03e2c56afb7bc9de8932e51e8">getMinSchedulingPriority</a> (<a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a> policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a6db40ef6674e222b3c8a1d1bfdbc039e">getMaxSchedulingPriority</a> (<a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a> policy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">join</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;threadHandle, void **status=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">microSleep</a> (int microseconds, int seconds=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a667b0f54d6c038c8ecb851ca66dc0529">sleep</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;sleepTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#ac961974e28226a54525b0afedfd2a73e">sleepUntil</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;absoluteTime, <a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a> clockType=bsls::SystemClockType::e_REALTIME)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a6f7c5d60c974ba25866e5e881aec98be">yield</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3e3295d2b4ca2216122b50dc448b575e">areEqual</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;a, const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a9704ef33de227e0a084a7dcd04cfa0f3">areEqualId</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;a, const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#af43e0bc64786fdd44c0bd33dc251cf62">handleToId</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;threadHandle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a95829036e4c6bd8ef27f99c3e893a541">idAsUint64</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;threadId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a09f23fd5e72563265ac95a3ac11a50f1">idAsInt</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;threadId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a6ac8cf16bde241bc72c8ed38c3f0364f">invalidHandle</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a7c5da86da0e95e36a754b3f6e0cdf1fb">isEqual</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;a, const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a1d7059f3efc49c1d140b111a296e44e5">isEqualId</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;a, const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbslmt_1_1ThreadUtil.html#a7756e09e893350902e8f1a1f74d4b853">NativeHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a6fc6d4a6ef865e719b7a4c50b19de845">nativeHandle</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3d53ab226de9b3171135cb5f77f8e14a">self</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#ab0e8cf17dc664b9fb219858503c3d755">selfId</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#af3163740688319dc7fed68c743d80f6f">selfIdAsInt</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a05181cae182050a0c6942bfd641e56ae">selfIdAsUint64</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#aa05eafd599b7c839ceb1042997a96fdd">createKey</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a> *key, <a class="el" href="structbslmt_1_1ThreadUtil.html#aaa38422e3560c6f0ea68bdb595348ffd">Destructor</a> threadKeyCleanupFunction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a5604bea6bc1a4ec1185d080a0cfe5a43">deleteKey</a> (<a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a4f4db31a677718788fe1fa60123393ab">getSpecific</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmt_1_1ThreadUtil.html#a8b27f1f52dbe58219f0f76ca163b1689">setSpecific</a> (const <a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a> &amp;key, const void *value)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a suite of portable utility functions for managing threads. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ab7d80aa5995e15e90e47f61d1f8ecb4d"></a><!-- doxytag: member="bslmt::ThreadUtil::Imp" ref="ab7d80aa5995e15e90e47f61d1f8ecb4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ThreadUtilImpl&lt;Platform::ThreadPolicy&gt; <a class="el" href="structbslmt_1_1ThreadUtil.html#ab7d80aa5995e15e90e47f61d1f8ecb4d">bslmt::ThreadUtil::Imp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ed7de89fef3498278c0b4f8225217b9"></a><!-- doxytag: member="bslmt::ThreadUtil::Handle" ref="a3ed7de89fef3498278c0b4f8225217b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Imp::Handle <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7756e09e893350902e8f1a1f74d4b853"></a><!-- doxytag: member="bslmt::ThreadUtil::NativeHandle" ref="a7756e09e893350902e8f1a1f74d4b853" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Imp::NativeHandle <a class="el" href="structbslmt_1_1ThreadUtil.html#a7756e09e893350902e8f1a1f74d4b853">bslmt::ThreadUtil::NativeHandle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab83594893d20f6e63ea78c937265fc74"></a><!-- doxytag: member="bslmt::ThreadUtil::Id" ref="ab83594893d20f6e63ea78c937265fc74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Imp::Id <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">bslmt::ThreadUtil::Id</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a01c7a6983e80799b2f5ed11471543dd1"></a><!-- doxytag: member="bslmt::ThreadUtil::ThreadFunction" ref="a01c7a6983e80799b2f5ed11471543dd1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__bslmt__threadutil.html#ga6d94665750b795929138ed7eb7f88b56">bslmt_ThreadFunction</a> <a class="el" href="structbslmt_1_1ThreadUtil.html#a01c7a6983e80799b2f5ed11471543dd1">bslmt::ThreadUtil::ThreadFunction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac396cc2c2201d3b0b445240c1d19b902"></a><!-- doxytag: member="bslmt::ThreadUtil::Key" ref="ac396cc2c2201d3b0b445240c1d19b902" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Imp::Key <a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">bslmt::ThreadUtil::Key</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa38422e3560c6f0ea68bdb595348ffd"></a><!-- doxytag: member="bslmt::ThreadUtil::Destructor" ref="aaa38422e3560c6f0ea68bdb595348ffd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__bslmt__threadutil.html#ga730bddcc94d1a3cebc745dd23111f235">bslmt_KeyDestructorFunction</a> <a class="el" href="structbslmt_1_1ThreadUtil.html#aaa38422e3560c6f0ea68bdb595348ffd">bslmt::ThreadUtil::Destructor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abf87f34e8ce727a1342f05476a42427b"></a><!-- doxytag: member="bslmt::ThreadUtil::convertToSchedulingPriority" ref="abf87f34e8ce727a1342f05476a42427b" args="(ThreadAttributes::SchedulingPolicy policy, double normalizedSchedulingPriority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::convertToSchedulingPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>normalizedSchedulingPriority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an integer scheduling priority appropriate for the specified <code>normalizedSchedulingPriority</code> and the specified <code>policy</code>. If either the minimum or maximum priority for this platform cannot be determined, return <code><a class="el" href="classbslmt_1_1ThreadAttributes.html#a21679b30c880e88cefb6e3310b675296adc3891e6c4c2610f4efe3d0d4ca3b96f">ThreadAttributes::e_UNSET_PRIORITY</a></code>. Higher values of <code>normalizedSchedulingPriority</code> are considered to represent more urgent priorities. The behavior is undefined unless <code>policy</code> is a valid <code><a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a></code> and <code>normalizedSchedulingPriority</code> is in the range <code>[ 0.0, 1.0 ]</code>. </p>

</div>
</div>
<a class="anchor" id="a3948c1f54b2420a8e6b3d9a0821c8190"></a><!-- doxytag: member="bslmt::ThreadUtil::create" ref="a3948c1f54b2420a8e6b3d9a0821c8190" args="(Handle *handle, ThreadFunction function, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a01c7a6983e80799b2f5ed11471543dd1">ThreadFunction</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a16179b7ad42be172edfecac4cac93287"></a><!-- doxytag: member="bslmt::ThreadUtil::create" ref="a16179b7ad42be172edfecac4cac93287" args="(Handle *handle, const ThreadAttributes &amp;attributes, ThreadFunction function, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a01c7a6983e80799b2f5ed11471543dd1">ThreadFunction</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new thread of program control whose entry point will be the specified <code>function</code>, and which will be passed <code>userData</code> as its sole argument, and load into the specified <code>handle</code> an identifier that may be used to refer to this thread in calls to other <code><a class="el" href="structbslmt_1_1ThreadUtil.html">ThreadUtil</a></code> methods. Optionally specify <code>attributes</code> describing the properties for the new thread to create. If <code>attributes</code> is not supplied, a default <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a></code> object is used. Return 0 on success, and a non-zero value otherwise. <code><a class="el" href="structbslmt_1_1Configuration.html">bslmt::Configuration</a></code> is used to determine the created thread's default stack-size if either <code>attributes</code> is not supplied or if <code>attributes.stackSize()</code> has the unset value. The behavior is undefined unless unless <code>attributes</code>, if specified, has a <code>stackSize</code> that is either greater than 0 or <code>e_UNSET_STACK_SIZE</code>. Note that unless the created thread is explicitly "detached" (by invoking the <code>detach</code> class method with <code>handle</code>) or the <code>k_CREATE_DETACHED</code> attribute is specified, a call to <code>join</code> must be made to reclaim any system resources associated with the newly-created thread. Also note that users are encouraged to either explicitly provide a stack size attribute, or configure a <code>bslmt</code>-wide default using <code><a class="el" href="structbslmt_1_1Configuration.html">bslmt::Configuration</a></code>, because the default stack size is surprisingly small on some platforms. </p>

</div>
</div>
<a class="anchor" id="a6dd3dd9d6a00474655d6d054850802d2"></a><!-- doxytag: member="bslmt::ThreadUtil::create" ref="a6dd3dd9d6a00474655d6d054850802d2" args="(Handle *handle, const INVOKABLE &amp;function)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class INVOKABLE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const INVOKABLE &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adbdebc8b1f70acfd6de3c433ec2b7435"></a><!-- doxytag: member="bslmt::ThreadUtil::create" ref="adbdebc8b1f70acfd6de3c433ec2b7435" args="(Handle *handle, const ThreadAttributes &amp;attributes, const INVOKABLE &amp;function)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class INVOKABLE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const INVOKABLE &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new thread of program control whose entry point will invoke the the specified <code>function</code> object, and load into the specified <code>handle</code> an identifier that may be used to refer to this thread in calls to other <code><a class="el" href="structbslmt_1_1ThreadUtil.html">ThreadUtil</a></code> methods. Optionally specify <code>attributes</code> describing the properties for the new thread to create. If <code>attributes</code> is not supplied, a default <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a></code> object is used. Return 0 on success, and a non-zero value otherwise. <code>function</code> shall be a reference to a type, <code>INVOKABLE</code>, that can be copy-constructed, and where the expression <code>(void)function()</code> will execute a function call (i.e., either a <code>void()()</code> function, or a functor object implementing <code>void operator()()</code>). <code><a class="el" href="structbslmt_1_1Configuration.html">bslmt::Configuration</a></code> is used to determine the created thread's default stack-size if either <code>attributes</code> is not supplied or if <code>attributes.stackSize()</code> has the unset value. The behavior is undefined unless unless <code>attributes</code>, if specified, has a <code>stackSize</code> that is either greater than 0 or <code>e_UNSET_STACK_SIZE</code>. Note that unless the created thread is explicitly "detached" (by invoking the <code>detach</code> class method with <code>handle</code>) or the <code>k_CREATE_DETACHED</code> attribute is specified, a call to <code>join</code> must be made to reclaim any system resources associated with the newly-created thread. Also note that users are encouraged to either explicitly provide a stack size attribute, or configure a <code>bslmt</code>-wide default using <code><a class="el" href="structbslmt_1_1Configuration.html">bslmt::Configuration</a></code>, because the default stack size is surprisingly small on some platforms. </p>

</div>
</div>
<a class="anchor" id="ab70c3d5765f9fec97cd20589c3da23dd"></a><!-- doxytag: member="bslmt::ThreadUtil::createWithAllocator" ref="ab70c3d5765f9fec97cd20589c3da23dd" args="(Handle *handle, const INVOKABLE &amp;function, bslma::Allocator *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class INVOKABLE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::createWithAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const INVOKABLE &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7881184fbe7910c15638c884a6a386ca"></a><!-- doxytag: member="bslmt::ThreadUtil::createWithAllocator" ref="a7881184fbe7910c15638c884a6a386ca" args="(Handle *handle, const ThreadAttributes &amp;attributes, const INVOKABLE &amp;function, bslma::Allocator *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class INVOKABLE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::createWithAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const INVOKABLE &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new thread of program control whose entry point will invoke the the specified <code>function</code> object (using the specified <code>allocator</code> to supply memory to copy <code>function</code>), and load into the specified <code>handle</code> an identifier that may be used to refer to this thread in calls to other <code><a class="el" href="structbslmt_1_1ThreadUtil.html">ThreadUtil</a></code> methods. Optionally specify <code>attributes</code> describing the properties for the new thread to create. If <code>attributes</code> is not supplied, a default <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">ThreadAttributes</a></code> object is used. Return 0 on success, and a non-zero value otherwise. <code>function</code> shall be a reference to a type, <code>INVOKABLE</code>, that can be copy-constructed, and where the expression <code>(void)function()</code> will execute a function call (i.e., either a <code>void()()</code> function, or a functor object implementing <code>void operator()()</code>). <code><a class="el" href="structbslmt_1_1Configuration.html">bslmt::Configuration</a></code> is used to determine the created thread's default stack-size if either <code>attributes</code> is not supplied or if <code>attributes.stackSize()</code> has the unset value. The behavior is undefined unless unless <code>attributes</code>, if specified, has a <code>stackSize</code> that is either greater than 0 or <code>e_UNSET_STACK_SIZE</code>. Note that unless the created thread is explicitly "detached" (by invoking the <code>detach</code> class method with <code>handle</code>) or the <code>k_CREATE_DETACHED</code> attribute is specified, a call to <code>join</code> must be made to reclaim any system resources associated with the newly-created thread. Also note that the lifetime of <code>allocator</code> must exceed the lifetime of the thread. Also note that users are encouraged to either explicitly provide a stack size attribute, or configure a <code>bslmt</code>-wide default using <code><a class="el" href="structbslmt_1_1Configuration.html">bslmt::Configuration</a></code>, because the default stack size is surprisingly small on some platforms. </p>

</div>
</div>
<a class="anchor" id="a99ced7f499d10d60fa0e59777a133bf1"></a><!-- doxytag: member="bslmt::ThreadUtil::detach" ref="a99ced7f499d10d60fa0e59777a133bf1" args="(Handle &amp;handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>"Detach" the thread identified by the specified <code>handle</code> such that when it terminates, the resources associated with that thread will automatically be reclaimed. The behavior is undefined unless <code>handle</code> was obtained by a call to <code>create</code> or <code>self</code>. Note that once a thread is "detached", it is no longer possible to <code>join</code> the thread to retrieve its exit status. </p>

</div>
</div>
<a class="anchor" id="afd42ef584d5994983a02dee43b94e0a8"></a><!-- doxytag: member="bslmt::ThreadUtil::exit" ref="afd42ef584d5994983a02dee43b94e0a8" args="(void *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslmt::ThreadUtil::exit </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exit the current thread and return the specified <code>status</code>. If the current thread is not "detached", then a call to <code>join</code> must be made to reclaim any resources used by the thread, and to retrieve the exit status. Note that the preferred method of exiting a thread is to return from the entry point function. </p>

</div>
</div>
<a class="anchor" id="a9c4ca1b03e2c56afb7bc9de8932e51e8"></a><!-- doxytag: member="bslmt::ThreadUtil::getMinSchedulingPriority" ref="a9c4ca1b03e2c56afb7bc9de8932e51e8" args="(ThreadAttributes::SchedulingPolicy policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::getMinSchedulingPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the minimum available priority for the specified <code>policy</code>, where <code>policy</code> is of type <code><a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a></code>. Return <code><a class="el" href="classbslmt_1_1ThreadAttributes.html#a21679b30c880e88cefb6e3310b675296adc3891e6c4c2610f4efe3d0d4ca3b96f">ThreadAttributes::e_UNSET_PRIORITY</a></code> if the minimum scheduling priority cannot be determined. Note that, for some platform / policy combinations, <code>getMinSchedulingPriority(policy)</code> and <code>getMaxSchedulingPriority(policy)</code> return the same value. </p>

</div>
</div>
<a class="anchor" id="a6db40ef6674e222b3c8a1d1bfdbc039e"></a><!-- doxytag: member="bslmt::ThreadUtil::getMaxSchedulingPriority" ref="a6db40ef6674e222b3c8a1d1bfdbc039e" args="(ThreadAttributes::SchedulingPolicy policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::getMaxSchedulingPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>policy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum available priority for the specified <code>policy</code>, where <code>policy</code> is of type <code><a class="el" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">ThreadAttributes::SchedulingPolicy</a></code>. Return <code><a class="el" href="classbslmt_1_1ThreadAttributes.html#a21679b30c880e88cefb6e3310b675296adc3891e6c4c2610f4efe3d0d4ca3b96f">ThreadAttributes::e_UNSET_PRIORITY</a></code> if the maximum scheduling priority cannot be determined. Note that, for some platform / policy combinations, <code>getMinSchedulingPriority(policy)</code> and <code>getMaxSchedulingPriority(policy)</code> return the same value. </p>

</div>
</div>
<a class="anchor" id="a6080ed163948384d869f136bff12e248"></a><!-- doxytag: member="bslmt::ThreadUtil::join" ref="a6080ed163948384d869f136bff12e248" args="(Handle &amp;threadHandle, void **status=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threadHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>status</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend execution of the current thread until the thread referred to by the specified <code>threadHandle</code> terminates, and reclaim any system resources associated with <code>threadHandle</code>. If the optionally specified <code>status</code> is not 0, load into <code>*status</code> the value returned by the function supplied at the creation of the thread identified by <code>threadHandle</code>. The behavior is undefined unless <code>threadHandle</code> was obtained by a call to <code>create</code>. </p>

</div>
</div>
<a class="anchor" id="a4e6a840e495c3afa38474a2dcc073286"></a><!-- doxytag: member="bslmt::ThreadUtil::microSleep" ref="a4e6a840e495c3afa38474a2dcc073286" args="(int microseconds, int seconds=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslmt::ThreadUtil::microSleep </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>microseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>seconds</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend execution of the current thread for a period of at least the specified <code>microseconds</code> and the optionally specified <code>seconds</code> (relative time). Note that the actual time suspended depends on many factors including system scheduling and system timer resolution, and may be significantly longer than the time requested. </p>

</div>
</div>
<a class="anchor" id="a667b0f54d6c038c8ecb851ca66dc0529"></a><!-- doxytag: member="bslmt::ThreadUtil::sleep" ref="a667b0f54d6c038c8ecb851ca66dc0529" args="(const bsls::TimeInterval &amp;sleepTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslmt::ThreadUtil::sleep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sleepTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend execution of the current thread for a period of at least the specified <code>sleepTime</code> (relative time). Note that the actual time suspended depends on many factors including system scheduling and system timer resolution. </p>

</div>
</div>
<a class="anchor" id="ac961974e28226a54525b0afedfd2a73e"></a><!-- doxytag: member="bslmt::ThreadUtil::sleepUntil" ref="ac961974e28226a54525b0afedfd2a73e" args="(const bsls::TimeInterval &amp;absoluteTime, bsls::SystemClockType::Enum clockType=bsls::SystemClockType::e_REALTIME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslmt::ThreadUtil::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>absoluteTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>clockType</em> = <code>bsls::SystemClockType::e_REALTIME</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend execution of the current thread until the specified <code>absoluteTime</code>. Optionally specify <code>clockType</code> which determines the epoch from which the interval <code>absoluteTime</code> is measured (see <a href="group__Supported Clock-Types.html" class="el"><code>Supported Clock-Types</code></a> in the component documentation). The behavior is undefined unless <code>absoluteTime</code> represents a time after January 1, 1970 and before the end of December 31, 9999 (i.e., a time interval greater than or equal to 0, and less than 253,402,300,800 seconds). Note that the actual time suspended depends on many factors including system scheduling and system timer resolution. </p>

</div>
</div>
<a class="anchor" id="a6f7c5d60c974ba25866e5e881aec98be"></a><!-- doxytag: member="bslmt::ThreadUtil::yield" ref="a6f7c5d60c974ba25866e5e881aec98be" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslmt::ThreadUtil::yield </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the current thread to the end of the scheduler's queue and schedule another thread to run. Note that this allows cooperating threads of the same priority to share CPU resources equally. </p>

</div>
</div>
<a class="anchor" id="a3e3295d2b4ca2216122b50dc448b575e"></a><!-- doxytag: member="bslmt::ThreadUtil::areEqual" ref="a3e3295d2b4ca2216122b50dc448b575e" args="(const Handle &amp;a, const Handle &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bslmt::ThreadUtil::areEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>a</code> and <code>b</code> thread handles identify the same thread, or if both <code>a</code> and <code>b</code> are invalid handles, and <code>false</code> otherwise. Note that if <em>either</em> of <code>a</code> or <code>b</code> is an invalid handle, but not both, this method returns <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a9704ef33de227e0a084a7dcd04cfa0f3"></a><!-- doxytag: member="bslmt::ThreadUtil::areEqualId" ref="a9704ef33de227e0a084a7dcd04cfa0f3" args="(const Id &amp;a, const Id &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bslmt::ThreadUtil::areEqualId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>a</code> thread identifier is associated with the same thread as the specified <code>b</code> thread identifier, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="af43e0bc64786fdd44c0bd33dc251cf62"></a><!-- doxytag: member="bslmt::ThreadUtil::handleToId" ref="af43e0bc64786fdd44c0bd33dc251cf62" args="(const Handle &amp;threadHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> bslmt::ThreadUtil::handleToId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threadHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the unique identifier of the thread having the specified <code>threadHandle</code> within the current process. The behavior is undefined unless <code>handle</code> was obtained by a call to <code>create</code> or <code>self</code>. Note that this value is valid only until the thread terminates, and may be reused thereafter. </p>

</div>
</div>
<a class="anchor" id="a95829036e4c6bd8ef27f99c3e893a541"></a><!-- doxytag: member="bslmt::ThreadUtil::idAsUint64" ref="a95829036e4c6bd8ef27f99c3e893a541" args="(const Id &amp;threadId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> bslmt::ThreadUtil::idAsUint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threadId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the unique integral identifier of a thread uniquely identified by the specified <code>threadId</code> within the current process. Note that this representation is particularly useful for logging purposes. Also note that this value is only valid until the thread terminates and may be reused thereafter. </p>

</div>
</div>
<a class="anchor" id="a09f23fd5e72563265ac95a3ac11a50f1"></a><!-- doxytag: member="bslmt::ThreadUtil::idAsInt" ref="a09f23fd5e72563265ac95a3ac11a50f1" args="(const Id &amp;threadId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::idAsInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threadId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the unique integral identifier of a thread uniquely identified by the specified <code>threadId</code> within the current process. Note that this representation is particularly useful for logging purposes. Also note that this value is only valid until the thread terminates and may be reused thereafter.</p>
<p>DEPRECATED: use <code>idAsUint64</code>. </p>

</div>
</div>
<a class="anchor" id="a6ac8cf16bde241bc72c8ed38c3f0364f"></a><!-- doxytag: member="bslmt::ThreadUtil::invalidHandle" ref="a6ac8cf16bde241bc72c8ed38c3f0364f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a>&amp; bslmt::ThreadUtil::invalidHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable <code>Handle</code> object that is guaranteed never to be a valid thread handle. </p>

</div>
</div>
<a class="anchor" id="a7c5da86da0e95e36a754b3f6e0cdf1fb"></a><!-- doxytag: member="bslmt::ThreadUtil::isEqual" ref="a7c5da86da0e95e36a754b3f6e0cdf1fb" args="(const Handle &amp;a, const Handle &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bslmt::ThreadUtil::isEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>a</code> and <code>b</code> thread handles identify the same thread, or if both <code>a</code> and <code>b</code> are invalid handles, and <code>false</code> otherwise. Note that if <em>either</em> of <code>a</code> or <code>b</code> is an invalid handle, but not both, this method returns <code>false</code>.</p>
<p>DEPRECATED: use <code>areEqual</code> instead. </p>

</div>
</div>
<a class="anchor" id="a1d7059f3efc49c1d140b111a296e44e5"></a><!-- doxytag: member="bslmt::ThreadUtil::isEqualId" ref="a1d7059f3efc49c1d140b111a296e44e5" args="(const Id &amp;a, const Id &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bslmt::ThreadUtil::isEqualId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> thread identifier is associated with the same thread as the specified <code>rhs</code> thread identifier, and <code>false</code> otherwise.</p>
<p>DEPRECATED: use <code>areEqualId</code> instead. </p>

</div>
</div>
<a class="anchor" id="a6fc6d4a6ef865e719b7a4c50b19de845"></a><!-- doxytag: member="bslmt::ThreadUtil::nativeHandle" ref="a6fc6d4a6ef865e719b7a4c50b19de845" args="(const Handle &amp;handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbslmt_1_1ThreadUtil.html#a7756e09e893350902e8f1a1f74d4b853">NativeHandle</a> bslmt::ThreadUtil::nativeHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the platform-specific identifier associated with the thread referred to by the specified <code>handle</code>. The behavior is undefined unless <code>handle</code> was obtained by a call to <code>create</code> or <code>self</code>. Note that the returned native handle may not be a globally unique identifier for the thread (see <code>selfIdAsUint</code>). </p>

</div>
</div>
<a class="anchor" id="a3d53ab226de9b3171135cb5f77f8e14a"></a><!-- doxytag: member="bslmt::ThreadUtil::self" ref="a3d53ab226de9b3171135cb5f77f8e14a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">Handle</a> bslmt::ThreadUtil::self </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an identifier that can be used to refer to the current thread in calls to other <code><a class="el" href="structbslmt_1_1ThreadUtil.html">ThreadUtil</a></code> methods. </p>

</div>
</div>
<a class="anchor" id="ab0e8cf17dc664b9fb219858503c3d755"></a><!-- doxytag: member="bslmt::ThreadUtil::selfId" ref="ab0e8cf17dc664b9fb219858503c3d755" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbslmt_1_1ThreadUtil.html#ab83594893d20f6e63ea78c937265fc74">Id</a> bslmt::ThreadUtil::selfId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an identifier that can be used to uniquely identify the current thread within the current process. Note that the identifier is only valid until the thread terminates and may be reused thereafter. </p>

</div>
</div>
<a class="anchor" id="af3163740688319dc7fed68c743d80f6f"></a><!-- doxytag: member="bslmt::ThreadUtil::selfIdAsInt" ref="af3163740688319dc7fed68c743d80f6f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> bslmt::ThreadUtil::selfIdAsInt </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an integral identifier that can be used to uniquely identify the current thread within the current process. Note that this representation is particularly useful for logging purposes. Also note that this value is only valid until the thread terminates and may be reused thereafter.</p>
<p>DEPRECATED: use <code>selfIdAsUint64</code> instead. </p>

</div>
</div>
<a class="anchor" id="a05181cae182050a0c6942bfd641e56ae"></a><!-- doxytag: member="bslmt::ThreadUtil::selfIdAsUint64" ref="a05181cae182050a0c6942bfd641e56ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> bslmt::ThreadUtil::selfIdAsUint64 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an integral identifier that can be used to uniquely identify the current thread within the current process. Note that this representation is particularly useful for logging purposes. Also note that this value is valid only until the thread terminates, and may be reused thereafter. </p>

</div>
</div>
<a class="anchor" id="aa05eafd599b7c839ceb1042997a96fdd"></a><!-- doxytag: member="bslmt::ThreadUtil::createKey" ref="aa05eafd599b7c839ceb1042997a96fdd" args="(Key *key, Destructor threadKeyCleanupFunction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::createKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#aaa38422e3560c6f0ea68bdb595348ffd">Destructor</a>&nbsp;</td>
          <td class="paramname"> <em>threadKeyCleanupFunction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>key</code> a new process-wide identifier that can be used to store (via <code>setSpecific</code>) and retrieve (via <code>getSpecific</code>) a pointer value local to each thread, and associate with the new key the specified <code>threadKeyCleanupFunction</code>, which will be called by each thread, if <code>threadKeyCleanupFunction</code> is non-zero and the value associated with <code>key</code> for that thread is non-zero, with the associated value as an argument, after the function passed to <code>create</code> has returned and before the thread terminates. Return 0 on success, and a non-zero value otherwise. Note that multiple keys can be defined, which can result in multiple thread key cleanup functions being called for a given thread. </p>

</div>
</div>
<a class="anchor" id="a5604bea6bc1a4ec1185d080a0cfe5a43"></a><!-- doxytag: member="bslmt::ThreadUtil::deleteKey" ref="a5604bea6bc1a4ec1185d080a0cfe5a43" args="(Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::deleteKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the specified <code>key</code> from the calling process, and disassociate all threads from the thread key cleanup function supplied when <code>key</code> was created (see <code>createKey</code>). Return 0 on success, and a non-zero value otherwise. The behavior is undefined unless <code>key</code> was obtained from a successful call to <code>createKey</code> and has not already been deleted. Note that deleting a key does not delete any data referred to by the pointer values associated with that key in any thread. </p>

</div>
</div>
<a class="anchor" id="a4f4db31a677718788fe1fa60123393ab"></a><!-- doxytag: member="bslmt::ThreadUtil::getSpecific" ref="a4f4db31a677718788fe1fa60123393ab" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* bslmt::ThreadUtil::getSpecific </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the thread-local value associated with the specified <code>key</code>. A <code>key</code> is shared among all threads and the value associated with <code>key</code> for each thread is 0 until it is set by that thread using <code>setSpecific</code>. The behavior is undefined unless this method is called outside any thread key cleanup function associated with any key by <code>createKey</code>, <code>key</code> was obtained from a successful call to <code>createKey</code>, and <code>key</code> has not been deleted. </p>

</div>
</div>
<a class="anchor" id="a8b27f1f52dbe58219f0f76ca163b1689"></a><!-- doxytag: member="bslmt::ThreadUtil::setSpecific" ref="a8b27f1f52dbe58219f0f76ca163b1689" args="(const Key &amp;key, const void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bslmt::ThreadUtil::setSpecific </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslmt_1_1ThreadUtil.html#ac396cc2c2201d3b0b445240c1d19b902">Key</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate the specified thread-local <code>value</code> with the specified process-wide <code>key</code>. Return 0 on success, and a non-zero value otherwise. The value associated with a thread for a given key is 0 until it has been set by that thread using <code>setSpecific</code>. The behavior is undefined unless this method is called outside any thread key cleanup function associated with any key by <code>createKey</code>, <code>key</code> was obtained from a successful call to <code>createKey</code>, and <code>key</code> has not been deleted. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bslmt__threadutil_8h_source.html">bslmt_threadutil.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:06 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
