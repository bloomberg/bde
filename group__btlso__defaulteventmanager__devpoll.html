<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlso_defaulteventmanager_devpoll Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Component btlso_defaulteventmanager_devpoll<br/>
<small>
[<a class="el" href="group__btlso.html">Package btlso</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide socket multiplexer implementation using <code>/dev/poll</code>.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
</table>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Availability</a> </li>
<li>
<a href="#3.2">Component Diagram</a> </li>
<li>
<a href="#3.3">Thread Safety</a> </li>
<li>
<a href="#3.4">Performance</a> </li>
<li>
<a href="#3.5">Metrics</a> </li>
<li>
<a href="#3.6">Usage</a> <ul>
<li>
<a href="#3.6.1">Example 1: Using an Event Manager</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide socket multiplexer implementation using <code>/dev/poll</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>btlso::DefaultEventManager&lt;btlso::Platform::DEVPOLL&gt; </td><td><code>devpoll</code> multiplexer  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlso__eventmanager.html" title="Define a protocol for socket-event multiplexer.">Component btlso_eventmanager</a> <a class="el" href="group__btlso__defaulteventmanager.html" title="Provide an interface for default event manager.">Component btlso_defaulteventmanager</a> <a class="el" href="group__btlso__timemetrics.html" title="Provide thread-safe time-based categorized metrics.">Component btlso_timemetrics</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides an implementation of an event manager, <code><a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt;btlso::Platform::DEVPOLL&gt;</code>, that uses the <code>/dev/poll</code> device to monitor for socket events and adheres to the <code><a class="el" href="classbtlso_1_1EventManager.html">btlso::EventManager</a></code> protocol. In particular, this protocol supports the registration of socket events, along with an associated <code>bsl::function</code> callback functor, which is invoked when the corresponding socket event occurs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Registering a socket event requires specifying a socket handle and the type of event to monitor on the indicated socket. Socket event registrations stay in effect until they are subsequently deregistered; the associated callback is invoked each time the specified socket event occurs provided that appropriate method (i.e., <code>dispatch</code>) is called. Once deregistered, the callback will no longer be invoked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Documentation for the underlying facility can be found in <code>man 7d poll</code> on Solaris and <code>man 7 poll</code> on HPUX. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="availability"></a> <a class="anchor" id="description.availability"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Availability: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>/dev/poll</code> device (and consequently this specialized component) is currently supported only on Solaris and HP-UX platforms. Direct use of this library component unconditionally may result in non-portable software. It is recommended you use <code>btlso::Platform::DEFAULT_POLLING_MECHANISM</code> to choose the optimal default event manager for each platform. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_diagram"></a> <a class="anchor" id="description.component_diagram"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Component Diagram: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This specialized component is one of the specializations of the <code>btlso_defaulteventmanager</code> component; the other components are shown (schematically) on the following diagram: <br/>
<br/>
<div class="fragment"><pre class="fragment">                         _bteso_defaulteventmanager_
                 _______/    |        |        |    \_______
                 *_epoll *_select *_devpoll *_pollset *_poll
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component depends on a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> instance to supply memory. If the allocator is not thread enabled then the instances of this component that use the same allocator instance will consequently not be thread safe Otherwise, this component provides the following guarantees. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Accessing an instance of the event manager provided by this component from different threads may result in undefined behavior. Accessing distinct instances from different threads is safe. Distinct instances of the event manager provided by this component are <em>thread</em> <em>enabled</em> meaning that operations invoked on distinct instances from different threads can proceed concurrently. The event manager is not <em>async-safe</em>, meaning that one or more functions cannot be invoked safely from a signal handler. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance"></a> <a class="anchor" id="description.performance"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Performance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Given that S is the number of socket events registered, this component provides the following complexity guarantees: <br/>
<br/>
<div class="fragment"><pre class="fragment">  +=======================================================================+
  |        FUNCTION          | EXPECTED COMPLEXITY | WORST CASE COMPLEXITY|
  +-----------------------------------------------------------------------+
  | dispatch                 |        O(S)*        |       O(S^2)         |
  +-----------------------------------------------------------------------+
  | registerSocketEvent      |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterSocketEvent    |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterSocket         |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterAll            |        O(S)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | numSocketEvents          |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | numEvents                |        O(1)         |        O(1)          |
  +-----------------------------------------------------------------------+
  | isRegistered             |        O(1)         |        O(S)          |
  +=======================================================================+

 *: Note that we observe that <span class="keywordflow">if</span> very few of the sockets being listened to
 have events, the time taken by <span class="stringliteral">&#39;dispatch&#39;</span> remains roughly constant
 regardless of the number of sockets.  See tables at the beginning of
 <span class="stringliteral">&#39;btlso_eventmanagertester.t.cpp&#39;</span> <span class="keywordflow">for</span> actual test results.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="metrics"></a> <a class="anchor" id="description.metrics"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Metrics: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The event manager provided by this component can use external (i.e., user-installed) time metrics (see <code>btlso_timemetrics</code> component) to record times spend in IO-bound and CPU-bound operations using the category IDs defined in <code><a class="el" href="classbtlso_1_1TimeMetrics.html">btlso::TimeMetrics</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_an_event_manager"></a> <a class="anchor" id="usage.example_1~3A_using_an_event_manager"></a> <a class="anchor" id="description.usage.example_1~3A_using_an_event_manager"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.6.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using an Event Manager: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate how to use this event manager with a non-blocking socket. First, create a <code><a class="el" href="classbtlso_1_1TimeMetrics.html">btlso::TimeMetrics</a></code> object and a <code><a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt;btlso::Platform::DEVPOLL&gt;</code> object; also create a (locally-connected) socket pair: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbtlso_1_1TimeMetrics.html">btlso::TimeMetrics</a> timeMetric(<a class="code" href="classbtlso_1_1TimeMetrics.html#a8c490338b9de973043416ccef6f0f3ffadaeb514500db1ac0bd6158b2a915709f">btlso::TimeMetrics::e_MIN_NUM_CATEGORIES</a>,
                                <a class="code" href="classbtlso_1_1TimeMetrics.html#a8c490338b9de973043416ccef6f0f3ffafca7bc4bcfbf8b8d54928308afbc647c">btlso::TimeMetrics::e_CPU_BOUND</a>);

  <a class="code" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager&lt;btlso::Platform::DEVPOLL&gt;</a> mX(&amp;timeMetric);

  <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> socket[2];

  <span class="keywordtype">int</span> rc = btlso::SocketImpUtil::socketPair&lt;btlso::IPv4Address&gt;(
                                      socket,
                                      btlso::SocketImpUtil::k_SOCKET_STREAM);

  assert(0 == rc);
</pre></div><br/>
<br/>
 Second, register three socket events, two for <code>socket[0]</code>, and one for <code>socket[1]</code>, and verify the state by using accessor functions. The callback installed as part of each registration operation will either read or write the pre-determined (specified on a case-by-case basis) number of bytes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> numBytes = 5;
  <a class="code" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> readCb(
                               <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;genericCb,
                                                    <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>,
                                                    socket[0],
                                                    numBytes,
                                                    &amp;mX));
  mX.registerSocketEvent(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>, readCb);

  numBytes = 25;
  <a class="code" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> writeCb1(
                              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;genericCb,
                                                   <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>,
                                                   socket[0],
                                                   numBytes,
                                                   &amp;mX));
  mX.registerSocketEvent(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>, writeCb1);

  numBytes = 15;
  <a class="code" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> writeCb2(
                              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;genericCb,
                                                   <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>,
                                                   socket[1],
                                                   numBytes,
                                                   &amp;mX));
  mX.registerSocketEvent(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>, writeCb2);

  assert(3 == mX.numEvents());
  assert(2 == mX.numSocketEvents(socket[0]));
  assert(1 == mX.numSocketEvents(socket[1]));
  assert(1 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.isRegistered(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(1 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
  assert(1 == mX.isRegistered(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
</pre></div><br/>
<br/>
 Next, we try to execute the requests by calling the <code>dispatch</code> function with a timeout (5 seconds from now) requirement and verify the result. The two write requests should be executed since both ends are writable If we don't have a timeout requirement, a different version of <code>dispatch</code> (in which no timeout is specified) can also be called. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span>                flags = 0;
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> deadline(<a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>());

  deadline += 5;    <span class="comment">// timeout 5 seconds from now.</span>
  rc = mX.dispatch(deadline, flags);   assert(2 == rc);
</pre></div><br/>
<br/>
 Now we try to remove the write request of <code>socket[0]</code> from the event manager by calling <code>deregisterSocketEvent()</code> and verify the state: <br/>
<br/>
<div class="fragment"><pre class="fragment">  mX.deregisterSocketEvent(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>);
  assert(2 == mX.numEvents());
  assert(1 == mX.numSocketEvents(socket[0]));
  assert(1 == mX.numSocketEvents(socket[1]));
  assert(1 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.isRegistered(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
  assert(1 == mX.isRegistered(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
</pre></div><br/>
<br/>
 We then try to remove all registrations associated with <code>socket[1]</code> by calling <code>deregisterSocket()</code> and verify the state: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(1 == mX.deregisterSocket(socket[1]));
  assert(1 == mX.numEvents());
  assert(1 == mX.numSocketEvents(socket[0]));
  assert(0 == mX.numSocketEvents(socket[1]));
  assert(1 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.isRegistered(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
  assert(0 == mX.isRegistered(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
</pre></div><br/>
<br/>
 Finally, we remove all registrations by calling <code>deregisterAll()</code> and verify the state again: <br/>
<br/>
<div class="fragment"><pre class="fragment">  mX.deregisterAll();
  assert(0 == mX.numEvents());
  assert(0 == mX.numSocketEvents(socket[0]));
  assert(0 == mX.numSocketEvents(socket[1]));
  assert(0 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.isRegistered(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
  assert(0 == mX.isRegistered(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
</pre></div><br/>
<br/>
 The following snippets of code show what a <code>genericCb</code> may look like: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> genericCb(<a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a>       event,
                        <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a>  socket,
                        <span class="keywordtype">int</span>                          bytes,
                        <a class="code" href="classbtlso_1_1EventManager.html">btlso::EventManager</a>         *mX)
  {
      <span class="comment">// User specified callback function that is invoked when a socket</span>
      <span class="comment">// event is detected.</span>

      <span class="keyword">enum</span> {
          k_MAX_READ_SIZE  =  8192,   <span class="comment">// The numbers are for illustrative</span>
          k_MAX_WRITE_SIZE = 70000    <span class="comment">// purposes only.</span>
      };

      <span class="keywordflow">switch</span> (event) {
        <span class="keywordflow">case</span> <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>: {
            assert(0 &lt; bytes);

            <span class="keywordtype">char</span> buffer[k_MAX_READ_SIZE];

            <span class="keywordtype">int</span> rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a153aa8f6c8c42dc5c8ac96ea2ddb5341">btlso::SocketImpUtil::read</a>(buffer, socket, bytes, 0);
            assert(0 &lt; rc);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>: {
            <span class="keywordtype">char</span> wBuffer[k_MAX_WRITE_SIZE];
            assert(0 &lt; bytes);
            assert(k_MAX_WRITE_SIZE &gt;= bytes);

            memset(wBuffer,<span class="charliteral">&#39;4&#39;</span>, bytes);
            <span class="keywordtype">int</span> rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a635e8ba101b004a75235e7e83d509b44">btlso::SocketImpUtil::write</a>(socket, &amp;wBuffer, bytes, 0);
            assert(0 &lt; rc);
        } <span class="keywordflow">break</span>;
        <span class="comment">// ...</span>
        <span class="keywordflow">default</span>: {
             ASSERT(<span class="stringliteral">&quot;Invalid event code&quot;</span> &amp;&amp; 0);
        } <span class="keywordflow">break</span>;
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:14 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
