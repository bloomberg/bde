<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Namespace bslstl</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bslstl Namespace Reference<br/>
<small>
[<a class="el" href="group__bslstl__badweakptr.html">Component bslstl_badweakptr</a>,&nbsp;<a class="el" href="group__bslstl__bidirectionaliterator.html">Component bslstl_bidirectionaliterator</a>,&nbsp;<a class="el" href="group__bslstl__bidirectionalnodepool.html">Component bslstl_bidirectionalnodepool</a>,&nbsp;<a class="el" href="group__bslstl__forwarditerator.html">Component bslstl_forwarditerator</a>,&nbsp;<a class="el" href="group__bslstl__hashtable.html">Component bslstl_hashtable</a>,&nbsp;<a class="el" href="group__bslstl__hashtablebucketiterator.html">Component bslstl_hashtablebucketiterator</a>,&nbsp;<a class="el" href="group__bslstl__iteratorutil.html">Component bslstl_iteratorutil</a>,&nbsp;<a class="el" href="group__bslstl__mapcomparator.html">Component bslstl_mapcomparator</a>,&nbsp;<a class="el" href="group__bslstl__priorityqueue.html">Component bslstl_priorityqueue</a>,&nbsp;<a class="el" href="group__bslstl__queue.html">Component bslstl_queue</a>,&nbsp;<a class="el" href="group__bslstl__randomaccessiterator.html">Component bslstl_randomaccessiterator</a>,&nbsp;<a class="el" href="group__bslstl__setcomparator.html">Component bslstl_setcomparator</a>,&nbsp;<a class="el" href="group__bslstl__sharedptr.html">Component bslstl_sharedptr</a>,&nbsp;<a class="el" href="group__bslstl__sharedptrallocateinplacerep.html">Component bslstl_sharedptrallocateinplacerep</a>,&nbsp;<a class="el" href="group__bslstl__sharedptrallocateoutofplacerep.html">Component bslstl_sharedptrallocateoutofplacerep</a>,&nbsp;<a class="el" href="group__bslstl__simplepool.html">Component bslstl_simplepool</a>,&nbsp;<a class="el" href="group__bslstl__stdexceptutil.html">Component bslstl_stdexceptutil</a>,&nbsp;<a class="el" href="group__bslstl__stringref.html">Component bslstl_stringref</a>,&nbsp;<a class="el" href="group__bslstl__stringrefdata.html">Component bslstl_stringrefdata</a>,&nbsp;<a class="el" href="group__bslstl__treeiterator.html">Component bslstl_treeiterator</a>,&nbsp;<a class="el" href="group__bslstl__treenode.html">Component bslstl_treenode</a>,&nbsp;<a class="el" href="group__bslstl__treenodepool.html">Component bslstl_treenodepool</a>,&nbsp;<a class="el" href="group__bslstl__unorderedmapkeyconfiguration.html">Component bslstl_unorderedmapkeyconfiguration</a>,&nbsp;<a class="el" href="group__bslstl__unorderedsetkeyconfiguration.html">Component bslstl_unorderedsetkeyconfiguration</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BadWeakPtr.html">BadWeakPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1CallableVariable.html">CallableVariable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__HashWrapper.html">HashTable_HashWrapper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__HashWrapper_3_01const_01FUNCTOR_01_4.html">HashTable_HashWrapper&lt; const FUNCTOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__HashWrapper_3_01FUNCTOR_01_6_01_4.html">HashTable_HashWrapper&lt; FUNCTOR &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__ComparatorWrapper.html">HashTable_ComparatorWrapper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__ComparatorWrapper_3_01const_01FUNCTOR_01_4.html">HashTable_ComparatorWrapper&lt; const FUNCTOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__ComparatorWrapper_3_01FUNCTOR_01_6_01_4.html">HashTable_ComparatorWrapper&lt; FUNCTOR &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__ArrayProctor.html">HashTable_ArrayProctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__NodeProctor.html">HashTable_NodeProctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1HashTable__ImpDetails.html">HashTable_ImpDetails</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1HashTable__Util.html">HashTable_Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1HashTable__BaseHasher.html">HashTable_BaseHasher</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1HashTable__Comparator.html">HashTable_Comparator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__ImplParameters.html">HashTable_ImplParameters</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1IteratorUtil.html">IteratorUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1MapComparator.html">MapComparator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1PriorityQueue__HasAllocatorType.html">PriorityQueue_HasAllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1Queue__HasAllocatorType.html">Queue_HasAllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SetComparator.html">SetComparator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtrRepFromExistingSharedPtr.html">SharedPtrRepFromExistingSharedPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtrUtil.html">SharedPtrUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">SharedPtrNilDeleter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtr__DefaultDeleter.html">SharedPtr_DefaultDeleter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtr__ImpUtil.html">SharedPtr_ImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SharedPtr__RepProctor.html">SharedPtr_RepProctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SharedPtrAllocateInplaceRep.html">SharedPtrAllocateInplaceRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SharedPtrAllocateOutofplaceRep.html">SharedPtrAllocateOutofplaceRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SharedPtrAllocateOutofplaceRep__InitProctor.html">SharedPtrAllocateOutofplaceRep_InitProctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SimplePool__Type.html">SimplePool_Type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SimplePool.html">SimplePool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1StdExceptUtil.html">StdExceptUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1StringRefData.html">StringRefData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeNode.html">TreeNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeNodePool.html">TreeNodePool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1UnorderedMapKeyConfiguration.html">UnorderedMapKeyConfiguration</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1UnorderedSetKeyConfiguration.html">UnorderedSetKeyConfiguration</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">StringRef</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; wchar_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#adb41ff59615d4ad2799e48a19ed5c1b1">StringRefWide</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a064dc55e874a2088adf90e2b2e0686a1">operator==</a> (const <a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#afa4ee48809437ab2d069f79173424e5a">operator!=</a> (const <a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a00890c2044ab22c5074a3d85283319d0">operator++</a> (<a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7d3362e2ffdbd7358a6d1b82f3a52ca1">operator--</a> (<a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a3da1086340fad5f33bd00ca4a5630fe6">swap</a> (<a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt; &amp;a, <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7f451481ffe1f393fc3e5c01d5170acd">operator==</a> (const <a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ac4bdff7f9c3d766d890ec8f768778973">operator!=</a> (const <a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T, ITER_IMP, <br class="typebreak"/>
TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a760a167fee692abe13531c5cc19bf26b">operator++</a> (<a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNCTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a5cb036ae300679c34aab3c38b2eb9465">swap</a> (<a class="el" href="classbslstl_1_1HashTable__HashWrapper.html">HashTable_HashWrapper</a>&lt; FUNCTOR &gt; &amp;a, <a class="el" href="classbslstl_1_1HashTable__HashWrapper.html">HashTable_HashWrapper</a>&lt; FUNCTOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNCTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#af6888ca123c5c2f7e71e24273291ba81">swap</a> (<a class="el" href="classbslstl_1_1HashTable__ComparatorWrapper.html">HashTable_ComparatorWrapper</a>&lt; FUNCTOR &gt; &amp;lhs, <a class="el" href="classbslstl_1_1HashTable__ComparatorWrapper.html">HashTable_ComparatorWrapper</a>&lt; FUNCTOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ad670e66a5a51493256212888d0b0d323">swap</a> (<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;x, <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a1063679c9d32371726a7a63b6df38b36">operator==</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#add33aaba152cf25e05fcf72d3a9d8ca8">operator!=</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a62fa543a36e28bf1a91438de01b9cfa8">operator==</a> (const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a0349c9a8b4bf4a9843f2e306056737b8">operator==</a> (const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a26d1f3e1532d4ba7e1cc3ebf62c96479">operator==</a> (const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ac4603167aa033e2f5bd4f8354c0aef11">operator==</a> (const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a725c99e6c2ef2847af5414edc915e54b">operator!=</a> (const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae109fff54930ec66ae4b28895f6bc5a8">operator!=</a> (const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#af61d7eb5a1906688dbbfa202ebf7ff59">operator!=</a> (const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a56da634318f5a84aeaaa8bc54e20d07c">operator!=</a> (const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a><br class="typebreak"/>
&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab52ab7ae3ed21c85bbdea0e93b7e8945">operator++</a> (<a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;iterator, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ac95bb0338eaf3a0ed9b6193e1a32666f">swap</a> (<a class="el" href="classbslstl_1_1MapComparator.html">MapComparator</a>&lt; KEY, VALUE, COMPARATOR &gt; &amp;a, <a class="el" href="classbslstl_1_1MapComparator.html">MapComparator</a>&lt; KEY, VALUE, COMPARATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aecbf287bad6a393b3769e175a52c6d7c">operator==</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#af7cb42eda52cb8743df718fe6a210dfb">operator!=</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae8637170e8a9e783847423544ec50d0c">operator++</a> (<a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a30d8a025ea147a79a5aa83baabcfbfd8">operator--</a> (<a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7f19a03f08152be8c8e39eabc14a3be3">operator+</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;lhs, std::ptrdiff_t rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a519f1e2cf1b83913964f970430856ad6">operator+</a> (std::ptrdiff_t lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a6bef3ec6e42b48dd4f8f2d85049fc210">operator-</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;lhs, std::ptrdiff_t rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae2e1bbf938782393591b4e286dbe019a">operator-</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab0ae7c327c10a640d4b992a1c3e09d5b">operator&lt;</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a2524127f15e9c740c4438e7dd9a0df0f">operator&gt;</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a4b4b6cb26176b3a0019b8be3e114492f">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a4e28f5e3e7f7e66f033844d6c007e3b6">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#afbbb8131098bc296ee793cb4071e6520">swap</a> (<a class="el" href="classbslstl_1_1SetComparator.html">SetComparator</a>&lt; KEY, COMPARATOR &gt; &amp;a, <a class="el" href="classbslstl_1_1SetComparator.html">SetComparator</a>&lt; KEY, COMPARATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a51a4448bbcb4772a231f7852209652aa">operator==</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a53b2e769f22f3fb61a3bf3fdadf3d079">operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a766ff04bbf040fd1d9a3327b3fe576cb">operator==</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a608629b084f15499578272c74314a995">operator==</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a0b4a61741ae62fba3bd8aafec0626cac">operator==</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7b5ab509f3c1b81fa908e4636c5ff16f">operator==</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a784b4104f5e5743c052a3d46f794a6a1">operator==</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a689a400d8c71795d52682bc404ff1cd2">operator!=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a21cb98dc3e79c898d47195ddd68fcb2f">operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7e3c330ecce3de90507e21750690d636">operator!=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab54861a375b01007f4a5b37a16f72edd">operator!=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae330745a6c3d94bf23689dcb4b242493">operator!=</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a91e0ef74edb43cf5e43039d7a51a301e">operator!=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aaba9cb19a51780db17046adf48e95989">operator!=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a62af990a7655b773e8fa8cbef27e11c5">operator&lt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a852c89f4a2facfcf981d190c40d598fc">operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ad8efdf23241116e1f4afab74943a02f8">operator&lt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a2720b3d72171d8d831d576c914bc1937">operator&lt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a29e7f76b182f71a3105c9cad20bc9f37">operator&lt;</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aee079f1acfc52183d206bbc9f887b98d">operator&lt;</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a9e61b3c34539d9cc031ed68104a919c5">operator&lt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a6b1ae0407e51ac060e4ea000053643c0">operator&gt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#acc12e6d6b6fa5c949c2716b09b266a0b">operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aaf68974d96d294c01100e90e4bbf03c5">operator&gt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a8cf8fa46ccb775af95b276a5b1c56c51">operator&gt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae59d94f3d75fb38924e19a9ed2b586f1">operator&gt;</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a40d38fec7502dbd0ff03d399b2466462">operator&gt;</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a194191bdf7021dee6ab778d85bb0772b">operator&gt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aad89624494d7e6b8d602dd1570a2fbc8">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a41d962c19e7cd2717150e4e250eff499">operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a2fcfedda927703699dd7f53468c6cc85">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a5b3dffcd70cec8e7862187115105162c">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab4bb7954f3aa25ee660d3d1088cd4ab6">operator&lt;=</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a25d056447c04bcef8d21ba35747c8c34">operator&lt;=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#af77cda2842b34b1dd69bd3d6cc9b6d31">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a1b2c06ce27c05c33649175bea59aeda3">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a5911b68cc5c963c6ae44c429efe1b37c">operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a2139b94069ae5bfbc569b028955ad1dd">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ac2341fba5b5b9c924c815ace426d8fe5">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a8bd6c73caf1e9d4fb775067486c41c6e">operator&gt;=</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#add8cfd74def58e7bf0f76f0dbd7bba9e">operator&gt;=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a91aeab0aee9450792161564ad39dd9e8">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ad9b003210a2b3ec734ddcd40505ba459">operator+</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a5b13d228a164dc2fb066fc77652417d8">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aaf1f45b7b7b1c5838932274f3cb13177">operator+</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aa7f77b8445ad577f9fe04d501f9bb1dd">operator+</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab6c3d040dc8da6e0bf8edbb8894b8cdf">operator+</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#adb4287a6eae0d6050e3147087fadb54b">operator+</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a524b145b97b9c6499e1012d0fd322620">operator+</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR_TYPE &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a548f0d8ad545bdc2fda693e87f91315c">operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR_TYPE &gt; &amp;stream, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;stringRef)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class HASHALG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a5c20315ed215d90747c40caa9f8634ad">hashAppend</a> (HASHALG &amp;hashAlg, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;input)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aa518402a2acc877e044a26294c7e1870">operator==</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE1, NODEPTR, DIFF &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE2, NODEPTR, DIFF &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a9e374c4a808b092fcf3a26ba95779fef">operator!=</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE1, NODEPTR, DIFF &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE2, NODEPTR, DIFF &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class NODE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, <br class="typebreak"/>
DIFFERENCE_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a32cf6106957ddca059b0931ca630b3ae">operator++</a> (<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class NODE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, <br class="typebreak"/>
DIFFERENCE_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aa876e8690c75d4354c8185281c5ae9e3">operator--</a> (<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;iter, int)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>close namespace bslalg </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a10921a5e7fd9377149df174a1a12324f"></a><!-- doxytag: member="bslstl::StringRef" ref="a10921a5e7fd9377149df174a1a12324f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt;char&gt; <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb41ff59615d4ad2799e48a19ed5c1b1"></a><!-- doxytag: member="bslstl::StringRefWide" ref="adb41ff59615d4ad2799e48a19ed5c1b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt;wchar_t&gt; <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a064dc55e874a2088adf90e2b2e0686a1"></a><!-- doxytag: member="bslstl::operator==" ref="a064dc55e874a2088adf90e2b2e0686a1" args="(const BidirectionalIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const BidirectionalIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const BidirectionalIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BidirectionalIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators have the same value if they refer to the same element, or both have the past-the- end value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="afa4ee48809437ab2d069f79173424e5a"></a><!-- doxytag: member="bslstl::operator!=" ref="afa4ee48809437ab2d069f79173424e5a" args="(const BidirectionalIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const BidirectionalIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BidirectionalIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BidirectionalIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator does not have the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators do not have the same value if (1) they do not refer to the same element and (2) both do not have the past-the-end iterator value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a00890c2044ab22c5074a3d85283319d0"></a><!-- doxytag: member="bslstl::operator++" ref="a00890c2044ab22c5074a3d85283319d0" args="(BidirectionalIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the specified <code>iter</code> to the next element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the past-the-end value for an iterator of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a7d3362e2ffdbd7358a6d1b82f3a52ca1"></a><!-- doxytag: member="bslstl::operator&#45;&#45;" ref="a7d3362e2ffdbd7358a6d1b82f3a52ca1" args="(BidirectionalIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator-- </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrement the specified <code>iter</code> to the previous element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the same value as an iterator to the start of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a3da1086340fad5f33bd00ca4a5630fe6"></a><!-- doxytag: member="bslstl::swap" ref="a3da1086340fad5f33bd00ca4a5630fe6" args="(BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; &amp;a, BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the nodes of the specified <code>a</code> object with those of the specified <code>b</code> object. This method provides the no-throw exception-safety guarantee. The behavior is undefined unless <code>a.allocator() == b.allocator()</code>. </p>

</div>
</div>
<a class="anchor" id="a7f451481ffe1f393fc3e5c01d5170acd"></a><!-- doxytag: member="bslstl::operator==" ref="a7f451481ffe1f393fc3e5c01d5170acd" args="(const ForwardIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const ForwardIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators have the same value if they refer to the same element, or both have the past-the- end value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="ac4bdff7f9c3d766d890ec8f768778973"></a><!-- doxytag: member="bslstl::operator!=" ref="ac4bdff7f9c3d766d890ec8f768778973" args="(const ForwardIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const ForwardIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator does not have the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators do not have the same value if (1) they do not refer to the same element and (2) both do not have the past-the-end iterator value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a760a167fee692abe13531c5cc19bf26b"></a><!-- doxytag: member="bslstl::operator++" ref="a760a167fee692abe13531c5cc19bf26b" args="(ForwardIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the specified <code>iter</code> to the next element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the past-the-end value for an iterator of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a5cb036ae300679c34aab3c38b2eb9465"></a><!-- doxytag: member="bslstl::swap" ref="a5cb036ae300679c34aab3c38b2eb9465" args="(HashTable_HashWrapper&lt; FUNCTOR &gt; &amp;a, HashTable_HashWrapper&lt; FUNCTOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">HashTable_HashWrapper&lt; FUNCTOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashTable_HashWrapper&lt; FUNCTOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the functor wrapped by the specified <code>a</code> object with the functor wrapped by the specified <code>b</code> object. </p>

</div>
</div>
<a class="anchor" id="af6888ca123c5c2f7e71e24273291ba81"></a><!-- doxytag: member="bslstl::swap" ref="af6888ca123c5c2f7e71e24273291ba81" args="(HashTable_ComparatorWrapper&lt; FUNCTOR &gt; &amp;lhs, HashTable_ComparatorWrapper&lt; FUNCTOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">HashTable_ComparatorWrapper&lt; FUNCTOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashTable_ComparatorWrapper&lt; FUNCTOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the functor wrapped by the specified <code>lhs</code> object with the functor wrapped by the specified <code>rhs</code> object. </p>

</div>
</div>
<a class="anchor" id="ad670e66a5a51493256212888d0b0d323"></a><!-- doxytag: member="bslstl::swap" ref="ad670e66a5a51493256212888d0b0d323" args="(HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;x, HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap both the value, the hasher, the comparator and the <code>maxLoadFactor</code> of the specified <code>x</code> object with the value, the hasher, the comparator and the <code>maxLoadFactor</code> of the specified <code>y</code> object. Additionally, if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code>, then exchange the allocator of <code>x</code> with that of <code>y</code>, and do not modify either allocator otherwise. This method guarantees <code>O[1]</code> complexity if <code>x</code> and <code>y</code> have the same allocator or if the allocators propagate on swap, otherwise this operation will typically pay the cost of two copy constructors, which may in turn throw. If the allocators are the same or propagate, then this method provides the no-throw exception-safety guarantee unless the <code>swap</code> function of the hasher or comparator throw. Otherwise this method offers only the basic exception safety guarantee. </p>

</div>
</div>
<a class="anchor" id="a1063679c9d32371726a7a63b6df38b36"></a><!-- doxytag: member="bslstl::operator==" ref="a1063679c9d32371726a7a63b6df38b36" args="(const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> objects have the same value if they have the same number of elements, and for every subset of elements in <code>lhs</code> having keys that compare equal (according to that hash table's <code>comparator</code>), a corresponding subset of elements exists in <code>rhs</code>, having the same number of elements, where, for some permutation of the <code>lhs</code> subset, every element in that subset compares equal (using <code>operator==</code>) to the corresponding element in the <code>rhs</code> subset. The behavior is undefined unless both the <code>hasher</code> and <code>comparator</code> of <code>lhs</code> and <code>rhs</code> return the same value for every valid input. Note that this method requires that the <code>ValueType</code> of the parameterized <code>KEY_CONFIG</code> be <a href="group__bslstl__hashtable.html#requirements_on_key_config.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__hashtable.html#requirements_on_key_config" class="el">Requirements on <code>KEY_CONFIG</code></a>). </p>

</div>
</div>
<a class="anchor" id="add33aaba152cf25e05fcf72d3a9d8ca8"></a><!-- doxytag: member="bslstl::operator!=" ref="add33aaba152cf25e05fcf72d3a9d8ca8" args="(const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> objects do not have the same value if they do not have the same number of elements, or if, for any key found in <code>lhs</code>, the subset of elements having that key (according to the hash-table's <code>comparator</code>) in <code>lhs</code> either (1) does not have the same number of elements as the subset of elements having that key in <code>rhs</code>, or (2) there exists no permutation of the <code>lhs</code> subset where each element compares equal (using <code>operator==</code>) to the corresponding element in the <code>rhs</code> subset. The behavior is undefined unless both the <code>hasher</code> and <code>comparator</code> of <code>lhs</code> and <code>rhs</code> return the same value for every valid input. Note that this method requires that the <code>ValueType</code> of the parameterized <code>KEY_CONFIG</code> be <a href="group__bslstl__hashtable.html#requirements_on_key_config.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__hashtable.html#requirements_on_key_config" class="el">Requirements on <code>KEY_CONFIG</code></a>). </p>

</div>
</div>
<a class="anchor" id="a62fa543a36e28bf1a91438de01b9cfa8"></a><!-- doxytag: member="bslstl::operator==" ref="a62fa543a36e28bf1a91438de01b9cfa8" args="(const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0349c9a8b4bf4a9843f2e306056737b8"></a><!-- doxytag: member="bslstl::operator==" ref="a0349c9a8b4bf4a9843f2e306056737b8" args="(const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a26d1f3e1532d4ba7e1cc3ebf62c96479"></a><!-- doxytag: member="bslstl::operator==" ref="a26d1f3e1532d4ba7e1cc3ebf62c96479" args="(const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac4603167aa033e2f5bd4f8354c0aef11"></a><!-- doxytag: member="bslstl::operator==" ref="ac4603167aa033e2f5bd4f8354c0aef11" args="(const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators have the same value and <code>false</code> otherwise. Two iterators have the same value if they refer to the same element in the same hash table, or if both iterators are positioned after the end of a hash table bucket. </p>

</div>
</div>
<a class="anchor" id="a725c99e6c2ef2847af5414edc915e54b"></a><!-- doxytag: member="bslstl::operator!=" ref="a725c99e6c2ef2847af5414edc915e54b" args="(const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae109fff54930ec66ae4b28895f6bc5a8"></a><!-- doxytag: member="bslstl::operator!=" ref="ae109fff54930ec66ae4b28895f6bc5a8" args="(const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af61d7eb5a1906688dbbfa202ebf7ff59"></a><!-- doxytag: member="bslstl::operator!=" ref="af61d7eb5a1906688dbbfa202ebf7ff59" args="(const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a56da634318f5a84aeaaa8bc54e20d07c"></a><!-- doxytag: member="bslstl::operator!=" ref="a56da634318f5a84aeaaa8bc54e20d07c" args="(const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;lhs, const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTableBucketIterator&lt; const VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two iterators do not have the same value if they refer to the different elements in the same hash table, or if either (but not both) of the iterators are positioned after the end of a hash table bucket. </p>

</div>
</div>
<a class="anchor" id="ab52ab7ae3ed21c85bbdea0e93b7e8945"></a><!-- doxytag: member="bslstl::operator++" ref="ab52ab7ae3ed21c85bbdea0e93b7e8945" args="(HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1HashTableBucketIterator.html">HashTableBucketIterator</a>&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">HashTableBucketIterator&lt; VALUE_TYPE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the specified <code>iter</code> to the next element in the hash table bucket and return the value of <code>iter</code> prior to this call. The behavior is undefined unless <code>iter</code> refers to a valid (not yet erased) element in a bucket. Note that <code>iter</code> is invalidated when the underlying hash table is rehashed. </p>

</div>
</div>
<a class="anchor" id="ac95bb0338eaf3a0ed9b6193e1a32666f"></a><!-- doxytag: member="bslstl::swap" ref="ac95bb0338eaf3a0ed9b6193e1a32666f" args="(MapComparator&lt; KEY, VALUE, COMPARATOR &gt; &amp;a, MapComparator&lt; KEY, VALUE, COMPARATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">MapComparator&lt; KEY, VALUE, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapComparator&lt; KEY, VALUE, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This function provides the no-throw exception-safety guarantee. </p>

</div>
</div>
<a class="anchor" id="aecbf287bad6a393b3769e175a52c6d7c"></a><!-- doxytag: member="bslstl::operator==" ref="aecbf287bad6a393b3769e175a52c6d7c" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators have the same value if they refer to the same element, or both have the past-the- end value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="af7cb42eda52cb8743df718fe6a210dfb"></a><!-- doxytag: member="bslstl::operator!=" ref="af7cb42eda52cb8743df718fe6a210dfb" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator does not have the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators do not have the same value if (1) they do not refer to the same element and (2) both do not have the past-the-end iterator value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="ae8637170e8a9e783847423544ec50d0c"></a><!-- doxytag: member="bslstl::operator++" ref="ae8637170e8a9e783847423544ec50d0c" args="(RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the specified <code>iter</code> to next element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the past-the-end value for an iterator of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a30d8a025ea147a79a5aa83baabcfbfd8"></a><!-- doxytag: member="bslstl::operator&#45;&#45;" ref="a30d8a025ea147a79a5aa83baabcfbfd8" args="(RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator-- </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrement the specified <code>iter</code> to previous element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the same value as an iterator to the start of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a7f19a03f08152be8c8e39eabc14a3be3"></a><!-- doxytag: member="bslstl::operator+" ref="a7f19a03f08152be8c8e39eabc14a3be3" args="(const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;lhs, std::ptrdiff_t rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the element at the specified <code>rhs</code> positions past the specified <code>lhs</code>. The behavior is undefined unless <code>lhs</code>, after incrementing by <code>rhs</code>, is within the bounds of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a519f1e2cf1b83913964f970430856ad6"></a><!-- doxytag: member="bslstl::operator+" ref="a519f1e2cf1b83913964f970430856ad6" args="(std::ptrdiff_t lhs, const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the element at the specified <code>lhs</code> positions past the specified <code>rhs</code>. The behavior is undefined unless <code>rhs</code>, after incrementing by <code>lhs</code>, is within the bounds of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a6bef3ec6e42b48dd4f8f2d85049fc210"></a><!-- doxytag: member="bslstl::operator&#45;" ref="a6bef3ec6e42b48dd4f8f2d85049fc210" args="(const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;lhs, std::ptrdiff_t rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator- </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the element at the specified <code>rhs</code> positions before the specified <code>lhs</code>. The behavior is undefined unless <code>lhs</code>, after decrementing by <code>rhs</code>, is within the bounds of the underlying sequence. Note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      iter + (-rhs)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ae2e1bbf938782393591b4e286dbe019a"></a><!-- doxytag: member="bslstl::operator&#45;" ref="ae2e1bbf938782393591b4e286dbe019a" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t bslstl::operator- </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the distance from the specified <code>rhs</code> iterator to the specified <code>lhs</code> iterator. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. Note that the result might be negative. </p>

</div>
</div>
<a class="anchor" id="ab0ae7c327c10a640d4b992a1c3e09d5b"></a><!-- doxytag: member="bslstl::operator&lt;" ref="ab0ae7c327c10a640d4b992a1c3e09d5b" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if (1) the specified <code>lhs</code> iterator refers to an element before the specified <code>rhs</code> iterator in the iteration sequence, or (2) <code>rhs</code> (and not <code>lhs</code>) has the past-the-end value for an iterator over this sequence, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a2524127f15e9c740c4438e7dd9a0df0f"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a2524127f15e9c740c4438e7dd9a0df0f" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if (1) the specified <code>lhs</code> iterator refers to an element after the specified <code>rhs</code> iterator in the iteration sequence, or (2) <code>lhs</code> (and not <code>rhs</code>) has the past-the-end value for an iterator over this sequence, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a4b4b6cb26176b3a0019b8be3e114492f"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a4b4b6cb26176b3a0019b8be3e114492f" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if (1) the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, or (2) <code>lhs</code> refers to an element before <code>rhs</code> in the iteration sequence, or (3) <code>rhs</code> has the past-the-end value for an iterator over this sequence, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a4e28f5e3e7f7e66f033844d6c007e3b6"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a4e28f5e3e7f7e66f033844d6c007e3b6" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class ITER_IMP , class TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if (1) the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, or (2) <code>lhs</code> has the past-the-end value for an iterator over this sequence, or (3) <code>lhs</code> refers to an element after <code>rhs</code> in the iteration sequence, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="afbbb8131098bc296ee793cb4071e6520"></a><!-- doxytag: member="bslstl::swap" ref="afbbb8131098bc296ee793cb4071e6520" args="(SetComparator&lt; KEY, COMPARATOR &gt; &amp;a, SetComparator&lt; KEY, COMPARATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">SetComparator&lt; KEY, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SetComparator&lt; KEY, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This function provides the no-throw exception-safety guarantee. </p>

</div>
</div>
<a class="anchor" id="a51a4448bbcb4772a231f7852209652aa"></a><!-- doxytag: member="bslstl::operator==" ref="a51a4448bbcb4772a231f7852209652aa" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53b2e769f22f3fb61a3bf3fdadf3d079"></a><!-- doxytag: member="bslstl::operator==" ref="a53b2e769f22f3fb61a3bf3fdadf3d079" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a766ff04bbf040fd1d9a3327b3fe576cb"></a><!-- doxytag: member="bslstl::operator==" ref="a766ff04bbf040fd1d9a3327b3fe576cb" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a608629b084f15499578272c74314a995"></a><!-- doxytag: member="bslstl::operator==" ref="a608629b084f15499578272c74314a995" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b4a61741ae62fba3bd8aafec0626cac"></a><!-- doxytag: member="bslstl::operator==" ref="a0b4a61741ae62fba3bd8aafec0626cac" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b5ab509f3c1b81fa908e4636c5ff16f"></a><!-- doxytag: member="bslstl::operator==" ref="a7b5ab509f3c1b81fa908e4636c5ff16f" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a784b4104f5e5743c052a3d46f794a6a1"></a><!-- doxytag: member="bslstl::operator==" ref="a784b4104f5e5743c052a3d46f794a6a1" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the strings referred to by the specified <code>lhs</code> and <code>rhs</code> have the same lexicographic value, and <code>false</code> otherwise. Two strings have the same lexicographic value if they have the same length, and the respective values at each character position are the same. </p>

</div>
</div>
<a class="anchor" id="a689a400d8c71795d52682bc404ff1cd2"></a><!-- doxytag: member="bslstl::operator!=" ref="a689a400d8c71795d52682bc404ff1cd2" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a21cb98dc3e79c898d47195ddd68fcb2f"></a><!-- doxytag: member="bslstl::operator!=" ref="a21cb98dc3e79c898d47195ddd68fcb2f" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e3c330ecce3de90507e21750690d636"></a><!-- doxytag: member="bslstl::operator!=" ref="a7e3c330ecce3de90507e21750690d636" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab54861a375b01007f4a5b37a16f72edd"></a><!-- doxytag: member="bslstl::operator!=" ref="ab54861a375b01007f4a5b37a16f72edd" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae330745a6c3d94bf23689dcb4b242493"></a><!-- doxytag: member="bslstl::operator!=" ref="ae330745a6c3d94bf23689dcb4b242493" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91e0ef74edb43cf5e43039d7a51a301e"></a><!-- doxytag: member="bslstl::operator!=" ref="a91e0ef74edb43cf5e43039d7a51a301e" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaba9cb19a51780db17046adf48e95989"></a><!-- doxytag: member="bslstl::operator!=" ref="aaba9cb19a51780db17046adf48e95989" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the strings referred to by the specified <code>lhs</code> and <code>rhs</code> do not have the same lexicographic value, and <code>false</code> otherwise. Two strings do not have the same lexicographic value if they do not have the same length, or respective values at any character position are not the same. </p>

</div>
</div>
<a class="anchor" id="a62af990a7655b773e8fa8cbef27e11c5"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a62af990a7655b773e8fa8cbef27e11c5" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a852c89f4a2facfcf981d190c40d598fc"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a852c89f4a2facfcf981d190c40d598fc" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8efdf23241116e1f4afab74943a02f8"></a><!-- doxytag: member="bslstl::operator&lt;" ref="ad8efdf23241116e1f4afab74943a02f8" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2720b3d72171d8d831d576c914bc1937"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a2720b3d72171d8d831d576c914bc1937" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a29e7f76b182f71a3105c9cad20bc9f37"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a29e7f76b182f71a3105c9cad20bc9f37" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee079f1acfc52183d206bbc9f887b98d"></a><!-- doxytag: member="bslstl::operator&lt;" ref="aee079f1acfc52183d206bbc9f887b98d" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e61b3c34539d9cc031ed68104a919c5"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a9e61b3c34539d9cc031ed68104a919c5" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the string referred to by the specified <code>lhs</code> is lexicographically less than the string referred to by the specified <code>rhs</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6b1ae0407e51ac060e4ea000053643c0"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a6b1ae0407e51ac060e4ea000053643c0" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acc12e6d6b6fa5c949c2716b09b266a0b"></a><!-- doxytag: member="bslstl::operator&gt;" ref="acc12e6d6b6fa5c949c2716b09b266a0b" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf68974d96d294c01100e90e4bbf03c5"></a><!-- doxytag: member="bslstl::operator&gt;" ref="aaf68974d96d294c01100e90e4bbf03c5" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8cf8fa46ccb775af95b276a5b1c56c51"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a8cf8fa46ccb775af95b276a5b1c56c51" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae59d94f3d75fb38924e19a9ed2b586f1"></a><!-- doxytag: member="bslstl::operator&gt;" ref="ae59d94f3d75fb38924e19a9ed2b586f1" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a40d38fec7502dbd0ff03d399b2466462"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a40d38fec7502dbd0ff03d399b2466462" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a194191bdf7021dee6ab778d85bb0772b"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a194191bdf7021dee6ab778d85bb0772b" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the string referred to by the specified <code>lhs</code> is lexicographically greater than the string referred to by the specified <code>rhs</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aad89624494d7e6b8d602dd1570a2fbc8"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="aad89624494d7e6b8d602dd1570a2fbc8" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a41d962c19e7cd2717150e4e250eff499"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a41d962c19e7cd2717150e4e250eff499" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fcfedda927703699dd7f53468c6cc85"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a2fcfedda927703699dd7f53468c6cc85" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b3dffcd70cec8e7862187115105162c"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a5b3dffcd70cec8e7862187115105162c" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4bb7954f3aa25ee660d3d1088cd4ab6"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="ab4bb7954f3aa25ee660d3d1088cd4ab6" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a25d056447c04bcef8d21ba35747c8c34"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a25d056447c04bcef8d21ba35747c8c34" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af77cda2842b34b1dd69bd3d6cc9b6d31"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="af77cda2842b34b1dd69bd3d6cc9b6d31" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the string referred to by the specified <code>lhs</code> is lexicographically less than or equal to the string referred to by the specified <code>rhs</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a1b2c06ce27c05c33649175bea59aeda3"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a1b2c06ce27c05c33649175bea59aeda3" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5911b68cc5c963c6ae44c429efe1b37c"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a5911b68cc5c963c6ae44c429efe1b37c" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2139b94069ae5bfbc569b028955ad1dd"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a2139b94069ae5bfbc569b028955ad1dd" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2341fba5b5b9c924c815ace426d8fe5"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="ac2341fba5b5b9c924c815ace426d8fe5" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8bd6c73caf1e9d4fb775067486c41c6e"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a8bd6c73caf1e9d4fb775067486c41c6e" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="add8cfd74def58e7bf0f76f0dbd7bba9e"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="add8cfd74def58e7bf0f76f0dbd7bba9e" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91aeab0aee9450792161564ad39dd9e8"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a91aeab0aee9450792161564ad39dd9e8" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the string referred to by the specified <code>lhs</code> is lexicographically greater than or equal to the string referred to by the specified <code>rhs</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ad9b003210a2b3ec734ddcd40505ba459"></a><!-- doxytag: member="bslstl::operator+" ref="ad9b003210a2b3ec734ddcd40505ba459" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b13d228a164dc2fb066fc77652417d8"></a><!-- doxytag: member="bslstl::operator+" ref="a5b13d228a164dc2fb066fc77652417d8" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf1f45b7b7b1c5838932274f3cb13177"></a><!-- doxytag: member="bslstl::operator+" ref="aaf1f45b7b7b1c5838932274f3cb13177" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7f77b8445ad577f9fe04d501f9bb1dd"></a><!-- doxytag: member="bslstl::operator+" ref="aa7f77b8445ad577f9fe04d501f9bb1dd" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6c3d040dc8da6e0bf8edbb8894b8cdf"></a><!-- doxytag: member="bslstl::operator+" ref="ab6c3d040dc8da6e0bf8edbb8894b8cdf" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb4287a6eae0d6050e3147087fadb54b"></a><!-- doxytag: member="bslstl::operator+" ref="adb4287a6eae0d6050e3147087fadb54b" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a524b145b97b9c6499e1012d0fd322620"></a><!-- doxytag: member="bslstl::operator+" ref="a524b145b97b9c6499e1012d0fd322620" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>bsl::string</code> having the value of the concatenation of the strings referred to by the specified <code>lhs</code> and rhs' values. </p>

</div>
</div>
<a class="anchor" id="a548f0d8ad545bdc2fda693e87f91315c"></a><!-- doxytag: member="bslstl::operator&lt;&lt;" ref="a548f0d8ad545bdc2fda693e87f91315c" args="(std::basic_ostream&lt; CHAR_TYPE &gt; &amp;stream, const StringRefImp&lt; CHAR_TYPE &gt; &amp;stringRef)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CHAR_TYPE&gt;&amp; bslstl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stringRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the string bound to the specified <code>stringRef</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a5c20315ed215d90747c40caa9f8634ad"></a><!-- doxytag: member="bslstl::hashAppend" ref="a5c20315ed215d90747c40caa9f8634ad" args="(HASHALG &amp;hashAlg, const StringRefImp&lt; CHAR_TYPE &gt; &amp;input)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class HASHALG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::hashAppend </td>
          <td>(</td>
          <td class="paramtype">HASHALG &amp;&nbsp;</td>
          <td class="paramname"> <em>hashAlg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass the specified <code>input</code> to the specified <code>hashAlg</code> </p>

</div>
</div>
<a class="anchor" id="aa518402a2acc877e044a26294c7e1870"></a><!-- doxytag: member="bslstl::operator==" ref="aa518402a2acc877e044a26294c7e1870" args="(const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;lhs, const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators have the same value and <code>false</code> otherwise. Two iterators have the same value if they refer to the same position in the same tree, or if both iterators are at an invalid position in the tree (i.e., the <code>end</code> of the tree, or the default constructed value). </p>

</div>
</div>
<a class="anchor" id="a9e374c4a808b092fcf3a26ba95779fef"></a><!-- doxytag: member="bslstl::operator!=" ref="a9e374c4a808b092fcf3a26ba95779fef" args="(const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;lhs, const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two iterators do not have the same value if they differ in either the tree to which they refer or the position in that tree. </p>

</div>
</div>
<a class="anchor" id="a32cf6106957ddca059b0931ca630b3ae"></a><!-- doxytag: member="bslstl::operator++" ref="a32cf6106957ddca059b0931ca630b3ae" args="(TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class NODE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt;VALUE, NODE, DIFFERENCE_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the specified <code>iter</code> to the next element in the tree and return the value of <code>iter</code> prior to this call. The behavior is undefined unless the iterator refers to an element in the tree. </p>

</div>
</div>
<a class="anchor" id="aa876e8690c75d4354c8185281c5ae9e3"></a><!-- doxytag: member="bslstl::operator&#45;&#45;" ref="aa876e8690c75d4354c8185281c5ae9e3" args="(TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class NODE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt;VALUE, NODE, DIFFERENCE_TYPE&gt; bslstl::operator-- </td>
          <td>(</td>
          <td class="paramtype">TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the specified <code>iter</code> to the previous element in the tree and return the value of <code>iter</code> prior to this call. The behavior is undefined unless the iterator refers to the past-the-end or the non-leftmost element in the tree. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:08 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
