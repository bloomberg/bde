<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Namespace bslstl</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bslstl Namespace Reference<br/>
<small>
[<a class="el" href="group__bslstl__bidirectionaliterator.html">Component bslstl_bidirectionaliterator</a>,&nbsp;<a class="el" href="group__bslstl__bidirectionalnodepool.html">Component bslstl_bidirectionalnodepool</a>,&nbsp;<a class="el" href="group__bslstl__forwarditerator.html">Component bslstl_forwarditerator</a>,&nbsp;<a class="el" href="group__bslstl__hashtable.html">Component bslstl_hashtable</a>,&nbsp;<a class="el" href="group__bslstl__iteratorutil.html">Component bslstl_iteratorutil</a>,&nbsp;<a class="el" href="group__bslstl__mapcomparator.html">Component bslstl_mapcomparator</a>,&nbsp;<a class="el" href="group__bslstl__priorityqueue.html">Component bslstl_priorityqueue</a>,&nbsp;<a class="el" href="group__bslstl__queue.html">Component bslstl_queue</a>,&nbsp;<a class="el" href="group__bslstl__randomaccessiterator.html">Component bslstl_randomaccessiterator</a>,&nbsp;<a class="el" href="group__bslstl__setcomparator.html">Component bslstl_setcomparator</a>,&nbsp;<a class="el" href="group__bslstl__simplepool.html">Component bslstl_simplepool</a>,&nbsp;<a class="el" href="group__bslstl__stdexceptutil.html">Component bslstl_stdexceptutil</a>,&nbsp;<a class="el" href="group__bslstl__stringref.html">Component bslstl_stringref</a>,&nbsp;<a class="el" href="group__bslstl__stringrefdata.html">Component bslstl_stringrefdata</a>,&nbsp;<a class="el" href="group__bslstl__treeiterator.html">Component bslstl_treeiterator</a>,&nbsp;<a class="el" href="group__bslstl__treenode.html">Component bslstl_treenode</a>,&nbsp;<a class="el" href="group__bslstl__treenodepool.html">Component bslstl_treenodepool</a>,&nbsp;<a class="el" href="group__bslstl__unorderedmapkeyconfiguration.html">Component bslstl_unorderedmapkeyconfiguration</a>,&nbsp;<a class="el" href="group__bslstl__unorderedsetkeyconfiguration.html">Component bslstl_unorderedsetkeyconfiguration</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__ArrayProctor.html">HashTable_ArrayProctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1HashTable__ListProctor.html">HashTable_ListProctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1HashTable__ImpDetails.html">HashTable_ImpDetails</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1HashTable__Util.html">HashTable_Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1IteratorUtil.html">IteratorUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1MapComparator.html">MapComparator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1PriorityQueue__HasAllocatorType.html">PriorityQueue_HasAllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1Queue__HasAllocatorType.html">Queue_HasAllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SetComparator.html">SetComparator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SimplePool__Type.html">SimplePool_Type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SimplePool.html">SimplePool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1StdExceptUtil.html">StdExceptUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1StringRefData.html">StringRefData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeNode.html">TreeNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeNodePool.html">TreeNodePool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1UnorderedMapKeyConfiguration.html">UnorderedMapKeyConfiguration</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1UnorderedSetKeyConfiguration.html">UnorderedSetKeyConfiguration</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">StringRef</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; wchar_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#adb41ff59615d4ad2799e48a19ed5c1b1">StringRefWide</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a064dc55e874a2088adf90e2b2e0686a1">operator==</a> (const <a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#afa4ee48809437ab2d069f79173424e5a">operator!=</a> (const <a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a00890c2044ab22c5074a3d85283319d0">operator++</a> (<a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7d3362e2ffdbd7358a6d1b82f3a52ca1">operator--</a> (<a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a3da1086340fad5f33bd00ca4a5630fe6">swap</a> (<a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt; &amp;a, <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7f451481ffe1f393fc3e5c01d5170acd">operator==</a> (const <a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ac4bdff7f9c3d766d890ec8f768778973">operator!=</a> (const <a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T, ITER_IMP, <br class="typebreak"/>
TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a760a167fee692abe13531c5cc19bf26b">operator++</a> (<a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ad670e66a5a51493256212888d0b0d323">swap</a> (<a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;x, <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a1063679c9d32371726a7a63b6df38b36">operator==</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#add33aaba152cf25e05fcf72d3a9d8ca8">operator!=</a> (const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1HashTable.html">HashTable</a>&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ac95bb0338eaf3a0ed9b6193e1a32666f">swap</a> (<a class="el" href="classbslstl_1_1MapComparator.html">MapComparator</a>&lt; KEY, VALUE, COMPARATOR &gt; &amp;a, <a class="el" href="classbslstl_1_1MapComparator.html">MapComparator</a>&lt; KEY, VALUE, COMPARATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aecbf287bad6a393b3769e175a52c6d7c">operator==</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#af7cb42eda52cb8743df718fe6a210dfb">operator!=</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae8637170e8a9e783847423544ec50d0c">operator++</a> (<a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a30d8a025ea147a79a5aa83baabcfbfd8">operator--</a> (<a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7f19a03f08152be8c8e39eabc14a3be3">operator+</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;lhs, std::ptrdiff_t rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a519f1e2cf1b83913964f970430856ad6">operator+</a> (std::ptrdiff_t lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, <br class="typebreak"/>
ITER_IMP, TAG_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a6bef3ec6e42b48dd4f8f2d85049fc210">operator-</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;lhs, std::ptrdiff_t rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae2e1bbf938782393591b4e286dbe019a">operator-</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab0ae7c327c10a640d4b992a1c3e09d5b">operator&lt;</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a2524127f15e9c740c4438e7dd9a0df0f">operator&gt;</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a4b4b6cb26176b3a0019b8be3e114492f">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a4e28f5e3e7f7e66f033844d6c007e3b6">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#afbbb8131098bc296ee793cb4071e6520">swap</a> (<a class="el" href="classbslstl_1_1SetComparator.html">SetComparator</a>&lt; KEY, COMPARATOR &gt; &amp;a, <a class="el" href="classbslstl_1_1SetComparator.html">SetComparator</a>&lt; KEY, COMPARATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a51a4448bbcb4772a231f7852209652aa">operator==</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a53b2e769f22f3fb61a3bf3fdadf3d079">operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a766ff04bbf040fd1d9a3327b3fe576cb">operator==</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a608629b084f15499578272c74314a995">operator==</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a0b4a61741ae62fba3bd8aafec0626cac">operator==</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7b5ab509f3c1b81fa908e4636c5ff16f">operator==</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a784b4104f5e5743c052a3d46f794a6a1">operator==</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a689a400d8c71795d52682bc404ff1cd2">operator!=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a21cb98dc3e79c898d47195ddd68fcb2f">operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a7e3c330ecce3de90507e21750690d636">operator!=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab54861a375b01007f4a5b37a16f72edd">operator!=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae330745a6c3d94bf23689dcb4b242493">operator!=</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a91e0ef74edb43cf5e43039d7a51a301e">operator!=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aaba9cb19a51780db17046adf48e95989">operator!=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a62af990a7655b773e8fa8cbef27e11c5">operator&lt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a852c89f4a2facfcf981d190c40d598fc">operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ad8efdf23241116e1f4afab74943a02f8">operator&lt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a2720b3d72171d8d831d576c914bc1937">operator&lt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a29e7f76b182f71a3105c9cad20bc9f37">operator&lt;</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aee079f1acfc52183d206bbc9f887b98d">operator&lt;</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a9e61b3c34539d9cc031ed68104a919c5">operator&lt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a6b1ae0407e51ac060e4ea000053643c0">operator&gt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#acc12e6d6b6fa5c949c2716b09b266a0b">operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aaf68974d96d294c01100e90e4bbf03c5">operator&gt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a8cf8fa46ccb775af95b276a5b1c56c51">operator&gt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ae59d94f3d75fb38924e19a9ed2b586f1">operator&gt;</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a40d38fec7502dbd0ff03d399b2466462">operator&gt;</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a194191bdf7021dee6ab778d85bb0772b">operator&gt;</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aad89624494d7e6b8d602dd1570a2fbc8">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a41d962c19e7cd2717150e4e250eff499">operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a2fcfedda927703699dd7f53468c6cc85">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a5b3dffcd70cec8e7862187115105162c">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab4bb7954f3aa25ee660d3d1088cd4ab6">operator&lt;=</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a25d056447c04bcef8d21ba35747c8c34">operator&lt;=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#af77cda2842b34b1dd69bd3d6cc9b6d31">operator&lt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a1b2c06ce27c05c33649175bea59aeda3">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a5911b68cc5c963c6ae44c429efe1b37c">operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a2139b94069ae5bfbc569b028955ad1dd">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ac2341fba5b5b9c924c815ace426d8fe5">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a8bd6c73caf1e9d4fb775067486c41c6e">operator&gt;=</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#add8cfd74def58e7bf0f76f0dbd7bba9e">operator&gt;=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a91aeab0aee9450792161564ad39dd9e8">operator&gt;=</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ad9b003210a2b3ec734ddcd40505ba459">operator+</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a5b13d228a164dc2fb066fc77652417d8">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aaf1f45b7b7b1c5838932274f3cb13177">operator+</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aa7f77b8445ad577f9fe04d501f9bb1dd">operator+</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#ab6c3d040dc8da6e0bf8edbb8894b8cdf">operator+</a> (const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#adb4287a6eae0d6050e3147087fadb54b">operator+</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a524b145b97b9c6499e1012d0fd322620">operator+</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR_TYPE &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a548f0d8ad545bdc2fda693e87f91315c">operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR_TYPE &gt; &amp;stream, const <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt; CHAR_TYPE &gt; &amp;stringRef)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aa518402a2acc877e044a26294c7e1870">operator==</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE1, NODEPTR, DIFF &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE2, NODEPTR, DIFF &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a9e374c4a808b092fcf3a26ba95779fef">operator!=</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE1, NODEPTR, DIFF &gt; &amp;lhs, const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE2, NODEPTR, DIFF &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class NODE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, <br class="typebreak"/>
DIFFERENCE_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#a32cf6106957ddca059b0931ca630b3ae">operator++</a> (<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;iter, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class NODE , class DIFFERENCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, <br class="typebreak"/>
DIFFERENCE_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslstl.html#aa876e8690c75d4354c8185281c5ae9e3">operator--</a> (<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;iter, int)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a10921a5e7fd9377149df174a1a12324f"></a><!-- doxytag: member="bslstl::StringRef" ref="a10921a5e7fd9377149df174a1a12324f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt;char&gt; <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb41ff59615d4ad2799e48a19ed5c1b1"></a><!-- doxytag: member="bslstl::StringRefWide" ref="adb41ff59615d4ad2799e48a19ed5c1b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslstl_1_1StringRefImp.html">StringRefImp</a>&lt;wchar_t&gt; <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefWide</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a064dc55e874a2088adf90e2b2e0686a1"></a><!-- doxytag: member="bslstl::operator==" ref="a064dc55e874a2088adf90e2b2e0686a1" args="(const BidirectionalIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const BidirectionalIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const BidirectionalIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BidirectionalIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators have the same value if they refer to the same element, or both have the past-the- end value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="afa4ee48809437ab2d069f79173424e5a"></a><!-- doxytag: member="bslstl::operator!=" ref="afa4ee48809437ab2d069f79173424e5a" args="(const BidirectionalIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const BidirectionalIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BidirectionalIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BidirectionalIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator does not have the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators do not have the same value if (1) they do not refer to the same element and (2) both do not have the past-the-end iterator value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a00890c2044ab22c5074a3d85283319d0"></a><!-- doxytag: member="bslstl::operator++" ref="a00890c2044ab22c5074a3d85283319d0" args="(BidirectionalIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the specified <code>iter</code> to the next element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the past-the-end value for an iterator of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a7d3362e2ffdbd7358a6d1b82f3a52ca1"></a><!-- doxytag: member="bslstl::operator&#45;&#45;" ref="a7d3362e2ffdbd7358a6d1b82f3a52ca1" args="(BidirectionalIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1BidirectionalIterator.html">BidirectionalIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator-- </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrement the specified <code>iter</code> to the previous element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the same value as an iterator to the start of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a3da1086340fad5f33bd00ca4a5630fe6"></a><!-- doxytag: member="bslstl::swap" ref="a3da1086340fad5f33bd00ca4a5630fe6" args="(BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; &amp;a, BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap... TBD. </p>

</div>
</div>
<a class="anchor" id="a7f451481ffe1f393fc3e5c01d5170acd"></a><!-- doxytag: member="bslstl::operator==" ref="a7f451481ffe1f393fc3e5c01d5170acd" args="(const ForwardIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const ForwardIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators have the same value if they refer to the same element, or both have the past-the- end value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="ac4bdff7f9c3d766d890ec8f768778973"></a><!-- doxytag: member="bslstl::operator!=" ref="ac4bdff7f9c3d766d890ec8f768778973" args="(const ForwardIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const ForwardIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator does not have the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators do not have the same value if (1) they do not refer to the same element and (2) both do not have the past-the-end iterator value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a760a167fee692abe13531c5cc19bf26b"></a><!-- doxytag: member="bslstl::operator++" ref="a760a167fee692abe13531c5cc19bf26b" args="(ForwardIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1ForwardIterator.html">ForwardIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the specified <code>iter</code> to the next element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the past-the-end value for an iterator of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="ad670e66a5a51493256212888d0b0d323"></a><!-- doxytag: member="bslstl::swap" ref="ad670e66a5a51493256212888d0b0d323" args="(HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;x, HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap both the value, the hasher and the comparator of the specified <code>a</code> object with the value, the hasher and the comparator of the specified <code>b</code> object. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of <code>a</code> with that of <code>b</code>, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees O[1] complexity. The behavior is undefined unless both objects have the same allocator or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="a1063679c9d32371726a7a63b6df38b36"></a><!-- doxytag: member="bslstl::operator==" ref="a1063679c9d32371726a7a63b6df38b36" args="(const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> objects have the same value if they have the same number of elements, and for every subset of elements in <code>lhs</code> having keys that compare equal (according to that hash table's <code>comparator</code>), a corresponding subset of elements exists in <code>rhs</code>, having the same number of elements, where, for some permutation of the <code>lhs</code> subset, every element in that subset compares equal (using <code>operator==</code>) to the corresponding element in the <code>rhs</code> subset. This method requires that the <code>ValueType</code> of the parameterized <code>KEY_CONFIG</code> be <a href="group__bslstl__hashtable.html#requirements_on_key_config.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__hashtable.html#requirements_on_key_config" class="el">Requirements on <code>KEY_CONFIG</code></a>). The behavior is undefined unless both the <code>hasher</code> and <code>comparator</code> of <code>lhs</code> and <code>rhs</code> return the same value for every valid input. </p>

</div>
</div>
<a class="anchor" id="add33aaba152cf25e05fcf72d3a9d8ca8"></a><!-- doxytag: member="bslstl::operator!=" ref="add33aaba152cf25e05fcf72d3a9d8ca8" args="(const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashTable&lt; KEY_CONFIG, HASHER, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbslstl_1_1HashTable.html">HashTable</a></code> objects do not have the same value if they do not have the same number of elements, or if, for any key found in <code>lhs</code>, the subset of elements having that key (according to the hash-table's <code>comparator</code>) in <code>lhs</code> either (1) does not have the same number of elements as the subset of elements having that key in <code>rhs</code>, or (2) there exists no permutation of the <code>lhs</code> subset where each element compares equal (using <code>operator==</code>) to the corresponding element in the <code>rhs</code> subset. This method requires that the <code>ValueType</code> of the parameterized <code>KEY_CONFIG</code> be <a href="group__bslstl__hashtable.html#requirements_on_key_config.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__hashtable.html#requirements_on_key_config" class="el">Requirements on <code>KEY_CONFIG</code></a>). The behavior is undefined unless both the <code>hasher</code> and <code>comparator</code> of <code>lhs</code> and <code>rhs</code> return the same value for every valid input. </p>

</div>
</div>
<a class="anchor" id="ac95bb0338eaf3a0ed9b6193e1a32666f"></a><!-- doxytag: member="bslstl::swap" ref="ac95bb0338eaf3a0ed9b6193e1a32666f" args="(MapComparator&lt; KEY, VALUE, COMPARATOR &gt; &amp;a, MapComparator&lt; KEY, VALUE, COMPARATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">MapComparator&lt; KEY, VALUE, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapComparator&lt; KEY, VALUE, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This function provides the no-throw exception-safety guarantee. </p>

</div>
</div>
<a class="anchor" id="aecbf287bad6a393b3769e175a52c6d7c"></a><!-- doxytag: member="bslstl::operator==" ref="aecbf287bad6a393b3769e175a52c6d7c" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators have the same value if they refer to the same element, or both have the past-the- end value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="af7cb42eda52cb8743df718fe6a210dfb"></a><!-- doxytag: member="bslstl::operator!=" ref="af7cb42eda52cb8743df718fe6a210dfb" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> iterator does not have the same value as the specified <code>rhs</code> iterator, and <code>false</code> otherwise. Two iterators do not have the same value if (1) they do not refer to the same element and (2) both do not have the past-the-end iterator value for the underlying sequence. The behavior is undefined unless both iterators refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="ae8637170e8a9e783847423544ec50d0c"></a><!-- doxytag: member="bslstl::operator++" ref="ae8637170e8a9e783847423544ec50d0c" args="(RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the specified <code>iter</code> to next element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the past-the-end value for an iterator of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a30d8a025ea147a79a5aa83baabcfbfd8"></a><!-- doxytag: member="bslstl::operator&#45;&#45;" ref="a30d8a025ea147a79a5aa83baabcfbfd8" args="(RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator-- </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrement the specified <code>iter</code> to previous element. Return the previous value of <code>iter</code>. The behavior is undefined if, on entry, <code>iter</code> has the same value as an iterator to the start of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a7f19a03f08152be8c8e39eabc14a3be3"></a><!-- doxytag: member="bslstl::operator+" ref="a7f19a03f08152be8c8e39eabc14a3be3" args="(const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;lhs, std::ptrdiff_t rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the element at the specified <code>rhs</code> positions past the specified <code>lhs</code>. The behavior is undefined unless <code>lhs</code>, after incrementing by <code>rhs</code>, is within the bounds of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a519f1e2cf1b83913964f970430856ad6"></a><!-- doxytag: member="bslstl::operator+" ref="a519f1e2cf1b83913964f970430856ad6" args="(std::ptrdiff_t lhs, const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the element at the specified <code>lhs</code> positions past the specified <code>rhs</code>. The behavior is undefined unless <code>rhs</code>, after incrementing by <code>lhs</code>, is within the bounds of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a6bef3ec6e42b48dd4f8f2d85049fc210"></a><!-- doxytag: member="bslstl::operator&#45;" ref="a6bef3ec6e42b48dd4f8f2d85049fc210" args="(const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;lhs, std::ptrdiff_t rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1RandomAccessIterator.html">RandomAccessIterator</a>&lt;T,ITER_IMP,TAG_TYPE&gt; bslstl::operator- </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the element at the specified <code>rhs</code> positions before the specified <code>lhs</code>. The behavior is undefined unless <code>lhs</code>, after decrementing by <code>rhs</code>, is within the bounds of the underlying sequence. Note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      iter + (-rhs)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ae2e1bbf938782393591b4e286dbe019a"></a><!-- doxytag: member="bslstl::operator&#45;" ref="ae2e1bbf938782393591b4e286dbe019a" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t bslstl::operator- </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the distance from the specified <code>rhs</code> iterator to the specified <code>lhs</code> iterator. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. Note that the result might be negative. </p>

</div>
</div>
<a class="anchor" id="ab0ae7c327c10a640d4b992a1c3e09d5b"></a><!-- doxytag: member="bslstl::operator&lt;" ref="ab0ae7c327c10a640d4b992a1c3e09d5b" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if (1) the specified <code>lhs</code> iterator refers to an element before the specified <code>rhs</code> iterator in the iteration sequence, or (2) <code>rhs</code> (and not <code>lhs</code>) has the past-the-end value for an iterator over this sequence, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a2524127f15e9c740c4438e7dd9a0df0f"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a2524127f15e9c740c4438e7dd9a0df0f" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if (1) the specified <code>lhs</code> iterator refers to an element after the specified <code>rhs</code> iterator in the iteration sequence, or (2) <code>lhs</code> (and not <code>rhs</code>) has the past-the-end value for an iterator over this sequence, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a4b4b6cb26176b3a0019b8be3e114492f"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a4b4b6cb26176b3a0019b8be3e114492f" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if (1) the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, or (2) <code>lhs</code> refers to an element before <code>rhs</code> in the iteration sequence, or (3) <code>rhs</code> has the past-the-end value for an iterator over this sequence, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a4e28f5e3e7f7e66f033844d6c007e3b6"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a4e28f5e3e7f7e66f033844d6c007e3b6" args="(const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;lhs, const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename ITER_IMP , typename TAG_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIterator&lt; T1, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIterator&lt; T2, ITER_IMP, TAG_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if (1) the specified <code>lhs</code> iterator has the same value as the specified <code>rhs</code> iterator, or (2) <code>lhs</code> has the past-the-end value for an iterator over this sequence, or (3) <code>lhs</code> refers to an element after <code>rhs</code> in the iteration sequence, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are iterators into the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="afbbb8131098bc296ee793cb4071e6520"></a><!-- doxytag: member="bslstl::swap" ref="afbbb8131098bc296ee793cb4071e6520" args="(SetComparator&lt; KEY, COMPARATOR &gt; &amp;a, SetComparator&lt; KEY, COMPARATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::swap </td>
          <td>(</td>
          <td class="paramtype">SetComparator&lt; KEY, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SetComparator&lt; KEY, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This function provides the no-throw exception-safety guarantee. </p>

</div>
</div>
<a class="anchor" id="a51a4448bbcb4772a231f7852209652aa"></a><!-- doxytag: member="bslstl::operator==" ref="a51a4448bbcb4772a231f7852209652aa" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53b2e769f22f3fb61a3bf3fdadf3d079"></a><!-- doxytag: member="bslstl::operator==" ref="a53b2e769f22f3fb61a3bf3fdadf3d079" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a766ff04bbf040fd1d9a3327b3fe576cb"></a><!-- doxytag: member="bslstl::operator==" ref="a766ff04bbf040fd1d9a3327b3fe576cb" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a608629b084f15499578272c74314a995"></a><!-- doxytag: member="bslstl::operator==" ref="a608629b084f15499578272c74314a995" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b4a61741ae62fba3bd8aafec0626cac"></a><!-- doxytag: member="bslstl::operator==" ref="a0b4a61741ae62fba3bd8aafec0626cac" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b5ab509f3c1b81fa908e4636c5ff16f"></a><!-- doxytag: member="bslstl::operator==" ref="a7b5ab509f3c1b81fa908e4636c5ff16f" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a784b4104f5e5743c052a3d46f794a6a1"></a><!-- doxytag: member="bslstl::operator==" ref="a784b4104f5e5743c052a3d46f794a6a1" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the strings referred to by the specified <code>lhs</code> and <code>rhs</code> have the same lexicographic value, and <code>false</code> otherwise. Two strings have the same lexicographic value if they have the same length, and the respective values at each character position are the same. </p>

</div>
</div>
<a class="anchor" id="a689a400d8c71795d52682bc404ff1cd2"></a><!-- doxytag: member="bslstl::operator!=" ref="a689a400d8c71795d52682bc404ff1cd2" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a21cb98dc3e79c898d47195ddd68fcb2f"></a><!-- doxytag: member="bslstl::operator!=" ref="a21cb98dc3e79c898d47195ddd68fcb2f" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e3c330ecce3de90507e21750690d636"></a><!-- doxytag: member="bslstl::operator!=" ref="a7e3c330ecce3de90507e21750690d636" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab54861a375b01007f4a5b37a16f72edd"></a><!-- doxytag: member="bslstl::operator!=" ref="ab54861a375b01007f4a5b37a16f72edd" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae330745a6c3d94bf23689dcb4b242493"></a><!-- doxytag: member="bslstl::operator!=" ref="ae330745a6c3d94bf23689dcb4b242493" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91e0ef74edb43cf5e43039d7a51a301e"></a><!-- doxytag: member="bslstl::operator!=" ref="a91e0ef74edb43cf5e43039d7a51a301e" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaba9cb19a51780db17046adf48e95989"></a><!-- doxytag: member="bslstl::operator!=" ref="aaba9cb19a51780db17046adf48e95989" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the strings referred to by the specified <code>lhs</code> and <code>rhs</code> do not have the same lexicographic value, and <code>false</code> otherwise. Two strings do not have the same lexicographic value if they do not have the same length, or respective values at any character position are not the same. </p>

</div>
</div>
<a class="anchor" id="a62af990a7655b773e8fa8cbef27e11c5"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a62af990a7655b773e8fa8cbef27e11c5" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a852c89f4a2facfcf981d190c40d598fc"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a852c89f4a2facfcf981d190c40d598fc" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8efdf23241116e1f4afab74943a02f8"></a><!-- doxytag: member="bslstl::operator&lt;" ref="ad8efdf23241116e1f4afab74943a02f8" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2720b3d72171d8d831d576c914bc1937"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a2720b3d72171d8d831d576c914bc1937" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a29e7f76b182f71a3105c9cad20bc9f37"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a29e7f76b182f71a3105c9cad20bc9f37" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee079f1acfc52183d206bbc9f887b98d"></a><!-- doxytag: member="bslstl::operator&lt;" ref="aee079f1acfc52183d206bbc9f887b98d" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e61b3c34539d9cc031ed68104a919c5"></a><!-- doxytag: member="bslstl::operator&lt;" ref="a9e61b3c34539d9cc031ed68104a919c5" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the string referred to by the specified <code>lhs</code> is lexicographically less than the string referred to by the specified <code>rhs</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6b1ae0407e51ac060e4ea000053643c0"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a6b1ae0407e51ac060e4ea000053643c0" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acc12e6d6b6fa5c949c2716b09b266a0b"></a><!-- doxytag: member="bslstl::operator&gt;" ref="acc12e6d6b6fa5c949c2716b09b266a0b" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf68974d96d294c01100e90e4bbf03c5"></a><!-- doxytag: member="bslstl::operator&gt;" ref="aaf68974d96d294c01100e90e4bbf03c5" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8cf8fa46ccb775af95b276a5b1c56c51"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a8cf8fa46ccb775af95b276a5b1c56c51" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae59d94f3d75fb38924e19a9ed2b586f1"></a><!-- doxytag: member="bslstl::operator&gt;" ref="ae59d94f3d75fb38924e19a9ed2b586f1" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a40d38fec7502dbd0ff03d399b2466462"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a40d38fec7502dbd0ff03d399b2466462" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a194191bdf7021dee6ab778d85bb0772b"></a><!-- doxytag: member="bslstl::operator&gt;" ref="a194191bdf7021dee6ab778d85bb0772b" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the string referred to by the specified <code>lhs</code> is lexicographically greater than the string referred to by the specified <code>rhs</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aad89624494d7e6b8d602dd1570a2fbc8"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="aad89624494d7e6b8d602dd1570a2fbc8" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a41d962c19e7cd2717150e4e250eff499"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a41d962c19e7cd2717150e4e250eff499" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fcfedda927703699dd7f53468c6cc85"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a2fcfedda927703699dd7f53468c6cc85" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b3dffcd70cec8e7862187115105162c"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a5b3dffcd70cec8e7862187115105162c" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4bb7954f3aa25ee660d3d1088cd4ab6"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="ab4bb7954f3aa25ee660d3d1088cd4ab6" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a25d056447c04bcef8d21ba35747c8c34"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="a25d056447c04bcef8d21ba35747c8c34" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af77cda2842b34b1dd69bd3d6cc9b6d31"></a><!-- doxytag: member="bslstl::operator&lt;=" ref="af77cda2842b34b1dd69bd3d6cc9b6d31" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the string referred to by the specified <code>lhs</code> is lexicographically less than or equal to the string referred to by the specified <code>rhs</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a1b2c06ce27c05c33649175bea59aeda3"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a1b2c06ce27c05c33649175bea59aeda3" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5911b68cc5c963c6ae44c429efe1b37c"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a5911b68cc5c963c6ae44c429efe1b37c" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2139b94069ae5bfbc569b028955ad1dd"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a2139b94069ae5bfbc569b028955ad1dd" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2341fba5b5b9c924c815ace426d8fe5"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="ac2341fba5b5b9c924c815ace426d8fe5" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8bd6c73caf1e9d4fb775067486c41c6e"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a8bd6c73caf1e9d4fb775067486c41c6e" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="add8cfd74def58e7bf0f76f0dbd7bba9e"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="add8cfd74def58e7bf0f76f0dbd7bba9e" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91aeab0aee9450792161564ad39dd9e8"></a><!-- doxytag: member="bslstl::operator&gt;=" ref="a91aeab0aee9450792161564ad39dd9e8" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the string referred to by the specified <code>lhs</code> is lexicographically greater than or equal to the string referred to by the specified <code>rhs</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ad9b003210a2b3ec734ddcd40505ba459"></a><!-- doxytag: member="bslstl::operator+" ref="ad9b003210a2b3ec734ddcd40505ba459" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b13d228a164dc2fb066fc77652417d8"></a><!-- doxytag: member="bslstl::operator+" ref="a5b13d228a164dc2fb066fc77652417d8" args="(const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf1f45b7b7b1c5838932274f3cb13177"></a><!-- doxytag: member="bslstl::operator+" ref="aaf1f45b7b7b1c5838932274f3cb13177" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const bsl::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7f77b8445ad577f9fe04d501f9bb1dd"></a><!-- doxytag: member="bslstl::operator+" ref="aa7f77b8445ad577f9fe04d501f9bb1dd" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6c3d040dc8da6e0bf8edbb8894b8cdf"></a><!-- doxytag: member="bslstl::operator+" ref="ab6c3d040dc8da6e0bf8edbb8894b8cdf" args="(const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb4287a6eae0d6050e3147087fadb54b"></a><!-- doxytag: member="bslstl::operator+" ref="adb4287a6eae0d6050e3147087fadb54b" args="(const CHAR_TYPE *lhs, const StringRefImp&lt; CHAR_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a524b145b97b9c6499e1012d0fd322620"></a><!-- doxytag: member="bslstl::operator+" ref="a524b145b97b9c6499e1012d0fd322620" args="(const StringRefImp&lt; CHAR_TYPE &gt; &amp;lhs, const CHAR_TYPE *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt;CHAR_TYPE&gt; bslstl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR_TYPE *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>bsl::string</code> having the value of the concatenation of the strings referred to by the specified <code>lhs</code> and rhs' values. </p>

</div>
</div>
<a class="anchor" id="a548f0d8ad545bdc2fda693e87f91315c"></a><!-- doxytag: member="bslstl::operator&lt;&lt;" ref="a548f0d8ad545bdc2fda693e87f91315c" args="(std::basic_ostream&lt; CHAR_TYPE &gt; &amp;stream, const StringRefImp&lt; CHAR_TYPE &gt; &amp;stringRef)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CHAR_TYPE&gt;&amp; bslstl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRefImp&lt; CHAR_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stringRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the string bound to the specified <code>stringRef</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="aa518402a2acc877e044a26294c7e1870"></a><!-- doxytag: member="bslstl::operator==" ref="aa518402a2acc877e044a26294c7e1870" args="(const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;lhs, const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator== </td>
          <td>(</td>
          <td class="paramtype">const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators have the same value and <code>false</code> otherwise. Two iterators have the same value if they refer to the same position in the same tree, or if both iterators are at an invalid position in the tree (i.e., the <code>end</code> of the tree, or the default constructed value). </p>

</div>
</div>
<a class="anchor" id="a9e374c4a808b092fcf3a26ba95779fef"></a><!-- doxytag: member="bslstl::operator!=" ref="a9e374c4a808b092fcf3a26ba95779fef" args="(const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;lhs, const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bslstl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two iterators do not have the same value if they differ in either the tree to which they refer or the position in that tree. </p>

</div>
</div>
<a class="anchor" id="a32cf6106957ddca059b0931ca630b3ae"></a><!-- doxytag: member="bslstl::operator++" ref="a32cf6106957ddca059b0931ca630b3ae" args="(TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class NODE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt;VALUE, NODE, DIFFERENCE_TYPE&gt; bslstl::operator++ </td>
          <td>(</td>
          <td class="paramtype">TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the specified <code>iter</code> to the next element in the tree and return the value of <code>iter</code> prior to this call. The behavior is undefined unless the iterator refers to an element in the tree. </p>

</div>
</div>
<a class="anchor" id="aa876e8690c75d4354c8185281c5ae9e3"></a><!-- doxytag: member="bslstl::operator&#45;&#45;" ref="aa876e8690c75d4354c8185281c5ae9e3" args="(TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;iter, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class NODE , class DIFFERENCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt;VALUE, NODE, DIFFERENCE_TYPE&gt; bslstl::operator-- </td>
          <td>(</td>
          <td class="paramtype">TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the specified <code>iter</code> to the previous element in the tree and return the value of <code>iter</code> prior to this call. The behavior is undefined unless the iterator refers to the past-the-end or the non-leftmost element in the tree. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:20:06 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
