<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslalg_autoarraymovedestructor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_autoarraymovedestructor<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a proctor for destroying arrays.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Doubling the Length of an Array</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a proctor for destroying arrays. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslalg_1_1AutoArrayMoveDestructor.html">bslalg::AutoArrayMoveDestructor</a> </td><td>exception-neutrality guard for arrays  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__autodestructor.html" title="Provide a range proctor to manage an array of objects.">Component bslma_autodestructor</a>, <a class="el" href="group__bslalg__autoarraydestructor.html" title="Provide a proctor for destroying arrays.">Component bslalg_autoarraydestructor</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a proctor object to manage a contiguous (in-place) sequence of otherwise-unmanaged instances of a user-defined type. If not explicitly released, all objects managed by the proctor object are automatically destroyed by the proctor's destructor or moved back to their original area, using the <code>bslalg_arraydestructionprimitives</code> and <code>std::memmove</code>. This component is intended to be used only with bit-wise moveable types, and for a very special purpose as shown in the usage example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Overview of the operation of <code>AutoArrayMoveDestructor</code>: ---------------------------------------------------------------------------- Supposee we want to double the length of an array by prepending copies a <code>value</code> at the start of the array. Note that we assume there is ample uninitialized memory after the end of the initial array for these new values to be instered. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Legend: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="stringliteral">&#39;ABCDE&#39;</span>   -- initial array elements.
    <span class="charliteral">&#39;v&#39;</span>       -- copy of specified <span class="stringliteral">&#39;value&#39;</span> being inserted.
    <span class="charliteral">&#39;.&#39;</span>       -- (period) uninitialized memory.
    <span class="stringliteral">&#39;^(,)&#39;</span>    -- area guarded by <span class="stringliteral">&#39;AutoArrayMoveDestructor&#39;</span>, where:
                 <span class="charliteral">&#39;^&#39;</span> -- position of <span class="stringliteral">&#39;guard.destination()&#39;</span>
                 <span class="charliteral">&#39;(&#39;</span> -- position of <span class="stringliteral">&#39;guard.begin()&#39;</span>
                 <span class="charliteral">&#39;,&#39;</span> -- (comma) position of <span class="stringliteral">&#39;guard.middle()&#39;</span>
                 <span class="charliteral">&#39;)&#39;</span> -- position of <span class="stringliteral">&#39;guard.end()&#39;</span>
</pre></div><br/>
<br/>
 The copy constructor for the type being inserted may throw, so we need to have a guard object which allows us to make some guarantee about the state of the array after the guard is destroyed. What we want to guarantee is that there are as many valid objects at the start of the array as before with no other valid objects in existence. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following steps show a succssful operation prepending copies of the value <code>v</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  1: <span class="stringliteral">&#39;ABCDE.....&#39;</span>      -- initial memory.
  2: <span class="stringliteral">&#39;.....ABCDE&#39;</span>      -- memory after first <span class="stringliteral">&#39;std::memcpy&#39;</span>.
  3: <span class="stringliteral">&#39;^.....(,ABCDE)&#39;</span>  -- memory immediately after <span class="stringliteral">&#39;guard&#39;</span> is <span class="keyword">set</span>
  4: <span class="stringliteral">&#39;vv^...(AB,CDE)&#39;</span>  -- memory after 2 copies of <span class="stringliteral">&#39;value&#39;</span> have been
                          created, and <span class="stringliteral">&#39;guard.advance()&#39;</span> has been called
                          twice.
  5: <span class="stringliteral">&#39;vvvvv^(ABCDE,)&#39;</span>  -- memory after insertion is completed
  6: <span class="stringliteral">&#39;vvvvvABCDE&#39;</span>      -- memory after guard was destroyed (at which point
                          <span class="stringliteral">&#39;guard.middle() == guard.end()&#39;</span> so destructor did
                          nothing.
</pre></div><br/>
<br/>
 Now suppose we threw after step 4, destroying <code>guard</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  4:  <span class="stringliteral">&#39;vv^...(AB,CDE)&#39;</span> -- same as step <span class="charliteral">&#39;4&#39;</span> above, before destructor starts
  5b: <span class="stringliteral">&#39;vv^CDE(AB,...)&#39;</span> -- memory after <span class="stringliteral">&#39;guard&#39;</span>s destructor moves <span class="stringliteral">&#39;CDE&#39;</span> back
                          to their position before we began
  6b: <span class="stringliteral">&#39;vv^CDE(..,...)&#39;</span> -- memory after <span class="stringliteral">&#39;guard&#39;</span>s destructor destroys <span class="charliteral">&#39;A&#39;</span> and
                          <span class="charliteral">&#39;B&#39;</span>
  7b: <span class="stringliteral">&#39;vvCDE.....&#39;</span>     -- memory after <span class="stringliteral">&#39;guard&#39;</span>s destructor completes
</pre></div><br/>
<br/>
 We now have 5 valid elements in the beginning of the range, as it was when we started, making the situation predictable for our next destructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This was a very simple case, but using this guard in conjunction with <code><a class="el" href="classbslalg_1_1AutoArrayDestructor.html">bslalg::AutoArrayDestructor</a></code>, we can implment the more general case of inserting arbitrary numbers of elements at the beginning of an array. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_doubling_the_length_of_an_array"></a> <a class="anchor" id="usage.example_1~3A_doubling_the_length_of_an_array"></a> <a class="anchor" id="description.usage.example_1~3A_doubling_the_length_of_an_array"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Doubling the Length of an Array: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create the class <code>TestType</code>, which is bitwise-movable and allocates memory upon construction: <br/>
<br/>
<div class="fragment"><pre class="fragment">                             <span class="comment">// ==============</span>
                             <span class="comment">// class TestType</span>
                             <span class="comment">// ==============</span>

  <span class="keyword">class </span>TestType {
      <span class="comment">// This test type contains a &#39;char&#39; in some allocated storage.  It</span>
      <span class="comment">// counts the number of default and copy constructions, assignments,</span>
      <span class="comment">// and destructions.  It has no traits other than using a &#39;bslma&#39;</span>
      <span class="comment">// allocator.  It could have the bit-wise moveable traits but we defer</span>
      <span class="comment">// that trait to the &#39;MoveableTestType&#39;.</span>

      <span class="keywordtype">char</span>             *d_data_p;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> TestType(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_data_p(0)
      , d_allocator_p(bslma::Default::allocator(basicAllocator))
      {
          d_data_p  = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
          *d_data_p = <span class="charliteral">&#39;?&#39;</span>;
      }

      <span class="keyword">explicit</span> TestType(<span class="keywordtype">char</span> c, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_data_p(0)
      , d_allocator_p(bslma::Default::allocator(basicAllocator))
      {
          d_data_p  = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
          *d_data_p = c;
      }

      TestType(<span class="keyword">const</span> TestType&amp;   original,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_data_p(0)
      , d_allocator_p(bslma::Default::allocator(basicAllocator))
      {
          <span class="keywordflow">if</span> (&amp;original != <span class="keyword">this</span>) {
              d_data_p  = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
              *d_data_p = *original.d_data_p;
          }
      }

      ~TestType()
      {
          *d_data_p = <span class="charliteral">&#39;_&#39;</span>;
          d_allocator_p-&gt;deallocate(d_data_p);
          d_data_p = 0;
      }

      <span class="comment">// MANIPULATORS</span>
      TestType&amp; operator=(<span class="keyword">const</span> TestType&amp; rhs)
      {
          <span class="keywordflow">if</span> (&amp;rhs != <span class="keyword">this</span>) {
              <span class="keywordtype">char</span> *newData = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
              *d_data_p = <span class="charliteral">&#39;_&#39;</span>;
              d_allocator_p-&gt;deallocate(d_data_p);
              d_data_p  = newData;
              *d_data_p = *rhs.d_data_p;
          }
          <span class="keywordflow">return</span> *<span class="keyword">this</span>;
      }

      <span class="keywordtype">void</span> setDatum(<span class="keywordtype">char</span> c) { *d_data_p = c; }

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">char</span> datum()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *d_data_p; }
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> TestType&amp; lhs, <span class="keyword">const</span> TestType&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.datum() == rhs.datum();
  }

  <span class="comment">// TRAITS</span>
  <span class="keyword">namespace </span>BloombergLP {

  <span class="keyword">namespace </span>bslma {
  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>UsesBslmaAllocator&lt;TestType&gt; : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> {};
  }  <span class="comment">// close package namespace</span>

  <span class="keyword">namespace </span>bslma {
  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsBitwiseMoveable&lt;TestType&gt; : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> {};
  }  <span class="comment">// close package namespace</span>

  }  <span class="comment">// close enterprise namespace</span>
</pre></div><br/>
<br/>
 Then, we define the function <code>insertItems</code> which uses <code>AutoArrayMoveDestructor</code> to ensure that if an exception is thrown (e.g., when allocating memory), the array will be left in a state where it has the same number of elements, in the same location, as when the function begin (though not necessarily the same value). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> insertItems(TestType         *start,
                   TestType         *divider,
                   <span class="keyword">const</span> TestType    value,
                   <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
      <span class="comment">// The memory in the specified range &#39;[ start, divider )&#39; contains</span>
      <span class="comment">// valid elements, and the range of valid elements is to be doubled by</span>
      <span class="comment">// inserting &#39;divider - start&#39; copies of the specified &#39;value&#39; at</span>
      <span class="comment">// &#39;start&#39;, shifting the existing valid values back in memory.  Assume</span>
      <span class="comment">// that following the pointer &#39;divider&#39; is sufficient uninitialized</span>
      <span class="comment">// memory, and that the type &#39;TestType&#39; is bitwise-movable</span>
      <span class="comment">// (&#39;AutoArrayMoveDestructor&#39; will only work bitwise-movable types).</span>
  {
      TestType *finish = divider + (divider - start);

      <a class="code" href="group__bslmf__assert.html#ga25a196cf9f296d429b37512e9ad8ee27">BSLMF_ASSERT</a>(<a class="code" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable&lt; TestType&gt;::value</a>);
      <a class="code" href="group__bslmf__assert.html#ga25a196cf9f296d429b37512e9ad8ee27">BSLMF_ASSERT</a>(<a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator&lt;TestType&gt;::value</a>);

      <span class="comment">// The range &#39;[ start, divider )&#39; contains valid elements.  The range</span>
      <span class="comment">// &#39;[ divider, finish )&#39; is of equal length and contains uninitialized</span>
      <span class="comment">// memory.  We want to insert &#39;divider - start&#39; copies of the specified</span>
      <span class="comment">// &#39;value&#39; at the front half of the range &#39;[ start, finish )&#39;, moving</span>
      <span class="comment">// the exising elements back to make room for them.  Note that the copy</span>
      <span class="comment">// c&#39;tor of &#39;TestType&#39; allocates memory and may throw, so we have to</span>
      <span class="comment">// leave the array in a somewhat predicatable state if we do throw.</span>
      <span class="comment">// What the bslalg::AutoArrayMoveDestructor will do is guarantee that,</span>
      <span class="comment">// if it is destroyed before the insertion is complete, the range</span>
      <span class="comment">// &#39;[ start, divider )&#39; will contain valid elements, and that no other</span>
      <span class="comment">// valid elements will exist.</span>
      <span class="comment">//</span>
      <span class="comment">// Note that the existing elements, which are bitwise-moveable, may be</span>
      <span class="comment">// *moved* about the container without the possibility of throwing an</span>
      <span class="comment">// exception, but the newly inserted elements must be copy-constructed</span>
      <span class="comment">// (requiring memory allocation).</span>
      <span class="comment">//</span>
      <span class="comment">// First, move the valid elements from &#39;[ start, divider )&#39; to</span>
      <span class="comment">// &#39;[ divider, finish )&#39;.  This can be done without risk of a throw</span>
      <span class="comment">// occurring.</span>

      std::memcpy(divider, start, (divider - start) * <span class="keyword">sizeof</span>(TestType));

      <a class="code" href="classbslalg_1_1AutoArrayMoveDestructor.html">bslalg::AutoArrayMoveDestructor&lt;TestType&gt;</a> guard(start,
                                                      divider,
                                                      divider,
                                                      finish);

      <span class="keywordflow">while</span> (guard.middle() &lt; guard.end()) {
          <span class="comment">// Call the copy c&#39;tor, which may throw.</span>

          <span class="keyword">new</span> (guard.destination()) TestType(value, allocator);

          <span class="comment">// &#39;guard.advance()&#39; increments &#39;guard.destination()&#39; and</span>
          <span class="comment">// &#39;guard.middle()&#39; by one.</span>

          guard.advance();
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:47 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
