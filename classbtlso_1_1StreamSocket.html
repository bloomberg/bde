<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlso::StreamSocket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlso.html">btlso</a>      </li>
      <li><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket&lt; ADDRESS &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlso::StreamSocket&lt; ADDRESS &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlso::StreamSocket" -->
<p><code>#include &lt;<a class="el" href="btlso__streamsocket_8h_source.html">btlso_streamsocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlso::StreamSocket&lt; ADDRESS &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlso_1_1StreamSocket.png" usemap="#btlso::StreamSocket&lt; ADDRESS &gt;_map" alt=""/>
  <map id="btlso::StreamSocket&lt; ADDRESS &gt;_map" name="btlso::StreamSocket&lt; ADDRESS &gt;_map">
<area href="classbtlso_1_1InetStreamSocket.html" alt="btlso::InetStreamSocket&lt; ADDRESS &gt;" shape="rect" coords="0,56,224,80"/>
</map>
</div>

<p><a href="classbtlso_1_1StreamSocket-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a6ce8fbe6b03f5ba1517806d073e080c3">~StreamSocket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#ab139be1cd56e921ccb5c59b89d30f324">accept</a> (<a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt; ADDRESS &gt; **result)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a00310c3cd419984c2378429b7d9a48af">accept</a> (<a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt; ADDRESS &gt; **socket, ADDRESS *peerAddress)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a228da49e63aa2168283bbbc3ef50595b">bind</a> (const ADDRESS &amp;address)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#ab9ba5360e01c83b23deb820b22e83a80">connect</a> (const ADDRESS &amp;address)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a1369dadeaee4f34e57fac195f04ae94f">listen</a> (int backlog)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#aded1055cfd215bd6ae9cfd1723559a4a">read</a> (char *buffer, int length)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a5e77dab51358dfdb603aa7f3a58d2a8c">readv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#ae37bd2f372b33e69824a67cc863ac4f0">write</a> (const char *buffer, int length)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#ae4ad0aa34f9d01d28e4a00e76db73a0c">writev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#addad83353c2364adeb6608d5631b3d5f">writev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a8f80641594fa36ea7f7809158e0d4765">setBlockingMode</a> (<a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fc">btlso::Flag::BlockingMode</a> mode)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#ab55c62d3593db6d976223ce9a07aa6c8">shutdown</a> (<a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2c">btlso::Flag::ShutdownType</a> streamOption)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a3338803effb33adf0ff7fedc7c5748de">waitForConnect</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a72523ccb4195df6352c44ebcc0230632">waitForAccept</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a31c0d188e12127ebaface69f4b8783e1">waitForIO</a> (<a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603">btlso::Flag::IOWaitType</a> type, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a3919f6b708d8fd1688db037010ca0c99">waitForIO</a> (<a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603">btlso::Flag::IOWaitType</a> type)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#ae59b472fb1959cb9671246e4538866d9">setLingerOption</a> (const SocketOptUtil::LingerData &amp;options)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a2cd961ca861c0534a7c7f73e0744693f">setOption</a> (int level, int option, int value)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a99150fb3d4155be3d4b9a48aa472bb50">blockingMode</a> (<a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fc">btlso::Flag::BlockingMode</a> *result) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a7d1d22e0609c240f1851e77b96646043">connectionStatus</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#ae81e54f647121c797201d61067c785bf">handle</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#ad3df3ae4d09eff7bcce5360fc9b6ffb2">localAddress</a> (ADDRESS *result) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a06b531daeac4d0467f78dfdb10cb9c73">peerAddress</a> (ADDRESS *result) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a1898c0b78ac2e2d6b86551c9e05c517f">lingerOption</a> (SocketOptUtil::LingerData *result) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1StreamSocket.html#a30213f8b75c868edff6f4dda65f03991">socketOption</a> (int *result, int level, int option) const =0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class ADDRESS&gt;<br/>
 class btlso::StreamSocket&lt; ADDRESS &gt;</h3>

<p>This class defines a protocol for stream-based socket communications. The class is templatized to provide a family of type-safe address specializations (e.g., "IPv4", "IPv6"). Various socket-related operations including accepting and initiating connections and blocking/non-blocking I/O operations are provided. Vector I/O operations are also supported. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6ce8fbe6b03f5ba1517806d073e080c3"></a><!-- doxytag: member="btlso::StreamSocket::~StreamSocket" ref="a6ce8fbe6b03f5ba1517806d073e080c3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::~<a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this stream socket object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab139be1cd56e921ccb5c59b89d30f324"></a><!-- doxytag: member="btlso::StreamSocket::accept" ref="ab139be1cd56e921ccb5c59b89d30f324" args="(StreamSocket&lt; ADDRESS &gt; **result)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt; ADDRESS &gt; **&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept an incoming connection request and load into the specified <code>result</code> the address of the new socket. Return 0 on success, and a non-zero value otherwise. If this socket is in blocking mode, this function waits until a connection request is received or an error occurs. In non-blocking mode, if there is no pending connection request, this call returns immediately with an error status of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code>. The behavior is undefined unless this socket is listening for connections (i.e., unless <code>listen</code> has been called). </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a74237c27592bc477e1735d3bff9827bc">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a00310c3cd419984c2378429b7d9a48af"></a><!-- doxytag: member="btlso::StreamSocket::accept" ref="a00310c3cd419984c2378429b7d9a48af" args="(StreamSocket&lt; ADDRESS &gt; **socket, ADDRESS *peerAddress)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt; ADDRESS &gt; **&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>peerAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept an incoming connection request; load into the specified <code>socket</code>, the address of the new socket and into specified <code>peerAddress</code> the address of the peer. Return 0 on success, and a non-zero value otherwise. If this socket is in blocking mode, this function waits until a connection request is received or an error occurs. In non-blocking mode and there is no pending connection request, this call returns immediately with an error status of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code>. The behavior is undefined unless this socket is listening for connections (i.e., unless <code>listen</code> has been called). </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#abc361bc7c4bcdd9c9cf8fe65d196b7a5">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a228da49e63aa2168283bbbc3ef50595b"></a><!-- doxytag: member="btlso::StreamSocket::bind" ref="a228da49e63aa2168283bbbc3ef50595b" args="(const ADDRESS &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate the specified <code>address</code> with this socket. Return 0 on success, and a non-zero value otherwise. Note that, in order to receive connections on a socket, it must have an address associated with it, and when a socket is created, it has no associated address. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a2538fc6babbea46739d32847ab40505a">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab9ba5360e01c83b23deb820b22e83a80"></a><!-- doxytag: member="btlso::StreamSocket::connect" ref="ab9ba5360e01c83b23deb820b22e83a80" args="(const ADDRESS &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a connection to a peer process at the specified <code>address</code>. Return 0 on success, and a non-zero value otherwise. If this socket is in blocking mode, the call waits until a connection is established or an error occurs. In non-blocking mode and the connection cannot be established immediately <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> is returned. The <code>waitForConnect</code> method may then be used to determine when the connection request has completed. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a31eb95b48fe6a3296a649d29d542ebe1">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1369dadeaee4f34e57fac195f04ae94f"></a><!-- doxytag: member="btlso::StreamSocket::listen" ref="a1369dadeaee4f34e57fac195f04ae94f" args="(int backlog)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register this socket for accepting up to the specified <code>backlog</code> simultaneous connection requests. Return 0 on success, and a non-zero value otherwise. Note that the behavior is undefined unless <code>0 &lt; backlog</code>. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#adab926d2c6602a4b344d5c13b9559276">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aded1055cfd215bd6ae9cfd1723559a4a"></a><!-- doxytag: member="btlso::StreamSocket::read" ref="aded1055cfd215bd6ae9cfd1723559a4a" args="(char *buffer, int length)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::read </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read up to the specified <code>length</code> bytes from this socket into the specified <code>buffer</code>. If this socket is in non-blocking mode, or is in blocking mode and there is data available, the function reads as many bytes as possible without blocking. In blocking mode, if no data is available, the call waits until data is available, then reads as many bytes as possible without blocking. Return the positive total number of bytes read, or a negative value on error. If this socket is in non-blocking mode and zero bytes were immediately available, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> is returned. If this socket is in blocking mode and the call is interrupted before data is available, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. If the connection has been closed prior to this call and there is no data available, <code>SocketHandle::EOF</code> is returned. The behavior is undefined unless <code>0 &lt; length</code> and buffer provides capacity for at least <code>length</code> bytes. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a6a477eb389379df2a5cb4620e66ef74c">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5e77dab51358dfdb603aa7f3a58d2a8c"></a><!-- doxytag: member="btlso::StreamSocket::readv" ref="a5e77dab51358dfdb603aa7f3a58d2a8c" args="(const btls::Iovec *buffers, int numBuffers)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::readv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this socket into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as defined by the sum of the <code>buffers[i].length()</code> values. If this socket is in non-blocking mode, or is in blocking mode and there is data available, the function reads as many bytes as possible without blocking. In blocking mode, if no data is available, the call waits until data is available, then reads as many bytes as possible without blocking. Return the positive total number of bytes read, or a negative value on error. If this socket is in non-blocking mode and zero bytes were immediately available, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> is returned. If this socket is in blocking mode and the call is interrupted before data is available, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. If the connection has been closed prior to this call and there is no data available, <code>SocketHandle::EOF</code> is returned. The behavior is undefined unless <code>0 &lt; numBuffers</code> and at least one of the <code>buffers[i].length()</code> values is positive. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#ab896094717ff4053def5fa38d229322a">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae37bd2f372b33e69824a67cc863ac4f0"></a><!-- doxytag: member="btlso::StreamSocket::write" ref="ae37bd2f372b33e69824a67cc863ac4f0" args="(const char *buffer, int length)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write up to <code>length</code> bytes to this socket from the specified <code>buffer</code>; return the non-negative number of bytes written or, a negative value on error. In blocking mode, if there is no room to write the full message, the call blocks until the message is fully written. In non-blocking mode, the function writes as many bytes as possible without blocking, and returns the number of bytes written, or <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> if no bytes were written. If the connection has been closed <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcae59989ad2ee76ca0439e2e0ed1172481">SocketHandle::e_ERROR_CONNDEAD</a></code> is returned. If the call is interrupted before any data is written, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. The behavior is undefined unless <code>0 &lt; length</code>. Note that a successful call to this function does not guarantee that the data has been transmitted successfully, but simply that the data was written successfully to the underlying socket's transmit buffers. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a2579bddb8bc0e31bf30076e796cb6216">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae4ad0aa34f9d01d28e4a00e76db73a0c"></a><!-- doxytag: member="btlso::StreamSocket::writev" ref="ae4ad0aa34f9d01d28e4a00e76db73a0c" args="(const btls::Iovec *buffers, int numBuffers)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a5d9308dc6319898401fdf2650c5bab4c">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="addad83353c2364adeb6608d5631b3d5f"></a><!-- doxytag: member="btlso::StreamSocket::writev" ref="addad83353c2364adeb6608d5631b3d5f" args="(const btls::Ovec *buffers, int numBuffers)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this socket from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective number of bytes as defined by the sum of the <code>buffers[i].length()</code> values. Return the non-negative total number of bytes written, or a negative value on error. In blocking mode, if there is no room to write the full message, the call blocks until the message is fully written. In non-blocking mode, the function writes as many bytes as possible without blocking, and returns the number of bytes written, or <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code>, if no bytes were written. If the connection has been closed <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcae59989ad2ee76ca0439e2e0ed1172481">SocketHandle::e_ERROR_CONNDEAD</a></code> is returned. If the call is interrupted before any data is written, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. The behavior is undefined unless <code>0 &lt; numBuffers</code> and at least one of the <code>buffers[i].length()</code> values is positive. Note that a successful call to this function does not guarantee that the data has been transmitted successfully, but simply that the data was successfully written to the underlying socket's transmit buffers. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a5eefd29c3aab98b238e4fac8ccbe0025">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8f80641594fa36ea7f7809158e0d4765"></a><!-- doxytag: member="btlso::StreamSocket::setBlockingMode" ref="a8f80641594fa36ea7f7809158e0d4765" args="(btlso::Flag::BlockingMode mode)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::setBlockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fc">btlso::Flag::BlockingMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the current blocking mode of this socket to the specified <code>mode</code>. Return 0 on success, an a non-zero value otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#afcc8cd80e6573427791aaf64c1633414">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab55c62d3593db6d976223ce9a07aa6c8"></a><!-- doxytag: member="btlso::StreamSocket::shutdown" ref="ab55c62d3593db6d976223ce9a07aa6c8" args="(btlso::Flag::ShutdownType streamOption)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2c">btlso::Flag::ShutdownType</a>&nbsp;</td>
          <td class="paramname"> <em>streamOption</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shut down the input and/or output stream(s) specified by <code>streamOption</code> of the full-duplexed connection associated with this socket. Return 0 on success, and a non-zero value otherwise. Specifying <code>SHUTDOWN_RECEIVE</code> or <code>SHUTDOWN_SEND</code> closes the input or output streams, respectively, leaving the other stream unaffected. Specifying <code>SHUTDOWN_BOTH</code> closes both streams. Once the input (output) stream has been closed, any attempted read (write) operations will fail. Any data received after successfully shutting down the input stream will be acknowledged but silently discarded. Note that this function is typically used to transmit an EOF indication to the peer. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#aca27775f1d7b9c93b84b0d853b2c682d">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3338803effb33adf0ff7fedc7c5748de"></a><!-- doxytag: member="btlso::StreamSocket::waitForConnect" ref="a3338803effb33adf0ff7fedc7c5748de" args="(const bsls::TimeInterval &amp;timeout)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::waitForConnect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait until a pending outgoing connection request completes or until the specified absolute <code>timeout</code> is reached, whichever occurs first. Return 0 if the connection request has completed, and a non-zero value otherwise. Note that the completion of a connection request does not imply that a connection has been successfully established; a call to <code>connectionStatus</code> should be made to determine if the connection request completed successfully. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#aff89e88e24f5699423e1deb0f3801fa8">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a72523ccb4195df6352c44ebcc0230632"></a><!-- doxytag: member="btlso::StreamSocket::waitForAccept" ref="a72523ccb4195df6352c44ebcc0230632" args="(const bsls::TimeInterval &amp;timeout)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::waitForAccept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for an incoming connection request on this socket or until the specified absolute <code>timeout</code> is reached, whichever occurs first. Return 0 if a connection request has been received, and a non-zero value otherwise. Note that once a connection request has been received, a call to <code>accept</code> can be made to establish the connection. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a746678891094500a8cbd03f98bce0637">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a31c0d188e12127ebaface69f4b8783e1"></a><!-- doxytag: member="btlso::StreamSocket::waitForIO" ref="a31c0d188e12127ebaface69f4b8783e1" args="(btlso::Flag::IOWaitType type, const bsls::TimeInterval &amp;timeout)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::waitForIO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603">btlso::Flag::IOWaitType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for the occurrence of an I/O event matching the specified <code>type</code>, or until the specified absolute <code>timeout</code> is reached, whichever occurs first. Return a value indicating the type(s) of the event(s) occurred before <code>timeout</code>, if any, and a negative value otherwise. If <code>timeout</code> is reached without an I/O event matching <code>type</code>, a value of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaed8b3922b102aeab5676b53dcad04a36" title="A system call timed out.">SocketHandle::e_ERROR_TIMEDOUT</a></code> is returned. If this call is interrupted, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. Note that the return value is <code>type</code> if <code>type</code> is different from <code>IO_RW</code>, and one of <code>IO_READ</code>, <code>IO_WRITE</code>, or <code>IO_RW</code> if <code>type</code> is <code>IO_RW. Also note that if 'timeout</code> is in the past, this function will return a value indicating the type(s) of the event(s) currently available if polling the socket returns a matching event, and <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaed8b3922b102aeab5676b53dcad04a36" title="A system call timed out.">SocketHandle::e_ERROR_TIMEDOUT</a></code> otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a7181910a2b326f204730d9b251be308d">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3919f6b708d8fd1688db037010ca0c99"></a><!-- doxytag: member="btlso::StreamSocket::waitForIO" ref="a3919f6b708d8fd1688db037010ca0c99" args="(btlso::Flag::IOWaitType type)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::waitForIO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603">btlso::Flag::IOWaitType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for the occurrence of an I/O event matching the specified <code>type</code>. Return a value indicating the type(s) of the event(s) occurred, and a negative value on error. If this call is interrupted, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. Note that the return value is <code>type</code> if <code>type</code> is different from <code>IO_RW</code>, and one of <code>IO_READ</code>, <code>IO_WRITE</code>, or <code>IO_RW</code> if <code>type</code> is 'IO_RW. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#ab8a4ff9006089719efa4d77b2a17d801">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae59b472fb1959cb9671246e4538866d9"></a><!-- doxytag: member="btlso::StreamSocket::setLingerOption" ref="ae59b472fb1959cb9671246e4538866d9" args="(const SocketOptUtil::LingerData &amp;options)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::setLingerOption </td>
          <td>(</td>
          <td class="paramtype">const SocketOptUtil::LingerData &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the current linger options of this socket to the specified <code>options</code>. Return 0 on success, and a non-zero value otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a087616cbf28317e1d2a46f5efd4035e0">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2cd961ca861c0534a7c7f73e0744693f"></a><!-- doxytag: member="btlso::StreamSocket::setOption" ref="a2cd961ca861c0534a7c7f73e0744693f" args="(int level, int option, int value)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::setOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>option</code> (of the specified <code>level</code>) socket option on this socket to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. See <code>btlso_socketoptutil</code> for the list of commonly supported options. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a05d3883c28bdbeed2fffd9d91fd64c74">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a99150fb3d4155be3d4b9a48aa472bb50"></a><!-- doxytag: member="btlso::StreamSocket::blockingMode" ref="a99150fb3d4155be3d4b9a48aa472bb50" args="(btlso::Flag::BlockingMode *result) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::blockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fc">btlso::Flag::BlockingMode</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the current blocking mode of this socket. Return 0 on success, and a non-zero value without affecting <code>result</code> otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a5650ec77f080226fda5cf2936ddb936e">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7d1d22e0609c240f1851e77b96646043"></a><!-- doxytag: member="btlso::StreamSocket::connectionStatus" ref="a7d1d22e0609c240f1851e77b96646043" args="() const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::connectionStatus </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test the connection status of this socket. Return 0 if this socket has an established connection, and a non-zero value otherwise. A value of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcae59989ad2ee76ca0439e2e0ed1172481">SocketHandle::e_ERROR_CONNDEAD</a></code> is returned if a connection request has failed. Note that this method is typically used to determine the result of a non-blocking connection request. The behavior is undefined unless a connection request with <code>connect</code> has completed (independent of success or failure). </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a034dbde89fd63538947db5b0afb879ea">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae81e54f647121c797201d61067c785bf"></a><!-- doxytag: member="btlso::StreamSocket::handle" ref="ae81e54f647121c797201d61067c785bf" args="() const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::handle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the OS handle associated with this socket. Note that direct manipulation of the underlying stream may result in undefined behavior. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a3a4bcfce7dc655694ca357de924c3695">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocketFactory.html#a0d04e0214dc3075539e9b318120274ca">btlso::InetStreamSocketFactory&lt; ADDRESS &gt;::deallocate()</a>.</p>

</div>
</div>
<a class="anchor" id="ad3df3ae4d09eff7bcce5360fc9b6ffb2"></a><!-- doxytag: member="btlso::StreamSocket::localAddress" ref="ad3df3ae4d09eff7bcce5360fc9b6ffb2" args="(ADDRESS *result) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::localAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the local address of this socket. Return 0 on success, and a non-zero value with no effect on <code>result</code> otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a201558e806377bf44ab203eaf45dd2bc">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a06b531daeac4d0467f78dfdb10cb9c73"></a><!-- doxytag: member="btlso::StreamSocket::peerAddress" ref="a06b531daeac4d0467f78dfdb10cb9c73" args="(ADDRESS *result) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::peerAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the address of the peer connected to this socket. Return 0 on success, and a non-zero value with no effect on <code>result</code> otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a89eac6c93160150711c1007544ecd893">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1898c0b78ac2e2d6b86551c9e05c517f"></a><!-- doxytag: member="btlso::StreamSocket::lingerOption" ref="a1898c0b78ac2e2d6b86551c9e05c517f" args="(SocketOptUtil::LingerData *result) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::lingerOption </td>
          <td>(</td>
          <td class="paramtype">SocketOptUtil::LingerData *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the value of this socket's current linger option. Return 0 on success, and a non-zero value with no effect on <code>result</code> otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#a91741f4c0d010f8a2e0de359983ed0f6">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a30213f8b75c868edff6f4dda65f03991"></a><!-- doxytag: member="btlso::StreamSocket::socketOption" ref="a30213f8b75c868edff6f4dda65f03991" args="(int *result, int level, int option) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; ADDRESS &gt;::socketOption </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load int the specified <code>result</code> the value of the specified <code>option</code> of the specified <code>level</code> socket option on this socket. Return 0 on success and a non-zero value with no effect on <code>result</code> otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1InetStreamSocket.html#ae7aea87150a434d483d47bbb2a0674d5">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlso__streamsocket_8h_source.html">btlso_streamsocket.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
