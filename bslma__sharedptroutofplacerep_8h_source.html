<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_sharedptroutofplacerep.h                                     -*-C++-*-
#ifndef INCLUDED_BSLMA_SHAREDPTROUTOFPLACEREP
#define INCLUDED_BSLMA_SHAREDPTROUTOFPLACEREP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide an out-of-place implementation of &#39;bslma::SharedPtrRep&#39;.
//
//@CLASSES:
//  bslma::SharedPtrOutofplaceRep: out-of-place shared ptr implementation
//
//@SEE_ALSO: bslma_sharedptr, bslma_sharedptrrep, bslma_sharedptrinplacerep
//
//@DESCRIPTION: This component provides a concrete implementation of
// &#39;bslma::SharedPtrRep&#39; for managing objects of the parameterized &#39;TYPE&#39; that
// are stored outside of the representation.  When all references to the
// out-of-place object are released using &#39;releaseRef&#39;, the deleter of the
// parameterized &#39;DELETER&#39; type is invoked to delete the shared object.
//
///Thread Safety
///-------------
// &#39;bslma::SharedPtrOutofplaceRep&#39; is thread-safe provided that &#39;disposeObject&#39;
// and &#39;disposeRep&#39; are not called explicitly, meaning that all non-creator
// operations other than &#39;disposeObject&#39; and &#39;disposeRep&#39; on a given instance
// can be safely invoked simultaneously from multiple threads (&#39;disposeObject&#39;
// and &#39;disposeRep&#39; are meant to be invoked only by &#39;releaseRef&#39; and
// &#39;releaseWeakRef&#39;).  Note that there is no thread safety guarantees for
// operations on the managed object.
//
///Deleters
///--------
// When the last shared reference to a shared object is released, the object is
// destroyed using the &quot;deleter&quot; provided when the associated shared pointer
// representation was created.  &#39;bslma::SharedPtrOutofplaceRep&#39; supports two
// kinds of &quot;deleter&quot; objects, which vary in how they are invoked.  A
// &quot;function-like&quot; deleter is any language entity that can be invoked such that
// the expression &#39;deleterInstance(objectPtr)&#39; is a valid expression, and a
// &quot;factory&quot; deleter is any language entity that can be invoked such that the
// expression &#39;deleterInstance.deleteObject(objectPtr)&#39; is a valid expression,
// where &#39;deleterInstance&#39; is an instance of the &quot;deleter&quot; object, and
// &#39;objectPtr&#39; is a pointer to the shared object.  In summary:
//..
//  Deleter                     Expression used to destroy &#39;objectPtr&#39;
//  - - - - - - - -             - - - - - - - - - - - - - - - - - - -
//  &quot;function-like&quot;             deleterInstance(objectPtr);
//  &quot;factory&quot;                   deleterInstance.deleteObject(objectPtr);
//..
// The following are examples of function-like deleters that delete an object
// of &#39;MyType&#39;:
//..
//  void deleteObject(MyType *object);
//      // Delete the specified &#39;object&#39;.
//
//  void releaseObject(MyType *object);
//      // Release the specified &#39;object&#39;.
//
//  struct FunctionLikeDeleterObject {
//      // This &#39;struct&#39; provides an &#39;operator()&#39; that can be used to delete a
//      // &#39;MyType&#39; object.
//
//      void operator()(MyType *object);
//          // Destroy the specified &#39;object&#39;.
//  };
//..
// The following on the other hand is an example of a factory deleter:
//..
//  class MyFactory {
//
//     // . . .
//
//     // MANIPULATORS
//     MyType *createObject(bslma::Allocator *basicAllocator = 0);
//         // Create a &#39;MyType&#39; object.  Optionally specify a
//         // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//         // 0, the currently installed default allocator is used.
//
//     void deleteObject(MyType *object);
//         // Delete the specified &#39;object&#39;.
//  };
//..
// Note that &#39;deleteObject&#39; is provided by all &#39;bslma&#39; allocators and by any
// object that implements the &#39;bcema_Deleter&#39; protocol.  Thus, any of these
// objects can be used as a factory deleter.  The purpose of this design is to
// allow &#39;bslma&#39; allocators and factories to be used seamlessly as deleters.
//
// The selection of which expression is used by &#39;bslma::SharedPtrOutofplaceRep&#39;
// to destroy a shared object is based on how the deleter is passed to the
// shared pointer object: Deleters that are passed by *address* are assumed to
// be factory deleters, while those that are passed by *value* are assumed to
// be function-like.  Note that if the wrong interface is used for a deleter,
// i.e., if a function-like deleter is passed by pointer, or a factory deleter
// is passed by value, and the expression used to delete the object is invalid,
// a compiler diagnostic will be emitted indicating the error.
//
///Usage
///-----
// The following example demonstrates how to implement a shared &#39;bdet_Datetime&#39;
// object using &#39;bslma::SharedPtrOutofplaceRep&#39;:
//..
//  class MySharedDatetimePtr {
//      // This class provide a reference counted smart pointer to support
//      // shared ownership of a &#39;bdet_Datetime&#39; object.
//
//    private:
//      bdet_Datetime      *d_ptr_p;  // pointer to the managed object
//      bslma::SharedPtrRep *d_rep_p;  // pointer to the representation object
//
//    private:
//      // NOT IMPLEMENTED
//      MySharedDatetimePtr&amp; operator=(const MySharedDatetimePtr&amp;);
//
//    public:
//      // CREATORS
//      MySharedDatetimePtr(bdet_Datetime    *ptr,
//                          bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;MySharedDatetimePtr&#39; object to managed the specified
//          // &#39;ptr&#39;.  Optionally specify an &#39;basicAllocator&#39; to allocate and
//          // deallocate the internal representation and to destroy &#39;ptr&#39; when
//          // all references have been released.  The behavior is undefined
//          // unless &#39;ptr&#39; was allocated using memory supplied by
//          // &#39;basicAllocator&#39;.
//
//      MySharedDatetimePtr(const MySharedDatetimePtr&amp; original);
//          // Create a shared datetime that refers to the same object managed
//          // by the specified &#39;original&#39;
//
//      ~MySharedDatetimePtr();
//          // Destroy this shared datetime and release the reference to the
//          // &#39;bdet_Datetime&#39; object to which it might be referring.  If this
//          // is the last shared reference, deleted the managed object.
//
//      // MANIPULATORS
//      bdet_Datetime&amp; operator*() const;
//          // Return a modifiable reference to the shared datetime.
//
//      bdet_Datetime *operator-&gt;() const;
//          // Return the address of the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//
//      bdet_Datetime *ptr() const;
//          // Return the address of the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//  };
//..
// Finally, we define the implementation.
//..
//  MySharedDatetimePtr::MySharedDatetimePtr(bdet_Datetime    *ptr,
//                                           bslma::Allocator *basicAllocator)
//  {
//      d_ptr_p = ptr;
//      d_rep_p =
//           bslma::SharedPtrOutofplaceRep&lt;bdet_Datetime, bslma::Allocator *&gt;::
//                      makeOutofplaceRep(ptr, basicAllocator, basicAllocator);
//  }
//
//  MySharedDatetimePtr::MySharedDatetimePtr(
//                                         const MySharedDatetimePtr&amp; original)
//  : d_ptr_p(original.d_ptr_p)
//  , d_rep_p(original.d_rep_p)
//  {
//      if (d_ptr_p) {
//          d_rep_p-&gt;acquireRef();
//      } else {
//          d_rep_p = 0;
//      }
//  }
//
//  MySharedDatetimePtr::~MySharedDatetimePtr()
//  {
//      if (d_rep_p) {
//          d_rep_p-&gt;releaseRef();
//      }
//  }
//
//  bdet_Datetime&amp; MySharedDatetimePtr::operator*() const {
//      return *d_ptr_p;
//  }
//
//  bdet_Datetime *MySharedDatetimePtr::operator-&gt;() const {
//      return d_ptr_p;
//  }
//
//  bdet_Datetime *MySharedDatetimePtr::ptr() const {
//      return d_ptr_p;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_SHAREDPTRREP
#include &lt;bslma_sharedptrrep.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_CONDITIONAL
#include &lt;bslmf_conditional.h&gt;
#endif

#ifndef INCLUDED_BSLMF_FUNCTIONPOINTERTRAITS
#include &lt;bslmf_functionpointertraits.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISCONVERTIBLE
#include &lt;bslmf_isconvertible.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISFUNCTION
#include &lt;bslmf_isfunction.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISSAME
#include &lt;bslmf_issame.h&gt;
#endif

#ifndef INCLUDED_BSLMF_METAINT
#include &lt;bslmf_metaint.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

#ifndef INCLUDED_TYPEINFO
#include &lt;typeinfo&gt;
#define INCLUDED_TYPEINFO
#endif

namespace BloombergLP {
namespace bslma {

template &lt;class TYPE, class DELETER&gt;
struct SharedPtrOutofplaceRep_InitProctor;
struct SharedPtrOutofplaceRep_DeleterHelper;
struct SharedPtrOutofplaceRep_DeleterType;
template &lt;class DELETER&gt;
class SharedPtrOutofplaceRep_DeleterDiscriminator;

              // =========================================
              // struct SharedPtrOutofplaceRep_DeleterType
              // =========================================

struct SharedPtrOutofplaceRep_DeleterType {
    // This &#39;struct&#39; enumerates four kinds of deleters, the first two are
    // factory deleters, and the last two are function-like deleters.

    enum {
        // Enumeration used to discriminate among the different deleters.

        BSLMA_ALLOCATOR_PTR = 0,     // Used to indicate that a deleter is a
                                     // pointer that follows the &#39;Allocator&#39;
                                     // protocol.

        BSLMA_FACTORY_PTR = 1,       // Used to indicate that a deleter is a
                                     // pointer to a factory object that
                                     // implements the &#39;deleteObject&#39; protocol.

        BSLMA_FUNCTOR_WITH_ALLOC = 2,// Used to indicate that a deleter is a
                                     // functor that takes an allocator at
                                     // construction.

        BSLMA_FUNCTOR_WITHOUT_ALLOC = 3
                                     // Used to indicate that a deleter is a
                                     // functor that does not take an allocator
                                     // at construction.
    };
};

                     // ============================
                     // class SharedPtrOutofplaceRep
                     // ============================

template &lt;class TYPE, class DELETER&gt;
class SharedPtrOutofplaceRep : public SharedPtrRep {
    // This class provides a concrete implementation of the &#39;SharedPtrRep&#39;
    // protocol for out-of-place instances of the parameterized &#39;TYPE&#39;.  Upon
    // destruction of this object, the parameterized &#39;DELETER&#39; type is invoked
    // on the pointer to the shared object.

    // PRIVATE TYPES
    typedef SharedPtrOutofplaceRep_DeleterType DeleterType;
        // &#39;DeleterType&#39; is an alias for the &#39;struct&#39; that defines the types of
        // deleter used to destroy the shared object.

    typedef typename
      SharedPtrOutofplaceRep_DeleterDiscriminator&lt;DELETER&gt;::Type Deleter;
        // &#39;Deleter&#39; is an alias for the type of deleter used to destroy the
        // shared object.

    // DATA
    Deleter           d_deleter;     // deleter for this out-of-place instance
    TYPE             *d_ptr_p;       // pointer to out-of-place instance (held,
                                     // not owned)
    Allocator *d_allocator_p; // memory allocator (held, not owned)

  private:
    // NOT IMPLEMENTED
    SharedPtrOutofplaceRep(const SharedPtrOutofplaceRep&amp;);
    SharedPtrOutofplaceRep&amp; operator=(const SharedPtrOutofplaceRep&amp;);

    // PRIVATE CREATORS
    SharedPtrOutofplaceRep(TYPE           *ptr,
                           const DELETER&amp;  deleter,
                           Allocator      *basicAllocator,
                           bslmf::MetaInt&lt;DeleterType::BSLMA_ALLOCATOR_PTR&gt;);
    SharedPtrOutofplaceRep(TYPE           *ptr,
                           const DELETER&amp;  deleter,
                           Allocator      *basicAllocator,
                           bslmf::MetaInt&lt;DeleterType::BSLMA_FACTORY_PTR&gt;);
    SharedPtrOutofplaceRep(TYPE           *ptr,
                           const DELETER&amp;  deleter,
                           Allocator      *basicAllocator,
                        bslmf::MetaInt&lt;DeleterType::BSLMA_FUNCTOR_WITH_ALLOC&gt;);
    SharedPtrOutofplaceRep(TYPE           *ptr,
                           const DELETER&amp;  deleter,
                           Allocator      *basicAllocator,
                     bslmf::MetaInt&lt;DeleterType::BSLMA_FUNCTOR_WITHOUT_ALLOC&gt;);
        // Create a &#39;SharedPtrOutofplaceRep&#39; that manages the lifetime of the
        // specified &#39;ptr&#39;, using the specified &#39;deleter&#39; to destroy &#39;ptr&#39;, and
        // using the specified &#39;basicAllocator&#39; to supply memory.  Note that
        // &#39;basicAllocator&#39; will be used to destroy this representation object,
        // but not necessarily to destroy &#39;ptr&#39;.  Also note that
        // &#39;SharedPtrOutofplaceRep&#39; should be created using
        // &#39;makeOutofplaceRep&#39;, which will call the appropriate private
        // constructor depending on the parameterized &#39;DELETER&#39; type.

    ~SharedPtrOutofplaceRep();
        // Destroy this representation object and if the shared object has not
        // been deleted, delete the shared object using the associated deleter.
        // Note that this destructor is never called explicitly.  Instead,
        // &#39;disposeObject&#39; destroys the shared object object and &#39;disposeRep&#39;
        // deallocates this representation object.

  public:
    // CLASS METHODS
    static SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt; *makeOutofplaceRep(
                                           TYPE           *ptr,
                                           const DELETER&amp;  deleter,
                                           Allocator      *basicAllocator = 0);
        // Return the address of a newly created &#39;SharedPtrOutofplaceRep&#39;
        // object that manages the lifetime of the specified &#39;ptr&#39;, using the
        // specified &#39;deleter&#39; to destroy &#39;ptr&#39;.  Optionally, specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  Note that the
        // parameterized &#39;DELETER&#39; type will be used to deallocate the memory
        // pointed to by &#39;ptr&#39;.

    // MANIPULATORS
    virtual void disposeObject();
        // Destroy the object being referred to by this representation.  This
        // method is automatically invoked by &#39;releaseRef&#39; when the number of
        // shared references reaches zero and should not be explicitly invoked
        // otherwise.

    virtual void disposeRep();
        // Destroy this representation object and deallocate the associated
        // memory.  This method is automatically invoked by &#39;releaseRef&#39; and
        // &#39;releaseWeakRef&#39; when the number of weak references and the number
        // of shared references both reach zero and should not be explicitly
        // invoked otherwise.  The behavior is undefined unless &#39;disposeObject&#39;
        // has already been called for this representation.  Note that this
        // &#39;disposeRep&#39; method effectively serves as the representation
        // object&#39;s destructor.

    virtual void *getDeleter(const std::type_info&amp; type);
        // Return a pointer to the deleter stored by the derived representation
        // (if any) if the deleter has the same type as that described by the
        // specified &#39;type&#39;, and a null pointer otherwise.

    // ACCESSORS
    virtual void *originalPtr() const;
        // Return the (untyped) address of the modifiable shared object to
        // which this object refers.

    TYPE *ptr() const;
        // Return the address of the modifiable shared object to which this
        // object refers.
};

          // =================================================
          // class SharedPtrOutofplaceRep_DeleterDiscriminator
          // =================================================

template &lt;class DELETER, bool IS_ALLOC_PTR&gt;
class SharedPtrOutofplaceRep_DeleterDiscriminator_Imp {
    // This &#39;class&#39; provides the implementation of the
    // &#39;SharedPtrOutofplaceRep_DeleterDiscriminator&#39; for the &#39;DELETER&#39; template
    // parameter type which is not &#39;Allocator *&#39;.

    // PRIVATE TYPES
    enum {
        // Enumeration that calls meta-functions to describe properties of the
        // deleter.

        BSLMA_USES_ALLOC = UsesBslmaAllocator&lt;DELETER&gt;::value,

        BSLMA_IS_OBJ_PTR = bsl::is_pointer&lt;DELETER&gt;::value
                       &amp;&amp; !bslmf::IsFunctionPointer&lt;DELETER&gt;::value
    };

    typedef SharedPtrOutofplaceRep_DeleterType DeleterType;
        // &#39;DeleterType&#39; is an alias for the &#39;struct&#39; that defines the types of
        // deleter used to destroy the shared object.

  public:
    // TYPES
    enum {
        // This enumeration contains the return value of the meta-function.
        VALUE = BSLMA_USES_ALLOC
                ? DeleterType::BSLMA_FUNCTOR_WITH_ALLOC
                : !BSLMA_IS_OBJ_PTR
                  ? DeleterType::BSLMA_FUNCTOR_WITHOUT_ALLOC
                  : DeleterType::BSLMA_FACTORY_PTR
    };

    typedef typename bsl::conditional&lt;bsl::is_function&lt;DELETER&gt;::value,
                                      DELETER *,
                                      DELETER&gt;::type Type;
        // &#39;Type&#39; represents the type of the deleter used to destroy the shared
        // object.
};

template &lt;class DELETER&gt;
class SharedPtrOutofplaceRep_DeleterDiscriminator_Imp&lt;DELETER, true&gt; {
    // This &#39;class&#39; provides the implementation of the
    // &#39;SharedPtrOutofplaceRep_DeleterDiscriminator&#39; for the &#39;DELETER&#39; template
    // parameter type which is &#39;Allocator *&#39;.

    // PRIVATE TYPES
    typedef SharedPtrOutofplaceRep_DeleterType DeleterType;
        // &#39;DeleterType&#39; is an alias for the &#39;struct&#39; that defines the types of
        // deleter used to destroy the shared object.

  public:
    // TYPES
    enum {
        // This enumeration contains the return value of the meta-function.
        VALUE = DeleterType::BSLMA_ALLOCATOR_PTR
    };

    typedef Allocator *Type;
        // &#39;Type&#39; represents the type of the deleter used to destroy the shared
        // object.
};

template &lt;class DELETER&gt;
class SharedPtrOutofplaceRep_DeleterDiscriminator {
    // This &#39;class&#39; provides two meta-functions for determining the enumerated
    // type and the C++ type of a deleter based on whether it is a pointer to a
    // function, a pointer to a factory deleter, or an instance of a
    // function-like deleter.

    // PRIVATE TYPES
    typedef SharedPtrOutofplaceRep_DeleterDiscriminator_Imp&lt;
                              DELETER,
                              bsl::is_convertible&lt;DELETER, Allocator *&gt;::value&gt;
        ImpType;

  public:
    // TYPES
    enum {
        // This enumeration contains the return value of the meta-function.
        VALUE = ImpType::VALUE
    };

    typedef typename ImpType::Type Type;
        // &#39;Type&#39; represents the type of the deleter used to destroy the shared
        // object.
};

             // ===========================================
             // struct SharedPtrOutofplaceRep_DeleterHelper
             // ===========================================

struct SharedPtrOutofplaceRep_DeleterHelper {
    // This &#39;struct&#39; provides utility functions to apply a deleter to a shared
    // object referred to by &#39;SharedPtrOutofplaceRep&#39;.

    // PUBLIC TYPES
    typedef SharedPtrOutofplaceRep_DeleterType DeleterType;
        // &#39;DeleterType&#39; is an alias for the &#39;struct&#39; that defines the types of
        // deleter used to destroy the shared object.

  private:
    // PRIVATE CLASS METHODS
    template &lt;class TYPE, class DELETER&gt;
    static void deleteObject(TYPE     *ptr,
                             DELETER&amp;  deleter,
                             bslmf::MetaInt&lt;DeleterType::BSLMA_ALLOCATOR_PTR&gt;);
        // Delete the specified &#39;ptr&#39; using the specified &#39;deleter&#39; that
        // implements the &#39;Allocator&#39; protocol, which provides a &#39;deleteObject&#39;
        // function that can be invoked to delete &#39;ptr&#39;.

    template &lt;class TYPE, class DELETER&gt;
    static void deleteObject(TYPE     *ptr,
                             DELETER&amp;  deleter,
                             bslmf::MetaInt&lt;DeleterType::BSLMA_FACTORY_PTR&gt;);
        // Delete the specified &#39;ptr&#39; using the specified &#39;deleter&#39; that
        // provides a &#39;deleteObject&#39; function that can be invoked to delete
        // &#39;ptr&#39;.

    template &lt;class TYPE, class DELETER&gt;
    static void deleteObject(
                        TYPE     *ptr,
                        DELETER&amp;  deleter,
                        bslmf::MetaInt&lt;DeleterType::BSLMA_FUNCTOR_WITH_ALLOC&gt;);
        // Delete the specified &#39;ptr&#39; using the specified &#39;deleter&#39; that is a
        // functor that takes an allocator at construction and can be invoked
        // to delete &#39;ptr&#39;.

    template &lt;class TYPE, class DELETER&gt;
    static void deleteObject(
                     TYPE     *ptr,
                     DELETER&amp;  deleter,
                     bslmf::MetaInt&lt;DeleterType::BSLMA_FUNCTOR_WITHOUT_ALLOC&gt;);
        // Delete the specified &#39;ptr&#39; using the specified &#39;deleter&#39; that is a
        // functor that does not take an allocator at construction and can be
        // invoked to delete &#39;ptr&#39;.

  public:
    // CLASS METHODS
    template &lt;class TYPE, class DELETER&gt;
    static void deleteObject(TYPE *ptr, DELETER&amp; deleter);
        // Delete the specified &#39;ptr&#39; using the specified &#39;deleter&#39;.
};

               // =========================================
               // struct SharedPtrOutofplaceRep_InitProctor
               // =========================================

template &lt;class TYPE, class DELETER&gt;
struct SharedPtrOutofplaceRep_InitProctor {
    // This proctor is used for out-of-place shared pointer instantiations.
    // Generally, a proctor is created prior to constructing a
    // &#39;SharedPtrOutofplaceRep&#39; and released after successful construction.  In
    // the event that an exception is thrown during construction of the
    // representation, the proctor will delete the provided pointer using the
    // provided deleter.  Note that the provided deleter is held by reference
    // and must remain valid for the lifetime of the proctor.  If the proctor
    // is not released before it&#39;s destruction, a copy of the deleter is
    // instantiated to delete the pointer (in case &#39;operator()&#39; is
    // non-&#39;const&#39;).  Also note that if the deleter throws during
    // copy construction, the provided pointer will not be destroyed.

    // DATA
    TYPE           *d_ptr_p;    // address of the managed object (held, not
                                // owned)

    const DELETER&amp;  d_deleter;  // deleter used to destroy managed object

  public:
    // CREATORS
    SharedPtrOutofplaceRep_InitProctor(TYPE *ptr, const DELETER&amp; deleter);
        // Create a proctor referring to the specified &#39;ptr&#39; and using the
        // specified &#39;deleter&#39; to destroy &#39;ptr&#39; when the proctor is destroyed.

    ~SharedPtrOutofplaceRep_InitProctor();
        // Destroy this proctor and the object (if any) referred to by this
        // proctor.

    // MANIPULATORS
    void release();
        // Release from management the object referred to by this proctor.
};

// ============================================================================
//              INLINE FUNCTION AND FUNCTION TEMPLATE DEFINITIONS
// ============================================================================

                     // ----------------------------
                     // class SharedPtrOutofplaceRep
                     // ----------------------------

// CLASS FUNCTIONS
template &lt;class TYPE, class DELETER&gt;
SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt; *
               SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::makeOutofplaceRep(
                                                TYPE           *ptr,
                                                const DELETER&amp;  deleter,
                                                Allocator      *basicAllocator)
{
    SharedPtrOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt; proctor(ptr, deleter);

    enum { BSLMA_DELETER_TYPE =
                 SharedPtrOutofplaceRep_DeleterDiscriminator&lt;DELETER&gt;::VALUE };

    SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt; *rep = 0;

    basicAllocator = Default::allocator(basicAllocator);
    rep = new (*basicAllocator) SharedPtrOutofplaceRep(
                                         ptr,
                                         deleter,
                                         basicAllocator,
                                         bslmf::MetaInt&lt;BSLMA_DELETER_TYPE&gt;());

    proctor.release();

    return rep;
}

// CREATORS
template &lt;class TYPE, class DELETER&gt;
SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::SharedPtrOutofplaceRep(
                              TYPE           *ptr,
                              const DELETER&amp;  deleter,
                              Allocator      *basicAllocator,
                              bslmf::MetaInt&lt;DeleterType::BSLMA_ALLOCATOR_PTR&gt;)
: d_deleter(Default::allocator(deleter))
, d_ptr_p(ptr)
, d_allocator_p(basicAllocator)
{
}

template &lt;class TYPE, class DELETER&gt;
SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::SharedPtrOutofplaceRep(
                                TYPE           *ptr,
                                const DELETER&amp;  deleter,
                                Allocator      *basicAllocator,
                                bslmf::MetaInt&lt;DeleterType::BSLMA_FACTORY_PTR&gt;)
: d_deleter(deleter)
, d_ptr_p(ptr)
, d_allocator_p(basicAllocator)
{
}

template &lt;class TYPE, class DELETER&gt;
SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::SharedPtrOutofplaceRep(
                         TYPE           *ptr,
                         const DELETER&amp;  deleter,
                         Allocator      *basicAllocator,
                         bslmf::MetaInt&lt;DeleterType::BSLMA_FUNCTOR_WITH_ALLOC&gt;)
: d_deleter(deleter, basicAllocator)
, d_ptr_p(ptr)
, d_allocator_p(basicAllocator)
{
}

template &lt;class TYPE, class DELETER&gt;
SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::SharedPtrOutofplaceRep(
                      TYPE           *ptr,
                      const DELETER&amp;  deleter,
                      Allocator      *basicAllocator,
                      bslmf::MetaInt&lt;DeleterType::BSLMA_FUNCTOR_WITHOUT_ALLOC&gt;)
: d_deleter(deleter)
, d_ptr_p(ptr)
, d_allocator_p(basicAllocator)
{
}

template &lt;class TYPE, class DELETER&gt;
SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::~SharedPtrOutofplaceRep()
{
}

// MANIPULATORS
template &lt;class TYPE, class DELETER&gt;
void SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::disposeObject()
{
    SharedPtrOutofplaceRep_DeleterHelper::deleteObject(d_ptr_p, d_deleter);
    d_ptr_p = 0;
}

template &lt;class TYPE, class DELETER&gt;
inline
void SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::disposeRep()
{
    // If &#39;d_allocator_p-&gt;deleteObject&#39; is used to destroy the
    // &#39;SharedPtrOutofplaceRep&#39; object, a virtual function call will be used
    // and a &#39;dynamic_cast&#39; is required to obtain the address of the most
    // derived object to deallocate it.  Knowing &#39;SharedPtrOutofplaceRep&#39; is
    // the most derived class, this unnecessary overhead of a virtual function
    // call can be avoided by explicitly calling the destructor.  This behavior
    // is guaranteed by the standard ([class.virtual] 13: &quot;Explicit
    // qualification with the scope operator (5.1) suppresses the virtual call
    // mechanism.&quot;, page 224 of Working Draft 2007-10).

    this-&gt;SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::~SharedPtrOutofplaceRep();
    d_allocator_p-&gt;deallocate(this);
}

template &lt;class TYPE, class DELETER&gt;
inline
void *
SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::getDeleter(const std::type_info&amp; type)
{
    return (typeid(d_deleter) == type)
         ? bsls::Util::addressOf(d_deleter)
         : 0;
}

// ACCESSORS
template &lt;class TYPE, class DELETER&gt;
inline
void *SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::originalPtr() const
{
    return const_cast&lt;void *&gt;(static_cast&lt;const void *&gt;(d_ptr_p));
}

template &lt;class TYPE, class DELETER&gt;
inline
TYPE *SharedPtrOutofplaceRep&lt;TYPE, DELETER&gt;::ptr() const
{
    return d_ptr_p;
}

             // -------------------------------------------
             // struct SharedPtrOutofplaceRep_DeleterHelper
             // -------------------------------------------

// CLASS METHODS
template &lt;class TYPE, class DELETER&gt;
inline
void SharedPtrOutofplaceRep_DeleterHelper::deleteObject(
                              TYPE     *ptr,
                              DELETER&amp;  deleter,
                              bslmf::MetaInt&lt;DeleterType::BSLMA_ALLOCATOR_PTR&gt;)
{
    deleter-&gt;deleteObject(ptr);
}

template &lt;class TYPE, class DELETER&gt;
inline
void SharedPtrOutofplaceRep_DeleterHelper::deleteObject(
                                TYPE     *ptr,
                                DELETER&amp;  deleter,
                                bslmf::MetaInt&lt;DeleterType::BSLMA_FACTORY_PTR&gt;)
{
    deleter-&gt;deleteObject(ptr);
}

template &lt;class TYPE, class DELETER&gt;
inline
void SharedPtrOutofplaceRep_DeleterHelper::deleteObject(
                         TYPE     *ptr,
                         DELETER&amp;  deleter,
                         bslmf::MetaInt&lt;DeleterType::BSLMA_FUNCTOR_WITH_ALLOC&gt;)
{
    deleter(ptr);
}

template &lt;class TYPE, class DELETER&gt;
inline
void SharedPtrOutofplaceRep_DeleterHelper::deleteObject(
                      TYPE     *ptr,
                      DELETER&amp;  deleter,
                      bslmf::MetaInt&lt;DeleterType::BSLMA_FUNCTOR_WITHOUT_ALLOC&gt;)
{
    deleter(ptr);
}

template &lt;class TYPE, class DELETER&gt;
inline
void SharedPtrOutofplaceRep_DeleterHelper::deleteObject(TYPE     *ptr,
                                                        DELETER&amp;  deleter)
{
    enum { BSLMA_DELETER_TYPE =
                 SharedPtrOutofplaceRep_DeleterDiscriminator&lt;DELETER&gt;::VALUE };

    SharedPtrOutofplaceRep_DeleterHelper::deleteObject(
                                         ptr,
                                         deleter,
                                         bslmf::MetaInt&lt;BSLMA_DELETER_TYPE&gt;());
}

               // ---------------------------------------
               // struct SharedPtrOutofplaceRep_InitProctor
               // ---------------------------------------

// CREATORS
template &lt;class TYPE, class DELETER&gt;
inline
SharedPtrOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt;::
SharedPtrOutofplaceRep_InitProctor(TYPE *ptr, const DELETER&amp;  deleter)
: d_ptr_p(ptr)
, d_deleter(deleter)
{
}

template &lt;class TYPE, class DELETER&gt;
inline
SharedPtrOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt;::
~SharedPtrOutofplaceRep_InitProctor()
{
    // The definition of this function is intentionally *not* written as:
    //..
    //  if (d_ptr_p) {
    //      DELETER tempDeleter(d_deleter);
    //      SharedPtrOutofplaceRep_DeleterHelper::deleteObject(d_ptr_p,
    //                                                         tempDeleter);
    //  }
    //..
    // to work around a CC (Studio 12v4 on Solaris) compilation failure when
    // optimizations are enabled (&#39;opt_exc_mt&#39; and &#39;opt_exc_mt_64&#39;).

    if (!d_ptr_p) {
        return;                                                       // RETURN
    }

    typename bsl::conditional&lt;bsl::is_function&lt;DELETER&gt;::value,
                              DELETER *,
                              DELETER&gt;::type tempDeleter(d_deleter);
    SharedPtrOutofplaceRep_DeleterHelper::deleteObject(d_ptr_p, tempDeleter);
}

// MANIPULATORS
template &lt;class TYPE, class DELETER&gt;
inline
void SharedPtrOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt;::release()
{
    d_ptr_p = 0;
}

// ============================================================================
//                              TYPE TRAITS
// ============================================================================

template &lt;class TYPE, class DELETER&gt;
struct UsesBslmaAllocator&lt;SharedPtrOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt; &gt;
    : bsl::false_type
{
};

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
