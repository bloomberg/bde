<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslstl_unorderedmap.h                                              -*-C++-*-
#ifndef INCLUDED_BSLSTL_UNORDEREDMAP
#define INCLUDED_BSLSTL_UNORDEREDMAP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an STL-compliant &#39;unordered_map&#39; container.
//
//@CLASSES:
//   bsl::unordered_map : STL-compliant &#39;unordered_map&#39; container
//
//@SEE_ALSO: bsl+stdhdrs
//
//@DESCRIPTION: This component defines a single class template,
// &#39;bsl::unordered_map&#39;, implementing the standard container holding a
// collection of unique keys, each mapped to an associated value with no
// guarantees on ordering.
//
// An instantiation of &#39;unordered_map&#39; is an allocator-aware, value-semantic
// type whose salient attributes are its size (number of keys) and the set of
// key-value pairs the &#39;unordered_map&#39; contains, without regard to their order.
// If &#39;unordered_map&#39; is instantiated with a key type or mapped value-type that
// is not itself value-semantic, then it will not retain all of its
// value-semantic qualities.  In particular, if the key or value type cannot be
// tested for equality, then an &#39;unordered_map&#39; containing that type cannot be
// tested for equality.  It is even possible to instantiate &#39;unordered_map&#39;
// with types that do not have an accessible copy-constructor, in which case
// the &#39;unordered_map&#39; will not be copyable.  Note that the equality comparison
// operator for each key-value pair is used to determine when two
// &#39;unordered_map&#39; objects have the same value, and not the instance of the
// &#39;EQUAL&#39; template parameter supplied at construction.
//
// An &#39;unordered_map&#39; meets the requirements of an unordered associative
// container with forward iterators in the C++11 standard [unord].  The
// &#39;unordered_map&#39; implemented here adheres to the C++11 standard, except that
// it may rehash when setting the &#39;max_load_factor&#39; in order to preserve the
// property that the value is always respected (which is a potentially throwing
// operation) and it does not have interfaces that take rvalue references,
// &#39;initializer_list&#39;, &#39;emplace&#39;, or operations taking a variadic number of
// template parameters.  Note that excluded C++11 features are those that
// require (or are greatly simplified by) C++11 compiler support.
//
///Requirements on &#39;KEY&#39; and &#39;VALUE&#39;
///---------------------------------
// An &#39;unordered_map&#39; instantiation is a fully &quot;Value-Semantic Type&quot; (see
// {&#39;bsldoc_glossary&#39;}) only if the supplied &#39;KEY&#39; and &#39;VALUE&#39; template
// parameters are fully value-semantic.  It is possible to instantiate an
// &#39;unordered_map&#39; with &#39;KEY&#39; and &#39;VALUE&#39; parameter arguments that do not
// provide a full set of value-semantic operations, but then some methods of
// the container may not be instantiable.  The following terminology, adopted
// from the C++11 standard, is used in the function documentation of
// &#39;unordered_map&#39; to describe a function&#39;s requirements for the &#39;KEY&#39; and
// &#39;VALUE&#39; template parameters.  These terms are also defined in section
// [utility.arg.requirements] of the C++11 standard.  Note that, in the context
// of an &#39;unordered_map&#39; instantiation, the requirements apply specifically to
// the &#39;unordered_map&#39;s element type, &#39;value_type&#39;, which is an alias for
// &#39;std::pair&lt;const KEY, VALUE&gt;&#39;.
//
//: &quot;default-constructible&quot;:
//:     The type provides an accessible default constructor.
//:
//: &quot;copy-constructible&quot;:
//:     The type provides an accessible copy constructor.
//:
//: &quot;equality-comparable&quot;:
//:     The type provides an equality-comparison operator that defines an
//:     equivalence relationship and is both reflexive and transitive.
//
///Requirements on &#39;HASH&#39; and &#39;EQUAL&#39;
///----------------------------------
// The (template parameter) types &#39;HASH&#39; and &#39;EQUAL&#39; must be copy-constructible
// function-objects.  Note that this requirement is somewhat stronger than the
// requirement currently in the standard; see the discussion for Issue 2215
// (http://cplusplus.github.com/LWG/lwg-active.html#2215);
//
// Naturally, if either &#39;HASH&#39; or &#39;EQUAL&#39; is to be the default for its type, it
// must be default-constructible as well.
//
// &#39;HASH&#39; shall support a function call operator compatible with the following
// statements:
//..
//  HASH        hash;
//  KEY         key;
//  std::size_t result = hash(key);
//..
// where the definition of the called function meets the requirements of a
// hash function as specified in {&#39;bslstl_hash&#39;|Standard Hash Function}.
//
// &#39;EQUAL&#39; shall support the a function call operator compatible with the
//  following statements:
//..
//  EQUAL equal;
//  KEY   key1, key2;
//  bool  result = equal(key1, key2);
//..
// where the definition of the called function defines an equivalence
// relationship on keys that is both reflexive and transitive.
//
// &#39;HASH&#39; and &#39;EQUAL&#39; function-objects are further constrained, such for any
// two objects whose keys compare equal by the comparator, shall produce the
// same value from the hasher.
//
///Memory Allocation
///-----------------
// The type supplied as the &#39;ALLOCATOR&#39; template parameter determines how
// memory will be allocated.  The &#39;unordered_map&#39; template supports allocators
// meeting the requirements of the C++11 standard [allocator.requirements],
// and, in addition, it supports scoped-allocators derived from the
// &#39;bslma::Allocator&#39; memory allocation protocol.  Clients intending to use
// &#39;bslma&#39; style allocators should use the template&#39;s default &#39;ALLOCATOR&#39; type:
// The default type for the &#39;ALLOCATOR&#39; template parameter, &#39;bsl::allocator&#39;,
// provides a C++11 standard-compatible adapter for a &#39;bslma::Allocator&#39;
// object.
//
///&#39;bslma&#39;-Style Allocators
/// - - - - - - - - - - - -
// If the (template parameter) type &#39;ALLOCATOR&#39; of an &#39;unordered_map&#39;
// instantiation is &#39;bsl::allocator&#39;, then objects of that unordered map type
// will conform to the standard behavior of a &#39;bslma&#39;-allocator-enabled type.
// Such an unordered map accepts an optional &#39;bslma::Allocator&#39; argument at
// construction.  If the address of a &#39;bslma::Allocator&#39; object is explicitly
// supplied at construction, it will be used to supply memory for the
// &#39;unordered_map&#39; throughout its lifetime; otherwise, the &#39;unordered_map&#39; will
// use the default allocator installed at the time of the &#39;unordered_map&#39;s
// construction (see &#39;bslma_default&#39;).  In addition to directly allocating
// memory from the indicated &#39;bslma::Allocator&#39;, an &#39;unordered_map&#39; supplies
// that allocator&#39;s address to the constructors of contained objects of the
// (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; having the
// &#39;bslalg::TypeTraitUsesBslmaAllocator&#39; trait.
//
///Operations
///----------
// This section describes the run-time complexity of operations on instances
// of &#39;unordered_map&#39;:
//..
//  Legend
//  ------
//  &#39;K&#39;               - template parameter type &#39;KEY&#39; of the unordered map
//  &#39;V&#39;               - template parameter type &#39;VALUE&#39; of the unordered map
//  &#39;a&#39;, &#39;b&#39;          - two distinct objects of type &#39;unordered_map&lt;K, V&gt;&#39;
//  &#39;n&#39;, &#39;m&#39;          - number of elements in &#39;a&#39; and &#39;b&#39;, respectively
//  &#39;w&#39;               - number of buckets of &#39;a&#39;
//  &#39;value_type&#39;      - &#39;unordered_map&lt;K, V&gt;::value_type&#39;
//  &#39;hf&#39;              - hash functor hashing objects of type &#39;K&#39;
//  &#39;eq&#39;              - equality functor comparing objects of type &#39;K&#39;
//  &#39;al               - an STL-style memory allocator
//  &#39;i1&#39;, &#39;i2&#39;        - two iterators defining a sequence of &#39;value_type&#39;
//                      objects
//  &#39;k&#39;               - an object of type &#39;K&#39;
//  &#39;v&#39;               - an object of type &#39;value_type&#39;
//  &#39;p1&#39;, &#39;p2&#39;        - two iterators belonging to &#39;a&#39;
//  &#39;distance(i1,i2)&#39; - the number of elements in the range [i1, i2)
//  &#39;distance(p1,p2)&#39; - the number of elements in the range [p1, p2)
//  &#39;z&#39;               - a floating point value representing a load factor
//
//  +----------------------------------------------------+--------------------+
//  | Operation                                          | Complexity         |
//  +====================================================+====================+
//  | unordered_map&lt;K, V&gt; a;    (default construction)   | O[1]               |
//  | unordered_map&lt;K, V&gt; a(al);                         |                    |
//  +----------------------------------------------------+--------------------+
//  | unordered_map&lt;K, V&gt; a(b); (copy construction)      | Average: O[m]      |
//  | unordered_map&lt;K, V&gt; a(b, al);                      | Worst:   O[m^2]    |
//  +----------------------------------------------------+--------------------+
//  | unordered_map&lt;K, V&gt; a(w);                          | O[n]               |
//  | unordered_map&lt;K, V&gt; a(w, hf);                      |                    |
//  | unordered_map&lt;K, V&gt; a(w, hf, eq);                  |                    |
//  | unordered_map&lt;K, V&gt; a(w, hf, eq, al);              |                    |
//  +----------------------------------------------------+--------------------+
//  | unordered_map&lt;K, V&gt; a(i1, i2);                     | Average: O[N]      |
//  | unordered_map&lt;K, V&gt; a(i1, i2, w)                   | Worst:   O[N^2]    |
//  | unordered_map&lt;K, V&gt; a(i1, i2, w, hf);              | where N =          |
//  | unordered_map&lt;K, V&gt; a(i1, i2, w, hf, eq);          |  distance(i1, i2)] |
//  | unordered_map&lt;K, V&gt; a(i1, i2, w, hf, eq, al);      |                    |
//  +----------------------------------------------------+--------------------+
//  | a.~unordered_map&lt;K, V&gt;(); (destruction)            | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a = b;          (assignment)                       | Average: O[n]      |
//  |                                                    | Worst:   O[n^2]    |
//  +----------------------------------------------------+--------------------+
//  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a == b, a != b                                     | Best:  O[n]        |
//  |                                                    | Worst: O[n^2]      |
//  +----------------------------------------------------+--------------------+
//  | a.swap(b), swap(a, b)                              | O[1] if &#39;a&#39; and    |
//  |                                                    | &#39;b&#39; use the same   |
//  |                                                    | allocator,         |
//  |                                                    | O[n + m] otherwise |
//  +----------------------------------------------------+--------------------+
//  | a.key_eq()                                         | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.hash_function()                                  | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.size()                                           | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.max_size()                                       | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.empty()                                          | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.get_allocator()                                  | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a[k]                                               | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.at(k)                                            | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.insert(v)                                        | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.insert(p1, v)                                    | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.insert(i1, i2)                                   | Average: O[        |
//  |                                                    |   distance(i1, i2)]|
//  |                                                    | Worst:   O[n *     |
//  |                                                    |   distance(i1, i2)]|
//  +----------------------------------------------------+--------------------+
//  | a.erase(p1)                                        | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.erase(k)                                         | Average:           |
//  |                                                    |       O[a.count(k)]|
//  |                                                    | Worst:             |
//  |                                                    |       O[n]         |
//  +----------------------------------------------------+--------------------+
//  | a.erase(p1, p2)                                    | Average: O[        |
//  |                                                    |   distance(p1, p2)]|
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.clear()                                          | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a.find(k)                                          | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.count(k)                                         | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.equal_range(k)                                   | Average: O[        |
//  |                                                    |         a.count(k)]|
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.bucket_count()                                   | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.max_bucket_count()                               | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.bucket(k)                                        | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.bucket_size(k)                                   | O[a.bucket_size(k)]|
//  +----------------------------------------------------+--------------------+
//  | a.load_factor()                                    | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.max_load_factor()                                | O[1]               |
//  | a.max_load_factor(z)                               | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.rehash(k)                                        | Average: O[n]      |
//  |                                                    | Worst:   O[n^2]    |
//  +----------------------------------------------------+--------------------+
//  | a.reserve(k)                                       | Average: O[n]      |
//  |                                                    | Worst:   O[n^2]    |
//  +----------------------------------------------------+--------------------+
//..
//
///Iterator, pointer and reference invalidation
///--------------------------------------------
// No method of &#39;unordered_map&#39; invalidates a pointer or reference to an
// element in the set, unless it also erases that element, such as any &#39;erase&#39;
// overload, &#39;clear&#39;, or the destructor (that erases all elements).  Pointers
// and references are stable through a rehash.
//
// Iterators to elements in the container are invalidated by any rehash, so
// iterators may be invalidated by an &#39;insert&#39; or &#39;emplace&#39; call if it triggers
// a rehash (but not otherwise).  Iterators to specific elements are also
// invalidated when that element is erased.  Note that the &#39;end&#39; iterator is
// not an iterator referring to any element in the container, so may be
// invalidated by any non-&#39;const&#39; method.
//
///Unordered Map Configuration
///---------------------------
// The unordered map has interfaces that can provide insight into and control
// of its inner workings.  The unordered map is implemented using a hash table
// (see {&#39;bslstl_hashtable&#39;}), a dynamically sized array of &quot;buckets&quot;.  If two
// elements hash to the same bucket (termed a &quot;collision&quot;), then that bucket
// will house multiple elements.  As elements are added to the unordered map,
// the number of buckets is increased (and the existing elements redistributed)
// to keep the average number of elements per bucket (the &quot;loading factor&quot;)
// below the specified maximum (the &quot;maximum load factor&quot;, 1 by default).
// {Example 2: Examining and Setting Unordered Map Configuration} illustrates
// the use of these interfaces.
//
///Practical Requirements on &#39;HASH&#39;
///--------------------------------
// An important factor in the performance an unordered map (and any of the
// other unordered containers) is the choice of hash function.  In general, one
// wants the hash function to return uniformly distributed values that can be
// assigned to buckets (see {Unordered Map Configuration}) with few collisions.
//
// The &#39;bsl&#39; package provides general purpose, default hash functions for
// &#39;bsl::string&#39;, &#39;bslstl::StringRef&#39;, and the arithmetic types (e.g., &#39;int&#39;);
// however, custom defined hash functions may do better, especially if one has
// information about the distribution of keys; there is considerable literature
// on designing hash functions.
//
// When a user-defined class is used as a key, hasher must be provided (and
// equality functor, if equality is not otherwise defined).  Two examples,
// {Example 3} and {&#39;bslstl_unorderedset&#39;|Example 1}, address this issue by
// adapting the existing default hash functions for primitive types, an
// approach that may not always prove adequate.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Gathering Document Statistics
/// - - - - - - - - - - - - - - - - - - - -
// Unordered maps are useful in situations when there is no meaningful way to
// order the key values, when the order of the keys is irrelevant to the
// problem domain (see {Example 3}), and (even if there is a meaningful
// ordering) the value of ordering the results is outweighed by the higher
// performance provided by unordered maps (compared to ordered maps).
//
// Suppose one wished to gather statistics on the words appearing in a large
// set of documents on disk or in a data base.  Gathering those statistics is
// intrusive (as one is competing for access to the documents with the regular
// users) and must be done as quickly as possible.  Moreover, the set of unique
// words appearing in those documents may be high.  The English language has in
// excess of a million words (albeit many appear infrequently), and, if the
// documents contain serial numbers, or Social Security numbers, or chemical
// formulas, etc. then the O[log(n)] insertion time of ordered maps may well be
// inadequate.  The unordered map, having an O[1] typical insertion cost, is a
// viable alternative.  In many problem domains, sorting, if needed, can be
// done after the data is gathered.
//
// This example illustrates the use of &#39;bsl::unordered_map&#39; to gather one
// simple statistic (counts of unique words) on a single document.  To avoid
// irrelevant details of acquiring the data, several modestly sized documents
// are stored in static arrays:
//..
//  static char document0[] =
//  &quot; IN CONGRESS, July 4, 1776.\n&quot;
//  &quot;\n&quot;
//  &quot; The unanimous Declaration of the thirteen united States of America,\n&quot;
//  &quot;\n&quot;
//  &quot; When in the Course of human events, it becomes necessary for one\n&quot;
//  &quot; people to dissolve the political bands which have connected them with\n&quot;
//  &quot; another, and to assume among the powers of the earth, the separate\n&quot;
//  &quot; and equal station to which the Laws of Nature and of Nature&#39;s God\n&quot;
//  &quot; entitle them, a decent respect to the opinions of mankind requires\n&quot;
//  &quot; that they should declare the causes which impel them to the\n&quot;
//  &quot; separation.  We hold these truths to be self-evident, that all men\n&quot;
//  &quot; are created equal, that they are endowed by their Creator with\n&quot;
//  &quot; certain unalienable Rights, that among these are Life, Liberty and\n&quot;
//  &quot; the pursuit of Happiness.--That to secure these rights, Governments\n&quot;
//  &quot; are instituted among Men, deriving their just powers from the consent\n&quot;
//  &quot; of the governed, --That whenever any Form of Government becomes\n&quot;
//  ...
//  &quot; States may of right do.  And for the support of this Declaration,\n&quot;
//  &quot; with a firm reliance on the protection of divine Providence, we\n&quot;
//  &quot; mutually pledge to each other our Lives, our Fortunes and our sacred\n&quot;
//  &quot; Honor.\n&quot;;
//
//  static char document1[] =
//  &quot;/The Universal Declaration of Human Rights\n&quot;
//  &quot;/-----------------------------------------\n&quot;
//  &quot;/Preamble\n&quot;
//  &quot;/ - - - -\n&quot;
//  &quot; Whereas recognition of the inherent dignity and of the equal and\n&quot;
//  &quot; inalienable rights of all members of the human family is the\n&quot;
//  &quot; foundation of freedom, justice and peace in the world,\n&quot;
//  ...
//  &quot;/Article 30\n&quot;
//  &quot;/ - - - - -\n&quot;
//  &quot; Nothing in this Declaration may be interpreted as implying for any\n&quot;
//  &quot; State, group or person any right to engage in any activity or to\n&quot;
//  &quot; perform any act aimed at the destruction of any of the rights and\n&quot;
//  &quot; freedoms set forth herein.\n&quot;;
//
//  static char document2[] =
//  &quot;/CHARTER OF FUNDAMENTAL RIGHTS OF THE EUROPEAN UNION\n&quot;
//  &quot;/---------------------------------------------------\n&quot;
//  &quot; PREAMBLE\n&quot;
//  &quot;\n&quot;
//  &quot; The peoples of Europe, in creating an ever closer union among them,\n&quot;
//  &quot; are resolved to share a peaceful future based on common values.\n&quot;
//  ...
//  &quot;/Article 54\n&quot;
//  &quot;/-  -  -  -\n&quot;
//  &quot; Prohibition of abuse of rights\n&quot;
//  &quot;\n&quot;
//  &quot; Nothing in this Charter shall be interpreted as implying any right to\n&quot;
//  &quot; engage in any activity or to perform any act aimed at the destruction\n&quot;
//  &quot; of any of the rights and freedoms recognized in this Charter or at\n&quot;
//  &quot; their limitation to a greater extent than is provided for herein.\n&quot;;
//
//  static char * const documents[] = { document0,
//                                      document1,
//                                      document2
//                                    };
//  const int           numDocuments = sizeof documents / sizeof *documents;
//..
// First, we define an alias to make our code more comprehensible.
//..
//  typedef bsl::unordered_map&lt;bsl::string, int&gt; WordTally;
//..
// Next, we create an (empty) unordered map to hold our word tallies.  The
// output from the &#39;printf&#39; statements will be discussed in {Example 2}.
//..
//  WordTally wordTally;
//
//  printf(&quot;size             %4d initial\n&quot;, wordTally.size());
//  printf(&quot;bucket_count     %4d initial\n&quot;, wordTally.bucket_count());
//  printf(&quot;load_factor      %f  initial\n&quot;, wordTally.load_factor());
//  printf(&quot;max_load_factor  %f  initial\n&quot;, wordTally.max_load_factor());
//..
// Then, we define the set of characters that define word boundaries:
//..
//  const char *delimiters = &quot; \n\t,:;.()[]?!/&quot;;
//..
// Next, we extract the words from our documents.  Note that &#39;strtok&#39; modifies
// the document arrays (which were not made &#39;const&#39;).
//
// For each iteration of the inner loop, that method looks for a map entry
// matching the given key value.  On the first occurrence of a word, the map
// has no such entry, so one is created with a default value of the mapped
// value (0, just what we want in this case) and inserted into the map where is
// is found on any subsequent occurrences of the word.  The &#39;operator[]&#39; method
// returns a reference providing modifiable access to the mapped value.  Here,
// we apply the &#39;++&#39; operator to that reference to maintain a tally for the
// word.
//..
//  for (int idx = 0; idx &lt; numDocuments; ++idx) {
//      for (char *cur = strtok(documents[idx], delimiters);
//                 cur;
//                 cur = strtok(NULL,     delimiters)) {
//          ++wordTally[bsl::string(cur)];
//      }
//  }
//..
// Now that the data has been (quickly) gathered, we can indulge in analysis
// that is more time consuming.  For example, we can define a comparison
// function, copy the data to another container (e.g., &#39;bsl::vector&#39;), sort the
// entries, and determine the 20 most commonly used words in the given
// documents:
//..
//  typedef bsl::pair&lt;bsl::string, int&gt; WordTallyEntry;
//      // Assignable equivalent to &#39;WordTally::value_type&#39;.  Note that
//      // &#39;bsl::vector&#39; requires assignable types.
//
//  struct WordTallyEntryCompare {
//      static bool lessValue(const WordTallyEntry&amp; a,
//                            const WordTallyEntry&amp; b) {
//          return a.second &lt; b.second;
//      }
//      static bool moreValue(const WordTallyEntry&amp; a,
//                            const WordTallyEntry&amp; b) {
//          return !lessValue(a, b);
//      }
//  };
//
//  bsl::vector&lt;WordTallyEntry&gt; array(wordTally.cbegin(), wordTally.cend());
//
//  assert(20 &lt;= array.size());
//
//  std::partial_sort(array.begin(),
//                    array.begin() + 20,
//                    array.end(),
//                    WordTallyEntryCompare::moreValue);
//..
// Notice that &#39;partial_sort&#39; suffices here since we seek only the 20 most used
// words, not a complete distribution of word counts.
//
// Finally, we print the sorted portion of &#39;array&#39;:
//..
//  for (bsl::vector&lt;WordTallyEntry&gt;::const_iterator cur  = array.begin(),
//                                                   end  = cur + 20;
//                                                   end != cur; ++cur) {
//      printf(&quot;%-10s %4d\n&quot;, cur-&gt;first.c_str(), cur-&gt;second);
//  }
//..
// and standard output shows:
//..
//  the         463
//  -           398
//  of          361
//  and         349
//  to          306
//  in          141
//  or          106
//  right        93
//  be           90
//  Article      86
//  has          79
//  a            76
//  shall        69
//  for          69
//  by           62
//  with         50
//  Everyone     49
//  rights       44
//  their        44
//  is           43
//..
// Notice that &quot;-&quot; (used as an header underscore in our markup) appears in the
// word count.  That could be eliminated by adding &#39;-&#39; to the set of
// delimiters; however, that would partition hyphenated words into separate
// words.  In practice, one defines a &quot;stop list&quot; of common words (e.g., &quot;the&quot;,
// &quot;of&quot;, &quot;and&quot;, &quot;is&quot;) that one does not wish to tally.  We could easily and &quot;-&quot;
// to the stop list.
//
///Example 2: Examining and Setting Unordered Map Configuration
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we wish to examine (and possibly influence) the performance of an
// unordered map.  The unordered map provides several interfaces that allow us
// to do so.  Several of these were used in {Example 1} (code repeated below):
//..
//  WordTally wordTally;
//
//  printf(&quot;size             %4d initial\n&quot;, wordTally.size());
//  printf(&quot;bucket_count     %4d initial\n&quot;, wordTally.bucket_count());
//  printf(&quot;load_factor      %f  initial\n&quot;, wordTally.load_factor());
//  printf(&quot;max_load_factor  %f  initial\n&quot;, wordTally.max_load_factor());
//..
// First, we examine the metrics of of this newly created (empty) unordered
// map:
//..
//  size                0 initial
//  bucket_count        1 initial
//  load_factor      0.000000  initial
//  max_load_factor  1.000000  initial
//..
// Notice that even when there are no elements (&#39;size&#39; is 0) there is one
// bucket.  Since there are no elements, the average number of elements per
// bucket (the &#39;load_factor&#39; above) must be 0.
//
// Next, after &#39;wordTally&#39; has been loaded, we examine its metrics:
//..
//  printf(&quot;size             %4d\n&quot;, wordTally.size());
//  printf(&quot;bucket_count     %4d\n&quot;, wordTally.bucket_count());
//  printf(&quot;load_factor      %f\n&quot;,  wordTally.load_factor());
//  printf(&quot;max_load_factor  %f\n&quot;,  wordTally.max_load_factor());
//..
// and find at standard output:
//..
//  size             1504
//  bucket_count     2099
//  load_factor      0.716532
//  max_load_factor  1.000000
//..
// Notice how the number of buckets has increased.  (Sampling this metric as
// the map was loaded would show that the increase was done in several stages.)
//
// Then, we see that the load factor is indeed below the specified maximum;
// however we obtain further details of how the buckets are used.
//
// Using the &#39;bucket_count&#39; method, the unordered map&#39;s interface for the
// number of elements in each bucket, we can easily determine the bucket with
// the greatest number of elements (i.e., the greatest number of collisions):
//..
//  bsl::vector&lt;int&gt; bucketSizes;
//  bucketSizes.reserve(wordTally.bucket_count());
//
//  for (size_t idx = 0; idx &lt; wordTally.bucket_count(); ++idx) {
//     bucketSizes.push_back(static_cast&lt;int&gt;(wordTally.bucket_size(idx)));
//  }
//
//  assert(0 &lt; bucketSizes.size());
//  int maxBucketSize = *std::max_element(bucketSizes.begin(),
//                                        bucketSizes.end());
//  printf(&quot;maxBucketSize    %4d\n&quot;, maxBucketSize);
//..
// and find on standard output:
//..
//  maxBucketSize       5
//..
// We can also count the number of empty buckets, and the number of buckets at
// &#39;maxBucketSize&#39;.
//..
//  int numEmptyBuckets = static_cast&lt;int&gt;(std::count(bucketSizes.begin(),
//                                                    bucketSizes.end(),
//                                                    0));
//  printf(&quot;numEmptyBuckets  %4d\n&quot;, numEmptyBuckets);
//
//  int numMaxBuckets = static_cast&lt;int&gt;(std::count(bucketSizes.begin(),
//                                                  bucketSizes.end(),
//                                                  maxBucketSize));
//  printf(&quot;numMaxBuckets    %4d\n&quot;, numMaxBuckets);
//..
// which shows on standard output:
//..
//  numEmptyBuckets  1031
//  numMaxBuckets       3
//..
// Suppose we are not satisfied with this distribution.  (Perhaps the load
// factor is too high.)  We can create a second, differently configured table.
//
// Next, create a new table &#39;wordTally2&#39; with twice the bucket count shown by
// the first table (&#39;wordTally&#39;), and examine its initial metrics.
//..
//  WordTally wordTally2(wordTally.bucket_count() * 2);
//
//  printf(&quot;size2            %4d initial\n&quot;, wordTally2.size());
//  printf(&quot;bucket_count2    %4d initial\n&quot;, wordTally2.bucket_count());
//  printf(&quot;load_factor2     %f  initial\n&quot;, wordTally2.load_factor());
//  printf(&quot;max_load_factor2 %f  initial\n&quot;, wordTally2.max_load_factor());
//..
// Standard output shows:
//..
//  size2               0 initial
//  bucket_count2    4201 initial
//  load_factor2     0.000000  initial
//  max_load_factor2 1.000000  initial
//..
// Notice that although we requested 4198 buckets (2 * 2099), we created a
// table with 4201 buckets.  (4201 is the smallest prime number greater than
// 4198).
//
// Then, we load our new table and examine its metrics.  For simplicity, we
// load data from the first table rather than re-tokenize our documents.
//..
//  wordTally2 = wordTally;
//
//  printf(&quot;size2            %4d\n&quot;, wordTally2.size());
//  printf(&quot;bucket_count2    %4d\n&quot;, wordTally2.bucket_count());
//  printf(&quot;load_factor2     %f\n&quot;,  wordTally2.load_factor());
//  printf(&quot;max_load_factor2 %f\n&quot;,  wordTally2.max_load_factor());
//
//  bsl::vector&lt;int&gt; bucketSizes2;
//  bucketSizes2.reserve(wordTally2.bucket_count());
//
//  for (size_t idx = 0; idx &lt; wordTally2.bucket_count(); ++idx) {
//     bucketSizes2.push_back(static_cast&lt;int&gt;(wordTally2.bucket_size(idx)));
//  }
//
//  assert(0 &lt; bucketSizes2.size());
//  int maxBucketSize2 = *std::max_element(bucketSizes2.begin(),
//                                         bucketSizes2.end());
//  printf(&quot;maxBucketSize2   %4d\n&quot;, maxBucketSize2);
//
//  int numEmptyBuckets2 = static_cast&lt;int&gt;(std::count(bucketSizes2.begin(),
//                                          bucketSizes2.end(),
//                                          0));
//  printf(&quot;numEmptyBuckets2 %4d\n&quot;, numEmptyBuckets2);
//
//  int numMaxBuckets2 = static_cast&lt;int&gt;(std::count(bucketSizes2.begin(),
//                                        bucketSizes2.end(),
//                                        maxBucketSize2));
//  printf(&quot;numMaxBuckets2   %4d\n&quot;, numMaxBuckets2);
//..
// Finally, we see on standard output:
//..
//  size2            1504
//  bucket_count2    4201
//  load_factor2     0.358010
//  max_load_factor2 1.000000
//  maxBucketSize2      4
//  numEmptyBuckets2 2971
//  numMaxBuckets2      5
//..
// Notice that the loading factor has been (roughly) cut in half; we have
// achieved our goal.  Also notice that the bucket count is unchanged since
// construction; thus, there were no rehashes during the loading this unordered
// map.  Finally, notice that the number of empty (unused) buckets is
// significantly higher, and there&#39;s been a modest decrease in the largest
// bucket size, but more instances of them.
//
// Thus, the unordered map provides facilities by which we can make trade-offs
// in performance characteristics of the containers we create.
//
///Example 3: Inverse Concordance
/// - - - - - - - - - - - - - - -
// If one has a concordance for a set of documents (an index of the position of
// every unique word in those documents), then words of interest can be
// efficiently located.  Suppose after locating a word of interest one also
// needs the surrounding words (for context).  Searching in the original
// document requires re-tokenization (time consuming).  Alternatively, one can
// use the concordance to create an inverse concordance to provide a fast
// lookup of the words at given locations in a document and then examine words
// near the word of interest.
//
// First, we define the types required (and convenient aliases) to create an
// unordered map from a word location to the corresponding word.  The &quot;key&quot;
// value will be &#39;WordLocation&#39;, a pair of &#39;int&#39; values: the first being the
// document code number (arbitrarily assigned), and second the word offset in
// that document (the first word of the document is at offset 0).  The &quot;value&quot;
// of each entry is a &#39;bsl::string&#39; containing the word at that location.
//..
//  typedef bsl::pair&lt;int, int&gt; WordLocation;
//      // Document code number (&#39;first&#39;) and word offset (&#39;second&#39;) in that
//      // document specify a word location.  The first word in the document
//      // is at word offset 0.
//..
// Notice that that &#39;WordLocation&#39;, the type of the key value, has no natural
// ordering.  The assignment of document codes is arbitrary so there is no
// reason to consider the words on one document to sort below those in any
// another.
//
// Then, since there is no default hash function for the &#39;WordLocation&#39; type,
// we define one.  The document code and the word offset are individually
// hashed using the default hasher for the &#39;int&#39; type and those results bitwise
// exclusive OR-ed a combined result.  This trivial combination formula
// suffices for this problem, but is *not* a general solution for combining
// hashes; see {Practical Requirements on &#39;HASH&#39;}.
//..
//  class WordLocationHash
//  {
//    private:
//      WordLocationHash&amp; operator=(const WordLocationHash&amp; rhs);
//
//    public:
//      // CREATORS
//      //! WordLocationHash() = default;
//          // Create a &#39;WordLocationHash&#39; object.
//
//      //! WordLocationHash(const WordLocationHash&amp; original) = default;
//          // Create a &#39;WordLocationHash&#39; object.  Note that as
//          // &#39;WordLocationHash&#39; is an empty (stateless) type, this operation
//          // will have no observable effect.
//
//      //! ~WordLocationHash() = default;
//          // Destroy this object.
//
//      // ACCESSORS
//      std::size_t operator()(WordLocation x) const
//          // Return a hash value computed using the specified &#39;x&#39;.
//      {
//          bsl::hash&lt;int&gt; hasher;
//          return hasher(x.first) ^ hasher(x.second);
//      }
//  };
//..
// Notice that many of the required methods of the hash type are compiler
// generated.  (The declaration of those methods are commented out and suffixed
// by an &#39;= default&#39; comment.)
//
// In addition to a hash functor, the unordered map requires an equality
// comparison functor.  In this example, the unordered map uses &#39;operator==&#39;
// method of &#39;std::pair&#39; by default.  If the mapped type has no such method, a
// equality comparison functor must be provided explicitly.
//
// Next, we define the type of the unordered map and associated convenience
// aliases:
//..
//  typedef bsl::unordered_map&lt;WordLocation, bsl::string, WordLocationHash&gt;
//                                               InverseConcordance;
//
//  typedef InverseConcordance::const_iterator   InverseConcordanceConstItr;
//..
// Next, we obtain a concordance for the document set (see
// {&#39;bslstl_unorderedmultimap&#39;|Example 1}).  Here, the concordance is provided
// as a statically initialized array:
//..
//  const static struct {
//      const char *d_word;
//      int         d_documentCode;
//      int         d_wordOffset;
//  } concordance[] = {
//      { &quot;extent&quot;,             2,  3597 }, { &quot;to&quot;,                 2,  1225 },
//      ...
//      { &quot;to&quot;,                 2,  1252 }, { &quot;Every&quot;,              2,  1049 }
//  };
//  const int numConcordance = sizeof concordance/sizeof *concordance;
//..
// Then, we create &#39;inverseConcordance&#39;, an unordered map, and initialize it
// with values obtained from &#39;concordance&#39;.
//..
//  InverseConcordance inverseConcordance;
//
//  for (int idx = 0; idx &lt; numConcordance; ++idx) {
//      bsl::string word         = concordance[idx].d_word;
//      int         documentCode = concordance[idx].d_documentCode;
//      int         wordOffset   = concordance[idx].d_wordOffset;
//
//      WordLocation                   location(documentCode, wordOffset);
//      InverseConcordance::value_type value(location, word);
//      bool                           status =
//                                     inverseConcordance.insert(value).second;
//      assert(status);
//  }
//..
// Notice that we expect every &#39;insert&#39; to be successful, as the concordance
// should not show more than one word at any location.
//
// Next, suppose we knew the location of the word &quot;unalienable&quot; in the document
// set (see {&#39;bslstl_unorderedmultimap&#39;|Example 1}) and want to know its
// context?
//..
//  &quot;unalienable&quot;,  0,  109
//..
// We use the &#39;find&#39; method of &#39;inverseConcordance&#39; to determine the words
// within offset &#39;delta&#39; of &quot;unalienable&quot;.  Note that we must check the
// validity of the returned iterator, in case we probe beyond the boundaries of
// the document.
//..
//  const int docCode =   0;
//  const int origin  = 109;
//  const int delta   =  16;
//
//  for (int offset = origin - delta; offset &lt; origin + delta; ++offset) {
//      WordLocation               location(docCode, offset);
//      InverseConcordanceConstItr itr = inverseConcordance.find(location);
//
//      if (inverseConcordance.end() != itr) {
//          printf(&quot;%d %4d: %s\n&quot;,
//                 itr-&gt;first.first,
//                 itr-&gt;first.second,
//                 itr-&gt;second.c_str());
//          assert(origin != offset
//              || bsl::string(&quot;unalienable&quot;) == itr-&gt;second);
//      }
//  }
//..
// Notice that the assertion confirms that &quot;unalienable&quot; is found in our
// inverse location at the location we obtained from the concordance.
//
// Finally, we find on standard output:
//..
//  0   93: evident
//  0   94: that
//  0   95: all
//  0   96: men
//  0   97: are
//  0   98: created
//  0   99: equal
//  0  100: that
//  0  101: they
//  0  102: are
//  0  103: endowed
//  0  104: by
//  0  105: their
//  0  106: Creator
//  0  107: with
//  0  108: certain
//  0  109: unalienable
//  0  110: Rights
//  0  111: that
//  0  112: among
//  0  113: these
//  0  114: are
//  0  115: Life
//  0  116: Liberty
//  0  117: and
//  0  118: the
//  0  119: pursuit
//  0  120: of
//  0  121: Happiness
//  0  122: That
//  0  123: to
//  0  124: secure
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_unorderedmap.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATOR
#include &lt;bslstl_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATORTRAITS
#include &lt;bslstl_allocatortraits.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_EQUALTO
#include &lt;bslstl_equalto.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASH
#include &lt;bslstl_hash.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASHTABLE
#include &lt;bslstl_hashtable.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASHTABLEBUCKETITERATOR
#include &lt;bslstl_hashtablebucketiterator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASHTABLEITERATOR
#include &lt;bslstl_hashtableiterator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ITERATORUTIL
#include &lt;bslstl_iteratorutil.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_PAIR
#include &lt;bslstl_pair.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STDEXCEPTUTIL
#include &lt;bslstl_stdexceptutil.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_UNORDEREDMAPKEYCONFIGURATION
#include &lt;bslstl_unorderedmapkeyconfiguration.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITHASSTLITERATORS
#include &lt;bslalg_typetraithasstliterators.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;  // for &#39;std::size_t&#39;
#define INCLUDED_CSTDDEF
#endif

namespace bsl {
                        // =======================
                        // class bsl::unorderedmap
                        // =======================

template &lt;class KEY,
          class VALUE,
          class HASH      = bsl::hash&lt;KEY&gt;,
          class EQUAL     = bsl::equal_to&lt;KEY&gt;,
          class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt; &gt;
class unordered_map {
    // This class template implements a value-semantic container type holding
    // an unordered set of key-value pairs having unique keys that provide a
    // mapping from keys (of template parameter type &#39;KEY&#39;) to their associated
    // values (of template parameter type &#39;VALUE&#39;).
    //
    // This class:
    //: o supports a complete set of *value-semantic* operations
    //: o is *exception-neutral* (agnostic except for the &#39;at&#39; method)
    //: o is *alias-safe*
    //: o is &#39;const&#39; *thread-safe*
    // For terminology see {&#39;bsldoc_glossary&#39;}.

  private:
    // PRIVATE TYPES
    typedef bsl::allocator_traits&lt;ALLOCATOR&gt; AllocatorTraits;
        // This &#39;typedef&#39; is an alias for the allocator traits type associated
        // with this container.

    typedef bsl::pair&lt;const KEY, VALUE&gt;  ValueType;
        // This &#39;typedef&#39; is an alias for the type of key-value pair objects
        // maintained by this unordered map.

    typedef BloombergLP::bslstl::UnorderedMapKeyConfiguration&lt;ValueType&gt;
                                                             ListConfiguration;
        // This &#39;typedef&#39; is an alias for the policy used internally by this
        // unordered map to extract the &#39;KEY&#39; value from the key-value pair
        // objects maintained by this unordered map.

    typedef BloombergLP::bslstl::HashTable&lt;ListConfiguration,
                                             HASH,
                                             EQUAL,
                                             ALLOCATOR&gt; HashTable;
        // This typedef is an alias for the template instantiation of the
        // underlying &#39;bslstl::HashTable&#39; used to implement this container.

    typedef BloombergLP::bslalg::BidirectionalLink HashTableLink;
        // This typedef is an alias for the type of links maintained by the
        // linked list of elements held by the underlying &#39;bslstl::HashTable&#39;.

    typedef typename HashTable::NodeType HashTableNode;
        // This typedef is an alias for the type of nodes that hold the values
        // in this unordered map.

    // FRIENDS
    template &lt;class KEY2,
              class VALUE2,
              class HASH2,
              class EQUAL2,
              class ALLOCATOR2&gt;
    friend bool operator==(
                const unordered_map&lt;KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2&gt;&amp;,
                const unordered_map&lt;KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2&gt;&amp;);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
                    unordered_map,
                    ::BloombergLP::bslmf::IsBitwiseMoveable,
                    ::BloombergLP::bslmf::IsBitwiseMoveable&lt;HashTable&gt;::value);

    // PUBLIC TYPES
    typedef KEY                                        key_type;
    typedef VALUE                                      mapped_type;
    typedef bsl::pair&lt;const KEY, VALUE&gt;                value_type;
    typedef HASH                                       hasher;
    typedef EQUAL                                      key_equal;
    typedef ALLOCATOR                                  allocator_type;

    typedef typename allocator_type::reference         reference;
    typedef typename allocator_type::const_reference   const_reference;

    typedef typename AllocatorTraits::size_type        size_type;
    typedef typename AllocatorTraits::difference_type  difference_type;
    typedef typename AllocatorTraits::pointer          pointer;
    typedef typename AllocatorTraits::const_pointer    const_pointer;

    typedef BloombergLP::bslstl::HashTableIterator&lt;
                                         value_type, difference_type&gt; iterator;
    typedef BloombergLP::bslstl::HashTableIterator&lt;
                             const value_type, difference_type&gt; const_iterator;
    typedef BloombergLP::bslstl::HashTableBucketIterator&lt;
                                   value_type, difference_type&gt; local_iterator;
    typedef BloombergLP::bslstl::HashTableBucketIterator&lt;
                       const value_type, difference_type&gt; const_local_iterator;

  private:
    // DATA
    HashTable d_impl;  // underlying hash table used by this unordered map

  public:
    // CREATORS
    explicit unordered_map(
                   size_type             initialNumBuckets = 0,
                   const hasher&amp;         hashFunction      = hasher(),
                   const key_equal&amp;      keyEqual          = key_equal(),
                   const allocator_type&amp; basicAllocator    = allocator_type());
        // Create an empty unordered map having a &#39;max_load_factor&#39; of 1.0.
        // Optionally specify an &#39;initialNumBuckets&#39; indicating the minimum
        // initial size of the array of buckets of this unordered map.  If
        // &#39;initialNumBuckets&#39; is not supplied, one empty bucket shall be used
        // and no memory allocated.  Optionally specify a &#39;hashFunction&#39; used
        // to generate the hash values associated with the key-value pairs
        // contained in this unordered map.  If &#39;hashFunction&#39; is not supplied,
        // a default-constructed object of type &#39;hasher&#39; is used.  Optionally
        // specify a key-equality functor &#39;keyEqual&#39; used to determine whether
        // two keys have the same value.  If &#39;keyEqual&#39; is not supplied, a
        // default-constructed object of type &#39;key_equal&#39; is used.  Optionally
        // specify the &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is not supplied, a default-constructed object of
        // the (template parameter) type &#39;allocator_type&#39; is used.  If the
        // &#39;allocator_type&#39; is &#39;bsl::allocator&#39; (the default), then
        // &#39;basicAllocator&#39; shall be convertible to &#39;bslma::Allocator *&#39;.  If
        // the &#39;allocator_type&#39; is &#39;bsl::allocator&#39; and &#39;basicAllocator&#39; is not
        // supplied, the currently installed default allocator will be used to
        // supply memory.  Note that more than &#39;initialNumBuckets&#39; buckets may
        // be created in order to preserve the bucket allocation strategy of
        // the hash-table (but never fewer).

    explicit unordered_map(const allocator_type&amp; basicAllocator);
        // Create an empty unordered map, having a &#39;max_load_factor&#39; of 1.0,
        // that uses the specified &#39;basicAllocator&#39; to supply memory.  Use a
        // default-constructed object of type &#39;hasher&#39; to generate hash values
        // for the key-value pairs contained in this unordered map, and use a
        // default-constructed object of type &#39;key_equal&#39; to determine whether
        // two keys have the same value.  If the &#39;allocator_type&#39; is
        // &#39;bsl::allocator&#39; (the default), then &#39;basicAllocator&#39; shall be
        // convertible to &#39;bslma::Allocator *&#39;.

    unordered_map(const unordered_map&amp; original);
        // Create an unordered map having the same value, hasher, key-equality
        // comparator, and &#39;max_load_factor&#39; as the specified &#39;original&#39;.  Use
        // the allocator returned by &#39;bsl::allocator_traits&lt;allocator_type&gt;::
        // select_on_container_copy_construction(original.get_allocator())&#39; to
        // supply memory.  If the &#39;allocator_type&#39; is &#39;bsl::allocator&#39; (the
        // default), the currently installed default allocator will be used to
        // supply memory.

    unordered_map(const unordered_map&amp;  original,
                  const allocator_type&amp; basicAllocator);
        // Create an unordered map having the same value, hasher, key-equality
        // comparator, and &#39;max_load_factor&#39; as the specified &#39;original&#39;, and
        // using the specified &#39;basicAllocator&#39; to supply memory.  If the
        // &#39;allocator_type&#39; is &#39;bsl::allocator&#39; (the default), then
        // &#39;basicAllocator&#39; shall be convertible to &#39;bslma::Allocator *&#39;.

    template &lt;class INPUT_ITERATOR&gt;
    unordered_map(INPUT_ITERATOR        first,
                  INPUT_ITERATOR        last,
                  size_type             initialNumBuckets = 0,
                  const hasher&amp;         hashFunction      = hasher(),
                  const key_equal&amp;      keyEqual          = key_equal(),
                  const allocator_type&amp; basicAllocator    = allocator_type());
        // Create an empty unordered map, having a &#39;max_load_factor&#39; of 1.0,
        // and then create a &#39;value_type&#39; object for each iterator in the range
        // starting at the specified &#39;first&#39; iterator and ending immediately
        // before the specified &#39;last&#39; iterator, by converting from the object
        // referred to by each iterator.  Insert into this unordered map each
        // such object, ignoring those having a key that appears earlier in the
        // sequence.  Optionally specify a minimum &#39;initialNumBuckets&#39;
        // indicating the minimum initial size of the array of buckets of this
        // unordered map.  If &#39;initialNumBuckets&#39; is not supplied, and &#39;first&#39;
        // and &#39;last&#39; denote an empty range, a single empty bucket shall be
        // supplied.  Optionally specify a &#39;hashFunction&#39; used to generate hash
        // values associated with the key-value pairs contained in this
        // unordered map.  If &#39;hashFunction&#39; is not supplied, a
        // default-constructed object of type &#39;hasher&#39; is used.  Optionally
        // specify a key-equality functor &#39;keyEqual&#39; used to verify that two
        // key values are the same.  If &#39;keyEqual&#39; is not supplied, a
        // default-constructed object of type &#39;key_equal&#39; is used.  Optionally
        // specify an &#39;allocator&#39; used to supply memory.  If &#39;allocator&#39; is not
        // supplied, a default-constructed object of the (template parameter)
        // type &#39;allocator_type&#39; is used.  If the &#39;allocator_type&#39; is
        // &#39;bsl::allocator&#39; (the default), then &#39;allocator&#39; shall be
        // convertible to &#39;bslma::Allocator *&#39;.  If the &#39;allocator_type&#39; is
        // &#39;bsl::allocator&#39; and &#39;allocator&#39; is not supplied, the currently
        // installed default allocator will be used to supply memory.  The
        // (template parameter) type &#39;INPUT_ITERATOR&#39; shall meet the
        // requirements of an input iterator defined in the C++11 standard
        // [24.2.3] providing access to values of a type convertible to
        // &#39;value_type&#39;.  The behavior is undefined unless &#39;first&#39; and &#39;last&#39;
        // refer to a sequence of valid values where &#39;first&#39; is at a position
        // at or before &#39;last&#39;.  Note that more than &#39;initialNumBuckets&#39;
        // buckets may be created in order to preserve the bucket allocation
        // strategy of the hash-table (but never fewer).

    ~unordered_map();
        // Destroy this object and each of its elements.

    // MANIPULATORS
    unordered_map&amp; operator=(const unordered_map&amp; rhs);
        // Assign to this object the value, hasher, key-equality functor, and
        // &#39;max_load_factor&#39; of the specified &#39;rhs&#39; object, propagate to this
        // object the allocator of &#39;rhs&#39; if &#39;allocator_type&#39; has trait
        // &#39;propagate_on_container_copy_assignment&#39;, and return a reference
        // providing modifiable access to this object.  This method requires
        // that the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both be
        // &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

    mapped_type&amp; operator[](const key_type&amp; key);
        // Return a reference providing modifiable access to the mapped-value
        // associated with the specified &#39;key&#39; in this unordered map; if this
        // unordered map does not already contain a &#39;value_type&#39; object with
        // &#39;key&#39;, first insert a new &#39;value_type&#39; object having &#39;key&#39; and a
        // default-constructed &#39;VALUE&#39; object.  This method requires that the
        // (template parameter) type &#39;KEY&#39; is &quot;copy-constructible&quot; and the
        // (template parameter) &#39;VALUE&#39; is &quot;default-constructible&quot; (see
        // {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

    mapped_type&amp; at(const key_type&amp; key);
        // Return a reference providing modifiable access to the mapped-value
        // associated with the specified &#39;key&#39;, if such an entry exists;
        // otherwise throw a &#39;std::out_of_range&#39; exception.  Note that this
        // method is not exception agnostic.

    iterator begin();
        // Return an iterator providing modifiable access to the first
        // &#39;value_type&#39; object in the sequence of &#39;value_type&#39; objects
        // maintained by this unordered map, or the &#39;end&#39; iterator if this
        // unordered map is empty.

    iterator end();
        // Return an iterator providing modifiable access to the past-the-end
        // element in the sequence of &#39;value_type&#39; objects maintained by this
        // unordered map.

    local_iterator begin(size_type index);
        // Return a local iterator providing modifiable access to the first
        // &#39;value_type&#39; object in the sequence of &#39;value_type&#39; objects of the
        // bucket having the specified &#39;index&#39; in the array of buckets
        // maintained by this unordered map, or the &#39;end(index)&#39; iterator if
        // the bucket is empty.  The behavior is undefined unless &#39;index &lt;
        // bucket_count()&#39;.

    local_iterator end(size_type index);
        // Return a local iterator providing modifiable access to the
        // past-the-end element in the sequence of &#39;value_type&#39; objects of the
        // bucket having the specified &#39;index&#39; in the array of buckets
        // maintained by this unordered map.  The behavior is undefined unless
        // &#39;index &lt; bucket_count()&#39;.

    void clear();
        // Remove all entries from this unordered map.  Note that this
        // unordered map will be empty after this call, but allocated memory
        // may be retained for future use.

    iterator erase(const_iterator position);
        // Remove from this unordered map the &#39;value_type&#39; object at the
        // specified &#39;position&#39;, and return an iterator referring to the
        // element immediately following the removed element, or to the
        // past-the-end position if the removed element was the last element in
        // the sequence of elements maintained by this unordered map.  The
        // behavior is undefined unless &#39;position&#39; refers to a &#39;value_type&#39;
        // object in this unordered map.

    size_type erase(const key_type&amp; key);
        // Remove from this unordered map the &#39;value_type&#39; object having the
        // specified &#39;key&#39;, if it exists, and return 1; otherwise (there is no
        // &#39;value_type&#39; object having &#39;key&#39; in this unordered map) return 0
        // with no other effect.

    iterator erase(const_iterator first, const_iterator last);
        // Remove from this unordered map the &#39;value_type&#39; objects starting at
        // the specified &#39;first&#39; position up to, but not including, the
        // specified &#39;last&#39; position, and return &#39;last&#39;.  The behavior is
        // undefined unless &#39;first&#39; and &#39;last&#39; either refer to elements in this
        // unordered map or are both the &#39;end&#39; iterator, and the &#39;first&#39;
        // position is at or before the &#39;last&#39; position in the iteration
        // sequence provided by this container.

    iterator find(const key_type&amp; key);
        // Return an iterator providing modifiable access to the &#39;value_type&#39;
        // object in this unordered map having the specified &#39;key&#39;, if such an
        // entry exists, and the past-the-end iterator (&#39;end&#39;) otherwise.

    template &lt;class SOURCE_TYPE&gt;
    pair&lt;iterator, bool&gt; insert(const SOURCE_TYPE&amp; value);
        // Insert the specified &#39;value&#39; into this unordered map if the key (the
        // &#39;first&#39; element) of a &#39;value_type&#39; object constructed from &#39;value&#39;
        // does not already exist in this unordered map; otherwise, this method
        // has no effect (a &#39;value_type&#39; object having the same key as the
        // converted &#39;value&#39; already exists in this unordered map) .  Return a
        // &#39;pair&#39; whose &#39;first&#39; member is an iterator referring to the
        // (possibly newly inserted) &#39;value_type&#39; object in this unordered map
        // whose key is the same as that of &#39;value&#39;, and whose &#39;second&#39; member
        // is &#39;true&#39; if a new value was inserted, and &#39;false&#39; if the value was
        // already present.  This method requires that the (template parameter)
        // types &#39;KEY&#39; and &#39;VALUE&#39; both be &quot;copy-constructible&quot; (see
        // {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).  Note that this one template
        // stands in for two &#39;insert&#39; functions in the C++11 standard.

    template &lt;class SOURCE_TYPE&gt;
    iterator insert(const_iterator hint, const SOURCE_TYPE&amp; value);
        // Insert the specified &#39;value&#39; into this unordered map if the key (the
        // &#39;first&#39; element) of a &#39;value_type&#39; object constructed from &#39;value&#39;
        // does not already exist in this unordered map.  Return an iterator
        // referring to the (possibly newly inserted) &#39;value_type&#39; object in
        // this unordered map whose key is the same as that of the converted
        // &#39;value&#39;.  This method requires that the (template parameter) types
        // &#39;KEY&#39; and &#39;VALUE&#39; both be &quot;copy-constructible&quot; (see {Requirements on
        // &#39;KEY&#39; and &#39;VALUE&#39;}).  The behavior is undefined unless the specified
        // &#39;hint&#39; is a valid iterator into this unordered map.  Note that
        // &#39;hint&#39; is not used by this method template, and this one template
        // stands in for two &#39;insert&#39; functions in the C++11 standard.

    template &lt;class INPUT_ITERATOR&gt;
    void insert(INPUT_ITERATOR first, INPUT_ITERATOR last);
        // Create a &#39;value_type&#39; object for each iterator in the range starting
        // at the specified &#39;first&#39; iterator and ending immediately before the
        // specified &#39;last&#39; iterator, by converting from the object referred to
        // by each iterator.  Insert into this unordered map each such object
        // whose key is not already contained.  The (template parameter) type
        // &#39;INPUT_ITERATOR&#39; shall meet the requirements of an input iterator
        // defined in the C++11 standard [24.2.3] providing access to values of
        // a type convertible to &#39;value_type&#39;.  This method requires that the
        // (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both be
        // &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

    pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; key);
        // Return a pair of iterators providing modifiable access to the
        // sequence of &#39;value_type&#39; objects in this unordered map having the
        // specified &#39;key&#39;, where the first iterator is positioned at the start
        // of the sequence, and the second is positioned one past the end of
        // the sequence.  If this unordered map contains no &#39;value_type&#39; object
        // having &#39;key&#39;, then the two returned iterators will have the same
        // value, &#39;end()&#39;.  Note that since an unordered map maintains unique
        // keys, the range will contain at most one element.

    void max_load_factor(float newMaxLoadFactor);
        // Set the maximum load factor of this unordered map to the specified
        // &#39;newMaxLoadFactor&#39;.  If &#39;newMaxLoadFactor &lt; loadFactor()&#39;, this
        // operator require an immediate rehash; otherwise, it has a
        // constant-time cost.  The behavior is undefined unless &#39;0 &lt;
        // newMaxLoadFactor&#39;.  Note that, however, the C++11 standard does not
        // allow this operation to rehash, as it requires a constant cost for
        // all (positive) values of &#39;newMaxLoadFactor&#39;.

    void rehash(size_type numBuckets);
        // Change the size of the array of buckets maintained by this unordered
        // map to at least the specified &#39;numBuckets&#39;, and redistribute all the
        // contained elements into the new sequence of buckets, according to
        // their hash values.  After this call, &#39;load_factor&#39; will be less than
        // or equal to &#39;max_load_factor&#39;.  This operation has no effect if
        // rehashing the elements into &#39;numBuckets&#39; would cause this map to
        // exceed its &#39;max_load_factor&#39;.

    void reserve(size_type numElements);
        // Increase the number of buckets of this set to a quantity such that
        // the ratio between the specified &#39;numElements&#39; and this quantity does
        // not exceed &#39;max_load_factor&#39;.  Note that this guarantees that, after
        // the reserve, elements can be inserted to grow the container to
        // &#39;size() == numElements&#39; without rehashing. Also note that memory
        // allocations may still occur when growing the container to &#39;size() ==
        // numElements&#39;.  Also note that this operation has no effect if
        // &#39;numElements &lt;= size()&#39;.

    void swap(unordered_map&amp; other);
        // Exchange the value of this object as well as its hasher,
        // key-equality functor, and &#39;max_load_factor&#39; with those of the
        // specified &#39;other&#39; object.  If &#39;allocator_type&#39; has the trait
        // &#39;propagate_on_container_swap&#39;, exchange the allocator of this object
        // with that of the &#39;other&#39; object, and do not modify either allocator
        // otherwise.  This method provides the no-throw exception-safety
        // guarantee and guarantees O[1] complexity, as long as the (template
        // parameter) &#39;HASH&#39; and (template parameter) &#39;EQUAL&#39; do not throw when
        // swapped.  The behavior is undefined unless either this object was
        // created with the same allocator as &#39;other&#39; or &#39;allocator_type&#39; has
        // the &#39;propagate_on_container_swap&#39; trait.

    // ACCESSORS
    const mapped_type&amp; at(const key_type&amp; key) const;
        // Return a reference providing non-modifiable access to the
        // mapped-value associated with the specified &#39;key&#39;, if such an entry
        // exists; otherwise throw a &#39;std::out_of_range&#39; exception.  Note that
        // this method is not exception agnostic.

    const_iterator begin() const;
    const_iterator cbegin() const;
        // Return an iterator providing non-modifiable access to the first
        // &#39;value_type&#39; object in the sequence of &#39;value_type&#39; objects
        // maintained by this unordered map, or the &#39;end&#39; iterator if this
        // unordered map is empty.

    const_iterator end() const;
    const_iterator cend() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end element in the sequence of &#39;value_type&#39; objects
        // maintained by this unordered map.

    const_local_iterator begin(size_type index) const;
    const_local_iterator cbegin(size_type index) const;
        // Return a local iterator providing non-modifiable access to the first
        // &#39;value_type&#39; object in the sequence of &#39;value_type&#39; objects of the
        // bucket having the specified &#39;index&#39; in the array of buckets
        // maintained by this unordered map, or the &#39;end(index)&#39; iterator if
        // the bucket is empty.  The behavior is undefined unless
        // &#39;index &lt; bucket_count()&#39;.

    const_local_iterator end(size_type index) const;
    const_local_iterator cend(size_type index) const;
        // Return a local iterator providing non-modifiable access to the
        // past-the-end element in the sequence of &#39;value_type&#39; objects of the
        // bucket having the specified &#39;index&#39; in the array of buckets
        // maintained by this unordered map.  The behavior is undefined unless
        // &#39;index &lt; bucket_count()&#39;.

    size_type bucket(const key_type&amp; key) const;
        // Return the index of the bucket, in the array of buckets maintained
        // by this unordered map, where values having the specified &#39;key&#39; would
        // be inserted.

    size_type bucket_count() const;
        // Return the number of buckets in the array of buckets maintained by
        // this unordered map.

    size_type max_bucket_count() const;
        // Return a theoretical upper bound on the largest number of buckets
        // that this unordered map could possibly manage.  Note that there is
        // no guarantee that the unordered map can successfully grow to the
        // returned size, or even close to that size, without running out of
        // resources.

    size_type bucket_size(size_type index) const;
        // Return the number of elements contained in the bucket at the
        // specified &#39;index&#39; in the array of buckets maintained by this
        // unordered map.  The behavior is undefined unless
        // &#39;index &lt; bucket_count()&#39;.

    size_type count(const key_type&amp; key) const;
        // Return the number of &#39;value_type&#39; objects contained within this
        // unordered map having the specified &#39;key&#39;.  Note that since an
        // unordered map maintains unique keys, the returned value will be
        // either 0 or 1.

    bool empty() const;
        // Return &#39;true&#39; if this unordered map contains no elements, and
        // &#39;false&#39; otherwise.

    pair&lt;const_iterator, const_iterator&gt; equal_range(
                                                    const key_type&amp; key) const;
        // Return a pair of iterators providing non-modifiable access to the
        // sequence of &#39;value_type&#39; objects in this unordered map having the
        // specified &#39;key&#39;, where the first iterator is positioned at the start
        // of the sequence, and the second is positioned one past the end of
        // the sequence.  If this unordered map contains no &#39;value_type&#39; object
        // having &#39;key&#39;, then the two returned iterators will have the same
        // value, &#39;end()&#39;.  Note that since an unordered map maintains unique
        // keys, the range will contain at most one element.

    const_iterator find(const key_type&amp; key) const;
        // Return an iterator providing non-modifiable access to the
        // &#39;value_type&#39; object in this unordered map having the specified
        // &#39;key&#39;, if such an entry exists, and the past-the-end iterator
        // (&#39;end&#39;) otherwise.

    allocator_type get_allocator() const;
        // Return (a copy of) the allocator used for memory allocation by this
        // unordered map.

    hasher hash_function() const;
        // Return (a copy of) the unary hash functor used by this unordered map
        // to generate a hash value (of type &#39;std::size_t&#39;) for a &#39;key_type&#39;
        // object.

    key_equal key_eq() const;
        // Return (a copy of) binary the key-equality functor used by this
        // unordered map that returns &#39;true&#39; if two &#39;key_type&#39; objects have the
        // same value, and &#39;false&#39; otherwise.

    float load_factor() const;
        // Return the current ratio between the &#39;size&#39; of this unordered map
        // and the number of buckets.  The load factor is a measure of how
        // full the container is, and a higher load factor typically leads to
        // an increased number of collisions, thus resulting in a loss of
        // performance.

    float max_load_factor() const;
        // Return the maximum load factor allowed for this unordered map.  Note
        // that if an insert operation would cause the load factor to exceed
        // the &#39;max_load_factor&#39;, that same insert operation will increase the
        // number of buckets and rehash the elements of the container into
        // those buckets (see &#39;rehash&#39;).

    size_type size() const;
        // Return the number of elements in this unordered map.

    size_type max_size() const;
        // Return a theoretical upper bound on the largest number of elements
        // that this unordered map could possibly hold.  Note that there is no
        // guarantee that the unordered map can successfully grow to the
        // returned size, or even close to that size, without running out of
        // resources.
};

// FREE OPERATORS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bool operator==(const unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; lhs,
                const unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;unordered_map&#39; objects have the
    // same value if they have the same number of key-value pairs, and for each
    // key-value pair that is contained in &#39;lhs&#39; there is a key-value pair
    // contained in &#39;rhs&#39; having the same value, and vice versa.  This method
    // requires that the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both be
    // &quot;equality-comparable&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bool operator!=(const unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; lhs,
                const unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;unordered_map&#39; objects do not
    // have the same value if they do not have the same number of key-value
    // pairs, or for some key-value pair that is contained in &#39;lhs&#39; there is
    // not a key-value pair in &#39;rhs&#39; having the same value or vice-versa.  This
    // method requires that the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39;
    // both be &quot;equality-comparable&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

// FREE FUNCTIONS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
void swap(unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; a,
          unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; b);
    // Exchange the value, the hasher, the key-equality functor, and the
    // &#39;max_load_factor&#39; of the specified &#39;a&#39; object with those of the
    // specified &#39;b&#39; object.  If the (template parameter) type &#39;ALLOCATOR&#39; has
    // the trait &#39;propagate_on_container_swap&#39;, exchange the allocator of &#39;a&#39;
    // with that of &#39;b&#39;, and do not modify either allocator otherwise.  This
    // function provides the no-throw exception-safety guarantee and guarantees
    // O[1] complexity, as long as the (template parameter) type &#39;HASH&#39; and the
    // (template parameter) type &#39;EQUAL&#39; do not throw when swapped.  The
    // behavior is undefined unless &#39;a&#39; and &#39;b&#39; were created with the same
    // allocator, or &#39;ALLOCATOR&#39; has the &#39;propagate_on_container_swap&#39; trait.

}  // close namespace bsl

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

namespace bsl
{
                        //--------------------
                        // class unordered_map
                        //--------------------

// CREATORS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::
unordered_map(size_type             initialNumBuckets,
              const hasher&amp;         hashFunction,
              const key_equal&amp;      keyEqual,
              const allocator_type&amp; basicAllocator)
: d_impl(hashFunction, keyEqual, initialNumBuckets, 1.0f, basicAllocator)
{
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
template &lt;class INPUT_ITERATOR&gt;
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::unordered_map(
                                       INPUT_ITERATOR        first,
                                       INPUT_ITERATOR        last,
                                       size_type             initialNumBuckets,
                                       const hasher&amp;         hashFunction,
                                       const key_equal&amp;      keyEqual,
                                       const allocator_type&amp; basicAllocator)
: d_impl(hashFunction, keyEqual, initialNumBuckets, 1.0f, basicAllocator)
{
    this-&gt;insert(first, last);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::unordered_map(
                                                 const unordered_map&amp; original)
: d_impl(original.d_impl,
         AllocatorTraits::select_on_container_copy_construction(
                                                     original.get_allocator()))
{
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::unordered_map(
                                          const allocator_type&amp; basicAllocator)
: d_impl(basicAllocator)
{
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::unordered_map(
                                          const unordered_map&amp;  original,
                                          const allocator_type&amp; basicAllocator)
: d_impl(original.d_impl, basicAllocator)
{
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::~unordered_map()
{
    // All memory management is handled by the base &#39;d_impl&#39; member.
}

// MANIPULATORS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp;
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::operator=(
                                                      const unordered_map&amp; rhs)
{
    unordered_map(rhs, this-&gt;get_allocator()).swap(*this);
    return *this;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::mapped_type&amp;
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::operator[](
                                                           const key_type&amp; key)
{
    HashTableLink *node = d_impl.insertIfMissing(key);
    return static_cast&lt;HashTableNode *&gt;(node)-&gt;value().second;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::mapped_type&amp;
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::at(const key_type&amp; key)
{
    HashTableLink *node = d_impl.find(key);

    if (!node) {
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                        &quot;unordered_map&lt;...&gt;::at(key_type): invalid key value&quot;);
    }

    return static_cast&lt;HashTableNode *&gt;(node)-&gt;value().second;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::begin()
{
    return iterator(d_impl.elementListRoot());
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::end()
{
    return iterator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::local_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::begin(size_type index)
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return local_iterator(&amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::local_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::end(size_type index)
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return local_iterator(0, &amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::clear()
{
    d_impl.removeAll();
}


template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::erase(
                                                       const_iterator position)
{
    BSLS_ASSERT_SAFE(position != this-&gt;end());

    return iterator(d_impl.remove(position.node()));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::erase(const key_type&amp; key)
{
    if (HashTableLink *target = d_impl.find(key)) {
        d_impl.remove(target);
        return 1;                                                     // RETURN
    }
    else {
        return 0;                                                     // RETURN
    }
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::erase(const_iterator first,
                                                         const_iterator last)
{

#if defined BDE_BUILD_TARGET_SAFE_2
    if (first != last) {
        iterator it        = this-&gt;begin();
        const iterator end = this-&gt;end();
        for (; it != first; ++it) {
            BSLS_ASSERT(last != it);
            BSLS_ASSERT(end  != it);
        }
        for (; it != last; ++it) {
            BSLS_ASSERT(end  != it);
        }
    }
#endif

    while (first != last) {
        first = this-&gt;erase(first);
    }

    return iterator(first.node()); // convert from const_iterator
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::find(const key_type&amp; key)
{
    return iterator(d_impl.find(key));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
template &lt;class SOURCE_TYPE&gt;
bsl::pair&lt;typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator,
          bool&gt;
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::insert(
                                                      const SOURCE_TYPE&amp; value)
{
    typedef bsl::pair&lt;iterator, bool&gt; ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.insertIfMissing(&amp;isInsertedFlag, value);

    return ResultType(iterator(result), isInsertedFlag);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
template &lt;class SOURCE_TYPE&gt;
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::insert(
                                                      const_iterator,
                                                      const SOURCE_TYPE&amp; value)
{
    // There is no realistic use-case for the &#39;hint&#39; in an &#39;unordered_map&#39; of
    // unique values.  We could quickly test for a duplicate key, and have a
    // fast return path for when the method fails, but in the typical use case
    // where a new element is inserted, we are adding an extra key check for no
    // benefit.  In order to insert an element into a bucket, we need to walk
    // the whole bucket looking for duplicates, and the hint is no help in
    // finding the start of a bucket.

    bool isInsertedFlag;  // not used

    HashTableLink *result = d_impl.insertIfMissing(&amp;isInsertedFlag, value);

    return iterator(result);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
template &lt;class INPUT_ITERATOR&gt;
void unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::insert(
                                                          INPUT_ITERATOR first,
                                                          INPUT_ITERATOR last)
{
    size_type maxInsertions =
            ::BloombergLP::bslstl::IteratorUtil::insertDistance(first, last);
    if (maxInsertions) {
        this-&gt;reserve(this-&gt;size() + maxInsertions);
    }

    bool isInsertedFlag;  // not used
    while (first != last) {
        d_impl.insertIfMissing(&amp;isInsertedFlag, *first);
        ++first;
    }
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bsl::pair&lt;typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator,
          typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator&gt;
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::equal_range(
                                                           const key_type&amp; key)
{
    typedef bsl::pair&lt;iterator, iterator&gt; ResultType;

    HashTableLink *first = d_impl.find(key);
    return first
         ? ResultType(iterator(first), iterator(first-&gt;nextLink()))
         : ResultType(iterator(0),     iterator(0));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::max_load_factor(
                                                        float newMaxLoadFactor)

{
    d_impl.setMaxLoadFactor(newMaxLoadFactor);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::rehash(size_type numBuckets)
{
    d_impl.rehashForNumBuckets(numBuckets);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::reserve(
                                                         size_type numElements)
{
    d_impl.reserveForNumElements(numElements);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::swap(unordered_map&amp; other)
{
    BSLS_ASSERT_SAFE(this-&gt;get_allocator() == other.get_allocator());

    d_impl.swap(other.d_impl);
}

// ACCESSORS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
const typename
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::mapped_type&amp;
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::at(
                                                     const key_type&amp; key) const
{
    HashTableLink *target = d_impl.find(key);
    if (!target ){
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                        &quot;unordered_map&lt;...&gt;::at(key_type): invalid key value&quot;);
    }
    return static_cast&lt;HashTableNode *&gt;(target)-&gt;value().second;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::begin() const
{
    return const_iterator(d_impl.elementListRoot());
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::end() const
{
    return const_iterator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::cbegin() const
{
    return const_iterator(d_impl.elementListRoot());
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::cend() const
{
    return const_iterator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename
        unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_local_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::begin(size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return const_local_iterator(&amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_local_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::end(size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return const_local_iterator(0, &amp;d_impl.bucketAtIndex(index));
}


template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_local_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::cbegin(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return const_local_iterator(&amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_local_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::cend(size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return const_local_iterator(0, &amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::bucket(
                                                     const key_type&amp; key) const
{
    return d_impl.bucketIndexForKey(key);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::bucket_count() const
{
    return d_impl.numBuckets();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::max_bucket_count() const
{
    return d_impl.maxNumBuckets();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::bucket_size(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return d_impl.countElementsInBucket(index);
}


template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::count(
                                                     const key_type&amp; key) const
{
    return d_impl.find(key) != 0;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
bool
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::empty() const
{
    return 0 == d_impl.size();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bsl::pair&lt;typename unordered_map&lt;KEY,
                                 VALUE,
                                 HASH,
                                 EQUAL,
                                 ALLOCATOR&gt;::const_iterator,
          typename unordered_map&lt;KEY,
                                 VALUE,
                                 HASH,
                                 EQUAL,
                                 ALLOCATOR&gt;::const_iterator&gt;
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::equal_range(
                                                     const key_type&amp; key) const
{
    typedef bsl::pair&lt;const_iterator, const_iterator&gt; ResultType;

    HashTableLink *first = d_impl.find(key);
    return first
         ? ResultType(const_iterator(first), const_iterator(first-&gt;nextLink()))
         : ResultType(const_iterator(0),     const_iterator(0));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename
       unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::find(
                                                     const key_type&amp; key) const
{
    return const_iterator(d_impl.find(key));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
ALLOCATOR
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::get_allocator() const
{
    return d_impl.allocator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::hasher
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::hash_function() const
{
    return d_impl.hasher();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::key_equal
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::key_eq() const
{
    return d_impl.comparator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
float
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::load_factor() const
{
    return d_impl.loadFactor();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
float
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::max_load_factor() const
{
    return d_impl.maxLoadFactor();
}


template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size() const
{
    return d_impl.size();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::max_size() const
{
    return d_impl.maxSize();
}

}  // close namespace bsl

// FREE OPERATORS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
bool bsl::operator==(
             const bsl::unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; lhs,
             const bsl::unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; rhs)
{
    return lhs.d_impl == rhs.d_impl;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
bool bsl::operator!=(
             const bsl::unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; lhs,
             const bsl::unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

// FREE FUNCTIONS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void
bsl::swap(bsl::unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; a,
          bsl::unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; b)
{
    a.swap(b);
}

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for STL *unordered* *associative* containers:
//: o An unordered associative container defines STL iterators.
//: o An unordered associative container is bit-wise moveable if both functors
//:      and the allocator are bit-wise moveable.
//: o An unordered associative container uses &#39;bslma&#39; allocators if the
//:   (template parameter) type &#39;ALLOCATOR&#39; is convertible from
//:   &#39;bslma::Allocator *&#39;.

namespace BloombergLP {
namespace bslalg {

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
struct HasStlIterators&lt;bsl::unordered_map&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt; &gt;
     : bsl::true_type
{};

}  // close namespace bslalg

namespace bslma {

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
struct UsesBslmaAllocator&lt;bsl::unordered_map&lt;KEY,
                                             VALUE,
                                             HASH,
                                             EQUAL,
                                             ALLOCATOR&gt; &gt;
     : bsl::is_convertible&lt;Allocator*, ALLOCATOR&gt;::type
{};

}  // close namespace bslma

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
