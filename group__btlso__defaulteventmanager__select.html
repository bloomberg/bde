<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlso_defaulteventmanager_select Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlso_defaulteventmanager_select<br/>
<small>
[<a class="el" href="group__btlso.html">Package btlso</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a <code>select</code>-based socket-event multiplexer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Component Diagram</a> </li>
<li>
<a href="#3.2">Thread Safety</a> </li>
<li>
<a href="#3.3">Performance</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Using an Event Manager</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a <code>select</code>-based socket-event multiplexer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>btlso::DefaultEventManager&lt;btlso::Platform::SELECT&gt; </td><td><code>select</code> multiplexer  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlso__eventmanager.html" title="Define a protocol for socket-event multiplexer.">Component btlso_eventmanager</a> <a class="el" href="group__btlso__defaulteventmanager.html" title="Provide an interface for default event manager.">Component btlso_defaulteventmanager</a> <a class="el" href="group__btlso__timemetrics.html" title="Provide thread-safe time-based categorized metrics.">Component btlso_timemetrics</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt;<a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">btlso::Platform::SELECT</a>&gt;</code>, that implements the <code><a class="el" href="classbtlso_1_1EventManager.html">btlso::EventManager</a></code> protocol using the <code>select</code> system call available on platforms conforming to POSIX.1g. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Generally speaking, a platform imposes a limit on the number of socket handles that can be registered with <code>select</code>. This limit, which is a compile time constant (and, therefore, cannot be increased at run time), can be as low as 64 (e.g., Windows) or as high as 1024 (e.g., Solaris). However, it is often required to handle more than this maximum number of simultaneous connections. This component does not provide a solution to this problem but provides an accessor function, <code>canRegisterSockets</code>, that allows clients to identify if this event manager is at the socket registration limit. If that is the case then clients can create more objects of this class for registering their sockets. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_diagram"></a> <a class="anchor" id="description.component_diagram"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Component Diagram: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This specialized component is one of the specializations of the <code>btlso_defaulteventmanager</code> component; the other components are shown (schematically) on the following diagram: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          _bteso_defaulteventmanager_
                 _______/     |       |        |     \________
                 *_poll  *_pollset *_select *_devpoll  *_epoll
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>select</code>-based multiplexers provided by this component depend on a <code>bdema</code>-style allocator to supply memory. The allocator is installed at creation and is NOT managed by the multiplexers. If the allocator is not <em>thread</em> <em>safe</em> (<em>thread</em> <em>enabled</em>) then the instances of this component using that allocator will consequently not be <em>thread</em> <em>safe</em> (<em>thread</em> <em>enabled</em>). Moreover, if two distinct instances of a multiplexer share the same allocator, thread-safety is guaranteed if and only if the allocator is <em>thread</em> <em>enabled</em>. If no allocator is provided at creation, the default allocator, which is <em>thread</em> <em>enabled</em>, is used. Otherwise, the following is guaranteed: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
A single instance of this event manager is <em>not</em> <em>thread</em> <em>safe</em> with respect to operations invoked on the same instance from different threads: such operations are <em>not</em> guaranteed to work correctly.  </li>
<li>
An instance of this event manager <em>is</em> <em>thread</em> <em>safe</em> with respect to operations invoked on <em>different</em> <em>instances</em> from different threads: there will be no side-effects from such operations (which, generally speaking, means that there is no <code>static</code> data).  </li>
<li>
Distinct instances of this event manager are <em>thread</em> <em>enabled</em> meaning that operations invoked on distinct instances from different threads can proceed in parallel.  </li>
<li>
This event manager is not <em>async-safe</em>, meaning that one or more functions cannot be invoked safely from a signal handler.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance"></a> <a class="anchor" id="description.performance"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Performance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Given that S is the number of socket events registered, the two classes of this component each provide the following (typical) complexity guarantees: <br/>
<br/>
<div class="fragment"><pre class="fragment">  +=======================================================================+
  |        FUNCTION          | EXPECTED COMPLEXITY | WORST CASE COMPLEXITY|
  +-----------------------------------------------------------------------+
  | dispatch                 |        O(S)         |       O(S^2)         |
  +-----------------------------------------------------------------------+
  | registerSocketEvent      |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterSocketEvent    |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterSocket         |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterAll            |        O(S)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | numSocketEvents          |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | numEvents                |        O(1)         |        O(1)          |
  +-----------------------------------------------------------------------+
  | isRegistered             |        O(1)         |        O(S)          |
  +=======================================================================+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_an_event_manager"></a> <a class="anchor" id="usage.example_1~3A_using_an_event_manager"></a> <a class="anchor" id="description.usage.example_1~3A_using_an_event_manager"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using an Event Manager: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate how to use this event manager with a non-blocking socket. First, create a <code><a class="el" href="classbtlso_1_1TimeMetrics.html">btlso::TimeMetrics</a></code> object and a <code><a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt;<a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">btlso::Platform::SELECT</a>&gt;</code> object; also create a (locally-connected) socket pair: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbtlso_1_1TimeMetrics.html">btlso::TimeMetrics</a> timeMetric(<a class="code" href="classbtlso_1_1TimeMetrics.html#a63e555885de8fdb6e37055bb438b0232adaeb514500db1ac0bd6158b2a915709f">btlso::TimeMetrics::e_MIN_NUM_CATEGORIES</a>,
                                <a class="code" href="classbtlso_1_1TimeMetrics.html#a63e555885de8fdb6e37055bb438b0232afca7bc4bcfbf8b8d54928308afbc647c">btlso::TimeMetrics::e_CPU_BOUND</a>);

  <a class="code" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager&lt;btlso::Platform::SELECT&gt;</a> mX(&amp;timeMetric);

  <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> socket[2];

  <span class="keywordtype">int</span> rc = btlso::SocketImpUtil::socketPair&lt;btlso::IPv4Address&gt;(
                                      socket,
                                      btlso::SocketImpUtil::k_SOCKET_STREAM);

  assert(0 == rc);
</pre></div><br/>
<br/>
 Second, register three socket events, two for <code>socket[0]</code>, and one for <code>socket[1]</code>, and verify the state by using accessor functions. The callback installed as part of each registration operation will either read or write the pre-determined (specified on a case-by-case basis) number of bytes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> numBytes = 5;
  <a class="code" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> readCb(
                               <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;genericCb,
                                                    <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>,
                                                    socket[0],
                                                    numBytes,
                                                    &amp;mX));
  mX.<a class="code" href="classbtlso_1_1EventManager.html#a2f9f42a2cc3013cf6ac43553c30f8a46">registerSocketEvent</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>, readCb);

  numBytes = 25;
  <a class="code" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> writeCb1(
                              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;genericCb,
                                                   <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>,
                                                   socket[0],
                                                   numBytes,
                                                   &amp;mX));
  mX.<a class="code" href="classbtlso_1_1EventManager.html#a2f9f42a2cc3013cf6ac43553c30f8a46">registerSocketEvent</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>, writeCb1);

  numBytes = 15;
  <a class="code" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> writeCb2(
                              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;genericCb,
                                                   <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>,
                                                   socket[1],
                                                   numBytes,
                                                   &amp;mX));
  mX.<a class="code" href="classbtlso_1_1EventManager.html#a2f9f42a2cc3013cf6ac43553c30f8a46">registerSocketEvent</a>(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>, writeCb2);

  assert(3 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a6baa2ad4ccdcf4e56d29c9f331d834d3">numEvents</a>());
  assert(2 == mX.<a class="code" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a>(socket[0]));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a>(socket[1]));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
</pre></div><br/>
<br/>
 Next, we try to execute the requests by calling the <code>dispatch</code> function with a timeout (5 seconds from now) requirement and verify the result. The two write requests should be executed since both ends are writable If we don't have a timeout requirement, a different version of <code>dispatch</code> (in which no timeout is specified) can also be called. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span>                flags = 0;
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> deadline(<a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>());

  deadline += 5;    <span class="comment">// timeout 5 seconds from now.</span>
  rc = mX.<a class="code" href="classbtlso_1_1EventManager.html#a344d0ca3d7091da8a9b7ef87bc9fcad5">dispatch</a>(deadline, flags);   assert(2 == rc);
</pre></div><br/>
<br/>
 Now we try to remove the write request of <code>socket[0]</code> from the event manager by calling <code>deregisterSocketEvent()</code> and verify the state: <br/>
<br/>
<div class="fragment"><pre class="fragment">  mX.<a class="code" href="classbtlso_1_1EventManager.html#a0cd6f85fb3b4dc4e3066446d5da5c91c">deregisterSocketEvent</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>);
  assert(2 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a6baa2ad4ccdcf4e56d29c9f331d834d3">numEvents</a>());
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a>(socket[0]));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a>(socket[1]));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
</pre></div><br/>
<br/>
 We then try to remove all registrations associated with <code>socket[1]</code> by calling <code>deregisterSocket()</code> and verify the state: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a6f59c75d70601525f59c517c9d904bbd">deregisterSocket</a>(socket[1]));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a6baa2ad4ccdcf4e56d29c9f331d834d3">numEvents</a>());
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a>(socket[0]));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a>(socket[1]));
  assert(1 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
</pre></div><br/>
<br/>
 Finally, we remove all registrations by calling <code>deregisterAll()</code> and verify the state again: <br/>
<br/>
<div class="fragment"><pre class="fragment">  mX.<a class="code" href="classbtlso_1_1EventManager.html#a2bf336c8772631b783f26aead6be54d0">deregisterAll</a>();
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a6baa2ad4ccdcf4e56d29c9f331d834d3">numEvents</a>());
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a>(socket[0]));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a>(socket[1]));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[0], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
  assert(0 == mX.<a class="code" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a>(socket[1], <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>));
</pre></div><br/>
<br/>
 The following snippets of code show what a <code>genericCb</code> may look like: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> genericCb(<a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a>       event,
                        <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a>  socket,
                        <span class="keywordtype">int</span>                          bytes,
                        <a class="code" href="classbtlso_1_1EventManager.html">btlso::EventManager</a>         *mX)
  {
      <span class="comment">// User specified callback function that is invoked when a socket</span>
      <span class="comment">// event is detected.</span>

      <span class="keyword">enum</span> {
          k_MAX_READ_SIZE  = 8192,   <span class="comment">// The numbers are for illustrative</span>
          k_MAX_WRITE_SIZE = 70000   <span class="comment">// purposes only.</span>
      };

      <span class="keywordflow">switch</span> (event) {
        <span class="keywordflow">case</span> <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>: {
            assert(0 &lt; bytes);
            <span class="keywordtype">char</span> buffer[k_MAX_READ_SIZE];

            <span class="keywordtype">int</span> rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a153aa8f6c8c42dc5c8ac96ea2ddb5341">btlso::SocketImpUtil::read</a>(buffer, socket, bytes, 0);
            assert(0 &lt; rc);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a>: {
            <span class="keywordtype">char</span> wBuffer[k_MAX_WRITE_SIZE];
            assert(0 &lt; bytes);
            assert(k_MAX_WRITE_SIZE &gt;= bytes);
            memset(wBuffer,<span class="charliteral">&#39;4&#39;</span>, bytes);
            <span class="keywordtype">int</span> rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a635e8ba101b004a75235e7e83d509b44">btlso::SocketImpUtil::write</a>(socket, &amp;wBuffer, bytes, 0);
            assert(0 &lt; rc);
        } <span class="keywordflow">break</span>;
        <span class="comment">// ...</span>
        <span class="keywordflow">default</span>: {
             ASSERT(<span class="stringliteral">&quot;Invalid event code&quot;</span> &amp;&amp; 0);
        } <span class="keywordflow">break</span>;
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:02 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
