<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlmt Package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Components</a>  </div>
  <div class="headertitle">
<h1>Package bdlmt<br/>
<small>
[<a class="el" href="group__bdl.html">Package Group bdl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provides thread pools and event schedulers.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Components</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlmt__eventscheduler.html">Component bdlmt_eventscheduler</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a thread-safe recurring and one-time event scheduler. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlmt__fixedthreadpool.html">Component bdlmt_fixedthreadpool</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide portable implementation for a fixed-size pool of threads. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlmt__multiprioritythreadpool.html">Component bdlmt_multiprioritythreadpool</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a mechanism to parallelize a prioritized sequence of jobs. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlmt__multiqueuethreadpool.html">Component bdlmt_multiqueuethreadpool</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a pool of queues, each processed serially by a thread pool. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlmt__threadmultiplexor.html">Component bdlmt_threadmultiplexor</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a mechanism for partitioning a collection of threads. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlmt__threadpool.html">Component bdlmt_threadpool</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide portable implementation for a dynamic pool of threads. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlmt__timereventscheduler.html">Component bdlmt_timereventscheduler</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a thread-safe recurring and non-recurring event scheduler. </p>
</td></tr>
</p>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">MNEMONIC: Basic Development Library Multi Thread (bdlmt)</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Hierarchical Synopsis</a> </li>
<li>
<a href="#3.2">Component Synopsis</a> </li>
<li>
<a href="#3.3">Generic Overview of Thread Pools</a> </li>
<li>
<a href="#3.4">Synchronous Signals on Unix</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provides thread pools and event schedulers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="mnemonic~3A_basic_development_library_multi_thread_(bdlmt)"></a> <a class="anchor" id="mnemonic"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>MNEMONIC: Basic Development Library Multi Thread (bdlmt): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacebdlcc.html">bdlcc</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bdlmt</code> ("Basic Development Library Multi Thread") package provides components for creating and managing thread pools, and components for scheduling (time-based) events. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A "thread pool" is a collection of processor threads that are managed together and used interchangeably to support user requests. The <code>bdlmt_threadpool</code> component allows clients to configure the pool so that it grows and shrinks according to user demand, manage thread availability, and schedule client "jobs" to be run independently as threads in the pool become available. It does this by placing client requests on an internal job queue, and controlling multiple threads as they remove jobs from the queue and execute them. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A "multi-queue thread pool" defines a dynamic, configurable pool of queues, each of which is processed by a thread in a thread pool, such that elements on a given queue are processed serially, regardless of which thread is processing the queue at a given time. In addition to the ability to create and delete queues, clients are able to tune the underlying thread pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A "timer-event scheduler" defines a thread-safe event scheduler. It provides methods to schedule and cancel recurring and non-recurring events (also referred to as clock). The callbacks are processed by a separate thread (called dispatcher thread). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hierarchical_synopsis"></a> <a class="anchor" id="description.hierarchical_synopsis"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Hierarchical Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bdlmt</code> package currently has 7 components having 2 levels of physical dependency. The list below shows the hierarchical ordering of the components. The order of components within each level is not architecturally significant, just alphabetical. <br/>
<br/>
<div class="fragment"><pre class="fragment">  2. bdlmt_multiqueuethreadpool
     bdlmt_threadmultiplexor

  1. bdlmt_eventscheduler
     bdlmt_fixedthreadpool
     bdlmt_multiprioritythreadpool
     bdlmt_threadpool
     bdlmt_timereventscheduler
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_synopsis"></a> <a class="anchor" id="description.component_synopsis"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Component Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlmt_eventscheduler</code>: <br/>
 Provide a thread-safe recurring and one-time event scheduler.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlmt_fixedthreadpool</code>: <br/>
 Provide portable implementation for a fixed-size pool of threads.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlmt_multiprioritythreadpool</code>: <br/>
 Provide a mechanism to parallelize a prioritized sequence of jobs.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlmt_multiqueuethreadpool</code>: <br/>
 Provide a pool of queues, each processed serially by a thread pool.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlmt_threadmultiplexor</code>: <br/>
 Provide a mechanism for partitioning a collection of threads.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlmt_threadpool</code>: <br/>
 Provide portable implementation for a dynamic pool of threads.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlmt_timereventscheduler</code>: <br/>
 Provide a thread-safe recurring and non-recurring event scheduler.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="generic_overview_of_thread_pools"></a> <a class="anchor" id="description.generic_overview_of_thread_pools"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Generic Overview of Thread Pools: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>At the current time, this generic overview applies only to the <code>bdlmt_MultipriorityThreadPool</code>. The plan is for other threadpools to move to this model at a later date. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As Figure 1 illustrates, a threadpool allows its clients to enqueue units of work to be processed concurrently in multiple threads. Each work item, or "job", consists of a function along with the address of its associated input data. When executed, this address is supplied to the function as its only argument; note that this function must have external linkage and return <code>void</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> job(<span class="keywordtype">void</span> *);     <span class="comment">// Idiomatic C-style function signature</span>
</pre></div><br/>
<br/>
 Alternatively both the function and its data can be encapsulated and supplied in the form of an (invokable) function object, or "functor", taking no arguments and returning <code>void</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  +-------------------------------------------------------------------------+
  |                     ThreadPool *Control* Methods                        |
  |                                                                         |
  | Front Operations        Middle Operations      Back Operations          |
  | ----------------        -----------------      ---------------          |
  | <span class="keywordtype">int</span> startThreads()      void removeJobs()      <span class="keywordtype">void</span> enableQueue()       |
  | <span class="keywordtype">void</span> stopThreads()      <span class="keywordtype">void</span> drainJobs()       <span class="keywordtype">void</span> disableQueue()      |
  | <span class="keywordtype">int</span> resumeProcessing()                         <span class="keywordtype">int</span> enqueueJob(func,arg) |
  | <span class="keywordtype">int</span> suspendProcessing()                        <span class="keywordtype">int</span> enqueueJob(job)      |
  |                                                                         |
  +- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -+
  |           +--&lt;--+--&lt;--+--&lt;--+--&lt;--+--&lt;--+----------------+              |
  |           |     |     |     |     |     |                |              |
  |  Front &lt;==| Job | Job | Job | Job | Job |                |==&lt; Back      |
  |           |     |     |     |     |     |                |              |
  |           +--&lt;--+--&lt;--+--&lt;--+--&lt;--+--&lt;--+----------------+              |
  |                                                                         |
  |     ,----------------.                      ,-----------------.         |
  |    ( N Worker Threads )                    ( Thread Attributes )        |
  |     `----------------&#39;                      `-----------------&#39;         |
  +-------------------------------------------------------------------------+
             Figure 1: Illustration of Generalized Thread Pool
</pre></div><br/>
<br/>
 In addition to enqueuing jobs, a thread pool must supply primitive control functionality such as creating and destroying worker threads, enabling and disabling the enqueuing of new jobs, causing the queue to block until there are no pending jobs, and removing (i.e., canceling) all pending (i.e., not yet running) jobs. Different kinds of threadpools will provide different functionality and/or performance characteristics, corresponding those of the underlying thread-enabled (<code>bdlcc</code>) queue -- e.g., (limited-capacity) <code>FixedQueue</code>, (heap-based) <code>PriorityQueue</code>, and (array-based) <code>MultipriorityQueue</code>. Nonetheless, each of the threadpool objects in <code>bdlmt</code> should provide a suite of input and control operations that are consistent in both name and behavior across the <code>bdlmt</code> package. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to the intricate nature of threadpools, it is easy to convolve behaviors in subtly different ways for functions having the same name. Consider, for example, the method <code>void drainJobs()</code>, the basic functionality of which is to <code>block</code> the caller until all of the pending jobs complete (i.e., the queue is empty and all worker threads are idle). Should <code>drainJobs()</code> also leave the queue in the disabled state? Even if that is a common usage pattern, it is often useful to start with simple, orthogonal behaviors, and if needed, define more complex behaviors in terms of them. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the case of a thread pool, it is instructive to break the functionality into three categories of operations relative to the underlying queue: Front, Middle, and Back. At the back of the queue (refer to Figure 1), we need to enable/disable clients from adding work items. Enabling or disabling the queue does not affect the items already in the queue [Middle], nor any worker threads processing these items [Front]. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the middle of the queue, we have two operations that result in purging all pending items in the queue: <code>drainJobs()</code> and <code>removeJobs()</code> If we invoke <code>removeJobs()</code>, then all currently pending (i.e., not started) work items will be removed (i.e., canceled). During this process, clients attempting to add work items [Back] will block, but their eventual success or failure, (which is based solely on whether the queue is enabled or disabled) is not affected. Note that jobs that are already in progress [Front] are also unaffected. Similarly, invoking our orthogonal <code>drainJobs()</code> method will block enqueuing clients until all pending jobs have completed, but will not affect the enabledness of the thread pool [Back], nor the processing of work items [Front]. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally we come to the front of the queue, which addresses the processing of jobs. A (typically fixed) number of worker threads is specified at construction. The thread pool "wakes up" in an enabled state, but without having created the worker threads. Invoking the <code>startThreads()</code> method attempts to create these threads (unless they are already created). The <code>startThreads()</code> method returns 0 if all of these threads are started, and a non-zero value otherwise (in which case none of the worker threads are started). Redundant calls to <code>startThreads()</code> do nothing and return zero. Invoking <code>stopThreads()</code> destroys each worker thread (after it completes any current job). Note that the current contents of the queue [Middle], and the ability to enqueue new jobs [Back] are not affected. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Whether or not started threads should be pulling jobs from the queue and processing them is not necessarily the same as having the user-specified number of worker threads created. In addition to being <em>enabled</em> and <em>started</em> let's consider one more possible state, <em>suspended</em>. If a thread pool is in the <em>suspended</em> state, then even when it is in the <em>started</em> state, it will not attempt to pop jobs from the queue and execute them. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A created threadpool will be created enabled, not suspended, and not started. All three of these qualities are orthogonal and any one of them can be changed at any time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The vast majority of users will be uninterested in both the <code>suspend</code> and <code>disable</code> features, so it is imperative that newly created threadpools be both non-suspended and enabled so users can remain blissfully ignorant of them. It is also important the first usage examples, if not all of them, omit use of these features to minimize learning time for the typical user. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To conclude this generic overview, we note that there is one common usage that, although not minimal, arguably deserves to be a method of every thread pool class: <code>void shutdown()</code>. This method is best described as a composition of the simple, orthogonal functions described above. In order to shut down a thread pool, we need to first disable the enqueuing of any additional jobs, then remove all of the the pending work items, and finally stop all of the active threads: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> shutdown()
  {
      disableQueue();
      removeJobs();
      stopThreads();
  }
</pre></div><br/>
<br/>
 By making sure that our initial operations are simple and orthogonal, we can ensure that the precise meaning of more complex operations is kept clear. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synchronous_signals_on_unix"></a> <a class="anchor" id="description.synchronous_signals_on_unix"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Synchronous Signals on Unix: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A thread pool ensures that, on Unix platforms, all the threads in the pool block all asynchronous signals. Specifically all the signals, except the following synchronous signals are blocked. <br/>
<br/>
<div class="fragment"><pre class="fragment">  SIGBUS
  SIGFPE
  SIGILL
  SIGSEGV
  SIGSYS
  SIGABRT
  SIGTRAP
  SIGIOT
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
