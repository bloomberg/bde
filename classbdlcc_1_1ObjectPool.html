<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlcc::ObjectPool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlcc.html">bdlcc</a>      </li>
      <li><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool&lt; TYPE, CREATOR, RESETTER &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bdlcc::ObjectPool&lt; TYPE, CREATOR, RESETTER &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlcc::ObjectPool" --><!-- doxytag: inherits="bdlma::Factory" -->
<p><code>#include &lt;<a class="el" href="bdlcc__objectpool_8h_source.html">bdlcc_objectpool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdlcc::ObjectPool&lt; TYPE, CREATOR, RESETTER &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdlcc_1_1ObjectPool.png" usemap="#bdlcc::ObjectPool&lt; TYPE, CREATOR, RESETTER &gt;_map" alt=""/>
  <map id="bdlcc::ObjectPool&lt; TYPE, CREATOR, RESETTER &gt;_map" name="bdlcc::ObjectPool&lt; TYPE, CREATOR, RESETTER &gt;_map">
<area href="classbdlma_1_1Factory.html" alt="bdlma::Factory&lt; TYPE &gt;" shape="rect" coords="0,56,306,80"/>
<area href="classbdlma_1_1Deleter.html" alt="bdlma::Deleter&lt; TYPE &gt;" shape="rect" coords="0,0,306,24"/>
</map>
</div>

<p><a href="classbdlcc_1_1ObjectPool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>AutoCleanup</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><b>BlockNode</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><b>ObjectNode</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RESETTER&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a17cd75523455828063d9e5f21568fa33">ResetterType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CREATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#af7066bc3afdcfee470d5576195d528bc">CreatorType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a2a04af878ac2051027f3f04c07eb532b">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#ae57a408781beca696734efdebe9cef2f">ObjectPool</a> (int growBy=-1, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a07d7715a28c385c093405d1a71871729">ObjectPool</a> (const CREATOR &amp;objectCreator, int growBy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#addf639c964438cf4a64ad4a09d43da16">ObjectPool</a> (const CREATOR &amp;objectCreator, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a4f8cbd3c9747be7d261274c1a56d0a8c">ObjectPool</a> (const CREATOR &amp;objectCreator, const RESETTER &amp;objectResetter, int growBy=-1, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANYPROTO &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#aa01da55445a4a91a366d7c6a5fccc00c">ObjectPool</a> (const bsl::function&lt; ANYPROTO &gt; &amp;objectCreator, int growBy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANYPROTO &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#adedaaf1b553aa435cdd381e8d54618ba">ObjectPool</a> (const bsl::function&lt; ANYPROTO &gt; &amp;objectCreator, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a5309c7f60b5f22f37e736600750fe53e">~ObjectPool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a2aa05cd506bc83b24c0869a3326db5f9">getObject</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a2d4d61aa9e07e785d0a209d8c927bede">increaseCapacity</a> (int numObjects)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a762eb19f3ddc452f85bd5e4b5c24ecb5">releaseObject</a> (TYPE *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a29a7dfad71677958e36aaae5fb9edaae">reserveCapacity</a> (int numObjects)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a9110e3bbbf6acff5fca6f46c8246b47a">numAvailableObjects</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a33123ab5762ece30d156b20bef37ade8">numObjects</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a434a94e74f4bbe097a090939c49334d6">createObject</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a15ba8a4e7c0099515d44b4609ab2dcc1">deleteObject</a> (TYPE *object)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1ObjectPool.html#a1eb4eec8c2145217757a38bf8db719e4">AutoCleanup</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt;<br/>
 class bdlcc::ObjectPool&lt; TYPE, CREATOR, RESETTER &gt;</h3>

<p>This class provides a thread-safe pool of reusable objects. It also implements the <code><a class="el" href="classbdlma_1_1Factory.html">bdlma::Factory</a></code> protocol: "creating" objects gets them from the pool and "deleting" objects returns them to the pool. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a17cd75523455828063d9e5f21568fa33"></a><!-- doxytag: member="bdlcc::ObjectPool::ResetterType" ref="a17cd75523455828063d9e5f21568fa33" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef RESETTER <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::<a class="el" href="classbdlcc_1_1ObjectPool.html#a17cd75523455828063d9e5f21568fa33">ResetterType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af7066bc3afdcfee470d5576195d528bc"></a><!-- doxytag: member="bdlcc::ObjectPool::CreatorType" ref="af7066bc3afdcfee470d5576195d528bc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CREATOR <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::<a class="el" href="classbdlcc_1_1ObjectPool.html#af7066bc3afdcfee470d5576195d528bc">CreatorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae57a408781beca696734efdebe9cef2f"></a><!-- doxytag: member="bdlcc::ObjectPool::ObjectPool" ref="ae57a408781beca696734efdebe9cef2f" args="(int growBy=&#45;1, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::<a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>growBy</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an object pool that invokes the default constructor of the the parameterized <code>TYPE</code> to construct objects. When the pool is depleted, it will increase its capacity according to the optionally specified <code>growBy</code> value. If <code>growBy</code> is positive, the pool replenishes itself with at least <code>growBy</code> new objects. If <code>growBy</code> is negative, the amount of increase begins at <code>-growBy</code> and grows geometrically up to an implementation-defined maximum. When objects are returned to the pool, the default value of RESETTER is invoked with a pointer to the returned object to restore the object to a reusable state. The optionally specified <code>basicAllocator</code> is used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 != growBy</code>. </p>

</div>
</div>
<a class="anchor" id="a07d7715a28c385c093405d1a71871729"></a><!-- doxytag: member="bdlcc::ObjectPool::ObjectPool" ref="a07d7715a28c385c093405d1a71871729" args="(const CREATOR &amp;objectCreator, int growBy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::<a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">const CREATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>objectCreator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>growBy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="addf639c964438cf4a64ad4a09d43da16"></a><!-- doxytag: member="bdlcc::ObjectPool::ObjectPool" ref="addf639c964438cf4a64ad4a09d43da16" args="(const CREATOR &amp;objectCreator, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::<a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">const CREATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>objectCreator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an object pool that uses the specified <code>objectCreator</code> (encapsulating the construction of objects) to create objects. The client must ensure that <code>objectCreator(buf, alloc)</code> creates an object at memory location <code>buf</code> using <code>alloc</code> to supply memory. When the pool is depleted, it will grow capacity according to the optionally specified <code>growBy</code> value. If <code>growBy</code> is positive, the pool replenishes itself with at least <code>growBy</code> new objects. If <code>growBy</code> is negative, the amount of increase begins at <code>-growBy</code> and grows geometrically up to an implementation-defined maximum. When objects are returned to the pool, the default value of RESETTER is invoked with a pointer to the returned object to restore the object to a reusable state. The optionally specified <code>basicAllocator</code> is used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 != growBy</code>. </p>

</div>
</div>
<a class="anchor" id="a4f8cbd3c9747be7d261274c1a56d0a8c"></a><!-- doxytag: member="bdlcc::ObjectPool::ObjectPool" ref="a4f8cbd3c9747be7d261274c1a56d0a8c" args="(const CREATOR &amp;objectCreator, const RESETTER &amp;objectResetter, int growBy=&#45;1, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::<a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">const CREATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>objectCreator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RESETTER &amp;&nbsp;</td>
          <td class="paramname"> <em>objectResetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>growBy</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an object pool that uses the specified <code>objectCreator</code> (encapsulating the construction of objects) to create objects. The client must ensure that <code>objectCreator(buf, alloc)</code> creates an object at memory location <code>buf</code> using <code>alloc</code> to supply memory. When the pool is depleted, it will increase its capacity according to the optionally specified <code>growBy</code> value. If <code>growBy</code> is positive, the pool replenishes itself with at least <code>growBy</code> new objects. If <code>growBy</code> is negative, the amount of increase begins at <code>-growBy</code> and grows geometrically up to an implementation-defined maximum. When objects are returned to the pool, the specified <code>objectResetter</code> is invoked with a pointer to the returned object to restore the object to a reusable state. The optionally specified <code>basicAllocator</code> is used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 != growBy</code>. </p>

</div>
</div>
<a class="anchor" id="aa01da55445a4a91a366d7c6a5fccc00c"></a><!-- doxytag: member="bdlcc::ObjectPool::ObjectPool" ref="aa01da55445a4a91a366d7c6a5fccc00c" args="(const bsl::function&lt; ANYPROTO &gt; &amp;objectCreator, int growBy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ANYPROTO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::<a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">const bsl::function&lt; ANYPROTO &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objectCreator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>growBy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adedaaf1b553aa435cdd381e8d54618ba"></a><!-- doxytag: member="bdlcc::ObjectPool::ObjectPool" ref="adedaaf1b553aa435cdd381e8d54618ba" args="(const bsl::function&lt; ANYPROTO &gt; &amp;objectCreator, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ANYPROTO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::<a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">const bsl::function&lt; ANYPROTO &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objectCreator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>DEPRECATED</em> Use a creator of the parameterized <code>CREATOR</code> type. </p>

</div>
</div>
<a class="anchor" id="a5309c7f60b5f22f37e736600750fe53e"></a><!-- doxytag: member="bdlcc::ObjectPool::~ObjectPool" ref="a5309c7f60b5f22f37e736600750fe53e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::~<a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object pool. All objects created by this pool are destroyed (even if some of them are still in use) and memory is reclaimed. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2a04af878ac2051027f3f04c07eb532b"></a><!-- doxytag: member="bdlcc::ObjectPool::BSLALG_DECLARE_NESTED_TRAITS" ref="a2a04af878ac2051027f3f04c07eb532b" args="(ObjectPool, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1ObjectPool.html">ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2aa05cd506bc83b24c0869a3326db5f9"></a><!-- doxytag: member="bdlcc::ObjectPool::getObject" ref="a2aa05cd506bc83b24c0869a3326db5f9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE* <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::getObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an address of modifiable object from this object pool. If this pool is empty, it is replenished according to the strategy specified at the pool construction (or an implementation-defined strategy if none was provided). </p>

</div>
</div>
<a class="anchor" id="a2d4d61aa9e07e785d0a209d8c927bede"></a><!-- doxytag: member="bdlcc::ObjectPool::increaseCapacity" ref="a2d4d61aa9e07e785d0a209d8c927bede" args="(int numObjects)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::increaseCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numObjects</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create the specified <code>numObjects</code> objects and add them to this object pool. The behavior is undefined unless <code>0 &lt;= numObjects</code>. </p>

</div>
</div>
<a class="anchor" id="a762eb19f3ddc452f85bd5e4b5c24ecb5"></a><!-- doxytag: member="bdlcc::ObjectPool::releaseObject" ref="a762eb19f3ddc452f85bd5e4b5c24ecb5" args="(TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::releaseObject </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the specified <code>object</code> back to this object pool. Invoke the RESETTER specified at construction, or the default RESETTER if none was provided, before making the object available for reuse. Note that if RESETTER is the default type (<code><a class="el" href="classbdlcc_1_1ObjectPoolFunctors_1_1Nil.html">ObjectPoolFunctors::Nil</a></code>), then this method should be invoked to return only <em>valid</em> objects because the pool uses the released objects to satisfy further <code>getObject</code> requests. The behavior is undefined unless the <code>object</code> was obtained from this object pool's <code>getObject</code> method. </p>

</div>
</div>
<a class="anchor" id="a29a7dfad71677958e36aaae5fb9edaae"></a><!-- doxytag: member="bdlcc::ObjectPool::reserveCapacity" ref="a29a7dfad71677958e36aaae5fb9edaae" args="(int numObjects)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numObjects</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create enough objects to satisfy requests for at least the specified <code>numObjects</code> objects before the next replenishment. The behavior is undefined unless <code>0 &lt;= numObjects</code>. Note that this method is different from <code>increaseCapacity</code> in that the number of created objects may be less than <code>numObjects</code>. </p>

</div>
</div>
<a class="anchor" id="a9110e3bbbf6acff5fca6f46c8246b47a"></a><!-- doxytag: member="bdlcc::ObjectPool::numAvailableObjects" ref="a9110e3bbbf6acff5fca6f46c8246b47a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::numAvailableObjects </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <em>snapshot</em> of the number of objects available in this pool. </p>

</div>
</div>
<a class="anchor" id="a33123ab5762ece30d156b20bef37ade8"></a><!-- doxytag: member="bdlcc::ObjectPool::numObjects" ref="a33123ab5762ece30d156b20bef37ade8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::numObjects </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (instantaneous) number of objects managed by this pool. This includes both the objects available in the pool and the objects that were allocated from the pool and not yet released. </p>

</div>
</div>
<a class="anchor" id="a434a94e74f4bbe097a090939c49334d6"></a><!-- doxytag: member="bdlcc::ObjectPool::createObject" ref="a434a94e74f4bbe097a090939c49334d6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual TYPE* <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::createObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This concrete implementation of <code><a class="el" href="classbdlma_1_1Factory.html#aada9ccbcc9313d18d6d3318e60aee2e9">bdlma::Factory::createObject</a></code> invokes <code>getObject</code>. This should not be invoked directly. </p>

<p>Implements <a class="el" href="classbdlma_1_1Factory.html#aada9ccbcc9313d18d6d3318e60aee2e9">bdlma::Factory&lt; TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a15ba8a4e7c0099515d44b4609ab2dcc1"></a><!-- doxytag: member="bdlcc::ObjectPool::deleteObject" ref="a15ba8a4e7c0099515d44b4609ab2dcc1" args="(TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a>&lt; TYPE, CREATOR, RESETTER &gt;::deleteObject </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This concrete implementation of <code><a class="el" href="classbdlma_1_1Factory.html#a290061ceb693b61d14418951159c1a9a">bdlma::Factory::deleteObject</a></code> invokes <code>releaseObject</code> on the specified <code>object</code>, returning it to this pool. Note that this does <em>not</em> destroy the object and should not be invoked directly. </p>

<p>Implements <a class="el" href="classbdlma_1_1Factory.html#a290061ceb693b61d14418951159c1a9a">bdlma::Factory&lt; TYPE &gt;</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a1eb4eec8c2145217757a38bf8db719e4"></a><!-- doxytag: member="bdlcc::ObjectPool::AutoCleanup" ref="a1eb4eec8c2145217757a38bf8db719e4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class CREATOR = ObjectPoolFunctors::DefaultCreator, class RESETTER = ObjectPoolFunctors::Nil&lt;TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class AutoCleanup<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlcc__objectpool_8h_source.html">bdlcc_objectpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:18 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
