<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_allocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslma_allocator<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a pure abstract interface for memory-allocation mechanisms.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__allocator.html#gac5363158ac0ed1690a6a09e3300c19e5">operator new</a> (std::size_t size, BloombergLP::bslma::Allocator &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__allocator.html#ga6cf9e81d957defe9c22a005d59e9624d">operator delete</a> (void *address, BloombergLP::bslma::Allocator &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__allocator.html#gab092d166ac47246cc0780e40258dba16">operator new</a> (std::size_t size, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslma__allocator.html#ga758c1b7ef9fe890629dd8ef16fc21f8a">operator delete</a> (void *address, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Allocators Versus Pools</a> </li>
<li>
<a href="#3.3">Overloaded Global Operators <code>new</code> and <code>delete</code></a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Usage 1: Container Objects</a> </li>
<li>
<a href="#3.4.2">Usage 2: Derived Concrete Allocators</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a pure abstract interface for memory-allocation mechanisms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> </td><td>protocol class for memory allocation and deallocation  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__newdeleteallocator.html" title="Provide singleton new/delete adaptor to bslma::Allocator protocol.">Component bslma_newdeleteallocator</a>, <a class="el" href="group__bslma__testallocator.html" title="Provide instrumented malloc/free allocator to track memory usage.">Component bslma_testallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides the base-level protocol (pure abstract interface) class, <code>bslma_allocator</code>, that serves as a ubiquitous vocabulary type for various memory allocation mechanisms. The functional capabilities documented by this protocol are similar to those afforded by global operators <code>new</code> and <code>delete</code>: sufficiently (but not necessarily maximally) aligned memory is guaranteed for any object of a given size. Clients of this abstract base class will typically accept a supplied allocator (often at construction) and use its <code>allocate</code> and <code>deallocate</code> methods instead of <code>new</code> and <code>delete</code> directly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The use of (abstract) allocators provide at least three distinct advantages over direct (hard-coded) calls to global <code>new</code> and <code>delete</code> (see <code>bslma_newdeleteallocator</code>): </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
The particular choice of allocator can be selected to improve performance on a per-object basis. Without allocators, the best we can do in C++ is to overload the class-specific new and delete. Class-specific allocators tend to hoard memory even when most objects of the class have been deallocated, and often mask memory leaks that would otherwise have been detected. See Lakos-96, Section 10.3.4.2, pp 705-711.  </li>
<li>
By providing extra capabilities (beyond <code>new</code> and <code>delete</code>) in the derived class (see <code>bslma_managedallocator</code>), we can bypass the individual destructors in a dynamically allocated type and remove all memory for one or more associated object almost instantly.  </li>
<li>
The <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol, like any other protocol, isolates clients from direct coupling with platform level facilities that are not fully under their control. By installing a test allocator (see <code>bslma_testallocator</code>), we are able to orchestrate the white-box testing of internal calls to global operators <code>new</code> and <code>delete</code> in a platform-neutral manner.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unless otherwise documented, a single allocator object is not safe for concurrent access by multiple threads. Classes derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> that are specifically designed for concurrent access must be documented as such. Unless specifically documented otherwise, separate objects of classes derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> may safely be used in separate threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="allocators_versus_pools"></a> <a class="anchor" id="description.allocators_versus_pools"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Allocators Versus Pools: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An allocator and a pool are quite different. For starters, <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> is an abstract class used to obtain "raw" memory of arbitrary size. A pool is a concrete data structure used to organize and supply memory according to specific needs (e.g., a consistent size). Concrete allocators may use pools in their implementations, and pools will aways take a base <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol in their interface. You can think of an allocator as a stream of memory that flows into a pool of memory. Memory is allocated from the pool until it is dry; only then does new memory flow into the pool from the allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="overloaded_global_operators_new_and_delete"></a> <a class="anchor" id="description.overloaded_global_operators_new_and_delete"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Overloaded Global Operators new and delete: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component overloads the global operator <code>new</code> to allow convenient syntax for the construction of objects using the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol. The overloaded <code>new</code> operator defined in this component has a second parameter, <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>&amp;</code>, that identifies the concrete (derived) allocator that will be used to supply memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Consider the following use of standard placement syntax (supplied by <code>#include &lt;new&gt;</code>) along with a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, used to allocate an arbitrary <code>TYPE</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> someFunction(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  {
      TYPE *obj = <span class="keyword">new</span> (basicAllocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>(<span class="keyword">sizeof</span>(TYPE))) TYPE(...);

      <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 This style of usage is inconvenient and error prone; it is also <em>not</em> exception safe: If the constructor of <code>TYPE</code> throws an exception, the <code>basicAllocator-&gt;deallocate</code> method is never called. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Providing an overloaded global operator <code>new</code>, taking a reference to a modifiable <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> as an explicit argument allows for cleaner usage and guarantees that the <code>basicAllocator-&gt;deallocate</code> method is called in case of an exception: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> someFunction(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  {
      TYPE *obj = <span class="keyword">new</span> (*basicAllocator) TYPE(...);

      <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Finally, the analogous version of operator <code>delete</code> should not be called directly: The overloaded operator <code>delete</code> supplied in this component is solely for the compiler to invoke in the event an exception is thrown during a failed construction. Instead, the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol provides <code>deleteObject</code> (a template member function parameterized by the type of the object being deleted), which is implemented <em>conceptually</em> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> <a class="code" href="classbslma_1_1Allocator.html#a0e51fc2d107684523cc66bf65293dc37">bslma::Allocator::deleteObject</a>(TYPE *address)
  {
      address-&gt;~TYPE();
      this-&gt;<a class="code" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">deallocate</a>(address);
  }
</pre></div><br/>
<br/>
 Note that there is also a <code>deleteObjectRaw</code> which is more efficient when it is known that the <code>address</code> does <em>not</em> refer to a secondary base class of the object being deleted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol provided in this component defines a bilateral contract between suppliers and consumers of raw memory. The following subsections illustrate (1) use, and (2) implementation of the abstract <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> base class: </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_1"></a> <a class="anchor" id="usage.usage_1"></a> <a class="anchor" id="description.usage.usage_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage 1: Container Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Allocators are often supplied to objects requiring dynamically-allocated memory at construction. For example, consider the following <code>my_DoubleStack</code> class, parameterized by a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_doublestack.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">namespace </span>bslma { <span class="keyword">class </span>Allocator; } <span class="comment">// forward declaration of allocator</span>

  <span class="keyword">class </span>my_DoubleStack {
      <span class="comment">// DATA</span>
      <span class="keywordtype">double</span>           *d_stack_p;     <span class="comment">// dynamically allocated array (d_size</span>
                                       <span class="comment">// elements)</span>

      <span class="keywordtype">int</span>               d_size;        <span class="comment">// physical capacity of this stack (in</span>
                                       <span class="comment">// elements)</span>

      <span class="keywordtype">int</span>               d_length;      <span class="comment">// logical index of next available</span>
                                       <span class="comment">// stack element</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p; <span class="comment">// holds (but does not own) object</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keyword">class </span>my_DoubleStackIter;

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> increaseSize(); <span class="comment">// Increase the capacity by at least one element.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_DoubleStack(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
      my_DoubleStack(<span class="keyword">const</span> my_DoubleStack&amp;  other,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>       *basicAllocator = 0);
      ~my_DoubleStack();

      <span class="comment">// MANIPULATORS</span>
      my_DoubleStack&amp; operator=(<span class="keyword">const</span> my_DoubleStack&amp; rhs);
      <span class="keywordtype">void</span> push(<span class="keywordtype">double</span> value);
      <span class="keywordtype">void</span> pop();

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; top() <span class="keyword">const</span>;
      <span class="keywordtype">bool</span> isEmpty() <span class="keyword">const</span>;
  };

  <span class="comment">// ...</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_DoubleStack::push(<span class="keywordtype">double</span> value)
  {
      <span class="keywordflow">if</span> (d_length &gt;= d_size) {
          increaseSize();
      }
      d_stack_p[d_length++] = item;
  }

  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 The stack interface takes an optional <code>basicAllocator</code> supplied only at construction. (We avoid use of the name <code>allocator</code> so as not to conflict with the STL use of the word, which differs slightly.) If non-zero, the stack holds a pointer to this allocator, but does not own it. If no allocator is supplied, the implementation itself must either conditionally invoke global <code>new</code> and <code>delete</code> explicitly whenever memory dynamic memory must be managed (BAD IDEA) or (GOOD IDEA) install a default allocator that adapts use of these global operators to the <code>bslma_allocator</code> interface (see <code>bslma_newdeleteallocator</code>). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_doublestack.cpp</span>
<span class="preprocessor">  #include &lt;my_doublestack.h&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bslma__allocator_8h.html" title="Provide a pure abstract interface for memory-allocation mechanisms.">bslma_allocator.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bslma__newdeleteallocator_8h.html" title="Provide singleton new/delete adaptor to bslma::Allocator protocol.">bslma_newdeleteallocator.h</a>&gt;</span>  <span class="comment">// adapter for &#39;new&#39; and &#39;delete&#39;</span>
  <span class="comment">// ...</span>

  <span class="keyword">enum</span> { INITIAL_SIZE = 1, GROW_FACTOR = 2 };

  <span class="comment">// ...</span>

  <span class="comment">// CREATORS</span>
  my_DoubleStack::my_DoubleStack(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_size(INITIAL_SIZE)
  , d_length(0)
  , d_allocator_p(bslma::NewDeleteAllocator::allocator(basicAllocator))
      <span class="comment">// The above initialization expression is equivalent to &#39;basicAllocator</span>
      <span class="comment">// ? basicAllocator : &amp;bslma::NewDeleteAllocator::singleton()&#39;.</span>
  {
      assert(d_allocator_p);
      d_stack_p = (<span class="keywordtype">double</span> *)
                  d_allocator_p-&gt;allocate(d_size * <span class="keyword">sizeof</span> *d_stack_p);
  }

  my_DoubleStack::~my_DoubleStack()
  {
      <span class="comment">// CLASS INVARIANTS</span>
      assert(d_allocator_p);
      assert(d_stack_p);
      assert(0 &lt;= d_length);
      assert(0 &lt;= d_size);
      assert(d_length &lt;= d_size);

      d_allocator_p-&gt;deallocate(d_stack_p);
  }
</pre></div><br/>
<br/>
 Even in this simplified implementation, all use of the allocator protocol is relegated to the <code>.cpp</code> file. Subsequent use of the allocator is demonstrated by the following file-scope static reallocation function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keyword">inline</span>
  <span class="keywordtype">void</span> reallocate(<span class="keywordtype">double</span>          **array,
                  <span class="keywordtype">int</span>               newSize,
                  <span class="keywordtype">int</span>               length,
                  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>  *basicAllocator)
      <span class="comment">// Reallocate memory in the specified &#39;array&#39; to the specified</span>
      <span class="comment">// &#39;newSize&#39; using the specified &#39;basicAllocator&#39;.  The specified</span>
      <span class="comment">// &#39;length&#39; number of leading elements are preserved.  Since the</span>
      <span class="comment">// class invariant requires that the physical capacity of the</span>
      <span class="comment">// container may grow but never shrink, the behavior is undefined</span>
      <span class="comment">// unless &#39;length &lt;= newSize&#39;.</span>
  {
      assert(array);
      assert(1 &lt;= newSize);
      assert(0 &lt;= length);
      assert(basicAllocator);
      assert(length &lt;= newSize);  <span class="comment">// enforce class invariant</span>

      <span class="keywordtype">double</span> *tmp = *array;       <span class="comment">// support exception neutrality</span>
      *array = (<span class="keywordtype">double</span> *) basicAllocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>(newSize * <span class="keyword">sizeof</span> **array);

      <span class="comment">// COMMIT POINT</span>

      std::memcpy(*array, tmp, length * <span class="keyword">sizeof</span> **array);
      basicAllocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">deallocate</a>(tmp);
  }

  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keywordtype">void</span> my_DoubleStack::increaseSize()
  {
      <span class="keywordtype">int</span> proposedNewSize = d_size * GROW_FACTOR;  <span class="comment">// reallocate can throw</span>
      assert(proposedNewSize &gt; d_length);
      reallocate(&amp;d_stack_p, proposedNewSize, d_length, d_allocator_p);
      d_size = proposedNewSize;                    <span class="comment">// we&#39;re committed</span>
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_2"></a> <a class="anchor" id="usage.usage_2"></a> <a class="anchor" id="description.usage.usage_2"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage 2: Derived Concrete Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order for the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> interface to be useful, we must supply a concrete allocator that implements it. In this example we demonstrate how to adapt <code>operator new</code> and <code>operator delete</code> to this protocol base class. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_newdeleteallocator.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">class </span>my_NewDeleteAllocator : <span class="keyword">public</span> bslma::Allocator {
      <span class="comment">// This class is a sample concrete implementation of the</span>
      <span class="comment">// &#39;bslma::Allocator&#39; protocol that provides direct access to the</span>
      <span class="comment">// system-supplied (native) global operators &#39;new&#39; and &#39;delete&#39;.</span>

      <span class="comment">// NOT IMPLEMENTED</span>
      my_NewDeleteAllocator(<span class="keyword">const</span> <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a>&amp;);
      my_NewDeleteAllocator&amp; operator=(<span class="keyword">const</span> <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a>&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_NewDeleteAllocator();
          <span class="comment">// Create an allocator that wraps the global (native) operators</span>
          <span class="comment">// &#39;new&#39; and &#39;delete&#39; to supply memory.  Note that all objects of</span>
          <span class="comment">// this class share the same underlying resource.</span>

      <span class="keyword">virtual</span> ~my_NewDeleteAllocator();
          <span class="comment">// Destroy this allocator object.  Note that destroying this</span>
          <span class="comment">// allocator has no effect on any outstanding allocated memory.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(size_type size);
          <span class="comment">// Return a newly allocated block of memory of (at least) the</span>
          <span class="comment">// specified positive &#39;size&#39; (in bytes).  If &#39;size&#39; is 0, a null</span>
          <span class="comment">// pointer is returned with no other effect.  If this allocator</span>
          <span class="comment">// cannot return the requested number of bytes, then it will throw</span>
          <span class="comment">// a &#39;std::bad_alloc&#39; exception in an exception-enabled build, or</span>
          <span class="comment">// else will abort the program in a non-exception build.  The</span>
          <span class="comment">// behavior is undefined unless &#39;0 &lt;= size&#39;.  Note that the</span>
          <span class="comment">// alignment of the address returned is the maximum alignment for</span>
          <span class="comment">// any type defined on this platform.  Also note that global</span>
          <span class="comment">// &#39;operator new&#39; is *not* called when &#39;size&#39; is 0 (in order to</span>
          <span class="comment">// avoid having to acquire a lock, and potential contention in</span>
          <span class="comment">// multi-threaded programs).</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
          <span class="comment">// Return the memory block at the specified &#39;address&#39; back to this</span>
          <span class="comment">// allocator.  If &#39;address&#39; is 0, this function has no effect.  The</span>
          <span class="comment">// behavior is undefined unless &#39;address&#39; was allocated using this</span>
          <span class="comment">// allocator object and has not already been deallocated.  Note</span>
          <span class="comment">// that global &#39;operator delete&#39; is *not* called when &#39;address&#39; is</span>
          <span class="comment">// 0 (in order to avoid having to acquire a lock, and potential</span>
          <span class="comment">// contention in multi-treaded programs).</span>
  };

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_NewDeleteAllocator::my_NewDeleteAllocator()
  {
  }
  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 The virtual methods of <code>my_NewDeleteAllocator</code> are defined in the component <code>.cpp</code> file as they would not be inlined when invoked from the base class, which would be the typical usage in this case: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_newdeleteallocator.cpp</span>
<span class="preprocessor">  #include &lt;my_newdeleteallocator.h&gt;</span>

  <span class="comment">// CREATORS</span>
  my_NewDeleteAllocator::~my_NewDeleteAllocator()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> *my_NewDeleteAllocator::allocate(size_type size)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(0 &lt;= size);

      <span class="keywordflow">return</span> 0 == size ? 0 : ::operator <span class="keyword">new</span>(size);
  }

  <span class="keywordtype">void</span> my_NewDeleteAllocator::deallocate(<span class="keywordtype">void</span> *address)
  {
      <span class="comment">// While the C++ standard guarantees that calling delete(0) is safe</span>
      <span class="comment">// (3.7.3.2 paragraph 3), some libc implementations take out a lock to</span>
      <span class="comment">// deal with the free(0) case, so this check can improve efficiency of</span>
      <span class="comment">// threaded programs.</span>

      <span class="keywordflow">if</span> (address) {
          ::operator <span class="keyword">delete</span>(address);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gac5363158ac0ed1690a6a09e3300c19e5"></a><!-- doxytag: member="bslma_allocator.h::operator new" ref="gac5363158ac0ed1690a6a09e3300c19e5" args="(std::size_t size, BloombergLP::bslma::Allocator &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the memory allocated from the specified <code>basicAllocator</code> of at least the specified <code>size</code> bytes, or 0 if <code>size</code> is 0. The behavior is undefined unless <code>0 &lt;= static_cast&lt;<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a>&gt;(size)</code>. Note that an object may allocate additional memory internally, requiring the allocator to be passed in as a constructor argument: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      my_Type *createMyType(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
      {
          <span class="keywordflow">return</span> <span class="keyword">new</span> (*basicAllocator) my_Type(..., basicAllocator);
      }
</pre></div><p><br/>
<br/>
 Note also that the analogous version of operator <code>delete</code> should <em>not</em> be called directly. Instead, this component provides a template member function <code>deleteObject</code> parameterized by <code>TYPE</code> that effectively performs the following operations: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> deleteMyType(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator, my_Type *address)
      {
          address-&gt;~my_Type();
          basicAllocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">deallocate</a>(<span class="keywordtype">object</span>);
      }
</pre></div><p><br/>
<br/>
 See also <code>deleteObjectRaw</code> for better performance when <code>address</code> is known not be a secondary base type of the object being deleted. </p>

</div>
</div>
<a class="anchor" id="ga6cf9e81d957defe9c22a005d59e9624d"></a><!-- doxytag: member="bslma_allocator.h::operator delete" ref="ga6cf9e81d957defe9c22a005d59e9624d" args="(void *address, BloombergLP::bslma::Allocator &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the specified <code>basicAllocator</code> to deallocate the memory at the specified <code>address</code>. The behavior is undefined unless <code>address</code> was allocated using <code>basicAllocator</code> and has not already been deallocated. This operator is supplied solely to allow the compiler to arrange for it to be called in case of an exception. </p>

</div>
</div>
<a class="anchor" id="gab092d166ac47246cc0780e40258dba16"></a><!-- doxytag: member="bslma_allocator.h::operator new" ref="gab092d166ac47246cc0780e40258dba16" args="(std::size_t size, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Note that this operator is intentionally not defined. </p>

</div>
</div>
<a class="anchor" id="ga758c1b7ef9fe890629dd8ef16fc21f8a"></a><!-- doxytag: member="bslma_allocator.h::operator delete" ref="ga758c1b7ef9fe890629dd8ef16fc21f8a" args="(void *address, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Note that this operator is intentionally not defined. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
