<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Namespace bslx::OutStreamFunctions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslx.html">bslx</a>      </li>
      <li><a class="el" href="namespacebslx_1_1OutStreamFunctions.html">OutStreamFunctions</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bslx::OutStreamFunctions Namespace Reference</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslx_1_1OutStreamFunctions_1_1IsEnumType.html">IsEnumType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslx_1_1OutStreamFunctions_1_1IsNotEnumType.html">IsNotEnumType</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a69661290cca788f6a2fccf48b13d077e">bdexStreamOutImp</a> (STREAM &amp;stream, const TYPE &amp;value, int version, const <a class="el" href="structbslx_1_1OutStreamFunctions_1_1IsEnumType.html">IsEnumType</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a1d4ef2886f8ab6519b2736b3ecc66a36">bdexStreamOutImp</a> (STREAM &amp;stream, const TYPE &amp;value, int version, const <a class="el" href="structbslx_1_1OutStreamFunctions_1_1IsNotEnumType.html">IsNotEnumType</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a74f1889766c3cbd4427fd8370e4e734a">bdexStreamOut</a> (STREAM &amp;stream, const TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a1ee11d9f72984e984503fd99ade2d035">bdexStreamOut</a> (STREAM &amp;stream, const TYPE &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a8636578ba5434aa4fbfeb2e9c955347b">bdexStreamOut</a> (STREAM &amp;stream, const bool &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#aa9abeed159112d0a67fda10e63b59906">bdexStreamOut</a> (STREAM &amp;stream, const char &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#afdfe9769d318f53c7890af39f74b7b74">bdexStreamOut</a> (STREAM &amp;stream, const signed char &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a342b113855fba5a1a2b3d7a55c7a724d">bdexStreamOut</a> (STREAM &amp;stream, const unsigned char &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a121e808903e06af5cd40421fa23b91e8">bdexStreamOut</a> (STREAM &amp;stream, const short &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a17c12d643562aab4cf268e3ac9f4d195">bdexStreamOut</a> (STREAM &amp;stream, const unsigned short &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a113662bf2645831aad06b013cbfb434b">bdexStreamOut</a> (STREAM &amp;stream, const int &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#ae7bcd14aeeb501c1983f1f0692b205d5">bdexStreamOut</a> (STREAM &amp;stream, const unsigned int &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a9fa19cc88c9f9e458ae61673e232ee4c">bdexStreamOut</a> (STREAM &amp;stream, const long &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a26699c4cbac8963680662ff0d2a8e8af">bdexStreamOut</a> (STREAM &amp;stream, const unsigned long &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a7099b220918b72c8f7beef5ce5947512">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a2106712fc579b65021072968d5477643">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a3207d3ddf3bd1a0d73153107d96dcb67">bdexStreamOut</a> (STREAM &amp;stream, const float &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#afcd6e1cbd18b1f5c6f430eaf69e27add">bdexStreamOut</a> (STREAM &amp;stream, const double &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#ab45ffd7c381a371496dd941a4c5c7498">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;value, int version=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a8ddd8f3e3d59ca517d7997c834d9288b">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a99a9488de3f79e3cc28992a5e0e1d940">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; signed char, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a0c5aba9c9a83f79af7c4ac42231695ba">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned char, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a16091d101eac7e192d974a17bd65ec57">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; short, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a3a03b6c8c3467d407bb22956a73ca116">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a407f3d6e39178bc9adbf0ce25cfac53b">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; int, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a451233d1e57825dadb0d785782c665b5">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned int, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#ac7507e039c39f1b863fe3daedb20dc78">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#aafb4d07555f1e6dd8c14b18cd87f284f">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#ab91b7083a42ab31737c77309df9b65c0">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; float, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a67fe37b6fc0f3836798e62003cd78d5a">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; double, ALLOC &gt; &amp;value, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class TYPE , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#a32a75bb9d44834d66481579aa4212f39">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE, ALLOC &gt; &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM , class TYPE , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebslx_1_1OutStreamFunctions.html#adfe560a0e15598fc01b8b044ff30773e">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE, ALLOC &gt; &amp;value, int version)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a69661290cca788f6a2fccf48b13d077e"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOutImp" ref="a69661290cca788f6a2fccf48b13d077e" args="(STREAM &amp;stream, const TYPE &amp;value, int version, const IsEnumType &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOutImp </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IsEnumType &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>value</code> to the specified output <code>stream</code> as a 32-bit <code>int</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. Note that this function is called only for enumeration types and that if <code>value</code> is outside the range of an <code>int32_t</code> the externalization will be lossy. Also note that this function is for internal use only. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a1d4ef2886f8ab6519b2736b3ecc66a36"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOutImp" ref="a1d4ef2886f8ab6519b2736b3ecc66a36" args="(STREAM &amp;stream, const TYPE &amp;value, int version, const IsNotEnumType &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOutImp </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IsNotEnumType &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>value</code>, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code>TYPE</code>, <code>stream</code> is invalidated, but otherwise unmodified. Note that <code>version</code> is not written to <code>stream</code>. Also note that this function is for internal use only. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a74f1889766c3cbd4427fd8370e4e734a"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a74f1889766c3cbd4427fd8370e4e734a" args="(STREAM &amp;stream, const TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If needed, first write the computed version information to the <code>stream</code> and if this version is not supported by <code>TYPE</code>, <code>stream</code> is invalidated. Note that the version is only needed when the (template parameter) <code>TYPE</code> is a <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code> or a user-defined type. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a1ee11d9f72984e984503fd99ade2d035"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a1ee11d9f72984e984503fd99ade2d035" args="(STREAM &amp;stream, const TYPE &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>value</code>, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code>TYPE</code>, <code>stream</code> is invalidated, but otherwise unmodified. Note that <code>version</code> is not written to <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a8636578ba5434aa4fbfeb2e9c955347b"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a8636578ba5434aa4fbfeb2e9c955347b" args="(STREAM &amp;stream, const bool &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>bool</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="aa9abeed159112d0a67fda10e63b59906"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="aa9abeed159112d0a67fda10e63b59906" args="(STREAM &amp;stream, const char &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>char</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="afdfe9769d318f53c7890af39f74b7b74"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="afdfe9769d318f53c7890af39f74b7b74" args="(STREAM &amp;stream, const signed char &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const signed char &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>signed char</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a342b113855fba5a1a2b3d7a55c7a724d"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a342b113855fba5a1a2b3d7a55c7a724d" args="(STREAM &amp;stream, const unsigned char &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>unsigned char</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a121e808903e06af5cd40421fa23b91e8"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a121e808903e06af5cd40421fa23b91e8" args="(STREAM &amp;stream, const short &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>short</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a17c12d643562aab4cf268e3ac9f4d195"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a17c12d643562aab4cf268e3ac9f4d195" args="(STREAM &amp;stream, const unsigned short &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>unsigned short</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a113662bf2645831aad06b013cbfb434b"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a113662bf2645831aad06b013cbfb434b" args="(STREAM &amp;stream, const int &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>int</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="ae7bcd14aeeb501c1983f1f0692b205d5"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="ae7bcd14aeeb501c1983f1f0692b205d5" args="(STREAM &amp;stream, const unsigned int &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>unsigned int</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a9fa19cc88c9f9e458ae61673e232ee4c"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a9fa19cc88c9f9e458ae61673e232ee4c" args="(STREAM &amp;stream, const long &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>long</code> <code>value</code> to the specified output <code>stream</code> as a 32-bit <code>int</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. Note that for platforms where <code>long</code> is not equivalent to <code>int32_t</code>, this operation may be lossy. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a26699c4cbac8963680662ff0d2a8e8af"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a26699c4cbac8963680662ff0d2a8e8af" args="(STREAM &amp;stream, const unsigned long &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>unsigned long</code> <code>value</code> to the specified output <code>stream</code> as a 32-bit <code>unsigned int</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. Note that for platforms where <code>unsigned long</code> is not equivalent to <code>uint32_t</code>, this operation may be lossy. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a7099b220918b72c8f7beef5ce5947512"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a7099b220918b72c8f7beef5ce5947512" args="(STREAM &amp;stream, const bsls::Types::Int64 &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a></code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a2106712fc579b65021072968d5477643"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a2106712fc579b65021072968d5477643" args="(STREAM &amp;stream, const bsls::Types::Uint64 &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a></code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a3207d3ddf3bd1a0d73153107d96dcb67"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a3207d3ddf3bd1a0d73153107d96dcb67" args="(STREAM &amp;stream, const float &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>float</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="afcd6e1cbd18b1f5c6f430eaf69e27add"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="afcd6e1cbd18b1f5c6f430eaf69e27add" args="(STREAM &amp;stream, const double &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>double</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="ab45ffd7c381a371496dd941a4c5c7498"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="ab45ffd7c381a371496dd941a4c5c7498" args="(STREAM &amp;stream, const bsl::string &amp;value, int version=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>bsl::string</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The optionally specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a8ddd8f3e3d59ca517d7997c834d9288b"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a8ddd8f3e3d59ca517d7997c834d9288b" args="(STREAM &amp;stream, const bsl::vector&lt; char, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;char, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a99a9488de3f79e3cc28992a5e0e1d940"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a99a9488de3f79e3cc28992a5e0e1d940" args="(STREAM &amp;stream, const bsl::vector&lt; signed char, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; signed char, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;signed char, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a0c5aba9c9a83f79af7c4ac42231695ba"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a0c5aba9c9a83f79af7c4ac42231695ba" args="(STREAM &amp;stream, const bsl::vector&lt; unsigned char, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned char, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;unsigned char, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a16091d101eac7e192d974a17bd65ec57"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a16091d101eac7e192d974a17bd65ec57" args="(STREAM &amp;stream, const bsl::vector&lt; short, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; short, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;short, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a3a03b6c8c3467d407bb22956a73ca116"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a3a03b6c8c3467d407bb22956a73ca116" args="(STREAM &amp;stream, const bsl::vector&lt; unsigned short, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned short, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;unsigned short, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a407f3d6e39178bc9adbf0ce25cfac53b"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a407f3d6e39178bc9adbf0ce25cfac53b" args="(STREAM &amp;stream, const bsl::vector&lt; int, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; int, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;int, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a451233d1e57825dadb0d785782c665b5"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a451233d1e57825dadb0d785782c665b5" args="(STREAM &amp;stream, const bsl::vector&lt; unsigned int, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned int, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;unsigned int, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="ac7507e039c39f1b863fe3daedb20dc78"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="ac7507e039c39f1b863fe3daedb20dc78" args="(STREAM &amp;stream, const bsl::vector&lt; bsls::Types::Int64, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="aafb4d07555f1e6dd8c14b18cd87f284f"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="aafb4d07555f1e6dd8c14b18cd87f284f" args="(STREAM &amp;stream, const bsl::vector&lt; bsls::Types::Uint64, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="ab91b7083a42ab31737c77309df9b65c0"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="ab91b7083a42ab31737c77309df9b65c0" args="(STREAM &amp;stream, const bsl::vector&lt; float, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; float, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;float, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a67fe37b6fc0f3836798e62003cd78d5a"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a67fe37b6fc0f3836798e62003cd78d5a" args="(STREAM &amp;stream, const bsl::vector&lt; double, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; double, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;double, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. The specified <code>version</code> is ignored. If <code>stream</code> is initially invalid, this operation has no effect. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a32a75bb9d44834d66481579aa4212f39"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="a32a75bb9d44834d66481579aa4212f39" args="(STREAM &amp;stream, const bsl::vector&lt; TYPE, ALLOC &gt; &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class TYPE , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;TYPE, ALLOC&gt;</code> <code>value</code> to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If needed, first write the computed version information to the <code>stream</code> and if this version is not supported by <code>TYPE</code> and the vector is not empty, <code>stream</code> is invalidated. Note that the version is only needed when the (template parameter) <code>TYPE</code> is a <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code> or a user-defined type. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="adfe560a0e15598fc01b8b044ff30773e"></a><!-- doxytag: member="bslx::OutStreamFunctions::bdexStreamOut" ref="adfe560a0e15598fc01b8b044ff30773e" args="(STREAM &amp;stream, const bsl::vector&lt; TYPE, ALLOC &gt; &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM , class TYPE , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bslx::OutStreamFunctions::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE, ALLOC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;TYPE, ALLOC&gt;</code> <code>value</code>, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code>TYPE</code> and the vector is not empty, <code>stream</code> is invalidated, but otherwise unmodified. Note that the specified <code>TYPE</code> might not require a <code>version</code> to be serialized and that <code>version</code> is not written to <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:46 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
