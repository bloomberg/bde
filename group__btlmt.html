<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlmt Package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Components</a>  </div>
  <div class="headertitle">
<h1>Package btlmt<br/>
<small>
[<a class="el" href="group__btl.html">Package Group btl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide framework for multi-threaded TCP/IP transport.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Components</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__asyncchannel.html">Component btlmt_asyncchannel</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a protocol for asynchronous IO operations. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__channelpool.html">Component btlmt_channelpool</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide thread-enabled stream-based IPv4 communication. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__channelpoolchannel.html">Component btlmt_channelpoolchannel</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a concrete implementation of <code><a class="el" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a></code> </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__channelpoolconfiguration.html">Component btlmt_channelpoolconfiguration</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a class for configuring channel pools. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__channelstatus.html">Component btlmt_channelstatus</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Enumerate the set of channel status codes. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__channeltype.html">Component btlmt_channeltype</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Enumerate the set of channel types. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__session.html">Component btlmt_session</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a <em>pure</em> protocol class for a session. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__sessionfactory.html">Component btlmt_sessionfactory</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a <em>pure</em> protocol class for creating sessions. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__sessionpool.html">Component btlmt_sessionpool</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide thread-enabled session-based IPv4 communication. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__btlmt__tcptimereventmanager.html">Component btlmt_tcptimereventmanager</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a thread-enabled multiplexor of socket events and timers. </p>
</td></tr>
</p>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">MNEMONIC: Basic Transport Environment Multi-Threaded (btlmt)</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Hierarchical Synopsis</a> </li>
<li>
<a href="#3.2">Component Synopsis</a> </li>
<li>
<a href="#3.3">Framework Overview</a> <ul>
<li>
<a href="#3.3.1">Channel Queue Pool</a> </li>
<li>
<a href="#3.3.2">Message</a> </li>
<li>
<a href="#3.3.3">Channel Pool</a> </li>
<li>
<a href="#3.3.4">Channel Pool Configuration</a> </li>
<li>
<a href="#3.3.5">TCP Timer Event Manager</a> </li>
<li>
<a href="#3.3.6">Queue</a> </li>
<li>
<a href="#3.3.7"><code>btlmt_ChannelQueuePool::ParseMessagesCallback</code></a> </li>
<li>
<a href="#3.3.8">Resource Management</a> </li>
</ul>
</li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Implementing an Echo Server</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide framework for multi-threaded TCP/IP transport. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="mnemonic~3A_basic_transport_environment_multi-threaded_(btlmt)"></a> <a class="anchor" id="mnemonic"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>MNEMONIC: Basic Transport Environment Multi-Threaded (btlmt): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>btlmt</code> package offers a multi-threaded framework for TCP/IPv4 interprocess communication (IPC). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hierarchical_synopsis"></a> <a class="anchor" id="description.hierarchical_synopsis"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Hierarchical Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>btlmt</code> package currently has 10 components having 4 levels of physical dependency. The list below shows the hierarchical ordering of the components. The order of components within each level is not architecturally significant, just alphabetical. <br/>
<br/>
<div class="fragment"><pre class="fragment">  4. btlmt_sessionpool

  3. btlmt_channelpoolchannel

  2. btlmt_channelpool

  1. btlmt_asyncchannel
     btlmt_channelpoolconfiguration
     btlmt_channelstatus
     btlmt_channeltype
     btlmt_session
     btlmt_sessionfactory
     btlmt_tcptimereventmanager
</pre></div><br/>
<br/>
 <code>btlmt</code> also depends directly upon the <code>btlso</code> and <code>btlsos</code> packages within <code>btl</code>, and on the <code>bce</code> ("concurrency" or multi-threaded) and <code>bde</code> package groups. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_synopsis"></a> <a class="anchor" id="description.component_synopsis"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Component Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_asyncchannel</code>: <br/>
 Provide a protocol for asynchronous IO operations</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_channelpool</code>: <br/>
 Provide thread-enabled stream-based IPv4 communication.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_channelpoolchannel</code>: <br/>
 Provide a concrete implementation of <code><a class="el" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a></code></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_channelpoolconfiguration</code>: <br/>
 Provide a class for configuring channel pools.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_channelstatus</code>: <br/>
 Enumerate the set of channel status codes.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_channeltype</code>: <br/>
 Enumerate the set of channel types.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_session</code>: <br/>
 Provide a <em>pure</em> protocol class for a session</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_sessionfactory</code>: <br/>
 Provide a <em>pure</em> protocol class for creating sessions</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_sessionpool</code>: <br/>
 Provide thread-enabled session-based IPv4 communication</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>btlmt_tcptimereventmanager</code>: <br/>
 Provide a thread-enabled multiplexor of socket events and timers.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="framework_overview"></a> <a class="anchor" id="description.framework_overview"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Framework Overview: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>btlmt</code> package can be viewed as a framework for building efficient multi-threaded applications requiring interprocess communication (IPC). <code>btlmt</code> provides the structure whereby multiple threads within a process can engage in IPC via a flexible message format. The following overview presents the main <code>btlmt</code> components and types, plus other types used by the framework. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="channel_queue_pool"></a> <a class="anchor" id="framework_overview.channel_queue_pool"></a> <a class="anchor" id="description.framework_overview.channel_queue_pool"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Channel Queue Pool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The heart of the <code>btlmt</code> framework, sitting at the top of the component physical hierarchy, is <code>btlmt_channelqueuepool</code>, which provides the <code>btlmt_ChannelQueuePool</code> object (CQP). The CQP provides queue-based message transport over IPv4-addressed byte-stream communication channels. (See the <a href="group__btlsc.html" class="el"><code>btlsc</code></a> package documentation for an overview of the <code>btl</code> stream-based channel protocols, and see the <a href="group__btlso.html" class="el"><code>btlso</code></a> package documentation for details about concrete TCP/IPv4 channels.) The CQP creates channels automatically as needed when the appropriate events occur, and destroys those channels based on user requests. For example, a new channel is allocated automatically when an incoming connection is accepted, or when a user explicitly requests a connection to a server. The CQP creates both client (connector) and server (acceptor) channels as appropriate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="message"></a> <a class="anchor" id="framework_overview.message"></a> <a class="anchor" id="description.framework_overview.message"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Message: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are four physical-hierarchy peer components at the bottom (Level 1) of the hierarchy, but we will focus on <code>btlmt_message</code> as being the most central of these to understand, if only because the user will most likely be interacting with messages most directly and frequently in the course of writing useful code. <code>btlmt_message</code> provides several distinct message objects and one generic message container. The distinct message objects are: <br/>
<br/>
<div class="fragment"><pre class="fragment">    Class               Message Contents
    ---------------     ----------------
    btlmt_DataMsg       raw data as read from a socket
    btlmt_ChannelMsg    a <span class="keyword">new</span> state <span class="keywordflow">for</span> a channel
    btlmt_PoolMsg       an <span class="keyword">event</span> from the pool
    btlmt_TimerMsg      notification that a timer is expired
    btlmt_UserMsg       user-generated message
    btlmt_Message       container <span class="keywordflow">for</span> a <span class="keyword">generic</span> message
</pre></div><br/>
<br/>
 Details regarding messages can be found in both the <code>btlmt_message</code> and <code>btlmt_channelqueuepool</code> component documentation. One point worth mentioning here is that the CPQ messages are protocol-neutral, meaning that CPQ supports message delivery using any application-level (i.e., OSI levels 5-7) protocol. This in turn means that the data in any one Data message may contain a non-integral number of (logical) messages. The CQP therefore provides a <code>ParseMessagesCallback</code> type, which should be used to distinguish message boundaries. The Usage Example below illustrates this message-boundary issue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="channel_pool"></a> <a class="anchor" id="framework_overview.channel_pool"></a> <a class="anchor" id="description.framework_overview.channel_pool"></a> <a class="anchor" id="3.3.3"></a> </dd></dl>
<dl class="user"><dt><b>Channel Pool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>btlmt_ChannelPool</code> object (CP) itself is provided by the <code>btlmt_channelpool</code> component. The CP is in its own right a useful manager of TCP/IPv4 channels, but in the context of the most straightforward use of the <code>btlmt</code> framework, the CP can be regarded as an implementation detail of the CQP. (See the <a href="group__btlmt__channelpool.html" class="el"><code>btlmt_channelpool</code></a> component documentation for information about the CP.) The main mode of interaction with the CP is through the <code>btlmt_ChannelPoolConfiguration</code> object (CPC), which will be discussed next. Even so, the CPC can be regarded as setting the configuration of a logical CP within the CQP, so the CP itself can be largely ignored by new users of <code>btlmt</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="channel_pool_configuration"></a> <a class="anchor" id="framework_overview.channel_pool_configuration"></a> <a class="anchor" id="description.framework_overview.channel_pool_configuration"></a> <a class="anchor" id="3.3.4"></a> </dd></dl>
<dl class="user"><dt><b>Channel Pool Configuration: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The CPC provides a "constrained attributes" class for the CP, which is to say that althought the CPC is in some sense a <code>struct</code> of parameters characterizing a CP, these parameters are not all independent of one another. The CPC manages the constraints among the attributes. In particular, the CPC "set" methods for constrained values will fail if their arguments are not consistent with the constraints (see the two tables below). Also, the CPC constructor does not take any constrained arguments, but rather sets those values to valid defaults unconditionally. This behavior avoids "silent
 failures", since the constructor cannot explicitly return a status value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The attributes contained by a CPC and the attribute constraints are given, respectively, in two tables below. The attributes are as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  TYPE                 NAME                DESCRIPTION
  ------------------   --------------      --------------------------------
   <span class="keywordtype">int</span>                 maxConnections      maximum number of connections
                                           that can be managed by a channel
                                           pool
   <span class="keywordtype">int</span>                 maxThreads          maximum number of threads managed
                                           by a channel pool
   <span class="keywordtype">int</span>                 maxWriteCache       maximum number of bytesto be
                                           cached in the outgoingbuffer <span class="keywordflow">for</span>
                                           a managed channel
   <span class="keywordtype">double</span>              readTimeout         timeout <span class="keywordflow">for</span> <span class="stringliteral">&quot;read&quot;</span> operations
   <span class="keywordtype">double</span>              metricsInterval     periodic-update interval <span class="keywordflow">for</span>
                                           metrics
   <span class="keywordtype">int</span>                 minMessageSizeOut   output message strategy hint
   <span class="keywordtype">int</span>                 typMessageSizeOut   output message strategy hint
   <span class="keywordtype">int</span>                 maxMessageSizeOut   output message strategy hint
   <span class="keywordtype">int</span>                 minMessageSizeIn    input  message strategy hint
   <span class="keywordtype">int</span>                 typMessageSizeIn    input  message strategy hint
   <span class="keywordtype">int</span>                 maxMessageSizeIn    input  message strategy hint
   <span class="keywordtype">int</span>                 workloadThreshold   threshold of the workload <span class="keywordflow">for</span> an
                                           <span class="keyword">event</span> manager after which
                                           a <span class="keyword">new</span> thread will be created,
                                           or an alert generated <span class="keywordflow">if</span>
                                           no <span class="keyword">new</span> thread can be created.
</pre></div><br/>
<br/>
 The constraints are as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">   NAME                 CONSTRAINT
  +--------------------+---------------------------------------------+
  | maxConnections     | 0 &lt;= maxConnections                         |
  +--------------------+---------------------------------------------+
  | maxThreads         | 0 &lt;= maxThreads                             |
  +--------------------+---------------------------------------------+
  | maxWriteCache      | 0 &lt;= maxWriteCache                          |
  +--------------------+---------------------------------------------+
  | readTimeout        | 0 &lt;= readTimeout                            |
  +--------------------+---------------------------------------------+
  | metricsInterval    | 0 &lt;= metricsInterval                        |
  +--------------------+---------------------------------------------+
  | minMessageSizeOut  | 0 &lt;= minMessageSizeOut &lt;= typMessageSizeOut |
  | typMessageSizeOut  |   &lt;= maxMessageSizeOut                      |
  | maxMessageSizeOut  |                                             |
  +--------------------+---------------------------------------------+
  | minMessageSizeIn   | 0 &lt;= minMessageSizeIn &lt;= typMessageSizeIn   |
  | typMessageSizeIn   |   &lt;= maxMessageSizeIn                       |
  | maxMessageSizeIn   |                                             |
  +--------------------+---------------------------------------------+
  | workloadThreshold  | 0 &lt;= workloadThreshold                      |
  +--------------------+---------------------------------------------+
</pre></div><br/>
<br/>
 Note that the CPC ensures that the channel pool configuration is legal, but it does not insure that the configuration is wise. The user must still analyze the requirements of the software being developed, and must have a basic understansing of thread and socket performance issues in order to choose an optimal configuration. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="tcp_timer_event_manager"></a> <a class="anchor" id="framework_overview.tcp_timer_event_manager"></a> <a class="anchor" id="description.framework_overview.tcp_timer_event_manager"></a> <a class="anchor" id="3.3.5"></a> </dd></dl>
<dl class="user"><dt><b>TCP Timer Event Manager: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>btlmt_tcptimereventmanager</code> component provides the <code>btlmt_TcpTimerEventManager</code> object (TTEM), which is a multi-threaded implememtation of the <code>btlso_TimerEventManager</code> protocol. (See the <a href="group__btlso__timereventmanager.html" class="el"><code>btlso_timereventmanager</code></a> component documentation for protocol details.) The TTEM is a thread-enabled multiplexor of socket events and timers. Within the context of the <code>btlmt</code> framework, it is safe to regard the TTEM as an implementation detail. Information regarding TTEM performance can be found in the <code>btlmt_tcptimereventmanager</code> component documentation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="queue"></a> <a class="anchor" id="framework_overview.queue"></a> <a class="anchor" id="description.framework_overview.queue"></a> <a class="anchor" id="3.3.6"></a> </dd></dl>
<dl class="user"><dt><b>Queue: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>btlmt</code> uses the <code>bcec_Queue&lt;btlmt_Message&gt;</code> queue. Two instances of this queue, one for the input queue and one for the output queue, are used as constructor arguments to the CQP. These queues are held but not owned by the CQP, so the user is responsible for managing queue lifetimes. Moreover, the user acceses each queue directly through the <code>bcec_Queue</code> interface. See the <a href="group__bcec__queue.html" class="el"><code>bcec_queue</code></a> component documentation for details regarding this template queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="btlmt_channelqueuepool~3A~3Aparsemessagescallback"></a> <a class="anchor" id="framework_overview.btlmt_channelqueuepool~3A~3Aparsemessagescallback"></a> <a class="anchor" id="description.framework_overview.btlmt_channelqueuepool~3A~3Aparsemessagescallback"></a> <a class="anchor" id="btlmt_channelqueuepool"></a> <a class="anchor" id="framework_overview.btlmt_channelqueuepool"></a> <a class="anchor" id="description.framework_overview.btlmt_channelqueuepool"></a> <a class="anchor" id="3.3.7"></a> </dd></dl>
<dl class="user"><dt><b>btlmt_ChannelQueuePool::ParseMessagesCallback: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>ParseMessageCallback</code> is a <code>typedef</code> within the CPQ class. The type that is aliased is: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bcef_Vfunc4&lt;int *, int *, const char *, int&gt;
</pre></div><br/>
<br/>
 which is used, as its name implies, to parse the body of data messages. As mentioned above, an instance of a data message as popped from a queue may have a non-integral number of logical messages. It is the purpose of the message parsing callback to identify message boundaries and to communicate the number of bytes needed (if any) to complete the last (possibly partial) logical message within the buffer of the data message. See <a href="group__btlmt.html#usage" class="el">Usage</a> for an illustration. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="resource_management"></a> <a class="anchor" id="framework_overview.resource_management"></a> <a class="anchor" id="description.framework_overview.resource_management"></a> <a class="anchor" id="3.3.8"></a> </dd></dl>
<dl class="user"><dt><b>Resource Management: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>btlmt_pooldeallocator</code> component is deprecated, and will be replaced by a component that will perform the required functionality without the need of user intervention. This aspect of resource management can thus safely be ignored by most users of <code>btlmt</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this package. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_an_echo_server"></a> <a class="anchor" id="usage.example_1~3A_implementing_an_echo_server"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_an_echo_server"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing an Echo Server: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We illustrate the basic usage of the <code>btlmt</code> framework by considering an echo server. Let's start with a brief overview. The heart of the server is the <code>while(1)</code> loop, which endlessly pops a message off of the <code>incoming</code> queue and processes it according to a <code>switch</code> statement that dispatches the message depending on the message type. Data messages are pushed back onto the <code>outgoing</code> queue ("echoed"). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Other steps common to <code>btlmt</code> applications are configuring the channel pool (i.e., constructing and setting the attributes of a CPC object), constructing the two queues, and constructing and populating the <code>ParseMessageCallback</code> function. These four objects are then provided as constructor arguments to the CQP. With the CQP constructed, one can enter the infinite loop described above. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The full, uninterrupted example file appears at the end of this section. The following snippets drawn from that example highlight the key features as described above. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the file-'static' function <code>parseMessages</code>, which will be loaded into the <code>ParseMessagesCallback</code> functor within <code>main</code>. As prescribed by the callback <code>typedef</code>, the functor will require four arguments of types as indicated above. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As a side detail -- not central to this specific example -- note that the function loaded into the <code>ParseMessagesCallback</code> functor could well take more than four arguments (up to nine, at present), if such a function were convenient for our purposes. In that case, the initial four arguments would match the types of the four required arguments, and the values set for any trailing arguments of the underlying function would be supplied to the <code>bcefu</code> <code>make</code> method. See the <a href="group__bcef.html" class="el"><code>bcef</code></a> and <a href="group__bcefu.html" class="el"><code>bcefu</code></a> package documentation for more details on binding functions with extra arguments to functors taking fewer arguments. For our purposes, no additional arguments are needed, and so the <code>parseMessages</code> function is defined as follows. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// btlmt_usage.m.cpp                                                -*-C++-*-</span>

  <span class="keyword">using namespace </span>BloombergLP;

  <span class="keyword">static</span>
  <span class="keyword">inline</span> <span class="keywordtype">void</span> parseMessages(<span class="keywordtype">int</span>        *numBytesConsumed,
                            <span class="keywordtype">int</span>        *numBytesNeeded,
                            <span class="keyword">const</span> <span class="keywordtype">char</span> *data,
                            <span class="keywordtype">int</span>         length)
      <span class="comment">// Parse the specified message &#39;data&#39; of the specified &#39;length&#39;.  Load</span>
      <span class="comment">// into the specified &#39;numBytesConsumed&#39; the number of bytes of &#39;data&#39;</span>
      <span class="comment">// that comprise the number of *complete* (logical) messages within</span>
      <span class="comment">// &#39;data&#39; and load into the specified &#39;numBytesNeeded&#39; the number of</span>
      <span class="comment">// bytes needed to complete a trailing partial logical message within</span>
      <span class="comment">// &#39;data&#39; or load 0 if the last logical message in &#39;data&#39; was complete.</span>
</pre></div><br/>
<br/>
 Basically, the CQP will use this callback function to identify an integral number of complete messages. Since the CQP is "protocol neutral", the lower-level transport channel has no way of knowing what the significance of any given number of received bytes might be. This user-supplied function allows the CQP to identify message boundaries. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, the message header consists of a network-byte-order <code>int</code> value denoting the total number of bytes (including the header) that comprise the message. The following function body fulfills the documented contract for the example case of a single <code>int</code> header. <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <span class="keywordtype">int</span> originalLength    = length;
      <span class="keywordtype">int</span> processedMessages = 0;

      <span class="keywordflow">while</span>(length &gt; <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) {
          <span class="keywordtype">int</span> msgLength = ntohl(*(<span class="keywordtype">int</span>*)data);  <span class="comment">// decode message length</span>
</pre></div><br/>
<br/>
 Note here that, as a guard against malicious users, the <code>msgLength</code> should be limited in the protocol. <br/>
<br/>
<div class="fragment"><pre class="fragment">          <span class="keywordflow">if</span> (length &lt; msgLength) {
             *numBytesConsumed = originalLength - length;
             *numBytesNeeded   = msgLength - length;
             <span class="keywordflow">return</span>;
          }
          length -= msgLength;
          data   += msgLength;
          ++processedMessages;  <span class="comment">// count not used in this implementation</span>
     }

     *numBytesConsumed = originalLength - length;
     *numBytesNeeded   = <span class="keyword">sizeof</span>(int) - length;
  }
</pre></div><br/>
<br/>
 We are now ready to write <code>main</code> as outlined above. In this simple example, we hard-code several needed parameters in an 'enum. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      <span class="keyword">enum</span> {
          SERVER_ID       = 0xAB,    <span class="comment">// a cookie</span>
          PORT_NUMBER     = 4564,
          MAX_CONNECTIONS = 10000
      };
</pre></div><br/>
<br/>
 Next, we construct a default <code>btlmt_ChannelPoolConfiguration</code> object <code>config</code> and use its <code>set</code> methods so that <code>config</code> contains the CP configuration that we want. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// Configure the channel</span>
      btlmt_ChannelPoolConfiguration config;
      config.setMaxThreads(4);
      config.setMaxConnections(MAX_CONNECTIONS);
      config.setReadTimeout(5.0);                   <span class="comment">// in seconds</span>
      config.setWorkloadThreshold(75);              <span class="comment">// 75% busy</span>
      config.setMetricsInterval(10.0);              <span class="comment">// seconds</span>
      config.setMaxWriteCache(1&lt;&lt;10);               <span class="comment">// 1Mb</span>
      config.setIncomingMessageSizes(4, 100, 1024);
      config.setOutgoingMessageSizes(4, 100, 1024);
</pre></div><br/>
<br/>
 We can write the value of <code>config</code> to <code>stdout</code> to confirm that we have correctly initialized the CPC. <br/>
<br/>
<div class="fragment"><pre class="fragment">      bsl::cout &lt;&lt; config;
</pre></div><br/>
<br/>
 Next, we instantiate a default functor <code>cb</code> and use <code>bcefu_Vfunc4::makeF</code> to load into <code>cb</code> the <code>parseMessages</code> function defined above. <br/>
<br/>
<div class="fragment"><pre class="fragment">      btlmt_ChannelQueuePool::ParseMessagesCallback cb;
      bcefu_Vfunc4::makeF(&amp;cb, parseMessages);
</pre></div><br/>
<br/>
 We now have our CPC and callback functor ready. The last objects that we need are the <code>incoming</code> and <code>outgoing</code> queues. We construct the queues, and use them along with the callback and the CPC to construct a CQP object <code>qp</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      bcec_Queue&lt;btlmt_Message&gt; incoming, outgoing;
      btlmt_ChannelQueuePool qp(&amp;incoming, &amp;outgoing, cb, config);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>With all of our objects and input data ready, we start the echo server by calling the CQP's <code>start</code> method. Note that we call the method from within an <code>assert</code> call, since we might as well abort if the CQP cannot start. <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(0 == qp.start());   <span class="comment">// fails if no system resources.</span>
</pre></div><br/>
<br/>
 The final startup step, before entering into the body of the server loop, is to call the <code>listen</code> method. In this case, we call <code>listen</code> within an <code>if</code> statement and return an error message and call the <code>stop</code> method before returning. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (0 != qp.listen(PORT_NUMBER, MAX_CONNECTIONS, SERVER_ID)) {
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Can&#39;t open server port.&quot;</span> &lt;&lt; bsl::endl;
          qp.stop();
          <span class="keywordflow">return</span> -1;
      }
</pre></div><br/>
<br/>
 The server is now live and running. We enter an infinite <code>while</code> loop wherein we call the <code>popFront</code> method of the <code>incoming</code> queue to fetch the next available message <code>msg</code> and <code>switch</code> on <code>msg.type()</code>. <code>msg</code> might be a status message generated by the CQP, or it might be a data message, in which case the datat is processed as desired and pushed back onto the <code>outgoing</code> queue. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">while</span>(1) {
          btlmt_Message msg = incoming.popFront();
          <span class="keywordflow">switch</span>(msg.type()) {
            <span class="keywordflow">case</span> btlmt_Message::CHANNEL_STATE: {
              <span class="keyword">const</span> btlmt_ChannelMsg&amp; data = msg.channelMsg();
              bsl::cout &lt;&lt; data &lt;&lt; bsl::endl;
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> btlmt_Message::POOL_STATE: {
              bsl::cout &lt;&lt; msg.poolMsg() &lt;&lt; bsl::endl;
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> btlmt_Message::TIMER: {
              bsl::cout &lt;&lt; msg.timerMsg().timerId() &lt;&lt; bsl::endl;
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> btlmt_Message::DATA: {
              <span class="comment">// PROCESS DATA MESSAGE HERE</span>
              outgoing.pushBack(msg);
            } <span class="keywordflow">break</span>;
         }
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 This completes the echo server example. The entire example file is repeated below without interruption for ease of reading. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// btlmt_usage.m.cpp                                                -*-C++-*-</span>

<span class="preprocessor">  #include &lt;bcec_queue.h&gt;</span>
<span class="preprocessor">  #include &lt;bcef_vfunc4.h&gt;</span>

<span class="preprocessor">  #include &lt;bcefu_vfunc4.h&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="btlmt__channelpoolconfiguration_8h.html" title="Provide a class for configuring channel pools.">btlmt_channelpoolconfiguration.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;btlmt_channelqueuepool.h&gt;</span>
<span class="preprocessor">  #include &lt;btlmt_message.h&gt;</span>

<span class="preprocessor">  #include &lt;bsl_cassert.h&gt;</span>
<span class="preprocessor">  #include &lt;bsl_iostream.h&gt;</span>

  <span class="keyword">using namespace </span>BloombergLP;

  <span class="keyword">static</span>
  <span class="keyword">inline</span> <span class="keywordtype">void</span> parseMessages(<span class="keywordtype">int</span>        *numBytesConsumed,
                            <span class="keywordtype">int</span>        *numBytesNeeded,
                            <span class="keyword">const</span> <span class="keywordtype">char</span> *data,
                            <span class="keywordtype">int</span>         length)
      <span class="comment">// Parse the specified message &#39;data&#39; of the specified &#39;length&#39;.  Load</span>
      <span class="comment">// into the specified &#39;numBytesConsumed&#39; the number of bytes of &#39;data&#39;</span>
      <span class="comment">// that comprise the number of *complete* (logical) messages within</span>
      <span class="comment">// &#39;data&#39; and load into the specified &#39;numBytesNeeded&#39; the number of</span>
      <span class="comment">// bytes needed to complete a trailing partial logical message within</span>
      <span class="comment">// &#39;data&#39; or load 0 if the last logical message in &#39;data&#39; was complete.</span>
  {
      assert(numBytesConsumed);
      assert(data);
      assert(0 &lt; length);

      <span class="keywordtype">int</span> originalLength    = length;
      <span class="keywordtype">int</span> processedMessages = 0;

      <span class="keywordflow">while</span>(length &gt; <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) {
          <span class="keywordtype">int</span> msgLength = ntohl(*(<span class="keywordtype">int</span>*)data);  <span class="comment">// decode message length</span>

          assert(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) &lt; msgLength);

          <span class="keywordflow">if</span> (length &lt; msgLength) {
             *numBytesConsumed = originalLength - length;
             *numBytesNeeded   = msgLength - length;
             <span class="keywordflow">return</span>;
          }
          length -= msgLength;
          data   += msgLength;
          ++processedMessages;  <span class="comment">// count not used in this implementation</span>
     }

     *numBytesConsumed = originalLength - length;
     *numBytesNeeded   = <span class="keyword">sizeof</span>(int) - length;
  }

  <span class="keywordtype">int</span> main()
  {
      <span class="keyword">enum</span> {
          SERVER_ID       = 0xAB,    <span class="comment">// a cookie</span>
          PORT_NUMBER     = 4564,
          MAX_CONNECTIONS = 10000
      };

      <span class="comment">// Configure the channel</span>
      btlmt_ChannelPoolConfiguration config;
      config.setMaxThreads(4);
      config.setMaxConnections(MAX_CONNECTIONS);
      config.setReadTimeout(5.0);                   <span class="comment">// in seconds</span>
      config.setWorkloadThreshold(75);              <span class="comment">// 75% busy</span>
      config.setMetricsInterval(10.0);              <span class="comment">// seconds</span>
      config.setMaxWriteCache(1&lt;&lt;10);               <span class="comment">// 1Mb</span>
      config.setIncomingMessageSizes(4, 100, 1024);
      config.setOutgoingMessageSizes(4, 100, 1024);

      bsl::cout &lt;&lt; config;

      btlmt_ChannelQueuePool::ParseMessagesCallback cb;
      bcefu_Vfunc4::makeF(&amp;cb, parseMessages);

      bcec_Queue&lt;btlmt_Message&gt; incoming, outgoing;
      btlmt_ChannelQueuePool qp(&amp;incoming, &amp;outgoing, cb, config);

      assert(0 == qp.start());   <span class="comment">// fails if no system resources.</span>
      <span class="keywordflow">if</span> (0 != qp.listen(PORT_NUMBER, MAX_CONNECTIONS, SERVER_ID)) {
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Can&#39;t open server port.&quot;</span> &lt;&lt; bsl::endl;
          qp.stop();
          <span class="keywordflow">return</span> -1;
      }

      <span class="keywordflow">while</span>(1) {
          btlmt_Message msg = incoming.popFront();
          <span class="keywordflow">switch</span>(msg.type()) {
            <span class="keywordflow">case</span> btlmt_Message::CHANNEL_STATE: {
              <span class="keyword">const</span> btlmt_ChannelMsg&amp; data = msg.channelMsg();
              bsl::cout &lt;&lt; data &lt;&lt; bsl::endl;
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> btlmt_Message::POOL_STATE: {
              bsl::cout &lt;&lt; msg.poolMsg() &lt;&lt; bsl::endl;
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> btlmt_Message::TIMER: {
              bsl::cout &lt;&lt; msg.timerMsg().timerId() &lt;&lt; bsl::endl;
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> btlmt_Message::DATA: {
              <span class="comment">// PROCESS DATA MESSAGE HERE</span>
              outgoing.pushBack(msg);
            } <span class="keywordflow">break</span>;
         }
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
