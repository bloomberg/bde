<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_bufferimputil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_bufferimputil<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide pure procedures for allocating memory from a buffer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Raw versus Non-Raw</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide pure procedures for allocating memory from a buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlma_1_1BufferImpUtil.html">bdlma::BufferImpUtil</a> </td><td>pure procedures for allocating memory from a buffer  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__buffermanager.html" title="Provide a memory manager that manages an external buffer.">Component bdlma_buffermanager</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a <code>struct</code>, <code><a class="el" href="structbdlma_1_1BufferImpUtil.html">bdlma::BufferImpUtil</a></code>, that implements procedures for allocating memory from a buffer using an indicated memory alignment strategy. Each of the procedures take a buffer, the size of the buffer, a cursor pointing to the free memory within the buffer, and the allocation size. Two of the procedures, <code>allocateFromBuffer</code> and <code>allocateFromBufferRaw</code>, take an additional argument that specifies the memory alignment strategy to apply. The other six procedures apply a specific memory alignment strategy as indicated by their names (e.g., <code>allocateNaturallyAlignedFromBuffer</code> and <code>allocateMaximallyAlignedFromBufferRaw</code>). In all cases, a pointer to the allocated memory is returned, and the cursor passed in is updated to point to the portion of the buffer that contains the next available free memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, suppose we initially have a 2-byte aligned buffer having a size of 5 bytes, and a cursor pointing to the first byte: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          0     1     2     3     4
                        _____ _____ _____ _____ _____
  buffer (size = 5):   |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |          <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> - allocated
                       `=====^=====^=====^=====^=====<span class="stringliteral">&#39;          F - free</span>
<span class="stringliteral">                          ^                                     W - wasted</span>
<span class="stringliteral">                          |</span>
<span class="stringliteral">                        cursor</span>
</pre></div><br/>
<br/>
 Using natural alignment, suppose 1 byte is allocated from the buffer using <code>allocateFromBuffer</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  BufferImpUtil::allocateFromBuffer(&amp;cursor, buffer, bufferSize, 1
                                    bsls::AlignmentStrategy::BSLS_NATURAL);
</pre></div><br/>
<br/>
 The cursor will be advanced as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          0     1     2     3     4
                        _____ _____ _____ _____ _____
  buffer (size = 5):   |  <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |          <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> - allocated
                       `=====^=====^=====^=====^=====<span class="stringliteral">&#39;          F - free</span>
<span class="stringliteral">                                ^                               W - wasted</span>
<span class="stringliteral">                                |</span>
<span class="stringliteral">                              cursor</span>
</pre></div><br/>
<br/>
 Suppose <code>allocateFromBuffer</code> is then used to allocate 2 bytes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  BufferImpUtil::allocateFromBuffer(&amp;cursor, buffer, bufferSize, 2,
                                    bsls::AlignmentStrategy::BSLS_NATURAL);
</pre></div><br/>
<br/>
 The cursor will be advanced as follows (after taking into consideration the alignment strategy used): <br/>
<br/>
<div class="fragment"><pre class="fragment">                          0     1     2     3     4
                        _____ _____ _____ _____ _____
  buffer (size = 5):   |  <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a>  |  W  |  <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a>  |  <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  |          <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> - allocated
                       `=====^=====^=====^=====^=====<span class="stringliteral">&#39;          F - free</span>
<span class="stringliteral">                                                  ^             W - wasted</span>
<span class="stringliteral">                                                  |</span>
<span class="stringliteral">                                                cursor</span>
</pre></div><br/>
<br/>
 The byte at (only) position 1 is skipped because of the natural alignment strategy (otherwise, more bytes would have been skipped if maximum alignment was used). See <code>bsls_alignment</code> for more details about memory alignment. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="raw_versus_non-raw"></a> <a class="anchor" id="description.raw_versus_non-raw"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Raw versus Non-Raw: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The raw and non-raw versions differ in behavior only when the requested memory size is larger than the memory available within the provided buffer (after taking memory alignment into consideration). The raw versions result in undefined behavior, while the non-raw versions return 0. Note that the safety of the non-raw versions comes at the extra cost of a conditional statement. For example, clients of the non-raw versions must check the return value to ensure successful allocation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is typically used by a class that manages a memory buffer. First, suppose we have a class that maintains a linked list of memory blocks, details of which are elided: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>BlockList {
      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 We can then create our memory manager using <code>BlockList</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_SequentialPool {
      <span class="comment">// This class allocates memory from an internal pool of memory buffers</span>
      <span class="comment">// using natural alignment.  All allocated memory is managed internally</span>
      <span class="comment">// by the pool and released when the pool is destroyed.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span>      *d_buffer_p;    <span class="comment">// pointer to current buffer</span>
      <span class="keywordtype">int</span>        d_bufferSize;  <span class="comment">// size (in bytes) of the current buffer</span>
      <span class="keywordtype">int</span>        d_cursor;      <span class="comment">// byte offset to unused memory in buffer</span>
      BlockList  d_blockList;   <span class="comment">// used to replenish memory</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> replenishBuffer(<span class="keywordtype">int</span> size);
          <span class="comment">// Replenish the current buffer with memory that satisfies an</span>
          <span class="comment">// allocation request having at least the specified &#39;size&#39; (in</span>
          <span class="comment">// bytes).</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_SequentialPool(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a memory pool that dispenses heterogeneous blocks of</span>
          <span class="comment">// memory (of varying, user-specified sizes).  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      ~my_SequentialPool();
          <span class="comment">// Destroy this memory pool and release all associated memory.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> *allocate(<span class="keywordtype">int</span> size);
          <span class="comment">// Return the address of a contiguous block of naturally-aligned</span>
          <span class="comment">// memory of the specified &#39;size&#39; (in bytes).  The behavior is</span>
          <span class="comment">// undefined unless &#39;0 &lt; size&#39;.</span>
  };
</pre></div><br/>
<br/>
 The implementations of the constructor and destructor are elided since <code>allocate</code> alone is sufficient to illustrate the use of <code><a class="el" href="structbdlma_1_1BufferImpUtil.html">bdlma::BufferImpUtil</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> *my_SequentialPool::allocate(<span class="keywordtype">int</span> size)
  {
      assert(0 &lt; size);

      <span class="keywordtype">void</span> *address = <a class="code" href="structbdlma_1_1BufferImpUtil.html#a4e9ce6e2bb63e996bd819a19a0c372c7">bdlma::BufferImpUtil::allocateFromBuffer</a>(
                                              &amp;d_cursor,
                                              d_buffer_p,
                                              d_bufferSize,
                                              size,
                                              <a class="code" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1ea21a8cce492020ee6035db3660094e91c">bsls::Alignment::BSLS_NATURAL</a>);
</pre></div><br/>
<br/>
 Note that if there is insufficient space in <code>d_buffer_p</code>, <code>allocateFromBuffer</code> returns 0: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (address) {
          <span class="keywordflow">return</span> address;                                           <span class="comment">// RETURN</span>
      }

      replenishBuffer(size);

      <span class="keywordflow">return</span> <a class="code" href="structbdlma_1_1BufferImpUtil.html#abb47ae3abb3d9cc55e31703b38e5281b">bdlma::BufferImpUtil::allocateFromBufferRaw</a>(
                                              &amp;d_cursor,
                                              d_buffer_p,
                                              size,
                                              <a class="code" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1ea21a8cce492020ee6035db3660094e91c">bsls::Alignment::BSLS_NATURAL</a>);
  }
</pre></div><br/>
<br/>
 Note that the <em>raw</em> version is used because the contract of <code>replenishBuffer</code> guarantees that the buffer will have sufficient space to satisfy the allocation request of the specified <code>size</code>. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:44 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
