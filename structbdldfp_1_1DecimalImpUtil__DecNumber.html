<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct bdldfp::DecimalImpUtil_DecNumber</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdldfp.html">bdldfp</a>      </li>
      <li><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html">bdldfp::DecimalImpUtil_DecNumber</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdldfp::DecimalImpUtil_DecNumber Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdldfp::DecimalImpUtil_DecNumber" -->
<p><code>#include &lt;<a class="el" href="bdldfp__decimalimputil__decnumber_8h_source.html">bdldfp_decimalimputil_decnumber.h</a>&gt;</code></p>

<p><a href="structbdldfp_1_1DecimalImpUtil__DecNumber-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef decSingle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef decDouble&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef decQuad&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static decContext *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a773d4f96d023636956ab9c0837d911ea">getDecNumberContext</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a35402c8e2acb0125f7a01a85bce924c1">int32ToDecimal32</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#aafe00bc2fa9c7d88aa97acbcf885276b">uint32ToDecimal32</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a60207be3b38fb511d33aa60eb0ba7b23">int64ToDecimal32</a> (long long int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a371bd588b2ca21af3551ff68cb2b61f6">uint64ToDecimal32</a> (unsigned long long int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a61e928159ccd4e32f127ad628b8651dc">int32ToDecimal64</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afced4637089d2d35d6dbf6f38eda4090">uint32ToDecimal64</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a0088fceed2b4e6f3e5214a0f70f1deaf">int64ToDecimal64</a> (long long int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a79fbdf8e9ca1bf60454300a5e3b6ae83">uint64ToDecimal64</a> (unsigned long long int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a798ff9e349b903c9199343cae04c884c">int32ToDecimal128</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a36da0e7fd109abcecc1fd7563f82e8ce">uint32ToDecimal128</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a5d621758247c7f2e36d18db759df35de">int64ToDecimal128</a> (long long int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a572bb786852445e7c78742b1983da07a">uint64ToDecimal128</a> (unsigned long long int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a715cb466162c473d7bd0429daba67f97">add</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a7b57dbdf93d65afd34061c95768f310b">add</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a17229d56f385063ac163fec5129a0beb">subtract</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a4cea8e60b0aa49ee5868744fc43663be">subtract</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a7413ab1498b511ef0fb152daddfb0521">multiply</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1ce9e1280444bdd5f29734ed1484317a">multiply</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a93a075cf263ccf5417511b1a288efbeb">divide</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a0803b8c23a4c608217a1e19a47c8a6b0">divide</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a2c610637c0aae5a17823d27260552129">negate</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afbfad96dd3042a5e36d82cc55038ec49">negate</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a4060efe6bfabcf8ea0d4840c4f0cc26a">negate</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74447b1c0a328e046f592df0a0ff0b77">less</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a4ee72b197e296fe2c2792abbb72f470e">less</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a02fa0250bcafe1a83a5b67aa1dd1cf93">less</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a8291ba3dd9bf9c21c5aba58bf954b1f7">greater</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#abce18464e520f9ddd628d96e77a685b2">greater</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#ab8b0775a5fe2b7db713b3b9408fdb829">greater</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#ac55e2e76e3e3e0c345104f923645dfcd">lessEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#ab981e7b2ad900e3b8385ffd71bfbe8d4">lessEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a67e172a3bcc28309e7aad972a6cdb2ed">lessEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a0f5da8f8b5e73ec35a9be213c126e9fc">greaterEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a9c7eb355086309e3aa35b0ca17cc4e0c">greaterEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a59666c5e4b189c9244b69898c2575d8a">greaterEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#ae54527be738cf8a1d6246c4724e577f8">equal</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a41192f34592b504c5ebb7216f8a73a4f">equal</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afd1924de110bc41fee47a288d4834a76">equal</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a4690daaba7b155afb52d30f7cd73cbd8">notEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a3bcd46df7b0c5d653bb773f1f51a0bdc">notEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a8e81e6779e4193738d08b29146dbe185">notEqual</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> lhs, <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#ac92485456790dae77b7ffb2162d13d34">convertToDecimal32</a> (const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> &amp;input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a678164f3a578b69eaa838fb1cea1f030">convertToDecimal64</a> (const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> &amp;input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a27ae034417b2369e4ccdf01823125196">convertToDecimal64</a> (const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> &amp;input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a5965ae0a7eb3ede062114f7f30fe4095">convertToDecimal128</a> (const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> &amp;input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#ac1347f6d170a52256c0ae00e8ce8dcbc">convertToDecimal128</a> (const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> &amp;input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a23ed2485765f3878c44134e69b2940dc">binaryToDecimal32</a> (float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a069e938ed3255bc1a26471e9217996c8">binaryToDecimal32</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#aeafd56e7e0fa92b382f3fe15b23bd69a">binaryToDecimal64</a> (float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#aa31d90dca70993ce0075c9c11d823d67">binaryToDecimal64</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a21e5a10ce572633757bf0697de4a1a91">binaryToDecimal128</a> (float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a0b9eb2dea358f7b8b08134cb1c472dc8">binaryToDecimal128</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a677132490524bf9f84e69ebe9f002763">makeDecimalRaw32</a> (int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a23c75a23b42ffcc0b3ead1ec8d134bdc">makeDecimalRaw64</a> (unsigned long long int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#ad365965a1bbf1ebde6d5806faac5a0db">makeDecimalRaw64</a> (long long int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a7c5e600b7e840f0c8cc65cdbca1a70b0">makeDecimalRaw64</a> (unsigned int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a3f0818fc67fe56484afa5c38ea07163d">makeDecimalRaw64</a> (int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#ae9eb69314bad000e49ccb8f713f16a58">makeDecimalRaw128</a> (unsigned long long int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1f8771c54c7821421256834864452c26">makeDecimalRaw128</a> (long long int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#aa40d6bea0f39cc239dc0ec3115ac2ae8">makeDecimalRaw128</a> (unsigned int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afa4c73c87c97975364837b2a943d4cb9">makeDecimalRaw128</a> (int significand, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a327f098b41c1320d92b64243bcaf3260">scaleB</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> value, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a8ceee1bf240d5192fdd0c50b413f4f22">scaleB</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> value, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#aa70786fd14dfc2699f5539fea49aaec2">scaleB</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> value, int exponent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a99fdfdf0e0c45764116f802df449d6e3">parse32</a> (const char *string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a04411c684b43f36b40c0d57ef5c03382">parse64</a> (const char *string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a7f22865aa76c9ba513ecf6a9fdca3ae9">parse128</a> (const char *string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#abb5b13d94e73baaec16d6093bd7b6afb">format</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> value, char *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a530db81181b9e1055605541707c7f5e5">format</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> value, char *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a62e7aa7efaf5c9f793a7bbc7bc875859">format</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> value, char *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a9ff4bed00699b4954643deb9300f19b2">convertFromDPD</a> (<a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html#a931cf6c097bd92c23f50a233f4fcc9f1">DenselyPackedDecimalImpUtil::StorageType32</a> dpd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a985576a86cc83239db58259071c90da9">convertFromDPD</a> (<a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html#a1e9b63aea47d96548a2ceb7d93cba029">DenselyPackedDecimalImpUtil::StorageType64</a> dpd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a008d224278af40b464a2598b7cc105de">convertFromDPD</a> (<a class="el" href="classbdldfp_1_1Uint128.html">DenselyPackedDecimalImpUtil::StorageType128</a> dpd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <br class="typebreak"/>
<a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html#a931cf6c097bd92c23f50a233f4fcc9f1">DenselyPackedDecimalImpUtil::StorageType32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#aa5535a916fffd5549993114eb3340877">convertToDPD</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <br class="typebreak"/>
<a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html#a1e9b63aea47d96548a2ceb7d93cba029">DenselyPackedDecimalImpUtil::StorageType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a101b9a0dfc831e03d2ac08d5706d08dd">convertToDPD</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <br class="typebreak"/>
<a class="el" href="classbdldfp_1_1Uint128.html">DenselyPackedDecimalImpUtil::StorageType128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a583cf08d6b0cb3befd1ec7c5c95f5cdb">convertToDPD</a> (<a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> value)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for implementation functions that work in terms of the underlying C-style decimal floating point implementation, decNumber. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a74ea22bbeacb696c317d3d46b78edd5c"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::ValueType32" ref="a74ea22bbeacb696c317d3d46b78edd5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef decSingle <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">bdldfp::DecimalImpUtil_DecNumber::ValueType32</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a9c73123eb90cab7ed61b9a1d5b12ee"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::ValueType64" ref="a1a9c73123eb90cab7ed61b9a1d5b12ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef decDouble <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">bdldfp::DecimalImpUtil_DecNumber::ValueType64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afc4c48295b768063cdb1886954b60713"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::ValueType128" ref="afc4c48295b768063cdb1886954b60713" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef decQuad <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">bdldfp::DecimalImpUtil_DecNumber::ValueType128</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a773d4f96d023636956ab9c0837d911ea"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::getDecNumberContext" ref="a773d4f96d023636956ab9c0837d911ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static decContext* bdldfp::DecimalImpUtil_DecNumber::getDecNumberContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer providing modifiable access to the floating point environment of the <code>decNumber</code> library. This function does not get exposed through <code><a class="el" href="classbdldfp_1_1DecimalImpUtil.html">bdldfp::DecimalImpUtil</a></code>. </p>

</div>
</div>
<a class="anchor" id="a35402c8e2acb0125f7a01a85bce924c1"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::int32ToDecimal32" ref="a35402c8e2acb0125f7a01a85bce924c1" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::int32ToDecimal32 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aafe00bc2fa9c7d88aa97acbcf885276b"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::uint32ToDecimal32" ref="aafe00bc2fa9c7d88aa97acbcf885276b" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::uint32ToDecimal32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a60207be3b38fb511d33aa60eb0ba7b23"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::int64ToDecimal32" ref="a60207be3b38fb511d33aa60eb0ba7b23" args="(long long int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::int64ToDecimal32 </td>
          <td>(</td>
          <td class="paramtype">long long int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a371bd588b2ca21af3551ff68cb2b61f6"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::uint64ToDecimal32" ref="a371bd588b2ca21af3551ff68cb2b61f6" args="(unsigned long long int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::uint64ToDecimal32 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>Decimal32</code> object having the value closest to the specified <code>value</code> following the conversion rules as defined by IEEE-754:</p>
<ul>
<li>
If <code>value</code> is zero then initialize this object to a zero with an unspecified sign and an unspecified exponent.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal32&gt;max()</code> then raise the "overflow" floating-point exception and initialize this object to infinity with the same sign as <code>other</code>.  </li>
<li>
Otherwise if <code>value</code> has a value that is not exactly representable using <code>std::numeric_limits&lt;Decimal32&gt;max_digit</code> decimal digits then raise the "inexact" floating-point exception and initialize this object to the value of <code>other</code> rounded according to the rounding direction.  </li>
<li>
Otherwise initialize this object to the value of the <code>value</code>.  </li>
</ul>
<p>The exponent 0 (quantum 1e-6) is preferred during conversion unless it would cause unnecessary loss of precision. </p>

</div>
</div>
<a class="anchor" id="a61e928159ccd4e32f127ad628b8651dc"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::int32ToDecimal64" ref="a61e928159ccd4e32f127ad628b8651dc" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::int32ToDecimal64 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afced4637089d2d35d6dbf6f38eda4090"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::uint32ToDecimal64" ref="afced4637089d2d35d6dbf6f38eda4090" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::uint32ToDecimal64 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0088fceed2b4e6f3e5214a0f70f1deaf"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::int64ToDecimal64" ref="a0088fceed2b4e6f3e5214a0f70f1deaf" args="(long long int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::int64ToDecimal64 </td>
          <td>(</td>
          <td class="paramtype">long long int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a79fbdf8e9ca1bf60454300a5e3b6ae83"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::uint64ToDecimal64" ref="a79fbdf8e9ca1bf60454300a5e3b6ae83" args="(unsigned long long int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::uint64ToDecimal64 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>Decimal64</code> object having the value closest to the specified <code>value</code> following the conversion rules as defined by IEEE-754:</p>
<ul>
<li>
If <code>value</code> is zero then initialize this object to a zero with an unspecified sign and an unspecified exponent.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and initialize this object to infinity with the same sign as <code>other</code>.  </li>
<li>
Otherwise if <code>value</code> has a value that is not exactly representable using <code>std::numeric_limits&lt;Decimal64&gt;max_digit</code> decimal digits then raise the "inexact" floating-point exception and initialize this object to the value of <code>other</code> rounded according to the rounding direction.  </li>
<li>
Otherwise initialize this object to the value of the <code>value</code>.  </li>
</ul>
<p>The exponent 0 (quantum 1e-15) is preferred during conversion unless it would cause unnecessary loss of precision. </p>

</div>
</div>
<a class="anchor" id="a798ff9e349b903c9199343cae04c884c"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::int32ToDecimal128" ref="a798ff9e349b903c9199343cae04c884c" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::int32ToDecimal128 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a36da0e7fd109abcecc1fd7563f82e8ce"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::uint32ToDecimal128" ref="a36da0e7fd109abcecc1fd7563f82e8ce" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::uint32ToDecimal128 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d621758247c7f2e36d18db759df35de"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::int64ToDecimal128" ref="a5d621758247c7f2e36d18db759df35de" args="(long long int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::int64ToDecimal128 </td>
          <td>(</td>
          <td class="paramtype">long long int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a572bb786852445e7c78742b1983da07a"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::uint64ToDecimal128" ref="a572bb786852445e7c78742b1983da07a" args="(unsigned long long int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::uint64ToDecimal128 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>Decimal128</code> object having the value closest to the specified <code>value</code> subject to the conversion rules as defined by IEEE-754:</p>
<ul>
<li>
If <code>value</code> is zero then initialize this object to a zero with an unspecified sign and an unspecified exponent.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and initialize this object to infinity with the same sign as <code>other</code>.  </li>
<li>
Otherwise if <code>value</code> has a value that is not exactly representable using <code>std::numeric_limits&lt;Decimal128&gt;max_digit</code> decimal digits then raise the "inexact" floating-point exception and initialize this object to the value of <code>value</code> rounded according to the rounding direction.  </li>
<li>
Otherwise initialize this object to <code>value</code>.  </li>
</ul>
<p>The exponent 0 (quantum 1e-33) is preferred during conversion unless it would cause unnecessary loss of precision. </p>

</div>
</div>
<a class="anchor" id="a715cb466162c473d7bd0429daba67f97"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::add" ref="a715cb466162c473d7bd0429daba67f97" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b57dbdf93d65afd34061c95768f310b"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::add" ref="a7b57dbdf93d65afd34061c95768f310b" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the value of the specified <code>rhs</code> to the value of the specified <code>lhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either of <code>lhs</code> or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are infinities of differing signs, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are infinities of the same sign then return infinity of that sign.  </li>
<li>
Otherwise if <code>rhs</code> is zero (positive or negative), return <code>lhs</code>.  </li>
<li>
Otherwise if the sum of <code>lhs</code> and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the sum of the number represented by <code>lhs</code> and the number represented by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a17229d56f385063ac163fec5129a0beb"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::subtract" ref="a17229d56f385063ac163fec5129a0beb" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4cea8e60b0aa49ee5868744fc43663be"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::subtract" ref="a4cea8e60b0aa49ee5868744fc43663be" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the value of the specified <code>rhs</code> from the value of the specified <code>lhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either <code>lhs</code> or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and the <code>rhs</code> have infinity values of the same sign, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and the <code>rhs</code> have infinity values of differing signs, then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> has a zero value (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if subtracting the value of the <code>rhs</code> object from the value of <code>lhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the result of subtracting the value of <code>rhs</code> from the value of <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a7413ab1498b511ef0fb152daddfb0521"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::multiply" ref="a7413ab1498b511ef0fb152daddfb0521" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ce9e1280444bdd5f29734ed1484317a"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::multiply" ref="a1ce9e1280444bdd5f29734ed1484317a" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the value of the specified <code>lhs</code> object by the value of the specified <code>rhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either of <code>lhs</code> or <code>rhs</code> is NaN, return a NaN.  </li>
<li>
Otherwise if one of the operands is infinity (positive or negative) and the other is zero (positive or negative), then raise the "invalid" floating-point exception raised and return a NaN.  </li>
<li>
Otherwise if both <code>lhs</code> and <code>rhs</code> are infinity (positive or negative), return infinity. The sign of the returned value will be positive if <code>lhs</code> and <code>rhs</code> have the same sign, and negative otherwise.  </li>
<li>
Otherwise, if either <code>lhs</code> or <code>rhs</code> is zero, return zero. The sign of the returned value will be positive if <code>lhs</code> and <code>rhs</code> have the same sign, and negative otherwise.  </li>
<li>
Otherwise if the product of <code>lhs</code> and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the product of <code>lhs</code> and <code>rhs</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the product of the value of <code>rhs</code> and the number represented by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a93a075cf263ccf5417511b1a288efbeb"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::divide" ref="a93a075cf263ccf5417511b1a288efbeb" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0803b8c23a4c608217a1e19a47c8a6b0"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::divide" ref="a0803b8c23a4c608217a1e19a47c8a6b0" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the value of the specified <code>lhs</code> by the value of the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>lhs</code> or <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are both infinity (positive or negative) or both zero (positive or negative), raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> has a positive zero value, raise the "overflow" floating-point exception and return infinity with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> has a negative zero value, raise the "overflow" floating-point exception and return infinity with the opposite sign as <code>lhs</code>.  </li>
<li>
Otherwise if dividing the value of <code>lhs</code> with the value of <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if dividing the value of <code>lhs</code> with the value of <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the result of dividing the value of <code>lhs</code> with the value of <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a2c610637c0aae5a17823d27260552129"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::negate" ref="a2c610637c0aae5a17823d27260552129" args="(ValueType32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::negate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afbfad96dd3042a5e36d82cc55038ec49"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::negate" ref="afbfad96dd3042a5e36d82cc55038ec49" args="(ValueType64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::negate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4060efe6bfabcf8ea0d4840c4f0cc26a"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::negate" ref="a4060efe6bfabcf8ea0d4840c4f0cc26a" args="(ValueType128 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::negate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the result of applying the unary - operator to the specified <code>value</code> as described by IEEE-754. Note that floating-point numbers have signed zero, therefore this operation is not the same as <code>0-value</code>. </p>

</div>
</div>
<a class="anchor" id="a74447b1c0a328e046f592df0a0ff0b77"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::less" ref="a74447b1c0a328e046f592df0a0ff0b77" args="(ValueType32 lhs, ValueType32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::less </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ee72b197e296fe2c2792abbb72f470e"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::less" ref="a4ee72b197e296fe2c2792abbb72f470e" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::less </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a02fa0250bcafe1a83a5b67aa1dd1cf93"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::less" ref="a02fa0250bcafe1a83a5b67aa1dd1cf93" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::less </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal64</code> object <code>lhs</code> is less than that of an object <code>rhs</code> if the <code>compareQuietLess</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less than of that of <code>rhs</code>. In other words, <code>lhs</code> is less than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> is positive, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> negative, or  </li>
<li>
<code>lhs</code> is not positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a8291ba3dd9bf9c21c5aba58bf954b1f7"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::greater" ref="a8291ba3dd9bf9c21c5aba58bf954b1f7" args="(ValueType32 lhs, ValueType32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::greater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abce18464e520f9ddd628d96e77a685b2"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::greater" ref="abce18464e520f9ddd628d96e77a685b2" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::greater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8b0775a5fe2b7db713b3b9408fdb829"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::greater" ref="ab8b0775a5fe2b7db713b3b9408fdb829" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::greater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a greater value than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal64</code> object <code>lhs</code> is greater than that of an object <code>rhs</code> if the <code>compareQuietGreater</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be greater than of that of <code>rhs</code>. In other words, <code>lhs</code> is greater than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> positive, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> negative, or  </li>
<li>
<code>lhs</code> is not negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="ac55e2e76e3e3e0c345104f923645dfcd"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::lessEqual" ref="ac55e2e76e3e3e0c345104f923645dfcd" args="(ValueType32 lhs, ValueType32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::lessEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab981e7b2ad900e3b8385ffd71bfbe8d4"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::lessEqual" ref="ab981e7b2ad900e3b8385ffd71bfbe8d4" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::lessEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a67e172a3bcc28309e7aad972a6cdb2ed"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::lessEqual" ref="a67e172a3bcc28309e7aad972a6cdb2ed" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::lessEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than or equal the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal64</code> object <code>lhs</code> is less than or equal to the value of an object <code>rhs</code> if the <code>compareQuietLessEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is less or equal than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a0f5da8f8b5e73ec35a9be213c126e9fc"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::greaterEqual" ref="a0f5da8f8b5e73ec35a9be213c126e9fc" args="(ValueType32 lhs, ValueType32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::greaterEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c7eb355086309e3aa35b0ca17cc4e0c"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::greaterEqual" ref="a9c7eb355086309e3aa35b0ca17cc4e0c" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::greaterEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a59666c5e4b189c9244b69898c2575d8a"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::greaterEqual" ref="a59666c5e4b189c9244b69898c2575d8a" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::greaterEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater than or equal to the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal64</code> object <code>lhs</code> is greater or equal to a <code>Decimal64</code> object <code>rhs</code> if the <code>compareQuietGreaterEqual</code> operation (IEEE-754 defined, non-total ordering comparison ) considers the underlying IEEE representation of <code>lhs</code> to be greater or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is greater than or equal to <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="ae54527be738cf8a1d6246c4724e577f8"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::equal" ref="ae54527be738cf8a1d6246c4724e577f8" args="(ValueType32 lhs, ValueType32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a41192f34592b504c5ebb7216f8a73a4f"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::equal" ref="a41192f34592b504c5ebb7216f8a73a4f" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afd1924de110bc41fee47a288d4834a76"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::equal" ref="afd1924de110bc41fee47a288d4834a76" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> have the same value, and <code>false</code> otherwise. Two decimal objects have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations equal. In other words, two decimal objects have the same value if:</p>
<ul>
<li>
both have a zero value (positive or negative), or  </li>
<li>
both have the same infinity value (both positive or negative), or  </li>
<li>
both have the value of a real number that are equal, even if they are represented differently (cohorts have the same value)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a4690daaba7b155afb52d30f7cd73cbd8"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::notEqual" ref="a4690daaba7b155afb52d30f7cd73cbd8" args="(ValueType32 lhs, ValueType32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::notEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3bcd46df7b0c5d653bb773f1f51a0bdc"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::notEqual" ref="a3bcd46df7b0c5d653bb773f1f51a0bdc" args="(ValueType64 lhs, ValueType64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::notEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e81e6779e4193738d08b29146dbe185"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::notEqual" ref="a8e81e6779e4193738d08b29146dbe185" args="(ValueType128 lhs, ValueType128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdldfp::DecimalImpUtil_DecNumber::notEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>false</code> if the specified <code>lhs</code> and <code>rhs</code> have the same value, and <code>true</code> otherwise. Two decimal objects have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations equal. In other words, two decimal objects have the same value if:</p>
<ul>
<li>
both have a zero value (positive or negative), or  </li>
<li>
both have the same infinity value (both positive or negative), or  </li>
<li>
both have the value of a real number that are equal, even if they are represented differently (cohorts have the same value)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="ac92485456790dae77b7ffb2162d13d34"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertToDecimal32" ref="ac92485456790dae77b7ffb2162d13d34" args="(const ValueType64 &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::convertToDecimal32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a678164f3a578b69eaa838fb1cea1f030"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertToDecimal64" ref="a678164f3a578b69eaa838fb1cea1f030" args="(const ValueType32 &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::convertToDecimal64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a27ae034417b2369e4ccdf01823125196"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertToDecimal64" ref="a27ae034417b2369e4ccdf01823125196" args="(const ValueType128 &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::convertToDecimal64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5965ae0a7eb3ede062114f7f30fe4095"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertToDecimal128" ref="a5965ae0a7eb3ede062114f7f30fe4095" args="(const ValueType32 &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::convertToDecimal128 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1347f6d170a52256c0ae00e8ce8dcbc"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertToDecimal128" ref="ac1347f6d170a52256c0ae00e8ce8dcbc" args="(const ValueType64 &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::convertToDecimal128 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert the specified <code>input</code> to the indicated result type. Note that a conversion from <code>ValueType128</code> to <code>ValueType32</code> is not provided (because such a conversion is not provided by the <code>decNumber</code> library). A conversion from 128-bit to 32-bit representations is <em>not</em> identical to the composing the conversions from 128-bit to 64-bit, and 64-bit to 32-bit representations, because rounding should only be performed once. </p>

</div>
</div>
<a class="anchor" id="a23ed2485765f3878c44134e69b2940dc"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal32" ref="a23ed2485765f3878c44134e69b2940dc" args="(float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal32 </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a069e938ed3255bc1a26471e9217996c8"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal32" ref="a069e938ed3255bc1a26471e9217996c8" args="(double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal32 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>Decimal32</code> object having the value closest to the specified <code>value</code> following the conversion rules as defined by IEEE-754:</p>
<ul>
<li>
If <code>value</code> is NaN, return a NaN.  </li>
<li>
Otherwise if <code>value</code> is infinity (positive or negative), then return an object equal to infinity with the same sign.  </li>
<li>
Otherwise if <code>value</code> is a zero value, then return an object equal to zero with the same sign.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal32&gt;max()</code> then raise the "overflow" floating-point exception and return an infinity with the same sign as <code>value</code>.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal32&gt;min()</code> then raise the "underflow" floating-point exception and return a zero with the same sign as <code>value</code>.  </li>
<li>
Otherwise if <code>value</code> needs more than <code>std::numeric_limits&lt;Decimal32&gt;max_digit</code> significant decimal digits to represent then raise the "inexact" floating-point exception and return the <code>value</code> rounded according to the rounding direction.  </li>
<li>
Otherwise return a <code>Decimal32</code> object representing <code>value</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="aeafd56e7e0fa92b382f3fe15b23bd69a"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal64" ref="aeafd56e7e0fa92b382f3fe15b23bd69a" args="(float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal64 </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa31d90dca70993ce0075c9c11d823d67"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal64" ref="aa31d90dca70993ce0075c9c11d823d67" args="(double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal64 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>Decimal64</code> object having the value closest to the specified <code>value</code> following the conversion rules as defined by IEEE-754:</p>
<ul>
<li>
If <code>value</code> is NaN, return a NaN.  </li>
<li>
Otherwise if <code>value</code> is infinity (positive or negative), then return an object equal to infinity with the same sign.  </li>
<li>
Otherwise if <code>value</code> is a zero value, then return an object equal to zero with the same sign.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return an infinity with the same sign as <code>value</code>.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return a zero with the same sign as <code>value</code>.  </li>
<li>
Otherwise if <code>value</code> needs more than <code>std::numeric_limits&lt;Decimal64&gt;max_digit</code> significant decimal digits to represent then raise the "inexact" floating-point exception and return the <code>value</code> rounded according to the rounding direction.  </li>
<li>
Otherwise return a <code>Decimal64</code> object representing <code>value</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a21e5a10ce572633757bf0697de4a1a91"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal128" ref="a21e5a10ce572633757bf0697de4a1a91" args="(float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal128 </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b9eb2dea358f7b8b08134cb1c472dc8"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal128" ref="a0b9eb2dea358f7b8b08134cb1c472dc8" args="(double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::binaryToDecimal128 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>Decimal128</code> object having the value closest to the specified <code>value</code> following the conversion rules as defined by IEEE-754:</p>
<ul>
<li>
If <code>value</code> is NaN, return a NaN.  </li>
<li>
Otherwise if <code>value</code> is infinity (positive or negative), then return an object equal to infinity with the same sign.  </li>
<li>
Otherwise if <code>value</code> is a zero value, then return an object equal to zero with the same sign.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return an infinity with the same sign as <code>value</code>.  </li>
<li>
Otherwise if <code>value</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal128&gt;min()</code> then raise the "underflow" floating-point exception and return a zero with the same sign as <code>value</code>.  </li>
<li>
Otherwise if <code>value</code> needs more than <code>std::numeric_limits&lt;Decimal128&gt;max_digit</code> significant decimal digits to represent then raise the "inexact" floating-point exception and return the <code>value</code> rounded according to the rounding direction.  </li>
<li>
Otherwise return a <code>Decimal128</code> object representing <code>value</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a677132490524bf9f84e69ebe9f002763"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw32" ref="a677132490524bf9f84e69ebe9f002763" args="(int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw32 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>ValueType32</code> object representing a decimal floating point number consisting of the specified <code>significand</code> and <code>exponent</code>, with the sign given by <code>significand</code>. The behavior is undefined unless <code>abs(significand) &lt;= 9,999,999</code> and <code>-101 &lt;= exponent &lt;= 90</code>. </p>

</div>
</div>
<a class="anchor" id="a23c75a23b42ffcc0b3ead1ec8d134bdc"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw64" ref="a23c75a23b42ffcc0b3ead1ec8d134bdc" args="(unsigned long long int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw64 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad365965a1bbf1ebde6d5806faac5a0db"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw64" ref="ad365965a1bbf1ebde6d5806faac5a0db" args="(long long int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw64 </td>
          <td>(</td>
          <td class="paramtype">long long int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c5e600b7e840f0c8cc65cdbca1a70b0"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw64" ref="a7c5e600b7e840f0c8cc65cdbca1a70b0" args="(unsigned int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw64 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f0818fc67fe56484afa5c38ea07163d"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw64" ref="a3f0818fc67fe56484afa5c38ea07163d" args="(int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw64 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>ValueType64</code> object representing a decimal floating point number consisting of the specified <code>significand</code> and <code>exponent</code>, with the sign given by <code>significand</code>. The behavior is undefined unless <code>abs(significand) &lt;= 9,999,999,999,999,999</code> and <code>-398 &lt;= exponent &lt;= 369</code>. </p>

</div>
</div>
<a class="anchor" id="ae9eb69314bad000e49ccb8f713f16a58"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw128" ref="ae9eb69314bad000e49ccb8f713f16a58" args="(unsigned long long int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw128 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f8771c54c7821421256834864452c26"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw128" ref="a1f8771c54c7821421256834864452c26" args="(long long int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw128 </td>
          <td>(</td>
          <td class="paramtype">long long int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa40d6bea0f39cc239dc0ec3115ac2ae8"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw128" ref="aa40d6bea0f39cc239dc0ec3115ac2ae8" args="(unsigned int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw128 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afa4c73c87c97975364837b2a943d4cb9"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw128" ref="afa4c73c87c97975364837b2a943d4cb9" args="(int significand, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::makeDecimalRaw128 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>significand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>ValueType128</code> object representing a decimal floating point number consisting of the specified <code>significand</code> and <code>exponent</code>, with the sign given by <code>significand</code>. The behavior is undefined unless <code>-6176 &lt;= exponent &lt;= 6111</code>. </p>

</div>
</div>
<a class="anchor" id="a327f098b41c1320d92b64243bcaf3260"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::scaleB" ref="a327f098b41c1320d92b64243bcaf3260" args="(ValueType32 value, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::scaleB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ceee1bf240d5192fdd0c50b413f4f22"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::scaleB" ref="a8ceee1bf240d5192fdd0c50b413f4f22" args="(ValueType64 value, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::scaleB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa70786fd14dfc2699f5539fea49aaec2"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::scaleB" ref="aa70786fd14dfc2699f5539fea49aaec2" args="(ValueType128 value, int exponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::scaleB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exponent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the result of multiplying the specified <code>value</code> by ten raised to the specified <code>exponent</code>. The quantum of <code>value</code> is scaled according to IEEE 754's <code>scaleB</code> operations. The result is unspecified if <code>value</code> is NaN or infinity. The behavior is undefined unless <code>-1999999997 &lt;= y &lt;= 99999999</code>. </p>

</div>
</div>
<a class="anchor" id="a99fdfdf0e0c45764116f802df449d6e3"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::parse32" ref="a99fdfdf0e0c45764116f802df449d6e3" args="(const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::parse32 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the specified <code>string</code> as a 32 bit decimal floating- point value and return the result. The parsing is as specified for the <code>strtod32</code> function in section 9.6 of the ISO/EIC TR 24732 C Decimal Floating-Point Technical Report, except that it is unspecified whether the NaNs returned are quiet or signaling. The behavior is undefined unless <code>input</code> represents a valid 32 bit decimal floating-point number in scientific or fixed notation, and no unrelated characters precede (not even whitespace) that textual representation and a terminating nul character immediately follows it. Note that this method does not guarantee the behavior of ISO/EIC TR 24732 C when parsing NaN because the AIX compiler intrinsics return a signaling NaN. </p>

</div>
</div>
<a class="anchor" id="a04411c684b43f36b40c0d57ef5c03382"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::parse64" ref="a04411c684b43f36b40c0d57ef5c03382" args="(const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::parse64 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the specified <code>string</code> string as a 64 bit decimal floating- point value and return the result. The parsing is as specified for the <code>strtod64</code> function in section 9.6 of the ISO/EIC TR 24732 C Decimal Floating-Point Technical Report, except that it is unspecified whether the NaNs returned are quiet or signaling. The behavior is undefined unless <code>input</code> represents a valid 64 bit decimal floating-point number in scientific or fixed notation, and no unrelated characters precede (not even whitespace) that textual representation and a terminating nul character immediately follows it. Note that this method does not guarantee the behavior of ISO/EIC TR 24732 C when parsing NaN because the AIX compiler intrinsics return a signaling NaN. </p>

</div>
</div>
<a class="anchor" id="a7f22865aa76c9ba513ecf6a9fdca3ae9"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::parse128" ref="a7f22865aa76c9ba513ecf6a9fdca3ae9" args="(const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::parse128 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the specified <code>string</code> string as a 128 bit decimal floating- point value and return the result. The parsing is as specified for the <code>strtod128</code> function in section 9.6 of the ISO/EIC TR 24732 C Decimal Floating-Point Technical Report, except that it is unspecified whether the NaNs returned are quiet or signaling. The behavior is undefined unless <code>input</code> represents a valid 128 bit decimal floating-point number in scientific or fixed notation, and no unrelated characters precede (not even whitespace) that textual representation and a terminating nul character immediately follows it. Note that this method does not guarantee the behavior of ISO/EIC TR 24732 C when parsing NaN because the AIX compiler intrinsics return a signaling NaN. </p>

</div>
</div>
<a class="anchor" id="abb5b13d94e73baaec16d6093bd7b6afb"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::format" ref="abb5b13d94e73baaec16d6093bd7b6afb" args="(ValueType32 value, char *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdldfp::DecimalImpUtil_DecNumber::format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a530db81181b9e1055605541707c7f5e5"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::format" ref="a530db81181b9e1055605541707c7f5e5" args="(ValueType64 value, char *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdldfp::DecimalImpUtil_DecNumber::format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a62e7aa7efaf5c9f793a7bbc7bc875859"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::format" ref="a62e7aa7efaf5c9f793a7bbc7bc875859" args="(ValueType128 value, char *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdldfp::DecimalImpUtil_DecNumber::format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce a string representation of the specified decimal <code>value</code>, in the specified <code>buffer</code>, which is at least <code>BDLDFP_DECIMALPLATFORM_SNPRINTF_BUFFER_SIZE</code> bytes in length. The string will be suitable for use with the <code>strtod128</code> function in section 9.6 of the ISO/EIC TR 24732 C Decimal Floating-Point Technical Report, except that it is unspecified whether the NaNs returned are quiet or signaling. The behavior is undefined unless there are <code>size</code> bytes available in <code>buffer</code>. </p>

</div>
</div>
<a class="anchor" id="a9ff4bed00699b4954643deb9300f19b2"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertFromDPD" ref="a9ff4bed00699b4954643deb9300f19b2" args="(DenselyPackedDecimalImpUtil::StorageType32 dpd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a> bdldfp::DecimalImpUtil_DecNumber::convertFromDPD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html#a931cf6c097bd92c23f50a233f4fcc9f1">DenselyPackedDecimalImpUtil::StorageType32</a>&nbsp;</td>
          <td class="paramname"> <em>dpd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a985576a86cc83239db58259071c90da9"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertFromDPD" ref="a985576a86cc83239db58259071c90da9" args="(DenselyPackedDecimalImpUtil::StorageType64 dpd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a> bdldfp::DecimalImpUtil_DecNumber::convertFromDPD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html#a1e9b63aea47d96548a2ceb7d93cba029">DenselyPackedDecimalImpUtil::StorageType64</a>&nbsp;</td>
          <td class="paramname"> <em>dpd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a008d224278af40b464a2598b7cc105de"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertFromDPD" ref="a008d224278af40b464a2598b7cc105de" args="(DenselyPackedDecimalImpUtil::StorageType128 dpd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a> bdldfp::DecimalImpUtil_DecNumber::convertFromDPD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Uint128.html">DenselyPackedDecimalImpUtil::StorageType128</a>&nbsp;</td>
          <td class="paramname"> <em>dpd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>ValueTypeXX</code> representing the specified <code>dpd</code>, which is currently in Densely Packed Decimal (DPD) format. This format is compatible with the IBM compiler's native type, and the decNumber library. </p>

</div>
</div>
<a class="anchor" id="aa5535a916fffd5549993114eb3340877"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertToDPD" ref="aa5535a916fffd5549993114eb3340877" args="(ValueType32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html#a931cf6c097bd92c23f50a233f4fcc9f1">DenselyPackedDecimalImpUtil::StorageType32</a> bdldfp::DecimalImpUtil_DecNumber::convertToDPD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a74ea22bbeacb696c317d3d46b78edd5c">ValueType32</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a101b9a0dfc831e03d2ac08d5706d08dd"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertToDPD" ref="a101b9a0dfc831e03d2ac08d5706d08dd" args="(ValueType64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html#a1e9b63aea47d96548a2ceb7d93cba029">DenselyPackedDecimalImpUtil::StorageType64</a> bdldfp::DecimalImpUtil_DecNumber::convertToDPD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#a1a9c73123eb90cab7ed61b9a1d5b12ee">ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a583cf08d6b0cb3befd1ec7c5c95f5cdb"></a><!-- doxytag: member="bdldfp::DecimalImpUtil_DecNumber::convertToDPD" ref="a583cf08d6b0cb3befd1ec7c5c95f5cdb" args="(ValueType128 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbdldfp_1_1Uint128.html">DenselyPackedDecimalImpUtil::StorageType128</a> bdldfp::DecimalImpUtil_DecNumber::convertToDPD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html#afc4c48295b768063cdb1886954b60713">ValueType128</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>DenselyPackedDecimalImpUtil::StorageTypeXX</code> representing the specified <code>value</code> in Densely Packed Decimal (DPD) format. This format is compatible with the IBM compiler's native type, and the decNumber library. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bdldfp__decimalimputil__decnumber_8h_source.html">bdldfp_decimalimputil_decnumber.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:41 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
