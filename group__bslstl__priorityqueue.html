<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_priorityqueue Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_priorityqueue<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide container adapter class template <code>priority_queue</code>.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html">bslstl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html">bsl</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Memory Allocation</a> </li>
<li>
<a href="#3.2">Operations</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Task Scheduler</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide container adapter class template <code>priority_queue</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslstl::priority_queue </td><td>template of highest-priority-first data structure  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__queue.html" title="Provide container adapter class template queue.">Component bslstl_queue</a>, <a class="el" href="group__bslstl__stack.html" title="Provide an STL-compliant stack class.">Component bslstl_stack</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a class template, <code><a class="el" href="classbsl_1_1priority__queue.html">bsl::priority_queue</a></code>, holding a container (of a parameterized type <code>CONTAINER</code> containing elements of another parameterized type <code>VALUE</code>), and adapting it to provide highest-priority-first priority queue data structure. The component takes a third parameterized type <code>COMPARATOR</code> for customized priorities comparison between two elements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>priority_queue</code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of held elements) and the sorted sequence of values (of held elements). If <code>priority_queue</code> is instantiated with a parameterized type <code>VALUE</code> that is not itself value-semantic, then it will not retain all of its value-semantic qualities. A <code>priority_queue</code> cannot be tested for equality, but its parameterized type <code>VALUE</code> must be able to be tested for comparing less by its parameterized type <code>COMPARATOR</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>priority_queue</code> meets the requirements of a container adapter in the C++ standard [23.6]. The <code>priority_queue</code> implemented here adheres to the C++11 standard, except that it does not have methods that take rvalue references and <code>initializer_lists</code>. Note that excluded C++11 features are those that require C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as <code>ALLOCATOR</code> template parameter in some of <code>priority_queue</code> constructors determines how the held container (of parameterized <code>CONTAINER</code>) will allocate memory. A <code>priority_queue</code> supports allocators meeting the requirements of the C++11 standard [17.6.3.5] as long as the held container does. In addition it supports scoped-allocators derived from the <code>bslma_Allocator</code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> as the <code>ALLOCATOR</code> template parameter, providing a C++11 standard-compatible adapter for a <code>bslma_Allocator</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The C++11 standard [23.6.4] declares any container type supporting operations <code>front</code>, <code>push_back</code>, and <code>pop_back</code> can be used to instantiate the parameterized type <code>CONTAINER</code>. Below is a list of public methods of <code>priority_queue</code> class that are effectively implementationed based on corresponding operations in the held container (referenced as <code>c</code>). +--------------------------------------+---------------------------+ | Public methods in <code>priority_queue</code> | Operation in <code>CONTAINER</code> | +======================================+===========================+ | void push(const value_type&amp; value); | c.push_back(value); | | void pop(); | c.pop_back(); | +--------------------------------------+---------------------------+ | bool empty() const; | c.empty(); | | size_type size() const; | c.size(); | | const_reference top() const; | c.front(); | +--------------------------------------+---------------------------+ </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Task Scheduler: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will use the <code><a class="el" href="classbsl_1_1priority__queue.html">bsl::priority_queue</a></code> class to implement a task scheduler that schedules a group of tasks based on their designated priorities. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to write a background process that runs tasks needed by foreground applications. Each task has a task id, a priority, and a function pointer that can be invoked by the background process. This background process has two threads: one thread (receiving thread) receives requests from other applications, passing required tasks to a task scheduler; the other thread (processing thread) runs the task scheduler, executing the tasks one-by-one from higher to lower priorities. To implement this functionality, we can use <code><a class="el" href="classbsl_1_1priority__queue.html">bsl::priority_queue</a></code> in the task scheduler to buffer received, but as yet unprocessed, tasks. The task scheduler adds newly received tasks into the priority queue in the receiving thread, and extracts tasks from the the priority queue for execution according to their priorities in the processing thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a <code>TaskFunction</code> type: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> void (*TaskFunction)(int, int, int);
</pre></div><br/>
<br/>
 Then, we define a <code>Task</code> class, which contains a task id, a <code>TaskFunction</code> object and an associated task priority: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Task
      <span class="comment">// This class represents a task that has an integer task id, a task</span>
      <span class="comment">// function, and an integer priority.  The smaller the numerical value</span>
      <span class="comment">// of a priority, the higher the priority.</span>
  {
    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span>          d_taskId;          <span class="comment">// task id</span>

      TaskFunction d_taskFunction_p;  <span class="comment">// task function</span>

      <span class="keywordtype">int</span>          d_priority;        <span class="comment">// priority of the task</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> Task(<span class="keywordtype">int</span> taskId, TaskFunction taskFunction, <span class="keywordtype">int</span> priority);
          <span class="comment">// Create a &#39;Task&#39; object having the specified &#39;taskId&#39;, the</span>
          <span class="comment">// specified &#39;d_taskFunction_p&#39;, and the specified &#39;priority&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> getId() <span class="keyword">const</span>;
          <span class="comment">// Return the contained task id.</span>

      <span class="keywordtype">int</span> getPriority() <span class="keyword">const</span>;
          <span class="comment">// Return the priority of the task.</span>

      TaskFunction getFunction() <span class="keyword">const</span>;
          <span class="comment">// Return the contained task function object.</span>
  };

  <span class="comment">// CREATORS</span>
  Task::Task(<span class="keywordtype">int</span> taskId, TaskFunction taskFunction, <span class="keywordtype">int</span> priority)
  : d_taskId(taskId)
  , d_taskFunction_p(taskFunction)
  , d_priority(priority)
  {
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> Task::getId()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_taskId;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> Task::getPriority()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_priority;
  }

  <span class="keyword">inline</span>
  TaskFunction Task::getFunction()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_taskFunction_p;
  }
</pre></div><br/>
<br/>
 Next, we define a functor to compare the priorities of two <code>Task</code> objects: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>TaskComparator {
      <span class="comment">// This &#39;struct&#39; defines an ordering on &#39;Task&#39; objects, allowing them</span>
      <span class="comment">// to be included in sorted data structures such as</span>
      <span class="comment">// &#39;bsl::priority_queue&#39;.</span>

      <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Task&amp; lhs, <span class="keyword">const</span> Task&amp; rhs) <span class="keyword">const</span>
          <span class="comment">// Return &#39;true&#39; if the priority of the specified &#39;lhs&#39; is</span>
          <span class="comment">// numerically less than that of the specified &#39;rhs&#39;, and &#39;false&#39;</span>
          <span class="comment">// otherwise.  Note that the smaller the value returned by the</span>
          <span class="comment">// &#39;Task::getPriority&#39; method, the higher the priority.</span>
      {
          <span class="keywordflow">return</span> lhs.getPriority() &gt; rhs.getPriority();
      }
  };
</pre></div><br/>
<br/>
 Then, we define a <code>TaskScheduler</code> class that provides methods to hold and schedule unprocessed tasks: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>TaskScheduler {
      <span class="comment">// This class holds and schedules tasks to execute.</span>
</pre></div><br/>
<br/>
 Here, we define a private data member that is an instantiation of <code><a class="el" href="classbsl_1_1priority__queue.html">bsl::priority_queue</a></code>, which uses <code>Task</code> for its <code>VALUE</code> (template parameter) type, <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;Task&gt;</code> for its <code>CONTAINER</code> (template parameter) type, and <code>TaskComparator</code> for its <code>COMPARATOR</code> (template parameter) type: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1priority__queue.html">bsl::priority_queue</a>&lt;Task,
                          <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;Task&gt;</a>,
                          TaskComparator&gt;
            d_taskPriorityQueue;  <span class="comment">// priority queue holding unprocessed tasks</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> TaskScheduler(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;TaskScheduler&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addTask(<span class="keywordtype">int</span> taskId, TaskFunction taskFunction, <span class="keywordtype">int</span> priority);
          <span class="comment">// Enqueue the specified &#39;task&#39; having the specified &#39;priority&#39;</span>
          <span class="comment">// onto this scheduler.</span>

      <span class="keywordtype">void</span> processTasks(<span class="keywordtype">int</span> verbose);
          <span class="comment">// Dequeue the task having the highest priority in this scheduler,</span>
          <span class="comment">// and call its task function by passing in the specified &#39;verbose&#39;</span>
          <span class="comment">// flag.</span>
  };
</pre></div><br/>
<br/>
 Next, we implement the <code>TaskScheduler</code> constructor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  TaskScheduler::TaskScheduler(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_taskPriorityQueue(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Notice that we pass to the contained <code>d_taskPriorityQueue</code> object the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> supplied to the <code>TaskScheduler</code> at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we implement the <code>addTask</code> method, which constructs a <code>Task</code> object and adds it into the priority queue: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> TaskScheduler::addTask(<span class="keywordtype">int</span> taskId,
                              TaskFunction taskFunction,
                              <span class="keywordtype">int</span> priority)
  {
      <span class="comment">// ... (some synchronization)</span>

      d_taskPriorityQueue.push(Task(taskId, taskFunction, priority));

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 Next, we implement the <code>processTasks</code> method, which extracts tasks from the priority queue in order of descending priorities, and executes them: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> TaskScheduler::processTasks(<span class="keywordtype">int</span> verbose)
  {
      <span class="comment">// ... (some synchronization)</span>

      <span class="keywordflow">while</span> (!d_taskPriorityQueue.empty()) {
          <span class="keyword">const</span> Task&amp; task = d_taskPriorityQueue.top();
          TaskFunction taskFunction = task.getFunction();
          <span class="keywordflow">if</span> (taskFunction) {
              taskFunction(task.getId(), task.getPriority(), verbose);
          }
          d_taskPriorityQueue.pop();
      }

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 Note that the <code>top</code> method always returns the <code>Task</code> object having the highest priority in the priority queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we define two task functions: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> taskFunction1(<span class="keywordtype">int</span> taskId, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> verbose)
  {
      <span class="keywordflow">if</span> (verbose) {
          printf(<span class="stringliteral">&quot;Executing task %d (priority = %d) in &#39;taskFunction1&#39;.\n&quot;</span>,
                 taskId,
                 priority);
      }
  }

  <span class="keywordtype">void</span> taskFunction2(<span class="keywordtype">int</span> taskId, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> verbose)
  {
      <span class="keywordflow">if</span> (verbose) {
          printf(<span class="stringliteral">&quot;Executing task %d (priority = %d) in &#39;taskFunction2&#39;.\n&quot;</span>,
                 taskId,
                 priority);
      }
  }
</pre></div><br/>
<br/>
 Next, we create a global <code>TaskScheduler</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  TaskScheduler taskScheduler;
</pre></div><br/>
<br/>
 Now, we call the <code>addTask</code> method of <code>taskScheduler</code> in the receiving thread: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// (in receiving thread)</span>
  <span class="comment">// ...</span>

  taskScheduler.addTask(1, taskFunction1, 50);

  <span class="comment">// ...</span>

  taskScheduler.addTask(2, taskFunction1, 99);

  <span class="comment">// ...</span>

  taskScheduler.addTask(3, taskFunction2, 4);

  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Finally, we call the <code>processTasks</code> method of <code>taskScheduler</code> in the processing thread: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// (in processing thread)</span>
  <span class="comment">// ...</span>

  taskScheduler.processTasks(veryVerbose);

  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
