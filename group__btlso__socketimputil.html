<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlso_socketimputil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlso_socketimputil<br/>
<small>
[<a class="el" href="group__btlso.html">Package btlso</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide platform-independent operations on sockets.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Synopsis</a> </li>
<li>
<a href="#3.2">Note About Transport Layers</a> </li>
<li>
<a href="#3.3">Signals</a> </li>
<li>
<a href="#3.4">Addresses</a> </li>
<li>
<a href="#3.5">Errors</a> <ul>
<li>
<a href="#3.5.1">Interrupted System Calls: <code>btlso::SocketHandle::e_ERROR_INTERRUPTED</code></a> </li>
<li>
<a href="#3.5.2">Would Block: <code>btlso::SocketHandle::e_ERROR_WOULDBLOCK</code></a> </li>
<li>
<a href="#3.5.3">Connection Dead: <code>btlso::SocketHandle::e_ERROR_CONNDEAD</code></a> </li>
</ul>
</li>
<li>
<a href="#3.6">Startup and Cleanup</a> </li>
<li>
<a href="#3.7">Usage</a> <ul>
<li>
<a href="#3.7.1">Example 1: Implementing a Client and Server</a> </li>
<li>
<a href="#3.7.2">Typical Server Usage</a> </li>
<li>
<a href="#3.7.3">Typical Client Usage</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide platform-independent operations on sockets. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbtlso_1_1SocketImpUtil.html">btlso::SocketImpUtil</a> </td><td>platform-independent socket function suite  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlso__socketoptutil.html" title="Provide operations to manipulate socket options.">Component btlso_socketoptutil</a>, <a class="el" href="group__btlso__ioutil.html" title="Provide operations to set socket I/O modes.">Component btlso_ioutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a suite of pure procedures to support various commonly used operations on sockets. No provisions are made within this component for setting socket options (see <code>btlso_socketoptutil</code> for option-setting functions and <code>btlso_ioutil</code> for IO modes). However, specific behavior is documented for sockets in blocking and non-blocking mode. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synopsis"></a> <a class="anchor" id="description.synopsis"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The table below lists the functions of this component, and summarizes their behavior. Where the behavior for sockets in blocking and non-blocking mode is different, the behavior is documented separately. <br/>
<br/>
<div class="fragment"><pre class="fragment">  +=========================================================================+
  | OPERATION         | BLOCKING SOCKET         | NON-BLOCKING SOCKET       |
  +=========================================================================+
  |                   |                                                     |
  | startup           |              initialize environment                 |
  |                   |                                                     |
  +-------------------------------------------------------------------------+
  |                   |                                                     |
  | open              |                  open <span class="keyword">new</span> socket                    |
  |                   |                                                     |
  +-------------------------------------------------------------------------+
  |                   |                                                     |
  | bind              |          bind socket to a local address             |
  |                   |                                                     |
  +-------------------------------------------------------------------------+
  |                   |              listen passively <span class="keywordflow">for</span>                   |
  | listen            |              connection requests;                   |
  |                   |              specify the queue <a class="code" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size</a>                 |
  +-------------------------------------------------------------------------+
  |                   | accept request from the |                           |
  | accept            | queue <span class="keywordflow">if</span> available,     | accept request from the   |
  |                   | block otherwise         |        queue              |
  +-------------------------------------------------------------------------+
  |                   | connect to the specified|  <span class="keywordflow">return</span> immediately with  |
  | connect           | peer; block until       |  an error indicating that |
  |                   | connection              |  the call would block     |
  +-------------------------------------------------------------------------+
  |                   |                                                     |
  | getLocalAddress   |    <span class="keyword">get</span> address of local socket                      |
  |                   |                                                     |
  +-------------------------------------------------------------------------+
  |                   |                                                     |
  | getPeerAddress    |    <span class="keyword">get</span> address of peer socket                       |
  |                   |                                                     |
  +-------------------------------------------------------------------------+
  |                   | read data <span class="keywordflow">if</span> available, |                           |
  | read              | block otherwise         | read data <span class="keywordflow">if</span> available    |
  |                   |                         |                           |
  +-------------------------------------------------------------------------+
  |                   | read data <span class="keywordflow">if</span> available, |                           |
  | readFrom          | block otherwise;        | read data <span class="keywordflow">if</span> available;   |
  |                   | load address and port   | load address and port     |
  +-------------------------------------------------------------------------+
  |                   | write data <span class="keywordflow">if</span> possible, |                           |
  | write             | block otherwise         | write data <span class="keywordflow">if</span> possible    |
  |                   |                         |                           |
  +-------------------------------------------------------------------------+
  |                   | write data <span class="keywordflow">if</span> possible, | write data <span class="keywordflow">if</span> possible;   |
  | writeTo           | block otherwise;        | specify address, port     |
  |                   | specify address, port   |                           |
  +-------------------------------------------------------------------------+
  |                   |                                                     |
  | shutDown          |                shut down the connection             |
  |                   |                                                     |
  +-------------------------------------------------------------------------+
  |                   |                                                     |
  | close             |                  close the socket                   |
  |                   |                                                     |
  +-------------------------------------------------------------------------+
  |                   |                                                     |
  | cleanup           |               clean up the environment              |
  |                   |                                                     |
  +-------------------------------------------------------------------------+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="note_about_transport_layers"></a> <a class="anchor" id="description.note_about_transport_layers"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Note About Transport Layers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The utilities in this component explicitly assume that the sockets will be using the Network Layer protocol, but no assumptions are made regarding the transport layer, other than that it is consistent with the address type specified as the template parameter. Individual functions may behave differently depending on the transport layer in use. It is not possible to document every eventuality (since this component supports transport layer protocols that have not yet been written), and so only the most common cases (i.e., the behavior of TCP and UDP sockets) are discussed in the function-level documentation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="signals"></a> <a class="anchor" id="description.signals"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Signals: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Signals may be generated in response to socket operations including the SIGPIPE and SIGIO signals. The processing of these signals is outside the scope of this component. The SIGPIPE signal will be generated on UNIX like systems when a write operation is performed on a socket that has no reader. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="addresses"></a> <a class="anchor" id="description.addresses"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Addresses: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Some functions are templatized by <code>ADDRESS</code>, where <code>ADDRESS</code> is a network address type. The address type implicitly specifies the native socket domain (e.g., AF_INET for IPv4 addresses). The address type for IPv4 addresses is <code><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a></code>. After a socket has been created with a particular address type, all further functions on this socket taking the <code>ADDRESS</code> parameter must use the same address type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="errors"></a> <a class="anchor" id="description.errors"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Errors: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>On success, all functions return a non-negative integer value. On errors, these functions return a error classification as a negative integer as defined <code><a class="el" href="structbtlso_1_1SocketHandle.html">btlso::SocketHandle</a></code>. Additionally, each function has an optional parameter <code>errorCode</code> which returns the platform-specific error code. Platform specific error codes map onto the error classifications. When a mapping does not exist, the classification is <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca5ca10da3e0f3ffaa2748632f0f7eed1b">btlso::SocketHandle::e_ERROR_UNCLASSIFIED</a></code>. This component does not use the <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaba6dbf82bcd9911aa5d306af0886653b">btlso::SocketHandle::e_ERROR_EOF</a></code> or the <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaed8b3922b102aeab5676b53dcad04a36" title="A system call timed out.">btlso::SocketHandle::e_ERROR_TIMEDOUT</a></code> classifications. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="interrupted_system_calls~3A_btlso~3A~3Asockethandle~3A~3Ae_error_interrupted"></a> <a class="anchor" id="errors.interrupted_system_calls~3A_btlso~3A~3Asockethandle~3A~3Ae_error_interrupted"></a> <a class="anchor" id="description.errors.interrupted_system_calls~3A_btlso~3A~3Asockethandle~3A~3Ae_error_interrupted"></a> <a class="anchor" id="interrupted_system_calls"></a> <a class="anchor" id="errors.interrupted_system_calls"></a> <a class="anchor" id="description.errors.interrupted_system_calls"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Interrupted System Calls: btlso::SocketHandle::e_ERROR_INTERRUPTED: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>On some platforms, calls can be interrupted without completing the requested operation. For read or write calls, when some data was transferred the number of bytes transferred is returned and <code>ERROR_INTERRUPTED</code> otherwise. For other calls <code>ERROR_INTERRUPTED</code> is returned. When <code>ERROR_INTERRUPTED</code> is returned, the function call did not perform its requested operation and the operation can be repeated. An exception is the <code>connect</code> operation which should not be repeated. In this case, the state of the socket is undefined and should be closed. The platform specific error code on UNIX is EINTR. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="would_block~3A_btlso~3A~3Asockethandle~3A~3Ae_error_wouldblock"></a> <a class="anchor" id="errors.would_block~3A_btlso~3A~3Asockethandle~3A~3Ae_error_wouldblock"></a> <a class="anchor" id="description.errors.would_block~3A_btlso~3A~3Asockethandle~3A~3Ae_error_wouldblock"></a> <a class="anchor" id="would_block"></a> <a class="anchor" id="errors.would_block"></a> <a class="anchor" id="description.errors.would_block"></a> <a class="anchor" id="3.5.2"></a> </dd></dl>
<dl class="user"><dt><b>Would Block: btlso::SocketHandle::e_ERROR_WOULDBLOCK: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When a socket is in non-blocking mode and the call cannot complete without blocking, the error classification <code>BTESO_ERROR_WOULDBLOCK</code> is returned. The platform specific error codes on UNIX are <code>EINPROGRESS</code>, <code>EAGAIN</code> or <code>EWOULDBLOCK</code>. On Windows, the platform specified error codes are <code>WSAEINPROGRESS</code> or <code>WSAEWOULDBLOCK</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="connection_dead~3A_btlso~3A~3Asockethandle~3A~3Ae_error_conndead"></a> <a class="anchor" id="errors.connection_dead~3A_btlso~3A~3Asockethandle~3A~3Ae_error_conndead"></a> <a class="anchor" id="description.errors.connection_dead~3A_btlso~3A~3Asockethandle~3A~3Ae_error_conndead"></a> <a class="anchor" id="connection_dead"></a> <a class="anchor" id="errors.connection_dead"></a> <a class="anchor" id="description.errors.connection_dead"></a> <a class="anchor" id="3.5.3"></a> </dd></dl>
<dl class="user"><dt><b>Connection Dead: btlso::SocketHandle::e_ERROR_CONNDEAD: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This error is returned when an attempt to setup a connection has failed or an operation was attempted on an existing connection that has been terminated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="startup_and_cleanup"></a> <a class="anchor" id="description.startup_and_cleanup"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Startup and Cleanup: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Prior to any socket operations on a process, the <code>startup</code> function must be called. Although some socket implementations (e.g., UNIX) do not require any initialization, this function must be called to ensure maximum portability. After completing all socket operations, the <code>cleanup</code> function should be called. The state of any open sockets after cleanup is undefined. The <code>startup</code> function may be invoked any number of times. However, the <code>cleanup</code> function must invoked the same number of times. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_client_and_server"></a> <a class="anchor" id="usage.example_1~3A_implementing_a_client_and_server"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_a_client_and_server"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.7.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Client and Server: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component supports inter-process communication functionality, and so possible usage within a single process would consist of half of a dialog, either the "client" or the "server". Note that the <code>shutDown</code> operation is optional. The following diagram shows a typical sequence of operations on the client and the server processes, for sockets using the TCP protocol: <br/>
<br/>
<div class="fragment"><pre class="fragment">                                                 TCP SERVER
                                               +-----------+ prepares
                                               | startup() | sockets
                                               +-----------+ environment
                                                     |
                                               +-----------+ gets a
                                               |   open()  | socket
                                               +-----------+
                                                     |
                                               +-----------+ binds <span class="keyword">this</span>
                                               |   bind()  | socket to a
                                               +-----------+ port number
                TCP CLIENT                           |
                                               +-----------+ queues up
                                               |  listen() | connection
                                               +-----------+ requests
                                                     |
                                               +-----------+ accepts
                                               |  accept() | connection
  prepares     +-----------+                   +-----------+ requests from
  sockets      | startup() |                         |       the queue
  environment  +-----------+                         |
                     |                     blocks until a connection
    gets a     +-----------+                  request is accepted
    socket     |   open()  |                         |
               +-----------+                         |
                     |                               | connection request
 establishes a +-----------+                         | <span class="stringliteral">&quot;accepted&quot;</span> by server,
 connection    |  connect()|------------------------&gt;| creates a <span class="keyword">new</span> socket
 request with  +-----------+                         | socket
 the server          |                               |
               +-----------+                   +-----------+
     writes    |   write() |------------------&gt;| read()    | reads client
   requests    +-----------+                   +-----------+ requests,
     and             :                               :       process them
    reads         :                               :       and writes
   replies     +-----------+                   +-----------+ back replies
               | read()    |&lt;------------------|   write() | until client
               +-----------+                   +-----------+ closes the
                     |                               |       connection
  closes the   +-----------+                   +-----------+
  connection   | shutDown()|-------------------| shutDown()|
  when done    +-----------+                   +-----------+
                     |                               |       connection
  closes the   +-----------+                   +-----------+
  connection   |   close() |-------------------|   close() |
  when done    +-----------+                   +-----------+
                     |                               |       connection
  cleans up    +-----------+                   +-----------+ cleans up
  sockets      | cleanup() |                   | cleanup() | sockets
  environment  +-----------+                   +-----------+ environment
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="typical_server_usage"></a> <a class="anchor" id="usage.typical_server_usage"></a> <a class="anchor" id="description.usage.typical_server_usage"></a> <a class="anchor" id="3.7.2"></a> </dd></dl>
<dl class="user"><dt><b>Typical Server Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate a simple single user echo server implemented using <code>btlso_socketimputil</code>. Note that the server binds to and the client connects to the specified IP_ADDR. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> serverSocket, sessionSocket;
  <span class="keyword">const</span> <span class="keywordtype">int</span>                   BACKLOG      = 32;
  <span class="keyword">const</span> <span class="keywordtype">int</span>                   RECEIVE_SIZE = 32;
  <span class="keywordtype">char</span>                        readBuffer[RECEIVE_SIZE];
  <span class="keywordtype">int</span>                         rc, errCode = 0;

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#ab899cc56fedaa558d3502e0351a8819f">btlso::SocketImpUtil::startup</a>(&amp;errCode);      assert(0 == rc);

  rc = btlso::SocketImpUtil::open&lt;btlso::IPv4Address&gt;(
                                       &amp;serverSocket,
                                       btlso::SocketImpUtil::k_SOCKET_STREAM,
                                       &amp;errCode);    assert(0 == rc);

  rc = btlso::SocketImpUtil::bind&lt;btlso::IPv4Address&gt;(serverSocket,
                                                      IP_ADDR,
                                                      &amp;errCode);
                                                     assert(0 == rc);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#ab532d5cb596d8362dc70d34dba65040e">btlso::SocketImpUtil::listen</a>(serverSocket, BACKLOG, &amp;errCode);
                                                     assert(0 == rc);

  rc = btlso::SocketImpUtil::accept&lt;btlso::IPv4Address&gt;(&amp;sessionSocket,
                                                        serverSocket,
                                                        &amp;errCode);
                                                     assert(0 == rc);

  <span class="keywordflow">do</span> {
      <span class="comment">// Echo each packet back until the client disconnects</span>
      rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a153aa8f6c8c42dc5c8ac96ea2ddb5341">btlso::SocketImpUtil::read</a>(readBuffer,
                                      sessionSocket,
                                      RECEIVE_SIZE,
                                      &amp;errCode);
      <span class="keywordflow">if</span> (rc &gt; 0) {
          <a class="code" href="structbtlso_1_1SocketImpUtil.html#a635e8ba101b004a75235e7e83d509b44">btlso::SocketImpUtil::write</a>(sessionSocket,
                                      readBuffer,
                                      rc,
                                      &amp;errCode);
      }
  } <span class="keywordflow">while</span> (rc &gt; 0);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#ad0fe311b3f4f8409ace35cb491bac37a">btlso::SocketImpUtil::shutDown</a>(
                                sessionSocket,
                                <a class="code" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7ab8c652c9e5ada32da6eb143d8b389535">btlso::SocketImpUtil::e_SHUTDOWN_BOTH</a>,
                                &amp;errCode);           assert(0 == rc);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a7325d5370d7aca579a1db09f81e56475">btlso::SocketImpUtil::close</a>(sessionSocket, &amp;errCode);
                                                     assert(0 == rc);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a7325d5370d7aca579a1db09f81e56475">btlso::SocketImpUtil::close</a>(serverSocket, &amp;errCode);
                                                     assert(0 == rc);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a6d2436f0b4ccf92c4609c89896b6dc63">btlso::SocketImpUtil::cleanup</a>(&amp;errCode);      assert(0 == rc);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="typical_client_usage"></a> <a class="anchor" id="usage.typical_client_usage"></a> <a class="anchor" id="description.usage.typical_client_usage"></a> <a class="anchor" id="3.7.3"></a> </dd></dl>
<dl class="user"><dt><b>Typical Client Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate a simple client implemented using <code>bteso_socketutil</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a>  sendSocket;
  <span class="keyword">const</span> <span class="keywordtype">int</span>                    RECEIVE_SIZE = 32;
  <span class="keywordtype">char</span>                         buffer[RECEIVE_SIZE];
  <span class="keywordtype">int</span>                          rc, errorCode = 0;
  <span class="keyword">const</span> <span class="keywordtype">char</span>                  *DATA = <span class="stringliteral">&quot;Is it raining in London now?&quot;</span>;
  <span class="keyword">const</span> <span class="keywordtype">int</span>                    DATA_SIZE = bsl::strlen(DATA) + 1;

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#ab899cc56fedaa558d3502e0351a8819f">btlso::SocketImpUtil::startup</a>(&amp;errorCode);       assert(0 == rc);

  rc = btlso::SocketImpUtil::open&lt;btlso::IPv4Address&gt;(
                                &amp;sendSocket,
                                btlso::SocketImpUtil::k_SOCKET_STREAM,
                                &amp;errorCode);
                                                        assert(0 == rc);

  rc = btlso::SocketImpUtil::connect&lt;btlso::IPv4Address&gt;(sendSocket,
                                                         IP_ADDR,
                                                         &amp;errorCode);
                                                        assert(0 == rc);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a635e8ba101b004a75235e7e83d509b44">btlso::SocketImpUtil::write</a>(sendSocket,
                                   DATA,
                                   DATA_SIZE,
                                   &amp;errorCode);  assert(DATA_SIZE == rc);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a153aa8f6c8c42dc5c8ac96ea2ddb5341">btlso::SocketImpUtil::read</a>(buffer,
                                  sendSocket,
                                  RECEIVE_SIZE,
                                  &amp;errorCode);   assert(DATA_SIZE == rc);

  assert(0 == bsl::strcmp(DATA, buffer));

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#ad0fe311b3f4f8409ace35cb491bac37a">btlso::SocketImpUtil::shutDown</a>(
                                sendSocket,
                                <a class="code" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7ab8c652c9e5ada32da6eb143d8b389535">btlso::SocketImpUtil::e_SHUTDOWN_BOTH</a>,
                                &amp;errorCode);            assert(0 == rc);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a7325d5370d7aca579a1db09f81e56475">btlso::SocketImpUtil::close</a>(sendSocket, &amp;errorCode);
                                                        assert(0 == rc);

  rc = <a class="code" href="structbtlso_1_1SocketImpUtil.html#a6d2436f0b4ccf92c4609c89896b6dc63">btlso::SocketImpUtil::cleanup</a>(&amp;errorCode);       assert(0 == rc);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
