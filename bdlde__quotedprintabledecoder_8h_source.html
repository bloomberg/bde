<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlde_quotedprintabledecoder.h                                     -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLDE_QUOTEDPRINTABLEDECODER
#define INCLUDED_BDLDE_QUOTEDPRINTABLEDECODER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide automata converting to and from Quoted-Printable encodings.
//
//@CLASSES:
//  bdlde::QuotedPrintableDecoder: automata for Quoted-Printable decoding
//
//@SEE_ALSO: &#39;bdlde::QuotedPrintableEncoder&#39;
//
//@DESCRIPTION: This component provides a template class (parameterized
// separately on both input and output iterators) that can be used to decode
// byte sequences of arbitrary length from the Quoted Printable representation
// described in Section 6.7 &quot;Quoted-Printable Content Transfer Encoding&quot; of RFC
// 2045, &quot;Multipurpose Internet Mail Extensions (MIME) Part One: Format of
// Internet Message Bodies.&quot;
//
// Each instance of the decoder retains the state of the conversion from one
// supplied input to the next, enabling the processing of segmented input --
// i.e., processing resumes where it left off with the next invocation on new
// input.  Instance methods are provided for the decoder to (1) assert the end
// of input, (2) determine whether the input so far is currently acceptable,
// and (3) indicate whether a non-recoverable error has occurred.
//
///Quoted-Printable Decoding
///-------------------------
// (In the following, all rules mentioned refer to those listed in the encoder
// section above.)
//
// The decoding process for this encoding scheme involves:
//
//: 1 transforming any encoded character triplets back into their original
//:   representation (rule #1 and rule #4).
//:
//: 2 literally writing out characters that have not been changed (rule #2).
//:
//: 3 deleting any trailing whitespace at the end of an encoded line (rule #3).
//
//: 4 removing the soft line breaks including the &#39;=&#39; prefix (i.e.,
//:   concatenating broken sentences) (rule #5).
//
// The standard imposes a maximum of 76 characters exclusive of CRLF; however,
// the decoder implemented in this component will handle lines of arbitrary
// length.
//
// The decoder also provides support for 2 error-reporting modes: the strict
// mode and the relaxed mode (configurable at construction).  A strict-mode
// decoder stops decoding at the first offending character encountered, while a
// relaxed-mode decoder would continue decoding to the end of the input,
// allowing straight pass-through of character sets that cannot be interpreted.
//
// The following kinds of errors can be encountered during decoding, listed in
// order of decreasing order of precedence:
//..
//  E1. BAD_DATA
//..
// An &#39;=&#39; character is not followed by either two uppercase hexadecimal digits,
// or a soft line break -- e.g.,
//..
//   &#39;=4=&#39; (only one hexadecimal)
//   &#39;=K3&#39; (K3 is not a hexadecimal number)
//   &#39;=1f&#39; (lower case f is a literally encoded character)
//..
//
// Note that:
//
//: 1 In the relaxed error-reporting mode of this implementation, lowercase
//:   hexadecimal digits are treated as valid numerals.
//:
//: 2 E1 can be caused by a missing or corrupted numeric, a corrupted character
//:   disguised as an &#39;=&#39;, or an accidental insertion of a &#39;=&#39; that does not
//:   belong.
//:
//: 3 The case where a seemingly valid character is found in place of a missing
//:   numeric cannot be detected, e.g., &#39;=4F&#39; where &#39;F&#39; is actually a literally
//:   encoded character.
//:
//: 4 An erroneous occurrence of a &#39;=&#39; character preceding 2 seemingly valid
//:   hexadecimal numerics is also undetectable, e.g., &#39;=4F&#39; where &#39;=&#39; was
//:   actually a &#39;t&#39; corrupted during transmission.
//..
//  E2. BAD_LINEBREAK
//..
// A &#39;\r&#39; is not followed by a &#39;\n&#39;.  In the relaxed mode, each stand-alone
// &#39;\r&#39; or &#39;\n&#39; will be copied straight through to the output.  For soft line
// breaks, whitespace is ignored between the &#39;=&#39; character and the CRLF as they
// are to be treated and removed as transport padding.
//..
//  E3. BAD_LINELENTH
//..
// An encoded line exceeds the specified maximum line length with missing soft
// line breaks.  (Because input of flexible line lengths is allowed in this
// implementation, this error is not detected or reported.)
//
// In the relaxed-mode, errors of the types E1 and E2 would be copied straight
// to output and type E3 ignored.  Decoded lines will be broken even when a
// bare CRLF is encountered in this mode.  Users can still be alerted to the
// the unreported errors as offending characters are copied straight through to
// the output stream, which can be observed.
//
// The &#39;isError&#39; method is used to detect the above anomalies, while for the
// &#39;convert&#39; method, a &#39;numIn&#39; output parameter (indicating the number of input
// characters consumed) or possibly the iterator itself (for iterators with
// reference-semantics) identifies the offending character.
//
///Usage
///- - -
// TBD

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#ifndef INCLUDED_BSL_QUEUE
#include &lt;bsl_queue.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace bdlde {

class QuotedPrintableDecoder {
    // This class implements a mechanism capable of converting data of
    // arbitrary length from its corresponding Quoted-Printable representation.

    // PRIVATE TYPES
    enum {
        // Symbolic state values.

        e_ERROR_STATE        = -1, // input is irreparably invalid
        e_INPUT_STATE        =  0, // general input state
        e_SAW_EQUAL_STATE    =  1, // need two hexadecimal values or CR LF
        e_SAW_WS_STATE       =  2, // saw a whitespace
        e_NEED_HEX_STATE     =  3, // need one hexadecimal value
        e_NEED_SOFT_LF_STATE =  4, // need soft new line
        e_NEED_HARD_LF_STATE =  5, // need soft new line
        e_DONE_STATE         =  6  // any additional input is an error
    };

  public:

    enum EquivalenceClasses {
        // This enumeration type enumerates the input equivalence classes.
        // Separate enums are given to variants resulting from different modes
        // of operation to eliminate an extra step of mode checking inside the
        // main decoding loop.

                       // Regular character - copy straight to output
        e_RC_ = 0, // strict mode
        e_RC,      // relaxed mode

                       // Hexadecimal digit - numeral only when preceded by
                       // &#39;=&#39;; otherwise a regular character
        e_HX_,     // strict mode
        e_HX,      // relaxed mode

                       // &#39;=&#39; - wait for more input
        e_EQ_,     // strict mode
        e_EQ,      // relaxed mode

                       // Whitespace        - buffer; wait for more input
        e_WS_,     // strict mode
        e_WS,      // relaxed mode

                       // Carriage return
        e_CR_,     // strict mode       - wait for further input
        e_CR,      // relaxed mode      - wait for further input

                       // Line Feed Strict mode
                       // ------------
        e_LC_,     // CRLF_MODE         - decode to &quot;\r\n&quot; if preceded by
                       // &#39;\r&#39;; report error otherwise
        e_LL_,     // LF_MODE           - decode to &#39;\n&#39; if preceded by
                       // &#39;\r&#39; report error otherwise Relaxed mode
                       // ------------
        e_LC,      // CRLF_MODE         - decode to &quot;\r\n&quot; if preceded by
                       // &#39;\r&#39;; ignore otherwise
        e_LL,      // LF_MODE           - decode to &quot;\n&quot; if preceded by
                       // &#39;\r&#39;; ignore otherwise

                       // Unrecognized char - halt and report error
        e_UC_,     // strict mode       - Ignore and halt decoding
        e_UC       // relaxed mode      - Ignore but continue decoding
    };

    enum LineBreakMode {
        // Configuration governing how line breaks are decoded.

        e_CRLF_MODE,       // &quot;\r\n&quot; are decoded to &quot;\r\n&quot;.
        e_LF_MODE          // &quot;\r\n&quot; are decoded to &quot;\n&quot;.
    };

    // CLASS DATA
    static const char s_componentName[];
        // Name of component used when reporting errors.

    static const bool s_defaultUnrecognizedIsErrorFlag;
        // Default error reporting mode

    static const char *s_defaultEquivClassStrict_p;
        // Default map of &#39;unsigned char&#39; to equivalence class for strict mode

    static const char *s_defaultEquivClassCRLF_p;
        // Default map of &#39;unsigned char&#39; to equivalence class for CRLF line
        // break mode

    static const unsigned char *const s_decodingMap_p;
        // Character map used for converting an ASCII character to the
        // hexadecimal value it is representing.

    static const int   s_defaultMaxLineLength; // Default maximum line length
    static const char* s_lineBreakModeName[];  // Names of line break mode

    // INSTANCE DATA
    bool d_unrecognizedIsErrorFlag;  // If true, fail on &quot;bad&quot; characters
    LineBreakMode d_lineBreakMode;   // Line break mode
    int d_state;  // TBD doc
    char d_buffer[90]; // TBD doc
    int d_bufferLength; // TBD doc
    char d_hexBuffer; // TBD doc
    int d_outputLength;   // Total number of output characters
    char *d_equivClass_p; // Map of &#39;unsigned char&#39; to input equivalence class;
                          // dynamically allocated because there is no default
                          // complete configuration.

  private:
    // NOT IMPLEMENTED
    QuotedPrintableDecoder(const QuotedPrintableDecoder&amp;);
    QuotedPrintableDecoder&amp; operator=(const QuotedPrintableDecoder&amp;);

  public:
    // CLASS METHODS
    static const char* lineBreakModeToAscii(LineBreakMode mode);
        // Return the ASCII string describing the specified &#39;mode&#39; governing
        // the decoding of hard linebreaks (&quot;\r\n&quot;).  The behavior is undefined
        // unless &#39;mode&#39; is either e_CRLF_MODE or e_LF_MODE.

    // CREATORS
    explicit
    QuotedPrintableDecoder(
        bool                                  detectError,
        QuotedPrintableDecoder::LineBreakMode lineBreakMode =
                                          QuotedPrintableDecoder::e_CRLF_MODE);
        // Create a Quoted-Printable decoder in the initial state, set to the
        // strict or relaxed error-reporting mode according to whether the
        // specified &#39;detectError&#39; flag is &#39;true&#39; or &#39;false&#39;, respectively, and
        // also configured to the specified &#39;lineBreakMode&#39;.  The behavior is
        // undefined unless &#39;lineBreakMode&#39; is either e_CRLF_MODE or
        // e_LF_MODE.  Note that the decoder reports errors in the strict
        // mode and output offending characters in the relaxed mode.  Hard line
        // breaks (&quot;\r\n&quot;) are decoded to &quot;\r\n&quot; in e_CRLF_MODE (default)
        // and to &#39;\n&#39; in e_LF_MODE.

    ~QuotedPrintableDecoder();
        // Destroy this object.

    // MANIPULATORS
    int convert(char       *out,
                int        *numOut,
                int        *numIn,
                const char *begin,
                const char *end,
                int         maxNumOut = -1);
        // Append to the buffer addressed by the specified &#39;out&#39; all pending
        // output (if there is any) up to the optionally specified &#39;maxNumOut&#39;
        // limit (default is negative, meaning no limit) and, when there is no
        // pending output and &#39;maxNumOut&#39; is still not reached, begin to
        // consume and decode a sequence of input characters starting at the
        // specified &#39;begin&#39; position, up to but not including the specified
        // &#39;end&#39; position, writing any resulting output in the specified
        // &#39;output&#39; buffer up to the (cumulative) &#39;maxNumOut&#39; limit.  If
        // &#39;maxNumOut&#39; limit is reached, no further input will be consumed.
        // Load into the specified &#39;numOut&#39; and &#39;numIn&#39; the number of output
        // bytes produced and input bytes consumed, respectively.  Return a
        // non-negative value on success and a negative value otherwise.  A
        // successful return status indicates the number of characters that
        // would be output if &#39;endConvert&#39; were called with no output limit
        // immediately upon exit from this method.  These bytes are also
        // available for output if this method is called with a sufficiently
        // large &#39;maxNumOut&#39;.  Note that calling this method after &#39;endConvert&#39;
        // has been invoked without an intervening &#39;reset&#39; call will place this
        // instance in an error state, and return an error status.  Note also
        // that it is recommended that after all calls to &#39;convert&#39; are
        // finished, the &#39;endConvert&#39; method be called to complete the decoding
        // of any unprocessed input characters (e.g., whitespace).

    int endConvert(char *out, int *numOut, int maxNumOut = -1);
        // Terminate encoding for this decoder; write any retained output
        // (e.g., from a previous call to &#39;convert&#39; with a non-zero &#39;maxNumOut&#39;
        // argument) to the specified &#39;out&#39; buffer.  Optionally specify the
        // &#39;maxNumOut&#39; limit on the number of bytes to output; if &#39;maxNumOut&#39;
        // is negative, no limit is imposed.  Load into the specified &#39;numOut&#39;
        // the number of output bytes produced.  Return 0 on success with no
        // pending output, the positive number of bytes (if any) that would be
        // output if &#39;endConvert&#39; were called with no output limit immediately
        // upon exit from this method, and a negative value otherwise.  Any
        // retained bytes are available on a subsequent call to &#39;endConvert&#39;.
        // Once this method is called, no additional input may be supplied
        // without an intervening call to &#39;reset&#39;; once this method returns a
        // zero status, a subsequent call will place this decoder in the error
        // state, and return an error status.

    void reset();
        // Reset this decoder to its initial state (i.e., as if no input had
        // been consumed).

    // ACCESSORS
    bool isAccepting() const;
        // Return &#39;true&#39; if the input read so far by this decoder is considered
        // syntactically complete and all resulting output has been emitted;
        // return &#39;false&#39; otherwise.  Note that there must not be any
        // unprocessed characters accumulated in the input buffer of this
        // decoder.

    bool isDone() const;
        // Return &#39;true&#39; if this decoder is in the done state (i.e.,
        // &#39;endConvert&#39; has been called and any additional input will result in
        // an error), and if there is no pending output; return &#39;false&#39;
        // otherwise.

    bool isError() const;
        // Return &#39;true&#39; if this decoder has encountered an irrecoverable error
        // and &#39;false&#39; otherwise.  An irrecoverable error is one for which
        // there is no subsequent possibility of achieving an &quot;acceptable&quot;
        // result (as defined by the &#39;isAccepting&#39; method).

    bool isInitialState() const;
        // Return &#39;true&#39; if this decoder is in the initial state (i.e., as if
        // no input had been consumed) and &#39;false&#39; otherwise.

    bool isMaximal() const;
        // Return &#39;true&#39; if the input to this decoder is maximal (i.e., the
        // input contains an end-of-input sentinel, signaling that no further
        // input should be expected).  *Always* returns &#39;false&#39; for
        // Quoted-Printable decoders since the encoding scheme does not specify
        // an end-of-input sentinel.

    bool isUnrecognizedAnError() const;
        // Return &#39;true&#39; if this decoder is currently configured to detect an
        // error when an unrecognizable encoding is encountered, and &#39;false&#39;
        // otherwise.

    LineBreakMode lineBreakMode() const;
        // Return the line break mode specified for this decoder.

    int numOutputPending() const;
        // Return the number of output bytes retained by this decoder and not
        // emitted because &#39;maxNumOut&#39; has been reached.

    int outputLength() const;
        // Return the total length of the output emitted by this decoder
        // (possibly after several calls to the &#39;convert&#39; or the &#39;input&#39;
        // methods) since its initial construction or the latest &#39;reset&#39;.
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
//
// ============================================================================

// CLASS METHODS
inline
const char* QuotedPrintableDecoder::lineBreakModeToAscii(
    LineBreakMode mode)
{
    return s_lineBreakModeName[mode];
}

// CREATORS
inline
QuotedPrintableDecoder::QuotedPrintableDecoder(
                 bool                                  unrecognizedIsErrorFlag,
                 QuotedPrintableDecoder::LineBreakMode lineBreakMode)
: d_unrecognizedIsErrorFlag(unrecognizedIsErrorFlag)
, d_lineBreakMode(lineBreakMode)
, d_state(e_INPUT_STATE)
, d_bufferLength(0)
, d_outputLength(0)
{
    if (unrecognizedIsErrorFlag) {
        // Strict mode
        d_equivClass_p = const_cast&lt;char*&gt;(s_defaultEquivClassStrict_p);
    }
    else {
        if (lineBreakMode == e_CRLF_MODE) {
            d_equivClass_p = const_cast&lt;char*&gt;(s_defaultEquivClassCRLF_p);
        }
        else {
            // First copy the map of equivalence classes for the
            // e_CRLF_MODE to the strict error-report mode.

            int len = sizeof(*s_defaultEquivClassCRLF_p) * 256;
            d_equivClass_p = new char[len];
            bsl::memcpy(d_equivClass_p, s_defaultEquivClassCRLF_p, len);
            d_equivClass_p[&#39;\n&#39;] = e_LL;  // output &#39;\n&#39; instead if preceded
                                              // by &#39;=&#39;.
        }
    }
}

// MANIPULATORS
inline
void QuotedPrintableDecoder::reset()
{
    d_state = e_INPUT_STATE;
    d_outputLength = 0;
    d_bufferLength = 0;
}

// ACCESSORS
inline
bool QuotedPrintableDecoder::isAccepting() const
{
    return e_INPUT_STATE == d_state || e_DONE_STATE == d_state;
}

inline
bool QuotedPrintableDecoder::isDone() const
{
    return e_DONE_STATE == d_state &amp;&amp; 0 == d_bufferLength;
}

inline
bool QuotedPrintableDecoder::isError() const
{
    return e_ERROR_STATE == d_state;
}

inline
bool QuotedPrintableDecoder::isInitialState() const
{
    return e_INPUT_STATE == d_state &amp;&amp; 0 == d_outputLength;
}

inline
bool QuotedPrintableDecoder::isMaximal() const
{
    return false;
}

inline
bool QuotedPrintableDecoder::isUnrecognizedAnError() const
{
    return d_unrecognizedIsErrorFlag;
}

inline
QuotedPrintableDecoder::LineBreakMode
QuotedPrintableDecoder::lineBreakMode() const
{
    return d_lineBreakMode;
}

inline
int QuotedPrintableDecoder::numOutputPending() const
{
    return d_bufferLength;
}

inline
int QuotedPrintableDecoder::outputLength() const
{
    return d_outputLength;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
