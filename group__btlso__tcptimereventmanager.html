<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlso_tcptimereventmanager Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlso_tcptimereventmanager<br/>
<small>
[<a class="el" href="group__btlso.html">Package btlso</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a multiplexer of events on sockets and timers.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Performance</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Implementing a Command Mediator</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a multiplexer of events on sockets and timers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlso_1_1TcpTimerEventManager.html">btlso::TcpTimerEventManager</a> </td><td>socket-event and timer multiplexer  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlso__eventmanager.html" title="Define a protocol for socket-event multiplexer.">Component btlso_eventmanager</a>, <a class="el" href="group__btlso__timereventmanager.html" title="Provide a protocol for multiplexing sockets events and timers.">Component btlso_timereventmanager</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a concrete implementation of the <code>btlso_timereventmanager</code> protocol for socket handles. An interested party can register a callback to be invoked whenever a particular event happens on a particular socket, or when a timer expires. Socket events have "permanent" semantics, i.e., once registered, a callback is invoked whenever appropriate events happen until it is explicitly deregistered. Timers have "one-time" semantics -- a timer callback is invoked at most once. A registered callback can only be invoked from the <code>dispatch</code> method. Registering the same socket handle and the same event with two different instances of this event managers may result in undefined behavior of an application. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This event manager can optimize its performance based on a hint provided at construction. Generally speaking, a particular usage falls into two categories: whether or not socket events are frequently registered. On some platforms, a significant performance improvement can be achieved if the registrations are infrequent. For this situation, the currently installed hint should be provided to this event manager for optimal performance. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When callbacks are being dispatched (through the <code>dispatch</code> method) priority is given to callbacks associated with socket events. The timer- related callbacks are invoked only after all socket callbacks are invoked. If two timer callbacks are registered with the same time, they're invoked in the order of registration (i.e., this timer event manager is stable with respect to timers). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This event manager is <em>thread</em> <em>safe</em>, meaning that any operation can be called on <em>distinct</em> <em>instances</em> from different threads without any side-effects (which, generally speaking, means that there is no <code>static</code> data), but not <em>thread</em> <em>enabled</em> (i.e., two threads cannot safely call methods on the <em>same</em> <em>instance</em> without external synchronization). This event manager is not <em>async-safe</em>, meaning that one or more of its functions cannot be invoked safely from a signal handler. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance"></a> <a class="anchor" id="description.performance"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Performance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component will minimize the number of system calls for the set of callbacks. A significant performance improvement can be achieved if an appropriate hint is provided. Providing a false hint (e.g., indicating infrequent registration when the reverse is true) may result in significant performance degradation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Given that T is the number of timers registered and S is the number of socket events registered, the following complexity is guaranteed by this component: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">  +=======================================================================+
  |        FUNCTION          | EXPECTED COMPLEXITY | WORST CASE COMPLEXITY|
  +-----------------------------------------------------------------------+
  | dispatch                 |    O(S + log[T])    |    O(S^2 + log[T])   |
  +-----------------------------------------------------------------------+
  | registerTimer            |      O(log[T])      |      O(log[T])       |
  +-----------------------------------------------------------------------+
  | rescheduleTimer          |      O(log[T])      |      O(log[T])       |
  +-----------------------------------------------------------------------+
  | deregisterTimer          |        O(T)         |        O(T)          |
  +-----------------------------------------------------------------------+
  | registerSocketEvent      |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterSocketEvent    |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | isRegistered             |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterSocket         |        O(1)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterAllSocketEvents|        O(S)         |        O(S)          |
  +-----------------------------------------------------------------------+
  | deregisterAllTimers      |        O(T)         |        O(T)          |
  +-----------------------------------------------------------------------+
  | deregisterAll            |       O(S+T)        |       O(S+T)         |
  +-----------------------------------------------------------------------+
  | numEvents                |        O(1)         |        O(1)          |
  +-----------------------------------------------------------------------+
  | numTimers                |        O(1)         |        O(1)          |
  +-----------------------------------------------------------------------+
  | numSocketEvents          |        O(1)         |        O(S)          |
  +=======================================================================+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_command_mediator"></a> <a class="anchor" id="usage.example_1~3A_implementing_a_command_mediator"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_a_command_mediator"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Command Mediator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following usage example shows the implementation of a command mediator. Given that this event manager is not thread enabled, a workaround is required if we are to use this manager in a multithreaded program. Let's assume that the memory allocator is either thread enabled or the design of the program is such that no concurrent allocations occur. The problem then becomes to find or create a mechanism that will allow multiple threads to register/deregister callbacks with the same instance of this event manager. This mechanism then would delegate the request to the thread that is running the <code>dispatch</code> method. Further analysis of the problem leads to a very simple solution. Clearly, the dispatcher thread needs to be activated. However, it might be blocked on a polling call (e.g., <code>select</code>) and there may be no activity on the set of monitored sockets. There are a few alternatives available on UNIX systems; Windows turns out to be the most restrictive platform and therefore the only solution that works across all platforms is to create a local pair of connected sockets and register one socket with the event manager. Whenever the invocation is requested, a byte is written into the other socket, and the dispatcher thread will invoke the (read) callback on the monitored socket from the pair, which, in turn will read the byte and invoke user-installed callback. This is the basic structure for the mechanism, which we will call <code>my_CommandMediator</code>. The implementation that follows is self-explanatory. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_CommandMediator {
      <span class="comment">// This class provides a mechanism to invoke a user-installed command</span>
      <span class="comment">// from the user-installed socket event manager&#39;s &#39;dispatch&#39; method.</span>
      <span class="comment">// Internally, it creates a socket pair, and monitors one of the pair&#39;s</span>
      <span class="comment">// socket handles for incoming data.  The &#39;invoke&#39; method will write a</span>
      <span class="comment">// byte into the other handle.  On the next call to the &#39;dispatch&#39;</span>
      <span class="comment">// method, read event will be signaled, and an internal callback will</span>
      <span class="comment">// be invoked.  This callback, in turn, will read a byte, and invoke</span>
      <span class="comment">// the user&#39;s command.</span>

      <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a>  d_client;   <span class="comment">// socket handle for &quot;control</span>
                                               <span class="comment">// data&quot;</span>
      <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a>  d_server;   <span class="comment">// socket handle to monitor</span>
      <a class="code" href="classbtlso_1_1TcpTimerEventManager.html">btlso::TcpTimerEventManager</a> *d_manager_p;<span class="comment">// targeted event manager</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span>                   d_byte;     <span class="comment">// control byte</span>
      bsl::function&lt;void()&gt;        d_command;  <span class="comment">// user command.</span>

    <span class="keyword">private</span>:
      <span class="keywordtype">void</span> readCb();
          <span class="comment">// Read exactly one byte from the &#39;d_server&#39; socket, and, if read</span>
          <span class="comment">// successfully and correctly, invoke the callback currently</span>
          <span class="comment">// installed.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_CommandMediator(<a class="code" href="classbtlso_1_1TcpTimerEventManager.html">btlso::TcpTimerEventManager</a> *manager,
                         bsl::function&lt;<span class="keywordtype">void</span>()&gt;        command,
                         <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>            *basicAllocator = 0);
          <span class="comment">// Create a mediator attached to the specified &#39;manager&#39; and</span>
          <span class="comment">// the specified &#39;command&#39;, which will be invoked from &#39;manager&#39;&#39;s</span>
          <span class="comment">// &#39;dispatch&#39; method.  Optionally specify a &#39;basicAllocator&#39; used</span>
          <span class="comment">// to supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.  The behavior is undefined</span>
          <span class="comment">// if &#39;manager&#39; is 0.</span>

      ~my_CommandMediator();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> operator()();
          <span class="comment">// Initiate an invocation of the associated command on the</span>
          <span class="comment">// next invocation of the &#39;dispatch&#39; method of the installed timer</span>
          <span class="comment">// event manager.   Return 0 on success and a non-zero value</span>
          <span class="comment">// otherwise.</span>
  };

  <span class="comment">// Private member functions</span>
  <span class="keywordtype">void</span> my_CommandMediator::readCb() {
      <span class="keywordtype">char</span> data;
      ASSERT(1 == <a class="code" href="structbtlso_1_1SocketImpUtil.html#a153aa8f6c8c42dc5c8ac96ea2ddb5341">btlso::SocketImpUtil::read</a>(&amp;data, d_server, <span class="keyword">sizeof</span> data));
      ASSERT(data == d_byte);
      d_command();
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_CommandMediator::my_CommandMediator(
                                 <a class="code" href="classbtlso_1_1TcpTimerEventManager.html">btlso::TcpTimerEventManager</a> *manager,
                                 bsl::function&lt;<span class="keywordtype">void</span>()&gt;        command,
                                 <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>            *basicAllocator)
  : d_manager_p(manager)
  , d_byte(0xAF)
  , d_command(command)
  {
      <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> handles[2];
      ASSERT(0 == btlso::SocketImpUtil::socketPair&lt;btlso::IPv4Address&gt;
                        (handles, btlso::SocketImpUtil::k_SOCKET_STREAM));

      d_client = handles[0];
      d_server = handles[1];

      bsl::function&lt;void()&gt; functor(
              <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_CommandMediator::readCb, <span class="keyword">this</span>),
              basicAllocator);
      d_manager_p-&gt;registerSocketEvent(d_server, <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>,
                                       functor);
  }

  <span class="keyword">inline</span>
  my_CommandMediator::~my_CommandMediator() {
      d_manager_p-&gt;deregisterSocketEvent(d_server,
                                         <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a>);
      ASSERT(0 == d_manager_p-&gt;numSocketEvents(d_server));
      <a class="code" href="structbtlso_1_1SocketImpUtil.html#a7325d5370d7aca579a1db09f81e56475">btlso::SocketImpUtil::close</a>(d_client);
      <a class="code" href="structbtlso_1_1SocketImpUtil.html#a7325d5370d7aca579a1db09f81e56475">btlso::SocketImpUtil::close</a>(d_server);
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_CommandMediator::operator()() {
      <span class="keywordflow">return</span>
          <a class="code" href="structbtlso_1_1SocketImpUtil.html#a635e8ba101b004a75235e7e83d509b44">btlso::SocketImpUtil::write</a>(d_client, &amp;d_byte, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))
          != <span class="keyword">sizeof</span>(char);

  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Please note that the mediator implementation presented in this usage example cannot be considered complete. Particularly, there is no data passing between the mediator thread and dispatcher thread. In a real-world application, being able to pass data is required, and, therefore, additional thread-enabled mechanisms (e.g., a thread-enabled queue) are needed. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
