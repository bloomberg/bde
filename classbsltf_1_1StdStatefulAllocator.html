<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bsltf::StdStatefulAllocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebsltf.html">bsltf</a>      </li>
      <li><a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bsltf::StdStatefulAllocator&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bsltf::StdStatefulAllocator" -->
<p><code>#include &lt;<a class="el" href="bsltf__stdstatefulallocator_8h_source.html">bsltf_stdstatefulallocator.h</a>&gt;</code></p>

<p><a href="classbsltf_1_1StdStatefulAllocator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsltf_1_1StdStatefulAllocator_1_1rebind.html">rebind</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a3680200be357cc5b8ed7220cd792d761">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a6881262fc94f6ec617d08c78fe1de4df">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a5ddb2927204019a51aff343ebb0a109a">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#ab5ab37de6b4e19e602232494764788c1">pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a63abc4dfec113272af62f6210f4ce334">const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a><br class="typebreak"/>
&lt; bool, <br class="typebreak"/>
PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#aae1e1a40dfc5ce5f76a32f87fcba1a96">propagate_on_container_copy_assignment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a><br class="typebreak"/>
&lt; bool, <br class="typebreak"/>
PROPAGATE_ON_CONTAINER_SWAP &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a7237d1dd84961c7a89f0bd9b431a10fe">propagate_on_container_swap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a><br class="typebreak"/>
&lt; bool, <br class="typebreak"/>
PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a4763aaf047fdc4bd19772b1d95ac9de1">propagate_on_container_move_assignment</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#aff6be79d5d2a9c7ab3264bbddcc97888">StdStatefulAllocator</a> (<a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> *testAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class OTHER_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a58879a319cc412e7f31c62d4a08933ae">StdStatefulAllocator</a> (const <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a>&lt; OTHER_TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt; &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a00fadda9be122bdf226064da2b14c733">allocate</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a> numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a245f71c24540d60e037230496da2d746">deallocate</a> (TYPE *address, <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a> numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a7d79b17f0beb88c3874b69327ca62b3c">testAllocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a8cf572b19069ed75989da093982b7afc">select_on_container_copy_construction</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a6881262fc94f6ec617d08c78fe1de4df">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a44f55db877cf335f37a47767a5e0176f">max_size</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE, bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt;<br/>
 class bsltf::StdStatefulAllocator&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;</h3>

<p>This allocator implements the minimal interface to comply with section 17.6.3.5 ([allocator.requirements]) of the C++11 standard, while maintaining a distinct object state - in this case a wrapped pointer to a <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code>. The template is configurable to control its allocator propagation properties, but does not support the BDE "scoped" allocator model, as scoped allocators should never propagate. Instances of this allocator delegate their operations to the wrapped test allocator that constitutes its state. Note that meeting only the minimal requirements means that this class is not DefaultConstructible. Note that while we define the various traits used by the C++11 allocator traits facility, they actually mean very little for this component, as it is the consumer of the allocator's responsibility to check and apply the traits correctly, typically by using <code><a class="el" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a></code> to perform all memory allocation tasks rather than using the allocator directly. The <code>PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION</code> flag is consumed directly though, in the static member function <code>select_on_container_copy_construction</code>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3680200be357cc5b8ed7220cd792d761"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::value_type" ref="a3680200be357cc5b8ed7220cd792d761" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TYPE <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a3680200be357cc5b8ed7220cd792d761">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6881262fc94f6ec617d08c78fe1de4df"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::size_type" ref="a6881262fc94f6ec617d08c78fe1de4df" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a6881262fc94f6ec617d08c78fe1de4df">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ddb2927204019a51aff343ebb0a109a"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::difference_type" ref="a5ddb2927204019a51aff343ebb0a109a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a5ddb2927204019a51aff343ebb0a109a">difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5ab37de6b4e19e602232494764788c1"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::pointer" ref="ab5ab37de6b4e19e602232494764788c1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TYPE* <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="classbsltf_1_1StdStatefulAllocator.html#ab5ab37de6b4e19e602232494764788c1">pointer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a63abc4dfec113272af62f6210f4ce334"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::const_pointer" ref="a63abc4dfec113272af62f6210f4ce334" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const TYPE* <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a63abc4dfec113272af62f6210f4ce334">const_pointer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aae1e1a40dfc5ce5f76a32f87fcba1a96"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::propagate_on_container_copy_assignment" ref="aae1e1a40dfc5ce5f76a32f87fcba1a96" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a>&lt;bool, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT&gt; <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="structbsl_1_1integral__constant.html">propagate_on_container_copy_assignment</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7237d1dd84961c7a89f0bd9b431a10fe"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::propagate_on_container_swap" ref="a7237d1dd84961c7a89f0bd9b431a10fe" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a>&lt;bool, PROPAGATE_ON_CONTAINER_SWAP&gt; <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="structbsl_1_1integral__constant.html">propagate_on_container_swap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4763aaf047fdc4bd19772b1d95ac9de1"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::propagate_on_container_move_assignment" ref="a4763aaf047fdc4bd19772b1d95ac9de1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsl_1_1integral__constant.html">bsl::integral_constant</a>&lt;bool, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt; <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="structbsl_1_1integral__constant.html">propagate_on_container_move_assignment</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aff6be79d5d2a9c7ab3264bbddcc97888"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::StdStatefulAllocator" ref="aff6be79d5d2a9c7ab3264bbddcc97888" args="(bslma::TestAllocator *testAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> *&nbsp;</td>
          <td class="paramname"> <em>testAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a></code> object wrapping the specified <code>testAllocator</code>. </p>

</div>
</div>
<a class="anchor" id="a58879a319cc412e7f31c62d4a08933ae"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::StdStatefulAllocator" ref="a58879a319cc412e7f31c62d4a08933ae" args="(const StdStatefulAllocator&lt; OTHER_TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt; &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::<a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a>&lt; OTHER_TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a></code> object wrapping the same test allocator as the specified <code>original</code>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a00fadda9be122bdf226064da2b14c733"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::allocate" ref="a00fadda9be122bdf226064da2b14c733" args="(bslma::Allocator::size_type numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE* <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate enough (properly aligned) space for the specified <code>numElements</code> of type <code>TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="a245f71c24540d60e037230496da2d746"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::deallocate" ref="a245f71c24540d60e037230496da2d746" args="(TYPE *address, bslma::Allocator::size_type numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return memory previously at the specified <code>address</code> for <code>numElements</code> back to this allocator. The <code>numElements</code> argument is ignored by this allocator type. The behavior is undefined unless <code>address</code> was allocated using this allocator object and has not already been deallocated. </p>

</div>
</div>
<a class="anchor" id="a7d79b17f0beb88c3874b69327ca62b3c"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::testAllocator" ref="a7d79b17f0beb88c3874b69327ca62b3c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>* <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::testAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the test allocator wrapped by this object. </p>

</div>
</div>
<a class="anchor" id="a8cf572b19069ed75989da093982b7afc"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::select_on_container_copy_construction" ref="a8cf572b19069ed75989da093982b7afc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a> <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::select_on_container_copy_construction </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a copy of this object if the <code>bool</code> template parameter <code>PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION</code> is true, and a copy of a <code><a class="el" href="classbsltf_1_1StdStatefulAllocator.html">StdStatefulAllocator</a></code> object wrapping the default allocator otherwise. The behavior is undefined unless the template parameter <code>PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION</code> is true, or unless a <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> object has been installed as the default allocator. </p>

</div>
</div>
<a class="anchor" id="a44f55db877cf335f37a47767a5e0176f"></a><!-- doxytag: member="bsltf::StdStatefulAllocator::max_size" ref="a44f55db877cf335f37a47767a5e0176f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , bool PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true, bool PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true, bool PROPAGATE_ON_CONTAINER_SWAP = true, bool PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsltf_1_1StdStatefulAllocator.html#a6881262fc94f6ec617d08c78fe1de4df">size_type</a> <a class="el" href="classbsltf_1_1StdStatefulAllocator.html">bsltf::StdStatefulAllocator</a>&lt; TYPE, PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION, PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT, PROPAGATE_ON_CONTAINER_SWAP, PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of elements of type <code>TYPE</code> that can be allocated using this allocator in a single call to the <code>allocate</code> method. Note that there is no guarantee that attempts at allocating less elements than the value returned by <code>max_size</code> will not throw. *** DO NOT RELY ON THE CONTINUING PRESENT OF THIS METHOD *** THIS METHOD WILL BE REMOVED ONCE <code>bslstl::allocator_traits</code> PROPERLY DEDUCES AN IMPLEMENTATION FOR THIS FUNCTION WHEN NOT SUPPLIED BY THE ALLOCATOR DIRECTLY. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bsltf__stdstatefulallocator_8h_source.html">bsltf_stdstatefulallocator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:45 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
