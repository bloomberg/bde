<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlde_md5.h                                                        -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLDE_MD5
#define INCLUDED_BDLDE_MD5

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a value-semantic type encoding a message in an MD5 digest.
//
//@CLASSES:
//  bdlde::Md5: value-semantic type representing an MD5 digest
//
//@SEE_ALSO:
//
//@DESCRIPTION: This component implements a mechanism for computing, updating,
// and streaming an MD5 digest (a cryptographic hash comprised of 128 bits).
// This digest is a strong technique for determining whether or not a message
// was received without errors.  This implementation is based on the RFC 1321
// specification which can be found at:
//..
//  http://www.ietf.org/rfc/rfc1321.txt
//..
// Note that an MD5 digest does not aid in error correction.
//
///Performance
///-----------
// The performance of this component is slightly slower than the native
// &#39;openssl&#39; implementation of MD5.  It is typically within 7% of the speed of
// the native &#39;openssl&#39; implementation with an error margin of +/-2%, depending
// on machine load.  A million iterations of the &#39;update&#39; method will typically
// take between 0.84s to 0.90s on Sun and 0.68s to 0.69s on IBM.  A million
// iterations of the equivalent function in &#39;openssl&#39;, &#39;MD5_Update&#39;, will
// typically take between 0.80s to 0.85s on Sun and 0.65s to 0.67s on IBM.
//
///Usage
///-----
// The following snippets of code illustrate a typical use of the &#39;bdlde::Md5&#39;
// class.  Each function would typically execute in separate processes or
// potentially on separate machines.  The &#39;senderExample&#39; function below
// demonstrates how a message sender can write a message and its MD5 digest
// to a &#39;bdex&#39; output stream.  Note that &#39;Out&#39; may be a &#39;typedef&#39; of any class
// that implements the &#39;bslx::OutStream&#39; protocol:
//..
//  void senderExample(Out&amp; output)
//      // Write a message and its MD5 digest to the specified &#39;output&#39;
//      // stream.
//  {
//      // Prepare a message.
//      bsl::string message = &quot;This is a test message.&quot;;
//
//      // Generate a digest for &#39;message&#39;.
//      bdlde::Md5 digest(message.data(), message.length());
//
//      // Write the message to &#39;output&#39;.
//      output &lt;&lt; message;
//
//      // Write the digest to &#39;output&#39;.
//      const int VERSION = 1;
//      digest.bdexStreamOut(output, VERSION);
//  }
//..
// The &#39;receiverExample&#39; function below illustrates how a message receiver can
// read a message and its MD5 digest from a &#39;bdex&#39; input stream, then perform a
// local MD5 computation to verify that the message was received intact.  Note
// that &#39;In&#39; may be a &#39;typedef&#39; of any class that implements the
// &#39;bslx::InStream&#39; protocol:
//..
//  void receiverExample(In&amp; input)
//      // Read a message and its MD5 digest from the specified &#39;input&#39; stream,
//      // and verify the integrity of the message.
//  {
//      // Read the message from &#39;input&#39;.
//      bsl::string message;
//      input &gt;&gt; message;
//
//      // Read the digest from &#39;input&#39;.
//      bdlde::Md5 digest;
//      const int VERSION = 1;
//      digest.bdexStreamIn(input, VERSION);
//
//      // Locally compute the digest of the received &#39;message&#39;.
//      bdlde::Md5 digestLocal;
//      digestLocal.update(message.data(), message.length());
//
//      // Verify that the received and locally-computed digests match.
//      assert(digestLocal == digest);
//  }
//..
//
///Additional Copyright Notice
///---------------------------
// The implementation of this component is *substantially* derived from the RSA
// Data Security, Inc. MD5 Message-Digest Algorithm that was published in the
// aforementioned RFC 1321.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNEDBUFFER
#include &lt;bsls_alignedbuffer.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace bdlde {

                                 // =========
                                 // class Md5
                                 // =========

class Md5 {
    // This &#39;class&#39; represents an MD5 digest that can be updated as additional
    // data is provided.
    //
    // More generally, this class supports a complete set of *value*
    // *semantic* operations, including copy construction, assignment,
    // equality comparison, &#39;ostream&#39; printing, and &#39;bdex&#39; serialization.
    // (A precise operational definition of when two instances have the same
    // value can be found in the description of &#39;operator==&#39; for the class.)
    // This container is *exception* *neutral* with no guarantee of rollback:
    // if an exception is thrown during the invocation of a method on a
    // pre-existing instance, the class is left in a valid state, but its
    // value is undefined.  In no event is memory leaked.  Finally, *aliasing*
    // (e.g., using all or part of an object as both source and destination)
    // is supported in all cases.

    // DATA
    unsigned int       d_state[4];    // state array storing the digest

    bsls::Types::Int64 d_length;      // length of the message

    unsigned char      d_buffer[64];  // buffer for storing remaining part of
                                      // message that is not yet incorporated
                                      // into &#39;d_state&#39;

    // FRIENDS
    friend bool operator==(const Md5&amp;, const Md5&amp;);

  public:
    // TYPES
    typedef bsls::AlignedBuffer&lt;16&gt; Md5Digest;
        // A maximally-aligned, 16-byte object type used to represent an MD5
        // digest.

    // CLASS METHODS
    static int maxSupportedBdexVersion(int);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that the &#39;versionSelector&#39; is expected to be formatted
        // as &#39;yyyymmdd&#39;, a date representation.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // CREATORS
    Md5();
        // Construct an MD5 digest having the value corresponding to no data
        // having been provided.

    Md5(const void *data, int length);
        // Construct an MD5 digest corresponding to the specified &#39;data&#39; having
        // the specified &#39;length&#39; (in bytes).  The behavior is undefined unless
        // &#39;0 &lt;= length&#39;.  Note that if &#39;data&#39; is 0, then &#39;length&#39; also must
        // be 0.

    Md5(const Md5&amp; original);
        // Construct an MD5 digest having the value of the specified &#39;original&#39;
        // digest.

    ~Md5();
        // Destroy this MD5 digest.

    // MANIPULATORS
    // !Md5&amp; operator=(const Md5&amp; rhs);
        // Assign to this MD5 digest the value of the specified &#39;rhs&#39; MD5
        // digest and return a reference to this modifiable MD5 digest.  Note
        // that this method&#39;s definition is compiler generated.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format and return a reference
        // to the modifiable &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;stream&#39; becomes invalid during this
        // operation, this object is valid, but its value is undefined.  If the
        // specified &#39;version&#39; is not supported, &#39;stream&#39; is marked invalid,
        // but this object is unaltered.  Note that no version is read from
        // &#39;stream&#39;.  (See the package-group-level documentation for more
        // information on &#39;bdex&#39; streaming of container types.)

    void reset();
        // Reset the value of this MD5 digest to the value provided by the
        // default constructor.

    void update(const void *data, int length);
        // Update the value of this MD5 digest to incorporate the specified
        // &#39;data&#39; having the specified &#39;length&#39; in bytes.  If the current state
        // is the default state, the resultant value of this MD5 digest is the
        // application of the MD5 algorithm upon the currently given &#39;data&#39; of
        // the given &#39;length&#39;.  If this digest has been previously provided
        // data and has not been subsequently reset, the current state is not
        // the default state and the resultant value is equivalent to applying
        // the MD5 algorithm upon the concatenation of all the provided data.
        // The behavior is undefined unless &#39;0 &lt;= length&#39;.  Note that if &#39;data&#39;
        // is 0, then &#39;length&#39; also must be 0.

    void loadDigestAndReset(Md5Digest *result);
        // Load the current value of this MD5 digest into the specified
        // &#39;result&#39; and set the value of this MD5 digest to the value provided
        // by the default constructor.

    // ACCESSORS
    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; and return a
        // reference to the modifiable &#39;stream&#39;.  Optionally specify an
        // explicit &#39;version&#39; format; by default, the maximum supported version
        // is written to &#39;stream&#39; and used as the format.  If &#39;version&#39; is
        // specified, that format is used, but *not* written to &#39;stream&#39;.  If
        // &#39;version&#39; is not supported, &#39;stream&#39; is left unmodified.  (See the
        // package-group-level documentation for more information on &#39;bdex&#39;
        // streaming of container types).

    bsl::ostream&amp; print(bsl::ostream&amp; stream) const;
        // Format the current value of this MD5 digest to the specified output
        // &#39;stream&#39; and return a reference to the modifiable &#39;stream&#39;.

    void loadDigest(Md5Digest *result) const;
        // Load the current value of this MD5 digest into the specified
        // &#39;result&#39;.

#ifndef BDE_OMIT_DEPRECATED
    // CLASS METHODS
    static int maxSupportedBdexVersion();
        // Return the most current &#39;bdex&#39; streaming version number supported by
        // this class.  (See the package-group-level documentation for more
        // information on &#39;bdex&#39; streaming of container types.)
#endif
};

// FREE OPERATORS
bool operator==(const Md5&amp; lhs, const Md5&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; MD5 digests have the same
    // value, and &#39;false&#39; otherwise.  Two digests have the same value if the
    // values obtained from their respective &#39;loadDigest&#39; methods are
    // identical.

inline
bool operator!=(const Md5&amp; lhs, const Md5&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; MD5 digests do not have
    // the same value, and &#39;false&#39; otherwise.  Two digests do not have the same
    // value if the values obtained from their respective &#39;loadDigest&#39; methods
    // differ.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Md5&amp; digest);
    // Write to the specified output &#39;stream&#39; the specified MD5 &#39;digest&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                                 // ---------
                                 // class Md5
                                 // ---------

// CLASS METHODS
inline
int Md5::maxSupportedBdexVersion(int)
{
    return 1;
}

// MANIPULATORS
template &lt;class STREAM&gt;
STREAM&amp; Md5::bdexStreamIn(STREAM&amp; stream, int version)
{
    switch (version) {
      case 1: {
        unsigned int       state[4];
        unsigned char      buf[64];
        bsls::Types::Int64 length;

        // first the state

        for (int i = 0; i &lt; 4; i++) {
            stream.getUint32(state[i]);
        }

        // then the length

        stream.getInt64(length);

        // finally the buffer

        for (int i = 0; i &lt; 64; i++) {
            stream.getUint8(buf[i]);
        }

        if (!stream) {
            return stream;                                            // RETURN
        }

        d_length = length;
        bsl::memcpy(d_state, state, sizeof state);
        bsl::memcpy(d_buffer, buf, sizeof buf);

      } break;
      default: {
        stream.invalidate();
      } break;
    }
    return stream;
}

// ACCESSORS
template &lt;class STREAM&gt;
STREAM&amp; Md5::bdexStreamOut(STREAM&amp; stream, int version) const
{
    if (stream) {
        switch (version) {
          case 1: {
            // first the state

            for (int i = 0; i &lt; 4; ++i) {
                stream.putUint32(d_state[i]);
            }

            // then the length

            stream.putInt64(d_length);

            // finally the buffer

            for (int i = 0; i &lt; 64; ++i) {
                stream.putUint8(d_buffer[i]);
            }

          } break;
          default: {
            stream.invalidate();
          } break;
        }
    }
    return stream;
}

// FREE OPERATORS
inline
bool operator!=(const Md5&amp; lhs, const Md5&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Md5&amp; digest)
{
    return digest.print(stream);
}

#ifndef BDE_OMIT_DEPRECATED

// ACCESSORS
inline
int Md5::maxSupportedBdexVersion()
{
    return maxSupportedBdexVersion(0);
}

#endif

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
