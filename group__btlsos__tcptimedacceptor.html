<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsos_tcptimedacceptor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsos_tcptimedacceptor<br/>
<small>
[<a class="el" href="group__btlsos.html">Package btlsos</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a blocking acceptor of TCP-based connections with timeout.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsc.html">btlsc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsos.html">btlsos</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Performance</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a blocking acceptor of TCP-based connections with timeout. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html">btlsos::TcpTimedAcceptor</a> </td><td>a blocking <code>btesc</code>-style timed channel allocator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsos__tcpchannel.html" title="Provide synchronous TCP-based communication channel.">Component btlsos_tcpchannel</a>, <a class="el" href="group__btlsos__tcptimedchannel.html" title="Provide synchronous TCP-based communication channel with timeouts.">Component btlsos_tcptimedchannel</a>, <a class="el" href="group__btlsos__tcptimedconnector.html" title="Provide a synchronous connector (with timeout) to TCP servers.">Component btlsos_tcptimedconnector</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a blocking single-port acceptor of TCP connections with timeout capability, <code><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html">btlsos::TcpTimedAcceptor</a></code>, that adheres to <code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code> protocol. Both timed and non-timed (blocking) channels can be allocated in a timed or non-timed fashion correspondingly as indicated by the following table: <br/>
<br/>
<div class="fragment"><pre class="fragment">       +=============================================================+
       |  Result/Operation |        Timed         |    Non-Timed     |
       +-------------------------------------------------------------+
       |      Timed        | <span class="stringliteral">&#39;timedAllocateTimed&#39;</span> | <span class="stringliteral">&#39;allocateTimed&#39;</span>  |
       +-------------------------------------------------------------+
       |    Non-Timed      |    <span class="stringliteral">&#39;timedAllocate&#39;</span>   |    <span class="stringliteral">&#39;allocate&#39;</span>    |
       +=============================================================+
</pre></div><br/>
<br/>
 The acceptor has the flexibility of opening and closing a listening socket with no effect on any existing channels managed by this object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The acceptor is <em>thread safe</em>, meaning that any operation can be called on <em>distinct instances</em> from different threads without any side-effects (which, generally speaking, means that there is no <code>static</code> data), but not *thread enabled* (i.e., two threads cannot safely call methods on the *same instance* without external synchronization). Acceptor is not <em>async-safe</em>, meaning that one or more functions cannot be invoked safely from a signal handler. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance"></a> <a class="anchor" id="description.performance"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Performance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Acceptor is optimized for operations with the timeout. Non-timed operations will have worse performance than their respective counterparts in the non-timed version of the acceptor (i.e., <code>btlsos_tcpacceptor</code>). If timed allocations are not required, <code><a class="el" href="classbtlsos_1_1TcpAcceptor.html">btlsos::TcpAcceptor</a></code> should be used instead. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following usage example shows a possible implementation of a single-user echo server. An echo server accepts a connection and sends back any received data back to the client (until the connection is terminated). This server requires that data is read from an accepted connection within certain time interval and be dropped on timeout. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, create a concrete socket factory that is used to manage stream sockets: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbtlso_1_1InetStreamSocketFactory.html">btlso::InetStreamSocketFactory&lt;btlso::IPv4Address&gt;</a> factory;
</pre></div><br/>
<br/>
 Second, define configuration parameters for the acceptor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      k_ECHO_PORT  = 1888,
      k_QUEUE_SIZE =   32
  };
  <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> serverAddress;
  serverAddress.<a class="code" href="classbtlso_1_1IPv4Address.html#a0db9b6717cd8bd435caeeb46a9bbd818">setPortNumber</a>(k_ECHO_PORT);
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> acceptTimeout(120, 0);  <span class="comment">// 2 minutes</span>
</pre></div><br/>
<br/>
 Now, create an acceptor and prepare it for accepting connections: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbtlsos_1_1TcpTimedAcceptor.html">btlsos::TcpTimedAcceptor</a> acceptor(&amp;factory);  <span class="comment">// uses default allocator</span>
  assert(0 == acceptor.<a class="code" href="classbtlsc_1_1TimedCbChannelAllocator.html#a40c1d76268ee3f52c53c384f49c1738b">isInvalid</a>());
  <span class="keywordflow">if</span> (0 != acceptor.open(serverAddress, k_QUEUE_SIZE)) {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Can&#39;t open listening socket&quot;</span> &lt;&lt; bsl::endl;
      <span class="keywordflow">return</span> -1;                                                    <span class="comment">// RETURN</span>
  }
  assert(acceptor.address() == serverAddress);
</pre></div><br/>
<br/>
 Set communication parameters for a channel: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { k_READ_SIZE = 8 };
  <span class="comment">// Note: this is OK *if and only if* it is in the &#39;main&#39; function.</span>
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> readTimeout(30, 0);  <span class="comment">// 30 seconds</span>
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> writeTimeout(0.5);   <span class="comment">// 0.5 seconds</span>
</pre></div><br/>
<br/>
 Go into "infinite" loop, accepting connections and servicing user requests: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">while</span> (0 == acceptor.<a class="code" href="classbtlsc_1_1TimedCbChannelAllocator.html#a40c1d76268ee3f52c53c384f49c1738b">isInvalid</a>()) {
      <span class="keywordtype">int</span> status;
      <a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> *channel = acceptor.<a class="code" href="classbtlsc_1_1TimedCbChannelAllocator.html#adaa3226abf37c0cee94d9b2bd7418ae8">timedAllocateTimed</a>(
                                   &amp;status,
                                   <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + acceptTimeout);
      <span class="keywordflow">if</span> (channel) {
          <span class="keywordflow">while</span> (1) {
              <span class="keyword">const</span> <span class="keywordtype">char</span> * result;
              <span class="keywordtype">int</span> readStatus = channel-&gt;<a class="code" href="classbtlsc_1_1TimedChannel.html#ab01361256bd112dfcb2226fd62b46baa">timedBufferedReadRaw</a>(
                                     &amp;result,
                                     k_READ_SIZE,
                                     <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + readTimeout);
              <span class="keywordflow">if</span> (0 &gt;= readStatus) {
                  <span class="keywordflow">if</span> (verbose) {
                      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to read data, readStatus = &quot;</span>
                                &lt;&lt; readStatus &lt;&lt; bsl::endl;
                  }
                  <span class="keywordflow">break</span>;
              }
              <span class="keywordflow">else</span> {
                  <span class="keywordflow">if</span> (verbose) {
                      bsl::cout &lt;&lt; <span class="stringliteral">&quot;readStatus = &quot;</span>
                                &lt;&lt; readStatus
                                &lt;&lt; bsl::endl;
                  }
              }
              <span class="keywordtype">int</span> ws = channel-&gt;<a class="code" href="classbtlsc_1_1TimedChannel.html#adfb9b67e2675cf0bac48100380b7be46">timedWrite</a>(
                                    result,
                                    readStatus,
                                    <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + writeTimeout);
              <span class="keywordflow">if</span> (readStatus != ws) {
                  <span class="keywordflow">if</span> (verbose) {
                      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to send data, writeStatus = &quot;</span>
                                &lt;&lt; ws &lt;&lt; bsl::endl;
                  }
                  <span class="keywordflow">break</span>;
              }
              <span class="keywordflow">else</span> {
                  <span class="keywordflow">if</span> (verbose) {
                      bsl::cout &lt;&lt; <span class="stringliteral">&quot;writeStatus = &quot;</span> &lt;&lt; ws &lt;&lt; bsl::endl;
                  }
              }
          }
          acceptor.<a class="code" href="classbtlsc_1_1TimedCbChannelAllocator.html#ad25de5b44d86a37ebe6bd8fde13b8010">deallocate</a>(channel);
      }
      <span class="keywordflow">else</span> {
          assert(status &lt;= 0);  <span class="comment">// Interrupts are not enabled.</span>
          <span class="keywordflow">if</span> (0 == status) {
              <span class="keywordflow">if</span> (verbose) {
                  bsl::cout &lt;&lt; <span class="stringliteral">&quot;Timed out accepting a connection&quot;</span>
                            &lt;&lt; bsl::endl;
              }
          }
      }
  }
</pre></div><br/>
<br/>
 At this point, acceptor became invalid. The server port must be closed explicitly: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(acceptor.<a class="code" href="classbtlsc_1_1TimedCbChannelAllocator.html#a40c1d76268ee3f52c53c384f49c1738b">isInvalid</a>());
  assert(0 == acceptor.close());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
