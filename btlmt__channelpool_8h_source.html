<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlmt_channelpool.h                                                -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLMT_CHANNELPOOL
#define INCLUDED_BTLMT_CHANNELPOOL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide thread-enabled stream-based IPv4 communication.
//
//@CLASSES:
//  btlmt::ChannelPool: channel manager
//
//@SEE_ALSO: btlmt_channelpoolconfiguration, btlmt_sessionpool
//
//@DESCRIPTION: This component provides a thread-enabled manager of IPv4-based
// byte-stream communication channels.  The channels are created automatically
// when the appropriate events occur and destroyed based on user requests.  A
// new channel is allocated automatically when an incoming connection is
// accepted, or when the user explicitly requests a connection to a server.
// Channel pool provides both client (aka connector) and server (aka acceptor)
// functionality.  The channel pool manages efficient delivery of messages
// to/from the user based on configuration information supplied at
// construction.  The states of individual messages are *not* reported; rather,
// channel pool notifies the user when a channel&#39;s state changes.  It also
// notifies the user when the pool&#39;s state is affected and provides the
// classification of errors.  The notification is done via asynchronous
// callback that may be invoked from *any* (managed) thread.
//
///Message Management and Delivery
///-------------------------------
// The channel pool provides an efficient mechanism for the full-duplex
// delivery of messages trying to achieve fully parallel communication on a
// socket whenever possible.  If a particular socket&#39;s system buffers are full,
// the messages are queued up to a certain (user-defined) limit, at which point
// an alert is generated.
//
// The channel pool tries to achieve optimal performance by enabling zero-copy
// semantics whenever appropriate.  On the read side, a message is read into a
// buffer that is subsequently passed to the user (via the
// &#39;BlobBasedReadCallback&#39;) for accessing and eventual deallocation.  On the
// write side, the channel pool adopts ownership of the buffers passed to
// &#39;write()&#39;.
//
///Channel Identification
///----------------------
// Each channel is identified by an integer ID that is (a) assigned by the
// channel pool and (b) is guaranteed to be unique for the lifetime of the
// channel pool.  The user can rely on this uniqueness to identify channels.
//
///Asynchronous Connect
///--------------------
// The channel pool supports an extended asynchronous connect mechanism, by
// which the pool will try to establish a connection with the server making up
// to a (user-provided) number of attempts with a (user-provided) interval
// between attempts.  If a connection attempt cannot succeed within an
// interval, it is aborted and a new connection request is issued.  If a
// connection is successfully established, the channel state callback (see
// configuration) is invoked.  In that case, if this connection is dropped at a
// later time, channel pool *will* *not* *try* to reconnect automatically.  If
// *all* attempts to establish a connection fail, then a pool state callback
// (see configuration) is invoked.  Once initiated, a connect request can lead
// to only two outcomes -- success or failure.  In particular, it can&#39;t be
// canceled.
//
///Half-Open Connections
///---------------------
// It is already possible to import a half-duplex connection into a channel
// pool, but should any half of any channel be closed, the channel pool would
// always close the channel (both halves).  A new feature, introduced in BCE
// 1.5.0, allows to keep half-open channels, i.e., single-duplex connections.
// In particular, it is possible at the creation of the channel to specify what
// the channel pool should do if only half of the channel is closed.  Passing
// in the following optional parameter (of enumeration type
// &#39;btlmt::ChannelPool::KeepHalfOpenMode&#39;) to &#39;close&#39;, &#39;import&#39;, or &#39;listen&#39;
// has the following behavior.
//..
//  e_KEEP_HALF_OPEN    If a peer closes its write part of the channel,
//                      but keeps its receive part open, then the channel pool
//                      will keep sending messages to the peer, but will
//                      disable reading on the channel.  If a peer closes its
//                      receive part of the channel, but keeps its write part
//                      open, then the channel pool will keep reading enable
//                      on this channel, but further calls to writeMessage on
//                      this channel will fail.
//
//  e_CLOSE_BOTH        If a peer closes either its write or receive part of
//                      the channel, the channel pool will simply down the
//                      channel.  This is the default behavior.
//..
//
///Resource Limits
///---------------
// The channel pool limits the resource usage based on the configuration.  The
// user must specify the maximum number of connections that an instance can
// manage, the maximum number of threads that should be used, and the size (in
// bytes) of a channel&#39;s outgoing buffer.  Once the maximum number of
// connections has been reached, an alert is generated and further channels
// cannot be created.  On the client side, all requests for a connection will
// be denied.  On the server side, no connections will be accepted, though the
// listening port is *not* closed.
//
// If the peer on a particular channel is unable to keep up with the traffic,
// the system buffers will become full and the channel will queue the outgoing
// messages up to the specified limit.  Once this limit is reached, an alert is
// generated and all further requests for sending data are denied until there
// is space available in the channel&#39;s buffer.  The same limit applies for
// every channel.
//
///Behavior on &#39;fork&#39;
///------------------
// On Unix systems, the channel&#39;s underlying sockets (file descriptors) have
// the close-on-exec flag set by default at construction time, which is passed
// on to all the child processes created by &#39;fork()&#39; during the lifetime of the
// channel pool.  This ensures that the channels, which are owned by the
// channel pool, are not passed on to other applications created by &#39;fork()&#39;
// followed by an &#39;exec()&#39;; instead, all sockets associated to channels are
// closed in the child process following the &#39;exec()&#39; command.
//
// This default setting is done for user convenience.  The user should realize
// that the behavior of &#39;fork()&#39; is actually undefined for multi-threaded
// processes.  Also, beware that this does not guard against &#39;fork()&#39; *not*
// followed by &#39;exec()&#39;: the file descriptors will remain opened in the child
// processes, which may potentially outlive the lifetime of the channel pool,
// preventing the channel&#39;s socket files from being closed properly.
//
///Metrics and Capacity
///--------------------
// By default, the channel pool monitors the workload of managed event managers
// and reports, upon request, an average value of this workload.  The workload
// of each individual event manager is calculated as the ratio of CPU bound
// processing time to the total processing time of the event manager (i.e.  CPU
// bound time +  I/O bound time) over a user-configured interval.  The time
// line for each event manager is broken into two classifications, I/O bound
// and CPU bound intervals; an event manager is performing an I/O bound
// operation when it is blocked on a system call (e.g., &#39;select&#39;); otherwise,
// it is performing a CPU bound operation.  Note that non-blocking system calls
// are NOT considered as I/O bound.  An average is then calculated over the set
// of *all* *possible* event managers, and the load is taken as 0 if an event
// manager is not started.  The length of interval that metrics are
// periodically collected over is configured by the
// &#39;btlmt::ChannelPoolConfiguration&#39; supplied at construction.
//
// For calculating the percentage of CPU time used by the channel pool given
// that channel pool manages &#39;n&#39; event pollers at a moment (with the maximum of
// the number of threads, &#39;T&#39;), the sum of workloads is taken over the set of
// &#39;T&#39; event managers, and the workload is 0 for non-existent managers.  Then
// the sum is divided by the number of event managers, T.  The result reflects
// the workload of the channel pool as &quot;percent busy&quot;.  Strictly speaking, the
// following is true:
//..
//  ] T - maximum number of event managers
//  ] n - current number of event managers.
//  Then, the total workload is
//
//       T
//      __
//      \ &#39;                                         -
//      /  workload(ev )   , where workload(ev ) = | CPU time/(CPU + I/0 time)
//      --            i                       i    | or
//      i=1                                        | 0 iff i &gt; n
//  W = ----------------                            -
//            T
//..
//
///Thread Safety
///-------------
// The channel pool is *thread-enabled* meaning that any operation on the same
// instance can be invoked from any thread.  The configuration is thread-safe,
// but not thread-enabled and requires explicit synchronization in the user
// space.  A user-defined callback can be invoked from *any* (managed) thread
// and the user must account for that.
//
///Invocation of High- and Low-Water Mark Callbacks
///------------------------------------------------
// Users of channel pool objects can specify at construction, via the
// &#39;setWriteQueueWatermarks&#39; method of &#39;btlmt::ChannelPoolConfiguration&#39;, or
// later via &#39;setWriteQueueHighWatermark&#39;, a soft limit on the number of
// bytes that can be enqueued on a channel for writing.  Any time that the
// write-queue size exceeds this high-water mark value, subsequent &#39;write&#39;
// calls on that channel will fail until the size falls back below the limit.
// When a &#39;write&#39; call fails for this reason, this event triggers a
// &#39;e_WRITE_QUEUE_HIGHWATER&#39; alert to the client via the channel-state
// callback.   Note that &#39;write&#39; calls also fail if the write-queue size
// exceeds the optionally specified &#39;enqueueWatermark&#39; argument provided to
// &#39;write&#39;, and then trigger the same alert.  Note, too, that the alert
// callback may be delivered (to a different thread) before the &#39;write&#39; call
// returns.
//
// In addition to the high-water mark, users can also specify at construction
// a low-water mark, again via the &#39;setWriteQueueWatermarks&#39; function of
// &#39;btlmt::ChannelPoolConfiguration&#39;, or later via &#39;setWriteQueueLowWatermark&#39;.
// After a write fails because a write-queue size limit has been exceeded,
// the channel pool will later provide a &#39;e_WRITE_QUEUE_LOWWATER&#39; alert to
// the client via the channel state callback when the write-queue size falls
// to, or below, the low-water mark.  Note that the alert callback may be
// delivered (to a different thread) before the &#39;write&#39; call returns.
//
// Typically, clients will suspend writing to a channel when the write queue
// tops a high-water mark, and then resume when they receive a low-water mark
// callback. Since callback alerts are not synchronized with calls to &#39;write&#39;,
// programs that rely on a mix of error-return values and callback alerts for
// flow control must provide their own synchronization.
//
// Values for the high- and low-watermark settings may be chosen according to
// requirements on data flow rate, latency, and memory usage.  A positive
// low-watermark setting, by notifying the client before the queue is empty,
// enables clients to ensure that the channel does not go idle while messages
// are being prepared to send; or it may be used simply to notify a client
// immediately when the next message may be queued.  A high-watermark setting
// may be chosen to limit the latency between a call to &#39;write&#39; and actual
// delivery of a message, or simply to limit the amount of storage used for
// buffering messages.  A high-watermark value less than the low-watermark
// value, thus, enables tuning to maximize throughput without exceeding
// message-delivery latency requirements.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Establishing a Connection
/// - - - - - - - - - - - - - - - - - -
// The following snippets of code illustrate how to establish connection
// to a remote host.  First of all, we need to create a callback to be invoked
// once the channel status change (i.e., a new connection is established, in
// this case):
//..
//  struct my_LocalCallback {
//      int d_sourceId;
//      void channelStateCb(int                 channelId,
//                          int                 sourceId,
//                          int                 status,
//                          void               *arg,
//                          btlmt::ChannelPool **poolAddr)
//      {
//          assert(sourceId == d_sourceId);
//          if (btlmt::ChannelPool::e_CHANNEL_DOWN == status) {
//              // Client disconnected from the server.
//              assert(poolAddr &amp;&amp; *poolAddr);
//              (*poolAddr)-&gt;shutdown(channelId,
//                                    btlmt::ChannelPool::e_IMMEDIATE);
//          } else
//          if (btlmt::ChannelPool::e_CHANNEL_UP == status) {
//              // Connected to the server.
//              // ...
//          }
//          else {
//              // Handle various failure modes
//              // ...
//          }
//      }
//  };
//..
// Secondly, we need to create a configuration for the channel pool:
//..
//  int main(int argc, char *argv[]) {
//      my_LocalCallback localCallback;
//      btlmt::ChannelPoolConfiguration config;
//      config.setMaxThreads(4);
//      config.setMetricsInterval(10.0);
//      config.setMaxConnections(16);
//      config.setIncomingMessageSizes(1, 128, 256);
//
//      bsl::function&lt;void(int, int, int, void*)&gt;
//                                          ccb;    // channel state callback
//      bsl::function&lt;void(int, int*, int*, void*)&gt;
//                                          dcb;    // data callback
//      bsl::function&lt;void(int, int, int)&gt;
//                                          pcb;    // pool state callback
//
//      bslmt::ChannelPool *poolAddr;
//      ccb = bdlf::BindUtil::bind( &amp;my_LocalCallback::channelStateCb
//                               , &amp;local)
//                               , _1, _2, _3, _4
//                               , &amp;poolAddr);
//      makeNull(&amp;dcb);  // not interested in data
//      makeNull(&amp;pcb);  // not interested in pool state
//
//      localCallback.d_sourceId = 5;    // just for a simple verification
//
//      btlmt::ChannelPool pool(ccb, dcb, pcb, config);
//      poolAddr = &amp;pool;
//..
// Now, start the channel pool, issue the connect request, and wait for
// completion.  Note that main thread is never blocked, so we have to put it
// to sleep explicitly:
//..
//      assert(0 == pool.start());
//      btlso::IPv4Address peer(&quot;127.0.0.1&quot;, 7); // echo server
//      assert(0 == pool.connect(peer, 1, bsls::TimeInterval(10.0), 5));
//      bslmt::ThreadUtil::sleep(15000000); // Give enough time to connect.
//      return 0;
//  }
//..
//
///Example 2: Implementing an Echo Server
/// - - - - - - - - - - - - - - - - - - -
// The following usage example shows a possible implementation of a multi-user
// echo server.  An echo server accepts connections and, for every connection,
// sends any received data back to the client (until the connection is
// terminated).  This server requires that data be read from an accepted
// connection within a certain time interval or else it is dropped on timeout.
// The echo server is implemented as a separate class (&#39;my_EchoServer&#39;) that
// owns a channel pool and its configuration parameters.  The configuration
// parameters are compile-time constants within this class.  The definition
// for &#39;my_EchoServer&#39; follows:
//..
//  class my_EchoServer {
//      // This class implements a multi-user multi-threaded echo server.
//
//      enum {
//          SERVER_ID = 0xAB   // An (arbitrary) constant (passed to &#39;listen&#39;)
//                             // that identifies the channel pool operation
//                             // associated with a pool state or channel
//                             // state callback.
//      };
//
//      // DATA
//      btlmt::ChannelPoolConfiguration d_config;        // pool&#39;s config
//      btlmt::ChannelPool             *d_channelPool_p; // managed pool
//      bslma::Allocator              *d_allocator_p;    // memory manager
//      bslmt::Mutex                   *d_coutLock_p;   // synchronize &#39;cout&#39;
//
//    private:
//      // Callback functions:
//      void poolStateCb(int state, int source, int severity);
//          // Output a message to &#39;stdout&#39; indicating the specified &#39;state&#39;
//          // associated with the specified &#39;source&#39; has occurred, with the
//          // specified &#39;severity&#39;.  Note that &#39;state&#39; is one of the
//          // &#39;PoolEvents&#39; constants, &#39;source&#39; identifies the channel pool
//          // operation associated with this state (in this case, the
//          // &#39;SERVER_ID&#39; passed to &#39;listen()&#39; or 0 for pool states with no
//          // associated source), and &#39;severity&#39; is one of the
//          // &#39;btlmt::ChannelPool::Severity&#39; values.
//
//      void channelStateCb(int channelId, int sourceId, int state, void *ctx);
//          // Output a message to &#39;stdout&#39; indicating the specified &#39;state&#39;,
//          // associated with the specified &#39;channelId&#39; and &#39;sourceId&#39;, has
//          // occurred.  If &#39;state&#39; is &#39;btlmt::ChannelPool::e_CHANNEL_DOWN&#39;
//          // then &#39;shutdown&#39; the channel.  Note that the &#39;channelId&#39; is a
//          // unique identifier chosen by the channel pool for each connection
//          // channel, &#39;sourceId&#39; identifies the channel pool operation
//          // responsible for creating the channel (in this case, the
//          // &#39;SERVER_ID&#39; passed to &#39;listen()&#39;), &#39;state&#39; is a
//          // &#39;btlmt::ChannelPool::ChannelState&#39; enumeration value, and &#39;ctx&#39;
//          // is the address of a context object provided for the channel
//          // (using &#39;setChannelContext()&#39;), in this example we do not
//          // specify a context, so the value will be 0.
//
//      void dataCb(int           *numNeeded,
//                  btlb::Blob  *msg,
//                  int            channelId
//                  void          *context);
//          // Echo the specified &#39;msg&#39; to the client on the channel
//          // identified by &#39;channelId&#39; channel, load into the
//          // specified &#39;numNeeeded&#39; the minimum length of
//          // additional data that is needed to complete a message, and close
//          // the communication channel.  Because this echo server is not
//          // interested in a discrete messages in a particular message
//          // format, the entire message in &#39;msg&#39; is read, and &#39;numNeeded&#39;
//          // will be set to 1 (indicating this callback should be invoked
//          // again as soon as any new data is read).
//
//      // NOT IMPLEMENTED
//      my_EchoServer(const my_EchoServer&amp;);
//      my_EchoServer&amp; operator=(const my_EchoServer&amp;);
//
//    public:
//      my_EchoServer(bslmt::Mutex      *coutLock,
//                    int               portNumber,
//                    int               numConnections,
//                    bslma::Allocator *basicAllocator = 0);
//          // Create an echo server that listens for incoming connections on
//          // the specified &#39;portNumber&#39; managing up to the specified
//          // &#39;numConnections&#39; simultaneous connections.  The echo server
//          // will use the specified &#39;coutLock&#39; to synchronize access to the
//          // standard output.  Optionally specify a &#39;basicAllocator&#39; used to
//          // supply memory.  If &#39;basicAllocator&#39; is 0, the currently
//          // installed default allocator is used.  The behavior is undefined
//          // unless &#39;coutLock&#39; is a valid address for a mutex object.
//
//      ~my_EchoServer();
//          // Destroy this server.
//
//      // MANIPULATORS
//      const btlmt::ChannelPool&amp; pool() { return *d_channelPool_p; }
//  };
//..
// In the constructor of &#39;my_EchoServer&#39;, the configuration is initialized,
// the channel pool is created, configured, and started.  The listening port
// is established:
//..
//  my_EchoServer::my_EchoServer(bslmt::Mutex      *coutLock,
//                               int               portNumber,
//                               int               numConnections,
//                               bslma::Allocator *basicAllocator)
//  : d_allocator_p(bslma::Default::allocator(basicAllocator))
//  , d_coutLock_p(coutLock) {
//      d_config.setMaxThreads(4);
//      d_config.setMaxConnections(numConnections);
//      d_config.setReadTimeout(5.0);       // in seconds
//      d_config.setMetricsInterval(10.0);  // seconds
//      d_config.setMaxWriteQueue(1&lt;&lt;10);   // 1MB
//      d_config.setIncomingMessageSizes(1, 100, 1024);
//
//      btlmt::ChannelPool::ChannelStateChangeCallback channelStateFunctor(
//              &amp;my_EchoServer::channelStateCb
//            , this)
//            , basicAllocator);
//
//      btlmt::ChannelPool::PoolStateChangeCallback poolStateFunctor(
//              &amp;my_EchoServer::poolStateCb
//            , this)
//            , basicAllocator));
//
//      btlmt::ChannelPool::DataReadCallback dataFunctor(
//              &amp;my_EchoServer::dataCb
//            , this)
//            , basicAllocator));
//
//      d_channelPool_p = new (*d_allocator_p)
//          btlmt::ChannelPool(channelStateFunctor,
//                            dataFunctor,
//                            poolStateFunctor,
//                            d_config,
//                            basicAllocator);
//
//      assert(0 == d_channelPool_p-&gt;start());
//      assert(0 == d_channelPool_p-&gt;listen(portNumber,
//                                          numConnections,
//                                          SERVER_ID));
//  }
//..
// Destructor just stops the pool and destroys it:
//..
//  my_EchoServer::~my_EchoServer() {
//      d_channelPool_p-&gt;stop();
//      d_allocator_p-&gt;deleteObject(d_channelPool_p);
//  }
//..
// The pool state callback will just print the new state.  The channel state
// callback will report a new state and the address of the peer.  The data
// state callback will immediately write data back to the channel pool.  These
// methods are documented in the example header, and the implementation for
// these methods is shown below:
//..
//  void my_EchoServer::poolStateCb(int state, int source, int severity) {
//      d_coutLock_p-&gt;lock();
//      cout &lt;&lt; &quot;Pool state changed: (&quot;
//           &lt;&lt; source &lt;&lt; &quot;, &quot;
//           &lt;&lt; severity &lt;&lt; &quot;, &quot;
//           &lt;&lt; state &lt;&lt; &quot;) &quot; &lt;&lt; endl;
//      d_coutLock_p-&gt;unlock();
//  }
//
//  void my_EchoServer::channelStateCb(int   channelId,
//                                     int   sourceId,
//                                     int   state,
//                                     void *context)
//  {
//      assert(SERVER_ID == sourceId);
//
//      switch(state) {
//        case btlmt::ChannelPool::e_CHANNEL_DOWN: {
//            btlso::IPv4Address peer;
//            d_channelPool_p-&gt;getPeerAddress(&amp;peer, channelId);
//            d_coutLock_p-&gt;lock();
//            cout &lt;&lt; &quot;Client from &quot; &lt;&lt; peer &lt;&lt; &quot; has disconnected.&quot; &lt;&lt; endl;
//            d_coutLock_p-&gt;unlock();
//            d_channelPool_p-&gt;shutdown(channelId,
//                                      btlmt::ChannelPool::e_IMMEDIATE);
//        } break;
//        case btlmt::ChannelPool::e_CHANNEL_UP: {
//            btlso::IPv4Address peer;
//            d_channelPool_p-&gt;getPeerAddress(&amp;peer, channelId);
//            d_coutLock_p-&gt;lock();
//            cout &lt;&lt; &quot;Client connected from &quot; &lt;&lt; peer &lt;&lt; endl;
//            d_coutLock_p-&gt;unlock();
//        } break;
//      }
//  }
//
//  void my_EchoServer::dataCb(int          *numNeeded,
//                             btlb::Blob *msg,
//                             int           channelId,
//                             void         *context)
//  {
//      assert(msg);
//      assert(0 &lt; msg-&gt;length());
//
//      assert(0 == d_channelPool_p-&gt;write(channelId, *msg));
//
//      msg-&gt;removeAll();
//
//      *numNeeded = 1;
//
//      d_channelPool_p-&gt;shutdown(channelId,
//                                btlmt::ChannelPool::e_IMMEDIATE);
//  }
//..
// The implementation of an echo server is now complete.  Let&#39;s create
// a small program that uses it.  We will create a server object, then
// the main thread will monitor the channel pool and periodically print
// its busy metrics.  For simplicity, we will use the following function
// for monitoring:
//..
//  static void monitorPool(bslmt::Mutex              *coutLock,
//                          const btlmt::ChannelPool&amp;  pool,
//                          int                        numTimes)
//      // Every 10 seconds, output the percent busy of the specified channel
//      // &#39;pool&#39; to the standard output, using the specified &#39;coutLock&#39; to
//      // synchronizing access to the standard output stream; return to the
//      // caller after &#39;numTimes&#39; output operations (i.e. numTimes * 10
//      // seconds).
//  {
//      while(--numTimes &gt; 0) {
//          coutLock-&gt;lock();
//          cout &lt;&lt; &quot;The pool is &quot; &lt;&lt; pool.busyMetrics() &lt;&lt; &quot;% busy (&quot;
//              &lt;&lt; pool.numThreads() &lt;&lt; &quot; threads).&quot; &lt;&lt; endl;
//          coutLock-&gt;unlock();
//      }
//  }
//..
// The main function is shown below:
//..
//   int main() {
//       enum {
//           PORT_NUMBER     = 1423
//         , MAX_CONNECTIONS = 1000
//         , NUM_MONITOR     = 50
//       };
//       bslmt::Mutex coutLock;
//       my_EchoServer echoServer(&amp;coutLock, PORT_NUMBER, MAX_CONNECTIONS);
//       monitorPool(&amp;coutLock, echoServer.pool(), NUM_MONITOR);
//       return 0;
//
//   }
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLMT_CHANNELSTATUS
#include &lt;btlmt_channelstatus.h&gt;
#endif

#ifndef INCLUDED_BTLMT_CHANNELPOOLCONFIGURATION
#include &lt;btlmt_channelpoolconfiguration.h&gt;
#endif

#ifndef INCLUDED_BTLMT_CHANNELTYPE
#include &lt;btlmt_channeltype.h&gt;
#endif

#ifndef INCLUDED_BTLMT_TCPTIMEREVENTMANAGER
#include &lt;btlmt_tcptimereventmanager.h&gt;
#endif

#ifndef INCLUDED_BTLS_IOVECUTIL
#include &lt;btls_iovecutil.h&gt;
#endif

#ifndef INCLUDED_BTLSO_INETSTREAMSOCKETFACTORY
#include &lt;btlso_inetstreamsocketfactory.h&gt;
#endif

#ifndef INCLUDED_BTLSO_SOCKETHANDLE
#include &lt;btlso_sockethandle.h&gt;
#endif

#ifndef INCLUDED_BDLCC_OBJECTCATALOG
#include &lt;bdlcc_objectcatalog.h&gt;
#endif

#ifndef INCLUDED_BTLB_BLOB
#include &lt;btlb_blob.h&gt;
#endif

#ifndef INCLUDED_BDLMA_CONCURRENTPOOLALLOCATOR
#include &lt;bdlma_concurrentpoolallocator.h&gt;
#endif

#ifndef INCLUDED_BTLB_POOLEDBLOBBUFFERFACTORY
#include &lt;btlb_pooledblobbufferfactory.h&gt;
#endif

#ifndef INCLUDED_bslmt_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_bslmt_THREADUTIL
#include &lt;bslmt_threadutil.h&gt;
#endif

#ifndef INCLUDED_BDLT_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BDLB_NULLABLEVALUE
#include &lt;bdlb_nullablevalue.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTR
#include &lt;bslma_managedptr.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTRDELETER
#include &lt;bslma_managedptrdeleter.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMICOPERATIONS
#include &lt;bsls_atomicoperations.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_MAP
#include &lt;bsl_map.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

#ifdef BSLS_PLATFORM_OS_UNIX
#ifndef INCLUDED_BSL_C_LIMITS
#include &lt;bsl_c_limits.h&gt;      // for IOV_MAX
#endif
#endif

namespace BloombergLP {

namespace btlso {

class IPv4Address;
class SocketOptions;

}

namespace btlmt {

class Channel;
class Connector;
class ServerState;

                       //==================
                       // struct TimerState
                       //==================

struct TimerState {
    // Provide a description of a scheduled timer event.  Note that a
    // &#39;ChannelPool&#39; associates a &#39;TimerState&#39; object with each timer callback
    // it registers with an underlying &#39;TcpTimerEventManager&#39;.
    //
    // This class is an implementation detail of &#39;ChannelPool&#39;, and is *not*
    // intended to be used in client code.

    void                       *d_eventManagerId; // identifies the timer in
                                                  // &#39;d_eventManager_p&#39;

    TcpTimerEventManager       *d_eventManager_p; // event manager the timer
                                                  // is registered with

    bsls::TimeInterval          d_absoluteTime;   // next scheduled occurrence
                                                  // (as an offset from the
                                                  // epoch time)

    bsls::TimeInterval          d_period;         // if a positive value, the
                                                  // periodic interval for
                                                  // the timer; otherwise it
                                                  // is a non-recurring timer

    bsl::function&lt;void()&gt;       d_callback;       // callback function to
                                                  // invoke
};

                       //==================
                       // class ChannelPool
                       //==================

class ChannelPool {
    // This class provides a channel pool, i.e., a mechanism by which
    // connections can be established and managed.  This channel pool allows
    // the establishment of both server channels (see section &quot;Server part&quot; of
    // the manipulators section) via the &#39;listen&#39; and &#39;close&#39; methods, and
    // client channels (see section &quot;Client part&quot;) via the &#39;connect&#39; method,
    // and provide the &#39;disableRead&#39;, &#39;enableRead&#39;, and &#39;shutdown&#39; methods for
    // managing the channels once they have been created (see the section
    // &quot;Channel management&quot;).  In addition, it allows the communication of
    // messages through any of the channels (see the section &quot;Outgoing
    // Messages&quot;) via the &#39;write&#39; methods; the processing of incoming data to
    // any of the channels is done asynchronously through a data callback
    // passed at construction of this pool.  An existing socket can be imported
    // and this will create a channel enabled both for read and for write.
    // This channel pool can dispatch events to be executed at different times
    // at recurring intervals (see the section &quot;Clock management&quot;).  All this
    // processing will be performed in a number of threads.  The channel pool
    // can be started or stopped (see the section &quot;Threads management&quot;).  Once
    // started and until stopped, the channel pool dispatches incoming and
    // outgoing connections, messages, and other channel functions to the
    // processing threads.  Once stopped, the channel pool can be started again
    // and the channels will resume their operations.  This channel pool keeps
    // a set of metrics (see the &quot;Metrics&quot; section).  It can be configured at
    // construction by passing a &#39;ChannelPoolConfiguration&#39; object.

  public:
    // TYPES
    typedef bsl::function&lt;void(int, int, int, void*)&gt;
                                                    ChannelStateChangeCallback;
        // The callback of this type is invoked whenever a channel&#39;s state
        // changes.  The first argument is the (unique) channel ID, chosen by
        // the channel pool, that identifies the connection channel that
        // changed state.  The second argument is the source ID, i.e., the
        // client-provided identifier passed to the channel pool, identifying
        // the operation responsible for creating the channel (e.g., the
        // &#39;serverId&#39; parameter of &#39;listen()&#39; or the &#39;sourceId&#39; parameter of
        // &#39;connect()&#39;).  The third argument is the new state of this channel
        // (can be any one of the &#39;ChannelEvents&#39; enumerations).  The fourth
        // and last parameter is passed the user-specified (via
        // &#39;setChannelContext&#39;) channel context or &#39;(void*)0&#39; if no context was
        // specified.  Users MUST handle the &#39;e_CHANNEL_DOWN&#39; event, minimally
        // by calling &#39;shutdown&#39; on the channel ID.  The prototype for a
        // channel state callback might look like:
        //..
        //  void channelStateCallback(int   channelId,
        //                            int   sourceId,
        //                            int   state,
        //                            void *context);
        //..

    typedef bsl::function&lt;void(int *, btlb::Blob *, int, void *)&gt;
                                                         BlobBasedReadCallback;
        // The callback of this type is invoked every time there is a
        // sufficiently large amount of data read from a channel.  The second
        // argument to this callback is passed the data read from the channel
        // in the form of a modifiable &#39;btlb::Blob&#39;.  The channel pool expects
        // that clients take ownership of some of the data in the passed
        // &#39;btlb::Blob&#39; and readjust the &#39;btlb::Blob&#39; accordingly.  The third
        // argument specifies the channel ID.  The fourth and last parameter is
        // passed the user-specified channel context (set using
        // &#39;setChannelContext()&#39;) or &#39;(void *)0&#39; if no context was specified.
        // The callback, when invoked, must store into the first argument the
        // minimum length of additional data that is needed to complete a
        // message.  If there is not enough data for a single message of a
        // particular protocol, 0 must be stored into the first argument.  The
        // prototype for a data callback might look like:
        //..
        //  void blobDataCallback(int          *numNeeded,
        //                        btlb::Blob *message,
        //                        int           channelId,
        //                        void         *context);
        //..

    typedef bsl::function&lt;void(int, int, int)&gt; PoolStateChangeCallback;
        // The callback of this type is invoked whenever a change affecting the
        // pool occurs.  The first parameter indicates the type of event which
        // triggered the callback (i.e., one of the &#39;PoolEvents&#39; enumerations).
        // The second parameter indicates the source of the event (e.g., the
        // &#39;serverId&#39; passed to &#39;listen()&#39; or the &#39;sourceId&#39; passed to
        // &#39;connect()&#39;), or is 0 if there is no associated source (e.g. a
        // &#39;e_CHANNEL_LIMIT&#39; alert).  The third parameter indicates the
        // severity of the event (must be one of the &#39;Severity&#39; enumerations).
        // The prototype of a pool state callback might look like:
        //..
        //  void poolStateCallback(int eventType, int sourceId, int severity);
        //..

    enum ChannelEvents {
        // This enumeration provides names for the different values passed into
        // the third argument to &#39;ChannelCallback&#39; to discriminate between
        // various changes in the state of a channel.

        e_CHANNEL_DOWN         = 0,
        e_CHANNEL_UP           = 1,
        e_READ_TIMEOUT         = 2,
        e_WRITE_BUFFER_FULL    = 3,
        e_MESSAGE_DISCARDED    = 4,
        e_AUTO_READ_ENABLED    = 5,
        e_AUTO_READ_DISABLED   = 6,
        e_WRITE_QUEUE_LOWWATER   = 7,
        e_WRITE_QUEUE_HIGHWATER  = e_WRITE_BUFFER_FULL,
        e_CHANNEL_DOWN_READ    = 8,
        e_CHANNEL_DOWN_WRITE   = 9


    };

    enum PoolEvents {
        e_ACCEPT_TIMEOUT = 0,           // timed out accepting a connection
        e_ERROR_ACCEPTING,              // error accepting a connection
        e_ERROR_CONNECTING,             // error connecting to the peer
        e_CHANNEL_LIMIT,                // channel limit reached
        e_CAPACITY_LIMIT,               // capacity limit reached
        e_ERROR_BINDING_CLIENT_ADDR,    // error binding client address
        e_ERROR_SETTING_OPTIONS,        // error setting socket options
        e_EVENT_MANAGER_LIMIT           // event manager limit reached

    };

    enum ConnectResolutionMode {
        // Mode indicating whether to perform name resolution at each connect
        // attempt in &#39;connect&#39;.

        e_RESOLVE_ONCE                = 0,  // perform resolution once prior
                                            // to the first connect attempt

        e_RESOLVE_AT_EACH_ATTEMPT     = 1   // perform resolution prior to each
                                            // connect attempt
    };

    enum KeepHalfOpenMode {
        // Mode affecting how half-open connections are handled by a server or
        // a client channel, passed to &#39;connect&#39;, &#39;import&#39; or &#39;listen&#39;.

        e_CLOSE_BOTH         = 0,  // close whole channel if half-open
                                   // connection

        e_KEEP_HALF_OPEN     = 1   // keep either part alive, if the other
                                   // half senses a closed connection by
                                   // the peer


    };

    enum ShutdownMode {
        // Mode affecting how channel is terminated, passed to &#39;shutdown&#39;.

        e_IMMEDIATE     = 0  // The channel is terminated immediately, all
                             // pending messages are discarded.


    };

    enum Severity {
        // This enumeration provides names for different levels of severity.

        e_CRITICAL      = 0, // A critical condition occurred and the channel
                             // pool is unable to operate normally.

        e_ALERT         = 1  // An alerting condition occurred and the channel
                             // pool can operate normally.


    };

    struct HandleInfo {
        // This &#39;struct&#39; contains information about an open file descriptor,
        // namely the channel ID of the channel that uses this file descriptor,
        // its manager ID (and thread ID of that manager&#39;s dispatcher thread),
        // and the server ID (for a socket created by a call to &#39;listen&#39;, or a
        // channel accepted by that socket) or source ID (for a channel created
        // by a call to &#39;connect&#39; or &#39;import&#39;).  Some channel types correspond
        // to a channel in process of creation (during &#39;connect&#39;) and may not
        // yet have a channel ID, in which case -1 is used for &#39;d_channelId&#39;
        // and for &#39;d_userId&#39; instead.

        btlso::SocketHandle::Handle d_handle;       // socket handle (file
                                                    // descriptor)

        ChannelType::Value          d_channelType;  // indicates how the
                                                    // channel was created

        int                         d_channelId;    // channel using this
                                                    // file descriptor

        bsls::TimeInterval          d_creationTime; // when was this channel
                                                    // created

        bslmt::ThreadUtil::Handle   d_threadHandle; // manager&#39;s dispatcher
                                                    // thread

        int                         d_userId;       // &#39;serverId&#39; or &#39;sourceId&#39;
    };

  private:
    // PRIVATE TYPES
    typedef bsl::shared_ptr&lt;Channel&gt;     ChannelHandle;
    typedef bsl::shared_ptr&lt;ServerState&gt; ServerHandle;

    // INSTANCE DATA
                                        // *** Transport-related state ***
    bdlcc::ObjectCatalog&lt;ChannelHandle&gt; d_channels;

    bsl::vector&lt;TcpTimerEventManager *&gt; d_managers;

    mutable bslmt::Mutex                d_managersStateChangeLock;
                                                    // mutex to synchronize
                                                    // changing the state of
                                                    // the event managers

    bsl::map&lt;int, Connector&gt;            d_connectors;

    mutable bslmt::Mutex                d_connectorsLock;

    bsl::map&lt;int, ServerHandle&gt;         d_acceptors;

    mutable bslmt::Mutex                d_acceptorsLock;

    bdlma::ConcurrentPoolAllocator      d_sharedPtrRepAllocator;

    bslma::ManagedPtr&lt;btlb::BlobBufferFactory&gt;
                                        d_writeBlobFactory;

    bslma::ManagedPtr&lt;btlb::BlobBufferFactory&gt;
                                        d_readBlobFactory;

    bslmt::Mutex                        d_timersLock;

    bsl::map&lt;int, TimerState&gt;           d_timers;

                                        // *** Parameters ***

    ChannelPoolConfiguration            d_config;

    bsls::AtomicOperations::AtomicTypes::Int
                                        d_capacity;

    int                                 d_startFlag;

    bool                                d_collectTimeMetrics;
                                               // whether to collect time
                                               // metrics

                                        // *** Capacity monitoring ***

    bdlb::NullableValue&lt;void *&gt;         d_metricsTimerId;

    bsl::function&lt;void()&gt;               d_metricsFunctor;

    ChannelStateChangeCallback          d_channelStateCb;

    PoolStateChangeCallback             d_poolStateCb;

    BlobBasedReadCallback               d_blobBasedReadCb;

                                        // *** Metrics ***

    bsls::AtomicInt                     d_totalConnectionsLifetime;

    bsls::TimeInterval                  d_lastResetTime;

    volatile bsls::Types::Int64         d_totalBytesReadAdjustment;
                                               // adjustment to
                                               // the sum of individual
                                               // channel numBytesRead(),
                                               // accounting for closed
                                               // channels and calls to
                                               // &#39;resetTotalBytesRead&#39;

    volatile bsls::Types::Int64         d_totalBytesWrittenAdjustment;
                                               // adjustment to
                                               // the sum of individual
                                               // channel numBytesWritten(),
                                               // accounting for closed
                                               // channels and calls to
                                               // &#39;resetTotalBytesWritten&#39;

    volatile bsls::Types::Int64         d_totalBytesRequestedWrittenAdjustment;
                                               // adjustment to
                                               // the sum of individual
                                               // channel values,
                                               // accounting for closed
                                               // channels and calls to
                                               // reset

    mutable bslmt::Mutex                d_metricAdjustmentMutex;
                                               // synchronize operations on
                                               // two metric adjustment values

                                        // *** Memory allocation ***

    btlso::InetStreamSocketFactory&lt;btlso::IPv4Address&gt;
                                        d_factory;

    bdlma::ConcurrentPool               d_pool;        // for Channel
                                                       // (owned)

    bslma::Allocator                   *d_allocator_p; // (held, not owned)

  private:
    // FRIENDS
    friend class Channel;

    // PRIVATE MANIPULATORS
    TcpTimerEventManager *allocateEventManager();
        // From the set of current event managers, find the most idle one
        // (i.e., having the minimal percent CPU busy) and return its address.
        // Return the address of event manager on success, and 0 otherwise, in
        // which case &#39;status&#39; will be loaded with a non-zero value.
        //
        // LOCKING: This function doesn&#39;t lock any synchronization primitives.

    void init();
        // Initialize this channel pool.

                                  // *** Server part ***
    void acceptCb(int serverId, ServerHandle server);
        // Add a newly allocated channel to the set of channels managed by this
        // channel pool and invoke the channel pool callback.  Note that this
        // method is executed whenever a connection is accepted on the
        // listening socket corresponding to the server whose ID is
        // &#39;it-&gt;first&#39;.  All other information (e.g., listening socket and
        // event manager) is held in the server state &#39;it-&gt;second&#39;.

    void acceptRetryCb(int serverId, ServerHandle server);
        // Re-register listening socket for the server whose ID is &#39;serverId&#39;
        // to match &#39;ACCEPT&#39; events (and invoke callback &#39;acceptCb&#39; on such
        // events).  This callback is called after no resources were available
        // to accept a connection, and the socket was subsequently
        // deregistered.  This callback is scheduled in an exponential backoff
        // sequence fashion.  The exponential series is reset once a call to
        // &#39;accept&#39; stops returning &#39;btlso::SocketHandle::e_ERROR_NORESOURCES&#39;.

    void acceptTimeoutCb(int serverId, ServerHandle server);
        // Issue a pool callback with &#39;ACCEPT_TIMEOUT&#39; and re-schedule this
        // timeout callback for the server whose ID is &#39;it-&gt;first&#39;, if the
        // listening socket held in the server state &#39;it-&gt;second&#39; did not
        // receive a connection attempt in the timeout period specified in the
        // server state since the last server connection or last timeout
        // callback.

    int listen(const btlso::IPv4Address&amp;   endpoint,
               int                         backlog,
               int                         serverId,
               int                         reuseAddress,
               bool                        readEnabledFlag,
               KeepHalfOpenMode            mode,
               bool                        isTimedFlag,
               const bsls::TimeInterval&amp;   timeout = bsls::TimeInterval(),
               const btlso::SocketOptions *socketOptions = 0);
        // Establish a listening socket having the specified &#39;backlog&#39; maximum
        // number of pending connections on the specified &#39;endpoint&#39; and the
        // specified &#39;reuseAddress&#39; used in setting &#39;e_REUSEADDRESS&#39; socket
        // option, and associate this newly established socket with the
        // specified &#39;serverId&#39;.  If the specified &#39;readEnabledFlag&#39; is
        // non-zero, any channel created by &#39;acceptCb&#39; will be enabled for read
        // upon creation, and otherwise it will not.  If the specified
        // &#39;isTimedFlag&#39; is non-zero, register a timer which will execute
        // &#39;acceptTimeoutCb&#39; in the dispatcher thread of the event manager for
        // this server, if no connection attempt is received for the optionally
        // specified &#39;timeout&#39; period since the last connection or the last
        // timeout.  Optionally specify &#39;socketOptions&#39; that will be used to
        // specify what options should be set on the listening socket.  Return
        // 0 on success, a positive value if there is a listening socket
        // associated with &#39;serverId&#39; (i.e., &#39;serverId&#39; is not unique) and a
        // negative value if an error occurred.  The behavior is undefined
        // unless &#39;0 &lt; backlog&#39;.

                                  // *** Client part ***

    void connectCb(bsl::map&lt;int,Connector&gt;::iterator it);
        // Add a newly allocated channel to the set of channels managed by this
        // channel pool and invoke the channel state callback.  Note that this
        // method is executed whenever a valid connection is established
        // corresponding to the client whose ID is &#39;it-&gt;first&#39;.  All other
        // information (e.g., connection socket and event manager) is held in
        // the connector state &#39;it-&gt;second&#39;.

    void connectEventCb(bsl::map&lt;int,Connector&gt;::iterator it);
        // Check the connection status of the connection socket upon call back
        // from the socket event &#39;btlso::EventType::e_CONNECT&#39;.  If the
        // connection is valid then call &#39;connectCb&#39;, otherwise this socket
        // timed out and we must close it, reopen another socket, and
        // re-attempt a connection.  All other information (e.g., connection
        // socket and event manager) is held in the connector state
        // &#39;it-&gt;second&#39;.

    void connectInitiateCb(bsl::map&lt;int,Connector&gt;::iterator it);
        // Initiate a connection for the client whose clientId is &#39;it-&gt;first&#39;,
        // and upon success proceed to &#39;connectCb&#39;.  Otherwise, register
        // &#39;connectEventCb&#39; for when this connection is established or times
        // out, or upon failure, invoke a pool state callback with
        // &#39;e_ERROR_CONNECTING&#39;, clientId given by the specified &#39;it-&gt;first&#39;,
        // and severity &#39;e_ALERT&#39;.  All other information (e.g., connection
        // socket and event manager) is held in the connector state
        // &#39;it-&gt;second&#39;.

    void connectTimeoutCb(bsl::map&lt;int,Connector&gt;::iterator it);
        // Decrease the number of attempts held in the connector state.  Once
        // the number of attempts reaches zero, the connection event is
        // deregistered and the connector removed from &#39;d_connectors&#39;.  Note
        // that this callback is invoked if the connecting socket held in the
        // connector state &#39;it-&gt;second&#39; did not establish a connection in the
        // timeout period specified in the server state, either through
        // &#39;connectInitiateCb&#39; or through a &#39;connectEventCb&#39; after the last
        // &#39;connectInitiateCb&#39;.

    int connectImp(const btlso::IPv4Address&amp;   serverAddress,
                   int                         numAttempts,
                   const bsls::TimeInterval&amp;   interval,
                   int                         sourceId,
                   bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                              *socket,
                   bool                        readEnabledFlag,
                   KeepHalfOpenMode            mode,
                   const btlso::SocketOptions *socketOptions,
                   const btlso::IPv4Address   *localAddress);
        // Asynchronously issue up to the specified &#39;numAttempts&#39; connection
        // requests to a server at the specified &#39;serverAddress&#39;, with at least
        // the specified (relative) time &#39;interval&#39; after each attempt before
        // either a new connection is retried (if &#39;numAttempts&#39; is not reached)
        // or the connection attempts are abandoned (if &#39;numAttempts&#39; is
        // reached).  When the connection is established, an internal channel
        // is created and a channel state callback, with the event
        // &#39;e_CHANNEL_UP&#39;, the newly created channel ID, and the specified
        // &#39;sourceId&#39; is invoked in an internal thread.  If the &#39;interval&#39; is
        // reached, or in case other events occur (e.g., &#39;e_ERROR_CONNECTING&#39;,
        // &#39;e_CHANNEL_LIMIT&#39;, or &#39;e_CAPACITY_LIMIT&#39;), a pool state callback is
        // invoked with the event type, &#39;sourceId&#39; and a severity.  Use the
        // specified &#39;readEnabledFlag&#39; to indicate whether automatic reading
        // should be enabled on this channel immediately after creation and the
        // specified half-close &#39;mode&#39; in case the channel created for this
        // connection is half-closed.  Specify either &#39;socketOptions&#39; that will
        // be used to provide the options that should be set on the connecting
        // socket and the specified &#39;localAddress&#39; to be used as the source
        // address, or specify &#39;socket&#39; to use as the connecting socket (with
        // any desired options and source address already set).  If &#39;socket&#39; is
        // specified, this pool will assume its ownership if this function
        // returns successfully, and will be left unchanged if an error is
        // returned.  Return 0 on successful initiation, a positive value if
        // there is an active connection attempt with the same &#39;sourceId&#39; (in
        // which case this connection attempt may be retried after that other
        // connection either succeeds, fails, or times out), or a negative
        // value if an error occurred, with the value of -1 indicating that the
        // channel pool is not running.  The behavior is undefined unless
        // &#39;0 &lt; numAttempts&#39;, &#39;0 &lt; interval || 1 == numAttempts&#39;, and
        // &#39;0 == socketOptions || (0 == socket &amp;&amp; 0 == localAddress)&#39;.

    int connectImp(const char                 *hostname,
                   int                         portNumber,
                   int                         numAttempts,
                   const bsls::TimeInterval&amp;   interval,
                   int                         sourceId,
                   bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                              *socket,
                   ConnectResolutionMode       resolutionMode,
                   bool                        readEnabledFlag,
                   KeepHalfOpenMode            halfCloseMode,
                   const btlso::SocketOptions *socketOptions,
                   const btlso::IPv4Address   *localAddress);
        // Asynchronously issue up to the specified &#39;numAttempts&#39; connection
        // requests to a server at the address resolved from the specified
        // &#39;hostname&#39; on the specified &#39;portNumber&#39;, with at least the
        // specified (relative) time &#39;interval&#39; after each attempt before
        // either a new connection is retried (if &#39;numAttempts&#39; is not reached)
        // or the connection attempts are abandoned (if &#39;numAttempts&#39; is
        // reached).  When the connection is established, an internal channel
        // is created and a channel state callback, with the event
        // &#39;e_CHANNEL_UP&#39;, the newly created channel ID, and the specified
        // &#39;sourceId&#39;, is invoked in an internal thread.  If the &#39;interval&#39; is
        // reached, or in case other events occur (e.g., &#39;e_ERROR_CONNECTING&#39;,
        // &#39;e_CHANNEL_LIMIT&#39;, or &#39;e_CAPACITY_LIMIT&#39;), a pool state callback is
        // invoked with the event type, &#39;sourceId&#39; and a severity.  Use the
        // specified &#39;resolutionMode&#39; to indicate whether the name resolution
        // is performaed once (if &#39;resolutionMode&#39; is &#39;e_RESOLVE_ONCE&#39;), or
        // performed anew prior to each attempt (if &#39;resolutionMode&#39; is
        // &#39;e_RESOLVE_AT_EACH_ATTEMPT&#39;), the specified &#39;readEnabledFlag&#39; to
        // indicate whether automatic reading should be enabled on this channel
        // immediately after creationo, and the specified &#39;halfCloseMode&#39; in
        // case the channel created for this connection is half-closed.
        // Specify either &#39;socketOptions&#39; that will be used to provide the
        // options that should be set on the connecting socket and the
        // specified &#39;localAddress&#39; to be used as the source address, or
        // specify &#39;socket&#39; to use as the connecting socket (with any desired
        // options and source address already set).  If &#39;socket&#39; is specified,
        // this pool will assume ownership its ownership if this function
        // returns successfully, and will be left unchanged if an error is
        // returned.  Return 0 on successful initiation, a positive value if
        // there is an active connection attempt with the same &#39;sourceId&#39; (in
        // which case this connection attempt may be retried after that other
        // connection either succeeds, fails, or times out), or a negative
        // value if an error occurred, with the value of -1 indicating that the
        // channel pool is not running.  The behavior is undefined unless
        // &#39;0 &lt; numAttempts&#39;, &#39;0 &lt; interval || 1 == numAttempts&#39;, and
        // &#39;0 == socketOptions || (0 == socket &amp;&amp; 0 == localAddress)&#39;

                                  // *** Channel management part ***
    void importCb(btlso::StreamSocket&lt;btlso::IPv4Address&gt; *socket,
                  const bslma::ManagedPtrDeleter&amp;          deleter,
                  TcpTimerEventManager                    *manager,
                  TcpTimerEventManager                    *srcManager,
                  int                                      sourceId,
                  bool                                     readEnabledFlag,
                  bool                                     mode,
                  bool                                     imported);
        // Add a newly allocated channel to the set of channels managed by this
        // channel pool and invoke the channel pool callback in the specified
        // &#39;manager&#39;.  Upon destruction, &#39;socket&#39; will be destroyed via the
        // specified &#39;factory&#39;.  Note that this method is executed whenever a
        // connection is imported on the &#39;socket&#39; corresponding to &#39;sourceId&#39;.
        // In addition, it is invoked by &#39;connectCb&#39; to create a newly
        // allocated channel once the socket connection is established.  This
        // function should be executed in the dispatcher thread of the
        // specified &#39;srcManager&#39;.

                                  // *** Clock management ***

    void timerCb(int timerId);
        // Execute the callback associated with the timer or clock whose ID is
        // the specified &#39;timerId&#39; whenever the current timeout of this timer
        // or clock expires, and if the &#39;timerId&#39; corresponds to a clock then
        // re-register the clock for the next period.

                                  // *** Metrics ***
    void metricsCb();
        // Update metrics for each event manager.

    // PRIVATE ACCESSORS
    int findChannelHandle(ChannelHandle *handle, int channelId) const;
        // Load into &#39;handle&#39; a shared-pointer to the channel associated with
        // the specified &#39;channelId&#39;.  Return 0 on success, or a non-zero value
        // if there is no valid channel channel is associated with &#39;channelId&#39;.
        // Note that a channel handle in &#39;d_channels&#39; may be null, if the
        // channel has been added but not yet initialized.

  private:
    // NOT IMPLEMENTED
    ChannelPool(const ChannelPool&amp; original);
    ChannelPool&amp; operator=(const ChannelPool&amp; rhs);

  public:
    // CREATORS
    ChannelPool(ChannelStateChangeCallback       channelStateCb,
                BlobBasedReadCallback            blobBasedReadCb,
                PoolStateChangeCallback          poolStateCb,
                const ChannelPoolConfiguration&amp;  parameters,
                bslma::Allocator                *basicAllocator = 0);
        // Create a channel pool with the specified &#39;channelStateCb&#39;,
        // &#39;blobBasedReadCb&#39; and &#39;poolStateCb&#39; callbacks to be invoked,
        // correspondingly, when a channel state changes, data arrives, or pool
        // state changes.  The channel pool is configured using the specified
        // configuration &#39;parameters&#39;.  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.
        //
        // The exact description of the argument to the callbacks are given in
        // the type definitions of the &#39;ChannelStateChangeCallback&#39;,
        // &#39;BlobBasedReadCallback&#39;, and &#39;PoolStateChangeCallback&#39;.

    ChannelPool(btlb::BlobBufferFactory       *blobBufferFactory,
                ChannelStateChangeCallback       channelStateCb,
                BlobBasedReadCallback            blobBasedReadCb,
                PoolStateChangeCallback          poolStateCb,
                const ChannelPoolConfiguration&amp;  parameters,
                bslma::Allocator                *basicAllocator = 0);
        // Create a channel pool having the specified &#39;channelStateCb&#39;,
        // &#39;blobBasedReadCb&#39; and &#39;poolStateCb&#39; callbacks to be invoked, when a
        // channel state changes, data arrives, or pool state changes
        // (respectively), and using the specified &#39;blobBufferFactory&#39; to
        // supply buffers for all internal read and write blobs including those
        // passed to &#39;blobBasedReadCb&#39;.  The channel pool is configured using
        // the specified configuration &#39;parameters&#39;.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.
        //
        // The exact description of the argument to the callbacks are given in
        // the type definitions of the &#39;ChannelStateChangeCallback&#39;,
        // &#39;BlobBasedReadCallback&#39;, and &#39;PoolStateChangeCallback&#39;.

    ~ChannelPool();
        // Destroy this channel pool.  The behavior is undefined if the channel
        // pool was not shut down properly.

    // MANIPULATORS
                                  // *** Server part ***

    int close(int serverId);
        // Close the listening socket corresponding to the specified
        // &#39;serverId&#39;.  Return 0 on success, and a non-zero value otherwise.
        // Note that closing a listening socket has no effect on any channels
        // managed by this pool.

    int listen(int                         portNumber,
               int                         backlog,
               int                         serverId,
               int                         reuseAddress = 1,
               bool                        readEnabledFlag = true,
               const btlso::SocketOptions *socketOptions = 0);
    int listen(int                         portNumber,
               int                         backlog,
               int                         serverId,
               const bsls::TimeInterval&amp;   timeout,
               int                         reuseAddress = 1,
               bool                        readEnabledFlag = true,
               const btlso::SocketOptions *socketOptions = 0);
    int listen(const btlso::IPv4Address&amp;   endpoint,
               int                         backlog,
               int                         serverId,
               int                         reuseAddress = 1,
               bool                        readEnabledFlag = true,
               const btlso::SocketOptions *socketOptions = 0);
    int listen(const btlso::IPv4Address&amp;   endpoint,
               int                         backlog,
               int                         serverId,
               const bsls::TimeInterval&amp;   timeout,
               int                         reuseAddress = 1,
               bool                        readEnabledFlag = true,
               KeepHalfOpenMode            mode = e_CLOSE_BOTH,
               const btlso::SocketOptions *socketOptions = 0);
        // Establish a listening socket having the specified &#39;backlog&#39; maximum
        // number of pending connections on the specified &#39;portNumber&#39; on all
        // local interfaces or the specified &#39;endpoint&#39;, depending on which
        // overload of &#39;listen&#39; is used, and associate this newly established
        // socket with the specified &#39;serverId&#39;.  Optionally, specify a
        // &#39;timeout&#39; *duration* for accepting a connection.  If no connection
        // attempt is received for a period of &#39;timeout&#39; since the last
        // connection or the last timeout, a pool state callback is invoked
        // with event equal to &#39;e_ACCEPT_TIMEOUT&#39;.  Optionally specify a
        // &#39;reuseAddress&#39; value to be used in setting &#39;e_REUSEADDRESS&#39; socket
        // option; if &#39;reuseAddress&#39; is not specified, 1 is used (i.e.,
        // &#39;e_REUSEADDRESS&#39; is enabled).  Optionally specify via a
        // &#39;readEnabledFlag&#39; whether automatic reading should be enabled on
        // this channel immediately after creation; if &#39;readEnabledFlag&#39; is not
        // specified, then &#39;true&#39; is used (i.e., reading on new channels is
        // automatically enabled).  If &#39;endpoint&#39;, &#39;timeout&#39;, &#39;reuseAddress&#39;
        // and &#39;readEnabledFlag&#39; are all specified, also optionally specify a
        // &#39;mode&#39; to keep channel half-open in case a channel established by
        // the server with this &#39;serverId&#39; is half-closed; if &#39;mode&#39; is not
        // specified, then &#39;e_CLOSE_BOTH&#39; is used (i.e., half-open connections
        // lead to closing the channel completely).  Optionally specify
        // &#39;socketOptions&#39; that will be used to indicate what options should be
        // set on the listening socket.  Return 0 on success, a positive value
        // if there is a listening socket associated with &#39;serverId&#39; (i.e.,
        // &#39;serverId&#39; is not unique) and a negative value if an error occurred.
        // Every time a connection is accepted by this pool on this (newly
        // established) listening socket, &#39;serverId&#39; is passed to the callback
        // provided in the configuration at construction.  The behavior is
        // undefined unless &#39;0 &lt; backlog&#39;.

                                  // *** Client part ***

    int connect(const char                 *hostname,
                int                         portNumber,
                int                         numAttempts,
                const bsls::TimeInterval&amp;   interval,
                int                         sourceId,
                bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                           *socket,
                ConnectResolutionMode       resolutionMode = e_RESOLVE_ONCE,
                bool                        readEnabledFlag = true,
                KeepHalfOpenMode            halfCloseMode = e_CLOSE_BOTH);
    int connect(const char                 *hostname,
                int                         portNumber,
                int                         numAttempts,
                const bsls::TimeInterval&amp;   interval,
                int                         sourceId,
                ConnectResolutionMode       resolutionMode = e_RESOLVE_ONCE,
                bool                        readEnabledFlag = true,
                KeepHalfOpenMode            halfCloseMode = e_CLOSE_BOTH,
                const btlso::SocketOptions *socketOptions = 0,
                const btlso::IPv4Address   *localAddress = 0);
        // Asynchronously issue up to the specified &#39;numAttempts&#39; connection
        // requests to a server at the address resolved from the specified
        // &#39;hostname&#39; on the specified &#39;portNumber&#39;, with at least the
        // specified (relative) time &#39;interval&#39; after each attempt before
        // either a new connection is retried (if &#39;numAttempts&#39; is not reached)
        // or the connection attempts are abandoned (if &#39;numAttempts&#39; is
        // reached).  When the connection is established, an internal channel
        // is created and a channel state callback, with the event
        // &#39;e_CHANNEL_UP&#39;, the newly created channel ID, and the specified
        // &#39;sourceId&#39; is invoked in an internal thread.  If the &#39;interval&#39; is
        // reached, or in case other events occur (e.g., &#39;e_ERROR_CONNECTING&#39;,
        // &#39;e_CHANNEL_LIMIT&#39;, or &#39;e_CAPACITY_LIMIT&#39;), a pool state callback is
        // invoked with the event type, &#39;sourceId&#39; and a severity.  Optionally
        // specify a &#39;resolutionMode&#39; to indicate whether the name resolution
        // is performed once (if &#39;resolutionMode&#39; is &#39;e_RESOLVE_ONCE&#39;), or
        // performed anew prior to each attempt (if &#39;resolutionMode&#39; is
        // &#39;e_RESOLVE_AT_EACH_ATTEMPT&#39;); if &#39;resolutionMode&#39; is not specified,
        // &#39;e_RESOLVE_ONCE&#39; is used.  Optionally specify via a
        // &#39;readEnabledFlag&#39; whether automatic reading should be enabled on
        // this channel immediately after creation; if &#39;readEnabledFlag&#39; is not
        // specified, then &#39;true&#39; is used (i.e., reading on new channels is
        // automatically enabled).  Optionally specify a &#39;halfCloseMode&#39; in
        // case the channel created for this connection is half-closed; if
        // &#39;mode&#39; is not specified, then &#39;e_CLOSE_BOTH&#39; is used (i.e.,
        // so-called half-open connections, that is, anything less than full
        // duplex, lead to close the channel).  Optionally specify either
        // &#39;socketOptions&#39; that will be used to specify what options should be
        // set on the connecting socket and/or the specified &#39;localAddress&#39; to
        // be used as the source address, or specify &#39;socket&#39; to use as the
        // connecting socket (with any desired options and/or source address
        // already set).  If &#39;socket&#39; is specified, this pool will assume its
        // ownership if this function returns successfully, and will be left
        // unchanged if an error is returned.  Return 0 on successful
        // initiation, a positive value if there is an active connection
        // attempt with the same &#39;sourceId&#39; (in which case this connection
        // attempt may be retried after that other connection either succeeds,
        // fails, or times out), or a negative value if an error occurred, with
        // the value of -1 indicating that the channel pool is not running.
        // The behavior is undefined unless &#39;0 &lt; numAttempts&#39;, and either
        // &#39;0 &lt; interval&#39; or &#39;1 == numAttempts&#39; or both.  Note that if the
        // connection cannot be established, up to &#39;numAttempts&#39; pool state
        // callbacks with &#39;e_ERROR_CONNECTING&#39; may be generated, one for each
        // &#39;interval&#39;.  Also note that this function will fail if this channel
        // pool is not running, and that no callbacks will be invoked if the
        // return value is non-zero.  Also note that the same &#39;sourceId&#39; can be
        // used in several calls to &#39;connect&#39; or &#39;import&#39; as long as two calls
        // to connect with the same &#39;sourceId&#39; do not overlap.  Finally, note
        // that the lifetime of the &#39;hostname&#39; need not extend past the return
        // of this function call, that is, &#39;hostname&#39; need not remain valid
        // until the last connection attempt but can be deleted upon return.

    int connect(const btlso::IPv4Address&amp;   serverAddress,
                int                         numAttempts,
                const bsls::TimeInterval&amp;   interval,
                int                         sourceId,
                bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                           *socket,
                bool                        readEnabledFlag = true,
                KeepHalfOpenMode            mode = e_CLOSE_BOTH);
    int connect(const btlso::IPv4Address&amp;   serverAddress,
                int                         numAttempts,
                const bsls::TimeInterval&amp;   interval,
                int                         sourceId,
                bool                        readEnabledFlag = true,
                KeepHalfOpenMode            mode = e_CLOSE_BOTH,
                const btlso::SocketOptions *socketOptions = 0,
                const btlso::IPv4Address   *localAddress = 0);
        // Asynchronously issue up to the specified &#39;numAttempts&#39; connection
        // requests to a server at the specified &#39;serverAddress&#39;, with at least
        // the specified (relative) time &#39;interval&#39; after each attempt before
        // either a new connection is retried (if &#39;numAttempts&#39; is not reached)
        // or the connection attempts are abandoned (if &#39;numAttempts&#39; is
        // reached).  When the connection is established, an internal channel
        // is created and a channel state callback, with the event
        // &#39;e_CHANNEL_UP&#39;, the newly created channel ID, and the specified
        // &#39;sourceId&#39; is invoked in an internal thread.  If the &#39;interval&#39; is
        // reached, or in case other events occur (e.g., &#39;e_ERROR_CONNECTING&#39;,
        // &#39;e_CHANNEL_LIMIT&#39;, or &#39;e_CAPACITY_LIMIT&#39;), a pool state callback is
        // invoked with the event type, &#39;sourceId&#39; and a severity.  Optionally
        // specify via a &#39;readEnabledFlag&#39; whether automatic reading should be
        // enabled on this channel immediately after creation; if
        // &#39;readEnabledFlag&#39; is not specified, then &#39;true&#39; is used (i.e.,
        // reading on new channels is automatically enabled).  Optionally
        // specify a half-close &#39;mode&#39; in case the channel created for this
        // connection is half-closed; if &#39;mode&#39; is not specified, then
        // &#39;e_CLOSE_BOTH&#39; is used (i.e., half-open connections lead to close
        // the channel).  Optionally specify either &#39;socketOptions&#39; that will
        // be used to specify what options should be set on the connecting
        // socket and/or the specified &#39;localAddress&#39; to be used as the source
        // address, or specify &#39;socket&#39; to use as the connecting socket (with
        // any desired options and/or source address already set).  If &#39;socket&#39;
        // is specified, this pool will assume its ownership.  Return 0 on
        // successful initiation, a positive value if there is an active
        // connection attempt with the same &#39;sourceId&#39; (in which case this
        // connection attempt may be retried after that other connection either
        // succeeds, fails, or times out), or a negative value if an error
        // occurred, with the value of -1 indicating that the channel pool is
        // not running.  The behavior is undefined unless &#39;0 &lt; numAttempts&#39;,
        // and either &#39;0 &lt; interval&#39; or &#39;1 == numAttempts&#39; or both.  Note that
        // if the connection cannot be established, up to &#39;numAttempts&#39; pool
        // state callbacks with &#39;e_ERROR_CONNECTING&#39; may be generated, one for
        // each &#39;interval&#39;.  Also note that this function will fail if this
        // channel pool is not running, and that no callbacks will be invoked
        // if the return value is non-zero.  Also note that the same &#39;sourceId&#39;
        // can be used in several calls to &#39;connect&#39; or &#39;import&#39; as long as two
        // calls to connect with the same &#39;sourceId&#39; do not overlap.

                                  // *** Channel management ***

    int disableRead(int channelId);
        // Enqueue a request to disable automatic reading on the channel having
        // the specified &#39;channelId&#39;.  Return 0 on success and a non-zero value
        // otherwise.  Once automatic reading is disabled a channel state
        // callback for this channel is invoked with &#39;e_AUTO_READ_DISABLED&#39;
        // state.
        //
        // This method offers the following specific guarantees:
        // - When shutting down a channel, &#39;e_AUTO_READ_DISABLED&#39; message
        //   is *not* generated.
        // - A data callback will always happen in between
        //   &#39;e_AUTO_READ_ENABLED&#39; and &#39;e_AUTO_READ_DISABLED&#39;
        //   callbacks.
        // - The data currently enqueued in the channel pool for this channel
        //   is *not* discarded.

    int enableRead(int channelId);
        // Enqueue a request to enable automatic reading on the channel having
        // the specified &#39;channelId&#39;.  Return 0 on success and a non-zero value
        // otherwise.  Once automatic reading is enabled a channel state
        // callback for this channel is invoked with &#39;e_AUTO_READ_ENABLED&#39;
        // state.
        //
        // This method offers the following specific guarantees:
        // - By default, a newly created channel is in
        //   &#39;e_AUTO_READ_ENABLED&#39; state (except imported channels with
        //   &#39;readEnabledFlag&#39; not set), unless the &#39;readEnabledFlag was set to
        //   &#39;false&#39;.
        // - When a new channel is created and read is enabled, both
        //   &#39;e_CHANNEL_UP&#39; and e_AUTO_READ_ENABLED messages are
        //   generated, in this order.  However, &#39;e_CHANNEL_UP&#39; and
        //   &#39;e_AUTO_READ_ENABLED&#39; may be generated from different threads.
        // - A data callback will always happen in between
        //   &#39;e_AUTO_READ_ENABLED&#39; and &#39;e_AUTO_READ_DISABLED&#39;
        //   callbacks.

    int import(bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                                      *streamSocket,
               int                                     sourceId,
               bool                                    readEnabledFlag = true,
               KeepHalfOpenMode                        mode = e_CLOSE_BOTH);
        // Add the specified &#39;streamSocket&#39; to this channel pool.  Assign a
        // channel ID and invoke a channel state callback, passing
        // &#39;e_CHANNEL_UP&#39; and the specified &#39;sourceId&#39;, in an internal thread.
        // Assume ownership from &#39;streamSocket&#39;, leaving it null, if this
        // function returns successfully, and leave it unchanged if an error is
        // returned.  Optionally specify via &#39;readEnabledFlag&#39; whether
        // automatic reading should be enabled on this channel immediately
        // after creation; if &#39;readEnabledFlag&#39; is not specified, then &#39;true&#39;
        // is used (i.e., reading on new channels is automatically enabled).
        // Optionally specify a half-close &#39;mode&#39; in case the channel created
        // for this connection is half-closed; if &#39;mode&#39; is not specified, then
        // &#39;e_CLOSE_BOTH&#39; is used (i.e., half-open connections lead to close
        // the channel).  Return 0 on success and a non-zero value, with no
        // effect on the channel pool, otherwise.  Note that the same
        // &#39;sourceId&#39; can be used in several calls to &#39;connect&#39; or &#39;import&#39; as
        // long as two calls to connect with the same &#39;sourceId&#39; do not
        // overlap.  Also note that a half-closed &#39;streamSocket&#39; can be
        // imported into this channel pool, irrespective of &#39;mode&#39;.

    void setChannelContext(int channelId, void *context);
        // Associate the specified (opaque) &#39;context&#39; with the channel having
        // the specified &#39;channelId&#39;.  The channel context will be reported on
        // any invocation of a callback related to this channel.

    int shutdown(int                       channelId,
                 ShutdownMode              mode = e_IMMEDIATE);
    int shutdown(int                       channelId,
                 btlso::Flag::ShutdownType type,
                 ShutdownMode              mode = e_IMMEDIATE);
        // Shut down the communication channel having the specified &#39;channelId&#39;
        // in the optionally specified &#39;mode&#39; and return 0 on success, and a
        // non-zero value otherwise.  Optionally specify a shutdown &#39;type&#39; to
        // close only the reading or the writing part; by default,
        // &#39;e_CLOSE_BOTH&#39; is used (i.e., both halves of the channel are
        // closed).  Note that shutting down a channel will deallocate all
        // system resources associated with &#39;channel&#39; and subsequent references
        // to channel will result in undefined behavior.  Also note that, if
        // the channel does not support half-open connections (i.e., the &#39;mode&#39;
        // passed to &#39;connect&#39;, &#39;listen&#39;, or &#39;import&#39; was set to
        // &#39;e_CLOSE_BOTH&#39;), then shutting down the channel leads to a complete
        // shutdown, irrespective of the shutdown &#39;type&#39;.  If the channel does
        // support half-open connections, but is already half-closed, and the
        // &#39;type&#39; (set to &#39;e_SHUTDOWN_BOTH&#39;, &#39;e_SHUTDOWN_RECEIVE&#39; or
        // &#39;e_SHUTDOWN_SEND&#39;) closes the other half, then the channel is shut
        // down completely; otherwise, only one half of the channel is closed
        // but the channel itself is not, and subsequent calls to write (if
        // &#39;type&#39; is &#39;e_SHUTDOWN_SEND&#39;), or to &#39;enableRead&#39; (if &#39;type&#39; is
        // &#39;e_SHUTDOWN_RECEIVE&#39;), will fail.

    int stopAndRemoveAllChannels();
        // Terminate all threads managed by this channel pool, close all
        // listening sockets, close both the read and write parts of all
        // communication channels under management, and remove all those
        // communication channels from this channel pool.  Return 0 on success,
        // and a non-zero value otherwise.  If any attempt to terminate a
        // thread &quot;gracefully&quot; fails, previously terminated threads are
        // restarted and a negative value is returned.  The behavior is
        // undefined if &#39;start&#39; is called concurrently or subsequent to the
        // completion of this call.  Note that shutting down a channel will
        // deallocate all system resources associated with that channel.  Also
        // note that this function is intended to be called to release
        // resources held by this channel pool just prior to its destruction.

    int setWriteQueueHighWatermark(int channelId, int numBytes);
        // Set the write queue high-water mark for the specified &#39;channelId&#39; to
        // the specified &#39;numBytes&#39;; return 0 on success, and a non-zero value
        // if &#39;channelId&#39; does not exist. An &#39;e_WRITE_QUEUE_HIGHWATER&#39;
        // alert is provided (via the channel state callback) if &#39;numBytes&#39; is
        // less than or equal to the current size of the write queue.  (See the
        // &quot;Invocation of High- and Low-Water Mark Callbacks&quot; section under
        // @DESCRIPTION in the component-level documentation for details on
        // &#39;e_WRITE_QUEUE_HIGHWATER&#39; and &#39;e_WRITE_QUEUE_LOWWATER&#39; alerts.)  The
        // behavior is undefined unless &#39;0 &lt;= numBytes&#39;.  Note that this method
        // overrides the value configured (for all channels) by the
        // &#39;ChannelPoolConfiguration&#39; supplied at construction.

    int setWriteQueueLowWatermark(int channelId, int numBytes);
        // Set the write queue low-water mark for the specified &#39;channelId&#39; to
        // the specified &#39;numBytes&#39;; return 0 on success, and a non-zero value
        // if either &#39;channelId&#39; does not exist.  An &#39;e_WRITE_QUEUE_LOWWATER&#39;
        // alert is provided (via the channel state callback) if &#39;numBytes&#39; is
        // greater than or equal to the current size state of the write queue.
        // (See // the &quot;Invocation of High- and Low-Water Mark Callbacks&quot;
        // section under @DESCRIPTION in the component-level documentation for
        // details on &#39;e_WRITE_QUEUE_HIGHWATER&#39; and &#39;e_WRITE_QUEUE_LOWWATER&#39;
        // alerts.) The behavior is undefined unless &#39;0 &lt;= numBytes&#39;.  Note
        // that this method overrides the value configured (for all channels)
        // by the &#39;ChannelPoolConfiguration&#39; supplied at construction.

    int setWriteQueueWatermarks(int channelId,
                                int lowWatermark,
                                int highWatermark);
        // Set the write queue low- and high-water marks for the specified
        // &#39;channelId&#39; to the specified &#39;lowWatermark&#39; and &#39;highWatermark&#39;
        // values, respectively; return 0 on success, and a non-zero value if
        // &#39;channelId&#39; does not exist.  A &#39;e_WRITE_QUEUE_LOWWATER&#39; alert is
        // provided (via the channel state callback) if &#39;lowWatermark&#39; is
        // greater than or equal to the current size of the write queue, and a
        // &#39;e_WRITE_QUEUE_HIGHWATER&#39; alert is provided if &#39;highWatermark&#39; is
        // less than or equal to the current size of the write queue.  (See the
        // &quot;Invocation of High- and Low-Water Mark Callbacks&quot; section under
        // @DESCRIPTION in the component-level documentation for details on
        // &#39;e_WRITE_QUEUE_HIGHWATER&#39; and &#39;e_WRITE_QUEUE_LOWWATER&#39; alerts.)  The
        // behavior is undefined unless &#39;0 &lt;= lowWatermark&#39; and
        // &#39;0 &lt;= highWatermark&#39;.  Note that this method overrides the values
        // configured (for all channels) by the &#39;ChannelPoolConfiguration&#39;
        // supplied at construction.

    int resetRecordedMaxWriteQueueSize(int channelId);
        // Reset the recorded max write queue size for the specified
        // &#39;channelId&#39; to the current write queue size.  Return 0 on success,
        // or a non-zero value if &#39;channelId&#39; does not exist.  Note that this
        // function resets the recorded max write queue size and does not
        // change the write queue high-water mark for &#39;channelId&#39;.

                                  // *** Thread management ***

    int start();
        // Create internal threads that monitor network events and invoke
        // corresponding callbacks supplied (in the configuration) at
        // construction.  Return 0 on success, and a non-zero value otherwise.
        // The behavior is undefined if the internal threads are created (as
        // reflected by the pool&#39;s state), see &#39;state&#39;.

    int stop();
        // Gracefully terminate the worker threads; return 0 on success and a
        // non-zero value otherwise.  If any attempt to terminate a thread
        // &quot;gracefully&quot; fails, previously terminated threads are restarted and
        // a negative value is returned.  The behavior is undefined unless the
        // threads exist (i.e., were created successfully).  Note that this
        // function has no effect on the state of any channel managed by this
        // pool.

                                  // *** Incoming messages ***

    btlb::BlobBufferFactory *incomingBlobBufferFactory();
        // Return the address of the pooled blob buffer factory used by this
        // channel pool to produce blobs for incoming messages.

                                  // *** Outgoing messages ***

    btlb::BlobBufferFactory *outboundBlobBufferFactory();
        // Return the address of the blob buffer factory used by this channel
        // pool to produce blobs for outbound messages.
        //
        // Note that this version of channel pool now uses blob internally.  It
        // is more efficient to create blob messages, using the
        // &#39;outboundBlobBufferFactory()&#39;, than to create data messages using
        // &#39;outboundBufferFactory()&#39;.

    int write(int channelId, const btlb::Blob&amp; message);
    int write(int channelId, const btlb::Blob&amp; message, int enqueueWatermark);
    int write(int channelId, const btls::Iovec vecs[], int numVecs);
    int write(int channelId, const btls::Ovec  vecs[], int numVecs);
        // Enqueue a request to write the specified &#39;message&#39; or &#39;vecs&#39; into
        // the channel having the specified &#39;channelId&#39;.  Optionally specify an
        // &#39;enqueueWatermark&#39; to fail if the write queue already has more than
        // &#39;enqueueWatermark&#39; bytes.  Return 0 on success, and a non-zero value
        // otherwise.  On error, the return value *may* equal to one of the
        // enumerators in &#39;ChannelStatus::Enum&#39;.  If the error is a transient
        // failure resulting from an overfull output queue, a high-water
        // callback will be scheduled immediately, and a low-watermark callback
        // will be scheduled to be called when the queue has drained enough to
        // accept more data.  These callbacks may be delivered to a different
        // thread before this call returns.

                                  // *** Clock management ***

    int registerClock(const bsl::function&lt;void()&gt;&amp; command,
                      const bsls::TimeInterval&amp;    startTime,
                      const bsls::TimeInterval&amp;    period,
                      int                          clockId);
    int registerClock(const bsl::function&lt;void()&gt;&amp; command,
                      const bsls::TimeInterval&amp;    startTime,
                      const bsls::TimeInterval&amp;    period,
                      int                          clockId,
                      int                          channelId);
        // Register the specified &#39;command&#39; to be invoked after the specified
        // &#39;startTime&#39; absolute time and associate this registration with the
        // specified &#39;clockId&#39;.  If the specified &#39;period&#39; (relative time) is
        // positive, repeat invoking &#39;command&#39; at &#39;period&#39; intervals until the
        // clock is deregistered, otherwise a single &#39;command&#39; will be invoked.
        // Optionally specify &#39;channelId&#39; to indicate that the clock must be
        // executed in the same event manager as the &#39;channelId&#39; callbacks.
        // Return 0 on success and a non-zero value otherwise; the return value
        // of 1 is indicates that a clock with the specified &#39;clockId&#39; is
        // already registered.  Note that if &#39;channelId&#39; is provided and does
        // not correspond to an active channel, a non-zero value not equal to 1
        // is returned, even if a clock with the specified &#39;clockId&#39; is already
        // registered.

    void deregisterClock(int clockId);
        // Deregister the clock having the specified &#39;clockId&#39;.

                                  // *** Socket Options ***

    int getLingerOption(btlso::SocketOptUtil::LingerData *result,
                        int                               channelId) const;
        // Load into the specified &#39;result&#39;, the value of the linger option for
        // the channel having the specified &#39;channelId&#39;.  Return 0 on success
        // and a non-zero value otherwise.  The behavior is undefined if
        // &#39;result&#39; is 0.

    int getServerSocketOption(int *result,
                              int  option,
                              int  level,
                              int  serverId) const;
        // Load into the specified &#39;result&#39; the value of the specified &#39;option&#39;
        // of the specified &#39;level&#39; socket option on the server socket having
        // the specified &#39;serverId&#39;.  Return 0 on success and a non-zero value
        // otherwise.  (See &#39;btlso::SocketOptUtil&#39; for the set of commonly-used
        // options.)

    int getSocketOption(int *result,
                        int  option,
                        int  level,
                        int  channelId) const;
        // Load into the specified &#39;result&#39; the value of the specified &#39;option&#39;
        // of the specified &#39;level&#39; socket option on the channel having the
        // specified &#39;channelId&#39;.  Return 0 on success and a non-zero value
        // otherwise.  (See &#39;btlso::SocketOptUtil&#39; for the set of commonly-used
        // options.)

    int setLingerOption(const btlso::SocketOptUtil::LingerData&amp; value,
                        int                                     channelId);
        // Set the linger option on the channel with the specified &#39;channelId&#39;
        // to the specified &#39;value&#39;.  Return 0 on success and a non-zero value
        // otherwise.

    int setServerSocketOption(int option, int level, int value, int serverId);
        // Set the specified &#39;option&#39; (of the specified &#39;level&#39;) socket option
        // on the listening socket with the specified &#39;serverId&#39; to the
        // specified &#39;value&#39;.  Return 0 on success and a non-zero value
        // otherwise.  (See &#39;btlso_socketoptutil&#39; for the list of commonly
        // supported options.)

    int setSocketOption(int option, int level, int value, int channelId);
        // Set the specified &#39;option&#39; (of the specified &#39;level&#39;) socket option
        // on the channel with the specified &#39;channelId&#39; to the specified
        // &#39;value&#39;.  Return 0 on success and a non-zero value otherwise.  (See
        // &#39;btlso_socketoptutil&#39; for the list of commonly supported options.)

                                  // *** Metrics ***

    double reportWeightedAverageReset();
        // Return the weighted average of the connections lifetime since the
        // previous call to this method or, for the first call, since this
        // object construction, if at least one millisecond passed since then,
        // otherwise return -1.  If all the connections at the time of the call
        // have been up during the considered period of time and were already
        // up at the time of the previous reset, this method will return the
        // same number as &#39;numChannels()&#39;.  0 means that they were all down.

    void totalBytesReadReset(bsls::Types::Int64 *result);
        // Load, into the specified &#39;result&#39;, and atomically reset the total
        // number of bytes read by the pool.

    void totalBytesWrittenReset(bsls::Types::Int64 *result);
        // Load, into the specified &#39;result&#39;, and atomically reset the total
        // number of bytes written by the pool.

    void totalBytesRequestedToBeWrittenReset(bsls::Types::Int64 *result);
        // Load, into the specified &#39;result&#39;, and atomically reset the total
        // number of bytes requested to be written by the pool.

    // ACCESSORS
    int busyMetrics() const;
        // Return the (percent) value in the range [0..100] (inclusive) that
        // reflects the workload of this channel pool (e.g., how busy it is for
        // the last period).  If the &#39;collectTimeMetrics&#39; property of the
        // configuration supplied at construction is &#39;false&#39; (i.e., the
        // collection of time metrics has been disable), then the returned
        // value is unspecified.  The value 0 indicates that the pool is idle
        // and 100 indicates that pool operates at the configured capacity.

    void *channelContext(int channelId) const;
        // Return a user-defined channel context associated with the specified
        // &#39;channelId&#39;, and &#39;(void *)0&#39; if no such channel exists or the user
        // context for this channel was explicitly set to &#39;(void *)0&#39;.

    int getChannelStatistics(bsls::Types::Int64 *numRead,
                             bsls::Types::Int64 *numRequestedToBeWritten,
                             bsls::Types::Int64 *numWritten,
                             int                 channelId) const;
        // Load into the specified &#39;numRead&#39;, &#39;numRequestedToBeWritten&#39; and
        // &#39;numWritten&#39; respectively the number of bytes read, requested to be
        // written and written by the channel identified by the specified
        // &#39;channelId&#39; and return 0 if the specified &#39;channelId&#39; is a valid
        // channel id.  Otherwise, return a non-zero value.  Note that for
        // performance reasons this *sequence* is not captured atomically: by
        // the time one of the values is captured, another may already have
        // changed.
    
    int getChannelWriteQueueStatistics(int *recordedMaxWriteQueueSize,
                                       int *currentWriteQueueSize,
                                       int  channelId) const;
        // Load into the specified &#39;recordedMaxWriteQueueSize&#39; and
        // &#39;currentWriteQueueSize&#39; the maximum and current size respectively of
        // the write queue of the channel identified by the specified
        // &#39;channelId&#39; and return 0 if the specified &#39;channelId&#39; is a valid
        // channel id.  Otherwise, return a non-zero value.  Note that for
        // performance reasons this *sequence* is not captured atomically: by
        // the time one of the values is captured, another may already have
        // changed.

    void getHandleStatistics(bsl::vector&lt;HandleInfo&gt; *handleInfo) const;
        // Append to the specified &#39;handleInfo&#39; array a snapshot of the
        // information per socket handle currently in use by this channel pool.
        // Note that a socket handle &#39;fd&#39; is in use for one of five possible
        // reasons:
        //..
        //  Reason                               d_channelType      d_userId
        //  ------                               -------------      --------
        //  1. This channel pool is listening    LISTENING_CHANNEL  serverId
        //     on &#39;fd&#39;, with a given &#39;serverId&#39;
        //
        //  2. A channel was created as the      ACCEPTED_CHANNEL   serverId
        //     result of a connection to the
        //     server with the given &#39;serverId&#39;
        //
        //  3. This channel pool is connecting   CONNECTING_CHANNEL sourceId
        //     using a connection socket with
        //     the socket handle &#39;fd&#39;, with a
        //     a given &#39;sourceId&#39;
        //
        //  4. A channel was created as the      CONNECTED_CHANNEL  sourceId
        //     result of a call to &#39;connect&#39;
        //     with the given &#39;sourceId&#39;
        //
        //  5. A channel was created as the      IMPORTED_CHANNEL   sourceId
        //     result of a call to &#39;import&#39;
        //     with the given &#39;sourceId&#39;
        //..
        // Also note that there is no specified order in which &#39;handleInfo&#39; is
        // updated.  Finally note that entries are appended to &#39;handleInfo&#39;;
        // clear this vector prior to calling this function if desired.

    int getServerAddress(btlso::IPv4Address *result, int serverId) const;
        // Load into the specified &#39;result&#39; the complete IP address associated
        // with the server with the specified &#39;serverId&#39; that is managed by
        // this channel pool if the server is established.  Return 0 on
        // success, and a non-zero value with no effect on &#39;result&#39; otherwise.

    int getLocalAddress(btlso::IPv4Address *result, int channelId) const;
        // Load into the specified &#39;result&#39; the complete IP address associated
        // with the local (i.e., this process) end-point of the communication
        // channel having the specified &#39;channelId&#39;.  Return 0 on success, and
        // a non-zero value with no effect on &#39;result&#39; otherwise.

    int getPeerAddress(btlso::IPv4Address *result, int channelId) const;
        // Load into the specified &#39;result&#39; the complete IP address associated
        // with the remote (i.e., peer process) end-point of the communication
        // channel having the specified &#39;channelId&#39;.  Return 0 on success, and
        // a non-zero value with no effect on &#39;result&#39; otherwise.

    int numBytesRead(bsls::Types::Int64 *result, int channelId) const;
        // Load, into the specified &#39;result&#39;, the number of bytes read by the
        // channel identified by the specified &#39;channelId&#39; and return 0 if the
        // specified &#39;channelId&#39; is a valid channel id.  Otherwise, return a
        // non-zero value.

    int numBytesWritten(bsls::Types::Int64 *result, int channelId) const;
        // Load, into the specified &#39;result&#39;, the number of bytes written by
        // the channel identified by the specified &#39;channelId&#39; and return 0 if
        // the specified &#39;channelId&#39; is a valid channel id.  Otherwise, return
        // a non-zero value.

    int numBytesRequestedToBeWritten(bsls::Types::Int64 *result,
                                     int                 channelId) const;
        // Load, into the specified &#39;result&#39;, the number of bytes requested to
        // be written by the channel identified by the specified &#39;channelId&#39;
        // and return 0 if the specified &#39;channelId&#39; is a valid channel id.
        // Otherwise, return a non-zero value.

    int numChannels() const;
        // Return the number of channels currently managed by this channel
        // pool.

    int numEvents(int index) const;
        // Return the number of events currently registered with an event
        // manager corresponding to the specified &#39;index&#39;.  The behavior is
        // undefined unless &#39;0 &lt;= index &lt; numThreads&#39;.

    int numThreads() const;
        // Return the number of threads currently managed by this channel pool.
        // Note that each thread corresponds to a single event manager, and,
        // therefore, the number of threads is the number of active event
        // managers.

    bsl::shared_ptr&lt;const btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                             streamSocket(int channelId) const;
        // Return a shared pointer to the non-modifiable stream socket
        // associated with the specified &#39;channelId&#39;, and an empty shared
        // pointer if a corresponding channel does not exist.  The returned
        // shared pointer is aliased to the underlying channel and the channel
        // will not be closed until this shared pointer is destroyed.
        // Therefore, it is important that clients carefully manage the
        // lifetime of the returned shared pointer.  The behavior of this
        // channel pool is undefined if the underlying socket is manipulated
        // while still under management by this channel pool.

    void totalBytesRead(bsls::Types::Int64 *result) const;
        // Load, into the specified &#39;result&#39;, the total number of bytes read by
        // the pool.

    void totalBytesRequestedToBeWritten(bsls::Types::Int64 *result) const;
        // Load, into the specified &#39;result&#39;, the total number of bytes
        // requested to be written by the pool.

    void totalBytesWritten(bsls::Types::Int64 *result) const;
        // Load, into the specified &#39;result&#39;, the total number of bytes written
        // by the pool.



};

                 // ============================
                 // class ChannelPool_IovecArray
                 // ============================

template &lt;class IOVEC&gt;
class ChannelPool_IovecArray {
    // This is an implementation type of &#39;ChannelPool&#39; and should not be used
    // by clients of this component.  An &#39;IovecArray&#39; is an in-core
    // value-semantic type describing a array of iovec objects of templatized
    // type &#39;IOVEC&#39;.  The parameterized &#39;IOVEC&#39; type must be either
    // &#39;bteso::Iovec&#39; or &#39;btls::Ovec&#39;.  Note that the each &#39;IOVEC&#39; object in
    // the &#39;iovecs()&#39; array refers to an array of data, so an &#39;IovecArray&#39; is
    // an array of arrays, and the total data length of an &#39;IovecArray&#39; is the
    // sum of the lengths of the &#39;IOVEC&#39; objects in &#39;iovecs()&#39;.

    // DATA
    const IOVEC        *d_iovecs;       // array of iovecs
    int                 d_numIovecs;    // number of iovecs
    bsls::Types::Int64  d_totalLength;  // total data length

    public:

    // CREATORS
    ChannelPool_IovecArray(const IOVEC *iovecs, int numIovecs);
        // Create an &#39;IovecArray&#39; object for the specified array of &#39;iovecs&#39; of
        // length &#39;numIovecs&#39;.

    // ~ChannelPool_IovecArray();
        // Destroy this array of iovec objects.  Note that this operation is
        // supplied by the compiler.

    ChannelPool_IovecArray(const ChannelPool_IovecArray&amp; original);
        // Create an iovec array with the same value as the specified original.

    // MANIPULATORS
    ChannelPool_IovecArray&amp; operator=(const ChannelPool_IovecArray&amp; rhs);
        // Assign this iovec array the value of the specified &#39;rhs&#39;, and return
        // a reference to this modifiable iovec array.

    // ACCESSORS
    const IOVEC *iovecs() const;
        // Return the array of &#39;IOVEC&#39; objects.  Note that each &#39;IOVEC&#39; object
        // in the returned array refers to an array of data.

    int numIovecs() const;
        // Return the length of the array of &#39;IOVEC&#39; objects returned by
        // &#39;iovecs()&#39;.

    bsls::Types::Int64 length() const;
        // Return the total length, in bytes, of the data referred to by
        // &#39;IOVEC&#39; objects in the &#39;iovecs()&#39; array of &#39;IOVEC&#39; objects.
};

// FREE OPERATORS
template &lt;class IOVEC&gt;
inline
bool operator==(const ChannelPool_IovecArray&lt;IOVEC&gt; &amp;lhs,
                const ChannelPool_IovecArray&lt;IOVEC&gt; &amp;rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iovec arrays have the
    // same value, and &#39;false&#39; otherwise.  Two iovec arrays have the same value
    // if their respective array addresses, array lengths, and total data
    // lengths are the same.

template &lt;class IOVEC&gt;
inline
bool operator!=(const ChannelPool_IovecArray&lt;IOVEC&gt; &amp;lhs,
                const ChannelPool_IovecArray&lt;IOVEC&gt; &amp;rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iovec arrays do not have
    // the same value, and &#39;false&#39; otherwise.  Two iovec arrays do not have the
    // same value if their respective array addresses, array lengths, or total
    // data lengths are not the name.

                 // =============================
                 // class ChannelPool_MessageUtil
                 // =============================

struct ChannelPool_MessageUtil {
    // This is an implementation type of &#39;ChannelPool&#39; and should not be used
    // by clients of this component.  The &#39;ChannelPool_MessageUtil&#39; struct
    // provides a namespace for a set of common functions that can be applied
    // to the different message container types supported by a &#39;ChannelPool&#39;.

    // PUBLIC CONSTANTS
    enum {
        // This enumeration defines the constant &#39;e_MAX_IOVEC_SIZE&#39;, which is
        // used to indicate the maximum length of an array of iovecs that can
        // be directly read from or written to a socket.  Note that &#39;IOV_MAX&#39;
        // is defined (on POSIX unix platforms) in &quot;limits.h&quot;, and indicates
        // the maximum number of iovecs that can be supplied to &#39;writev&#39;.

#ifdef BSLS_PLATFORM_OS_UNIX
#ifdef IOV_MAX
#if IOV_MAX &gt; 32
// If too big, this would make &#39;Channel&#39; really big.
        e_MAX_IOVEC_SIZE = 32


#else
        e_MAX_IOVEC_SIZE = IOV_MAX


#endif
#else
        e_MAX_IOVEC_SIZE = 16


#endif
#else // Windows
        e_MAX_IOVEC_SIZE = 16


#endif
     };

    // CLASS METHODS
    template &lt;class IOVEC&gt;
    static bsls::Types::Int64 length(const ChannelPool_IovecArray&lt;IOVEC&gt;&amp; msg);
    static bsls::Types::Int64 length(const btlb::Blob&amp;                    msg);
        // Return the length of the specified &#39;msg&#39;.

    template &lt;class IOVEC&gt;
    static int write(btlso::StreamSocket&lt;btlso::IPv4Address&gt; *socket,
                     btls::Iovec                             *temp,
                     const ChannelPool_IovecArray&lt;IOVEC&gt;&amp;     msg);
    static int write(btlso::StreamSocket&lt;btlso::IPv4Address&gt; *socket,
                     btls::Iovec                             *temp,
                     const btlb::Blob&amp;                        msg);
        // Write, to the specified &#39;socket&#39;, the buffers in the specified
        // &#39;msg&#39;, up to &#39;e_MAX_IOVEC_SIZE&#39; buffers, using the specified &#39;temp&#39;
        // array of iovec objects as a (temporary) intermediary for
        // &#39;StreamSocket::writev&#39; (if required).  Return the return value from
        // &#39;StreamSocket::writev&#39;.

    static int loadIovec(btls::Iovec *dest, const btlb::Blob&amp; msg);
        // Load into the specified &#39;dest&#39; iovec the data buffers from the
        // specified &#39;msg&#39;, up to &#39;e_MAX_IOVEC_SIZE&#39; buffers.  Return the
        // number of buffers loaded into &#39;dest&#39;.

    template &lt;class IOVEC&gt;
    static int loadBlob(btlb::Blob                           *dest,
                        const ChannelPool_IovecArray&lt;IOVEC&gt;&amp;  msg,
                        int                                   msgOffset);
    static int loadBlob(btlb::Blob                           *dest,
                        const btlb::Blob&amp;                     msg,
                        int                                   msgOffset);
        // Load into the specified &#39;dest&#39; the data in the specified &#39;msg&#39;
        // starting at the specified &#39;msgOffset&#39;.  For performance reasons the
        // first blob buffer added to &#39;dest&#39; may start *before* the &#39;msgOffset&#39;
        // byte in &#39;msg&#39;; return the offset into the first blob buffer in
        // &#39;dest&#39; of the corresponding &#39;msgOffset&#39; byte in &#39;msg&#39;.  The behavior
        // is undefined unless &#39;dest&#39; is empty.

    template &lt;class IOVEC&gt;
    static void appendToBlob(btlb::Blob                           *dest,
                             const ChannelPool_IovecArray&lt;IOVEC&gt;&amp;  msg);
    static void appendToBlob(btlb::Blob                           *dest,
                             const btlb::Blob&amp;                     msg);
        // Append, to the specified &#39;dest&#39; blob, the data buffers in the
        // specified &#39;msg&#39;.  The behavior is undefined unless the last buffer
        // in &#39;dest&#39; is trimmed.
};

// ============================================================================
//                          INLINE FUNCTION DEFINITIONS
// ============================================================================

                       //------------------
                       // class ChannelPool
                       //------------------

// PRIVATE ACCESSORS
inline
int ChannelPool::findChannelHandle(ChannelHandle *handle, int channelId) const
{
    if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(
                                       0 == d_channels.find(channelId, handle))
     &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_LIKELY(*handle)) {
        return 0;                                                     // RETURN
    }
    BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
    return 1;
}

// MANIPULATORS
inline
int ChannelPool::write(int channelId, const btlb::Blob&amp; message)
{
    return write(channelId, message, 0x7FFFFFFF);
}

inline
int ChannelPool::connect(const btlso::IPv4Address&amp;   serverAddress,
                         int                         numAttempts,
                         const bsls::TimeInterval&amp;   interval,
                         int                         sourceId,
                         bool                        readEnabledFlag,
                         KeepHalfOpenMode            mode,
                         const btlso::SocketOptions *socketOptions,
                         const btlso::IPv4Address   *localAddress)
{
    return connectImp(serverAddress,
                      numAttempts,
                      interval,
                      sourceId,
                      0,
                      readEnabledFlag,
                      mode,
                      socketOptions,
                      localAddress);
}

inline
int ChannelPool::connect(const char                 *hostname,
                         int                         portNumber,
                         int                         numAttempts,
                         const bsls::TimeInterval&amp;   interval,
                         int                         sourceId,
                         ConnectResolutionMode       resolutionMode,
                         bool                        readEnabledFlag,
                         KeepHalfOpenMode            halfCloseMode,
                         const btlso::SocketOptions *socketOptions,
                         const btlso::IPv4Address   *localAddress)
{
    return connectImp(hostname,
                      portNumber,
                      numAttempts,
                      interval,
                      sourceId,
                      0,
                      resolutionMode,
                      readEnabledFlag,
                      halfCloseMode,
                      socketOptions,
                      localAddress);
}

inline
btlb::BlobBufferFactory *ChannelPool::incomingBlobBufferFactory()
{
    return d_readBlobFactory.ptr();
}

inline
btlb::BlobBufferFactory *ChannelPool::outboundBlobBufferFactory()
{
    return d_writeBlobFactory.ptr();
}

// ACCESSORS
inline
int ChannelPool::busyMetrics() const
{
    return bsls::AtomicOperations::getInt(&amp;d_capacity);
}

inline
int ChannelPool::numChannels() const
{
    return d_channels.length();
}

inline
int ChannelPool::numThreads() const
{
    return d_startFlag ? static_cast&lt;int&gt;(d_managers.size()) : 0;
}

                 // ----------------------------
                 // class ChannelPool_IovecArray
                 // ----------------------------

// CREATORS
template &lt;class IOVEC&gt;
inline
ChannelPool_IovecArray&lt;IOVEC&gt;::ChannelPool_IovecArray(const IOVEC *iovecs,
                                                      int          numIovecs)
: d_iovecs(iovecs)
, d_numIovecs(numIovecs)
, d_totalLength(btls::IovecUtil::length(iovecs, numIovecs))
{
}

template &lt;class IOVEC&gt;
inline
ChannelPool_IovecArray&lt;IOVEC&gt;::ChannelPool_IovecArray(
                                        const ChannelPool_IovecArray&amp; original)
: d_iovecs(original.d_iovecs)
, d_numIovecs(original.d_numIovecs)
, d_totalLength(original.d_totalLength)
{
}

// MANIPULATORS
template &lt;class IOVEC&gt;
inline
ChannelPool_IovecArray&lt;IOVEC&gt;&amp;
ChannelPool_IovecArray&lt;IOVEC&gt;::operator=(const ChannelPool_IovecArray&amp; rhs)
{
    d_iovecs      = rhs.d_iovecs;
    d_numIovecs   = rhs.d_numIovecs;
    d_totalLength = rhs.d_totalLength;
    return *this;
}

// ACCESSORS
template &lt;class IOVEC&gt;
inline
bsls::Types::Int64
ChannelPool_IovecArray&lt;IOVEC&gt;::length() const
{
    return d_totalLength;
}

template &lt;class IOVEC&gt;
inline
const IOVEC *
ChannelPool_IovecArray&lt;IOVEC&gt;::iovecs() const
{
    return d_iovecs;
}

template &lt;class IOVEC&gt;
inline
int ChannelPool_IovecArray&lt;IOVEC&gt;::numIovecs() const
{
    return d_numIovecs;
}

                 // -----------------------------
                 // class ChannelPool_MessageUtil
                 // -----------------------------

// CLASS METHODS
inline
bsls::Types::Int64
ChannelPool_MessageUtil::length(const btlb::Blob&amp; msg)
{
    return msg.length();
}

template &lt;class IOVEC&gt;
inline
bsls::Types::Int64
ChannelPool_MessageUtil::length(const ChannelPool_IovecArray&lt;IOVEC&gt;&amp; msg)
{
    return msg.length();
}

template &lt;class IOVEC&gt;
inline
int ChannelPool_MessageUtil::write(
                               btlso::StreamSocket&lt;btlso::IPv4Address&gt; *socket,
                               btls::Iovec                             *,
                               const ChannelPool_IovecArray&lt;IOVEC&gt;&amp;     msg)
{
    int minNumVecs = msg.numIovecs();
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(minNumVecs &gt; e_MAX_IOVEC_SIZE)) {
        minNumVecs = e_MAX_IOVEC_SIZE;
    }

    return socket-&gt;writev(msg.iovecs(), minNumVecs);
}

inline
int ChannelPool_MessageUtil::write(
                               btlso::StreamSocket&lt;btlso::IPv4Address&gt; *socket,
                               btls::Iovec                             *temp,
                               const btlb::Blob&amp;                        msg)
{
    int numVecs = loadIovec(temp, msg);
    BSLS_ASSERT(0 &lt; numVecs);
    return socket-&gt;writev(temp, numVecs);
}

template &lt;class IOVEC&gt;
inline
int ChannelPool_MessageUtil::loadBlob(
                               btlb::Blob                           *dest,
                               const ChannelPool_IovecArray&lt;IOVEC&gt;&amp;  msg,
                               int                                   msgOffset)
{
    btls::IovecUtil::appendToBlob(dest,
                                  msg.iovecs(),
                                  msg.numIovecs(),
                                  msgOffset);

    BSLS_ASSERT(dest-&gt;length() == msg.length() - msgOffset);
    return 0;
}

template &lt;class IOVEC&gt;
inline
void ChannelPool_MessageUtil::appendToBlob(
                                    btlb::Blob                           *dest,
                                    const ChannelPool_IovecArray&lt;IOVEC&gt;&amp;  msg)
{
    btls::IovecUtil::appendToBlob(dest, msg.iovecs(), msg.numIovecs());
}



}  // close package namespace

// FREE OPERATORS
template &lt;class IOVEC&gt;
inline
bool btlmt::operator==(const ChannelPool_IovecArray&lt;IOVEC&gt; &amp;lhs,
                       const ChannelPool_IovecArray&lt;IOVEC&gt; &amp;rhs)
{
    return lhs.iovecs()    == rhs.iovecs()
        &amp;&amp; lhs.numIovecs() == rhs.numIovecs()
        &amp;&amp; lhs.length()    == rhs.length();
}

template &lt;class IOVEC&gt;
inline
bool btlmt::operator!=(const ChannelPool_IovecArray&lt;IOVEC&gt; &amp;lhs,
                       const ChannelPool_IovecArray&lt;IOVEC&gt; &amp;rhs)
{
    return !(lhs == rhs);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
