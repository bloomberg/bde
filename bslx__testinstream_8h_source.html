<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslx_testinstream.h                                                -*-C++-*-
#ifndef INCLUDED_BSLX_TESTINSTREAM
#define INCLUDED_BSLX_TESTINSTREAM

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Enable unexternalization of fundamental types with identification.
//
//@CLASSES:
//  bslx::TestInStream: byte-array-based input stream class
//
//@MACROS:
//  BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN: macro to begin testing exceptions
//  BSLX_TESTINSTREAM_EXCEPTION_TEST_END: macro to end testing exceptions
//
//@SEE_ALSO: bslx_testoutstream, bslx_byteinstream
//
//@DESCRIPTION: This component implements a byte-array-based input stream
// class, &#39;bslx::TestInStream&#39;, that provides platform-independent input
// methods (&quot;unexternalization&quot;) on values, and arrays of values, of
// fundamental types, and on &#39;bsl::string&#39;.  &#39;bslx::TestInStream&#39; also
// verifies, for these types, that the type of data requested from the stream
// matches what was written to the stream.  &#39;bslx::TestInStream&#39; is meant for
// testing only.
//
// The &#39;bslx::TestInStream&#39; type reads from a user-supplied buffer directly,
// with no data copying or assumption of ownership.  The user must therefore
// make sure that the lifetime and visibility of the buffer is sufficient to
// satisfy the needs of the input stream.
//
// This component is intended to be used in conjunction with the
// &#39;bslx_testoutstream&#39; externalization component.  Each input method of
// &#39;bslx::TestInStream&#39; reads either a value or a homogeneous array of values
// of a fundamental type, in a format that was written by the corresponding
// &#39;bslx::TestOutStream&#39; method.  In general, the user of this component cannot
// rely on being able to read data that was written by any mechanism other than
// &#39;bslx::TestOutStream&#39;.
//
// The supported types and required content are listed in the &#39;bslx&#39;
// package-level documentation under &quot;Supported Types&quot;.
//
// Note that input streams can be *invalidated* explicitly and queried for
// *validity* and *emptiness*.  Reading from an initially invalid stream has no
// effect.  Attempting to read beyond the end of a stream will automatically
// invalidate the stream.  Whenever an inconsistent value is detected, the
// stream should be invalidated explicitly.
//
///Input Limit
///-----------
// If exceptions are enabled at compile time, the test input stream can be
// configured to throw an exception after a specified number of input requests
// is exceeded.  If the input limit is less than zero (default), then the
// stream never throws an exception.  Note that a non-negative input limit is
// decremented after each input attempt, and throws only when the current input
// limit transitions from 0 to -1; no additional exceptions will be thrown
// until the input limit is again reset to a non-negative value.
//
// The input limit is set using the &#39;setInputLimit&#39; manipulator.
//
///Exception Test Macros
///---------------------
// This component also provides a pair of macros:
//
//: o &#39;BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN(testInStream)&#39;
//: o &#39;BSLX_TESTINSTREAM_EXCEPTION_TEST_END&#39;
//
// These macros can be used for testing exception-safety of classes and their
// methods when BDEX streaming is involved.  A reference to an object of type
// &#39;bslx::TestInStream&#39; must be supplied as an argument to the &#39;*_BEGIN&#39; macro.
// Note that if exception-handling is disabled (i.e., if
// &#39;-DBDE_BUILD_TARGET_EXC&#39; was *not* supplied at compile time), then the
// macros simply print the following:
//..
//  BSLX EXCEPTION TEST -- (NOT ENABLED) --
//..
// When exception-handling is enabled (i.e., if &#39;-DBDE_BUILD_TARGET_EXC&#39; was
// supplied at compile time), the &#39;*_BEGIN&#39; macro will set the input limit of
// the supplied instream to 0, &#39;try&#39; the code being tested, &#39;catch&#39; any
// &#39;TestInstreamException&#39;s that are thrown, and keep increasing the input
// limit until the code being tested completes successfully.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Unexternalization Test
///- - - - - - - - - - - - - - - - - - - -
// Suppose we wish to implement a (deliberately simple) &#39;MyPerson&#39; class as a
// value-semantic object that supports BDEX externalization and
// unexternalization.  In addition to whatever data and methods that we choose
// to put into our design, we must supply three methods having specific names
// and signatures in order to comply with the BDEX protocol: a class method
// &#39;maxSupportedBdexVersion&#39;, an accessor (i.e., a &#39;const&#39; method)
// &#39;bdexStreamOut&#39;, and a manipulator (i.e., a non-&#39;const&#39; method)
// &#39;bdexStreamIn&#39;.  This example shows how to implement those three methods.
//
// In this example we will not worry overly about &quot;good design&quot; of the
// &#39;MyPerson&#39; component, and we will declare but not implement illustrative
// methods and free operators, except for the three required BDEX methods,
// which are implemented in full.  In particular, we will not make explicit use
// of &#39;bslma&#39; allocators; a more complete design would do so:
//
// First, we implement &#39;MyPerson&#39;:
//..
//  class MyPerson {
//      bsl::string d_firstName;
//      bsl::string d_lastName;
//      int         d_age;
//
//      friend bool operator==(const MyPerson&amp;, const MyPerson&amp;);
//
//    public:
//      // CLASS METHODS
//      static int maxSupportedBdexVersion(int versionSelector);
//          // Return the maximum valid BDEX format version, as indicated by
//          // the specified &#39;versionSelector&#39;, to be passed to the
//          // &#39;bdexStreamOut&#39; method.  Note that it is highly recommended that
//          // &#39;versionSelector&#39; be formatted as &quot;YYYYMMDD&quot;, a date
//          // representation.  Also note that &#39;versionSelector&#39; should be a
//          // *compile*-time-chosen value that selects a format version
//          // supported by both externalizer and unexternalizer.  See the
//          // &#39;bslx&#39; package-level documentation for more information on BDEX
//          // streaming of value-semantic types and containers.
//
//      // CREATORS
//      MyPerson();
//          // Create a default person.
//
//      MyPerson(const char *firstName, const char *lastName, int age);
//          // Create a person having the specified &#39;firstName&#39;, &#39;lastName&#39;,
//          // and &#39;age&#39;.
//
//      MyPerson(const MyPerson&amp; original);
//          // Create a person having the value of the specified &#39;original&#39;
//          // person.
//
//      ~MyPerson();
//          // Destroy this object.
//
//      // MANIPULATORS
//      MyPerson&amp; operator=(const MyPerson&amp; rhs);
//          // Assign to this person the value of the specified &#39;rhs&#39; person,
//          // and return a reference to this person.
//
//      template &lt;class STREAM&gt;
//      STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
//          // Assign to this object the value read from the specified input
//          // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
//          // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
//          // operation has no effect.  If &#39;version&#39; is not supported, this
//          // object is unaltered and &#39;stream&#39; is invalidated, but otherwise
//          // unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes
//          // invalid during this operation, this object has an undefined, but
//          // valid, state.  Note that no version is read from &#39;stream&#39;.  See
//          // the &#39;bslx&#39; package-level documentation for more information on
//          // BDEX streaming of value-semantic types and containers.
//
//      //...
//
//      // ACCESSORS
//      const bsl::string&amp; firstName() const;
//          // Return the first name of this person.
//
//      const bsl::string&amp; lastName() const;
//          // Return the last name of this person.
//
//      int age() const;
//          // Return the age of this person.
//
//      template &lt;class STREAM&gt;
//      STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
//          // Write the value of this object, using the specified &#39;version&#39;
//          // format, to the specified output &#39;stream&#39;, and return a reference
//          // to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation
//          // has no effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is
//          // invalidated, but otherwise unmodified.  Note that &#39;version&#39; is
//          // not written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level
//          // documentation for more information on BDEX streaming of
//          // value-semantic types and containers.
//
//      //...
//
//  };
//
//  // FREE OPERATORS
//  bool operator==(const MyPerson&amp; lhs, const MyPerson&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects have
//      // the same value, and &#39;false&#39; otherwise.  Two person objects have the
//      // same value if they have the same first name, last name, and age.
//
//  bool operator!=(const MyPerson&amp; lhs, const MyPerson&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects do not
//      // have the same value, and &#39;false&#39; otherwise.  Two person objects
//      // differ in value if they differ in first name, last name, or age.
//
//  bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const MyPerson&amp; person);
//      // Write the specified &#39;person&#39; value to the specified output &#39;stream&#39;
//      // in some reasonable format, and return a reference to &#39;stream&#39;.
//
//  // ========================================================================
//  //                  INLINE FUNCTION DEFINITIONS
//  // ========================================================================
//
//  // CLASS METHODS
//  inline
//  int MyPerson::maxSupportedBdexVersion(int /* versionSelector */) {
//      return 1;
//  }
//
//  // CREATORS
//  inline
//  MyPerson::MyPerson()
//  : d_firstName(&quot;&quot;)
//  , d_lastName(&quot;&quot;)
//  , d_age(0)
//  {
//  }
//
//  inline
//  MyPerson::MyPerson(const char *firstName, const char *lastName, int age)
//  : d_firstName(firstName)
//  , d_lastName(lastName)
//  , d_age(age)
//  {
//  }
//
//  inline
//  MyPerson::~MyPerson()
//  {
//  }
//
//  template &lt;class STREAM&gt;
//  STREAM&amp; MyPerson::bdexStreamIn(STREAM&amp; stream, int version)
//  {
//      if (stream) {
//          switch (version) {  // switch on the &#39;bslx&#39; version
//            case 1: {
//              stream.getString(d_firstName);
//              if (!stream) {
//                  d_firstName = &quot;stream error&quot;;  // *might* be corrupted;
//                                                 //  value for testing
//                  return stream;
//              }
//              stream.getString(d_lastName);
//              if (!stream) {
//                  d_lastName = &quot;stream error&quot;;  // *might* be corrupted;
//                                                //  value for testing
//                  return stream;
//              }
//              stream.getInt32(d_age);
//              if (!stream) {
//                  d_age = 999;     // *might* be corrupted; value for testing
//                  return stream;
//              }
//            } break;
//            default: {
//              stream.invalidate();
//            }
//          }
//      }
//      return stream;
//  }
//
//  // ACCESSORS
//  template &lt;class STREAM&gt;
//  STREAM&amp; MyPerson::bdexStreamOut(STREAM&amp; stream, int version) const
//  {
//      switch (version) {
//        case 1: {
//          stream.putString(d_firstName);
//          stream.putString(d_lastName);
//          stream.putInt32(d_age);
//        } break;
//        default: {
//          stream.invalidate();
//        } break;
//      }
//      return stream;
//  }
//..
// Then, we can exercise the new &#39;MyPerson&#39; value-semantic class by
// externalizing and reconstituting an object.  First, create a &#39;MyPerson&#39;
// &#39;janeSmith&#39; and a &#39;bslx::TestOutStream&#39; &#39;outStream&#39;:
//..
//  MyPerson janeSmith(&quot;Jane&quot;, &quot;Smith&quot;, 42);
//  bslx::TestOutStream outStream(20131127);
//  const int VERSION = 1;
//  outStream.putVersion(VERSION);
//  janeSmith.bdexStreamOut(outStream, VERSION);
//  assert(outStream.isValid());
//..
// Next, create a &#39;MyPerson&#39; &#39;janeCopy&#39; initialized to the default value, and
// assert that &#39;janeCopy&#39; is different from &#39;janeSmith&#39;:
//..
//  MyPerson janeCopy;
//  assert(janeCopy != janeSmith);
//..
// Then, create a &#39;bslx::TestInStream&#39; &#39;inStream&#39; initialized with the buffer
// from the &#39;bslx::TestOutStream&#39; object &#39;outStream&#39; and unexternalize this
// data into &#39;janeCopy&#39;:
//..
//  bslx::TestInStream inStream(outStream.data(), outStream.length());
//  int version;
//  inStream.getVersion(version);
//  janeCopy.bdexStreamIn(inStream, version);
//  assert(inStream.isValid());
//..
// Finally, &#39;assert&#39; the obtained values are as expected and display the
// results to &#39;bsl::stdout&#39;:
//..
//  assert(version  == VERSION);
//  assert(janeCopy == janeSmith);
//
//  if (janeCopy == janeSmith) {
//      bsl::cout &lt;&lt; &quot;Successfully serialized and de-serialized Jane Smith:&quot;
//                &lt;&lt; &quot;\n\tFirstName: &quot; &lt;&lt; janeCopy.firstName()
//                &lt;&lt; &quot;\n\tLastName : &quot; &lt;&lt; janeCopy.lastName()
//                &lt;&lt; &quot;\n\tAge      : &quot; &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
//  }
//  else {
//      bsl::cout &lt;&lt; &quot;Serialization unsuccessful.  &#39;janeCopy&#39; holds:&quot;
//                &lt;&lt; &quot;\n\tFirstName: &quot; &lt;&lt; janeCopy.firstName()
//                &lt;&lt; &quot;\n\tLastName : &quot; &lt;&lt; janeCopy.lastName()
//                &lt;&lt; &quot;\n\tAge      : &quot; &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLX_INSTREAMFUNCTIONS
#include &lt;bslx_instreamfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLX_TESTINSTREAMEXCEPTION
#include &lt;bslx_testinstreamexception.h&gt;
#endif

#ifndef INCLUDED_BSLX_TYPECODE
#include &lt;bslx_typecode.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace bslx {

                         // ==================
                         // class TestInStream
                         // ==================

class TestInStream {
    // This class provides input methods to unexternalize values, and C-style
    // arrays of values, of fundamental types from their byte representations.
    // Each input method also verifies the input value type.  By default, if
    // invalid data is detected, error messages are displayed on &#39;stdout&#39;; this
    // error reporting may be disabled via the &#39;setQuiet&#39; method.  Note that
    // attempting to read beyond the end of a stream will automatically
    // invalidate the stream.  See the &#39;bslx&#39; package-level documentation for
    // the definition of the BDEX &#39;InStream&#39; protocol.

    // DATA
    const char  *d_buffer;      // bytes to be unexternalized

    bsl::size_t  d_numBytes;    // number of bytes in &#39;d_buffer&#39;

    bool         d_validFlag;   // stream validity flag; &#39;true&#39; if stream is in
                                // valid state, &#39;false&#39; otherwise

    int          d_quietFlag;   // flag for &quot;quiet&quot; mode

    int          d_inputLimit;  // number of input op&#39;s before exception

    bsl::size_t  d_cursor;      // index of the next byte to be extracted from
                                // this stream

    // FRIENDS
    friend bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;, const TestInStream&amp;);

    // NOT IMPLEMENTED
    TestInStream(const TestInStream&amp;);
    TestInStream&amp; operator=(const TestInStream&amp;);

  private:
    // PRIVATE MANIPULATORS
    void checkArray(TypeCode::Enum code,
                    int            elementSize,
                    int            numElements);
        // Verify the validity of the type code and array length, and the
        // sufficiency of data at the current cursor position in the external
        // memory buffer.  Extract the type code at the cursor position from
        // the buffer.  If the type code does not correspond to the specified
        // &#39;code&#39;, then mark this stream as invalid, and if the quiet flag is
        // zero print an error message.  Otherwise, advance the cursor by the
        // size of the type code and extract the array length.  If the length
        // does not correspond to the specified &#39;numElements&#39;, then mark this
        // stream as invalid, and if the quiet flag is zero print an error
        // message.  Otherwise, advance the cursor by the size of the array
        // length, and verify that the buffer contains sufficient bytes for
        // &#39;numElements&#39; of the specified &#39;elementSize&#39;.  If there are too few
        // bytes in the buffer, then mark this stream as invalid.  If this
        // stream is invalid on entry, this function has no effect.  The
        // behavior is undefined unless &#39;0 &lt; elementSize&#39; and
        // &#39;0 &lt;= numElements&#39;.  Note that error messages are not printed for
        // insufficient data in the buffer.

    void checkTypeCodeAndAvailableLength(TypeCode::Enum code,
                                         bsl::size_t    numExpectedBytes);
        // Verify the validity of the type code and the sufficiency of data at
        // the current cursor position in the external memory buffer.  Extract
        // the type code at the cursor position from the buffer.  If the type
        // code does not correspond to the specified &#39;code&#39;, then mark this
        // stream as invalid and, if the quiet flag is zero, print an error
        // message.  Otherwise, advance the cursor position by the size of the
        // type code, and verify that the buffer contains sufficient bytes for
        // the specified &#39;numExpectedBytes&#39;.  If there are too few bytes, then
        // this stream is marked as invalid.  If this stream is invalid on
        // entry, this function has no effect.  The behavior is undefined
        // unless &#39;0 &lt; numExpectedBytes&#39;.  Also note that error messages are
        // not printed for insufficient data in the buffer.

    void throwExceptionIfInputLimitExhausted(const TypeCode::Enum&amp; code);
        // Decrement the internal input limit of this test stream.  If the
        // input limit becomes negative and exception-handling is enabled
        // (i.e., &#39;-DBDE_BUILD_TARGET_EXC&#39; was supplied at compile time), then
        // throw a &#39;TestInStreamException&#39; object initialized with the
        // specified type &#39;code&#39;.  If exception-handling is not enabled, this
        // method has no effect.

  public:
    // CREATORS
    explicit TestInStream();
        // Create an empty test input stream.  Note that the constructed object
        // is useless until a buffer is set with the &#39;reset&#39; method.

    TestInStream(const char *buffer, bsl::size_t numBytes);
        // Create a test input stream containing the specified initial
        // &#39;numBytes&#39; from the specified &#39;buffer&#39;.  The behavior is undefined
        // unless &#39;0 == numBytes&#39; if &#39;0 == buffer&#39;.

    explicit TestInStream(const bslstl::StringRef&amp; srcData);
        // Create a test input stream containing the specified &#39;srcData&#39;.

    ~TestInStream();
        // Destroy this test input stream.

    // MANIPULATORS
    TestInStream&amp; getLength(int&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 8-bit unsigned integer or 32-bit signed
        // integer value representing a length (see the &#39;bslx&#39; package-level
        // documentation) into the specified &#39;variable&#39; if its type is
        // appropriate, update the cursor location, and return a reference to
        // this stream.  Consume an 8-bit unsigned integer if the most
        // significant bit of this byte is 0, otherwise consume a 32-bit signed
        // integer and set the most significant bit to zero in the resultant
        // &#39;variable&#39;.  If the type is incorrect, then this stream is marked
        // invalid and the value of &#39;variable&#39; is unchanged.  If this stream is
        // initially invalid, this operation has no effect.  If this function
        // otherwise fails to extract a valid value, this stream is marked
        // invalid and the value of &#39;variable&#39; is undefined.

    TestInStream&amp; getVersion(int&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 8-bit unsigned integer value representing
        // a version (see the &#39;bslx&#39; package-level documentation) into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    void invalidate();
        // Put this input stream in an invalid state.  This function has no
        // effect if this stream is already invalid.  Note that this function
        // should be called whenever a value extracted from this stream is
        // determined to be invalid, inconsistent, or otherwise incorrect.

    void reset();
        // Set the index of the next byte to be extracted from this stream to 0
        // (i.e., the beginning of the stream) and validate this stream if it
        // is currently invalid.

    void reset(const char *buffer, bsl::size_t numBytes);
        // Reset this stream to extract from the specified &#39;buffer&#39; containing
        // the specified &#39;numBytes&#39;, set the index of the next byte to be
        // extracted to 0 (i.e., the beginning of the stream), and validate
        // this stream if it is currently invalid.  The behavior is undefined
        // unless &#39;0 == numBytes&#39; if &#39;0 == buffer&#39;.

    void reset(const bslstl::StringRef&amp; srcData);
        // Reset this stream to extract from the specified &#39;srcData&#39;, set the
        // index of the next byte to be extracted to 0 (i.e., the beginning of
        // the stream), and validate this stream if it is currently invalid.

    void seek(bsl::size_t offset);
        // Set the index of the next byte to be extracted from this stream to
        // the specified &#39;offset&#39; from the beginning of the stream, and
        // validate this stream if it is currently invalid.  The behavior is
        // undefined unless &#39;offset &lt;= length()&#39;.

    void setInputLimit(int limit);
        // Set the number of input operations allowed on this stream to the
        // specified &#39;limit&#39; before an exception is thrown.  If &#39;limit&#39; is less
        // than 0, no exception is to be thrown.  By default, no exception is
        // scheduled.

    void setQuiet(bool flagValue);
        // Set the quiet mode for this test stream to the specified (boolean)
        // &#39;flagValue&#39;.  If &#39;flagValue&#39; is &#39;true&#39;, then quiet mode is turned ON
        // and no error messages will be written to standard output.  If
        // &#39;flagValue&#39; is &#39;false&#39;, then quiet mode is turned OFF.  Note that
        // quiet mode is turned OFF by default.

                      // *** scalar integer values ***

    TestInStream&amp; getInt64(bsls::Types::Int64&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 64-bit signed integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getUint64(bsls::Types::Uint64&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 64-bit unsigned integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getInt56(bsls::Types::Int64&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 56-bit signed integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getUint56(bsls::Types::Uint64&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 56-bit unsigned integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getInt48(bsls::Types::Int64&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 48-bit signed integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getUint48(bsls::Types::Uint64&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 48-bit unsigned integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getInt40(bsls::Types::Int64&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 40-bit signed integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getUint40(bsls::Types::Uint64&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 40-bit unsigned integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getInt32(int&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 32-bit signed integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getUint32(unsigned int&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 32-bit unsigned integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getInt24(int&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 24-bit signed integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getUint24(unsigned int&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 24-bit unsigned integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getInt16(short&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 16-bit signed integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getUint16(unsigned short&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 16-bit unsigned integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getInt8(char&amp;        variable);
    TestInStream&amp; getInt8(signed char&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 8-bit signed integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

    TestInStream&amp; getUint8(char&amp;          variable);
    TestInStream&amp; getUint8(unsigned char&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 8-bit unsigned integer value into the
        // specified &#39;variable&#39; if its type is appropriate, update the cursor
        // location, and return a reference to this stream.  If the type is
        // incorrect, then this stream is marked invalid and the value of
        // &#39;variable&#39; is unchanged.  If this stream is initially invalid, this
        // operation has no effect.  If this function otherwise fails to
        // extract a valid value, this stream is marked invalid and the value
        // of &#39;variable&#39; is undefined.

                      // *** scalar floating-point values ***

    TestInStream&amp; getFloat64(double&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that IEEE double-precision (8-byte)
        // floating-point value into the specified &#39;variable&#39; if its type is
        // appropriate, update the cursor location, and return a reference to
        // this stream.  If the type is incorrect, then this stream is marked
        // invalid and the value of &#39;variable&#39; is unchanged.  If this stream is
        // initially invalid, this operation has no effect.  If this function
        // otherwise fails to extract a valid value, this stream is marked
        // invalid and the value of &#39;variable&#39; is undefined.  Note that for
        // non-conforming platforms, this operation may be lossy.

    TestInStream&amp; getFloat32(float&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that IEEE single-precision (4-byte)
        // floating-point value into the specified &#39;variable&#39; if its type is
        // appropriate, update the cursor location, and return a reference to
        // this stream.  If the type is incorrect, then this stream is marked
        // invalid and the value of &#39;variable&#39; is unchanged.  If this stream is
        // initially invalid, this operation has no effect.  If this function
        // otherwise fails to extract a valid value, this stream is marked
        // invalid and the value of &#39;variable&#39; is undefined.  Note that for
        // non-conforming platforms, this operation may be lossy.

                      // *** string values ***

    TestInStream&amp; getString(bsl::string&amp; variable);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume a string
        // from this input stream, assign that value to the specified
        // &#39;variable&#39;, update the cursor location, and return a reference to
        // this stream.  If this stream is initially invalid, this operation
        // has no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variable&#39; is
        // undefined.  The string must be prefaced by a non-negative integer
        // indicating the number of characters composing the string.  The
        // behavior is undefined unless the length indicator is non-negative.

                      // *** arrays of integer values ***

    TestInStream&amp; getArrayInt64(bsls::Types::Int64 *variables,
                                int                 numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 64-bit signed integer array value into the
        // specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its type
        // and length are appropriate, update the cursor location, and return a
        // reference to this stream.  If the type is incorrect, then this
        // stream is marked invalid and the value of &#39;variables&#39; is unchanged.
        // If this stream is initially invalid, this operation has no effect.
        // If this function otherwise fails to extract a valid value, this
        // stream is marked invalid and the value of &#39;variables&#39; is undefined.
        // The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39;
        // has sufficient capacity.

    TestInStream&amp; getArrayUint64(bsls::Types::Uint64 *variables,
                                 int                  numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 64-bit unsigned integer array value into
        // the specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its
        // type and length are appropriate, update the cursor location, and
        // return a reference to this stream.  If the type is incorrect, then
        // this stream is marked invalid and the value of &#39;variables&#39; is
        // unchanged.  If this stream is initially invalid, this operation has
        // no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variables&#39; is
        // undefined.  The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and
        // &#39;variables&#39; has sufficient capacity.

    TestInStream&amp; getArrayInt56(bsls::Types::Int64 *variables,
                                int                 numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 56-bit signed integer array value into the
        // specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its type
        // and length are appropriate, update the cursor location, and return a
        // reference to this stream.  If the type is incorrect, then this
        // stream is marked invalid and the value of &#39;variables&#39; is unchanged.
        // If this stream is initially invalid, this operation has no effect.
        // If this function otherwise fails to extract a valid value, this
        // stream is marked invalid and the value of &#39;variables&#39; is undefined.
        // The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39;
        // has sufficient capacity.

    TestInStream&amp; getArrayUint56(bsls::Types::Uint64 *variables,
                                 int                  numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 56-bit unsigned integer array value into
        // the specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its
        // type and length are appropriate, update the cursor location, and
        // return a reference to this stream.  If the type is incorrect, then
        // this stream is marked invalid and the value of &#39;variables&#39; is
        // unchanged.  If this stream is initially invalid, this operation has
        // no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variables&#39; is
        // undefined.  The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and
        // &#39;variables&#39; has sufficient capacity.

    TestInStream&amp; getArrayInt48(bsls::Types::Int64 *variables,
                                int                 numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 48-bit signed integer array value into the
        // specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its type
        // and length are appropriate, update the cursor location, and return a
        // reference to this stream.  If the type is incorrect, then this
        // stream is marked invalid and the value of &#39;variables&#39; is unchanged.
        // If this stream is initially invalid, this operation has no effect.
        // If this function otherwise fails to extract a valid value, this
        // stream is marked invalid and the value of &#39;variables&#39; is undefined.
        // The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39;
        // has sufficient capacity.

    TestInStream&amp; getArrayUint48(bsls::Types::Uint64 *variables,
                                 int                  numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 48-bit unsigned integer array value into
        // the specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its
        // type and length are appropriate, update the cursor location, and
        // return a reference to this stream.  If the type is incorrect, then
        // this stream is marked invalid and the value of &#39;variables&#39; is
        // unchanged.  If this stream is initially invalid, this operation has
        // no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variables&#39; is
        // undefined.  The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and
        // &#39;variables&#39; has sufficient capacity.

    TestInStream&amp; getArrayInt40(bsls::Types::Int64 *variables,
                                int                 numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 40-bit signed integer array value into the
        // specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its type
        // and length are appropriate, update the cursor location, and return a
        // reference to this stream.  If the type is incorrect, then this
        // stream is marked invalid and the value of &#39;variables&#39; is unchanged.
        // If this stream is initially invalid, this operation has no effect.
        // If this function otherwise fails to extract a valid value, this
        // stream is marked invalid and the value of &#39;variables&#39; is undefined.
        // The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39;
        // has sufficient capacity.

    TestInStream&amp; getArrayUint40(bsls::Types::Uint64 *variables,
                                 int                  numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 40-bit unsigned integer array value into
        // the specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its
        // type and length are appropriate, update the cursor location, and
        // return a reference to this stream.  If the type is incorrect, then
        // this stream is marked invalid and the value of &#39;variables&#39; is
        // unchanged.  If this stream is initially invalid, this operation has
        // no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variables&#39; is
        // undefined.  The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and
        // &#39;variables&#39; has sufficient capacity.

    TestInStream&amp; getArrayInt32(int *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 32-bit signed integer array value into the
        // specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its type
        // and length are appropriate, update the cursor location, and return a
        // reference to this stream.  If the type is incorrect, then this
        // stream is marked invalid and the value of &#39;variables&#39; is unchanged.
        // If this stream is initially invalid, this operation has no effect.
        // If this function otherwise fails to extract a valid value, this
        // stream is marked invalid and the value of &#39;variables&#39; is undefined.
        // The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39;
        // has sufficient capacity.

    TestInStream&amp; getArrayUint32(unsigned int *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 32-bit unsigned integer array value into
        // the specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its
        // type and length are appropriate, update the cursor location, and
        // return a reference to this stream.  If the type is incorrect, then
        // this stream is marked invalid and the value of &#39;variables&#39; is
        // unchanged.  If this stream is initially invalid, this operation has
        // no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variables&#39; is
        // undefined.  The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and
        // &#39;variables&#39; has sufficient capacity.

    TestInStream&amp; getArrayInt24(int *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 24-bit signed integer array value into the
        // specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its type
        // and length are appropriate, update the cursor location, and return a
        // reference to this stream.  If the type is incorrect, then this
        // stream is marked invalid and the value of &#39;variables&#39; is unchanged.
        // If this stream is initially invalid, this operation has no effect.
        // If this function otherwise fails to extract a valid value, this
        // stream is marked invalid and the value of &#39;variables&#39; is undefined.
        // The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39;
        // has sufficient capacity.

    TestInStream&amp; getArrayUint24(unsigned int *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 24-bit unsigned integer array value into
        // the specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its
        // type and length are appropriate, update the cursor location, and
        // return a reference to this stream.  If the type is incorrect, then
        // this stream is marked invalid and the value of &#39;variables&#39; is
        // unchanged.  If this stream is initially invalid, this operation has
        // no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variables&#39; is
        // undefined.  The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and
        // &#39;variables&#39; has sufficient capacity.

    TestInStream&amp; getArrayInt16(short *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 16-bit signed integer array value into the
        // specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its type
        // and length are appropriate, update the cursor location, and return a
        // reference to this stream.  If the type is incorrect, then this
        // stream is marked invalid and the value of &#39;variables&#39; is unchanged.
        // If this stream is initially invalid, this operation has no effect.
        // If this function otherwise fails to extract a valid value, this
        // stream is marked invalid and the value of &#39;variables&#39; is undefined.
        // The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39;
        // has sufficient capacity.

    TestInStream&amp; getArrayUint16(unsigned short *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 16-bit unsigned integer array value into
        // the specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its
        // type and length are appropriate, update the cursor location, and
        // return a reference to this stream.  If the type is incorrect, then
        // this stream is marked invalid and the value of &#39;variables&#39; is
        // unchanged.  If this stream is initially invalid, this operation has
        // no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variables&#39; is
        // undefined.  The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and
        // &#39;variables&#39; has sufficient capacity.

    TestInStream&amp; getArrayInt8(char        *variables, int numVariables);
    TestInStream&amp; getArrayInt8(signed char *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 8-bit signed integer array value into the
        // specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its type
        // and length are appropriate, update the cursor location, and return a
        // reference to this stream.  If the type is incorrect, then this
        // stream is marked invalid and the value of &#39;variables&#39; is unchanged.
        // If this stream is initially invalid, this operation has no effect.
        // If this function otherwise fails to extract a valid value, this
        // stream is marked invalid and the value of &#39;variables&#39; is undefined.
        // The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39;
        // has sufficient capacity.

    TestInStream&amp; getArrayUint8(char          *variables, int numVariables);
    TestInStream&amp; getArrayUint8(unsigned char *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that 8-bit unsigned integer array value into
        // the specified &#39;variables&#39; of the specified &#39;numVariables&#39; if its
        // type and length are appropriate, update the cursor location, and
        // return a reference to this stream.  If the type is incorrect, then
        // this stream is marked invalid and the value of &#39;variables&#39; is
        // unchanged.  If this stream is initially invalid, this operation has
        // no effect.  If this function otherwise fails to extract a valid
        // value, this stream is marked invalid and the value of &#39;variables&#39; is
        // undefined.  The behavior is undefined unless &#39;0 &lt;= numVariables&#39; and
        // &#39;variables&#39; has sufficient capacity.

                      // *** arrays of floating-point values ***

    TestInStream&amp; getArrayFloat64(double *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that IEEE double-precision (8-byte)
        // floating-point array value into the specified &#39;variables&#39; of the
        // specified &#39;numVariables&#39; if its type and length are appropriate,
        // update the cursor location, and return a reference to this stream.
        // If the type is incorrect, then this stream is marked invalid and the
        // value of &#39;variables&#39; is unchanged.  If this stream is initially
        // invalid, this operation has no effect.  If this function otherwise
        // fails to extract a valid value, this stream is marked invalid and
        // the value of &#39;variables&#39; is undefined.  The behavior is undefined
        // unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39; has sufficient capacity.
        // Note that for non-conforming platforms, this operation may be lossy.

    TestInStream&amp; getArrayFloat32(float *variables, int numVariables);
        // If required, throw a &#39;TestInStreamException&#39; (see
        // &#39;throwExceptionIfInputLimitExhausted&#39;); otherwise, consume the 8-bit
        // unsigned integer type code, verify the type of the next value in
        // this stream, consume that IEEE single-precision (4-byte)
        // floating-point array value into the specified &#39;variables&#39; of the
        // specified &#39;numVariables&#39; if its type and length are appropriate,
        // update the cursor location, and return a reference to this stream.
        // If the type is incorrect, then this stream is marked invalid and the
        // value of &#39;variables&#39; is unchanged.  If this stream is initially
        // invalid, this operation has no effect.  If this function otherwise
        // fails to extract a valid value, this stream is marked invalid and
        // the value of &#39;variables&#39; is undefined.  The behavior is undefined
        // unless &#39;0 &lt;= numVariables&#39; and &#39;variables&#39; has sufficient capacity.
        // Note that for non-conforming platforms, this operation may be lossy.

    // ACCESSORS
    operator const void *() const;
        // Return a non-zero value if this stream is valid, and 0 otherwise.
        // An invalid stream is a stream for which an input operation was
        // detected to have failed.

    bsl::size_t cursor() const;
        // Return the index of the next byte to be extracted from this stream.

    const char *data() const;
        // Return the address of the contiguous, non-modifiable external memory
        // buffer of this stream.  The behavior of accessing elements outside
        // the range &#39;[ data() .. data() + (length() - 1) ]&#39; is undefined.

    int inputLimit() const;
        // Return the current number of input requests left before an exception
        // is thrown.  A negative value indicates that no exception is
        // scheduled.

    bool isEmpty() const;
        // Return &#39;true&#39; if this stream is empty, and &#39;false&#39; otherwise.  Note
        // that this function enables higher-level types to verify that, after
        // successfully reading all expected data, no data remains.

    bool isQuiet() const;
        // Return &#39;true&#39; if this stream&#39;s quiet mode is ON, and &#39;false&#39;
        // otherwise.

    bool isValid() const;
        // Return &#39;true&#39; if this stream is valid, and &#39;false&#39; otherwise.  An
        // invalid stream is a stream in which insufficient or invalid data was
        // detected during an extraction operation.  Note that an empty stream
        // will be valid unless an extraction attempt or explicit invalidation
        // causes it to be otherwise.

    bsl::size_t length() const;
        // Return the total number of bytes stored in the external memory
        // buffer.
};

// FREE OPERATORS
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const TestInStream&amp; object);
    // Write the specified &#39;object&#39; to the specified output &#39;stream&#39; in some
    // reasonable (multi-line) format, and return a reference to &#39;stream&#39;.

template &lt;class TYPE&gt;
TestInStream&amp; operator&gt;&gt;(TestInStream&amp; stream, TYPE&amp; value);
    // Read the specified &#39;value&#39; from the specified input &#39;stream&#39; following
    // the requirements of the BDEX protocol (see the &#39;bslx&#39; package-level
    // documentation), and return a reference to &#39;stream&#39;.  The behavior is
    // undefined unless &#39;TYPE&#39; is BDEX-compliant.

}  // close package namespace

               // ============================================
               // macro BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN
               // ============================================

#ifdef BDE_BUILD_TARGET_EXC

namespace bslx {

class TestInStream_ProxyBase {
    // This class provides a common base class for the parameterized
    // &#39;TestInStream_Proxy&#39; class (below).  Note that the &#39;virtual&#39;
    // &#39;setInputLimit&#39; method, although a &quot;setter&quot;, *must* be declared &#39;const&#39;.

  public:
    virtual ~TestInStream_ProxyBase()
    {
    }

    // ACCESSORS
    virtual void setInputLimit(int limit) const = 0;
};

template &lt;class BSLX_STREAM_TYPE&gt;
class TestInStream_Proxy: public TestInStream_ProxyBase {
    // This class provides a proxy to the test stream that is supplied to the
    // &#39;BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN&#39; macro.  This proxy may be
    // instantiated with &#39;TestInStream&#39;, or with a type that supports the same
    // interface as &#39;TestInStream&#39;.

    // DATA
    BSLX_STREAM_TYPE *d_stream_p;  // stream used in &#39;*_BEGIN&#39; and
                                   // &#39;*_END&#39; macros (held, not owned)

  public:
    // CREATORS
    TestInStream_Proxy(BSLX_STREAM_TYPE *stream)
    : d_stream_p(stream)
    {
    }

    ~TestInStream_Proxy()
    {
    }

    // ACCESSORS
    virtual void setInputLimit(int limit) const
    {
        d_stream_p-&gt;setInputLimit(limit);
    }
};

template &lt;class BSLX_STREAM_TYPE&gt;
inline
TestInStream_Proxy&lt;BSLX_STREAM_TYPE&gt;
TestInStream_getProxy(BSLX_STREAM_TYPE *stream)
    // Return, by value, a test stream proxy for the specified parameterized
    // &#39;stream&#39;.
{
    return TestInStream_Proxy&lt;BSLX_STREAM_TYPE&gt;(stream);
}

}  // close package namespace

#ifndef BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN
#define BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN(BSLX_TESTINSTREAM)             \
{                                                                             \
    const bslx::TestInStream_ProxyBase&amp; testInStream =                        \
                       bslx::TestInStream_getProxy(&amp;BSLX_TESTINSTREAM);       \
    {                                                                         \
        static int firstTime = 1;                                             \
        if (veryVerbose &amp;&amp; firstTime) bsl::cout &lt;&lt;                            \
            &quot;### BSLX EXCEPTION TEST -- (ENABLED) --&quot; &lt;&lt; &#39;\n&#39;;                \
        firstTime = 0;                                                        \
    }                                                                         \
    if (veryVeryVerbose) bsl::cout &lt;&lt;                                         \
        &quot;### Begin BSLX exception test.&quot; &lt;&lt; &#39;\n&#39;;                             \
    int bslxExceptionCounter = 0;                                             \
    static int bslxExceptionLimit = 100;                                      \
    testInStream.setInputLimit(bslxExceptionCounter);                         \
    do {                                                                      \
        try {
#endif  // BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN

#else // !defined(BDE_BUILD_TARGET_EXC)

#ifndef BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN
#define BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN(testInStream)                  \
{                                                                             \
    static int firstTime = 1;                                                 \
    if (verbose &amp;&amp; firstTime) {                                               \
        bsl::cout &lt;&lt; &quot;### BSLX EXCEPTION TEST -- (NOT ENABLED) --&quot; &lt;&lt; &#39;\n&#39;;   \
        firstTime = 0;                                                        \
    }                                                                         \
}
#endif  // BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN

#endif  // BDE_BUILD_TARGET_EXC

               // ==========================================
               // macro BSLX_TESTINSTREAM_EXCEPTION_TEST_END
               // ==========================================

#ifdef BDE_BUILD_TARGET_EXC

#ifndef BSLX_TESTINSTREAM_EXCEPTION_TEST_END
#define BSLX_TESTINSTREAM_EXCEPTION_TEST_END                                  \
        } catch (bslx::TestInStreamException&amp; e) {                            \
            if ((veryVerbose &amp;&amp; bslxExceptionLimit) || veryVeryVerbose)       \
            {                                                                 \
                --bslxExceptionLimit;                                         \
                bsl::cout &lt;&lt; &quot;(&quot; &lt;&lt; bslxExceptionCounter &lt;&lt; &#39;)&#39;;              \
                if (veryVeryVerbose) {                                        \
                    bsl::cout &lt;&lt; &quot; BSLX EXCEPTION: &quot;                          \
                              &lt;&lt; &quot;input limit = &quot;                             \
                              &lt;&lt; bslxExceptionCounter                         \
                              &lt;&lt; &quot;, &quot;                                         \
                              &lt;&lt; &quot;last data type = &quot;                          \
                              &lt;&lt; e.dataType();                                \
                }                                                             \
                else if (0 == bslxExceptionLimit) {                           \
                    bsl::cout &lt;&lt; &quot; [ Note: &#39;bslxExceptionLimit&#39; reached. ]&quot;;  \
                }                                                             \
                bsl::cout &lt;&lt; &#39;\n&#39;;                                            \
            }                                                                 \
            testInStream.setInputLimit(++bslxExceptionCounter);               \
            continue;                                                         \
        }                                                                     \
        testInStream.setInputLimit(-1);                                       \
        break;                                                                \
    } while (1);                                                              \
    if (veryVeryVerbose) {                                                    \
        bsl::cout &lt;&lt; &quot;### End BSLX exception test.&quot; &lt;&lt; &#39;\n&#39;;                  \
    }                                                                         \
}
#endif  // BSLX_TESTINSTREAM_EXCEPTION_TEST_END

#else // !defined(BDE_BUILD_TARGET_EXC)

#ifndef BSLX_TESTINSTREAM_EXCEPTION_TEST_END
#define BSLX_TESTINSTREAM_EXCEPTION_TEST_END
#endif

#endif  // BDE_BUILD_TARGET_EXC

namespace bslx {

// ============================================================================
//                          INLINE DEFINITIONS
// ============================================================================

                         // ------------------
                         // class TestInStream
                         // ------------------

// PRIVATE MANIPULATORS
inline
void TestInStream::throwExceptionIfInputLimitExhausted(
                                                    const TypeCode::Enum&amp; code)
{
#ifdef BDE_BUILD_TARGET_EXC
    if (0 &lt;= d_inputLimit) {
        --d_inputLimit;
        if (0 &gt; d_inputLimit) {
            throw TestInStreamException(code);
        }
    }
#endif
}

// MANIPULATORS
inline
void TestInStream::invalidate()
{
    d_validFlag = false;
}

inline
void TestInStream::reset()
{
    d_validFlag = true;
    d_cursor    = 0;
}

inline
void TestInStream::reset(const char *buffer, bsl::size_t numBytes)
{
    BSLS_ASSERT_SAFE(buffer || 0 == numBytes);

    d_buffer    = buffer;
    d_numBytes  = numBytes;
    d_validFlag = true;
    d_cursor    = 0;
}

inline
void TestInStream::reset(const bslstl::StringRef&amp; srcData)
{
    d_buffer    = srcData.data();
    d_numBytes  = srcData.length();
    d_validFlag = true;
    d_cursor    = 0;
}

inline
void TestInStream::seek(bsl::size_t offset)
{
    BSLS_ASSERT_SAFE(offset &lt;= length());

    d_cursor    = offset;
    d_validFlag = 1;
}

inline
void TestInStream::setInputLimit(int limit)
{
    d_inputLimit = limit;
}

inline
void TestInStream::setQuiet(bool flagValue)
{
    d_quietFlag = flagValue;
}

// ACCESSORS
inline
TestInStream::operator const void *() const
{
    return isValid() ? this : 0;
}

inline
bsl::size_t TestInStream::cursor() const
{
    return d_cursor;
}

inline
const char *TestInStream::data() const
{
    return d_numBytes ? d_buffer : 0;
}

inline
int TestInStream::inputLimit() const
{
    return d_inputLimit;
}

inline
bool TestInStream::isEmpty() const
{
    return cursor() &gt;= length();
}

inline
bool TestInStream::isQuiet() const
{
    return d_quietFlag;
}

inline
bool TestInStream::isValid() const
{
    return d_validFlag;
}

inline
bsl::size_t TestInStream::length() const
{
    return d_numBytes;
}

template &lt;class TYPE&gt;
inline
TestInStream&amp; operator&gt;&gt;(TestInStream&amp; stream, TYPE&amp; value)
{
    return InStreamFunctions::bdexStreamIn(stream, value);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
