<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslh_defaulthashalgorithm Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslh_defaulthashalgorithm<br/>
<small>
[<a class="el" href="group__bslh.html">Package bslh</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a reasonable hashing algorithm for default use.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslh.html">bslh</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Security</a> </li>
<li>
<a href="#3.2">Speed</a> </li>
<li>
<a href="#3.3">Hash Distribution</a> </li>
<li>
<a href="#3.4">Hash Consistency</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example: Creating and Using a Hash Table</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a reasonable hashing algorithm for default use. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslh_1_1DefaultHashAlgorithm.html">bslh::DefaultHashAlgorithm</a> </td><td>a default hashing algorithm  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslh__hash.html" title="Provide a struct to run bslh hash algorithms on supported types.">Component bslh_hash</a>, <a class="el" href="group__bslh__defaultseededhashalgorithm.html" title="Provide a reasonable seeded hashing algorithm for default use.">Component bslh_defaultseededhashalgorithm</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbslh_1_1DefaultHashAlgorithm.html">bslh::DefaultHashAlgorithm</a></code> provides an unspecified default hashing algorithm. The supplied algorithm is suitable for general purpose use in a hash table. The underlying algorithm is subject to change in future releases. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This class satisfies the requirements for regular <code>bslh</code> hashing algorithms, defined in <a class="el" href="bslh__hash_8h.html" title="Provide a struct to run bslh hash algorithms on supported types.">bslh_hash.h</a>. More information can be found in the package level documentation for <code>bslh</code> (internal users can also find information here {TEAM BDE:USING MODULAR HASHING&lt;GO&gt;}) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="security"></a> <a class="anchor" id="description.security"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Security: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this context "security" refers to the ability of the algorithm to produce hashes that are not predictable by an attacker. Security is a concern when an attacker may be able to provide malicious input into a hash table, thereby causing hashes to collide to buckets, which degrades performance. There are <em>no</em> security guarantees made by <code><a class="el" href="classbslh_1_1DefaultHashAlgorithm.html">bslh::DefaultHashAlgorithm</a></code>, meaning attackers may be able to engineer keys that will cause a Denial of Service (DoS) attack in hash tables using this algorithm. If security is required, an algorithm that documents better secure properties should be used, such as <code>bslh_siphashalgorithm</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="speed"></a> <a class="anchor" id="description.speed"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Speed: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default hash algorithm will compute a hash on the order of O(n) where <code>n</code> is the length of the input data. Note that this algorithm will produce hashes fast enough to be used to hash keys in a hash table. The chosen algorithm will be quicker than specialized algorithms such as SipHash, but not as fast as hashing using the identity function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hash_distribution"></a> <a class="anchor" id="description.hash_distribution"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Hash Distribution: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default hash algorithm will distribute hashes in a pseudo-random distribution across the key space. The hash function will exhibit avalanche behavior, meaning changing one bit of input will result in a 50% chance of each output bit changing. Avalanche behavior is enough to guarantee good key distribution, even when values are consecutive. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hash_consistency"></a> <a class="anchor" id="description.hash_consistency"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Hash Consistency: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default hash algorithm guarantees only that hashes will remain consistent within a single process, meaning different hashes may be produced on machines of different endianness or even between runs on the same machine. Therefor it is not recommended to send hashes from <code><a class="el" href="classbslh_1_1DefaultHashAlgorithm.html">bslh::DefaultHashAlgorithm</a></code> over a network. It is also not recommended to write hashes from <code><a class="el" href="classbslh_1_1DefaultHashAlgorithm.html">bslh::DefaultHashAlgorithm</a></code> to any memory accessible by multiple machines. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example~3A_creating_and_using_a_hash_table"></a> <a class="anchor" id="usage.example~3A_creating_and_using_a_hash_table"></a> <a class="anchor" id="description.usage.example~3A_creating_and_using_a_hash_table"></a> <a class="anchor" id="example"></a> <a class="anchor" id="usage.example"></a> <a class="anchor" id="description.usage.example"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example: Creating and Using a Hash Table: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have any array of types that define <code>operator==</code>, and we want a fast way to find out if values are contained in the array. We can create a <code>HashTable</code> data structure that is capable of looking up values in O(1) time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Further suppose that we will be storing futures (the financial instruments) in this table. Since futures have standardized names, we don't have to worry about any malicious values causing collisions. We will want to use a general purpose hashing algorithm with a good hash distribution and good speed. This algorithm will need to be in the form of a hash functor -- an object that will take objects stored in our array as input, and yield an integer value. The functor can pass the attributes of the <code>TYPE</code> that are salient to hashing into the hashing algorithm, and then return the hash that is produced. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can use the result of the hash function to index into our array of <code>buckets</code>. Each <code>bucket</code> is simply a pointer to a value in our original array of <code>TYPE</code> objects. We will resolve hash collisions in our array through <code>linear probing</code>, where we will search consecutive buckets following the bucket where the collision occurred, testing occupied buckets for equality with the value we are searching on, and concluding that the value is not in the table if we encounter an empty bucket before we encounter one referring to an equal element. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define our <code>HashTable</code> template class, with the two type parameters: <code>TYPE</code> (the type being referenced) and <code>HASHER</code> (a functor that produces the hash). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> HASHER&gt;
  <span class="keyword">class </span>HashTable {
      <span class="comment">// This class template implements a hash table providing fast lookup of</span>
      <span class="comment">// an external, non-owned, array of values of (template parameter)</span>
      <span class="comment">// &#39;TYPE&#39;.</span>
      <span class="comment">//</span>
      <span class="comment">// The (template parameter) &#39;TYPE&#39; shall have a transitive, symmetric</span>
      <span class="comment">// &#39;operator==&#39; function.  There is no requirement that it have any</span>
      <span class="comment">// kind of creator defined.</span>
      <span class="comment">//</span>
      <span class="comment">// The &#39;HASHER&#39; template parameter type must be a functor with a method</span>
      <span class="comment">// having the following signature:</span>
      <span class="comment">//..</span>
      <span class="comment">//  size_t operator()(TYPE)  const;</span>
      <span class="comment">//                   -OR-</span>
      <span class="comment">//  size_t operator()(const TYPE&amp;) const;</span>
      <span class="comment">//..</span>
      <span class="comment">// and &#39;HASHER&#39; shall have a publicly accessible default constructor</span>
      <span class="comment">// and destructor.</span>
      <span class="comment">//</span>
      <span class="comment">// Note that this hash table has numerous simplifications because we</span>
      <span class="comment">// know the size of the array and never have to resize the table.</span>

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> TYPE       *d_values;          <span class="comment">// Array of values table is to</span>
                                           <span class="comment">// hold</span>
      <span class="keywordtype">size_t</span>            d_numValues;       <span class="comment">// Length of &#39;d_values&#39;.</span>
      <span class="keyword">const</span> TYPE      **d_bucketArray;     <span class="comment">// Contains ptrs into &#39;d_values&#39;</span>
      <span class="keywordtype">unsigned</span>          d_bucketArrayMask; <span class="comment">// Will always be &#39;2^N - 1&#39;.</span>
      HASHER            d_hasher;          <span class="comment">// User supplied hashing algorithm</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keywordtype">bool</span> lookup(<span class="keywordtype">size_t</span>      *idx,
                  <span class="keyword">const</span> TYPE&amp;  value,
                  <span class="keywordtype">size_t</span>       hashValue) <span class="keyword">const</span>;
          <span class="comment">// Look up the specified &#39;value&#39;, having the specified &#39;hashValue&#39;,</span>
          <span class="comment">// and load its index in &#39;d_bucketArray&#39; into the specified &#39;idx&#39;.</span>
          <span class="comment">// If not found, return the vacant entry in &#39;d_bucketArray&#39; where</span>
          <span class="comment">// it should be inserted.  Return &#39;true&#39; if &#39;value&#39; is found and</span>
          <span class="comment">// &#39;false&#39; otherwise.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      HashTable(<span class="keyword">const</span> TYPE *valuesArray,
                <span class="keywordtype">size_t</span>      numValues);
          <span class="comment">// Create a hash table referring to the specified &#39;valuesArray&#39;</span>
          <span class="comment">// having length of the specified &#39;numValues&#39;.  No value in</span>
          <span class="comment">// &#39;valuesArray&#39; shall have the same value as any of the other</span>
          <span class="comment">// values in &#39;valuesArray&#39;</span>

      ~HashTable();
          <span class="comment">// Free up memory used by this hash table.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">bool</span> contains(<span class="keyword">const</span> TYPE&amp; value) <span class="keyword">const</span>;
          <span class="comment">// Return true if the specified &#39;value&#39; is found in the table and</span>
          <span class="comment">// false otherwise.</span>
  };
</pre></div><br/>
<br/>
 Then, we define a <code>Future</code> class, which holds a c-string <code>name</code>, char <code>callMonth</code>, and short <code>callYear</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Future {
      <span class="comment">// This class identifies a future contract.  It tracks the name, call</span>
      <span class="comment">// month and year of the contract it represents, and allows equality</span>
      <span class="comment">// comparison.</span>

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *d_name;    <span class="comment">// held, not owned</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span>  d_callMonth;
      <span class="keyword">const</span> <span class="keywordtype">short</span> d_callYear;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      Future(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> callMonth, <span class="keyword">const</span> <span class="keywordtype">short</span> callYear)
      : d_name(name), d_callMonth(callMonth), d_callYear(callYear)
          <span class="comment">// Create a &#39;Future&#39; object out of the specified &#39;name&#39;,</span>
          <span class="comment">// &#39;callMonth&#39;, and &#39;callYear&#39;.</span>
      {}

      Future() : d_name(<span class="stringliteral">&quot;&quot;</span>), d_callMonth(<span class="stringliteral">&#39;\0&#39;</span>), d_callYear(0)
          <span class="comment">// Create a &#39;Future&#39; with default values.</span>
      {}

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> * getMonth() const
          <span class="comment">// Return the month that this future expires.</span>
      {
          <span class="keywordflow">return</span> &amp;d_callMonth;
      }

      <span class="keyword">const</span> <span class="keywordtype">char</span> * getName() const
          <span class="comment">// Return the name of this future</span>
      {
          <span class="keywordflow">return</span> d_name;
      }

      <span class="keyword">const</span> <span class="keywordtype">short</span> * getYear() const
          <span class="comment">// Return the year that this future expires</span>
      {
          <span class="keywordflow">return</span> &amp;d_callYear;
      }

      <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> Future&amp; other) <span class="keyword">const</span>
          <span class="comment">// Compare this to the specified &#39;other&#39; object and return true if</span>
          <span class="comment">// they are equal</span>
      {
          <span class="keywordflow">return</span> (!strcmp(d_name, other.d_name))  &amp;&amp;
             d_callMonth == other.d_callMonth &amp;&amp;
             d_callYear  == other.d_callYear;
      }
  };

  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aceb1a703f6f64327cd3cdcd03a557f4a">operator!=</a>(<span class="keyword">const</span> Future&amp; lhs, <span class="keyword">const</span> Future&amp; rhs)
      <span class="comment">// Compare compare the specified &#39;lhs&#39; and &#39;rhs&#39; objects and return</span>
      <span class="comment">// true if they are not equal</span>
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 Next, we need a hash functor for <code>Future</code>. We are going to use the <code>DefaultHashAlgorithm</code> because it is a fast, general purpose hashing algorithm that will provide an easy way to combine the attributes of <code>Future</code> objects that are salient to hashing into one reasonable hash that will distribute the items evenly throughout the hash table. Moreover, when a new hashing algorithm is discovered to be a better default, we can be automatically be upgraded to use it as soon as <code><a class="el" href="classbslh_1_1DefaultHashAlgorithm.html">bslh::DefaultHashAlgorithm</a></code> is updated. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>HashFuture {
      <span class="comment">// This struct is a functor that will apply the &#39;DefaultHashAlgorithm&#39;</span>
      <span class="comment">// to objects of type &#39;Future&#39;.</span>

      <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> Future&amp; future) <span class="keyword">const</span>
          <span class="comment">// Return the hash of the of the specified &#39;future&#39;.  Note that</span>
          <span class="comment">// this uses the &#39;DefaultHashAlgorithm&#39; to quickly combine the</span>
          <span class="comment">// attributes of &#39;Future&#39; objects that are salient to hashing into</span>
          <span class="comment">// a hash suitable for a hash table.</span>
      {
          DefaultHashAlgorithm hash;

          hash(future.getName(),  strlen(future.getName()));
          hash(future.getMonth(), <span class="keyword">sizeof</span>(char));
          hash(future.getYear(),  <span class="keyword">sizeof</span>(short));

          <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(hash.computeHash());
      }
  };
</pre></div><br/>
<br/>
 Then, we want to actually use our hash table on <code>Future</code> objects. We create an array of <code>Future</code>s based on data that was originally from some external source: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Future futures[] = { Future(<span class="stringliteral">&quot;Swiss Franc&quot;</span>, <span class="charliteral">&#39;F&#39;</span>, 2014),
                           Future(<span class="stringliteral">&quot;US Dollar&quot;</span>, <span class="charliteral">&#39;G&#39;</span>, 2015),
                           Future(<span class="stringliteral">&quot;Canadian Dollar&quot;</span>, <span class="charliteral">&#39;Z&#39;</span>, 2014),
                           Future(<span class="stringliteral">&quot;British Pound&quot;</span>, <span class="charliteral">&#39;M&#39;</span>, 2015),
                           Future(<span class="stringliteral">&quot;Deutsche Mark&quot;</span>, <span class="charliteral">&#39;X&#39;</span>, 2016),
                           Future(<span class="stringliteral">&quot;Eurodollar&quot;</span>, <span class="charliteral">&#39;Q&#39;</span>, 2017)};
      <span class="keyword">enum</span> { NUM_FUTURES = <span class="keyword">sizeof</span> futures / <span class="keyword">sizeof</span> *futures };
</pre></div><br/>
<br/>
 Next, we create our HashTable <code>hashTable</code>. We pass the functor that we defined above as the second argument: <br/>
<br/>
<div class="fragment"><pre class="fragment">      HashTable&lt;Future, HashFuture&gt; hashTable(futures, NUM_FUTURES);
</pre></div><br/>
<br/>
 Now, we verify that each element in our array registers with count: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i) {
          ASSERT(hashTable.contains(futures[i]));
      }
</pre></div><br/>
<br/>
 Finally, we verify that futures not in our original array are correctly identified as not being in the set: <br/>
<br/>
<div class="fragment"><pre class="fragment">      ASSERT(!hashTable.contains(Future(<span class="stringliteral">&quot;French Franc&quot;</span>, <span class="charliteral">&#39;N&#39;</span>, 2019)));
      ASSERT(!hashTable.contains(Future(<span class="stringliteral">&quot;Swiss Franc&quot;</span>, <span class="charliteral">&#39;X&#39;</span>, 2014)));
      ASSERT(!hashTable.contains(Future(<span class="stringliteral">&quot;US Dollar&quot;</span>, <span class="charliteral">&#39;F&#39;</span>, 2014)));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
