<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class balst::StackTraceTestAllocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebalst.html">balst</a>      </li>
      <li><a class="el" href="classbalst_1_1StackTraceTestAllocator.html">balst::StackTraceTestAllocator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>balst::StackTraceTestAllocator Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="balst::StackTraceTestAllocator" --><!-- doxytag: inherits="bdlma::ManagedAllocator" -->
<p><code>#include &lt;<a class="el" href="balst__stacktracetestallocator_8h_source.html">balst_stacktracetestallocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for balst::StackTraceTestAllocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbalst_1_1StackTraceTestAllocator.png" usemap="#balst::StackTraceTestAllocator_map" alt=""/>
  <map id="balst::StackTraceTestAllocator_map" name="balst::StackTraceTestAllocator_map">
<area href="classbdlma_1_1ManagedAllocator.html" alt="bdlma::ManagedAllocator" shape="rect" coords="0,56,182,80"/>
<area href="classbslma_1_1Allocator.html" alt="bslma::Allocator" shape="rect" coords="0,0,182,24"/>
</map>
</div>

<p><a href="classbalst_1_1StackTraceTestAllocator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a4adaca50b50ae94587a41d71f3fe9c08">FailureHandler</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a512f712b08eddd0c54ffa4f31c8f335d">StackTraceTestAllocator</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#ad75f0c10023be16885fa0d088de16e5d">StackTraceTestAllocator</a> (int numRecordedFrames, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#aa507c8a4821801b007bd8d2031779b50">~StackTraceTestAllocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a1b7fc01c2c6c974fad944f1b995a34ad">allocate</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#afff71e94af64801b3b8a0184d3421724">deallocate</a> (void *address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#ab2e746a4657b0a2538181c49e6c79266">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#adead4f539975cba129fc895b4e054b0c">setDemanglingPreferredFlag</a> (bool value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a1424d10032ced8faf9f6dedb212f2bc1">setFailureHandler</a> (const <a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a4adaca50b50ae94587a41d71f3fe9c08">FailureHandler</a> &amp;func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a7ffbc8406a6214acb5bc2a65946f1ca0">setName</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a6bd576505d3c644f38f183a8288b28b0">setOstream</a> (bsl::ostream *ostream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a4adaca50b50ae94587a41d71f3fe9c08">FailureHandler</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a5b850068afdf3d64daccf262bdcda705">failureHandler</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a898b64bd6813faa207f374e83cfbcf95">numBlocksInUse</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#ac0d66d426396e472ca41f18a8ac5e43e">reportBlocksInUse</a> (bsl::ostream *ostream=0) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a0e51fc2d107684523cc66bf65293dc37">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a> (const TYPE *object)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a1eda6863792bc6e74d4d2d2b08c2f60b">failAbort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#aa7c4ea6bfb42eb10c0e9b8e1045bbb7e">failNoop</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class defines a concrete "test" allocator mechanism that implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> protocol, and provides instrumentation to track the set of all blocks allocated by this allocator that have yet to be freed. At any time it can produce a report about such blocks, listing for each place that any unfreed blocks were allocated </p>
<ul>
<li>
the number of unfreed blocks allocated at that place  </li>
<li>
the stack trace at that place  </li>
</ul>
<p>The allocator will also detect redundant frees of the same block, and frees by the wrong allocator. The client can choose whether such violations are handled by a core dump, or merely a report being written.</p>
<p>Note that, unlike many other allocators, this allocator does DOES NOT rely on the currently installed default allocator (see <code>bslma_default</code>) at all, but instead -- by default -- uses <code>MallocFreeAllocator</code> singleton, which in turn calls the C Standard Library functions <code>malloc</code> and <code>free</code> as needed. Clients may, however, override this allocator by supplying (at construction) any other allocator implementing the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a4adaca50b50ae94587a41d71f3fe9c08"></a><!-- doxytag: member="balst::StackTraceTestAllocator::FailureHandler" ref="a4adaca50b50ae94587a41d71f3fe9c08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void()&gt; <a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a4adaca50b50ae94587a41d71f3fe9c08">balst::StackTraceTestAllocator::FailureHandler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type of functor called by this object to handle failures. Note that this can be set and accessed using th <code>setFailureHandler</code> and <code>failureHandler</code> methods respectively. </p>

</div>
</div>
<a class="anchor" id="a07cd3ddf3fba145a0469a4e867047287"></a><!-- doxytag: member="balst::StackTraceTestAllocator::size_type" ref="a07cd3ddf3fba145a0469a4e867047287" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a512f712b08eddd0c54ffa4f31c8f335d"></a><!-- doxytag: member="balst::StackTraceTestAllocator::StackTraceTestAllocator" ref="a512f712b08eddd0c54ffa4f31c8f335d" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">balst::StackTraceTestAllocator::StackTraceTestAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad75f0c10023be16885fa0d088de16e5d"></a><!-- doxytag: member="balst::StackTraceTestAllocator::StackTraceTestAllocator" ref="ad75f0c10023be16885fa0d088de16e5d" args="(int numRecordedFrames, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">balst::StackTraceTestAllocator::StackTraceTestAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRecordedFrames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a test allocator. Optionally specify <code>numRecordedFrames</code>, the number of stack trace frame pointers to be saved for every allocation. Specifying a larger value of <code>numRecordedFrames</code> means that stack traces, when given, will be more complete, but will also mean that both more CPU time and more memory per allocation will be consumed. If <code>numRecordedFrames</code> is not specified, a value of <code>12</code> will be assumed. Optionally specify <code>basicAllocator</code>, the allocator from which memory will be provided. If <code>basicAllocator</code> is 0, the <code>MallocFreeAllocator</code> singleton is used. Associate <code>bsl::cerr</code> with this object for error diagnostic output, which may be changed by calling the <code>setOstream</code> manipulator. Set the <code>demanglingPreferringFlag</code> attribute to <code>true</code>, which may be changed using the <code>setDemanglingPreferredFlag</code> manipulator. The behavior is undefined if <code>numRecordedFrames &lt; 2</code>. </p>

</div>
</div>
<a class="anchor" id="aa507c8a4821801b007bd8d2031779b50"></a><!-- doxytag: member="balst::StackTraceTestAllocator::~StackTraceTestAllocator" ref="aa507c8a4821801b007bd8d2031779b50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual balst::StackTraceTestAllocator::~StackTraceTestAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this allocator. Report any memory leaks to the <code>ostream</code> that was supplied at construction. If no memory leaks are observed, nothing is written to the output <code>ostream</code>. Call the failure handler if <code><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a898b64bd6813faa207f374e83cfbcf95">numBlocksInUse()</a> &gt; 0</code>. Note that a report of outstanding memory blocks is written to <code>ostream</code> before the failure handler is called, and if the failure handler returns, all outstanding memory blocks will be released. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1eda6863792bc6e74d4d2d2b08c2f60b"></a><!-- doxytag: member="balst::StackTraceTestAllocator::failAbort" ref="a1eda6863792bc6e74d4d2d2b08c2f60b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void balst::StackTraceTestAllocator::failAbort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls <code>bsl::abort()</code>, <code>d_failureHandler</code> is initialized to this value by all constructors. Note that in ALL failure situations, errors or warnings will be written to the <code>ostream</code> associated with this object prior to the failure handler call. </p>

</div>
</div>
<a class="anchor" id="aa7c4ea6bfb42eb10c0e9b8e1045bbb7e"></a><!-- doxytag: member="balst::StackTraceTestAllocator::failNoop" ref="aa7c4ea6bfb42eb10c0e9b8e1045bbb7e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void balst::StackTraceTestAllocator::failNoop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does nothing. <code>setFailureHandler</code> may be called with this function, in which case this allocator object, when a failure occurs, will recover rather than abort. Note that in ALL failure situations, errors or warnings will be written to the <code>ostream</code> associated with this object prior to the failure handler call. </p>

</div>
</div>
<a class="anchor" id="a1b7fc01c2c6c974fad944f1b995a34ad"></a><!-- doxytag: member="balst::StackTraceTestAllocator::allocate" ref="a1b7fc01c2c6c974fad944f1b995a34ad" args="(size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* balst::StackTraceTestAllocator::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a newly allocated block of memory of the specified positive <code>size</code> (in bytes). If <code>size</code> is 0, a null pointer is returned with no other other effect. Otherwise, invoke the <code>allocate</code> method of the allocator supplied at construction and record the returned block in order to be able to report leaked blocks upon destruction. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="afff71e94af64801b3b8a0184d3421724"></a><!-- doxytag: member="balst::StackTraceTestAllocator::deallocate" ref="afff71e94af64801b3b8a0184d3421724" args="(void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void balst::StackTraceTestAllocator::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the memory block at the specified <code>address</code> back to this allocator. If <code>address</code> is 0, this function has no effect. Otherwise, if the memory at <code>address</code> is consistent with being allocated from this test allocator, deallocate it using the underlying allocator and delete it from the data structures keeping track of blocks in use'. If <code>address</code> is not zero and is not the address of a block allocated with this allocator (or if it is being deallocated a second time), write an error message and call the failure handler. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="ab2e746a4657b0a2538181c49e6c79266"></a><!-- doxytag: member="balst::StackTraceTestAllocator::release" ref="ab2e746a4657b0a2538181c49e6c79266" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void balst::StackTraceTestAllocator::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate all memory held by this allocator. </p>

<p>Implements <a class="el" href="classbdlma_1_1ManagedAllocator.html#ad86110a47aaf5e53356c86b5fd240bfb">bdlma::ManagedAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="adead4f539975cba129fc895b4e054b0c"></a><!-- doxytag: member="balst::StackTraceTestAllocator::setDemanglingPreferredFlag" ref="adead4f539975cba129fc895b4e054b0c" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void balst::StackTraceTestAllocator::setDemanglingPreferredFlag </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the <code>demanglingPreferredFlag</code> attribute, which is used to determine whether demangling of symbols is to be attempted when generating diagnostics, to the specified <code>value</code>. The default value of the flag is <code>true</code>. However the flag is ignored on some platforms; demangling never happens on some platforms and always happens on others. </p>

</div>
</div>
<a class="anchor" id="a1424d10032ced8faf9f6dedb212f2bc1"></a><!-- doxytag: member="balst::StackTraceTestAllocator::setFailureHandler" ref="a1424d10032ced8faf9f6dedb212f2bc1" args="(const FailureHandler &amp;func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void balst::StackTraceTestAllocator::setFailureHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a4adaca50b50ae94587a41d71f3fe9c08">FailureHandler</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the failure handler associated with this allocator object to the specified <code>func</code>. Upon construction, the function <code>failAbort</code> is associated with this object by default. Note that <code>func</code> will be called by this object's destructor if memory is leaked, so it is important that it not throw. Note that in ALL failure situations, errors or warnings will be written to the <code>ostream</code> associated with this object prior to the call to the failure handler. </p>

</div>
</div>
<a class="anchor" id="a7ffbc8406a6214acb5bc2a65946f1ca0"></a><!-- doxytag: member="balst::StackTraceTestAllocator::setName" ref="a7ffbc8406a6214acb5bc2a65946f1ca0" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void balst::StackTraceTestAllocator::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the name of this allocator to the specified <code>name</code>. If <code>setName</code> is never called, the name of the allocator is "&lt;unnamed&gt;". Note that the lifetime of <code>name</code> must exceed the lifetime of this object. </p>

</div>
</div>
<a class="anchor" id="a6bd576505d3c644f38f183a8288b28b0"></a><!-- doxytag: member="balst::StackTraceTestAllocator::setOstream" ref="a6bd576505d3c644f38f183a8288b28b0" args="(bsl::ostream *ostream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void balst::StackTraceTestAllocator::setOstream </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream *&nbsp;</td>
          <td class="paramname"> <em>ostream</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the stream to which diagnostics will be written to the specified <code>ostream</code>. If <code>setOstream</code> is never called, diagnostics will be written to <code>bsl::cerr</code>. </p>

</div>
</div>
<a class="anchor" id="a5b850068afdf3d64daccf262bdcda705"></a><!-- doxytag: member="balst::StackTraceTestAllocator::failureHandler" ref="a5b850068afdf3d64daccf262bdcda705" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a4adaca50b50ae94587a41d71f3fe9c08">StackTraceTestAllocator::FailureHandler</a> &amp; balst::StackTraceTestAllocator::failureHandler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the function that will be called when a failure is observered. </p>

</div>
</div>
<a class="anchor" id="a898b64bd6813faa207f374e83cfbcf95"></a><!-- doxytag: member="balst::StackTraceTestAllocator::numBlocksInUse" ref="a898b64bd6813faa207f374e83cfbcf95" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::size_t balst::StackTraceTestAllocator::numBlocksInUse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of blocks currently allocated from this object. </p>

</div>
</div>
<a class="anchor" id="ac0d66d426396e472ca41f18a8ac5e43e"></a><!-- doxytag: member="balst::StackTraceTestAllocator::reportBlocksInUse" ref="ac0d66d426396e472ca41f18a8ac5e43e" args="(bsl::ostream *ostream=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void balst::StackTraceTestAllocator::reportBlocksInUse </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream *&nbsp;</td>
          <td class="paramname"> <em>ostream</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a report to the specified <code>ostream</code>, reporting the unique call-stacks for each block that has been allocated and has not yet been freed. If <code>ostream</code> is not specified, the value of <code>ostream</code> passed to the last call to <code>setOstream</code> will be used. If <code>setOstream</code> was never called, <code>bsl::cerr</code> will be used. </p>

</div>
</div>
<a class="anchor" id="a0e51fc2d107684523cc66bf65293dc37"></a><!-- doxytag: member="balst::StackTraceTestAllocator::deleteObject" ref="a0e51fc2d107684523cc66bf65293dc37" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this allocator and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="abeccfe6cfd8205faf528a8e12f97aebe"></a><!-- doxytag: member="balst::StackTraceTestAllocator::deleteObjectRaw" ref="abeccfe6cfd8205faf528a8e12f97aebe" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code> was allocated using this allocator, is <b>not</b> a secondary base class pointer -- i.e., the address is (numerically) the same as when it was originally dispensed by this allocator, and has not already been deallocated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="balst__stacktracetestallocator_8h_source.html">balst_stacktracetestallocator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:05 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
