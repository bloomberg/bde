<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslma_destructorproctor.h                                          -*-C++-*-
#ifndef INCLUDED_BSLMA_DESTRUCTORPROCTOR
#define INCLUDED_BSLMA_DESTRUCTORPROCTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a proctor to conditionally manage an object.
//
//@CLASSES:
//  bslma::DestructorProctor: proctor to conditionally manage an object
//
//@SEE_ALSO: bslma_destructorguard, bslma_autodestructor
//
//@DESCRIPTION: This component provides a proctor class template to
// conditionally manage an (otherwise-unmanaged) object of parameterized &#39;TYPE&#39;
// supplied at construction.  If not explicitly released, the managed object is
// destroyed automatically when the proctor object goes out of scope by calling
// the object&#39;s destructor.  Note that after a proctor object releases its
// managed object, the same proctor can be reused to conditionally manage
// another object by invoking the &#39;reset&#39; method.
//
///Usage
///-----
// The &#39;bslma::DestructorProctor&#39; is normally used to manage objects that are
// constructed sequentially in a block of memory provided.  This is often the
// case when memory management and primitive helpers are implemented in
// different components.  An example would be the construction of a pair object
// within another container with the help of a scalar primitive helper (see
// &#39;bslalg_scalarprimitives&#39;).  After the first object is constructed in the
// provided memory, it should be protected in case the constructor of the
// second object throws.  The following example illustrates a typical use of
// the &#39;bslma::DestructorProctor&#39;.
//
// First, suppose we have a pair class similar to &#39;std::pair&#39;:
//..
//  // my_pair.h
//  // ...
//
//  template &lt;class TYPE1, class TYPE2&gt;
//  class my_Pair {
//      // This class provides a pair container to pair two different objects,
//      // one of parameterized &#39;TYPE1&#39;, and the other of parameterized
//      // &#39;TYPE2&#39;.
//
//    public:
//      // PUBLIC TYPES
//      typedef TYPE1 firstType;
//      typedef TYPE2 secondType;
//
//      // PUBLIC DATA
//      TYPE1            first;          // first object
//      TYPE2            second;         // second object
//
//      // Declare trait &#39;my_PairTrait&#39;.
//      // ...
//
//    public:
//      // CREATORS
//      // ...
//
//      my_Pair(const TYPE1&amp;     iFirst,
//              const TYPE2&amp;     iSecond)
//          // Create a &#39;my_Pair&#39; object that holds a copy of the specified
//          // &#39;iFirst&#39; and &#39;iSecond&#39;.
//      : first(iFirst)
//      , second(iSecond)
//      {
//      }
//
//      // ...
//
//  };
//..
// Note that parts of the implementation, including the &#39;my_PairTrait&#39;
// declaration, are elided.  The &#39;my_PairTrait&#39; will be used by the primitive
// helper to customize implementations for objects that are pairs.
//
// We now implement the primitive helper:
//..
//  // my_primitives.h
//  // ...
//
//  struct my_Primitives {
//      // This struct provides a namespace for pure procedure primitive
//      // functions used to construct, destroy, insert, append and remove
//      // objects.
//
//    private:
//      // PRIVATE TYPES
//      enum { PAIR_TRAIT = 1, NIL_TRAIT = 0 };
//
//    public:
//      // CLASS METHODS
//
//      template &lt;class TYPE&gt;
//      static void copyConstruct(TYPE             *address,
//                                const TYPE&amp;       original,
//                                bslma::Allocator *basicAllocator);
//          // Copy construct the specified &#39;original&#39; into the specified
//          // &#39;address&#39; using the specified &#39;basicAllocator&#39; (if the
//          // copy constructor of &#39;TYPE&#39; takes an allocator).
//
//      template &lt;class TYPE&gt;
//      static void copyConstruct(TYPE             *address,
//                                const TYPE&amp;       original,
//                                bslma::Allocator *basicAllocator,
//                                bslmf::MetaInt&lt;PAIR_TRAIT&gt; *);
//          // Copy construct the specified &#39;original&#39; into the specified
//          // &#39;address&#39; using the specified &#39;basicAllocator&#39; (if the
//          // copy constructor of &#39;TYPE&#39; takes an allocator).  Note that
//          // the last parameter is used only for overload resolution.
//
//      template &lt;class TYPE&gt;
//      static void copyConstruct(TYPE             *address,
//                                const TYPE&amp;       original,
//                                bslma::Allocator *basicAllocator,
//                                bslmf::MetaInt&lt;NIL_TRAIT&gt; *);
//          // Copy construct the specified &#39;original&#39; into the specified
//          // &#39;address&#39; using the specified &#39;basicAllocator&#39; (if the
//          // copy constructor of &#39;TYPE&#39; takes an allocator).  Note that
//          // the last parameter is used only for overload resolution.
//  };
//
//  template &lt;class TYPE&gt;
//  inline
//  void my_Primitives::copyConstruct(TYPE             *address,
//                                    const TYPE&amp;       original,
//                                    bslma::Allocator *basicAllocator)
//  {
//      copyConstruct(address,
//                    original,
//                    basicAllocator,
//                    (bslmf::MetaInt&lt;my_HasPairTrait&lt;TYPE&gt;::VALUE&gt; *)0);
//  }
//..
// The implementation of &#39;copyConstruct&#39; constructs the pair object in two
// steps because of the use of allocators.  We cannot simply pass the allocator
// to the copy constructor of the pair object (since &#39;std::pair&#39; does not take
// an allocator).  Therefore, we copy construct &#39;first&#39; and &#39;second&#39; directly
// in the pair object.
//..
//  template &lt;class TYPE&gt;
//  inline
//  void my_Primitives::copyConstruct(TYPE             *address,
//                                    const TYPE&amp;       original,
//                                    bslma::Allocator *basicAllocator,
//                                    bslmf::MetaInt&lt;PAIR_TRAIT&gt; *)
//  {
//      copyConstruct(&amp;address-&gt;first, original.first, basicAllocator);
//
//      //**************************************************
//      // Note the use of the destructor proctor (below). *
//      //**************************************************
//
//      bslma::DestructorProctor&lt;typename TYPE::firstType&gt; proctor(
//                                                            &amp;address-&gt;first);
//
//      copyConstruct(&amp;address-&gt;second, original.second, basicAllocator);
//
//      //********************************************************
//      // Note that the destructor proctor is released (below). *
//      //********************************************************
//
//      proctor.release();
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  void my_Primitives::copyConstruct(TYPE             *address,
//                                    const TYPE&amp;       original,
//                                    bslma::Allocator *basicAllocator,
//                                    bslmf::MetaInt&lt;NIL_TRAIT&gt; *)
//  {
//      new(address)TYPE(original, basicAllocator);
//  }
//..
// Note that the implementation of &#39;my_HasPairTrait&#39; is not shown.  It is
// used to detect whether &#39;TYPE&#39; has &#39;my_PairTrait&#39; or not
// (see &#39;bslalg_typetraits&#39;, &#39;bslalg_typetraitpair&#39;).
//
// In the above implementation, if the copy construction of the second object
// in the pair throws, all memory (and any other resources) acquired as a
// result of copying the (not-yet-managed) object would be leaked.  Using the
// &#39;bslma::DestructorProctor&#39; prevents the leaks by invoking the destructor of
// the proctored object automatically should the proctor go out of scope
// before the &#39;release&#39; method of the proctor is called (such as when the
// function exits prematurely due to an exception).
//
// Note that the &#39;copyConstruct&#39; method assumes the copy constructor of
// &#39;TYPE::firstType&#39; and &#39;TYPE::secondType&#39; takes an allocator as a second
// argument.  In production code, a constructor proxy that checks the traits
// of &#39;TYPE::firstType&#39; and &#39;TYPE::secondType&#39; (to determine whether they uses
// &#39;bslma::Allocator&#39;) should be used (see &#39;bslalg_constructorproxy&#39;).

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

                        // =======================
                        // class DestructorProctor
                        // =======================

template &lt;class TYPE&gt;
class DestructorProctor {
    // This class implements a proctor that, unless its &#39;release&#39; method has
    // previously been invoked, automatically destroys a managed object upon
    // destruction by invoking the (managed) object&#39;s destructor.

    // DATA
    TYPE *d_object_p;  // managed object

    // NOT IMPLEMENTED
    DestructorProctor(const DestructorProctor&amp;);
    DestructorProctor&amp; operator=(const DestructorProctor&amp;);

  public:
    // CREATORS
    DestructorProctor(TYPE *object);
        // Create a destructor proctor that conditionally manages the
        // specified &#39;object&#39; (if non-zero) by invoking the destructor of the
        // object managed by this proctor (if not released -- see &#39;release&#39;)
        // upon destruction.

    ~DestructorProctor();
        // Destroy this destructor proctor, and destroy the object it manages
        // (if any) by invoking the destructor of the (managed) object.  If no
        // object is currently being managed, this method has no effect.

    // MANIPULATORS
    void release();
        // Release from management the object currently managed by this
        // proctor.  If no object is currently being managed, this method has
        // no effect.

    void reset(TYPE *object);
        // Set the specified &#39;object&#39; as the object to be managed by this
        // proctor.  The behavior is undefined unless &#39;object&#39; is non-zero.
        // Note that this method releases any previously-managed object from
        // management (without destroying it), and so may be invoked with or
        // without having called &#39;release&#39; when reusing this object.
};

// ============================================================================
//                      TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

                        // -----------------------
                        // class DestructorProctor
                        // -----------------------

// CREATORS
template &lt;class TYPE&gt;
inline
DestructorProctor&lt;TYPE&gt;::DestructorProctor(TYPE *object)
: d_object_p(object)
{
}

template &lt;class TYPE&gt;
inline
DestructorProctor&lt;TYPE&gt;::~DestructorProctor()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(0 != d_object_p)) {
        d_object_p-&gt;~TYPE();
    }
}

// MANIPULATORS
template &lt;class TYPE&gt;
inline
void DestructorProctor&lt;TYPE&gt;::release()
{
    d_object_p = 0;
}

template &lt;class TYPE&gt;
inline
void DestructorProctor&lt;TYPE&gt;::reset(TYPE *object)
{
    BSLS_ASSERT_SAFE(object);

    d_object_p = object;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
