<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_rawdeleterguard Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_rawdeleterguard<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a guard to unconditionally manage an object.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">"Raw" Warning</a> </li>
<li>
<a href="#3.2">Requirement</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a guard to unconditionally manage an object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1RawDeleterGuard.html">bslma::RawDeleterGuard</a> </td><td>guard to unconditionally manage an object  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__rawdeleterproctor.html" title="Provide a proctor to conditionally manage an object.">Component bslma_rawdeleterproctor</a>, <a class="el" href="group__bslma__autorawdeleter.html" title="Provide a range proctor to manage a sequence objects.">Component bslma_autorawdeleter</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a guard class template to unconditionally manage an (otherwise-unmanaged) object of parameterized <code>TYPE</code> supplied at construction. The managed object is deleted automatically when the guard object goes out of scope by first calling the (managed) object's destructor, and then freeing the memory using the parameterized <code>ALLOCATOR</code> (allocator or pool) also supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="~22raw~22_warning"></a> <a class="anchor" id="description.~22raw~22_warning"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Raw</b></dt><dd>Warning:  </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that this component should be used only if we are sure that the supplied pointer is <b>not</b> of a type that is a secondary base class -- i.e., the (managed) object's address is (numerically) the same as when it was originally dispensed by <code>ALLOCATOR</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirement"></a> <a class="anchor" id="description.requirement"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Requirement: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The parameterized <code>ALLOCATOR</code> type of the <code><a class="el" href="classbslma_1_1RawDeleterGuard.html">bslma::RawDeleterGuard</a></code> class template must provide a (possibly <code>virtual</code>) method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
</pre></div><br/>
<br/>
 to deallocate memory at the specified <code>address</code> (originally supplied by the <code>ALLOCATOR</code> object). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example shows how one might use a <code><a class="el" href="classbslma_1_1RawDeleterGuard.html">bslma::RawDeleterGuard</a></code> to guard a dynamically-allocated object, deleting that object automatically when the guard goes out of scope. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have a simple queue class that stores object values using an "out-of-place" representation (i.e., an array of dynamically-allocated object pointers): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_queue.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>my_Queue {
      <span class="comment">// This class is a container that uses an &quot;out-of-place&quot;</span>
      <span class="comment">// representation to manage objects of parameterized &#39;TYPE&#39;.  Note</span>
      <span class="comment">// that this class is implemented with the native version of &#39;deque&#39;,</span>
      <span class="comment">// instead of the version provided in &#39;bslstl_Deque&#39;.  This is so that</span>
      <span class="comment">// a circular dependency in the physical hierarchy will not be created.</span>

      <span class="comment">// DATA</span>
      std::deque&lt;TYPE *&gt;   d_objects;      <span class="comment">// objects stored in the queue</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>    *d_allocator_p;  <span class="comment">// allocator (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_Queue(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;my_Queue&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// ...</span>

      ~my_Queue();
          <span class="comment">// Destroy this &#39;my_Queue&#39; object and all elements currently</span>
          <span class="comment">// stored.</span>

      <span class="comment">// MANIPULATORS</span>

      <span class="comment">// ...</span>

      <span class="keywordtype">void</span> pushBack(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>);
          <span class="comment">// Push the value of the specified &#39;object&#39; of parameterized &#39;TYPE&#39;</span>
          <span class="comment">// onto the back of this queue.</span>

      TYPE popFront();
          <span class="comment">// Remove and return (by value) the object of parameterized &#39;TYPE&#39;</span>
          <span class="comment">// that is currently at the front of this queue.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Note that the <code>popFront</code> method returns an object by value because (1) there may be no reasonable default object to pass in, (2) there may be no reasonable copy assignment semantics, or (3) it is simply more syntactically convenient (e.g., if, say, the queued objects are themselves pointers): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  my_Queue&lt;TYPE&gt;::my_Queue(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_objects(basicAllocator)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  my_Queue&lt;TYPE&gt;::~my_Queue()
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d_objects.size(); ++i) {
          d_allocator_p-&gt;deleteObjectRaw(d_objects[i]);
      }
  }
</pre></div><br/>
<br/>
 Note that the <code>pushBack</code> method should be implemented with a constructor proxy that determines whether <code>TYPE</code> takes an allocator at construction (see <code>bslalg_constructorproxy</code>). However, for the purpose of this example, the implementation is simplified by assuming <code>TYPE</code> takes an allocator. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_Queue&lt;TYPE&gt;::pushBack(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>)
  {
      TYPE *tmp = (TYPE *)<span class="keyword">new</span>(*d_allocator_p) TYPE(<span class="keywordtype">object</span>);
      d_objects.push_back(tmp);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  TYPE my_Queue&lt;TYPE&gt;::popFront()
  {
      TYPE *tmp = d_objects.front();
      d_objects.pop_front();

      <span class="comment">//***********************************************************</span>
      <span class="comment">//* Note the use of the raw deleter guard on &#39;tmp&#39; (below). *</span>
      <span class="comment">//***********************************************************</span>

      <a class="code" href="classbslma_1_1RawDeleterGuard.html">bslma::RawDeleterGuard&lt;TYPE, bslma::Allocator&gt;</a>
                                                   guard(tmp, d_allocator_p);

      <span class="keywordflow">return</span> *tmp;
  }
</pre></div><br/>
<br/>
 The <code>pushBack</code> method defined above stores a copy of the provided object. The <code>popFront</code> method returns the leading object by value, and the <code><a class="el" href="classbslma_1_1RawDeleterGuard.html">bslma::RawDeleterGuard</a></code> is used to automatically delete the copy the queue manages when the guard goes out of scope (i.e., when the function returns). </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
