<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: balst_stacktracetestallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component balst_stacktracetestallocator<br/>
<small>
[<a class="el" href="group__balst.html">Package balst</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a test allocator that reports the call stack for leaks.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebalst.html">balst</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Overhead / Efficiency</a> </li>
<li>
<a href="#3.2">Failure Handler</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a test allocator that reports the call stack for leaks. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbalst_1_1StackTraceTestAllocator.html">balst::StackTraceTestAllocator</a> </td><td>allocator that reports call stack for leaks  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides an instrumented allocator, <code><a class="el" href="classbalst_1_1StackTraceTestAllocator.html">balst::StackTraceTestAllocator</a></code>, that implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> protocol. An object of this type records the call stack for each allocation performed, and can report, either using the <code>reportBlocksInUse</code> method or implicitly at destruction, the call stack associated with every allocated block that has not (yet) been freed. It is optionally supplied a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> at construction that it uses to allocate memory. <br/>
<br/>
<div class="fragment"><pre class="fragment">                    ,------------------------------.
                   ( <a class="code" href="classbalst_1_1StackTraceTestAllocator.html">balst::StackTraceTestAllocator</a>  )
                    `------------------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                                    |    ctor/dtor</span>
<span class="stringliteral">                                    |    numBlocksInUse</span>
<span class="stringliteral">                                    |    reportBlocksInUse</span>
<span class="stringliteral">                                    |    setFailureHandler</span>
<span class="stringliteral">                                    V</span>
<span class="stringliteral">                         ,----------------------.</span>
<span class="stringliteral">                        ( bdlma::ManagedAllocator)</span>
<span class="stringliteral">                         `----------------------&#39;</span>
                                    |    release
                                    <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>
                             ,----------------.
                            ( <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> )
                             `----------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                                         allocate</span>
<span class="stringliteral">                                         deallocate</span>
</pre></div><br/>
<br/>
 Note that allocation using a <code><a class="el" href="classbalst_1_1StackTraceTestAllocator.html">balst::StackTraceTestAllocator</a></code> is deliberately incompatible with the default global <code>new</code>, <code>malloc</code>, <code>delete</code>, and <code>free</code>. Using <code>delete</code> or <code>free</code> to free memory supplied by this allocator will corrupt the dynamic memory manager and also cause a memory leak (and will be reported by purify as freeing mismatched memory, freeing unallocated memory, or as a memory leak). Using <code>deallocate</code> to free memory supplied by global <code>new</code> or <code>malloc</code> will immediately cause an error to be reported to the associated <code>ostream</code> and the abort handler (which can be configured to be a no-op) called. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="overhead_~2F_efficiency"></a> <a class="anchor" id="description.overhead_~2F_efficiency"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Overhead / Efficiency: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There is some overhead to using this allocator. It's is slower than <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> and uses more memory. It is, however, comparable in speed and memory usage to <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code>. The stack trace stored for each allocation is stack pointers only, which are compact and quick to obtain. Actual resolving of the stack pointer to subroutine names and, on some platforms, source file names and line numbers, is expensive but doesn't happen during allocation or deallocation and is put off until a memory leak report is being generated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the overhead increases and efficiency decreases as the <code>numRecordedFrames</code> argument to the constructor is increased. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="failure_handler"></a> <a class="anchor" id="description.failure_handler"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Failure Handler: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An object of type <code><a class="el" href="classbalst_1_1StackTraceTestAllocator.html">balst::StackTraceTestAllocator</a></code> always has a failure handler associated with it. This a a configurable <code>bdef::Functton</code> object that will be called if any error condition is detected, after the error condition is reported. By default, it is set to <code><a class="el" href="classbalst_1_1StackTraceTestAllocator.html#a1eda6863792bc6e74d4d2d2b08c2f60b">balst::StackTraceTestAllocator::failAbort</a></code> which calls <code>abort</code>, but it may be set by <code>setFailureHandler</code> to another routine. If the client does not want a core dump to occur, it is recommended they do: <br/>
<br/>
<div class="fragment"><pre class="fragment">    stackTraceTestAllocator.setFailurehandler(
                                  &amp;<a class="code" href="classbalst_1_1StackTraceTestAllocator.html#aa7c4ea6bfb42eb10c0e9b8e1045bbb7e">balst::StackTraceTestAllocator::failNoop</a>);
</pre></div><br/>
<br/>
 The stack trace test allocator is prepared for the failure handler to return, throw (provided the client will catch the exception) or longjmp without undefined behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If a memory is found to be outstanding during destruction, that is considered a memory leak and a report is written. After the report, the failure handler is called, and if the failure handler returns, the leaked memory is then released. This means that if the failure handler throws or longjmps in this case, the leaked memory will not be freed, and there will be no way to release it afterward since the allocator will no longer exist. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will define a class <code>ShipsCrew</code> that does something, but leaks memory, and then we will demonstrate the use of the stack trace test allocator to locate the leak. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define <code>ShipsCrew</code>, a class that will read the names of a ship's crew from a file at construction, and make the results available through accessors: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>ShipsCrew {
      <span class="comment">// This struct will, at construction, read and parse a file describing</span>
      <span class="comment">// the names of the crew of a ship.</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">struct </span>CharStrLess {
          <span class="comment">// Functor to compare two &#39;const char *&#39;s in alphabetical order.</span>

          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *a, <span class="keyword">const</span> <span class="keywordtype">char</span> *b)<span class="keyword"> const</span>
<span class="keyword">          </span>{
              <span class="keywordflow">return</span> bsl::strcmp(a, b) &lt; 0;
          }
      };

      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1set.html">bsl::set&lt;const char *, CharStrLess&gt;</a> NameSet;

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span>       *d_captain;
      <span class="keyword">const</span> <span class="keywordtype">char</span>       *d_firstMate;
      <span class="keyword">const</span> <span class="keywordtype">char</span>       *d_cook;
      NameSet           d_sailors;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> addSailor(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name);
          <span class="comment">// Add the specified &#39;name&#39; to the set of sailor&#39;s names.</span>
          <span class="comment">// Redundant names are ignored.</span>

      <span class="keyword">const</span> <span class="keywordtype">char</span> *copy(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; str);
          <span class="comment">// Allocate memory for a copy of the specified &#39;str&#39; as a char</span>
          <span class="comment">// array, copy the contents of &#39;str&#39; into it, and return a pointer</span>
          <span class="comment">// to the new copy.</span>

      <span class="keywordtype">void</span> free(<span class="keyword">const</span> <span class="keywordtype">char</span> **str);
          <span class="comment">// If &#39;0 != str&#39;, deallocate &#39;*str&#39; using the allocator associated</span>
          <span class="comment">// with this object and set &#39;*str&#39; to 0, otherwise do nothing.  The</span>
          <span class="comment">// behavior is undefined if &#39;0 == str&#39;.</span>

      <span class="keywordtype">void</span> setCaptain(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name);
          <span class="comment">// Set the name of the ship&#39;s captain to the specified &#39;name&#39;.</span>

      <span class="keywordtype">void</span> setCook(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name);
          <span class="comment">// Set the name of the ship&#39;s cook to the specified &#39;name&#39;.</span>

      <span class="keywordtype">void</span> setFirstMate(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name);
          <span class="comment">// Set the name of the ship&#39;s first mate to the specified &#39;name&#39;.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span>
      ShipsCrew(<span class="keyword">const</span> <span class="keywordtype">char</span>        *crewFileName,
                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Read the names of the ship&#39;s crew in from the file with the</span>
          <span class="comment">// specified name &#39;crewFileName&#39;.</span>

      ~ShipsCrew();
          <span class="comment">// Destroy this object and free memory.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *captain();
          <span class="comment">// Return the captain&#39;s name.</span>

      <span class="keyword">const</span> <span class="keywordtype">char</span> *cook();
          <span class="comment">// Return the cook&#39;s name.</span>

      <span class="keyword">const</span> <span class="keywordtype">char</span> *firstMate();
          <span class="comment">// Return the first mate&#39;s name.</span>

      <span class="keyword">const</span> <span class="keywordtype">char</span> *firstSailor();
          <span class="comment">// Return the name of the sailor whose name is alphabetically the</span>
          <span class="comment">// first in the list.</span>

      <span class="keyword">const</span> <span class="keywordtype">char</span> *nextSailor(<span class="keyword">const</span> <span class="keywordtype">char</span> *currentSailor);
          <span class="comment">// Return the next sailor alphabetically after the specified</span>
          <span class="comment">// &#39;currentSailor&#39;, or 0 if &#39;currentSailor&#39; is the last in the list</span>
          <span class="comment">// or not found.  The behavior is undefined if</span>
          <span class="comment">// &#39;0 == currentSailor&#39;.</span>
  };
</pre></div><br/>
<br/>
 Then, we implement the private manipulators of the class: <br/>
<br/>
<div class="fragment"><pre class="fragment"> PRIVATE MANIPULATORS
  <span class="keywordtype">void</span> ShipsCrew::addSailor(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name)
  {
      <span class="keywordflow">if</span> (!d_sailors.count(name.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>())) {
          d_sailors.insert(copy(name));
      }
  }

  <span class="keyword">const</span> <span class="keywordtype">char</span> *ShipsCrew::copy(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; str)
  {
      <span class="keywordtype">char</span> *result = (<span class="keywordtype">char</span> *) d_allocator_p-&gt;allocate(str.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>() + 1);
      bsl::strcpy(result, str.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>());
      <span class="keywordflow">return</span> result;
  }

  <span class="keywordtype">void</span> ShipsCrew::free(<span class="keyword">const</span> <span class="keywordtype">char</span> **str)
  {
      assert(str);

      <span class="keywordflow">if</span> (*str) {
          d_allocator_p-&gt;deallocate(const_cast&lt;char *&gt;(*str));
          *str = 0;
      }
  }

  <span class="keywordtype">void</span> ShipsCrew::setCaptain(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name)
  {
      free(&amp;d_captain);

      d_captain = copy(name);
  }

  <span class="keywordtype">void</span> ShipsCrew::setCook(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name)
  {
      free(&amp;d_cook);

      d_cook = copy(name);
  }

  <span class="keywordtype">void</span> ShipsCrew::setFirstMate(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name)
  {
      free(&amp;d_firstMate);

      d_firstMate = copy(name);
  }
</pre></div><br/>
<br/>
 Next, we implement the creators: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  ShipsCrew::ShipsCrew(<span class="keyword">const</span> <span class="keywordtype">char</span>       *crewFileName,
                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_captain(0)
  , d_firstMate(0)
  , d_cook(0)
  , d_sailors(    bslma::Default::allocator(basicAllocator))
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
      bsl::ifstream input(crewFileName);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(!input.eof() &amp;&amp; !input.bad());

      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> line(d_allocator_p);

      <span class="keywordflow">while</span> (!input.bad() &amp;&amp; !input.eof()) {
          <a class="code" href="group__bslstl__string.html#ga541ba270c84fdb45c5df71a668aa5d9d">bsl::getline</a>(input, line);

          bsl::size_t colon = line.find(<span class="charliteral">&#39;:&#39;</span>);
          <span class="keywordflow">if</span> (<a class="code" href="group__bslstl__string.html#gaf79bc85dc723320ef0f88c6c86946d3c">bsl::string::npos</a> != colon) {
              <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; field = line.substr(0, colon);
              <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name  = line.<a class="code" href="group__bslstl__string.html#ga17ae54972c60d59aed466eff43492ec3">substr</a>(colon + 1);

              <span class="keywordflow">if</span>      (0 == <a class="code" href="structbdlb_1_1String.html#adf552c03043afe171ab00488d6b37f08">bdlb::String::lowerCaseCmp</a>(field, <span class="stringliteral">&quot;captain&quot;</span>)) {
                  setCaptain(name);
              }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == <a class="code" href="structbdlb_1_1String.html#adf552c03043afe171ab00488d6b37f08">bdlb::String::lowerCaseCmp</a>(field, <span class="stringliteral">&quot;first mate&quot;</span>)){
                  setFirstMate(name);
              }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == <a class="code" href="structbdlb_1_1String.html#adf552c03043afe171ab00488d6b37f08">bdlb::String::lowerCaseCmp</a>(field, <span class="stringliteral">&quot;cook&quot;</span>)) {
                  setCook(name);
              }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == <a class="code" href="structbdlb_1_1String.html#adf552c03043afe171ab00488d6b37f08">bdlb::String::lowerCaseCmp</a>(field, <span class="stringliteral">&quot;sailor&quot;</span>)) {
                  addSailor(name);
              }
              <span class="keywordflow">else</span> {
                  cerr &lt;&lt; <span class="stringliteral">&quot;Unrecognized field &#39;&quot;</span> &lt;&lt; field &lt;&lt; <span class="stringliteral">&quot;&#39; in line &#39;&quot;</span> &lt;&lt;
                                                               line &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;
              }
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!line.empty()) {
              cerr &lt;&lt; <span class="stringliteral">&quot;Garbled line &#39;&quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;
          }
      }
  }

  ShipsCrew::~ShipsCrew()
  {
      free(&amp;d_captain);
      free(&amp;d_firstMate);

      <span class="comment">// Note that deallocating the strings will invalidate &#39;d_sailors&#39; --</span>
      <span class="comment">// any manipulation of &#39;d_sailors&#39; other than destruction after this</span>
      <span class="comment">// would lead to undefined behavior.</span>

      <span class="keyword">const</span> NameSet::iterator end = d_sailors.end();
      <span class="keywordflow">for</span> (NameSet::iterator it = d_sailors.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>(); end != it; ++it) {
          d_allocator_p-&gt;deallocate(const_cast&lt;char *&gt;(*it));
      }
  }
</pre></div><br/>
<br/>
 Then, we implement the public accessors: <br/>
<br/>
<div class="fragment"><pre class="fragment"> ACCESSORS
  <span class="keyword">const</span> <span class="keywordtype">char</span> *ShipsCrew::captain()
  {
      <span class="keywordflow">return</span> d_captain ? d_captain : <span class="stringliteral">&quot;&quot;</span>;
  }

  <span class="keyword">const</span> <span class="keywordtype">char</span> *ShipsCrew::cook()
  {
      <span class="keywordflow">return</span> d_cook ? d_cook : <span class="stringliteral">&quot;&quot;</span>;
  }

  <span class="keyword">const</span> <span class="keywordtype">char</span> *ShipsCrew::firstMate()
  {
      <span class="keywordflow">return</span> d_firstMate ? d_firstMate : <span class="stringliteral">&quot;&quot;</span>;
  }

  <span class="keyword">const</span> <span class="keywordtype">char</span> *ShipsCrew::firstSailor()
  {
      NameSet::iterator it = d_sailors.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>();
      <span class="keywordflow">return</span> d_sailors.end() == it ? 0 : *it;
  }

  <span class="keyword">const</span> <span class="keywordtype">char</span> *ShipsCrew::nextSailor(<span class="keyword">const</span> <span class="keywordtype">char</span> *currentSailor)
  {
      assert(currentSailor);
      NameSet::iterator it = d_sailors.find(currentSailor);
      <span class="keywordflow">if</span> (d_sailors.end() != it) {
          ++it;
      }
      <span class="keywordflow">return</span> d_sailors.end() == it ? 0 : *it;
  }
</pre></div><br/>
<br/>
 Next, in <code>main</code>, we create our file <code>./shipscrew.txt</code> describing the crew of the ship. Note that the order of crew members is not important: <br/>
<br/>
<div class="fragment"><pre class="fragment">      {
          bsl::ofstream outFile(<span class="stringliteral">&quot;shipscrew.txt&quot;</span>);

          outFile &lt;&lt; <span class="stringliteral">&quot;sailor:Mitch Sandler\n&quot;</span>
                  &lt;&lt; <span class="stringliteral">&quot;sailor:Ben Lampert\n&quot;</span>
                  &lt;&lt; <span class="stringliteral">&quot;cook:Bob Jones\n&quot;</span>
                  &lt;&lt; <span class="stringliteral">&quot;captain:Steve Miller\n&quot;</span>
                  &lt;&lt; <span class="stringliteral">&quot;sailor:Daniel Smith\n&quot;</span>
                  &lt;&lt; <span class="stringliteral">&quot;first mate:Sally Chandler\n&quot;</span>
                  &lt;&lt; <span class="stringliteral">&quot;sailor:Joe Owens\n&quot;</span>;
      }
</pre></div><br/>
<br/>
 Then, we set up a test case to test our <code>ShipsCrew</code> class. We do not use the stack trace test allocator yet, we just use a <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> to get memory usage statistics and determine whether any leakage occurred. <br/>
<br/>
<div class="fragment"><pre class="fragment">      {
          <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta(<span class="stringliteral">&quot;Bslma Test Allocator&quot;</span>);
          <a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a> tam(&amp;ta);

          {
              ShipsCrew crew(<span class="stringliteral">&quot;shipscrew.txt&quot;</span>, &amp;ta);
              assert(tam.isInUseUp());
              assert(tam.isTotalUp());

              <span class="keywordflow">if</span> (verbose) {
                  cout &lt;&lt; <span class="stringliteral">&quot;Captain: &quot;</span>  &lt;&lt; crew.captain() &lt;&lt;
                      <span class="stringliteral">&quot;\nFirst Mate: &quot;</span> &lt;&lt; crew.firstMate() &lt;&lt;
                      <span class="stringliteral">&quot;\nCook: &quot;</span>       &lt;&lt; crew.cook() &lt;&lt; endl;
                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *sailor = crew.firstSailor(); sailor;
                                          sailor = crew.nextSailor(sailor)) {
                      cout &lt;&lt; <span class="stringliteral">&quot;Sailor: &quot;</span> &lt;&lt; sailor &lt;&lt; endl;
                  }
              }
          }

          <span class="keywordtype">int</span> bytesLeaked = ta.<a class="code" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse</a>();
          <span class="keywordflow">if</span> (bytesLeaked &gt; 0) {
              cout &lt;&lt; bytesLeaked &lt;&lt; <span class="stringliteral">&quot; bytes of memory were leaked!\n&quot;</span>;
          }
      }
</pre></div><br/>
<br/>
 The program generates the following output in non-verbose mode, telling us that one segment of 10 bytes was leaked: <br/>
<br/>
<div class="fragment"><pre class="fragment">  10 bytes of memory were leaked!
  MEMORY_LEAK from Bslma Test Allocator:
  Number of blocks in use = 1
  Number of bytes in use = 10
</pre></div><br/>
<br/>
 Next, we would like to use stack trace test allocator to tell us WHERE the memory leak is, but we have a problem: our test case not only uses <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code>, but it calls the <code>numBytesInUse</code> accessor, which is not available from stack trace test allocator. We are also using <code><a class="el" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a></code>, which will only work with <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code>. So if we were to just substitute the stack trace test allocator for the bslma test allocator, it would break our test case in several ways. To instrument our test with a minimal change to the code, we create a stack test test allocator and feed that allocator to the constructor to bslma test allocator. The rest of our example will now work without modification. (Note that it is important to call <code>ta.setNoAbort(true)</code> when we use this method, otherwise the bslma test allocator will bomb out before the destructor for <code>stta</code> is able to generate its report). <br/>
<br/>
<div class="fragment"><pre class="fragment">      {
          <a class="code" href="classbalst_1_1StackTraceTestAllocator.html">balst::StackTraceTestAllocator</a> stta;
          stta.<a class="code" href="classbalst_1_1StackTraceTestAllocator.html#a7ffbc8406a6214acb5bc2a65946f1ca0">setName</a>(<span class="stringliteral">&quot;stta&quot;</span>);
          stta.<a class="code" href="classbalst_1_1StackTraceTestAllocator.html#a1424d10032ced8faf9f6dedb212f2bc1">setFailureHandler</a>(&amp;stta.<a class="code" href="classbalst_1_1StackTraceTestAllocator.html#aa7c4ea6bfb42eb10c0e9b8e1045bbb7e">failNoop</a>);

          <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta(<span class="stringliteral">&quot;Bslma Test Allocator&quot;</span>, &amp;stta);
          ta.<a class="code" href="classbslma_1_1TestAllocator.html#ab558d4e20e4a93c43ea86a4f6cf71042">setNoAbort</a>(<span class="keyword">true</span>);

          <span class="comment">// the rest of the test case after this is totally unchanged</span>

          <a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a> tam(&amp;ta);

          {
              ShipsCrew crew(<span class="stringliteral">&quot;shipscrew.txt&quot;</span>, &amp;ta);
              assert(tam.isInUseUp());
              assert(tam.isTotalUp());

              <span class="keywordflow">if</span> (verbose) {
                  cout &lt;&lt; <span class="stringliteral">&quot;Captain: &quot;</span>  &lt;&lt; crew.captain() &lt;&lt;
                      <span class="stringliteral">&quot;\nFirst Mate: &quot;</span> &lt;&lt; crew.firstMate() &lt;&lt;
                      <span class="stringliteral">&quot;\nCook: &quot;</span>       &lt;&lt; crew.cook() &lt;&lt; endl;
                  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *sailor = crew.firstSailor(); sailor;
                                          sailor = crew.nextSailor(sailor)) {
                      cout &lt;&lt; <span class="stringliteral">&quot;Sailor: &quot;</span> &lt;&lt; sailor &lt;&lt; endl;
                  }
              }
          }

          <span class="keywordtype">int</span> bytesLeaked = ta.<a class="code" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse</a>();
          <span class="keywordflow">if</span> (bytesLeaked &gt; 0) {
              cout &lt;&lt; bytesLeaked &lt;&lt; <span class="stringliteral">&quot; bytes of memory were leaked!\n&quot;</span>;
          }
      }
</pre></div><br/>
<br/>
 Now, this generates the following report: <br/>
<br/>
<div class="fragment"><pre class="fragment">  10 bytes of memory were leaked!
  MEMORY_LEAK from Bslma Test Allocator:
    Number of blocks in use = 1
     Number of bytes in use = 10
  ===========================================================================
  Error: memory leaked:
  1 block(s) in allocator &#39;stta&#39; in use.
  Block(s) allocated from 1 trace(s).
  ---------------------------------------------------------------------------
  Allocation trace 1, 1 block(s) in use.
  Stack trace at allocation time:
  (0): BloombergLP::balst::StackTraceTestAllocator::allocate(<span class="keywordtype">int</span>)+0x17d at 0x
  805e741 in balst_stacktracetestallocator.t.dbg_exc_mt
  (1): BloombergLP::bslma::TestAllocator::allocate(<span class="keywordtype">int</span>)+0x12c at 0x8077398 in
   balst_stacktracetestallocator.t.dbg_exc_mt
  (2): ShipsCrew::copy(bsl::basic_string&lt;<span class="keywordtype">char</span>, std::char_traits&lt;<span class="keywordtype">char</span>&gt;, bsl::a
  llocator&lt;<span class="keywordtype">char</span>&gt; &gt; const&amp;)+0x31 at 0x804c3db in balst_stacktracetestallocator
  .t.dbg_exc_mt
  (3): ShipsCrew::setCook(bsl::basic_string&lt;<span class="keywordtype">char</span>, std::char_traits&lt;<span class="keywordtype">char</span>&gt;, bsl
  ::allocator&lt;<span class="keywordtype">char</span>&gt; &gt; const&amp;)+0x2d at 0x804c4c1 in balst_stacktracetestalloca
  tor.t.dbg_exc_mt
  (4): ShipsCrew::ShipsCrew(<span class="keywordtype">char</span> const*, BloombergLP::bslma::Allocator*)+0x23
  4 at 0x804c738 in balst_stacktracetestallocator.t.dbg_exc_mt
  (5): main+0x53c at 0x804d55e in balst_stacktracetestallocator.t.dbg_exc_mt
  (6): __libc_start_main+0xdc at 0x182e9c in /lib/libc.so.6
  (7): --unknown-- at 0x804c1d1 in balst_stacktracetestallocator.t.dbg_exc_mt
</pre></div><br/>
<br/>
 Finally, Inspection shows that frame (3) of the stack trace from the allocation of the leaked segment was from <code>ShipsCrew::setCook</code>. Inspection of the code shows that we neglected to free <code>d_cook</code> in the destructor and we can now easily fix our leak. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:35 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
