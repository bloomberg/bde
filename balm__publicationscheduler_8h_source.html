<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balm_publicationscheduler.h                                        -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALM_PUBLICATIONSCHEDULER
#define INCLUDED_BALM_PUBLICATIONSCHEDULER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a scheduler for publishing metrics.
//
//@CLASSES:
// balm::PublicationScheduler: a scheduler for publishing metrics
//
//@SEE_ALSO: balm_metricsmanager
//
//@DESCRIPTION:  This component defines a &#39;balm::PublicationScheduler&#39; class
// that provides a scheduling mechanism for the publication of metrics. At
// construction, a &#39;balm::PublicationScheduler&#39; is provided the addresses of a
// &#39;balm::MetricsManager&#39; and a &#39;bdlmt::TimerEventScheduler&#39;.  The publication
// scheduler provides a &#39;scheduleCategory&#39; method that schedules an individual
// metric category to be published repeatedly at a given interval, and a
// &#39;setDefaultSchedule&#39; method that schedules the publication of any category
// not given an individual schedule.  The &#39;balm::PublicationScheduler&#39; creates
// timer events using the &#39;bdlmt::TimerEventScheduler&#39;.  At the end of a
// scheduled time interval, the publication scheduler invokes the metrics
// manager&#39;s &#39;publish&#39; operation with the set of categories to publish.  Note
// that the publication scheduler will combine categories that occur at the
// same frequency into a single invocation of the metrics manager&#39;s &#39;publish&#39;
// operation.  The publication scheduler also provides a method to cancel the
// publication of a particular category, or of all categories.
//
///Thread Safety
///-------------
// &#39;balm::PublicationScheduler&#39; is fully *thread-safe*, meaning that all
// non-creator operations on a given instance can be safely invoked
// simultaneously from multiple threads.
//
///Usage
///-----
// The following example demonstrates how to use &#39;balm::PublicationScheduler&#39;.
// Before instantiating the publication scheduler, we create a
// &#39;bdlmt::TimerEventScheduler&#39; as well as a &#39;balm::MetricsManager&#39;.  We obtain
// collectors for three different metric categories, &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;, that
// we will use to generate metric values for publication.
//..
//  bslma::Allocator         *allocator = bslma::Default::allocator(0);
//  bdlmt::TimerEventScheduler  timer(allocator);
//  balm::MetricsManager       manager(allocator);
//
//  balm::Collector *A = manager.collectorRepository().getDefaultCollector(
//                                                                   &quot;A&quot;, &quot;a&quot;);
//  balm::Collector *B = manager.collectorRepository().getDefaultCollector(
//                                                                   &quot;B&quot;, &quot;b&quot;);
//  balm::Collector *C = manager.collectorRepository().getDefaultCollector(
//                                                                   &quot;C&quot;, &quot;c&quot;);
//..
// We now create an instance of &#39;SimpleStreamPublisher&#39;, which implements the
// &#39;balm::Publisher&#39; protocol.  Note that &#39;SimpleStreamPublisher&#39; is an
// example implementation of the &#39;balm::Publisher&#39; protocol defined in the
// &#39;balm_publisher&#39; component.  In practice, clients typically use a standard
// publisher class (e.g., &#39;balm::StreamPublisher&#39;).
//..
//      bsl::shared_ptr&lt;balm::Publisher&gt; publisher(
//                          new (*allocator) SimpleStreamPublisher(bsl::cout),
//                          allocator);
//..
// We now register the &#39;publisher&#39; we have created with the metrics &#39;manager&#39;
// to publish our categories.  Then, we &#39;start&#39; the timer-event scheduler we
// will supply to the &#39;balm::PublicationScheduler&#39;.
//..
//  manager.addGeneralPublisher(publisher);
//  timer.start();
//..
// Now we construct a &#39;balm::PublicationScheduler&#39; and pass it the respective
// addresses of both the metrics manager and the timer-event scheduler.  We
// schedule the publication of category &quot;A&quot; and &quot;B&quot; every .05 seconds, then we
// set the scheduled default publication to every .10 seconds.  Note that those
// time intervals were chosen to ensure fast and consistent output for this
// example.  In normal usage the interval between publications should be large
// enough to ensure that metric publication does not negatively affect the
// performance of the application (a 30 second interval is typical).
//..
//  balm::PublicationScheduler scheduler(&amp;manager, &amp;timer, allocator);
//  scheduler.scheduleCategory(&quot;A&quot;, bsls::TimeInterval(.05));
//  scheduler.scheduleCategory(&quot;B&quot;, bsls::TimeInterval(.05));
//  scheduler.setDefaultSchedule(bsls::TimeInterval(.10));
//..
// We can use the accessor operations to verify the schedule that we have
// specified.
//..
//  bsls::TimeInterval intervalA, intervalB, intervalC, defaultInterval;
//  assert( scheduler.findCategorySchedule(&amp;intervalA, &quot;A&quot;));
//  assert( scheduler.findCategorySchedule(&amp;intervalB, &quot;B&quot;));
//  assert(!scheduler.findCategorySchedule(&amp;intervalC, &quot;C&quot;));
//  assert( scheduler.getDefaultSchedule(&amp;defaultInterval));
//
//  assert(bsls::TimeInterval(.05) == intervalA);
//  assert(bsls::TimeInterval(.05) == intervalB);
//  assert(bsls::TimeInterval(.10) == defaultInterval);
//..
// Finally we add a couple of metrics and wait just over .1 seconds.
//..
//  A-&gt;update(1.0);
//  B-&gt;update(2.0);
//  C-&gt;update(3.0);
//  bslmt::ThreadUtil::sleep(bsls::TimeInterval(.11));
//..
// The output of the publication should look similar to:
//..
// 19NOV2008_18:34:26.766+0000    2 Records   0.0517s Elapsed Time
//         A.a [count = 1, total = 1, min = 1, max = 1]
//         B.b [count = 1, total = 2, min = 2, max = 2]
// 19NOV2008_18:34:26.816+0000    2 Records   0.050183s Elapsed Time
//         A.a [count = 0, total = 0, min = inf, max = -inf]
//         B.b [count = 0, total = 0, min = inf, max = -inf]
// 19NOV2008_18:34:26.817+0000    1 Records   0.102473s Elapsed Time
//         C.c [count = 1, total = 3, min = 3, max = 3]
//..
// Note that category &#39;C&#39; is published as part of the scheduled default
// publication.  Also note that categories &#39;A&#39; and &#39;B&#39; are emitted as a single
// publication: the scheduler combines categories published at the same
// frequency into a single publication event to minimize the number of times
// &#39;balm::MetricsManager::publish&#39; is invoked.

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALM_METRICSMANAGER
#include &lt;balm_metricsmanager.h&gt;
#endif

#ifndef INCLUDED_BSLMT_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_BDLMT_TIMEREVENTSCHEDULER
#include &lt;bdlmt_timereventscheduler.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_MAP
#include &lt;bsl_map.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

#ifndef INCLUDED_BSL_SET
#include &lt;bsl_set.h&gt;
#endif

#ifndef INCLUDED_BSL_UTILITY
#include &lt;bsl_utility.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {


namespace balm {

class Category;

class PublicationScheduler_ClockData;  // defined in implementation
class PublicationScheduler_Proctor;    // defined in implementation

                         // ==========================
                         // class PublicationScheduler
                         // ==========================

class PublicationScheduler {
    // This class defines a mechanism for scheduling the periodic publication
    // of metrics.  Each publication scheduler object is supplied the address
    // of a &#39;MetricsManager&#39; and a &#39;bdlmt::TimerEventScheduler&#39; at
    // construction.  The metrics manager is used to publish metrics, while
    // the timer-event scheduler provides the underlying scheduling mechanism.
    // Metrics are scheduled for publication using the &#39;scheduleCategory&#39; and
    // &#39;setDefaultSchedule&#39; methods.  The &#39;scheduleCategory&#39; method schedules
    // an individual category to be publisher periodically at the provided
    // interval, whereas &#39;setDefaultSchedule&#39; schedules the periodic
    // publication of any category not given an individual schedule.  The
    // publication scheduler will create a recurring timer for each unique
    // time interval supplied, and will group together categories that share a
    // common time interval into a single call to &#39;MetricsManager::publish&#39;.
    // Note that it is left unspecified whether publication events that occur
    // on a common multiple of *different* intervals will be grouped into a
    // single invocation of &#39;MetricsManager::publish&#39;.

    // PRIVATE TYPES
    typedef PublicationScheduler_ClockData                  ClockData;
        // A private implementation type holding the data for a scheduled
        // publication frequency (e.g., the set of categories published at that
        // frequency).  Each &quot;clock&quot; created in the underlying
        // &#39;bdlmt::TimerEventScheduler&#39; is associated with a &#39;ClockData&#39;
        // object.

    typedef bsl::map&lt;const Category *, bsls::TimeInterval&gt;   Categories;
        // A map from a category to the publication interval for that
        // category.

    typedef bsl::map&lt;bsls::TimeInterval,
                     bsl::shared_ptr&lt;ClockData&gt; &gt;                Clocks;
        // A map from a time interval (i.e., publication period) to the clock
        // information for that time interval.

    // DATA
    bdlmt::TimerEventScheduler *d_scheduler_p;  // event scheduler (held)

    MetricsManager      *d_manager_p;    // metrics manager (held)

    Categories                d_categories;   // map of category =&gt; schedule

    Clocks                    d_clocks;       // map of interval =&gt; clock info

    bsls::TimeInterval         d_defaultInterval;
                                              // default publication interval

    mutable bslmt::Mutex       d_mutex;        // synchronize access to data
                                              // (&#39;d_categories&#39;, &#39;d_clocks&#39;,
                                              // and &#39;d_defaultInterval&#39;)

    bslma::Allocator         *d_allocator_p;  // allocator (held, not owned)


    // NOT IMPLEMENTED
    PublicationScheduler(const PublicationScheduler&amp; );
    PublicationScheduler&amp; operator=(const PublicationScheduler&amp; );

    // FRIENDS
    friend class PublicationScheduler_Proctor;

    // PRIVATE MANIPULATORS
    void publish(bsl::shared_ptr&lt;ClockData&gt; clockData);
        // Publish, to the held &#39;MetricsManager&#39; object, the categories
        // indicated by the specified &#39;clockData&#39;.  Note that this operation
        // serves as the event callback provided to the underlying
        // &#39;bdlmt::TimerEventScheduler&#39;: this method is bound with a
        // &#39;ClockData&#39; object in the &#39;bsl::function&#39; objects provided to
        // &#39;d_scheduler_p&#39;.

    void cancelCategory(Categories::iterator categoryIterator);
        // Cancel the periodic publication of the category indicated by the
        // specified &#39;categoryIterator&#39;.  Any scheduled publication of the
        // indicated category is either canceled or completed before this
        // method returns.  The behavior is undefined unless
        // &#39;categoryIterator&#39;  is a valid iterator over &#39;d_categories&#39; and
        // &#39;d_mutex&#39; is *locked*.

    int cancelDefaultSchedule();
        // If the default publication schedule has been set (using
        // &#39;setDefaultSchedule&#39;), cancel that periodic default publication,
        // and return 0.  This method has no effect and will return a non-zero
        // value if a default publication schedule has not been set.  Any
        // scheduled publication is either canceled or completed before this
        // method returns.  The behavior is undefined unless &#39;d_mutex&#39; is
        // *locked*.

  public:
    // PUBLIC TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(PublicationScheduler,
                                                    bslma::UsesBslmaAllocator);

    // CREATORS
    PublicationScheduler(MetricsManager             *metricsManager,
                         bdlmt::TimerEventScheduler *eventScheduler,
                              bslma::Allocator      *basicAllocator = 0);
        // Create a publication scheduler that will use the specified
        // &#39;metricsManager&#39; to publish metrics, and the specified
        // &#39;eventScheduler&#39; to supply timer events.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    ~PublicationScheduler();
        // Destroy this publication scheduler and cancel any pending
        // publications.  Note that, if any metrics are currently being
        // published, this operation will block until all of their
        // publications have completed.

    // MANIPULATORS
    void scheduleCategory(const char                *category,
                          const bsls::TimeInterval&amp;  interval);
        // Schedule the specified null-terminated string &#39;category&#39; to be
        // published periodically at the specified &#39;interval&#39; using the
        // &#39;MetricManager&#39; supplied at construction.  If &#39;category&#39; has
        // *already* been scheduled, change the scheduled period to &#39;interval&#39;;
        // any previously scheduled publication of &#39;category&#39; is either
        // canceled or completed (atomically) prior to rescheduling.  If a
        // category is rescheduled with the same &#39;interval&#39; as it is currently
        // scheduled, this operation has no effect.  The behavior is undefined
        // unless &#39;bsls::TimeInterval(0, 0) &lt; interval&#39;.

    void scheduleCategory(const Category            *category,
                          const bsls::TimeInterval&amp;  interval);
        // Schedule the specified &#39;category&#39; to be published periodically at
        // the specified &#39;interval&#39; using the &#39;MetricManager&#39; supplied at
        // construction.  If &#39;category&#39; has *already* been scheduled, change
        // the scheduled period to &#39;interval&#39;; any previously scheduled
        // publication of &#39;category&#39; is either canceled or completed
        // (atomically) prior to rescheduling.  If a category is rescheduled
        // with the same &#39;interval&#39; as it is currently scheduled, this
        // operation has no effect.  The behavior is undefined unless
        // &#39;bsls::TimeInterval(0, 0) &lt; interval&#39; and &#39;category&#39; is a valid
        // address supplied by the &#39;balm::MetricRegistry&#39; owned by the
        // &#39;MetricsManager&#39; object supplied at construction.

    void setDefaultSchedule(const bsls::TimeInterval&amp; interval);
        // Set, to the specified &#39;interval&#39;, the default interval for metrics
        // to be periodically published using the &#39;MetricsManager&#39; supplied at
        // construction.  This method schedules every metric category not given
        // a individual schedule (using &#39;scheduleCategory&#39;), to be published
        // periodically until that category is either given an individual
        // schedule, or the default schedule is canceled (using either
        // &#39;clearDefaultSchedule&#39; or &#39;cancelAllPublications&#39;).  If a default
        // publication has *already* been scheduled, change its schedule to
        // &#39;interval&#39;; any previously scheduled publication is either canceled
        // or completed (atomically) before rescheduling.  If the default
        // publication is rescheduled with the same &#39;interval&#39; as it is
        // currently scheduled, this operation has no effect.  The behavior is
        // undefined unless &#39;bsls::TimeInterval(0, 0) &lt; interval&#39;.  Note that,
        // to exclude a category from any publication, clients can disable the
        // category using the &#39;MetricsManager&#39; object supplied at construction.

    int cancelCategorySchedule(const char *category);
        // Cancel the periodic publication of the specified null-terminated
        // string &#39;category&#39;.  Return 0 on success, and a non-zero value if the
        // &#39;category&#39; is not scheduled for publication.  Any scheduled
        // publication of &#39;category&#39; is either canceled or completed before
        // this method returns.  Note that if a default publication schedule
        // has been set (using &#39;setDefaultSchedule&#39;), then &#39;category&#39; will
        // continue to be published as part of that scheduled default
        // publication; to exclude a category from any publication, clients
        // can disable the category using the &#39;MetricsManager&#39; object supplied
        // at construction.

    int cancelCategorySchedule(const Category *category);
        // Cancel the periodic publication of the specified &#39;category&#39;.  Return
        // 0 on success, and a non-zero value if the &#39;category&#39; is not
        // scheduled for publication.  Any scheduled publication of &#39;category&#39;
        // is either canceled or completed before this method returns.  The
        // behavior is undefined unless &#39;category&#39; is a valid address supplied
        // by the &#39;balm::MetricRegistry&#39; owned by &#39;metricsManager&#39;.  Note that
        // if a default publication schedule has been set (using
        // &#39;setDefaultSchedule&#39;), then &#39;category&#39; will continue to be published
        // as part of that scheduled default publication; to exclude a category
        // from any publication, clients can disable the category using the
        // &#39;MetricsManager&#39; object supplied at construction.

    int clearDefaultSchedule();
        // If the default publication schedule has been set (using
        // &#39;setDefaultSchedule&#39;), cancel that periodic default publication, and
        // return 0.  This method has no effect and will return a non-zero
        // value if a default publication schedule has not been set.  Any
        // scheduled publication is either canceled or completed before this
        // method returns.

    void cancelAll();
        // Cancel all periodic publication of metrics.  This operation
        // (atomically) clears the default publication schedule and cancels the
        // publication schedule of any category individually scheduled using
        // the &#39;scheduleCategory&#39; method.  Any scheduled publication is either
        // canceled or completed before this method returns.

    MetricsManager *manager();
        // Return the address of the modifiable metrics manager for which this
        // publication scheduler publishes metrics.

    // ACCESSORS
    bool findCategorySchedule(bsls::TimeInterval  *result,
                              const char          *category) const;
        // Load into the specified &#39;result&#39; the individual schedule interval
        // (set using the &#39;scheduleCategory&#39; method) that corresponds to the
        // specified null-terminated string &#39;category&#39;, if found, and return
        // &#39;true&#39;, or (if not found) return &#39;false&#39; with no effect.  This
        // method will return &#39;false&#39; and will not modify &#39;result&#39; if
        // &#39;category&#39; is published as part of the default scheduled
        // publication.

    bool findCategorySchedule(bsls::TimeInterval  *result,
                              const Category      *category) const;
        // Load into the specified &#39;result&#39; the individual schedule interval
        // (set using the &#39;scheduleCategory&#39; method) that corresponds to the
        // specified &#39;category&#39;, if found, and return &#39;true&#39;, or (if not
        // found) return &#39;false&#39; with no effect.  This method will return
        // &#39;false&#39; and will not modify &#39;result&#39; if &#39;category&#39; is published as
        // part of the default scheduled publication.  The behavior is
        // undefined unless &#39;category&#39; is a valid address supplied by the
        // &#39;balm::MetricRegistry&#39; owned by the &#39;MetricsManager&#39; object
        // supplied at construction.

    bool getDefaultSchedule(bsls::TimeInterval *result) const;
        // Load into the specified &#39;result&#39; the default scheduled interval,
        // (set using the &#39;setDefaultSchedule&#39; method), for periodically
        // publishing metrics, if found, and return &#39;true&#39;, or (if not found)
        // return &#39;false&#39; with no effect.

    int getCategorySchedule(
                 bsl::vector&lt;bsl::pair&lt;const Category *,
                                       bsls::TimeInterval&gt; &gt;    *result) const;
        // Load into the specified &#39;result&#39; a representation of the current
        // schedule for publishing categories being followed by this scheduler
        // and return the number of scheduled categories.  The schedule is
        // represented using a series of (category address, time interval)
        // pairs; each pair in the series indicates the periodic time interval
        // that the associated category will be published.  Note that the
        // &#39;result&#39; of this operation contains only those categories scheduled
        // using the &#39;scheduleCategory&#39; operation, and does *not* include
        // categories published as part of the default publication.

    const MetricsManager *manager() const;
        // Return the address of the non-modifiable metrics manager for which
        // this publication scheduler will publish metrics.

    bsl::ostream&amp; print(bsl::ostream&amp;   stream,
                        int             level = 0,
                        int             spacesPerLevel = 4) const;
        // Print a formatted string describing the current state of this
        // &#39;PublicationScheduler&#39; object to the specified &#39;stream&#39; at the
        // (absolute value of) the optionally specified indentation &#39;level&#39;
        // and return a reference to &#39;stream&#39;.  If &#39;level&#39; is specified,
        // optionally specify &#39;spacesPerLevel&#39;, the number of spaces per
        // indentation level for this and all of its nested objects.  If
        // &#39;level&#39; is negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress all indentation AND format
        // the entire output on one line.  If &#39;stream&#39; is not valid on entry,
        // this operation has no effect.  Note that this is provided primarily
        // for debugging purposes.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                         // --------------------------
                         // class PublicationScheduler
                         // --------------------------

// MANIPULATORS
inline
MetricsManager *PublicationScheduler::manager()
{
    return d_manager_p;
}

inline
void PublicationScheduler::scheduleCategory(
                                           const char                *category,
                                           const bsls::TimeInterval&amp;  interval)
{
    scheduleCategory(d_manager_p-&gt;metricRegistry().getCategory(category),
                     interval);
}

inline
int PublicationScheduler::cancelCategorySchedule(const char *category)
{
    return cancelCategorySchedule(
                          d_manager_p-&gt;metricRegistry().getCategory(category));
}

// ACCESSORS
inline
const MetricsManager *PublicationScheduler::manager() const
{
    return d_manager_p;
}

inline
bool PublicationScheduler::findCategorySchedule(
                                            bsls::TimeInterval *result,
                                            const char         *category) const
{
    return findCategorySchedule(
                          result,
                          d_manager_p-&gt;metricRegistry().getCategory(category));
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
