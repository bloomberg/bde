<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btls::LeakyBucket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtls.html">btls</a>      </li>
      <li><a class="el" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btls::LeakyBucket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btls::LeakyBucket" -->
<p><code>#include &lt;<a class="el" href="btls__leakybucket_8h_source.html">btls_leakybucket.h</a>&gt;</code></p>

<p><a href="classbtls_1_1LeakyBucket-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#aa8cd468a6990c4d69a326f80f3a559b8">LeakyBucket</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> drainRate, <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> capacity, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;currentTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#ab5cbc121b8b6754e3ab156630bf57afd">~LeakyBucket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#a48daf4603b323a2de875a4f56e8b6ca9">calculateTimeToSubmit</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;currentTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#a1f986cf4fa6443e478e63b7eb6874e2f">reserve</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> numUnits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#abea0e72c5e3ffa360095663d36d55b96">cancelReserved</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> numUnits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#a0f3d1041cc8acbe89d45bc1cb11e7fb2">submitReserved</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> numUnits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#ab210177af09c0e7280b16cb6a918d3c8">reset</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;currentTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#ad776f372610c1dd22b10a150b57a8607">resetStatistics</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#afb8f911686508aaab6b634e3fe80a160">setRateAndCapacity</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> newRate, <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> newCapacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#a7965721460ec06f1485d8b27fd192246">submit</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> numUnits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#a76b0fdc8de95615d902ba7c725d98973">updateState</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;currentTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#a01a4dd4d1bfdd0221f7a19d3d0eac8e7">wouldOverflow</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;currentTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#ab0b2501d2c488aed6140f677f47ad495">capacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#aa7031549c8c4a19c38454ee3aaed4abb">drainRate</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#af4ff9f7b112ce3fd159b512b837a46c8">getStatistics</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *submittedUnits, <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *unusedUnits) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#a91c98059e9a8d60edde711bc19bfed92">lastUpdateTime</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#adc25fb89e420229749fc7c49d06f3058">statisticsCollectionStartTime</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#afe5cc2f409aad77fbcab4efe2fca7ab9">unitsInBucket</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#a62de5e3a8fa3c77db4b02968ea0c33a3">unitsReserved</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#acb47b87e25fdb9ecb459e881f738d140">calculateDrainTime</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> numUnits, <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> drainRate, bool ceilFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#ad12cdd5a66eb9982f84a61ca336a04ca">calculateTimeWindow</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> drainRate, <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> capacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtls_1_1LeakyBucket.html#aa7c07b150a20ea6a92a2e6ed3f54826d">calculateCapacity</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> drainRate, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeWindow)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This mechanism implements a leaky bucket that allows clients to monitor whether a resource is being consumed at a particular rate. The behavior of a leaky bucket is determined by two properties: the drain rate (in units/s) and capacity (in units), both of which can be specified at construction or using the <code>setRateAndCapacity</code> method.</p>
<p>Units can be added to a leaky bucket by either submitting them using the <code>submit</code> method or reserving them using the <code>reserve</code> method. Submitted units are removed from a leaky bucket at the drain rate, while reserved units stays unaffected in a leaky bucket until they are either cancelled (removed from the leaky bucket) using the <code>cancelReserved</code> method or submitted using the <code>submitReserved</code> method.</p>
<p>Adding units to a leaky bucket will cause it to overflow if after the units are added, the total number of units in the leaky bucket (including both submitted and reserved units) exceeds its capacity. A leaky bucket can be queried whether adding a specified number of units would cause it to overflow via the <code>wouldOverflow</code> method. If submitting units to a leaky bucket will cause it to overflow, the estimated amount of time to wait before 1 more units can be submitted without causing the leaky bucket to overflow can be determined using the <code>calculateTimeToSubmit</code> method.</p>
<p>The state of a leaky bucket must be updated manually using the <code>updateState</code> method supplying the current time interval. The time intervals supplied should all refer to the same time origin.</p>
<p>A leaky bucket keeps some statistics, including the number of submitted units, that can be accessed using the <code>getStatistics</code> method and reset using the <code>resetStatistics</code> method.</p>
<p>The class invariants are: </p>
<ul>
<li>
<code><a class="el" href="classbtls_1_1LeakyBucket.html#ab0b2501d2c488aed6140f677f47ad495">capacity()</a> &gt; 0</code>  </li>
<li>
<code><a class="el" href="classbtls_1_1LeakyBucket.html#aa7031549c8c4a19c38454ee3aaed4abb">drainRate()</a> &gt; 0</code>  </li>
</ul>
<p>This class: </p>
<ul>
<li>
is <em>exception</em> <em>neutral</em> (agnostic)  </li>
<li>
is <em>const</em> <em>thread-safe</em>  </li>
</ul>
<p>For terminology see <code>bsldoc_glossary</code>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa8cd468a6990c4d69a326f80f3a559b8"></a><!-- doxytag: member="btls::LeakyBucket::LeakyBucket" ref="aa8cd468a6990c4d69a326f80f3a559b8" args="(bsls::Types::Uint64 drainRate, bsls::Types::Uint64 capacity, const bsls::TimeInterval &amp;currentTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btls::LeakyBucket::LeakyBucket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>drainRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty leaky bucket having the specified <code>drainRate</code>, the specified <code>capacity</code>, and the specified <code>currentTime</code> as the initial <code>lastUpdateTime</code>. The behavior is undefined unless <code>0 &lt; newRate</code>, <code>0 &lt; newCapacity</code>, and <code>LLONG_MIN != currentTime.seconds()</code>. </p>

</div>
</div>
<a class="anchor" id="ab5cbc121b8b6754e3ab156630bf57afd"></a><!-- doxytag: member="btls::LeakyBucket::~LeakyBucket" ref="ab5cbc121b8b6754e3ab156630bf57afd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btls::LeakyBucket::~LeakyBucket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acb47b87e25fdb9ecb459e881f738d140"></a><!-- doxytag: member="btls::LeakyBucket::calculateDrainTime" ref="acb47b87e25fdb9ecb459e881f738d140" args="(bsls::Types::Uint64 numUnits, bsls::Types::Uint64 drainRate, bool ceilFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> btls::LeakyBucket::calculateDrainTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>numUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>drainRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ceilFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the time interval required to drain the specified <code>numUnits</code> at the specified <code>drainRate</code>, round up the number of nanoseconds in the time interval if the specified <code>ceilFlag</code> is set to <code>true</code>, otherwise, round down the number of nanoseconds. The behavior is undefined unless the number of seconds in the calculated interval may be represented by a 64-bit signed integral type. </p>

</div>
</div>
<a class="anchor" id="ad12cdd5a66eb9982f84a61ca336a04ca"></a><!-- doxytag: member="btls::LeakyBucket::calculateTimeWindow" ref="ad12cdd5a66eb9982f84a61ca336a04ca" args="(bsls::Types::Uint64 drainRate, bsls::Types::Uint64 capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> btls::LeakyBucket::calculateTimeWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>drainRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>capacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the time interval over which a leaky bucket <em>approximates</em> a moving-total of submitted units, as the rounded-down ratio between the specified <code>capacity</code> and the specified <code>drainRate</code>. If the rounded ratio is 0, return a time interval of 1 nanosecond. The behavior is undefined unless <code>drainRate &gt; 0</code> and <code>capacity / drainRate</code> can be represented with 64-bit signed integral type. </p>

</div>
</div>
<a class="anchor" id="aa7c07b150a20ea6a92a2e6ed3f54826d"></a><!-- doxytag: member="btls::LeakyBucket::calculateCapacity" ref="aa7c07b150a20ea6a92a2e6ed3f54826d" args="(bsls::Types::Uint64 drainRate, const bsls::TimeInterval &amp;timeWindow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> btls::LeakyBucket::calculateCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>drainRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeWindow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the capacity of a leaky bucket as the rounded-down product of the specified <code>drainRate</code> by the specified <code>timeWindow</code>. If the result evaluates to 0, return 1. The behavior is undefined unless the product of <code>drainRate</code> and <code>timeWindow</code> can be represented by a 64-bit unsigned integral type. </p>

</div>
</div>
<a class="anchor" id="a48daf4603b323a2de875a4f56e8b6ca9"></a><!-- doxytag: member="btls::LeakyBucket::calculateTimeToSubmit" ref="a48daf4603b323a2de875a4f56e8b6ca9" args="(const bsls::TimeInterval &amp;currentTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> btls::LeakyBucket::calculateTimeToSubmit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If 1 more unit can be submitted to this leaky bucket without causing it to overflow, then return a time interval of 0 immediately. Otherwise, first update the state of this leaky bucket to the specified <code>currentTime</code>. Then, return the estimated time interval that should pass from <code>currentTime</code> until 1 more unit can be submitted to this leaky bucket without causing it to overflow. The number of nanoseconds in the returned time interval is rounded up. Note that a time interval of 0 can still be return after the state of this leaky bucket has been updated to <code>currentTime</code>. Also note that after waiting for the returned time interval, clients should typically check again using this method, because additional units may have been submitted in the interim. The behavior is undefined unless <code>LLONG_MIN != currentTime.seconds()</code> and the total number of seconds in the time interval resulting from <code>currentTime - <a class="el" href="classbtls_1_1LeakyBucket.html#a91c98059e9a8d60edde711bc19bfed92">lastUpdateTime()</a></code> can be represented with a 64-bit signed integer. </p>

</div>
</div>
<a class="anchor" id="a1f986cf4fa6443e478e63b7eb6874e2f"></a><!-- doxytag: member="btls::LeakyBucket::reserve" ref="a1f986cf4fa6443e478e63b7eb6874e2f" args="(bsls::Types::Uint64 numUnits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>numUnits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve the specified <code>numUnits</code> for future use by this leaky bucket. The behavior is undefined unless <code><a class="el" href="classbtls_1_1LeakyBucket.html#a62de5e3a8fa3c77db4b02968ea0c33a3">unitsReserved()</a> + <a class="el" href="classbtls_1_1LeakyBucket.html#afe5cc2f409aad77fbcab4efe2fca7ab9">unitsInBucket()</a> + numOfUnits</code> can be represented by a 64-bit unsigned integral type. Note that after this operation, this bucket may overflow. Also note that the time interval between the invocations of <code>reserve</code> and <code>submitReserved</code> or <code>cancelReserved</code> should be kept as short as possible; otherwise, the precision of the time interval calculated by <code>calculateTimeToSubmit</code> may be negatively affected. </p>

</div>
</div>
<a class="anchor" id="abea0e72c5e3ffa360095663d36d55b96"></a><!-- doxytag: member="btls::LeakyBucket::cancelReserved" ref="abea0e72c5e3ffa360095663d36d55b96" args="(bsls::Types::Uint64 numUnits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::cancelReserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>numUnits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the specified <code>numUnits</code> that were previously reserved. This method reduces the number of reserved units by <code>numUnits</code>. The behavior is undefined unless <code>numUnits &lt;= <a class="el" href="classbtls_1_1LeakyBucket.html#a62de5e3a8fa3c77db4b02968ea0c33a3">unitsReserved()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a0f3d1041cc8acbe89d45bc1cb11e7fb2"></a><!-- doxytag: member="btls::LeakyBucket::submitReserved" ref="a0f3d1041cc8acbe89d45bc1cb11e7fb2" args="(bsls::Types::Uint64 numUnits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::submitReserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>numUnits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Submit the specified <code>numUnits</code> that were previously reserved. This method reduces the number of reserved units by <code>numUnits</code> and submits <code>numUnits</code> to this leaky bucket. The behavior is undefined unless <code>numUnits &lt;= <a class="el" href="classbtls_1_1LeakyBucket.html#a62de5e3a8fa3c77db4b02968ea0c33a3">unitsReserved()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ab210177af09c0e7280b16cb6a918d3c8"></a><!-- doxytag: member="btls::LeakyBucket::reset" ref="ab210177af09c0e7280b16cb6a918d3c8" args="(const bsls::TimeInterval &amp;currentTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the the following statistic counters for this leaky bucket to 0: <code>unitsInBucket</code>, <code>unitsReserved</code>, <code>submittedUnits</code>, and <code>unusedUnits</code>. Set the <code>lastUpdateTime</code> and the <code>statisticCollectionStartTime</code> to the specified <code>currentTime</code>. The behavior is undefined unless <code>LLONG_MIN != currentTime.seconds()</code>. </p>

</div>
</div>
<a class="anchor" id="ad776f372610c1dd22b10a150b57a8607"></a><!-- doxytag: member="btls::LeakyBucket::resetStatistics" ref="ad776f372610c1dd22b10a150b57a8607" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::resetStatistics </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the statics collected for this leaky bucket by setting the number of units used and the number of units submitted to 0, and set the <code>statisticsCollectionStartTime</code> to the <code>lastUpdateTime</code> of this leaky bucket. </p>

</div>
</div>
<a class="anchor" id="afb8f911686508aaab6b634e3fe80a160"></a><!-- doxytag: member="btls::LeakyBucket::setRateAndCapacity" ref="afb8f911686508aaab6b634e3fe80a160" args="(bsls::Types::Uint64 newRate, bsls::Types::Uint64 newCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::setRateAndCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>newRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>newCapacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the drain rate of this leaky bucket to the specified <code>newRate</code> and the capacity of this leaky bucket to the specified <code>newCapacity</code>. The behavior is undefined unless <code>0 &lt; newRate</code> and <code>0 &lt; newCapacity</code>. </p>

</div>
</div>
<a class="anchor" id="a7965721460ec06f1485d8b27fd192246"></a><!-- doxytag: member="btls::LeakyBucket::submit" ref="a7965721460ec06f1485d8b27fd192246" args="(bsls::Types::Uint64 numUnits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>numUnits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Submit the specified <code>numUnits</code> to this leaky bucket. The behavior is undefined unless <code><a class="el" href="classbtls_1_1LeakyBucket.html#a62de5e3a8fa3c77db4b02968ea0c33a3">unitsReserved()</a> + <a class="el" href="classbtls_1_1LeakyBucket.html#afe5cc2f409aad77fbcab4efe2fca7ab9">unitsInBucket()</a> + numUnits</code> can be represented by a 64-bit unsigned integral type. Note that after this operation, this leaky bucket may overflow. </p>

</div>
</div>
<a class="anchor" id="a76b0fdc8de95615d902ba7c725d98973"></a><!-- doxytag: member="btls::LeakyBucket::updateState" ref="a76b0fdc8de95615d902ba7c725d98973" args="(const bsls::TimeInterval &amp;currentTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::updateState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the <code>lastUpdateTime</code> of this leaky bucket to the specified <code>currentTime</code>. If <code>currentTime</code> is after <code>lastUpdateTime</code>, then update the <code>unitsInBucket</code> of this leaky bucket by subtracting from it the number of units drained from <code>lastUpdateTime</code> to <code>currentTime</code>. If <code>currentTime</code> is before the <code>statisticsCollectionStartTime</code> of this leaky bucket, set <code>statisticsCollectionStartTime</code> to <code>currentTime</code>. The behavior is undefined unless <code>LLONG_MIN != currentTime.seconds()</code> and the total number of seconds in the time interval resulting from <code>currentTime - <a class="el" href="classbtls_1_1LeakyBucket.html#a91c98059e9a8d60edde711bc19bfed92">lastUpdateTime()</a></code> can be represented with a 64-bit signed integer. </p>

</div>
</div>
<a class="anchor" id="a01a4dd4d1bfdd0221f7a19d3d0eac8e7"></a><!-- doxytag: member="btls::LeakyBucket::wouldOverflow" ref="a01a4dd4d1bfdd0221f7a19d3d0eac8e7" args="(const bsls::TimeInterval &amp;currentTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool btls::LeakyBucket::wouldOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the state of this this leaky bucket to the specified <code>currentTime</code>, and return <code>true</code> if adding 1 more unit to this leaky bucket would cause the total number of units held by this leaky bucket to exceed its capacity, and <code>false</code> otherwise. Note that this method counts both submitted units and reserved units toward the total number of units held by this leaky bucket. The behavior is undefined unless <code>LLONG_MIN != currentTime.seconds()</code> and the total number of seconds in the time interval resulting from <code>currentTime - <a class="el" href="classbtls_1_1LeakyBucket.html#a91c98059e9a8d60edde711bc19bfed92">lastUpdateTime()</a></code> can be represented with a 64-bit signed integer. </p>

</div>
</div>
<a class="anchor" id="ab0b2501d2c488aed6140f677f47ad495"></a><!-- doxytag: member="btls::LeakyBucket::capacity" ref="ab0b2501d2c488aed6140f677f47ad495" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> btls::LeakyBucket::capacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the capacity of this leaky bucket. </p>

</div>
</div>
<a class="anchor" id="aa7031549c8c4a19c38454ee3aaed4abb"></a><!-- doxytag: member="btls::LeakyBucket::drainRate" ref="aa7031549c8c4a19c38454ee3aaed4abb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> btls::LeakyBucket::drainRate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the drain rate of this leaky bucket. </p>

</div>
</div>
<a class="anchor" id="af4ff9f7b112ce3fd159b512b837a46c8"></a><!-- doxytag: member="btls::LeakyBucket::getStatistics" ref="af4ff9f7b112ce3fd159b512b837a46c8" args="(bsls::Types::Uint64 *submittedUnits, bsls::Types::Uint64 *unusedUnits) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btls::LeakyBucket::getStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>submittedUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>unusedUnits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>submittedUnits</code> and the specified <code>unusedUnits</code> respectively, the numbers of submitted units and the number of unused units for this leaky bucket from the <code>statisticsCollectionStartTime</code> to the <code>lastUpdateTime</code>. The number of unused units is the difference between the number of units that could have been consumed and the number of units actually submitted for the time period. </p>

</div>
</div>
<a class="anchor" id="a91c98059e9a8d60edde711bc19bfed92"></a><!-- doxytag: member="btls::LeakyBucket::lastUpdateTime" ref="a91c98059e9a8d60edde711bc19bfed92" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> btls::LeakyBucket::lastUpdateTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the time interval when this leaky bucket was last updated. </p>

</div>
</div>
<a class="anchor" id="adc25fb89e420229749fc7c49d06f3058"></a><!-- doxytag: member="btls::LeakyBucket::statisticsCollectionStartTime" ref="adc25fb89e420229749fc7c49d06f3058" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> btls::LeakyBucket::statisticsCollectionStartTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the time interval when the collection of the statistics (as returned by <code>getStatistics</code>) started. </p>

</div>
</div>
<a class="anchor" id="afe5cc2f409aad77fbcab4efe2fca7ab9"></a><!-- doxytag: member="btls::LeakyBucket::unitsInBucket" ref="afe5cc2f409aad77fbcab4efe2fca7ab9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> btls::LeakyBucket::unitsInBucket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of submitted units in this leaky bucket. </p>

</div>
</div>
<a class="anchor" id="a62de5e3a8fa3c77db4b02968ea0c33a3"></a><!-- doxytag: member="btls::LeakyBucket::unitsReserved" ref="a62de5e3a8fa3c77db4b02968ea0c33a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> btls::LeakyBucket::unitsReserved </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of reserved units in this leaky bucket. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btls__leakybucket_8h_source.html">btls_leakybucket.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:14 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
