<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bslx::ByteOutStream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslx.html">bslx</a>      </li>
      <li><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bslx::ByteOutStream Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslx::ByteOutStream" -->
<p><code>#include &lt;<a class="el" href="bslx__byteoutstream_8h_source.html">bslx_byteoutstream.h</a>&gt;</code></p>

<p><a href="classbslx_1_1ByteOutStream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a23275498da6f649495f340606b4d9bce">ByteOutStream</a> (int versionSelector, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#afe063178bd7ef27ef1b3261eed5cf990">ByteOutStream</a> (int versionSelector, bsl::size_t initialCapacity, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a5099120c406bb1912bbbfde40f5594bf">~ByteOutStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a5345556c2b464f78b944b1014e40b035">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#af963d9c4368d91a1fc8c2f7d73c0e47b">putLength</a> (int length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ae7619e342abd9d5fe61962f57d88e0b8">putVersion</a> (int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a84ddac9f28a79ff52f08a9eb9f3bb962">reserveCapacity</a> (bsl::size_t newCapacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ae5ff47e2018b81aed6042c851edc5644">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a853b3d56e06eeb03f70b79f73ebec2a5">putInt64</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a875dea6487f6be78d90f4ebb8761ccf9">putUint64</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ae360c406926dddfdf9a536c336d26a22">putInt56</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#af0f1493016e0722e0c98b5de729ad976">putUint56</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a7514d9612f188ab40eaf4f2638fc54da">putInt48</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#af294ab3d533e93314a725408e75dc93e">putUint48</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a0bd3c4efa90df9b19944aa541e0a6080">putInt40</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#aacc417c113ce0bdfe1147201bfed2f4f">putUint40</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a9221385b5b5e1f504b1e815646a4042c">putInt32</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a21924dc96a9b3b9a4ba7699c7b79ef7e">putUint32</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#aa901742f1a8417153a50971cd8fb143a">putInt24</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ac6869ee5f19ea23e8470b63ebbf4edfa">putUint24</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#aaaa3af05af9c4b019f40cfb91b72fc24">putInt16</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#abf4a456ec8e1d9fc533c6a7583f23410">putUint16</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ab5abb090ad8bf58261b2fac3a114ead5">putInt8</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ae8556c0448b37f6b9c807034e03fe900">putUint8</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a3655ecc5bca6422156e24fc26d6f3616">putFloat64</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a5ceb1392af9b627d65a1a20c587bc3f3">putFloat32</a> (float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#aedf28678a791614008ae0f3655f8ae71">putString</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a17b349aface53a32c005071cf9745a9a">putArrayInt64</a> (const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ab3fada9286e112f29990671590509c2b">putArrayUint64</a> (const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#acdb71af7f79d8bcd5a45af94fe1599f0">putArrayInt56</a> (const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a62da4d84d4b1b4db2b29b62f872a987e">putArrayUint56</a> (const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a706bd354855dd449ecd6411c8f67e9fe">putArrayInt48</a> (const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a8cb9a6359224bc25d66e0660695ff1a2">putArrayUint48</a> (const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#aaf91d1a1dc287dc5f06a07b087d50f9b">putArrayInt40</a> (const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a7f31eef59e97a31d3323fe746baab29b">putArrayUint40</a> (const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#aa1b1ab1e0d6ac667259b460173660eab">putArrayInt32</a> (const int *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#aa348f975b0289f841f80f5c82a553162">putArrayUint32</a> (const unsigned int *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a0f4549fadac23b328fb0ba78ff588d74">putArrayInt24</a> (const int *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ae12bd0daa1ad28efd1bb8d58742707a4">putArrayUint24</a> (const unsigned int *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ac45705c2ef2267934041f76711ea2de5">putArrayInt16</a> (const short *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ad7886d0c2d2d94ce94c27e91d66ab817">putArrayUint16</a> (const unsigned short *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a81ea15a0d7257a49f5d5b2cf39e3a78c">putArrayInt8</a> (const char *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a0f4949c9cf9500cfb3c909fc4313f4ae">putArrayInt8</a> (const signed char *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a380e2f7ca820b1798735488acc5c0f85">putArrayUint8</a> (const char *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ad71c64b1c24b50dce94afb19e220a75f">putArrayUint8</a> (const unsigned char *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a8d9b4dbaabfb10f93e31f62fec2efec4">putArrayFloat64</a> (const double *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#acc1d6265c60919e7ca1dcffea653b99a">putArrayFloat32</a> (const float *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#ab7d0bfcadcd4b7cee47aac8666cf601d">operator const void *</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a7d9db0d645b120742fe4cba85acb884f">bdexVersionSelector</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a0f7d24b0f595e758a093ed244475d6db">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a4dca2b645513876fde5d209a22bf839f">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a8746c84c9c3b1e304609840e0bff66f5">length</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteOutStream.html#a28adf3d10daa1a5eb15c07dffc0fe256">operator&lt;&lt;</a> (bsl::ostream &amp;, const <a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides output methods to externalize values, and C-style arrays of values, of the fundamental integral and floating-point types, as well as <code>bsl::string</code> values. In particular, each <code>put</code> method of this class is guaranteed to write stream data that can be read by the corresponding <code>get</code> method of <code><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a></code>. See the <code>bslx</code> package-level documentation for the definition of the BDEX <code>OutStream</code> protocol. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a23275498da6f649495f340606b4d9bce"></a><!-- doxytag: member="bslx::ByteOutStream::ByteOutStream" ref="a23275498da6f649495f340606b4d9bce" args="(int versionSelector, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteOutStream::ByteOutStream </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty output byte stream that will use the specified (<em>compile</em>-time-defined) <code>versionSelector</code> as needed (see <a href="group__bslx__byteoutstream.html#versioning" class="el">Versioning</a>). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Note that the <code>versionSelector</code> is expected to be formatted as "YYYYMMDD", a date representation. </p>

</div>
</div>
<a class="anchor" id="afe063178bd7ef27ef1b3261eed5cf990"></a><!-- doxytag: member="bslx::ByteOutStream::ByteOutStream" ref="afe063178bd7ef27ef1b3261eed5cf990" args="(int versionSelector, bsl::size_t initialCapacity, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteOutStream::ByteOutStream </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>initialCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty output byte stream having an initial buffer capacity of at least the specified <code>initialCapacity</code> (in bytes) and that will use the specified (<em>compile</em>-time-defined) <code>versionSelector</code> as needed (see <a href="group__bslx__byteoutstream.html#versioning" class="el">Versioning</a>). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Note that the <code>versionSelector</code> is expected to be formatted as "YYYYMMDD", a date representation. </p>

</div>
</div>
<a class="anchor" id="a5099120c406bb1912bbbfde40f5594bf"></a><!-- doxytag: member="bslx::ByteOutStream::~ByteOutStream" ref="a5099120c406bb1912bbbfde40f5594bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteOutStream::~ByteOutStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5345556c2b464f78b944b1014e40b035"></a><!-- doxytag: member="bslx::ByteOutStream::invalidate" ref="a5345556c2b464f78b944b1014e40b035" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::ByteOutStream::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put this output stream in an invalid state. This function has no effect if this stream is already invalid. </p>

</div>
</div>
<a class="anchor" id="af963d9c4368d91a1fc8c2f7d73c0e47b"></a><!-- doxytag: member="bslx::ByteOutStream::putLength" ref="af963d9c4368d91a1fc8c2f7d73c0e47b" args="(int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the specified <code>length</code> is less than 128, write to this stream the one-byte integer comprised of the least-significant one byte of the <code>length</code>; otherwise, write to this stream the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the <code>length</code> (in host byte order) with the most-significant bit set. Return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= length</code>. </p>

</div>
</div>
<a class="anchor" id="ae7619e342abd9d5fe61962f57d88e0b8"></a><!-- doxytag: member="bslx::ByteOutStream::putVersion" ref="ae7619e342abd9d5fe61962f57d88e0b8" args="(int version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putVersion </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte, two's complement unsigned integer comprised of the least-significant one byte of the specified <code>version</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a84ddac9f28a79ff52f08a9eb9f3bb962"></a><!-- doxytag: member="bslx::ByteOutStream::reserveCapacity" ref="a84ddac9f28a79ff52f08a9eb9f3bb962" args="(bsl::size_t newCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::ByteOutStream::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>newCapacity</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the internal buffer size of this stream to be at least the specified <code>newCapacity</code> (in bytes). </p>

</div>
</div>
<a class="anchor" id="ae5ff47e2018b81aed6042c851edc5644"></a><!-- doxytag: member="bslx::ByteOutStream::reset" ref="ae5ff47e2018b81aed6042c851edc5644" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::ByteOutStream::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all content in this stream and validate this stream if it is currently invalid. </p>

</div>
</div>
<a class="anchor" id="a853b3d56e06eeb03f70b79f73ebec2a5"></a><!-- doxytag: member="bslx::ByteOutStream::putInt64" ref="a853b3d56e06eeb03f70b79f73ebec2a5" args="(bsls::Types::Int64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the eight-byte, two's complement integer (in network byte order) comprised of the least-significant eight bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a875dea6487f6be78d90f4ebb8761ccf9"></a><!-- doxytag: member="bslx::ByteOutStream::putUint64" ref="a875dea6487f6be78d90f4ebb8761ccf9" args="(bsls::Types::Uint64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the eight-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant eight bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="ae360c406926dddfdf9a536c336d26a22"></a><!-- doxytag: member="bslx::ByteOutStream::putInt56" ref="ae360c406926dddfdf9a536c336d26a22" args="(bsls::Types::Int64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putInt56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the seven-byte, two's complement integer (in network byte order) comprised of the least-significant seven bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="af0f1493016e0722e0c98b5de729ad976"></a><!-- doxytag: member="bslx::ByteOutStream::putUint56" ref="af0f1493016e0722e0c98b5de729ad976" args="(bsls::Types::Uint64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putUint56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the seven-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant seven bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a7514d9612f188ab40eaf4f2638fc54da"></a><!-- doxytag: member="bslx::ByteOutStream::putInt48" ref="a7514d9612f188ab40eaf4f2638fc54da" args="(bsls::Types::Int64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putInt48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the six-byte, two's complement integer (in network byte order) comprised of the least-significant six bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="af294ab3d533e93314a725408e75dc93e"></a><!-- doxytag: member="bslx::ByteOutStream::putUint48" ref="af294ab3d533e93314a725408e75dc93e" args="(bsls::Types::Uint64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putUint48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the six-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant six bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a0bd3c4efa90df9b19944aa541e0a6080"></a><!-- doxytag: member="bslx::ByteOutStream::putInt40" ref="a0bd3c4efa90df9b19944aa541e0a6080" args="(bsls::Types::Int64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putInt40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the five-byte, two's complement integer (in network byte order) comprised of the least-significant five bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="aacc417c113ce0bdfe1147201bfed2f4f"></a><!-- doxytag: member="bslx::ByteOutStream::putUint40" ref="aacc417c113ce0bdfe1147201bfed2f4f" args="(bsls::Types::Uint64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putUint40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the five-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant five bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a9221385b5b5e1f504b1e815646a4042c"></a><!-- doxytag: member="bslx::ByteOutStream::putInt32" ref="a9221385b5b5e1f504b1e815646a4042c" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putInt32 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a21924dc96a9b3b9a4ba7699c7b79ef7e"></a><!-- doxytag: member="bslx::ByteOutStream::putUint32" ref="a21924dc96a9b3b9a4ba7699c7b79ef7e" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putUint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the four-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant four bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="aa901742f1a8417153a50971cd8fb143a"></a><!-- doxytag: member="bslx::ByteOutStream::putInt24" ref="aa901742f1a8417153a50971cd8fb143a" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putInt24 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the three-byte, two's complement integer (in network byte order) comprised of the least-significant three bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="ac6869ee5f19ea23e8470b63ebbf4edfa"></a><!-- doxytag: member="bslx::ByteOutStream::putUint24" ref="ac6869ee5f19ea23e8470b63ebbf4edfa" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putUint24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the three-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant three bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="aaaa3af05af9c4b019f40cfb91b72fc24"></a><!-- doxytag: member="bslx::ByteOutStream::putInt16" ref="aaaa3af05af9c4b019f40cfb91b72fc24" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putInt16 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the two-byte, two's complement integer (in network byte order) comprised of the least-significant two bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="abf4a456ec8e1d9fc533c6a7583f23410"></a><!-- doxytag: member="bslx::ByteOutStream::putUint16" ref="abf4a456ec8e1d9fc533c6a7583f23410" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putUint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the two-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant two bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="ab5abb090ad8bf58261b2fac3a114ead5"></a><!-- doxytag: member="bslx::ByteOutStream::putInt8" ref="ab5abb090ad8bf58261b2fac3a114ead5" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putInt8 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte, two's complement integer comprised of the least-significant one byte of the specified <code>value</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="ae8556c0448b37f6b9c807034e03fe900"></a><!-- doxytag: member="bslx::ByteOutStream::putUint8" ref="ae8556c0448b37f6b9c807034e03fe900" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putUint8 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte, two's complement unsigned integer comprised of the least-significant one byte of the specified <code>value</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a3655ecc5bca6422156e24fc26d6f3616"></a><!-- doxytag: member="bslx::ByteOutStream::putFloat64" ref="a3655ecc5bca6422156e24fc26d6f3616" args="(double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putFloat64 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the eight-byte IEEE double-precision floating-point number (in network byte order) comprised of the most-significant eight bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="a5ceb1392af9b627d65a1a20c587bc3f3"></a><!-- doxytag: member="bslx::ByteOutStream::putFloat32" ref="a5ceb1392af9b627d65a1a20c587bc3f3" args="(float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putFloat32 </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the four-byte IEEE single-precision floating-point number (in network byte order) comprised of the most-significant four bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="aedf28678a791614008ae0f3655f8ae71"></a><!-- doxytag: member="bslx::ByteOutStream::putString" ref="aedf28678a791614008ae0f3655f8ae71" args="(const bsl::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the length of the specified <code>value</code> (see <code>putLength</code>) and an array of one-byte, two's complement unsigned integers comprised of the least-significant one byte of each character in the <code>value</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a17b349aface53a32c005071cf9745a9a"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt64" ref="a17b349aface53a32c005071cf9745a9a" args="(const bsls::Types::Int64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive eight-byte, two's complement integers (in network byte order) comprised of the least-significant eight bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="ab3fada9286e112f29990671590509c2b"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint64" ref="ab3fada9286e112f29990671590509c2b" args="(const bsls::Types::Uint64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive eight-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant eight bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="acdb71af7f79d8bcd5a45af94fe1599f0"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt56" ref="acdb71af7f79d8bcd5a45af94fe1599f0" args="(const bsls::Types::Int64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt56 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive seven-byte, two's complement integers (in network byte order) comprised of the least-significant seven bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a62da4d84d4b1b4db2b29b62f872a987e"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint56" ref="a62da4d84d4b1b4db2b29b62f872a987e" args="(const bsls::Types::Uint64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint56 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive seven-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant seven bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a706bd354855dd449ecd6411c8f67e9fe"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt48" ref="a706bd354855dd449ecd6411c8f67e9fe" args="(const bsls::Types::Int64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt48 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive six-byte, two's complement integers (in network byte order) comprised of the least-significant six bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a8cb9a6359224bc25d66e0660695ff1a2"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint48" ref="a8cb9a6359224bc25d66e0660695ff1a2" args="(const bsls::Types::Uint64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint48 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive six-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant six bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="aaf91d1a1dc287dc5f06a07b087d50f9b"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt40" ref="aaf91d1a1dc287dc5f06a07b087d50f9b" args="(const bsls::Types::Int64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt40 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive five-byte, two's complement integers (in network byte order) comprised of the least-significant five bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a7f31eef59e97a31d3323fe746baab29b"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint40" ref="a7f31eef59e97a31d3323fe746baab29b" args="(const bsls::Types::Uint64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint40 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive five-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant five bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="aa1b1ab1e0d6ac667259b460173660eab"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt32" ref="aa1b1ab1e0d6ac667259b460173660eab" args="(const int *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt32 </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive four-byte, two's complement integers (in network byte order) comprised of the least-significant four bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="aa348f975b0289f841f80f5c82a553162"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint32" ref="aa348f975b0289f841f80f5c82a553162" args="(const unsigned int *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint32 </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive four-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant four bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a0f4549fadac23b328fb0ba78ff588d74"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt24" ref="a0f4549fadac23b328fb0ba78ff588d74" args="(const int *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt24 </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive three-byte, two's complement integers (in network byte order) comprised of the least-significant three bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="ae12bd0daa1ad28efd1bb8d58742707a4"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint24" ref="ae12bd0daa1ad28efd1bb8d58742707a4" args="(const unsigned int *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint24 </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive three-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant three bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="ac45705c2ef2267934041f76711ea2de5"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt16" ref="ac45705c2ef2267934041f76711ea2de5" args="(const short *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt16 </td>
          <td>(</td>
          <td class="paramtype">const short *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive two-byte, two's complement integers (in network byte order) comprised of the least-significant two bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="ad7886d0c2d2d94ce94c27e91d66ab817"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint16" ref="ad7886d0c2d2d94ce94c27e91d66ab817" args="(const unsigned short *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint16 </td>
          <td>(</td>
          <td class="paramtype">const unsigned short *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive two-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant two bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a81ea15a0d7257a49f5d5b2cf39e3a78c"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt8" ref="a81ea15a0d7257a49f5d5b2cf39e3a78c" args="(const char *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f4949c9cf9500cfb3c909fc4313f4ae"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayInt8" ref="a0f4949c9cf9500cfb3c909fc4313f4ae" args="(const signed char *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">const signed char *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive one-byte, two's complement integers comprised of the least-significant one byte of each of the specified <code>numValues</code> leading entries in the specified <code>values</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a380e2f7ca820b1798735488acc5c0f85"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint8" ref="a380e2f7ca820b1798735488acc5c0f85" args="(const char *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad71c64b1c24b50dce94afb19e220a75f"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayUint8" ref="ad71c64b1c24b50dce94afb19e220a75f" args="(const unsigned char *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive one-byte, two's complement unsigned integers comprised of the least-significant one byte of each of the specified <code>numValues</code> leading entries in the specified <code>values</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a8d9b4dbaabfb10f93e31f62fec2efec4"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayFloat64" ref="a8d9b4dbaabfb10f93e31f62fec2efec4" args="(const double *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayFloat64 </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive eight-byte IEEE double-precision floating-point numbers (in network byte order) comprised of the most-significant eight bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="acc1d6265c60919e7ca1dcffea653b99a"></a><!-- doxytag: member="bslx::ByteOutStream::putArrayFloat32" ref="acc1d6265c60919e7ca1dcffea653b99a" args="(const float *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a>&amp; bslx::ByteOutStream::putArrayFloat32 </td>
          <td>(</td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the consecutive four-byte IEEE single-precision floating-point numbers (in network byte order) comprised of the most-significant four bytes of each of the specified <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="ab7d0bfcadcd4b7cee47aac8666cf601d"></a><!-- doxytag: member="bslx::ByteOutStream::operator const void *" ref="ab7d0bfcadcd4b7cee47aac8666cf601d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteOutStream::operator const void * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-zero value if this stream is valid, and 0 otherwise. An invalid stream is a stream for which an output operation was detected to have failed or <code>invalidate</code> was called. </p>

</div>
</div>
<a class="anchor" id="a7d9db0d645b120742fe4cba85acb884f"></a><!-- doxytag: member="bslx::ByteOutStream::bdexVersionSelector" ref="a7d9db0d645b120742fe4cba85acb884f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bslx::ByteOutStream::bdexVersionSelector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the <code>versionSelector</code> to be used with <code>operator&lt;&lt;</code> for BDEX streaming as per the <code>bslx</code> package-level documentation. </p>

</div>
</div>
<a class="anchor" id="a0f7d24b0f595e758a093ed244475d6db"></a><!-- doxytag: member="bslx::ByteOutStream::data" ref="a0f7d24b0f595e758a093ed244475d6db" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* bslx::ByteOutStream::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the contiguous, non-modifiable internal memory buffer of this stream. The address will remain valid as long as this stream is not destroyed or modified. The behavior of accessing elements outside the range <code>[ <a class="el" href="classbslx_1_1ByteOutStream.html#a0f7d24b0f595e758a093ed244475d6db">data()</a> .. <a class="el" href="classbslx_1_1ByteOutStream.html#a0f7d24b0f595e758a093ed244475d6db">data()</a> + (<a class="el" href="classbslx_1_1ByteOutStream.html#a8746c84c9c3b1e304609840e0bff66f5">length()</a> - 1) ]</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a4dca2b645513876fde5d209a22bf839f"></a><!-- doxytag: member="bslx::ByteOutStream::isValid" ref="a4dca2b645513876fde5d209a22bf839f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslx::ByteOutStream::isValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stream is valid, and <code>false</code> otherwise. An invalid stream is a stream for which an output operation was detected to have failed or <code>invalidate</code> was called. </p>

</div>
</div>
<a class="anchor" id="a8746c84c9c3b1e304609840e0bff66f5"></a><!-- doxytag: member="bslx::ByteOutStream::length" ref="a8746c84c9c3b1e304609840e0bff66f5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::size_t bslx::ByteOutStream::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes in this stream. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a28adf3d10daa1a5eb15c07dffc0fe256"></a><!-- doxytag: member="bslx::ByteOutStream::operator&lt;&lt;" ref="a28adf3d10daa1a5eb15c07dffc0fe256" args="(bsl::ostream &amp;, const ByteOutStream &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslx_1_1ByteOutStream.html">ByteOutStream</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>object</code> to the specified output <code>stream</code> in some reasonable (multi-line) format, and return a reference to <code>stream</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslx__byteoutstream_8h_source.html">bslx_byteoutstream.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:46 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
