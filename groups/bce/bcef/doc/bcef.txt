 bcef.txt

@PURPOSE: Provide signature-specific function objects (functors).

@MNEMONIC: Basic Concurrency Environment Functors (bcef)

@AUTHOR: David Laurance (dlauranc)

@SEE_ALSO: bdef, bcefr, bcefu, bces

@DESCRIPTION: The 'bcef' package provides components to implement thread-safe
 function objects (functors) that return void and take between zero and nine
 arguments of arbitrary type. Function objects created by 'bcef' components
 can be invoked in a manner similar to that of the following free function:
..
   void functionObject(arglist);
..
 where 'arglist' contains between zero and nine arguments.  Functor classes are
 differentiated by the number and type of arguments they expect.  The 'bcef'
 package contains 10 separate components that differ in the number of arguments
 their functors expect; within each component, templates are used to support
 variations in argument type.

 'bcef' function objects are created and initialized to call external functions
 supplied by the client program.  Each such existing function may be a member
 function for a specific class or a "free" (non-member) function.  The client
 function may have a different signature than that of the 'bcef' functor.  If
 the client function is a member function for some class, clients will
 typically not need to change that class, but can instead use an existing
 member function from that class.  Specifically, although 'bcef' implements
 'operator()' as its functor interface, client classes that are used by 'bcef'
 do not need to implement 'operator()' themselves, but can supply an ordinary
 member function instead.

 As mentioned above, 'bcef' implements thread-safe functors.  If thread safety
 is not an issue in your environment, you should instead use 'bdef' functors.
 These functors are identical to 'bcef' except that they do not support
 multi-threaded access.

 Note also that thread safety is guaranteed for creation and invocation of
 'bcef' functors, but 'bcef' cannot guarantee the thread safety of the client
 function.

/Related Packages in Package Group 'bce'
/---------------------------------------
 Package 'bcef' is designed to use three other packages in 'bce'.  'bcef'
 provides the primary interface that a client will see, and the other packages
 play supporting roles.

 The packages are:
..
   bcef   Provides functors to clients in a canonical form

   bcefr  This package is *DEPRECATED*.  A common reference-counted base class,
          used by bcefi.  These classes provide reference counting and object
          deletion for derived classes.

   bcefi  This package is *DEPRECATED*.  Concrete reference-counted function
          objects, held and managed by a 'bcef' object; classes in 'bcefi'
          implement behavior declared in 'bcefr'.

   bcefu  This package is *DEPRECATED*.  Utility functions to load a 'bcef'
          functor with a pointer to a user-supplied function; 'bcefu' does this
          by instantiating an object of a type defined in 'bcefi'.  Subsequent
          invocations of the bcef functor will be delegated to the 'bcefi'
          object.
..
 These four 'bce' packages work together to support generic functors.  Typical
 client usage involves two steps.  First, a client program creates a specific
 'bcef' functor, with template parameters that match the application callback
 requirements.  Second, the client program "loads" the 'bcef' functor by
 calling an appropriate utility function from 'bcefu'.

 Once these two steps are completed, the functor can be used to invoke the
 client function through the standard functor interface.

/Relationship to Packages in 'bde'
/---------------------------------
 The 'bcef', 'bcefr', 'bcefi', and 'bcefu' packages provide identical
 functionality to the corresponding packages in the 'bde' package group:
 'bdef', 'bdefr', 'bdefi', and 'bdefu', respectively.  The difference between
 the two sets of packages is that the 'bce' packages provide thread safety,
 whereas the 'bde' packages do not.  In particular, package 'bcefr' implements
 reference counting via atomic operators provided in package 'bces_atomicutil'.

/Functors and Function Pointers
/------------------------------
 Function pointers should be familiar to both C and C++ programmers.  A
 function pointer is a pointer to a C-style function.  In C++, the function
 pointer is declared to point to a function with a specific return type and a
 specific number of arguments of specific types.  For instance,
..
   void (*fp)(int, const char*);
..
 declares a function pointer 'fp' that points to a function returning 'void',
 and taking exactly two arguments, an 'int' and a const pointer to 'char'.

 Assume, then, that we have one or more functions declared with the matching
 signature:
..
   void f1(int x, const char* s);
   void f2(int x, const char* s);
..
 After assigning a value to the function pointer, we can call the
 corresponding function:
..
   fp = f1;
        .
        .
        .
   int my_x = 0;
   const char *my_s = "Text String";
   fp(my_x, my_s);          // invokes function f1
..
 Functors are objects that behave syntactically and semantically like
 functions.  Functors implement a function-call operator ('operator()') whose
 signature characterizes the particular functor's type.  In this example, for
 instance, we could define a functor like this:
..
   class MyFunctor {
       // Class MyFunctor can be used like a function.
        .
        .
        .
   public:
       void operator()(int x, const char* s);
       // this provides invocation semantics
        .
        .
        .
   };

   MyFunctor fn;
        .
        .
        .
   int my_x = 0;
   const char *my_s = "Text String";
   fn(my_x, my_s);          // "invokes" functor fn via fn::operator()
..
 Functors provide some interesting advantages over simple function pointers.
 Unlike a function pointer, a functor may be created with one or more
 arbitrary objects (sometimes called "user data") to be passed (typically as
 trailing arguments) to the underlying function.  By "pre-binding" particular
 arguments to the underlying function, a functor can reduce the number of
 arguments a caller must supply when the functor is invoked.  In this way,
 function objects can be used to coerce functions with extra arguments of
 arbitrary type into a standard calling signature.  Even (non-'static')
 *member* functions can be encapsulated within functors and treated uniformly,
 simply by supplying the appropriate object at construction.  Both the *object*
 pointer and a *member* *function* pointer are stored in the functor; the
 given object pointer is dereferenced when the functor is invoked.

/Functors in the 'bcef' package
/------------------------------
 Individual components are "numbered" to indicate the number of arguments
 (between 0 and 6) that a particular functor accepts.  Each component
 defines a templated class, whose template parameters correspond in number
 to the functor arguments.  When instantiated, the template argument types
 match the argument types used in invoking the functor.  The component name
 is 'bcef_vfunc' followed by 0 to 6; the letter 'v' indicates that the
 corresponding functor will return 'void'.  For the example above, we would
 use component 'bcef_vfunc2' to create a functor object whose 'operator()'
 member function obeys the required signature.
..
 #include <bcef_vfunc2.h>

     bcef_Vfunc2<int, const char*> fn;  // template arguments specify arg types
     // NOTE: This example is incomplete.
     //       We still need code to initialize 'fn'
        .
        .
        .
     int my_x = 0;
     const char *my_s = "Text String";
     fn(my_x, my_s);                    // "invokes" functor fn
..
 Before a 'bcef' functor is invoked as illustrated, the client is responsible
 for ensuring that it is valid; that is, it must contain a pointer to a
 function that will be called when the functor is invoked.  The function to be
 called is external to the functor, and supplied by the client.  This
 "external function" may be a free function, a static class method, or a
 (non-'static') member function for some class.  The client, then, needs a
 canonical mechanism, regardless of the function type, to create a
 reference to that function, and to bind the reference to the 'bcef' functor.

 The most common way to accomplish this is to use a "factory method" defined in
 the 'bcefu' package.  The 'bcefu' package contains 10 components which provide
 these factory methods.  Parallel to 'bcef', these components are "numbered" to
 support functors with different numbers of arguments.  The factory methods are
 also templatized to support varying argument types.

 Each 'bcefu' component contains 4 different types of factory methods, varying
 by the type of function pointer required.  For example, 'bcefu_vfunc2' defines
 the following *factory* *method* *families*:
..
   bcefu_Vfunc2::makeF()     generate a pointer to a free function
                             and assign it to a 'bcef_Vfunc2' object
   bcefu_Vfunc2::makeM()     generate a pointer to a member function
                             and assign it to a 'bcef_Vfunc2' object
   bcefu_Vfunc2::makeC()     generate a pointer to a const member
                             function and assign it to a  'bcef_Vfunc2' object
   bcefu_Vfunc2::makeNull()  initialize a 'bcef_Vfunc2' object with an empty
                             function
..
 These factory methods (except for 'makeNull') are templatized to support
 different return and argument types; in addition, each *factory* *method*
 *family* consists of a set of overloaded functions that support varying
 numbers of arguments on the underlying functions (member or free).  All
 classes returned by functions in component 'bcefu_vfunc2' are defined in
 component 'bcefi_vfunc2'.  See package documentation for the 'bcefu' package
 for details.

 For the simple example above, we would use component 'bcefu_Vfunc2' as follows
 to initialize the 'bcef_Vfunc2' object:
..
 #include <bcef_vfunc2.h>
 #include <bcefu_vfunc2.h>

     void f1(int x, const char* s);
     void f2(int x, const char* s);

     bcef_Vfunc2<int, const char*> fn;  // template arguments define arg types
     bcefu_Vfunc2::makeF(&fn,f1);       // bind functor fn to function f1
        .
        .
        .
     int my_x = 0;
     const char *my_s = "Text String";
     fn(my_x, my_s);                    // "invokes" functor fn
..
 The 'bcefu_Vfunc2::makeF' *factory* *method* in the above example expects two
 arguments.  The first is a pointer to the functor object itself, and the
 second is a pointer to a free function with a signature matching the functor
 object, that is, expecting args of 'int' and 'const char*', and returning
 'void'.

 The 'makeF()' functions create instances of classes from the 'bcefi'
 component; the specific classes are determined by the number and types of
 arguments on the 'bcef' functor and the free function.  Similarly, class
 member functions can be used to initialize a 'bcef' functor by invoking a
 'bcefu_Vfunc2::makeM()' or 'bcefu_Vfunc2::makeC()' function.

 The 'bcefu' and 'bcefi' packages will also allow clients to match a functor to
 a free or member function in situations where the function requires more
 arguments than the functor invocation can support.  See the documentation for
 package 'bcefu' for details describing how to do this; see package
 documentation for 'bcefi' for implementation details.

 Note that because each required argument type 'T' is passed by ('const'
 'T&'), a compiler will generate an error if the user declares a callback
 function taking an argument via a non-'const' reference parameter.  This
 is intended to support and enforce the rule that all modifiable arguments are
 passed using pointers and not using references.  For rare situations where
 clients want to use a callback function supplied by a third party, and that
 callback function uses non-'const' references, a wrapper function must be
 declared that converts non-'const' references to 'const' references or
 pointers as appropriate.

/Envelope-Letter Idiom
/- - - - - - - - - - -
 The functors in the 'bcef' package are implemented using the envelope-letter
 idiom. The classes in 'bcef' are *"envelopes"*; classes in 'bcefr' and
 'bcefi' are *"letters"*. The use of the envelope-letter idiom allows clients
 to wrap arbitrary functions, whose signatures may differ from the function
 signatures in 'bcef', with functors that support standard, well-known
 signatures.

 Each 'bcef_Vfunc*' functor *(envelope)* holds a pointer to an object
 *(letter)* from the corresponding 'bcefi_vfunc*' component.  The 'bcef'
 *envelope* forwards or delegates client requests to its *letter* object:
 in particular, the 'operator()' member function used by clients to invoke
 the functor is delegated to the *letter* object for execution.

 The *letter* object is polymorphic: all *letter* classes in a given 'bcefi'
 component are derived from a common protocol or abstract base class (defined
 in 'bcefr').  The 'bcef' *envelope* uses the abstract 'bcefr' protocol to
 delegate invocation requests.  Different polymorphic *letter* types are used
 to support different external function types and signatures, and the single
 *envelope* type is used to provide a consistent function signature to
 clients.

 Since polymorphism is used to support different bindings to external
 member or free functions, clients must be able to generate a specific type of
 *letter* object for a given *envelope*, based upon the type and signature
 of the specific external function.  This may be done directly through public
 interfaces of the corresponding 'bcefi' component, but in most cases it is
 simpler to use a suite of template functions provided by the corresponding
 'bcefu' package.  Different template functions are provided to match (1) the
 desired function-call-operator signature and (2) the supplied user data.
 Because the C++ compiler will deduce template parameters from argument types,
 clients need not specify them.  See the 'bcefu' package for more
 information on populating 'bcef' functors with specific *letter* objects.

 See also J.O. Coplien, "Advanced Programming Styles and Idioms", Sections
 5.5-5.6, for a complete discussion of the envelope/letter idiom.

/Usage
/-----
 'bcef'-style functors provide a type-neutral, exception-safe (and
 *potentially*, but not yet, thread-safe) *properly* *managed* alternative
 to the traditional callback paradigm (where "client data" is placed in a
 single structure whose address is cast to type 'void *').  The following
 example illustrates how functor callbacks can be added to a graphical
 object.

 Let's suppose that the implementor of the 'MyGuiButton' class allows the
 client to specify a callback function that should be called whenever a
 button is pressed.  Furthermore, the implementor agrees to provide to the
 callback function two arguments at its invocation: a modifiable object of
 type 'MyGuiContext', and a non-modifiable object of type 'MyGuiLocation'.
..
   class MyGuiContext {
       int d_changedFlag;

     public:
       MyGuiContext() : d_changedFlag(0) { }
       int isChanged() { return d_changedFlag; }
       void changeState() { ++d_changedFlag; }

       // 'MyGuiContext' implementation
   };

   class MyGuiLocation {
     public:
       MyGuiLocation() { };

       // 'MyGuiLocation' implementation
   };
..
 Here is the implementation of the 'MyGuiButton' class:
..
   class MyGuiButton  {
       bcef_Vfunc2<MyGuiContext *, MyGuiLocation> d_callback;
           // Functor to execute when button is pressed.

     public:
       MyGuiButton(const bcef_Vfunc2<MyGuiContext *,
                   MyGuiLocation>& buttonPressCallback);
           // Create a graphical button object that executes the
           // specified callback when 'pressButton' is invoked.

       void pressButton(MyGuiContext *context,
                        const MyGuiLocation& location);
           // Execute the callback owned by this button object.
   };

   MyGuiButton::MyGuiButton(const bcef_Vfunc2<MyGuiContext *,
                            MyGuiLocation>& buttonPressCallback)
   : d_callback(buttonPressCallback) // Retain a "copy" of the specified
                                     // functor.
   {
   }

   void MyGuiButton::pressButton(MyGuiContext *context,
                                 const MyGuiLocation& location)
   {
       d_callback(context, location);
           // Execute the contained callback object.
   }
..
 The 'context' and 'location' arguments are mandatory for every function
 called at the press of the button (the number '2' in the name of
 'bcef_Vfunc2' class specifies the number of required arguments).  However,
 we also allow the user of 'MyGuiButton' class to invoke the function with a
 number of additional parameters, as in the 'buttonpressFunction' function
 presented below.
..
   static void buttonpressFunction(MyGuiContext *a,
                                   const MyGuiLocation& b,
                                   int *invocationCounter)
       // This function will be invoked by a functor to increment the
       // specified 'invocationCounter'.
   {
           a->changeState();
           ++*invocationCounter;
   }
..
 The 'bcef_Vfunc2<MyGuiContext, MyGuiLocation>' class used in 'MyGuiButton'
 class has a private member of an abstract class 'bcefr_vfunc2', whose
 'execute' method is called when the functor is being called.  The 'execute'
 method of the 'bcefr_vfunc2' class, the functor invocation operator of the
 'bcef_Vfunc2' class, and the 'pressButton' method of 'MyGuiButton' class
 have two parameters.  The 'buttonpressFunction' callback function, however,
 has to be called with three arguments.  To achieve the proper calling
 signature the user implements a concrete class derived from 'bcefr_vfunc2'
 as follows:
..
   template <class F, class A1, class A2, class D1>
   class FuncRep : public bcefr_Vfunc2<A1, A2> {
       // This class defines the representation for a function object
       // (functor), characterized by a function-call operator taking two
       // arguments and returning 'void', that holds a pure procedure (i.e.,
       // free function, static member function, or functor) taking one
       // additional trailing argument, and this argument's corresponding
       // value.

       F  d_f;  // function pointer or function object (functor)
       D1 d_d1; // first embedded argument

     private:
       // not implemented
       FuncRep(const FuncRep<F, A1, A2, D1>&);
       FuncRep<F, A1, A2, D1>& operator=(const FuncRep<F, A1, A2, D1>&);

     private:
       ~FuncRep()
           // Destroy this functor.  Note that destructor can be invoked only
           // through the static 'deleteObject' method of the base class.
       {
       };

     public:
       // CREATORS
       FuncRep(const F&         procedure,
               const D1&        embeddedArg1,
               bdema_Allocator *basicAllocator)
           // Create a representation for a function object (functor) taking
           // two arguments and returning 'void', using the specified
           // 'procedure' taking 1 additional trailing argument, and this
           // argument's specified 'embeddedArg1' value.  Use
           // the specified 'basicAllocator' to supply memory.
       : bcefr_Vfunc1<A1, A2>(basicAllocator)
       , d_f(procedure)
       , d_d1(embeddedArg1)
       {
       };

       // ACCESSORS
       void execute(const A1& argument1, const A2& argument2) const
           // Invoke the underlying procedure (free function, static member
           // function, or functor) with the specified 'argument1' and
           // 'argument2' followed by the argument value specified at
           // construction.
       {
           d_f(argument1, argument2, d_d1);
       };
   };
..
 Note that the required arguments are passed in at the functor invocation,
 and optional arguments are passed in at the functor initialization.
 By BDE convention, a function signature consists of output parameters, and
 then input parameters.  Since here we have two parameter lists (one passed
 in by the caller, and one passed in by the callee) we can follow this
 convention within each list only.  We choose to pass in first the required
 arguments (passed by the caller) and then the optional arguments (supplied
 by the callee).  This order allows a callee to add parameters easily at
 the end of the function parameter list.  The number of required parameters
 is a part of the 'MyGuiButton' interface, and hence will never change.

 The following code shows how we
..
  (1) Create the functor representation-(letter).
  (2) Create the functor initialized with the representation.
  (3) Register the functor as a callback with an instance of the
      'MyGuiButton' class.
  (4) Invoke the functor.
..
..
   // (1) Create the representation.

   typedef void (*BpFun)(const MyGuiContext *, const MyGuiLocation&, int *);
   bdema_Allocator *myAllocator = bdema_Default::defaultAllocator();

   int globalCounter = 0;

   bcefr_Vfunc2<MyGuiContext *, MyGuiLocation>  *rep = new(myAllocator)
       FuncRep<BpFun, MyGuiContext *, MyGuiLocation, int*>
           (buttonpressFunction, &globalCounter, myAllocator);

   // (2) Create the functor using the representation.

   bcef_Vfunc2<MyGuiContext *, MyGuiLocation> callbackFunctor(rep);

   // (3) Register the functor as a callback.

   MyGuiButton button(callbackFunctor);

   // (4) Use the object.

   MyGuiContext gc;
   const MyGuiLocation gl;             assert(0 == globalCounter);
                                       assert(0 == gc.isChanged());
   button.pressButton(&gc, gl);        assert(1 == globalCounter);
                                       assert(1 == gc.isChanged());
   button.pressButton(&gc, gl);        assert(2 == globalCounter);
                                       assert(2 == gc.isChanged());
..
