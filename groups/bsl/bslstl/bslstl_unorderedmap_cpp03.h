// bslstl_unorderedmap_cpp03.h                                        -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLSTL_UNORDEREDMAP_CPP03
#define INCLUDED_BSLSTL_UNORDEREDMAP_CPP03

//@PURPOSE: Provide C++03 implementation for bslstl_unorderedmap.h
//
//@CLASSES: See bslstl_unorderedmap.h for list of classes
//
//@SEE_ALSO: bslstl_unorderedmap
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Mon Dec 16 09:06:26 2024
// Command line: sim_cpp11_features.pl bslstl_unorderedmap.h

#ifdef COMPILING_BSLSTL_UNORDEREDMAP_H

namespace bsl {

                           // ===================
                           // class unordered_map
                           // ===================

/// This class template implements a value-semantic container type holding
/// an unordered set of `KEY-VALUE` pairs having unique keys that provide a
/// mapping from keys (of template parameter type `KEY`) to their associated
/// mapped values (of template parameter type `VALUE`).
///
/// This class:
/// * supports a complete set of *value-semantic* operations
/// * is *exception-neutral* (agnostic except for the `at` method)
/// * is *alias-safe*
/// * is `const` *thread-safe*
/// For terminology see {`bsldoc_glossary`}.
template <class KEY,
          class VALUE,
          class HASH      = bsl::hash<KEY>,
          class EQUAL     = bsl::equal_to<KEY>,
          class ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE> > >
class unordered_map {

  private:
    // PRIVATE TYPES

    /// This `typedef` is an alias for the allocator traits type associated
    /// with this container.
    typedef bsl::allocator_traits<ALLOCATOR> AllocatorTraits;

    /// This `typedef` is an alias for the type of key-value pair objects
    /// maintained by this unordered map.
    typedef bsl::pair<const KEY, VALUE>  ValueType;

    /// This `typedef` is an alias for the policy used internally by this
    /// unordered map to extract the `KEY` value from the key-value pair
    /// objects maintained by this unordered map.
    typedef BloombergLP::bslstl::UnorderedMapKeyConfiguration<const KEY,
                                                              ValueType>
                                                        ListConfiguration;

    /// This typedef is an alias for the template instantiation of the
    /// underlying `bslstl::HashTable` used to implement this container.
    typedef BloombergLP::bslstl::HashTable<ListConfiguration,
                                             HASH,
                                             EQUAL,
                                             ALLOCATOR> HashTable;

    /// This typedef is an alias for the type of links maintained by the
    /// linked list of elements held by the underlying `bslstl::HashTable`.
    typedef BloombergLP::bslalg::BidirectionalLink HashTableLink;

    /// This typedef is an alias for the type of nodes that hold the values
    /// in this unordered map.
    typedef typename HashTable::NodeType HashTableNode;

    /// This typedef is a convenient alias for the utility associated with
    /// movable references.
    typedef BloombergLP::bslmf::MovableRefUtil    MoveUtil;

    // FRIENDS
    template <class KEY2,
              class VALUE2,
              class HASH2,
              class EQUAL2,
              class ALLOCATOR2>
    friend bool operator==(
                const unordered_map<KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2>&,
                const unordered_map<KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2>&);

  public:
    // TRAITS

    // PUBLIC TYPES
    typedef KEY                                        key_type;
    typedef VALUE                                      mapped_type;
    typedef bsl::pair<const KEY, VALUE>                value_type;
    typedef HASH                                       hasher;
    typedef EQUAL                                      key_equal;
    typedef ALLOCATOR                                  allocator_type;

    typedef value_type&                                reference;
    typedef const value_type&                          const_reference;

    typedef typename AllocatorTraits::size_type        size_type;
    typedef typename AllocatorTraits::difference_type  difference_type;
    typedef typename AllocatorTraits::pointer          pointer;
    typedef typename AllocatorTraits::const_pointer    const_pointer;

    typedef BloombergLP::bslstl::HashTableIterator<
                             value_type, difference_type> iterator;
    typedef BloombergLP::bslstl::HashTableIterator<
                       const value_type, difference_type> const_iterator;
    typedef BloombergLP::bslstl::HashTableBucketIterator<
                             value_type, difference_type> local_iterator;
    typedef BloombergLP::bslstl::HashTableBucketIterator<
                       const value_type, difference_type> const_local_iterator;

  private:
    // DATA
    HashTable d_impl;  // underlying hash table used by this unordered map

  public:
    // CREATORS

    /// Create an empty unordered map having a `max_load_factor` of 1.0.
    /// Optionally specify an `initialNumBuckets` indicating the minimum
    /// initial size of the array of buckets of this unordered map.  If
    /// `initialNumBuckets` is not supplied, one empty bucket shall be used
    /// and no memory allocated.  Optionally specify a `hashFunction` used
    /// to generate the hash values associated with the `KEY-VALUE` pairs
    /// contained in this unordered map.  If `hashFunction` is not supplied,
    /// a default-constructed object of the (template parameter) type `HASH`
    /// is used.  Optionally specify a key-equality functor `keyEqual` used
    /// to determine whether two keys are equivalent.  If `keyEqual` is not
    /// supplied, a default-constructed object of the (template parameter)
    /// type `EQUAL` is used.  Optionally specify the `basicAllocator` used
    /// to supply memory.  If `basicAllocator` is not supplied, a
    /// default-constructed object of the (template parameter) type
    /// `ALLOCATOR` is used.  If the `ALLOCATOR` type is `bsl::allocator`
    /// (the default), then `basicAllocator` shall be convertible to
    /// `bslma::Allocator *`.  If the `ALLOCATOR` type is `bsl::allocator`
    /// and `basicAllocator` is not supplied, the currently installed
    /// default allocator is used to supply memory.  Note that more than
    /// `initialNumBuckets` buckets may be created in order to preserve the
    /// bucket allocation strategy of the hash-table (but never fewer).
    explicit
    unordered_map(size_type        initialNumBuckets,
                  const HASH&      hashFunction      = HASH(),
                  const EQUAL&     keyEqual          = EQUAL(),
                  const ALLOCATOR& basicAllocator    = ALLOCATOR());
    unordered_map(size_type        initialNumBuckets,
                  const HASH&      hashFunction,
                  const ALLOCATOR& basicAllocator);
    unordered_map(size_type        initialNumBuckets,
                  const ALLOCATOR& basicAllocator);
    explicit
    unordered_map(const ALLOCATOR& basicAllocator);
    unordered_map();

    /// Create an empty unordered map, having a `max_load_factor` of 1.0,
    /// and then create a `value_type` object for each iterator in the range
    /// starting at the specified `first` iterator and ending immediately
    /// before the specified `last` iterator, by converting from the object
    /// referred to by each iterator.  Insert into this unordered map each
    /// such object, ignoring those having a key that appears earlier in the
    /// sequence.  Optionally specify a minimum `initialNumBuckets`
    /// indicating the minimum initial size of the array of buckets of this
    /// unordered map.  If `initialNumBuckets` is 0 or not supplied, and
    /// `first` and `last` denote an empty range, a single empty bucket
    /// shall be supplied.  The actual number of buckets the unordered_map
    /// is created with shall always be enough to accommodate the number of
    /// elements of the range without exceeding the `max_load_factor`.
    /// Optionally specify a `hashFunction` used to generate hash values
    /// associated with the `KEY-VALUE` pairs contained in this unordered
    /// map.  If `hashFunction` is not supplied, a default-constructed
    /// object of the (template parameter) type `HASH` is used.  Optionally
    /// specify a key-equality functor `keyEqual` used to verify that two
    /// keys are equivalent.  If `keyEqual` is not supplied, a
    /// default-constructed object of the (template parameter) type `EQUAL`
    /// is used.  Optionally specify a `basicAllocator` used to supply
    /// memory.  If `basicAllocator` is not supplied, a default-constructed
    /// object of the (template parameter) type `ALLOCATOR` is used.  If
    /// `ALLOCATOR` type is `bsl::allocator` (the default), then
    /// `basicAllocator` shall be convertible to `bslma::Allocator *`.  If
    /// the `ALLOCATOR` type is `bsl::allocator` and `basicAllocator` is not
    /// supplied, the currently installed default allocator is used to
    /// supply memory.  The (template parameter) type `INPUT_ITERATOR` shall
    /// meet the requirements of an input iterator defined in the C++11
    /// standard [24.2.3] providing access to values of a type convertible
    /// to `value_type`.  The behavior is undefined unless `first` and
    /// `last` refer to a sequence of valid values where `first` is at a
    /// position at or before `last`.  Note that more than
    /// `initialNumBuckets` buckets may be created in order to preserve the
    /// bucket allocation strategy of the hash-table (but never fewer).
    template <class INPUT_ITERATOR>
    unordered_map(INPUT_ITERATOR   first,
                  INPUT_ITERATOR   last,
                  size_type        initialNumBuckets = 0,
                  const HASH&      hashFunction      = HASH(),
                  const EQUAL&     keyEqual          = EQUAL(),
                  const ALLOCATOR& basicAllocator    = ALLOCATOR());
    template <class INPUT_ITERATOR>
    unordered_map(INPUT_ITERATOR   first,
                  INPUT_ITERATOR   last,
                  size_type        initialNumBuckets,
                  const HASH&      hashFunction,
                  const ALLOCATOR& basicAllocator);
    template <class INPUT_ITERATOR>
    unordered_map(INPUT_ITERATOR   first,
                  INPUT_ITERATOR   last,
                  size_type        initialNumBuckets,
                  const ALLOCATOR& basicAllocator);
    template <class INPUT_ITERATOR>
    unordered_map(INPUT_ITERATOR   first,
                  INPUT_ITERATOR   last,
                  const ALLOCATOR& basicAllocator);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
# ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
    template <
    class = bsl::enable_if_t<std::is_invocable_v<HASH, const KEY &>>,
    class = bsl::enable_if_t<
                         std::is_invocable_v<EQUAL, const KEY &, const KEY &>>,
    class = bsl::enable_if_t< bsl::IsStdAllocator_v<ALLOCATOR>>
    >
# endif
    unordered_map(
            std::initializer_list<value_type> values,
            size_type                         initialNumBuckets = 0,
            const HASH&                       hashFunction      = HASH(),
            const EQUAL&                      keyEqual          = EQUAL(),
            const ALLOCATOR&                  basicAllocator    = ALLOCATOR());
# ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
    template <
    class = bsl::enable_if_t<std::is_invocable_v<HASH, const KEY &>>,
    class = bsl::enable_if_t< bsl::IsStdAllocator_v<ALLOCATOR>>
    >
# endif
    unordered_map(std::initializer_list<value_type> values,
                  size_type                         initialNumBuckets,
                  const HASH&                       hashFunction,
                  const ALLOCATOR&                  basicAllocator);
# ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
    template <
    class = bsl::enable_if_t< bsl::IsStdAllocator_v<ALLOCATOR>>
    >
# endif
    unordered_map(std::initializer_list<value_type> values,
                  size_type                         initialNumBuckets,
                  const ALLOCATOR&                  basicAllocator);
# ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
    /// Create an empty unordered map, having a `max_load_factor` of 1.0,
    /// and then create a `value_type` object for each in the range
    /// specified by `values` argument, ignoring elements having a key that
    /// appears earlier in the sequence.  Optionally specify a minimum
    /// `initialNumBuckets` indicating the minimum initial size of the array
    /// of buckets of this unordered map.  If `initialNumBuckets` is not
    /// supplied and `values` is an empty list, a single empty bucket shall
    /// be created.  The actual number of buckets the unordered_map is
    /// created with shall always be enough to accommodate the number of
    /// elements in `values` without exceeding the `max_load_factor`.
    /// Optionally specify a `hashFunction` used to generate hash values
    /// associated with the `KEY-VALUE` pairs contained in this unordered
    /// map.  If `hashFunction` is not supplied, a default-constructed
    /// object of the (template parameter) type `HASH` is used.  Optionally
    /// specify a key-equality functor `keyEqual` used to verify that two
    /// keys are equivalent.  If `keyEqual` is not supplied, a
    /// default-constructed object of the (template parameter) type `EQUAL`
    /// is used.  Optionally specify a `basicAllocator` used to supply
    /// memory.  If `basicAllocator` is not supplied, a default-constructed
    /// object of the (template parameter) type `ALLOCATOR` is used.  If the
    /// `ALLOCATOR` type is `bsl::allocator` (the default), then
    /// `basicAllocator` shall be convertible to `bslma::Allocator *`.  If
    /// the `ALLOCATOR` type is `bsl::allocator` and `basicAllocator` is not
    /// supplied, the currently installed default allocator is used to
    /// supply memory.  Note that more than `initialNumBuckets` buckets may
    /// be created in order to preserve the bucket allocation strategy of
    /// the hash-table (but never fewer).
    template <
    class = bsl::enable_if_t< bsl::IsStdAllocator_v<ALLOCATOR>>
    >
# endif
    unordered_map(std::initializer_list<value_type> values,
                  const ALLOCATOR&                  basicAllocator);
#endif

    /// Create an unordered map having the same value, hasher, key-equality
    /// comparator, and `max_load_factor` as the specified `original`.  Use
    /// the allocator returned by 'bsl::allocator_traits<ALLOCATOR>::
    /// select_on_container_copy_construction(original.get_allocator())' to
    /// supply memory.  If the `ALLOCATOR` type is `bsl::allocator` (the
    /// default), the currently installed default allocator is used to
    /// supply memory.
    unordered_map(const unordered_map& original);

    /// Create an unordered map having the same value, hasher, key-equality
    /// comparator, and `max_load_factor` as the specified `original`, and
    /// using the specified `basicAllocator` to supply memory.  If the
    /// `ALLOCATOR` type is `bsl::allocator` (the default), then
    /// `basicAllocator` shall be convertible to `bslma::Allocator *`.
    unordered_map(
                const unordered_map&                           original,
                const typename type_identity<ALLOCATOR>::type& basicAllocator);

    /// Create an unordered map having the same value as the specified
    /// `original` object by moving (in constant time) the contents of
    /// `original` to the new unordered map.  Use a copy of
    /// `original.hash_function()` to generate hash values for the keys
    /// contained in this unordered map.  Use a copy of `original.key_eq()`
    /// to verify that two keys are equivalent.  The allocator associated
    /// with `original` is propagated for use in the newly-created unordered
    /// map.  `original` is left in a valid but unspecified state.
    unordered_map(
          BloombergLP::bslmf::MovableRef<unordered_map> original);  // IMPLICIT

    /// Create an unordered map having the same value, hasher, key-equality
    /// comparator, and `max_load_factor` as the specified `original`.  Use
    /// the specified `basicAllocator` to supply memory.  This method
    /// requires that the (template parameter) type `value_type` be
    /// `move-insertable` into this `unordered_map` (see {Requirements on
    /// `value_type`}).  Note that a `bslma::Allocator *` can be supplied
    /// for `basicAllocator` if the (template parameter) `ALLOCATOR` type is
    /// `bsl::allocator` (the default).
    unordered_map(
                BloombergLP::bslmf::MovableRef<unordered_map>  original,
                const typename type_identity<ALLOCATOR>::type& basicAllocator);

    /// Destroy this object and each of its elements.
    ~unordered_map();

    // MANIPULATORS

    /// Assign to this object the value, hasher, key-equality functor, and
    /// `max_load_factor` of the specified `rhs` object, propagate to this
    /// object the allocator of `rhs` if the `ALLOCATOR` type has trait
    /// `propagate_on_container_copy_assignment`, and return a reference
    /// providing modifiable access to this object.  Note that this method
    /// requires that the (template parameter) types `KEY` and `VALUE` both
    /// be `copy-constructible` (see {Requirements on `value_type`}).
    unordered_map& operator=(const unordered_map& rhs);

    /// Assign to this object the value, hash function, and key-equality
    /// comparator of the specified `rhs` object, propagate to this object
    /// the allocator of `rhs` if the `ALLOCATOR` type has trait
    /// `propagate_on_container_move_assignment`, and return a reference
    /// providing modifiable access to this object.  The contents of `rhs`
    /// are moved (in constant time) to this unordered map if
    /// `get_allocator() == rhs.get_allocator()` (after accounting for the
    /// aforementioned trait); otherwise, all elements in this container are
    /// either destroyed or move-assigned to, and each additional element in
    /// `rhs` is move-inserted into this unordered_map.  `rhs` is left in a
    /// valid but unspecified state, and if an exception is thrown, `*this`
    /// is left in a valid but unspecified state.  This method requires that
    /// the type `value_type` be `move-constructible` (see {Requirements on
    /// `value_type`}).
    unordered_map&
    operator=(BloombergLP::bslmf::MovableRef<unordered_map> rhs)
        BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                AllocatorTraits::is_always_equal::value &&
                                std::is_nothrow_move_assignable<HASH>::value &&
                                std::is_nothrow_move_assignable<EQUAL>::value);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
    /// Assign to this unordered map the value of the of the specified
    /// initializer list `rhs`, and return a reference providing modifiable
    /// access to this object.  This method requires that the (template
    /// parameter) type `value_type` be `copy-insertable` into this list.
    unordered_map& operator=(std::initializer_list<value_type> rhs);
#endif

    /// Return a reference providing modifiable access to the mapped-value
    /// associated with the specified `key` in this unordered map; if this
    /// unordered map does not already contain a `value_type` object with
    /// `key`, first insert a new `value_type` object having `key` and a
    /// default-constructed `VALUE` object.  Note that this method requires
    /// that the (template parameter) type `KEY` is `copy-constructible` and
    /// the (template parameter) `VALUE` is "default-constructible" (see
    /// {Requirements on `value_type`}).
    typename add_lvalue_reference<VALUE>::type operator[](const key_type& key);

    /// Return a reference providing modifiable access to the mapped-value
    /// associated with the specified `key` in this unordered map; if this
    /// unordered map does not already contain a `value_type` object with
    /// `key`, first insert a new `value_type` object having `key` and a
    /// default-constructed `VALUE` object.  Note that this method requires
    /// that the (template parameter) `VALUE` is "default-constructible"
    /// (see {Requirements on `value_type`}).  Note that `key` may be
    /// modified; it is guaranteed to be left in a valid state.
    typename add_lvalue_reference<VALUE>::type operator[](
                                 BloombergLP::bslmf::MovableRef<key_type> key);

#ifdef BSLSTL_NO_TRANSPARENT_OPS_FOR_NOW
// {{{ BEGIN GENERATED CODE
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class LOOKUP_KEY>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
        typename add_lvalue_reference<VALUE>::type>::type
    operator [](BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key)
    {
        return try_emplace(
                 BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key)).first->second;
    }
// }}} END GENERATED CODE
#endif

    /// Return a reference providing modifiable access to the mapped-value
    /// associated with the specified `key`, if such an entry exists;
    /// otherwise throw `std::out_of_range` exception.  Note that this
    /// method is not exception-neutral.
    typename add_lvalue_reference<VALUE>::type at(const key_type& key);

#ifdef BSLSTL_NO_TRANSPARENT_OPS_FOR_NOW
    /// Return a reference providing modifiable access to the
    /// mapped-value associated with a key that is equivalent to the
    /// specified `key`, if such an entry exists; otherwise, throw a
    /// `std::out_of_range` exception.  Note that this method may also throw
    /// a different kind of exception if the (user-supplied) comparator
    /// throws.
    ///
    /// Note: implemented inline due to Sun CC compilation error
    template <class LOOKUP_KEY>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
        typename add_lvalue_reference<VALUE>::type>::type
    at(const LOOKUP_KEY& key) {
        HashTableLink *node = d_impl.find(key);

        if (!node) {
            BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                      "unordered_map<...>::at(LOOKUP_KEY): invalid key value");
        }
        return static_cast<HashTableNode *>(node)->value().second;
    }
#endif

    /// Return an iterator providing modifiable access to the first
    /// `value_type` object in the sequence of `value_type` objects
    /// maintained by this unordered map, or the `end` iterator if this
    /// unordered map is empty.
    iterator begin() BSLS_KEYWORD_NOEXCEPT;

    /// Return an iterator providing modifiable access to the past-the-end
    /// position in the sequence of `value_type` objects maintained by this
    /// unordered map.
    iterator end() BSLS_KEYWORD_NOEXCEPT;

    /// Return a local iterator providing modifiable access to the first
    /// `value_type` object in the sequence of `value_type` objects of the
    /// bucket having the specified `index` in the array of buckets
    /// maintained by this unordered map, or the `end(index)` iterator if
    /// the bucket is empty.  The behavior is undefined unless 'index <
    /// bucket_count()'.
    local_iterator begin(size_type index);

    /// Return a local iterator providing modifiable access to the
    /// past-the-end position in the sequence of `value_type` objects of the
    /// bucket having the specified `index` in the array of buckets
    /// maintained by this unordered map.  The behavior is undefined unless
    /// `index < bucket_count()`.
    local_iterator end(size_type index);

    /// Remove all entries from this unordered map.  Note that this
    /// unordered map will be empty after calling this method, but allocated
    /// memory may be retained for future use.
    void clear() BSLS_KEYWORD_NOEXCEPT;

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_unorderedmap.h
#ifndef BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT
#define BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B
#define BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT
#endif
#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 0
    pair<iterator, bool> emplace(
                              );
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 1
    template <class Args_01>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 2
    template <class Args_01,
              class Args_02>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 3
    template <class Args_01,
              class Args_02,
              class Args_03>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 4
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 5
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 6
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 7
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 8
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 9
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 10
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09,
              class Args_10>
    pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 0
    iterator emplace_hint(const_iterator hint);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 1
    template <class Args_01>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 2
    template <class Args_01,
              class Args_02>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 3
    template <class Args_01,
              class Args_02,
              class Args_03>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 4
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 5
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 6
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 7
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 8
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 9
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 10
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09,
              class Args_10>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_B >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... Args>
    pair<iterator, bool> emplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);

    template <class... Args>
    iterator emplace_hint(const_iterator hint,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);
// }}} END GENERATED CODE
#endif

    /// Remove from this unordered map the `value_type` object at the
    /// specified `position`, and return an iterator referring to the
    /// element immediately following the removed element, or to the
    /// past-the-end position if the removed element was the last element in
    /// the sequence of elements maintained by this unordered map.  This
    /// method invalidates only iterators and references to the removed
    /// element and previously saved values of the `end()` iterator, and
    /// preserves the relative order of the elements not removed.  The
    /// behavior is undefined unless `position` refers to a `value_type`
    /// object in this unordered map.
    iterator erase(const_iterator position);
    iterator erase(iterator position);

    /// Remove from this unordered map the `value_type` object having the
    /// specified `key`, if it exists, and return 1; otherwise (there is no
    /// object with a key equivalent to `key` in this unordered map) return
    /// 0 with no other effect.  This method invalidates only iterators and
    /// references to the removed element and previously saved values of the
    /// `end()` iterator, and preserves the relative order of the elements
    /// not removed.
    size_type erase(const key_type& key);

    /// Remove from this unordered map the `value_type` objects starting at
    /// the specified `first` position up to, but not including, the
    /// specified `last` position, and return `last`.  This method
    /// invalidates only iterators and references to the removed element and
    /// previously saved values of the `end()` iterator, and preserves the
    /// relative order of the elements not removed.  The behavior is
    /// undefined unless `first` and `last` either refer to elements in this
    /// unordered map or are the `end` iterator, and the `first` position is
    /// at or before the `last` position in the iteration sequence provided
    /// by this container.
    iterator erase(const_iterator first, const_iterator last);

    /// Return an iterator providing modifiable access to the `value_type`
    /// object in this unordered map with a key equivalent to the specified
    /// `key`, if such an entry exists, and the past-the-end iterator
    /// (`end`) otherwise.  The behavior is undefined unless `key` is
    /// equivalent to the key of at most one element in this unordered map.
    template <class LOOKUP_KEY>
    typename enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
                      iterator>::type
    find(const LOOKUP_KEY& key)
        {
            // Note: implemented inline due to Sun CC compilation error.
            return iterator(d_impl.find(key));
        }

    /// Return an iterator providing modifiable access to the `value_type`
    /// object in this unordered map with a key equivalent to the specified
    /// `key`, if such an entry exists, and the past-the-end iterator
    /// (`end`) otherwise.
    iterator find(const key_type& key);

    /// Insert the specified `value` into this unordered map if the key (the
    /// `first` element) of the object referred to by `value` does not
    /// already exist in this unordered map; otherwise, this method has no
    /// effect (a `value_type` object having the key equivalent to the key
    /// of `value` already exists in this unordered map).  Return a `pair`
    /// whose `first` member is an iterator referring to the (possibly newly
    /// inserted) `value_type` object in this unordered map whose key is
    /// equivalent to that of the object to be inserted, and whose `second`
    /// member is `true` if a new value was inserted, and `false` if a value
    /// having an equivalent key was already present.  Note that this method
    /// requires that the (template parameter) types `KEY` and `VALUE` both
    /// be `copy-insertable` into this unordered map (see {Requirements on
    /// `value_type`}).
    pair<iterator, bool> insert(const value_type& value);

#if defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    template <class ALT_VALUE_TYPE>
    pair<iterator, bool>
#elif !defined(BSLS_COMPILERFEATURES_SUPPORT_TRAITS_HEADER)
    template <class ALT_VALUE_TYPE>
    typename enable_if<is_convertible<ALT_VALUE_TYPE, value_type>::value,
                       pair<iterator, bool> >::type
#else
    /// Insert the specified `value` into this unordered map if the key (the
    /// `first` element) of the object referred to by `value` does not
    /// already exist in this unordered map; otherwise, this method has no
    /// effect (a `value_type` object having the same key as the converted
    /// `value` already exists in this unordered map) .  Return a `pair`
    /// whose `first` member is an iterator referring to the (possibly newly
    /// inserted) `value_type` object in this unordered map whose key is the
    /// equivalent to that of the object to be inserted, and whose `second`
    /// member is `true` if a new value was inserted, and `false` if a value
    /// having an equivalent key was already present.  Note that this method
    /// requires that the (template parameter) types `KEY` and `VALUE` both
    /// be `move-constructible` (see {Requirements on `value_type`}), and
    /// that the `value_type` be constructible from the (template parameter)
    /// `ALT_VALUE_TYPE`.  Also note that this one template stands in for
    /// three `insert` functions in the C++11 standard.
    template <class ALT_VALUE_TYPE>
    typename enable_if<std::is_constructible<value_type,
                                             ALT_VALUE_TYPE&&>::value,
                       pair<iterator, bool> >::type
#endif
    insert(BSLS_COMPILERFEATURES_FORWARD_REF(ALT_VALUE_TYPE) value)
    {
        // Note that some compilers require functions declared with `enable_if`
        // to be defined inline.

        typedef bsl::pair<iterator, bool> ResultType;

        bool isInsertedFlag = false;

        HashTableLink *result = d_impl.insertIfMissing(
                         &isInsertedFlag,
                         BSLS_COMPILERFEATURES_FORWARD(ALT_VALUE_TYPE, value));

        return ResultType(iterator(result), isInsertedFlag);
    }

    /// Insert the specified `value` into this unordered map if the key (the
    /// `first` element) of the object referred to by `value` does not
    /// already exist in this unordered map; otherwise, this method has no
    /// effect (a `value_type` object having the key equivalent to the key
    /// of `value` already exists in this unordered map).  Return an
    /// iterator referring to ether the newly inserted `value_type` object
    /// or to the existing object whose key is equivalent to the key of
    /// `value`.  The average and worst case complexity of this operation is
    /// not affected by the specified `hint`.  This method requires that the
    /// (template parameter) types `KEY` and `VALUE` both be
    /// `copy-insertable` into this unordered map (see {Requirements on
    /// `value_type`}).  The behavior is undefined unless `hint` is an
    /// iterator in the range `[begin() .. end()]` (both endpoints
    /// included).  Note that `hint` is ignored (other than possibly
    /// asserting its validity in some build modes).
    iterator insert(const_iterator hint, const value_type& value);

#if defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    template <class ALT_VALUE_TYPE>
    iterator
#elif !defined(BSLS_COMPILERFEATURES_SUPPORT_TRAITS_HEADER)
    template <class ALT_VALUE_TYPE>
    typename enable_if<is_convertible<ALT_VALUE_TYPE, value_type>::value,
                       iterator>::type
#else
    /// Insert the specified `value` into this unordered map if the key (the
    /// `first` element) of the object referred to by `value` does not
    /// already exist in this unordered map; otherwise, this method has no
    /// effect (a `value_type` object having the same key as the converted
    /// `value` already exists in this unordered map) .  Return an iterator
    /// referring to ether the newly inserted) `value_type` object or to the
    /// existing object whose key is equivalent to the key of `value`.  The
    /// average and worst case complexity of this operation is not affected
    /// by the specified `hint`.  This method requires that the (template
    /// parameter) types `KEY` and `VALUE` both be `move-constructible` (see
    /// {Requirements on `value_type`}) and that the `value_type` be
    /// constructible from the (template parameter) `ALT_VALUE_TYPE`.  The
    /// behavior is undefined unless `hint` is an iterator in the range
    /// `[begin() .. end()]` (both endpoints included).  Note that `hint` is
    /// ignored (other than possibly asserting its validity in some build
    /// modes).  Also note that this one template stands in for three
    /// `insert` functions in the C++11 standard.
    template <class ALT_VALUE_TYPE>
    typename enable_if<std::is_constructible<value_type,
                                             ALT_VALUE_TYPE&&>::value,
                       iterator>::type
#endif
    insert(const_iterator                                    hint,
           BSLS_COMPILERFEATURES_FORWARD_REF(ALT_VALUE_TYPE) value)
    {
        // Note that some compilers require functions declared with 'enable_if'
        // to be defined inline.

        // There is no realistic use-case for the 'hint' in an 'unordered_map'
        // of unique values.  We could quickly test for a duplicate key, and
        // have a fast return path for when the method fails, but in the
        // typical use case where a new element is inserted, we are adding an
        // extra key check for no benefit.  In order to insert an element into
        // a bucket, we need to walk the whole bucket looking for duplicates,
        // and the hint is no help in finding the start of a bucket.

        (void)hint;  // suppress 'unused' warnings

        bool isInsertedFlag;  // not used

        HashTableLink *result = d_impl.insertIfMissing(
                         &isInsertedFlag,
                         BSLS_COMPILERFEATURES_FORWARD(ALT_VALUE_TYPE, value));

        return iterator(result);
    }

    /// Create a `value_type` object for each iterator in the range starting
    /// at the specified `first` iterator and ending immediately before the
    /// specified `last` iterator, by converting from the object referred to
    /// by each iterator.  Insert into this unordered map each such object
    /// whose key is not already contained.  The (template parameter) type
    /// `INPUT_ITERATOR` shall meet the requirements of an input iterator
    /// defined in the C++11 standard [24.2.3] providing access to values of
    /// a type convertible to `value_type`.  The behavior is undefined
    /// unless `first` and `last` refer to a sequence of valid values where
    /// `first` is at a position at or before `last`.  Note that this method
    /// requires that the (template parameter) types `KEY` and `VALUE` both
    /// be `copy-constructible` (see {Requirements on `value_type`}).
    template <class INPUT_ITERATOR>
    void insert(INPUT_ITERATOR first, INPUT_ITERATOR last);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
    /// Create a `value_type` object for each element in the specified
    /// `values`.  Insert into this unordered map each such object whose key
    /// is not already contained.  Note that this method requires that the
    /// (template parameter) types `KEY` and `VALUE` both be
    /// `copy-constructible` (see {Requirements on `value_type`}).
    void insert(std::initializer_list<value_type> values);
#endif

// {{{ BEGIN GENERATED CODE
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class BDE_OTHER_TYPE>
    pair<iterator, bool> insert_or_assign(const KEY&       key,
                        BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj);

    template <class BDE_OTHER_TYPE>
    pair<iterator, bool> insert_or_assign(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                        BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj);

#ifdef BSLSTL_NO_TRANSPARENT_OPS_FOR_NOW
    template<class LOOKUP_KEY, class BDE_OTHER_TYPE>
    typename bsl::enable_if<
            BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
         && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
         , pair<iterator, bool> >::type
    insert_or_assign(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                     BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.insertOrAssignTransparent(
                           &isInsertedFlag,
                           NULL,
                           BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                           BSLS_COMPILERFEATURES_FORWARD(BDE_OTHER_TYPE, obj));
        return ResultType(iterator(result), isInsertedFlag);
    }
#endif

    template <class BDE_OTHER_TYPE>
    iterator insert_or_assign(const_iterator   hint,
                              const KEY&       key,
                        BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj);

    template <class BDE_OTHER_TYPE>
    iterator insert_or_assign(const_iterator                      hint,
                              BloombergLP::bslmf::MovableRef<KEY> key,
                        BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj);

#ifdef BSLSTL_NO_TRANSPARENT_OPS_FOR_NOW
    template<class LOOKUP_KEY, class BDE_OTHER_TYPE>
    typename bsl::enable_if<
            BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
         && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
         , iterator>::type
    insert_or_assign(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.insertOrAssignTransparent(
                           &isInsertedFlag,
                           hint.node(),
                           BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                           BSLS_COMPILERFEATURES_FORWARD(BDE_OTHER_TYPE, obj));
        return iterator(result);
    }
#endif
// }}} END GENERATED CODE

    /// Return a pair of iterators providing modifiable access to the
    /// sequence of `value_type` objects in this unordered map having the
    /// specified `key`, where the first iterator is positioned at the start
    /// of the sequence, and the second is positioned one past the end of
    /// the sequence.  If this unordered map contains no `value_type` object
    /// having `key`, then the two returned iterators will have the same
    /// value, `end()`.  The behavior is undefined unless `key` is
    /// equivalent to at most one key in this unordered map.  Note that
    /// since an unordered map maintains unique keys, the range will contain
    /// at most one element.
    ///
    /// Note: implemented inline due to Sun CC compilation error.
    template <class LOOKUP_KEY>
    typename enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
                       pair<iterator, iterator> >::type
    equal_range(const LOOKUP_KEY& key)
        {
            typedef bsl::pair<iterator, iterator> ResultType;

            HashTableLink *first = d_impl.find(key);
            return first
                     ? ResultType(iterator(first), iterator(first->nextLink()))
                     : ResultType(iterator(0),     iterator(0));
        }

    /// Return a pair of iterators providing modifiable access to the
    /// sequence of `value_type` objects in this unordered map having the
    /// specified `key`, where the first iterator is positioned at the start
    /// of the sequence, and the second is positioned one past the end of
    /// the sequence.  If this unordered map contains no `value_type` object
    /// having `key`, then the two returned iterators will have the same
    /// value, `end()`.  Note that since an unordered map maintains unique
    /// keys, the range will contain at most one element.
    pair<iterator, iterator> equal_range(const key_type& key);

    /// Set the maximum load factor of this unordered map to the specified
    /// `newMaxLoadFactor`.  If `newMaxLoadFactor < loadFactor()`, this
    /// operator will cause an immediate rehash (in violation of the C++11
    /// standard); otherwise, it has a constant-time cost.  The behavior is
    /// undefined unless `0 < newMaxLoadFactor`.
    void max_load_factor(float newMaxLoadFactor);

    /// Change the size of the array of buckets maintained by this unordered
    /// map to at least the specified `numBuckets`, and redistribute all the
    /// contained elements into the new sequence of buckets, according to
    /// their hash values.  After this call, `load_factor` will be less than
    /// or equal to `max_load_factor`.  This operation has no effect if
    /// rehashing the elements into `numBuckets` would cause this map to
    /// exceed its `max_load_factor`.
    void rehash(size_type numBuckets);

    /// Increase the number of buckets of this set to a quantity such that
    /// the ratio between the specified `numElements` and this quantity does
    /// not exceed `max_load_factor`.  Note that this guarantees that, after
    /// the reserve, elements can be inserted to grow the container to
    /// `size() == numElements` without rehashing.  Also note that memory
    /// allocations may still occur when growing the container to `size() ==
    /// numElements`.  Also note that this operation has no effect if
    /// `numElements <= size()`.
    void reserve(size_type numElements);

    /// Exchange the value, hasher, key-equality functor, and
    /// `max_load_factor` of this object with those of the specified `other`
    /// object; also exchange the allocator of this object with that of
    /// `other` if the (template parameter) type `ALLOCATOR` has the
    /// `propagate_on_container_swap` trait, and do not modify either
    /// allocator otherwise.  This method provides the no-throw
    /// exception-safety guarantee if and only if both the (template
    /// parameter) types `HASH` and `EQUAL` provide no-throw swap
    /// operations; if an exception is thrown, both objects are left in
    /// valid but unspecified states.  This operation guarantees `O[1]`
    /// complexity.  The behavior is undefined unless either this object was
    /// created with the same allocator as `other` or `ALLOCATOR` has the
    /// `propagate_on_container_swap` trait.
    void swap(unordered_map& other) BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                     AllocatorTraits::is_always_equal::value &&
                                     bsl::is_nothrow_swappable<HASH>::value &&
                                     bsl::is_nothrow_swappable<EQUAL>::value);

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_unorderedmap.h
#ifndef BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT
#define BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D
#define BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT
#endif
#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0
    pair<iterator, bool> try_emplace(const KEY& key);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1
    template <class Args_01>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2
    template <class Args_01,
              class Args_02>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3
    template <class Args_01,
              class Args_02,
              class Args_03>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09,
              class Args_10>
    pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1
    template <class Args_01>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2
    template <class Args_01,
              class Args_02>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3
    template <class Args_01,
              class Args_02,
              class Args_03>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09,
              class Args_10>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0
    template<class LOOKUP_KEY>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1
    template<class LOOKUP_KEY, class Args_01>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06,
                               class Args_07>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06,
                               class Args_07,
                               class Args_08>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06,
                               class Args_07,
                               class Args_08,
                               class Args_09>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06,
                               class Args_07,
                               class Args_08,
                               class Args_09,
                               class Args_10>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(Args_10, args_10));

        return ResultType(iterator(result), isInsertedFlag);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0
    iterator
    try_emplace(const_iterator hint, const KEY& key);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1
    template<class Args_01>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2
    template<class Args_01,
             class Args_02>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3
    template<class Args_01,
             class Args_02,
             class Args_03>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4
    template<class Args_01,
             class Args_02,
             class Args_03,
             class Args_04>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5
    template<class Args_01,
             class Args_02,
             class Args_03,
             class Args_04,
             class Args_05>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6
    template<class Args_01,
             class Args_02,
             class Args_03,
             class Args_04,
             class Args_05,
             class Args_06>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7
    template<class Args_01,
             class Args_02,
             class Args_03,
             class Args_04,
             class Args_05,
             class Args_06,
             class Args_07>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8
    template<class Args_01,
             class Args_02,
             class Args_03,
             class Args_04,
             class Args_05,
             class Args_06,
             class Args_07,
             class Args_08>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9
    template<class Args_01,
             class Args_02,
             class Args_03,
             class Args_04,
             class Args_05,
             class Args_06,
             class Args_07,
             class Args_08,
             class Args_09>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10
    template<class Args_01,
             class Args_02,
             class Args_03,
             class Args_04,
             class Args_05,
             class Args_06,
             class Args_07,
             class Args_08,
             class Args_09,
             class Args_10>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1
    template <class Args_01>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2
    template <class Args_01,
              class Args_02>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3
    template <class Args_01,
              class Args_02,
              class Args_03>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10
    template <class Args_01,
              class Args_02,
              class Args_03,
              class Args_04,
              class Args_05,
              class Args_06,
              class Args_07,
              class Args_08,
              class Args_09,
              class Args_10>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10);
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0
    template<class LOOKUP_KEY>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1
    template<class LOOKUP_KEY, class Args_01>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06,
                               class Args_07>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06,
                               class Args_07,
                               class Args_08>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06,
                               class Args_07,
                               class Args_08,
                               class Args_09>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10
    template<class LOOKUP_KEY, class Args_01,
                               class Args_02,
                               class Args_03,
                               class Args_04,
                               class Args_05,
                               class Args_06,
                               class Args_07,
                               class Args_08,
                               class Args_09,
                               class Args_10>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(Args_10, args_10));

        return iterator(result);
    }
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_D >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... Args>
    pair<iterator, bool> try_emplace(const KEY& key,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);

    template <class... Args>
    pair<iterator, bool> try_emplace(
                              BloombergLP::bslmf::MovableRef<KEY> key,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);

    template<class LOOKUP_KEY, class... Args>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                const_iterator>::value
        && !bsl::is_convertible<BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY),
                                iterator>::value,
           pair<iterator, bool> >::type
    try_emplace(BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
    {
        typedef bsl::pair<iterator, bool> ResultType;
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                                BSLS_COMPILERFEATURES_FORWARD(Args, args)...);

        return ResultType(iterator(result), isInsertedFlag);
    }

    template<class... Args>
    iterator
    try_emplace(const_iterator hint, const KEY& key,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);

    template <class... Args>
    iterator try_emplace(const_iterator                      hint,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);

    template<class LOOKUP_KEY, class... Args>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
           iterator>::type
    try_emplace(const_iterator hint,
                             BSLS_COMPILERFEATURES_FORWARD_REF(LOOKUP_KEY) key,
                             BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
    {
        bool isInsertedFlag = false;
        HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(LOOKUP_KEY, key),
                                BSLS_COMPILERFEATURES_FORWARD(Args, args)...);

        return iterator(result);
    }
// }}} END GENERATED CODE
#endif

    // ACCESSORS

    /// Return a reference providing non-modifiable access to the
    /// mapped-value associated with the specified `key`, if such an entry
    /// exists; otherwise throw a `std::out_of_range` exception.  Note that
    /// this method is not exception-neutral.
    typename add_lvalue_reference<const VALUE>::type at(const key_type& key)
                                                                         const;

#ifdef BSLSTL_NO_TRANSPARENT_OPS_FOR_NOW
    /// Return a reference providing non-modifiable access to the
    /// mapped-value associated with a key that is equivalent to the
    /// specified `key`, if such an entry exists; otherwise, throw a
    /// `std::out_of_range` exception.  Note that this method may also throw
    /// a different kind of exception if the (user-supplied) comparator
    /// throws.
    ///
    /// Note: implemented inline due to Sun CC compilation error
    template <class LOOKUP_KEY>
    typename bsl::enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
        typename add_lvalue_reference<const VALUE>::type>::type
    at(const LOOKUP_KEY& key) const {
        HashTableLink *node = d_impl.find(key);

        if (!node) {
            BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                "unordered_map<...>::at(LOOKUP_KEY) const: invalid key value");
        }
        return static_cast<HashTableNode *>(node)->value().second;
    }
#endif

    const_iterator  begin() const BSLS_KEYWORD_NOEXCEPT;

    /// Return an iterator providing non-modifiable access to the first
    /// `value_type` object in the sequence of `value_type` objects
    /// maintained by this unordered map, or the `end` iterator if this
    /// unordered map is empty.
    const_iterator cbegin() const BSLS_KEYWORD_NOEXCEPT;

    const_iterator  end() const BSLS_KEYWORD_NOEXCEPT;

    /// Return an iterator providing non-modifiable access to the
    /// past-the-end position in the sequence of `value_type` objects
    /// maintained by this unordered map.
    const_iterator cend() const BSLS_KEYWORD_NOEXCEPT;

    const_local_iterator  begin(size_type index) const;

    /// Return a local iterator providing non-modifiable access to the first
    /// `value_type` object in the sequence of `value_type` objects of the
    /// bucket having the specified `index` in the array of buckets
    /// maintained by this unordered map, or the `end(index)` iterator if
    /// the bucket is empty.  The behavior is undefined unless
    /// `index < bucket_count()`.
    const_local_iterator cbegin(size_type index) const;

    const_local_iterator  end(size_type index) const;

    /// Return a local iterator providing non-modifiable access to the
    /// past-the-end position in the sequence of `value_type` objects of the
    /// bucket having the specified `index` in the array of buckets
    /// maintained by this unordered map.  The behavior is undefined unless
    /// `index < bucket_count()`.
    const_local_iterator cend(size_type index) const;

    /// Return the index of the bucket, in the array of buckets maintained
    /// by this unordered map, where values having a key equivalent to the
    /// specified `key` would be inserted.
    size_type bucket(const key_type& key) const;

#ifdef BSLSTL_NO_TRANSPARENT_OPS_FOR_NOW
    /// Return the index of the bucket, in the array of buckets maintained
    /// by this unordered map, where values having a key equivalent to the
    /// specified `key` would be inserted.
    ///
    /// Note: implemented inline due to Sun CC compilation error.
    template <class LOOKUP_KEY>
    typename enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
                      size_type>::type
    bucket(const LOOKUP_KEY& key) const
    {
        return d_impl.bucketIndexForKey(key);
    }
#endif

    /// Return the number of buckets in the array of buckets maintained by
    /// this unordered map.
    size_type bucket_count() const BSLS_KEYWORD_NOEXCEPT;

    /// Return a theoretical upper bound on the largest number of buckets
    /// that this unordered map could possibly manage.  Note that there is
    /// no guarantee that the unordered map can successfully grow to the
    /// returned size, or even close to that size, without running out of
    /// resources.
    size_type max_bucket_count() const BSLS_KEYWORD_NOEXCEPT;

    /// Return the number of elements contained in the bucket at the
    /// specified `index` in the array of buckets maintained by this
    /// unordered map.  The behavior is undefined unless
    /// `index < bucket_count()`.
    size_type bucket_size(size_type index) const;

    /// Return the number of `value_type` objects within this unordered map
    /// that have a key equivalent to the specified `key`.  The behavior is
    /// undefined unless `key` is equivalent to at most one key in this
    /// unordered map.  Note that since an unordered map maintains unique
    /// keys, the returned value will be either 0 or 1.
    ///
    /// Note: implemented inline due to Sun CC compilation error.
    template <class LOOKUP_KEY>
    typename enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
                      size_type>::type
    count(const LOOKUP_KEY& key) const
        {
            return d_impl.find(key) != 0;
        }

    /// Return the number of `value_type` objects contained within this
    /// unordered map having the specified `key`.  Note that since an
    /// unordered map maintains unique keys, the returned value will be
    /// either 0 or 1.
    size_type count(const key_type& key) const;

    /// Return `true` if this unordered map contains an element whose key is
    /// equivalent to the specified `key`.
    bool contains(const key_type &key) const;

    /// Return `true` if this unordered map contains an element whose key is
    /// equivalent to the specified `key`.
    ///
    /// Note: implemented inline due to Sun CC compilation error
    template <class LOOKUP_KEY>
    typename enable_if<
        BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value &&
            BloombergLP::bslmf::IsTransparentPredicate<EQUAL,
                                                       LOOKUP_KEY>::value,
        bool>::type
    contains(const LOOKUP_KEY& key) const
    {
        return find(key) != end();
    }

    /// Return `true` if this unordered map contains no elements, and
    /// `false` otherwise.
    bool empty() const BSLS_KEYWORD_NOEXCEPT;

    /// Return a pair of iterators providing non-modifiable access to the
    /// sequence of `value_type` objects in this unordered map with a key
    /// equivalent to specified `key`, where the first iterator is
    /// positioned at the start of the sequence, and the second is
    /// positioned one past the end of the sequence.  If this unordered map
    /// contains no `value_type` objects having a key equivalent to `key`,
    /// then the two returned iterators will have the same value, `end()`.
    /// The behavior is undefined unless `key` is equivalent to at most one
    /// key in this unordered map.  Note that since an unordered map
    /// maintains unique keys, the range will contain at most one element.
    ///
    /// Note: implemented inline due to Sun CC compilation error.
    template <class LOOKUP_KEY>
    typename enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
                      pair<const_iterator, const_iterator> >::type
    equal_range(const LOOKUP_KEY& key) const
        {
            typedef bsl::pair<const_iterator, const_iterator> ResultType;

            HashTableLink *first = d_impl.find(key);
            return first
                     ? ResultType(iterator(first), iterator(first->nextLink()))
                     : ResultType(iterator(0),     iterator(0));
        }

    /// Return a pair of iterators providing non-modifiable access to the
    /// sequence of `value_type` objects in this unordered map having the
    /// specified `key`, where the first iterator is positioned at the start
    /// of the sequence, and the second is positioned one past the end of
    /// the sequence.  If this unordered map contains no `value_type` object
    /// having `key`, then the two returned iterators will have the same
    /// value, `end()`.  Note that since an unordered map maintains unique
    /// keys, the range will contain at most one element.
    pair<const_iterator, const_iterator> equal_range(
                                                    const key_type& key) const;

    /// Return an iterator providing non-modifiable access to the
    /// `value_type` object in this unordered map with a key equivalent to
    /// the specified `key`, if such an entry exists, and the past-the-end
    /// iterator (`end`) otherwise.  The behavior is undefined unless `key`
    /// is equivalent to at most one key in this unordered map.
    ///
    /// Note: implemented inline due to Sun CC compilation error.
    template <class LOOKUP_KEY>
    typename enable_if<
           BloombergLP::bslmf::IsTransparentPredicate<HASH, LOOKUP_KEY>::value
        && BloombergLP::bslmf::IsTransparentPredicate<EQUAL,LOOKUP_KEY>::value,
                      const_iterator>::type
    find(const LOOKUP_KEY& key) const
        {
            return const_iterator(d_impl.find(key));
        }

    /// Return an iterator providing non-modifiable access to the
    /// `value_type` object in this unordered map with a key equivalent to
    /// the specified `key`, if such an entry exists, and the past-the-end
    /// iterator (`end`) otherwise.
    const_iterator find(const key_type& key) const;

    /// Return (a copy of) the allocator used for memory allocation by this
    /// unordered map.
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT;

    /// Return (a copy of) the unary hash functor used by this unordered map
    /// to generate a hash value (of type `size_type`) for a `key_type`
    /// object.
    HASH hash_function() const;

    /// Return (a copy of) binary the key-equality functor used by this
    /// unordered map that returns `true` if two `key_type` objects are
    /// equivalent, and `false` otherwise.
    EQUAL key_eq() const;

    /// Return the current ratio between the `size` of this unordered map
    /// and the number of buckets.  The load factor is a measure of how
    /// full the container is, and a higher load factor typically leads to
    /// an increased number of collisions, thus resulting in a loss of
    /// performance.
    float load_factor() const BSLS_KEYWORD_NOEXCEPT;

    /// Return the maximum load factor allowed for this unordered map.  Note
    /// that if an insert operation would cause the load factor to exceed
    /// the `max_load_factor`, that same insert operation will increase the
    /// number of buckets and rehash the elements of the container into
    /// those buckets (see `rehash`).
    float max_load_factor() const BSLS_KEYWORD_NOEXCEPT;

    /// Return the number of elements in this unordered map.
    size_type size() const BSLS_KEYWORD_NOEXCEPT;

    /// Return a theoretical upper bound on the largest number of elements
    /// that this unordered map could possibly hold.  Note that there is no
    /// guarantee that the unordered map can successfully grow to the
    /// returned size, or even close to that size, without running out of
    /// resources.
    size_type max_size() const BSLS_KEYWORD_NOEXCEPT;
};

#ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
// CLASS TEMPLATE DEDUCTION GUIDES

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the iterators supplied to the constructor of `unordered_map`.  Deduce
/// the template parameters `HASH`, `EQUAL` and `ALLOCATOR` from the other
/// parameters passed to the constructor of `unordered_map`.  This deduction
/// guide does not participate unless: (1) the supplied `HASH` is invokable
/// with a `KEY`, (2) the supplied `EQUAL` is invokable with two `KEY`s, and
/// (3) the supplied allocator meets the requirements of a standard
/// allocator.
template <
    class INPUT_ITERATOR,
    class KEY = BloombergLP::bslstl::IteratorUtil::IterKey_t<INPUT_ITERATOR>,
    class VALUE =
               BloombergLP::bslstl::IteratorUtil::IterMapped_t<INPUT_ITERATOR>,
    class HASH = bsl::hash<KEY>,
    class EQUAL = bsl::equal_to<KEY>,
    class ALLOCATOR = bsl::allocator<pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<std::is_invocable_v<HASH, const KEY &>>,
    class = bsl::enable_if_t<
                         std::is_invocable_v<EQUAL, const KEY &, const KEY &>>,
    class = bsl::enable_if_t<bsl::IsStdAllocator_v<ALLOCATOR>>
    >
unordered_map(INPUT_ITERATOR,
              INPUT_ITERATOR,
              typename bsl::allocator_traits<ALLOCATOR>::size_type = 0,
              HASH = HASH(),
              EQUAL = EQUAL(),
              ALLOCATOR = ALLOCATOR())
-> unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the iterators supplied to the constructor of `unordered_map`.  Deduce
/// the template parameters `HASH` and "EQUAL' from the other parameters
/// passed to the constructor of `unordered_map`.  This deduction guide does
/// not participate unless the supplied allocator is convertible to
/// `bsl::allocator<bsl::pair<const KEY, VALUE>>`.
template <
    class INPUT_ITERATOR,
    class HASH,
    class EQUAL,
    class ALLOC,
    class KEY = BloombergLP::bslstl::IteratorUtil::IterKey_t<INPUT_ITERATOR>,
    class VALUE =
               BloombergLP::bslstl::IteratorUtil::IterMapped_t<INPUT_ITERATOR>,
    class DEFAULT_ALLOCATOR = bsl::allocator<pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<bsl::is_convertible_v<ALLOC *, DEFAULT_ALLOCATOR>>
    >
unordered_map(INPUT_ITERATOR,
              INPUT_ITERATOR,
              typename bsl::allocator_traits<DEFAULT_ALLOCATOR>::size_type,
              HASH,
              EQUAL,
              ALLOC *)
-> unordered_map<KEY, VALUE, HASH, EQUAL>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the iterators supplied to the constructor of `unordered_map`.  Deduce
/// the template parameters `HASH` and `ALLOCATOR` from the other
/// parameters passed to the constructor of `unordered_map`.  This deduction
/// guide does not participate unless the supplied hash is invokable with a
/// `KEY` and the supplied allocator meets the requirements of a standard
/// allocator.
template <
    class INPUT_ITERATOR,
    class HASH,
    class ALLOCATOR,
    class KEY = BloombergLP::bslstl::IteratorUtil::IterKey_t<INPUT_ITERATOR>,
    class VALUE =
               BloombergLP::bslstl::IteratorUtil::IterMapped_t<INPUT_ITERATOR>,
    class = bsl::enable_if_t<std::is_invocable_v<HASH, const KEY &>>,
    class = bsl::enable_if_t<bsl::IsStdAllocator_v<ALLOCATOR>>
    >
unordered_map(INPUT_ITERATOR,
              INPUT_ITERATOR,
              typename bsl::allocator_traits<ALLOCATOR>::size_type,
              HASH,
              ALLOCATOR)
-> unordered_map<KEY, VALUE, HASH, bsl::equal_to<KEY>, ALLOCATOR>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the iterators supplied to the constructor of `unordered_map`.  Deduce
/// the template parameter `HASH` from the other parameters passed to the
/// constructor of `unordered_map`.  This deduction guide does not
/// participate unless the supplied allocator is convertible to
/// `bsl::allocator<bsl::pair<const KEY, VALUE>>`.
template <
    class INPUT_ITERATOR,
    class HASH,
    class ALLOC,
    class KEY = BloombergLP::bslstl::IteratorUtil::IterKey_t<INPUT_ITERATOR>,
    class VALUE =
               BloombergLP::bslstl::IteratorUtil::IterMapped_t<INPUT_ITERATOR>,
    class DEFAULT_ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<bsl::is_convertible_v<ALLOC *, DEFAULT_ALLOCATOR>>
    >
unordered_map(INPUT_ITERATOR,
              INPUT_ITERATOR,
              typename bsl::allocator_traits<DEFAULT_ALLOCATOR>::size_type,
              HASH,
              ALLOC *)
-> unordered_map<KEY, VALUE, HASH>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the iterators supplied to the constructor of `unordered_map`.  Deduce
/// the template parameter `ALLOCATOR` from the other parameter passed to
/// the constructor of `unordered_map`.  This deduction guide does not
/// participate unless the supplied allocator meets the requirements of a
/// standard allocator.
template <
    class INPUT_ITERATOR,
    class ALLOCATOR,
    class KEY = BloombergLP::bslstl::IteratorUtil::IterKey_t<INPUT_ITERATOR>,
    class VALUE =
               BloombergLP::bslstl::IteratorUtil::IterMapped_t<INPUT_ITERATOR>,
    class = bsl::enable_if_t<bsl::IsStdAllocator_v<ALLOCATOR>>
    >
unordered_map(INPUT_ITERATOR,
              INPUT_ITERATOR,
              typename bsl::allocator_traits<ALLOCATOR>::size_type,
              ALLOCATOR)
-> unordered_map<KEY, VALUE, bsl::hash<KEY>, bsl::equal_to<KEY>, ALLOCATOR>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the iterators supplied to the constructor of `unordered_map`.  This
/// deduction guide does not participate unless the supplied allocator is
/// convertible to `bsl::allocator<bsl::pair<const KEY, VALUE>>`.
template <
    class INPUT_ITERATOR,
    class ALLOC,
    class KEY = BloombergLP::bslstl::IteratorUtil::IterKey_t<INPUT_ITERATOR>,
    class VALUE =
               BloombergLP::bslstl::IteratorUtil::IterMapped_t<INPUT_ITERATOR>,
    class DEFAULT_ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<bsl::is_convertible_v<ALLOC *, DEFAULT_ALLOCATOR>>
    >
unordered_map(INPUT_ITERATOR,
              INPUT_ITERATOR,
              typename bsl::allocator_traits<DEFAULT_ALLOCATOR>::size_type,
              ALLOC *)
-> unordered_map<KEY, VALUE>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the iterators supplied to the constructor of `unordered_map`.  Deduce
/// the template parameter `ALLOCATOR` from the other parameter passed to
/// the constructor of `unordered_map`.  This deduction guide does not
/// participate unless the supplied allocator meets the requirements of a
/// standard allocator.
template <
    class INPUT_ITERATOR,
    class ALLOCATOR,
    class KEY = BloombergLP::bslstl::IteratorUtil::IterKey_t<INPUT_ITERATOR>,
    class VALUE =
               BloombergLP::bslstl::IteratorUtil::IterMapped_t<INPUT_ITERATOR>,
    class = bsl::enable_if_t<bsl::IsStdAllocator_v<ALLOCATOR>>
    >
unordered_map(INPUT_ITERATOR, INPUT_ITERATOR, ALLOCATOR)
-> unordered_map<KEY, VALUE, bsl::hash<KEY>, bsl::equal_to<KEY>, ALLOCATOR>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the iterators supplied to the constructor of `unordered_map`.  This
/// deduction guide does not participate unless the supplied allocator is
/// convertible to `bsl::allocator<bsl::pair<const KEY, VALUE>>`.
template <
    class INPUT_ITERATOR,
    class ALLOC,
    class KEY = BloombergLP::bslstl::IteratorUtil::IterKey_t<INPUT_ITERATOR>,
    class VALUE =
               BloombergLP::bslstl::IteratorUtil::IterMapped_t<INPUT_ITERATOR>,
    class DEFAULT_ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<bsl::is_convertible_v<ALLOC *, DEFAULT_ALLOCATOR>>
    >
unordered_map(INPUT_ITERATOR, INPUT_ITERATOR, ALLOC *)
-> unordered_map<KEY, VALUE>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the initializer_list supplied to the constructor of `unordered_map`.
/// Deduce the template parameters `HASH`, `EQUAL` and `ALLOCATOR` from the
/// other parameters supplied to the constructor of `unordered_map`.  This
/// deduction guide does not participate unless: (1) the supplied `HASH` is
/// invokable with a `KEY`, (2) the supplied `EQUAL` is invokable with two
/// `KEY`s, and (3) the supplied allocator meets the requirements of a
/// standard allocator.
template <
    class KEY,
    class VALUE,
    class HASH = bsl::hash<KEY>,
    class EQUAL = bsl::equal_to<KEY>,
    class ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<std::is_invocable_v<HASH, const KEY &>>,
    class = bsl::enable_if_t<
                         std::is_invocable_v<EQUAL, const KEY &, const KEY &>>,
    class = bsl::enable_if_t<bsl::IsStdAllocator_v<ALLOCATOR>>
    >
unordered_map(std::initializer_list<bsl::pair<const KEY, VALUE>>,
              typename bsl::allocator_traits<ALLOCATOR>::size_type = 0,
              HASH      = HASH(),
              EQUAL     = EQUAL(),
              ALLOCATOR = ALLOCATOR())
-> unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the initializer_list supplied to the constructor of `unordered_map`.
/// Deduce the template parameters `HASH` and `EQUAL` from the other
/// parameters supplied to the constructor of `unordered_map`.  This
/// deduction guide does not participate unless the supplied allocator is
/// convertible to `bsl::allocator<bsl::pair<const KEY, VALUE>>`.
template <
    class KEY,
    class VALUE,
    class HASH,
    class EQUAL,
    class ALLOC,
    class DEFAULT_ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<bsl::is_convertible_v<ALLOC *, DEFAULT_ALLOCATOR>>
    >
unordered_map(std::initializer_list<bsl::pair<const KEY, VALUE>>,
              typename bsl::allocator_traits<DEFAULT_ALLOCATOR>::size_type,
              HASH,
              EQUAL,
              ALLOC *)
-> unordered_map<KEY, VALUE, HASH, EQUAL>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the initializer_list supplied to the constructor of `unordered_map`.
/// Deduce the template parameters `HASH` and `ALLOCATOR` from the other
/// parameters supplied to the constructor of `unordered_map`.  This
/// deduction guide does not participate unless the supplied `HASH` is
/// invokable with a `KEY`, and the supplied allocator meets the
/// requirements of a standard allocator.
template <
    class KEY,
    class VALUE,
    class HASH,
    class ALLOCATOR,
    class = bsl::enable_if_t<std::is_invocable_v<HASH, const KEY &>>,
    class = bsl::enable_if_t<bsl::IsStdAllocator_v<ALLOCATOR>>
    >
unordered_map(std::initializer_list<bsl::pair<const KEY, VALUE>>,
              typename bsl::allocator_traits<ALLOCATOR>::size_type,
              HASH,
              ALLOCATOR)
-> unordered_map<KEY, VALUE, HASH, bsl::equal_to<KEY>, ALLOCATOR>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the initializer_list supplied to the constructor of `unordered_map`.
/// Deduce the template parameter `HASH` from the other parameters supplied
/// to the constructor of `unordered_map`.  This deduction guide does not
/// participate unless the supplied allocator is convertible to
/// `bsl::allocator<bsl::pair<const KEY, VALUE>>`.
template <
    class KEY,
    class VALUE,
    class HASH,
    class ALLOC,
    class DEFAULT_ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<bsl::is_convertible_v<ALLOC *, DEFAULT_ALLOCATOR>>
    >
unordered_map(std::initializer_list<bsl::pair<const KEY, VALUE>>,
              typename bsl::allocator_traits<DEFAULT_ALLOCATOR>::size_type,
              HASH,
              ALLOC *)
-> unordered_map<KEY, VALUE, HASH>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the initializer_list supplied to the constructor of `unordered_map`.
/// This deduction guide does not participate unless the supplied allocator
/// meets the requirements of a standard allocator.
template <
    class KEY,
    class VALUE,
    class ALLOCATOR,
    class = bsl::enable_if_t<bsl::IsStdAllocator_v<ALLOCATOR>>
    >
unordered_map(std::initializer_list<bsl::pair<const KEY, VALUE>>,
              typename bsl::allocator_traits<ALLOCATOR>::size_type,
              ALLOCATOR)
-> unordered_map<KEY, VALUE, bsl::hash<KEY>, bsl::equal_to<KEY>, ALLOCATOR>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the initializer_list supplied to the constructor of `unordered_map`.
/// This deduction guide does not participate unless the supplied allocator
/// is convertible to `bsl::allocator<bsl::pair<const KEY, VALUE>>`.
template <
    class KEY,
    class VALUE,
    class ALLOC,
    class DEFAULT_ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<bsl::is_convertible_v<ALLOC *, DEFAULT_ALLOCATOR>>
    >
unordered_map(std::initializer_list<bsl::pair<const KEY, VALUE>>,
              typename bsl::allocator_traits<DEFAULT_ALLOCATOR>::size_type,
              ALLOC *)
-> unordered_map<KEY, VALUE>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the initializer_list supplied to the constructor of `unordered_map`.
/// Deduce the template parameter `ALLOCATOR` from the other parameters
/// supplied to the constructor of `unordered_map`.  This deduction guide
/// does not participate unless the supplied allocator meets the
/// requirements of a standard allocator.
template <
    class KEY,
    class VALUE,
    class ALLOCATOR,
    class = bsl::enable_if_t<bsl::IsStdAllocator_v<ALLOCATOR>>
    >
unordered_map(std::initializer_list<bsl::pair<const KEY, VALUE>>, ALLOCATOR)
-> unordered_map<KEY, VALUE, bsl::hash<KEY>, bsl::equal_to<KEY>, ALLOCATOR>;

/// Deduce the template parameters `KEY` and `VALUE` from the `value_type`
/// of the initializer_list supplied to the constructor of `unordered_map`.
/// This deduction guide does not participate unless the supplied allocator
/// is convertible to `bsl::allocator<bsl::pair<const KEY, VALUE>>`.
template <
    class KEY,
    class VALUE,
    class ALLOC,
    class DEFAULT_ALLOCATOR = bsl::allocator<bsl::pair<const KEY, VALUE>>,
    class = bsl::enable_if_t<bsl::is_convertible_v<ALLOC *, DEFAULT_ALLOCATOR>>
    >
unordered_map(std::initializer_list<bsl::pair<const KEY, VALUE>>, ALLOC *)
-> unordered_map<KEY, VALUE>;
#endif

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` objects have the same
/// value, and `false` otherwise.  Two `unordered_map` objects have the
/// same value if they have the same number of key-value pairs, and for each
/// key-value pair that is contained in `lhs` there is a key-value pair
/// contained in `rhs` having the same value, and vice versa.  Note that
/// this method requires that the (template parameter) types `KEY` and
/// `VALUE` both be `equality-comparable` (see {Requirements on
/// `value_type`}).
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
bool operator==(const unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& lhs,
                const unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& rhs);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_THREE_WAY_COMPARISON
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
bool operator!=(const unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& lhs,
                const unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have the
    // same value, and 'false' otherwise.  Two 'unordered_map' objects do not
    // have the same value if they do not have the same number of key-value
    // pairs, or for some key-value pair that is contained in 'lhs' there is
    // not a key-value pair in 'rhs' having the same value or vice-versa.  Note
    // that this method requires that the (template parameter) types 'KEY' and
    // 'VALUE' both be 'equality-comparable' (see {Requirements on
    // 'value_type'}).
#endif

// FREE FUNCTIONS

/// Erase all the elements in the specified unordered_map `m` that satisfy
/// the specified predicate `predicate`.  Return the number of elements
/// erased.
template <class KEY,
          class VALUE,
          class HASH,
          class EQUAL,
          class ALLOCATOR,
          class PREDICATE>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
erase_if(unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>&         m,
                                                          PREDICATE predicate);

/// Exchange the value, hasher, key-equality functor, and `max_load_factor`
/// of the specified `a` object with those of the specified `b` object; also
/// exchange the allocator of `a` with that of `b` if the (template
/// parameter) type `ALLOCATOR` has the `propagate_on_container_swap` trait,
/// and do not modify either allocator otherwise.  This function provides
/// the no-throw exception-safety guarantee if and only if both the
/// (template parameter) types `HASH` and `EQUAL` provide no-throw swap
/// operations; if an exception is thrown, both objects are left in valid
/// but unspecified states.  This operation guarantees `O[1]` complexity.
/// The behavior is undefined unless either `a` was created with the same
/// allocator as `b` or `ALLOCATOR` has the `propagate_on_container_swap`
/// trait.
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
void swap(unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& a,
          unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& b)
                                    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false);

}  // close namespace bsl

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

namespace bsl {
                        //--------------------
                        // class unordered_map
                        //--------------------

// CREATORS
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::
unordered_map(size_type        initialNumBuckets,
              const HASH&      hashFunction,
              const EQUAL&     keyEqual,
              const ALLOCATOR& basicAllocator)
: d_impl(hashFunction, keyEqual, initialNumBuckets, 1.0f, basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                                            size_type        initialNumBuckets,
                                            const HASH&      hashFunction,
                                            const ALLOCATOR& basicAllocator)
: d_impl(hashFunction, EQUAL(), initialNumBuckets, 1.0f, basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                                            size_type        initialNumBuckets,
                                            const ALLOCATOR& basicAllocator)
: d_impl(HASH(), EQUAL(), initialNumBuckets, 1.0f, basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                                               const ALLOCATOR& basicAllocator)
: d_impl(basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map()
: d_impl()
{
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class INPUT_ITERATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                                            INPUT_ITERATOR   first,
                                            INPUT_ITERATOR   last,
                                            size_type        initialNumBuckets,
                                            const HASH&      hashFunction,
                                            const EQUAL&     keyEqual,
                                            const ALLOCATOR& basicAllocator)
: d_impl(hashFunction, keyEqual, initialNumBuckets, 1.0f, basicAllocator)
{
    this->insert(first, last);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class INPUT_ITERATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                                            INPUT_ITERATOR   first,
                                            INPUT_ITERATOR   last,
                                            size_type        initialNumBuckets,
                                            const HASH&      hashFunction,
                                            const ALLOCATOR& basicAllocator)
: d_impl(hashFunction, EQUAL(), initialNumBuckets, 1.0f, basicAllocator)
{
    this->insert(first, last);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class INPUT_ITERATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                                            INPUT_ITERATOR   first,
                                            INPUT_ITERATOR   last,
                                            size_type        initialNumBuckets,
                                            const ALLOCATOR& basicAllocator)
: d_impl(HASH(), EQUAL(), initialNumBuckets, 1.0f, basicAllocator)
{
    this->insert(first, last);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class INPUT_ITERATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                                               INPUT_ITERATOR   first,
                                               INPUT_ITERATOR   last,
                                               const ALLOCATOR& basicAllocator)
: d_impl(basicAllocator)
{
    this->insert(first, last);
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
# ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
template <class, class, class>
# endif
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                           std::initializer_list<value_type> values,
                           size_type                         initialNumBuckets,
                           const HASH&                       hashFunction,
                           const EQUAL&                      keyEqual,
                           const ALLOCATOR&                  basicAllocator)
: d_impl(hashFunction, keyEqual, initialNumBuckets, 1.0f, basicAllocator)
{
    insert(values.begin(), values.end());
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
# ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
template <class, class>
# endif
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                           std::initializer_list<value_type> values,
                           size_type                         initialNumBuckets,
                           const HASH&                       hashFunction,
                           const ALLOCATOR&                  basicAllocator)
: d_impl(hashFunction, EQUAL(), initialNumBuckets, 1.0f, basicAllocator)
{
    insert(values.begin(), values.end());
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
# ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
template <class>
# endif
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                           std::initializer_list<value_type> values,
                           size_type                         initialNumBuckets,
                           const ALLOCATOR&                  basicAllocator)
: d_impl(HASH(), EQUAL(), initialNumBuckets, 1.0f, basicAllocator)
{
    insert(values.begin(), values.end());
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
# ifdef BSLS_COMPILERFEATURES_SUPPORT_CTAD
template <class>
# endif
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                              std::initializer_list<value_type> values,
                              const ALLOCATOR&                  basicAllocator)
: d_impl(basicAllocator)
{
    insert(values.begin(), values.end());
}
#endif

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                                                 const unordered_map& original)
: d_impl(original.d_impl,
         AllocatorTraits::select_on_container_copy_construction(
                                                     original.get_allocator()))
{
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                 const unordered_map&                           original,
                 const typename type_identity<ALLOCATOR>::type& basicAllocator)
: d_impl(original.d_impl, basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                        BloombergLP::bslmf::MovableRef<unordered_map> original)
: d_impl(MoveUtil::access(original).get_allocator())
{
    unordered_map& lvalue = original;

    this->swap(lvalue);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::unordered_map(
                 BloombergLP::bslmf::MovableRef<unordered_map>  original,
                 const typename type_identity<ALLOCATOR>::type& basicAllocator)
: d_impl(MoveUtil::move(MoveUtil::access(original).d_impl), basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::~unordered_map()
{
    // All memory management is handled by the base 'd_impl' member.
}

// MANIPULATORS
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>&
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::operator=(
                                                      const unordered_map& rhs)
{
    // Note that we have delegated responsibility for correct handling of
    // allocator propagation to the 'HashTable' implementation.

    d_impl = rhs.d_impl;

    return *this;
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>&
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::operator=(
                             BloombergLP::bslmf::MovableRef<unordered_map> rhs)
    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                AllocatorTraits::is_always_equal::value &&
                                std::is_nothrow_move_assignable<HASH>::value &&
                                std::is_nothrow_move_assignable<EQUAL>::value)
{
    // Note that we have delegated responsibility for correct handling of
    // allocator propagation to the 'HashTable' implementation.

    unordered_map& lvalue = rhs;

    d_impl = MoveUtil::move(lvalue.d_impl);

    return *this;
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>&
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::operator=(
                                         std::initializer_list<value_type> rhs)
{
    unordered_map tmp(rhs.begin(), rhs.end(), d_impl.allocator());

    this->swap(tmp);

    return *this;
}
#endif

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename add_lvalue_reference<VALUE>::type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::operator[](
                                                           const key_type& key)
{
    HashTableLink *node = d_impl.insertIfMissing(key);
    return static_cast<HashTableNode *>(node)->value().second;
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename add_lvalue_reference<VALUE>::type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::operator[](
                                  BloombergLP::bslmf::MovableRef<key_type> key)
{
    HashTableLink *node = d_impl.insertIfMissing(
                                        MoveUtil::move(MoveUtil::access(key)));
    return static_cast<HashTableNode *>(node)->value().second;
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename add_lvalue_reference<VALUE>::type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::at(const key_type& key)
{
    HashTableLink *node = d_impl.find(key);

    if (!node) {
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                        "unordered_map<...>::at(key_type): invalid key value");
    }

    return static_cast<HashTableNode *>(node)->value().second;
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::begin()
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return iterator(d_impl.elementListRoot());
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::end() BSLS_KEYWORD_NOEXCEPT
{
    return iterator();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::local_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::begin(size_type index)
{
    BSLS_ASSERT_SAFE(index < this->bucket_count());

    return local_iterator(&d_impl.bucketAtIndex(index));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::local_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::end(size_type index)
{
    BSLS_ASSERT_SAFE(index < this->bucket_count());

    return local_iterator(0, &d_impl.bucketAtIndex(index));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
void
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::clear()
                                                          BSLS_KEYWORD_NOEXCEPT
{
    d_impl.removeAll();
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_unorderedmap.h
#ifndef BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT
#define BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E
#define BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT
#endif
#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 0
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                               )
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag);

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 1
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 2
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 3
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 4
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 5
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 6
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 7
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 8
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 9
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 10
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(Args_10, args_10));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 0
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag);

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 1
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 2
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 3
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 4
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 5
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 6
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 7
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 8
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 9
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 10
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(Args_10, args_10));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_E >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class... Args>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                                 BSLS_COMPILERFEATURES_FORWARD(Args, args)...);

    return ResultType(iterator(result), isInsertedFlag);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class... Args>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::emplace_hint(
                                                const_iterator,
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.emplaceIfMissing(
                                 &isInsertedFlag,
                                 BSLS_COMPILERFEATURES_FORWARD(Args, args)...);

    return iterator(result);
}
// }}} END GENERATED CODE
#endif

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::erase(
                                                       const_iterator position)
{
    BSLS_ASSERT_SAFE(position != this->end());

    return iterator(d_impl.remove(position.node()));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::erase(iterator position)
{
    return erase(const_iterator(position));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::erase(const key_type& key)
{
    HashTableLink *target = d_impl.find(key);
    if (target) {
        d_impl.remove(target);
        return 1;                                                     // RETURN
    }
    else {
        return 0;                                                     // RETURN
    }
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::erase(const_iterator first,
                                                         const_iterator last)
{

#if defined BDE_BUILD_TARGET_SAFE_2
    if (first != last) {
        iterator it        = this->begin();
        const iterator end = this->end();
        for (; it != first; ++it) {
            BSLS_ASSERT(last != it);
            BSLS_ASSERT(end  != it);
        }
        for (; it != last; ++it) {
            BSLS_ASSERT(end  != it);
        }
    }
#endif

    while (first != last) {
        first = this->erase(first);
    }

    return iterator(first.node()); // convert from const_iterator
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
bool unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::contains(
                                                     const key_type& key) const
{
    return find(key) != end();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::find(const key_type& key)
{
    return iterator(d_impl.find(key));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
pair<typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::insert(
                                                       const value_type& value)
{
    typedef bsl::pair<iterator, bool> ResultType;

    bool isInsertedFlag = false;

    HashTableLink *result = d_impl.insertIfMissing(&isInsertedFlag, value);

    return ResultType(iterator(result), isInsertedFlag);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::insert(
                                                       const_iterator,
                                                       const value_type& value)
{
    bool   isInsertedFlag;    // not used

    HashTableLink *result = d_impl.insertIfMissing(&isInsertedFlag, value);

    return iterator(result);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class INPUT_ITERATOR>
void unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::insert(
                                                          INPUT_ITERATOR first,
                                                          INPUT_ITERATOR last)
{
    difference_type maxInsertions =
              ::BloombergLP::bslstl::IteratorUtil::insertDistance(first, last);
    if (0 < maxInsertions) {
        this->reserve(this->size() + maxInsertions);
    }
    else {
        BSLS_ASSERT_SAFE(0 == maxInsertions);
    }

    bool isInsertedFlag;  // not used
    while (first != last) {
        d_impl.emplaceIfMissing(&isInsertedFlag, *first);
        ++first;
    }
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
void unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::insert(
                                      std::initializer_list<value_type> values)
{
    insert(values.begin(), values.end());
}
#endif

// {{{ BEGIN GENERATED CODE
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class BDE_OTHER_TYPE>
bsl::pair<typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
          bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::insert_or_assign(
    const KEY&       key,
    BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink                     *result = d_impl.insertOrAssign(
                            &isInsertedFlag,
                            NULL,
                            key,
                            BSLS_COMPILERFEATURES_FORWARD(BDE_OTHER_TYPE, obj));
    return ResultType(iterator(result), isInsertedFlag);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class BDE_OTHER_TYPE>
bsl::pair<typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
          bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::insert_or_assign(
    BloombergLP::bslmf::MovableRef<KEY> key,
    BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink                     *result = d_impl.insertOrAssign(
                            &isInsertedFlag,
                            NULL,
                            BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                            BSLS_COMPILERFEATURES_FORWARD(BDE_OTHER_TYPE, obj));
    return ResultType(iterator(result), isInsertedFlag);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class BDE_OTHER_TYPE>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::insert_or_assign(
                                                         const_iterator   hint,
                                                         const KEY&       key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj)
{
    bool isInsertedFlag = false;
    HashTableLink *result         = d_impl.insertOrAssign(
                &isInsertedFlag,
                hint.node(),
                key,
                BSLS_COMPILERFEATURES_FORWARD(BDE_OTHER_TYPE, obj));
    return iterator(result);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class BDE_OTHER_TYPE>
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::insert_or_assign(
                                      const_iterator                      hint,
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(BDE_OTHER_TYPE) obj)
{
    bool isInsertedFlag = false;
    HashTableLink *result         = d_impl.insertOrAssign(
                &isInsertedFlag,
                hint.node(),
                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                BSLS_COMPILERFEATURES_FORWARD(BDE_OTHER_TYPE, obj));
    return iterator(result);
}
// }}} END GENERATED CODE

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
bsl::pair<
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
         typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::equal_range(
                                                           const key_type& key)
{
    typedef bsl::pair<iterator, iterator> ResultType;

    HashTableLink *first = d_impl.find(key);
    return first ? ResultType(iterator(first), iterator(first->nextLink()))
                 : ResultType(iterator(0),     iterator(0));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
void
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::max_load_factor(
                                                        float newMaxLoadFactor)
{
    d_impl.setMaxLoadFactor(newMaxLoadFactor);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
void
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::rehash(
                                                          size_type numBuckets)
{
    d_impl.rehashForNumBuckets(numBuckets);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
void
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::reserve(
                                                         size_type numElements)
{
    d_impl.reserveForNumElements(numElements);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
void
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::swap(unordered_map& other)
    BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(
                                     AllocatorTraits::is_always_equal::value &&
                                     bsl::is_nothrow_swappable<HASH>::value &&
                                     bsl::is_nothrow_swappable<EQUAL>::value)
{
    d_impl.swap(other.d_impl);
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_unorderedmap.h
#ifndef BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT
#define BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G
#define BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT
#endif
#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 0
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key);

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 1
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 2
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 3
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 4
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 5
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 6
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 7
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 8
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 9
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 10
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(Args_10, args_10));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 0
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 1
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 2
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 3
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 4
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 5
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 6
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 7
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 8
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 9
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 10
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(Args_10, args_10));

    return ResultType(iterator(result), isInsertedFlag);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 0
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key);

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 1
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 2
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 3
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 4
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 5
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 6
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 7
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 8
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 9
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 10
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(Args_10, args_10));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 10


#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 0
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 0

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 1
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 1

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 2
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 2

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 3
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 3

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 4
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 4

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 5
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 5

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 6
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 6

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 7
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 7

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 8
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 8

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 9
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 9

#if BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 10
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class Args_01,
          class Args_02,
          class Args_03,
          class Args_04,
          class Args_05,
          class Args_06,
          class Args_07,
          class Args_08,
          class Args_09,
          class Args_10>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) args_10)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                              BSLS_COMPILERFEATURES_FORWARD(Args_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(Args_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(Args_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(Args_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(Args_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(Args_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(Args_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(Args_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(Args_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(Args_10, args_10));

    return iterator(result);
}
#endif  // BSLSTL_UNORDEREDMAP_VARIADIC_LIMIT_G >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class... Args>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                               const KEY& key,
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                key,
                                BSLS_COMPILERFEATURES_FORWARD(Args, args)...);

    return ResultType(iterator(result), isInsertedFlag);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class... Args>
inline
bsl::pair<
     typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator,
     bool>
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    typedef bsl::pair<iterator, bool> ResultType;
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                NULL,
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                                BSLS_COMPILERFEATURES_FORWARD(Args, args)...);

    return ResultType(iterator(result), isInsertedFlag);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class... Args>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                                           const_iterator hint,
                                                           const KEY&     key,
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                key,
                                BSLS_COMPILERFEATURES_FORWARD(Args, args)...);

    return iterator(result);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
template <class... Args>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::iterator
bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::try_emplace(
                                 const_iterator                           hint,
                                 BloombergLP::bslmf::MovableRef<KEY>      key,
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    bool isInsertedFlag = false;
    HashTableLink *result = d_impl.tryEmplace(
                                &isInsertedFlag,
                                hint.node(),
                                BSLS_COMPILERFEATURES_FORWARD(KEY, key),
                                BSLS_COMPILERFEATURES_FORWARD(Args, args)...);

    return iterator(result);
}
// }}} END GENERATED CODE
#endif

// ACCESSORS
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
typename add_lvalue_reference<const VALUE>::type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::at(
                                                     const key_type& key) const
{
    HashTableLink *target = d_impl.find(key);
    if (!target ){
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                        "unordered_map<...>::at(key_type): invalid key value");
    }
    return static_cast<HashTableNode *>(target)->value().second;
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::begin() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return const_iterator(d_impl.elementListRoot());
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::end() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return const_iterator();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::cbegin() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return const_iterator(d_impl.elementListRoot());
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::cend() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return const_iterator();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_local_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::begin(size_type index) const
{
    BSLS_ASSERT_SAFE(index < this->bucket_count());

    return const_local_iterator(&d_impl.bucketAtIndex(index));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_local_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::end(size_type index) const
{
    BSLS_ASSERT_SAFE(index < this->bucket_count());

    return const_local_iterator(0, &d_impl.bucketAtIndex(index));
}


template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_local_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::cbegin(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index < this->bucket_count());

    return const_local_iterator(&d_impl.bucketAtIndex(index));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_local_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::cend(size_type index) const
{
    BSLS_ASSERT_SAFE(index < this->bucket_count());

    return const_local_iterator(0, &d_impl.bucketAtIndex(index));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::bucket(
                                                     const key_type& key) const
{
    return d_impl.bucketIndexForKey(key);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::bucket_count() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return d_impl.numBuckets();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::max_bucket_count() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return d_impl.maxNumBuckets();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::bucket_size(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index < this->bucket_count());

    return d_impl.countElementsInBucket(index);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::count(
                                                     const key_type& key) const
{
    return d_impl.find(key) != 0;
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
bool
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::empty() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return 0 == d_impl.size();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
bsl::pair<typename unordered_map<KEY,
                                 VALUE,
                                 HASH,
                                 EQUAL,
                                 ALLOCATOR>::const_iterator,
          typename unordered_map<KEY,
                                 VALUE,
                                 HASH,
                                 EQUAL,
                                 ALLOCATOR>::const_iterator>
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::equal_range(
                                                     const key_type& key) const
{
    typedef bsl::pair<const_iterator, const_iterator> ResultType;

    HashTableLink *first = d_impl.find(key);
    return first
         ? ResultType(const_iterator(first), const_iterator(first->nextLink()))
         : ResultType(const_iterator(0),     const_iterator(0));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename
       unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::const_iterator
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::find(
                                                     const key_type& key) const
{
    return const_iterator(d_impl.find(key));
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
ALLOCATOR
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::get_allocator() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return d_impl.allocator();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
HASH unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::hash_function() const
{
    return d_impl.hasher();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
EQUAL unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::key_eq() const
{
    return d_impl.comparator();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
float
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::load_factor() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return d_impl.loadFactor();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
float
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::max_load_factor() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return d_impl.maxLoadFactor();
}


template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return d_impl.size();
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
typename unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::max_size() const
                                                          BSLS_KEYWORD_NOEXCEPT
{
    return d_impl.maxSize();
}

}  // close namespace bsl

// FREE OPERATORS
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
bool bsl::operator==(
             const bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& lhs,
             const bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& rhs)
{
    return lhs.d_impl == rhs.d_impl;
}

#ifndef BSLS_COMPILERFEATURES_SUPPORT_THREE_WAY_COMPARISON
template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
bool bsl::operator!=(
             const bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& lhs,
             const bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& rhs)
{
    return !(lhs == rhs);
}
#endif

// FREE FUNCTIONS
template <class KEY,
          class VALUE,
          class HASH,
          class EQUAL,
          class ALLOCATOR,
          class PREDICATE>
inline
typename bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>::size_type
bsl::erase_if(unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>&     m,
                                                           PREDICATE predicate)
{
    return BloombergLP::bslstl::AlgorithmUtil::containerEraseIf(m, predicate);
}

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
inline
void
bsl::swap(bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& a,
          bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR>& b)
                                     BSLS_KEYWORD_NOEXCEPT_SPECIFICATION(false)
{
    a.swap(b);
}

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for STL *unordered* *associative* containers:
//: o An unordered associative container defines STL iterators.
//: o An unordered associative container is bit-wise movable if both functors
//:   and the allocator are bit-wise movable.
//: o An unordered associative container uses 'bslma' allocators if the
//:   (template parameter) type 'ALLOCATOR' is convertible from
//:   'bslma::Allocator *'.

namespace BloombergLP {
namespace bslalg {

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
struct HasStlIterators<bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR> >
     : bsl::true_type
{};

}  // close namespace bslalg

namespace bslma {

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
struct UsesBslmaAllocator<bsl::unordered_map<KEY,
                                             VALUE,
                                             HASH,
                                             EQUAL,
                                             ALLOCATOR> >
     : bsl::is_convertible<Allocator*, ALLOCATOR>::type
{};

}  // close namespace bslma

namespace bslmf {

template <class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR>
struct IsBitwiseMoveable<
    bsl::unordered_map<KEY, VALUE, HASH, EQUAL, ALLOCATOR> >
    : ::BloombergLP::bslmf::IsBitwiseMoveable<BloombergLP::bslstl::HashTable<
          ::BloombergLP::bslstl::
               UnorderedMapKeyConfiguration<KEY, bsl::pair<const KEY, VALUE> >,
          HASH,
          EQUAL,
          ALLOCATOR> >::type
{};

}  // close namespace bslma
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLSTL_UNORDEREDMAP_H)
# error Not valid except when included from bslstl_unorderedmap.h
#endif // ! defined(COMPILING_BSLSTL_UNORDEREDMAP_H)

#endif // ! defined(INCLUDED_BSLSTL_UNORDEREDMAP_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
