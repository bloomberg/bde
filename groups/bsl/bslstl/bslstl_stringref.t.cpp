// bslstl_stringref.t.cpp                                             -*-C++-*-

#include <bslstl_stringref.h>

#include <bslh_hash.h>

#include <bslma_testallocator.h>
#include <bslma_defaultallocatorguard.h>

#include <bslma_usesbslmaallocator.h>

#include <bslmf_assert.h>
#include <bslmf_isbitwisecopyable.h>
#include <bslmf_isbitwiseequalitycomparable.h>
#include <bslmf_istriviallydefaultconstructible.h>

#include <bsls_asserttest.h>
#include <bsls_bsltestutil.h>
#include <bsls_nameof.h>
#include <bsls_platform.h>
#include <bsls_stopwatch.h>
#include <bsls_types.h>

#include <bsltf_templatetestfacility.h>

#include <algorithm>
#include <iomanip>
#include <ios>
#include <iostream>
#include <limits>
#include <map>
#include <ostream>
#include <sstream>
#include <string>
#include <vector>

#include <limits.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#undef ES  // From solaris/x86 2.10 <stdlib.h>
           //       -> sys/wait.h -> signal.h -> sys/ucontext.h -> sys/regset.h

using namespace BloombergLP;

#ifdef BSLS_PLATFORM_HAS_PRAGMA_GCC_DIAGNOSTIC
# ifdef BSLS_PLATFORM_CMP_CLANG
#   pragma clang diagnostic ignored "-Wshorten-64-to-32"
# elif defined(BDE_BUILD_TARGET_ASAN)
#   pragma GCC diagnostic ignored "-Wlarger-than="
# endif
#endif

//=============================================================================
//                                 TEST PLAN
//-----------------------------------------------------------------------------
//                                  Overview
//                                  --------
// The component under test provides an in-core pointer-semantic object.
//-----------------------------------------------------------------------------
// CREATORS
// [ 2] bslstl::StringRefImp();
// [ 2] bslstl::StringRefImp(const CHAR *begin, const CHAR *end);
// [ 2] bslstl::StringRefImp(const CHAR *begin, INT_TYPE length);
// [ 2] bslstl::StringRefImp(const CHAR *begin, size_type length, Nil);
// [ 2] bslstl::StringRefImp(const CHAR *begin, size_type f, size_type l);
// [ 2] bslstl::StringRefImp(const CHAR *begin);
// [ 2] bslstl::StringRefImp(const bsl::string& begin);
// [ 2] bslstl::StringRefImp(const std::string& begin);
// [ 2] bslstl::StringRefImp(const bslstl::StringRefImp& original);
// [ 2] ~bslstl::StringRefImp();
// [ 9] bslstl::StringRefImp(const StringRefImp& , size_type, size_type)
// [14] bsl::string_view(const char *);
// [14] bsl::string_view(const char *, size_t);
// [14] bsl::string_view(const bsl::string&);
// [14] bsl::string_view(const std::string&);
// [14] bsl::string_view(const bsl::string_view&);
//
// MANIPULATORS
// [ 2] bslstl::StringRefImp& operator=(const bslstl::StringRefImp&);
// [ 6] void reset();
// [ 6] void assign(const char *begin, const char *end);
// [ 6] void assign(const char *begin, size_type length);
// [ 6] void assign(const char *begin);
// [ 6] void assign(const bsl::string& begin);
//
// ACCESSORS
// [ 3] const_iterator begin() const;
// [ 3] const_iterator data() const;
// [ 3] const_iterator end() const;
// [ 3] size_type      length() const;
// [ 3] size_type      size() const;
// [ 3] int            empty() const;
// [ 3] int            isEmpty() const;
// [ 3] int            compare(const StringRefImp&) const;
// [ 3] int            compare(const CHAR *) const;
// [ 3]                operator std::basic_string() const;
// [ 3] const char&    operator[](size_type index) const;
// [10] const_reverse_iterator rbegin() const;
// [10] const_reverse_iterator rend() const;
//
// FREE OPERATORS
// [ 3] bool operator==(const StringRef& lhs, const StringRef& rhs);
// [ 3] bool operator==(const bsl::string& lhs, const StringRef& rhs);
// [ 3] bool operator==(const StringRef& lhs, const bsl::string& rhs);
// [ 3] bool operator==(const std::string& l, const StringRef& r);
// [ 3] bool operator==(const StringRef& l, const std::string& r);
// [ 3] bool operator==(const char *lhs, const StringRef& rhs);
// [ 3] bool operator==(const StringRef& lhs, const char *rhs);
// [ 3] bool operator==(const StringRef& lhs, string_view rhs);
// [ 3] bool operator==(string_view lhs, const StringRef& rhs);
// [ 3] bool operator!=(const StringRef& lhs, const StringRef& rhs);
// [ 3] bool operator!=(const bsl::string& lhs, const StringRef& rhs);
// [ 3] bool operator!=(const StringRef& lhs, const bsl::string& rhs);
// [ 3] bool operator!=(const std::string& l, const StringRef& r);
// [ 3] bool operator!=(const StringRef& l, const std::string& r);
// [ 3] bool operator!=(const char *lhs, const StringRef& rhs);
// [ 3] bool operator!=(const StringRef& lhs, const char *rhs);
// [ 3] bool operator!=(const StringRef& lhs, string_view rhs);
// [ 3] bool operator!=(string_view lhs, const StringRef& rhs);
// [ 3] bool operator<(const StringRef& lhs, const StringRef& rhs);
// [ 3] bool operator<(const bsl::string& lhs, const StringRef& rhs);
// [ 3] bool operator<(const StringRef& lhs, const bsl::string& rhs);
// [ 3] bool operator<(const std::string& l, const StringRef& r);
// [ 3] bool operator<(const StringRef& l, const std::string& r);
// [ 3] bool operator<(const char *lhs, const StringRef& rhs);
// [ 3] bool operator<(const StringRef& lhs, const char *rhs);
// [ 3] bool operator<(const StringRef& lhs, string_view rhs);
// [ 3] bool operator<(string_view lhs, const StringRef& rhs);
// [ 3] bool operator>(const StringRef& lhs, const StringRef& rhs);
// [ 3] bool operator>(const bsl::string& lhs, const StringRef& rhs);
// [ 3] bool operator>(const StringRef& lhs, const bsl::string& rhs);
// [ 3] bool operator>(const std::string& l, const StringRef& r);
// [ 3] bool operator>(const StringRef& l, const std::string& r);
// [ 3] bool operator>(const char *lhs, const StringRef& rhs);
// [ 3] bool operator>(const StringRef& lhs, const char *rhs);
// [ 3] bool operator>(const StringRef& lhs, string_view rhs);
// [ 3] bool operator>(string_view lhs, const StringRef& rhs);
// [ 3] bool operator<=(const StringRef& lhs, const StringRef& rhs);
// [ 3] bool operator<=(const bsl::string& lhs, const StringRef& rhs);
// [ 3] bool operator<=(const StringRef& lhs, const bsl::string& rhs);
// [ 3] bool operator<=(const std::string& l, const StringRef& r);
// [ 3] bool operator<=(const StringRef& l, const std::string& r);
// [ 3] bool operator<=(const char *lhs, const StringRef& rhs);
// [ 3] bool operator<=(const StringRef& lhs, const char *rhs);
// [ 3] bool operator<=(const StringRef& lhs, string_view rhs);
// [ 3] bool operator<=(string_view lhs, const StringRef& rhs);
// [ 3] bool operator>=(const StringRef& lhs, const StringRef& rhs);
// [ 3] bool operator>=(const bsl::string& lhs, const StringRef& rhs);
// [ 3] bool operator>=(const StringRef& lhs, const bsl::string& rhs);
// [ 3] bool operator>=(const std::string& l, const StringRef& r);
// [ 3] bool operator>=(const StringRef& l, const std::string& r);
// [ 3] bool operator>=(const char *lhs, const StringRef& rhs);
// [ 3] bool operator>=(const StringRef& lhs, const char *rhs);
// [ 3] bool operator>=(const StringRef& lhs, string_view rhs);
// [ 3] bool operator>=(string_view lhs, const StringRef& rhs);
// [ 4] operator<<(ostream&, const StringRef& string);
// [ 7] basic_string operator+(const StringRef& l, const StringRef& r);
// [ 7] basic_string operator+(const bsl::string& l, const StringRef& r);
// [ 7] basic_string operator+(const StringRef& l, const bsl::string& r);
// [ 7] basic_string operator+(const std::string& l, StringRef r);
// [ 7] basic_string operator+(const StringRef& l, std::string r);
// [ 7] basic_string operator+(const char *l, const StringRef& r);
// [ 7] basic_string operator+(const StringRef& l, const char *r);
// [ 8] bsl::hash<BloombergLP::bslstl::StringRef>
// [ 8] bslh::Hash<>
//
// OTHER COMPONENTS
// [ 7] basic_string basic_string::operator+=(const StringRefData& strRf);
// [11] bsl::string::operator=(const bslstl::StringRefData&);
//-----------------------------------------------------------------------------
// [ 1] BREATHING TEST
// [16] USAGE EXAMPLE
// [12] TYPE TRAITS
// [13] STRING CONSTRUCTORS COMPATIBILITY
// [15] CONV of `string_view` W.R.T. `std::basic_string` (from stringview)

// ============================================================================
//                     STANDARD BSL ASSERT TEST FUNCTION
// ----------------------------------------------------------------------------

namespace {

int testStatus = 0;

void aSsErT(bool condition, const char *message, int line)
{
    if (condition) {
        printf("Error " __FILE__ "(%d): %s    (failed)\n", line, message);
        fflush(stdout);

        if (0 <= testStatus && testStatus <= 100) {
            ++testStatus;
        }
    }
}

}  // close unnamed namespace

// ============================================================================
//               STANDARD BSL TEST DRIVER MACRO ABBREVIATIONS
// ----------------------------------------------------------------------------

#define ASSERT       BSLS_BSLTESTUTIL_ASSERT
#define ASSERTV      BSLS_BSLTESTUTIL_ASSERTV

#define LOOP_ASSERT  BSLS_BSLTESTUTIL_LOOP_ASSERT
#define LOOP0_ASSERT BSLS_BSLTESTUTIL_LOOP0_ASSERT
#define LOOP1_ASSERT BSLS_BSLTESTUTIL_LOOP1_ASSERT
#define LOOP2_ASSERT BSLS_BSLTESTUTIL_LOOP2_ASSERT
#define LOOP3_ASSERT BSLS_BSLTESTUTIL_LOOP3_ASSERT
#define LOOP4_ASSERT BSLS_BSLTESTUTIL_LOOP4_ASSERT
#define LOOP5_ASSERT BSLS_BSLTESTUTIL_LOOP5_ASSERT
#define LOOP6_ASSERT BSLS_BSLTESTUTIL_LOOP6_ASSERT

#define Q            BSLS_BSLTESTUTIL_Q   // Quote identifier literally.
#define P            BSLS_BSLTESTUTIL_P   // Print identifier and value.
#define P_           BSLS_BSLTESTUTIL_P_  // P(X) without '\n'.
#define T_           BSLS_BSLTESTUTIL_T_  // Print a tab (w/o newline).
#define L_           BSLS_BSLTESTUTIL_L_  // current Line number

#define RUN_EACH_TYPE BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE

// ============================================================================
//                  NEGATIVE-TEST MACRO ABBREVIATIONS
// ----------------------------------------------------------------------------

#define ASSERT_SAFE_PASS(EXPR) BSLS_ASSERTTEST_ASSERT_SAFE_PASS(EXPR)
#define ASSERT_SAFE_FAIL(EXPR) BSLS_ASSERTTEST_ASSERT_SAFE_FAIL(EXPR)
#define ASSERT_PASS(EXPR)      BSLS_ASSERTTEST_ASSERT_PASS(EXPR)
#define ASSERT_FAIL(EXPR)      BSLS_ASSERTTEST_ASSERT_FAIL(EXPR)
#define ASSERT_OPT_PASS(EXPR)  BSLS_ASSERTTEST_ASSERT_OPT_PASS(EXPR)
#define ASSERT_OPT_FAIL(EXPR)  BSLS_ASSERTTEST_ASSERT_OPT_FAIL(EXPR)

#define ASSERT_SAFE_PASS_RAW(EXPR) BSLS_ASSERTTEST_ASSERT_SAFE_PASS_RAW(EXPR)
#define ASSERT_SAFE_FAIL_RAW(EXPR) BSLS_ASSERTTEST_ASSERT_SAFE_FAIL_RAW(EXPR)
#define ASSERT_PASS_RAW(EXPR)      BSLS_ASSERTTEST_ASSERT_PASS_RAW(EXPR)
#define ASSERT_FAIL_RAW(EXPR)      BSLS_ASSERTTEST_ASSERT_FAIL_RAW(EXPR)
#define ASSERT_OPT_PASS_RAW(EXPR)  BSLS_ASSERTTEST_ASSERT_OPT_PASS_RAW(EXPR)
#define ASSERT_OPT_FAIL_RAW(EXPR)  BSLS_ASSERTTEST_ASSERT_OPT_FAIL_RAW(EXPR)

// ============================================================================
//                  PRINTF FORMAT MACRO ABBREVIATIONS
// ----------------------------------------------------------------------------

#define ZU BSLS_BSLTESTUTIL_FORMAT_ZU

// ============================================================================
//                       GLOBAL TEST VALUES
// ----------------------------------------------------------------------------

bool             verbose;
bool         veryVerbose;
bool     veryVeryVerbose;
bool veryVeryVeryVerbose;

const char VA = 'A';
const char VB = 'B';
const char VC = 'C';
const char VD = 'D';
const char VE = 'E';
const char VF = 'F';
const char VG = 'G';
const char VH = 'H';
const char VI = 'I';
const char VJ = 'J';
const char VK = 'K';

/// All test types have character value type.
const char VL = 'L';

//=============================================================================
//                  GLOBAL TYPEDEFS/CONSTANTS FOR TESTING
//-----------------------------------------------------------------------------

typedef bslstl::StringRef   Obj;

template <class CHAR>
struct TestData
{
    static CHAR const * s_emptyString_p;
    static CHAR const * s_nonEmptyString_p;
    static CHAR const * s_stringValue1_p;
    static CHAR const * s_stringValue2_p;
    static CHAR const * s_maxString_p;
    static CHAR const * s_minString_p;

    enum Enum { k_ENUM_ZERO_VALUE, k_ENUM_MAX = 0xFFFF };
    enum      { k_ZERO_VALUE,      k_MAX      = 0xFFFF };

    static
    const CHAR *emptyStringFunc()
    {
        static CHAR buf[] = { 0 };
        return &buf[0];
    }

    static
    const CHAR *nonEmptyStringFunc()
    {
        const char  origString[] = { "Tangled Up in Blue - Bob Dylan" };
        static CHAR buf[sizeof(origString)];
        for (unsigned uu = 0; uu < sizeof(origString); ++uu) {
            buf[uu] = origString[uu];
        }
        return &buf[0];
    }

    static
    const CHAR *stringValue1Func()
    {
        const char  origString[] = { "abcde" };
        static CHAR buf[sizeof(origString)];
        for (unsigned uu = 0; uu < sizeof(origString); ++uu) {
            buf[uu] = origString[uu];
        }
        return &buf[0];
    }

    static
    const CHAR *stringValue2Func()
    {
        const char  origString[] = { "abcfg" };
        static CHAR buf[sizeof(origString)];
        for (unsigned uu = 0; uu < sizeof(origString); ++uu) {
            buf[uu] = origString[uu];
        }
        return &buf[0];
    }

    static
    const CHAR *maxStringFunc()
    {
        static CHAR buf[2] = { std::numeric_limits<CHAR>::max(), 0 };
        return &buf[0];
    }

    static
    const CHAR *minStringFunc()
    {
        static CHAR buf[2] = { std::numeric_limits<CHAR>::min(), 0 };
        return &buf[0];
    }
};

template <>
char const * TestData<char>::s_emptyString_p = "";
template <>
char const * TestData<char>::s_nonEmptyString_p =
                                              "Tangled Up in Blue - Bob Dylan";
template <>
char const * TestData<char>::s_stringValue1_p = "abcde";
template <>
char const * TestData<char>::s_stringValue2_p = "abcfg";

template <>
wchar_t const * TestData<wchar_t>::s_emptyString_p = L"";
template <>
wchar_t const * TestData<wchar_t>::s_nonEmptyString_p
                                           = L"Tangled Up in Blue - Bob Dylan";
template <>
wchar_t const * TestData<wchar_t>::s_stringValue1_p = L"abcde";
template <>
wchar_t const * TestData<wchar_t>::s_stringValue2_p = L"abcfg";

char const * EMPTY_STRING     = TestData<char>::s_emptyString_p;
char const * NON_EMPTY_STRING = TestData<char>::s_nonEmptyString_p;

//-----------------------------------------------------------------------------
// The following is a sample of Multilingual UTF-8.  It is an amalgamation of
// prose in Chinese, Hindi, French, and Greek.
//     It was discovered that none of this natural language sample contained
// any four byte UTF-8 encodings, so several were added on the end by hand.
//-----------------------------------------------------------------------------

unsigned char utf8MultiLang[] = {
    239, 187, 191, 'C', 'h', 'i', 'n', 'e', 's', 'e', ':',  13,
     10,  13,  10, 228, 184, 173, 229, 141, 142, 228, 186, 186,
    230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 155, 189,
    239, 188, 140, 233, 128, 154, 231, 167, 176, 228, 184, 173,
    229, 155, 189, '[', 230, 179, 168, ' ', '3', ']', 239, 188,
    140, 230, 152, 175, 228, 189, 141, 230, 150, 188, 228, 186,
    154, 230, 180, 178, 230, 157, 177, 233, 131, 168, 227, 128,
    129, 229, 164, 170, 229, 185, 179, 230, 180, 139, 232, 165,
    191, 229, 178, 184, 231, 154, 132, 228, 184, 128, 228, 184,
    170, 231, 164, 190, 228, 188, 154, 228, 184, 187, 228, 185,
    137, 229, 155, 189, 229, 174, 182, 227, 128, 130, 233, 166,
    150, 233, 131, 189, 231, 130, 186, 229, 140, 151, 228, 186,
    172, 227, 128, 130, 229, 133, 182, 233, 153, 134, 229, 156,
    176, 231, 150, 134, 229, 159, 159, 232, 136, 135, 229, 145,
    168, 233, 130, 138, '1', '4', 229, 128, 139, 229, 156, 139,
    229, 174, 182, 230, 142, 165, 229, 163, 164, 239, 188, 140,
    233, 153, 134, 229, 156, 176, 229, 143, 138, 230, 185, 150,
    230, 179, 138, 231, 154, 132, 230, 128, 187, 233, 157, 162,
    231, 169, 141, 231, 186, 166, '9', '6', '0', 232, 144, 172,
    229, 185, 179, 230, 150, 185, 229, 133, 172, 233, 135, 140,
    '[', '1', '1', ']', '[', '1', '2', ']', '[', '1', '3', ']',
    239, 188, 140, 230, 152, 175, 229, 133, 168, 228, 184, 150,
    231, 149, 140, 233, 153, 134, 229, 156, 176, 233, 157, 162,
    231, 167, 175, 231, 172, 172, 228, 186, 140, 229, 164, 167,
    231, 154, 132, 229, 155, 189, 229, 174, 182, 239, 188, 140,
    230, 128, 187, 233, 157, 162, 231, 167, 175, 231, 172, 172,
    228, 184, 137, 230, 136, 150, 231, 172, 172, 229, 155, 155,
    229, 164, 167, 231, 154, 132, 229, 155, 189, 229, 174, 182,
    227, 128, 130, 229, 133, 182, 228, 186, 186, 229, 143, 163,
    232, 182, 133, 233, 129, 142, '1', '3', 229, 132, 132, 239,
    188, 140, 231, 180, 132, 228, 189, 148, 229, 133, 168, 231,
    144, 131, 228, 186, 186, 229, 143, 163, 231, 154, 132, 228,
    186, 148, 229, 136, 134, 228, 185, 139, 228, 184, 128, 239,
    188, 140, 230, 152, 175, 228, 184, 150, 231, 149, 140, 228,
    184, 138, 228, 186, 186, 229, 143, 163, 230, 156, 128, 229,
    164, 154, 231, 154, 132, 229, 156, 139, 229, 174, 182, 227,
    128, 130,  13,  10,  13,  10, 228, 189, 156, 231, 130, 186,
    231, 164, 190, 228, 188, 154, 228, 184, 187, 228, 185, 137,
    229, 155, 189, 229, 174, 182, 239, 188, 140, 228, 184, 173,
    232, 143, 175, 228, 186, 186, 230, 176, 145, 229, 133, 177,
    229, 146, 140, 229, 156, 139, 228, 187, 165, 233, 169, 172,
    229, 133, 139, 230, 128, 157, 229, 136, 151, 229, 174, 129,
    228, 184, 187, 228, 185, 137, 231, 130, 186, 230, 132, 143,
    232, 173, 152, 229, 189, 162, 230, 133, 139, 239, 188, 140,
    228, 190, 157, 228, 184, 173, 229, 156, 139, 231, 137, 185,
    232, 137, 178, 231, 164, 190, 230, 156, 131, 228, 184, 187,
    231, 190, 169, 231, 144, 134, 232, 174, 186, 230, 140, 135,
    229, 176, 142, 230, 148, 191, 228, 186, 139, 239, 188, 140,
    229, 185, 182, 231, 148, 177, 230, 134, 178, 230, 179, 149,
    230, 137, 128, 232, 179, 166, 228, 186, 136, 228, 184, 173,
    229, 155, 189, 229, 133, 177, 228, 186, 167, 229, 133, 154,
    229, 159, 183, 230, 148, 191, 239, 188, 140, 229, 174, 158,
    232, 161, 140, 228, 184, 173, 229, 155, 189, 229, 133, 177,
    228, 186, 167, 229, 133, 154, 233, 162, 134, 229, 175, 188,
    231, 154, 132, 229, 164, 154, 229, 133, 154, 229, 144, 136,
    228, 189, 156, 229, 146, 140, 230, 148, 191, 230, 178, 187,
    229, 141, 143, 229, 149, 134, 229, 136, 182, 229, 186, 166,
    '[', '1', '4', ']', 227, 128, 130, '1', '9', '4', '9', 229,
    185, 180, '1', '0', 230, 156, 136, '1', 230, 151, 165, 231,
    154, 132, 229, 188, 128, 229, 155, 189, 229, 164, 167, 229,
    133, 184, 228, 184, 173, 239, 188, 140, 228, 184, 173, 229,
    141, 142, 228, 186, 186, 230, 176, 145, 229, 133, 177, 229,
    146, 140, 229, 155, 189, 228, 184, 173, 229, 164, 174, 228,
    186, 186, 230, 176, 145, 230, 148, 191, 229, 186, 156, 230,
    173, 163, 229, 188, 143, 229, 174, 163, 229, 145, 138, 230,
    136, 144, 231, 171, 139, '[', 230, 179, 168, ' ', '4', ']',
    227, 128, 130, 229, 133, 168, 229, 156, 139, 229, 138, 131,
    229, 136, 134, 231, 130, 186, '2', '3', 229, 128, 139, 231,
    156, 129, 239, 188, 136, 229, 133, 182, 228, 184, 173, 229,
    185, 182, 230, 178, 161, 230, 156, 137, 229, 175, 185, 229,
    143, 176, 230, 185, 190, 231, 156, 129, 229, 133, 168, 233,
    131, 168, 228, 184, 142, 231, 166, 143, 229, 187, 186, 231,
    156, 129, 227, 128, 129, 230, 181, 183, 229, 141, 151, 231,
    156, 129, 233, 131, 168, 229, 136, 134, 229, 156, 176, 229,
    140, 186, 229, 174, 158, 233, 153, 133, 231, 174, 161, 232,
    190, 150, 239, 188, 137, 227, 128, 129, '5', 229, 128, 139,
    232, 135, 170, 230, 178, 187, 229, 141, 128, 227, 128, 129,
    '4', 229, 128, 139, 231, 155, 180, 232, 190, 150, 229, 184,
    130, 229, 146, 140, '2', 229, 128, 139, 231, 137, 185, 229,
    136, 165, 232, 161, 140, 230, 148, 191, 229, 140, 186, 239,
    188, 136, 229, 141, 179, 233, 166, 153, 230, 184, 175, 232,
    136, 135, 230, 190, 179, 233, 150, 128, 239, 188, 137, 239,
    188, 140, 231, 156, 129, 231, 186, 167, 228, 186, 186, 230,
    176, 145, 230, 148, 191, 229, 186, 156, 229, 143, 151, 229,
    155, 189, 229, 138, 161, 233, 153, 162, 233, 162, 134, 229,
    175, 188, 239, 188, 140, 231, 137, 185, 229, 136, 165, 232,
    161, 140, 230, 148, 191, 229, 141, 128, 229, 137, 135, 230,
    160, 185, 230, 147, 154, 228, 184, 128, 229, 156, 139, 229,
    133, 169, 229, 136, 182, 230, 148, 191, 231, 173, 150, 229,
    175, 166, 232, 161, 140, 233, 171, 152, 229, 186, 166, 232,
    135, 170, 230, 178, 187, 227, 128, 130, 229, 133, 168, 229,
    155, 189, 232, 183, 168, 232, 182, 138, 228, 186, 148, 228,
    184, 170, 229, 156, 176, 231, 144, 134, 230, 151, 182, 229,
    140, 186, 239, 188, 140, 228, 189, 134, 229, 157, 135, 228,
    189, 191, 231, 148, 168, 228, 184, 173, 229, 156, 139, 230,
    168, 153, 230, 186, 150, 230, 153, 130, 233, 150, 147, 239,
    188, 136, 229, 141, 179, 'U', 'T', 'C', '+', '8', 239, 188,
    137, 227, 128, 130,  13,  10,  13,  10, 228, 184, 173, 232,
    143, 175, 228, 186, 186, 230, 176, 145, 229, 133, 177, 229,
    146, 140, 229, 156, 139, 230, 152, 175, 229, 164, 154, 230,
    176, 145, 230, 151, 143, 229, 155, 189, 229, 174, 182, 239,
    188, 140, 229, 133, 182, 228, 184, 173, 230, 177, 137, 230,
    151, 143, 228, 189, 148, 231, 184, 189, 228, 186, 186, 229,
    143, 163, 231, 154, 132, '9', '1', '.', '5', '9', '%', 239,
    188, 140, 229, 133, 182, 233, 164, 152, '5', '5', 228, 184,
    170, 230, 176, 145, 230, 151, 143, 231, 130, 186, 229, 176,
    145, 230, 149, 176, 230, 176, 145, 230, 151, 143, 239, 188,
    140, 229, 155, 189, 229, 174, 182, 232, 170, 141, 229, 174,
    154, 231, 154, 132, '5', '6', 229, 128, 139, 230, 176, 145,
    230, 151, 143, 229, 144, 136, 231, 167, 176, 226, 128, 156,
    228, 184, 173, 229, 141, 142, 230, 176, 145, 230, 151, 143,
    226, 128, 157, 227, 128, 130, 228, 184, 173, 229, 141, 142,
    228, 186, 186, 230, 176, 145, 229, 133, 177, 229, 146, 140,
    229, 155, 189, 230, 156, 137, '2', '4', 231, 167, 141, 230,
    176, 145, 230, 151, 143, 230, 150, 135, 229, 173, 151, 239,
    188, 140, 229, 133, 171, 229, 141, 129, 229, 164, 154, 231,
    167, 141, 230, 176, 145, 230, 151, 143, 232, 175, 173, 232,
    168, 128, 227, 128, 130, 228, 184, 173, 229, 141, 142, 228,
    186, 186, 230, 176, 145, 229, 133, 177, 229, 146, 140, 229,
    155, 189, 230, 178, 161, 230, 156, 137, 230, 152, 142, 231,
    161, 174, 232, 167, 132, 229, 174, 154, 231, 154, 132, 229,
    155, 189, 229, 174, 182, 232, 175, 173, 232, 168, 128, 239,
    188, 140, 228, 187, 165, 230, 177, 137, 232, 175, 173, 230,
    153, 174, 233, 128, 154, 232, 175, 157, 229, 146, 140, 232,
    167, 132, 232, 140, 131, 231, 174, 128, 229, 140, 150, 230,
    177, 137, 229, 173, 151, 228, 184, 186, 226, 128, 156, 229,
    155, 189, 229, 174, 182, 233, 128, 154, 231, 148, 168, 232,
    175, 173, 232, 168, 128, 230, 150, 135, 229, 173, 151, 226,
    128, 157, '[', 230, 179, 168, ' ', '5', ']', 227, 128, 130,
    228, 184, 173, 229, 155, 189, 228, 188, 160, 231, 187, 159,
    228, 184, 138, 230, 152, 175, 228, 187, 165, 231, 165, 150,
    229, 133, 136, 228, 191, 161, 228, 187, 176, 228, 184, 186,
    228, 184, 187, 231, 154, 132, 229, 155, 189, 229, 174, 182,
    239, 188, 140, 229, 185, 182, 229, 133, 183, 230, 156, 137,
    229, 132, 146, 233, 135, 138, 233, 129, 147, 228, 184, 137,
    230, 149, 153, 229, 144, 136, 230, 181, 129, 231, 154, 132,
    229, 174, 151, 230, 149, 153, 228, 191, 161, 228, 187, 176,
    228, 188, 160, 231, 187, 159, 229, 146, 140, 231, 137, 185,
    231, 130, 185, 239, 188, 140, 229, 144, 140, 230, 151, 182,
    229, 173, 152, 229, 156, 168, 229, 133, 182, 229, 174, 131,
    229, 164, 154, 231, 167, 141, 229, 174, 151, 230, 149, 153,
    227, 128, 130, 228, 184, 173, 229, 141, 142, 228, 186, 186,
    230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 155, 189,
    229, 144, 142, 239, 188, 140, 229, 174, 152, 230, 150, 185,
    229, 165, 137, 232, 161, 140, 230, 151, 160, 231, 165, 158,
    232, 174, 186, 239, 188, 140, 229, 133, 182, 229, 144, 142,
    230, 155, 190, 229, 143, 145, 229, 138, 168, 231, 154, 132,
    230, 150, 135, 229, 140, 150, 229, 164, 167, 233, 157, 169,
    229, 145, 189, 229, 175, 185, 229, 144, 132, 231, 167, 141,
    229, 174, 151, 230, 149, 153, 233, 128, 160, 230, 136, 144,
    228, 184, 165, 233, 135, 141, 231, 160, 180, 229, 157, 143,
    239, 188, 140, 231, 155, 180, 229, 136, 176, 230, 148, 185,
    233, 157, 169, 229, 188, 128, 230, 148, 190, 229, 144, 142,
    230, 137, 141, 230, 156, 137, 230, 137, 128, 232, 189, 172,
    229, 143, 152, 227, 128, 130, 229, 189, 147, 228, 187, 138,
    228, 184, 173, 229, 155, 189, 230, 148, 191, 229, 186, 156,
    229, 175, 185, 229, 174, 151, 230, 149, 153, 228, 184, 142,
    228, 188, 160, 231, 187, 159, 228, 186, 139, 231, 137, 169,
    233, 135, 135, 229, 143, 150, 228, 191, 157, 230, 138, 164,
    231, 154, 132, 230, 128, 129, 229, 186, 166, 227, 128, 130,
     13,  10,  13,  10, 228, 184, 173, 229, 141, 142, 228, 186,
    186, 230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 155,
    189, 230, 152, 175, 229, 155, 189, 233, 153, 133, 231, 164,
    190, 228, 188, 154, 231, 154, 132, 233, 135, 141, 232, 166,
    129, 228, 184, 128, 229, 145, 152, 239, 188, 140, 228, 185,
    159, 230, 152, 175, 228, 188, 151, 229, 164, 154, 230, 173,
    163, 229, 188, 143, 229, 146, 140, 233, 157, 158, 230, 173,
    163, 229, 188, 143, 231, 154, 132, 229, 164, 154, 232, 190,
    185, 231, 187, 132, 231, 187, 135, 231, 154, 132, 230, 136,
    144, 229, 145, 152, 239, 188, 140, 229, 140, 133, 230, 139,
    172, 232, 129, 148, 229, 144, 136, 229, 155, 189, 227, 128,
    129, 228, 184, 150, 231, 149, 140, 232, 180, 184, 230, 152,
    147, 231, 187, 132, 231, 187, 135, 227, 128, 129, 228, 186,
    154, 229, 164, 170, 231, 187, 143, 229, 144, 136, 231, 187,
    132, 231, 187, 135, 227, 128, 129, 233, 135, 145, 231, 160,
    150, 229, 155, 155, 229, 155, 189, 227, 128, 129, 228, 184,
    138, 230, 181, 183, 229, 144, 136, 228, 189, 156, 231, 187,
    132, 231, 187, 135, 229, 146, 140, '2', '0', 229, 155, 189,
    233, 155, 134, 229, 155, 162, 231, 173, 137, 239, 188, 140,
    228, 184, 186, 232, 129, 148, 229, 144, 136, 229, 155, 189,
    229, 174, 137, 229, 133, 168, 231, 144, 134, 228, 186, 139,
    228, 188, 154, 229, 184, 184, 228, 187, 187, 231, 144, 134,
    228, 186, 139, 229, 155, 189, 227, 128, 129, 228, 184, 150,
    231, 149, 140, 231, 172, 172, 228, 186, 140, 229, 164, 167,
    231, 187, 143, 230, 181, 142, 228, 189, 147, 239, 188, 140,
    230, 152, 175, 228, 184, 150, 231, 149, 140, 231, 172, 172,
    228, 184, 128, 229, 164, 167, 229, 135, 186, 229, 143, 163,
    229, 156, 139, 227, 128, 129, 228, 184, 150, 231, 149, 140,
    231, 172, 172, 228, 186, 140, 229, 164, 167, 233, 128, 178,
    229, 143, 163, 229, 156, 139, 239, 188, 140, 230, 147, 129,
    230, 156, 137, 230, 156, 128, 229, 164, 154, 231, 154, 132,
    229, 164, 150, 230, 177, 135, 229, 132, 178, 229, 130, 153,
    239, 188, 140, 230, 156, 128, 228, 184, 176, 229, 175, 140,
    231, 154, 132, 228, 184, 150, 231, 149, 140, 230, 150, 135,
    229, 140, 150, 233, 129, 151, 228, 186, 167, 239, 188, 140,
    228, 186, 166, 230, 152, 175, 228, 184, 150, 231, 149, 140,
    228, 184, 138, 231, 187, 143, 230, 181, 142, 230, 136, 144,
    233, 149, 183, 230, 156, 128, 229, 191, 171, 231, 154, 132,
    229, 156, 139, 229, 174, 182, 228, 185, 139, 228, 184, 128,
    227, 128, 130, 229, 143, 166, 229, 164, 150, 239, 188, 140,
    228, 184, 173, 229, 155, 189, 230, 139, 165, 230, 156, 137,
    228, 184, 150, 231, 149, 140, 228, 184, 138, 231, 142, 176,
    229, 189, 185, 229, 163, 171, 229, 133, 181, 230, 156, 128,
    229, 164, 154, 231, 154, 132, 229, 134, 155, 233, 152, 159,
    239, 188, 155, 229, 134, 155, 228, 186, 139, 229, 188, 128,
    230, 148, 175, 228, 184, 150, 231, 149, 140, 231, 172, 172,
    228, 186, 140, 239, 188, 140, 230, 139, 165, 230, 156, 137,
    230, 160, 184, 230, 173, 166, 229, 153, 168, 239, 188, 140,
    229, 185, 182, 229, 133, 183, 229, 164, 135, 229, 143, 145,
    229, 176, 132, 229, 141, 171, 230, 152, 159, 227, 128, 129,
    232, 175, 149, 233, 170, 140, 229, 158, 139, 231, 169, 186,
    233, 151, 180, 231, 171, 153, 229, 146, 140, 230, 156, 136,
    231, 144, 131, 229, 143, 138, 230, 183, 177, 231, 169, 186,
    230, 142, 162, 230, 181, 139, 229, 153, 168, 231, 154, 132,
    232, 131, 189, 229, 138, 155, 239, 188, 155, '2', '0', '0',
    '3', 229, 185, 180, 239, 188, 140, 228, 184, 173, 229, 155,
    189, 230, 136, 144, 228, 184, 186, 228, 184, 150, 231, 149,
    140, 231, 172, 172, 228, 184, 137, 228, 184, 170, 232, 135,
    170, 228, 184, 187, 230, 136, 144, 229, 138, 159, 229, 143,
    145, 229, 176, 132, 232, 189, 189, 228, 186, 186, 232, 136,
    170, 229, 164, 169, 229, 153, 168, 231, 154, 132, 229, 155,
    189, 229, 174, 182, 227, 128, 130, 228, 184, 173, 229, 155,
    189, 228, 186, 166, 230, 152, 175, 230, 189, 156, 229, 156,
    168, 232, 182, 133, 231, 186, 167, 229, 164, 167, 229, 155,
    189, 228, 185, 139, 228, 184, 128, 239, 188, 140, 232, 162,
    171, 232, 174, 164, 228, 184, 186, 230, 152, 175, 228, 184,
    139, 228, 184, 128, 228, 189, 141, 232, 182, 133, 231, 186,
    167, 229, 164, 167, 229, 155, 189, 231, 154, 132, 230, 156,
    137, 229, 138, 155, 229, 128, 153, 233, 128, 137, 228, 186,
    186, 227, 128, 130,  13,  10,  13,  10, 228, 184, 173, 229,
    141, 142, 228, 186, 186, 230, 176, 145, 229, 133, 177, 229,
    146, 140, 229, 155, 189, 231, 154, 132, 230, 173, 163, 229,
    188, 143, 229, 155, 189, 229, 144, 141, 228, 186, 142, '1',
    '9', '4', '9', 229, 185, 180, 231, 148, 177, 228, 184, 173,
    229, 156, 139, 228, 186, 186, 230, 176, 145, 230, 148, 191,
    230, 178, 187, 229, 141, 148, 229, 149, 134, 230, 156, 131,
    232, 173, 176, 231, 177, 140, 229, 130, 153, 230, 156, 131,
    232, 173, 176, 231, 162, 186, 229, 174, 154, 239, 188, 140,
    229, 189, 147, 229, 136, 157, 230, 155, 190, 229, 138, 160,
    232, 168, 187, 227, 128, 140, 231, 176, 161, 231, 168, 177,
    239, 188, 154, 228, 184, 173, 232, 143, 175, 230, 176, 145,
    229, 156, 139, 227, 128, 141, 239, 188, 140, 228, 189, 134,
    229, 143, 184, 229, 190, 146, 231, 190, 142, 229, 160, 130,
    231, 173, 137, 230, 176, 145, 228, 184, 187, 229, 133, 154,
    230, 180, 190, 228, 186, 186, 229, 163, 171, 232, 174, 164,
    228, 184, 186, 230, 150, 176, 228, 184, 173, 229, 155, 189,
    229, 186, 148, 231, 161, 174, 231, 171, 139, 230, 150, 176,
    229, 155, 189, 229, 144, 141, 239, 188, 140, 228, 187, 165,
    231, 164, 186, 228, 184, 164, 230, 172, 161, 233, 157, 169,
    229, 145, 189, 231, 154, 132, 230, 160, 185, 230, 156, 172,
    230, 132, 143, 228, 185, 137, 228, 184, 141, 229, 144, 140,
    '[', '1', '5', ']', 227, 128, 130, 229, 155, 160, 230, 173,
    164, 231, 155, 180, 232, 135, 179, '9', 230, 156, 136, '2',
    '7', 230, 151, 165, 230, 148, 191, 229, 141, 148, 229, 133,
    168, 233, 171, 148, 230, 156, 131, 232, 173, 176, 232, 161,
    168, 230, 177, 186, 233, 128, 154, 233, 129, 142, 228, 184,
    173, 229, 164, 174, 228, 186, 186, 230, 176, 145, 230, 148,
    191, 229, 186, 156, 231, 181, 132, 231, 185, 148, 230, 179,
    149, 230, 153, 130, 239, 188, 140, 230, 173, 163, 229, 188,
    143, 232, 173, 176, 230, 177, 186, 229, 142, 187, 233, 153,
    164, 230, 173, 164, 229, 138, 160, 232, 168, 187, '[', '1',
    '6', ']', 227, 128, 130,  13,  10,  13,  10, 229, 156, 168,
    229, 133, 168, 233, 131, 168, 229, 156, 139, 233, 154, 155,
    229, 160, 180, 229, 144, 136, 239, 188, 140, 228, 184, 173,
    232, 143, 175, 228, 186, 186, 230, 176, 145, 229, 133, 177,
    229, 146, 140, 229, 156, 139, 228, 184, 128, 232, 136, 172,
    231, 176, 161, 231, 168, 177, 231, 130, 186, 228, 184, 173,
    229, 156, 139, 239, 188, 140, 230, 156, 137, 230, 151, 182,
    229, 128, 153, 228, 185, 159, 229, 155, 160, 229, 133, 182,
    230, 137, 128, 229, 164, 132, 229, 156, 176, 231, 144, 134,
    228, 189, 141, 231, 189, 174, 232, 128, 140, 232, 162, 171,
    231, 167, 176, 228, 184, 186, 228, 184, 173, 229, 155, 189,
    229, 164, 167, 233, 153, 134, 227, 128, 130, 229, 156, 168,
    228, 184, 173, 229, 156, 139, 229, 156, 139, 229, 133, 167,
    239, 188, 140, 231, 149, 182, '1', '9', '4', '9', 229, 185,
    180, 229, 137, 141, 231, 154, 132, 228, 184, 173, 232, 143,
    175, 230, 176, 145, 229, 156, 139, 232, 136, 135, '1', '9',
    '4', '9', 229, 185, 180, 229, 190, 140, 231, 154, 132, 228,
    184, 173, 232, 143, 175, 228, 186, 186, 230, 176, 145, 229,
    133, 177, 229, 146, 140, 229, 156, 139, 229, 129, 154, 229,
    176, 141, 230, 175, 148, 230, 136, 150, 230, 156, 137, 230,
    173, 164, 230, 182, 181, 230, 140, 135, 230, 153, 130, 239,
    188, 140, 229, 137, 141, 232, 128, 133, 229, 184, 184, 232,
    162, 171, 231, 168, 177, 231, 130, 186, 232, 136, 138, 228,
    184, 173, 229, 156, 139, 239, 188, 136, 228, 186, 166, 231,
    168, 177, 232, 136, 138, 231, 164, 190, 230, 156, 131, 239,
    188, 137, 239, 188, 140, 232, 128, 140, 229, 190, 140, 232,
    128, 133, 229, 137, 135, 229, 184, 184, 232, 162, 171, 231,
    168, 177, 231, 130, 186, 230, 150, 176, 228, 184, 173, 229,
    156, 139, 227, 128, 130, 231, 155, 174, 229, 137, 141, 239,
    188, 140, 228, 184, 173, 232, 143, 175, 228, 186, 186, 230,
    176, 145, 229, 133, 177, 229, 146, 140, 229, 156, 139, 232,
    170, 141, 231, 130, 186, 228, 184, 173, 232, 143, 175, 230,
    176, 145, 229, 156, 139, 229, 183, 178, 232, 162, 171, 229,
    133, 182, 229, 143, 150, 228, 187, 163, 239, 188, 140, 228,
    184, 173, 232, 143, 175, 230, 176, 145, 229, 156, 139, 230,
    148, 191, 229, 186, 156, 229, 137, 135, 228, 184, 141, 230,
    137, 191, 232, 170, 141, 228, 184, 173, 232, 143, 175, 228,
    186, 186, 230, 176, 145, 229, 133, 177, 229, 146, 140, 229,
    156, 139, 231, 154, 132, 230, 173, 163, 231, 181, 177, 230,
    128, 167, 239, 188, 140, 231, 149, 182, 229, 156, 168, 228,
    184, 173, 229, 156, 139, 229, 164, 167, 233, 153, 184, 231,
    154, 132, 228, 184, 173, 232, 143, 175, 228, 186, 186, 230,
    176, 145, 229, 133, 177, 229, 146, 140, 229, 156, 139, 230,
    148, 191, 229, 186, 156, 232, 136, 135, 229, 156, 168, 229,
    143, 176, 231, 129, 163, 231, 154, 132, 228, 184, 173, 232,
    143, 175, 230, 176, 145, 229, 156, 139, 230, 148, 191, 229,
    186, 156, 229, 129, 154, 229, 176, 141, 230, 175, 148, 230,
    136, 150, 230, 156, 137, 230, 173, 164, 230, 182, 181, 230,
    140, 135, 230, 153, 130, 239, 188, 140, 229, 137, 141, 232,
    128, 133, 229, 184, 184, 232, 162, 171, 229, 190, 140, 232,
    128, 133, 231, 168, 177, 231, 130, 186, 229, 140, 151, 228,
    186, 172, 231, 149, 182, 229, 177, 128, 227, 128, 129, 229,
    164, 167, 233, 153, 184, 231, 149, 182, 229, 177, 128, 227,
    128, 129, 228, 184, 173, 229, 133, 177, 231, 149, 182, 229,
    177, 128, 227, 128, 129, 228, 184, 173, 229, 156, 139, 229,
    164, 167, 233, 153, 184, 230, 136, 150, 229, 164, 167, 233,
    153, 184, '[', '1', '7', ']', 239, 188, 140, 229, 190, 140,
    232, 128, 133, 229, 184, 184, 232, 162, 171, 229, 137, 141,
    232, 128, 133, 231, 168, 177, 231, 130, 186, 229, 143, 176,
    231, 129, 163, 231, 149, 182, 229, 177, 128, 227, 128, 129,
    229, 143, 176, 229, 140, 151, 231, 149, 182, 229, 177, 128,
    230, 136, 150, 229, 143, 176, 231, 129, 163, '[', '1', '8',
    ']', 227, 128, 130, 232, 136, 135, 230, 184, 175, 230, 190,
    179, 229, 156, 176, 229, 141, 128, 228, 184, 166, 231, 148,
    168, 230, 153, 130, 229, 137, 135, 231, 168, 177, 231, 130,
    186, 228, 184, 173, 229, 156, 139, 229, 133, 167, 229, 156,
    176, 227, 128, 129, 229, 133, 167, 229, 156, 176, '[', '1',
    '9', ']', 227, 128, 130,  13,  10,  13,  10, 231, 149, 182,
    228, 184, 173, 229, 156, 139, 229, 164, 167, 233, 153, 184,
    231, 154, 132, 228, 184, 173, 232, 143, 175, 228, 186, 186,
    230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 156, 139,
    230, 148, 191, 229, 186, 156, 232, 136, 135, 229, 156, 168,
    229, 143, 176, 231, 129, 163, 231, 154, 132, 228, 184, 173,
    232, 143, 175, 230, 176, 145, 229, 156, 139, 230, 148, 191,
    229, 186, 156, 229, 129, 154, 229, 176, 141, 230, 175, 148,
    230, 136, 150, 229, 141, 128, 233, 154, 148, 228, 187, 139,
    231, 180, 185, 230, 153, 130, 239, 188, 140, 233, 128, 154,
    229, 184, 184, 230, 142, 161, 231, 148, 168, 229, 156, 176,
    231, 144, 134, 229, 144, 141, 232, 169, 158, 227, 128, 140,
    228, 184, 173, 229, 156, 139, 229, 164, 167, 233, 153, 184,
    227, 128, 141, 239, 188, 136, 'C', 'h', 'i', 'n', 'a', ' ',
    'M', 'a', 'i', 'n', 'l', 'a', 'n', 'd', 239, 188, 137, 230,
    136, 150, 228, 184, 173, 229, 155, 189, 239, 188, 136, 'C',
    'h', 'i', 'n', 'a', 239, 188, 137, 229, 129, 154, 231, 130,
    186, 228, 184, 173, 232, 143, 175, 228, 186, 186, 230, 176,
    145, 229, 133, 177, 229, 146, 140, 229, 156, 139, 231, 154,
    132, 231, 176, 161, 231, 168, 177, 239, 188, 140, 229, 176,
    141, 230, 150, 188, 228, 184, 173, 232, 143, 175, 230, 176,
    145, 229, 156, 139, 229, 137, 135, 231, 176, 161, 231, 168,
    177, 231, 130, 186, 228, 184, 173, 232, 143, 175, 229, 143,
    176, 229, 140, 151, 239, 188, 136, 'C', 'h', 'i', 'n', 'e',
    's', 'e', ' ', 'T', 'a', 'i', 'p', 'e', 'i', 239, 188, 137,
    230, 136, 150, 229, 143, 176, 231, 129, 163, 239, 188, 136,
    'T', 'a', 'i', 'w', 'a', 'n', 239, 188, 137, 227, 128, 130,
    232, 128, 140, 229, 143, 176, 230, 185, 190, 231, 154, 132,
    229, 170, 146, 228, 189, 147, 229, 137, 135, 229, 184, 184,
    228, 189, 191, 231, 148, 168, 227, 128, 140, 228, 184, 173,
    229, 133, 177, 227, 128, 141, 227, 128, 129, 227, 128, 140,
    229, 164, 167, 233, 153, 184, 229, 156, 176, 229, 141, 128,
    227, 128, 141, 227, 128, 129, 227, 128, 140, 229, 164, 167,
    233, 153, 184, 227, 128, 141, 230, 136, 150, 227, 128, 140,
    228, 184, 173, 229, 155, 189, 227, 128, 141, 230, 157, 165,
    228, 189, 156, 231, 130, 186, 228, 184, 173, 232, 143, 175,
    228, 186, 186, 230, 176, 145, 229, 133, 177, 229, 146, 140,
    229, 156, 139, 231, 154, 132, 231, 176, 161, 231, 168, 177,
    227, 128, 130, 233, 166, 153, 230, 184, 175, 233, 131, 168,
    229, 136, 134, 229, 170, 146, 233, 171, 148, 228, 185, 159,
    230, 156, 137, 228, 189, 191, 231, 148, 168, 227, 128, 140,
    228, 184, 173, 229, 156, 139, 227, 128, 141, 229, 146, 140,
    227, 128, 140, 228, 184, 173, 229, 133, 177, 227, 128, 141,
    228, 190, 134, 230, 140, 135, 228, 187, 163, 228, 184, 173,
    229, 156, 139, 229, 164, 167, 233, 153, 184, 227, 128, 130,
     13,  10,  13,  10, '1', '9', '4', '9', 229, 185, 180, 239,
    188, 140, 230, 173, 183, 230, 153, 130, 228, 184, 137, 229,
    185, 180, 231, 154, 132, 229, 156, 139, 229, 133, 177, 229,
    133, 167, 230, 136, 176, 228, 184, 187, 232, 166, 129, 230,
    136, 176, 229, 189, 185, 231, 181, 144, 230, 157, 159, 239,
    188, 140, 228, 184, 173, 229, 156, 139, 229, 133, 177, 231,
    148, 162, 233, 187, 168, 230, 137, 128, 233, 160, 152, 229,
    176, 142, 231, 154, 132, 228, 184, 173, 229, 156, 139, 228,
    186, 186, 230, 176, 145, 232, 167, 163, 230, 148, 190, 232,
    187, 141, 230, 136, 176, 229, 139, 157, 228, 186, 134, 228,
    184, 173, 229, 156, 139, 229, 156, 139, 230, 176, 145, 233,
    187, 168, 230, 137, 128, 233, 160, 152, 229, 176, 142, 231,
    154, 132, 228, 184, 173, 232, 143, 175, 230, 176, 145, 229,
    156, 139, 229, 155, 189, 232, 187, 141, '[', 230, 179, 168,
    ' ', '6', ']', 239, 188, 140, 228, 184, 166, 229, 183, 178,
    233, 128, 144, 230, 188, 184, 230, 142, 167, 229, 136, 182,
    228, 186, 134, 228, 184, 173, 229, 156, 139, 229, 164, 167,
    233, 153, 184, 229, 164, 167, 233, 131, 168, 229, 136, 134,
    231, 156, 129, 228, 187, 189, 229, 146, 140, 229, 156, 176,
    229, 140, 186, 227, 128, 130,  13,  10,  13,  10, 229, 144,
    140, 229, 185, 180, '9', 230, 156, 136, '2', '1', 230, 151,
    165, 232, 135, 179, '9', 230, 156, 136, '3', '0', 230, 151,
    165, 239, 188, 140, 231, 182, 147, 233, 129, 142, 230, 149,
    184, 230, 156, 136, 231, 154, 132, 231, 177, 140, 229, 130,
    153, 239, 188, 140, 228, 184, 173, 229, 156, 139, 228, 186,
    186, 230, 176, 145, 230, 148, 191, 230, 178, 187, 229, 141,
    148, 229, 149, 134, 230, 156, 131, 232, 173, 176, 231, 172,
    172, 228, 184, 128, 229, 177, 134, 229, 133, 168, 233, 171,
    148, 230, 156, 131, 232, 173, 176, 229, 156, 168, 229, 140,
    151, 229, 185, 179, 229, 143, 172, 233, 150, 139, 227, 128,
    130, '9', 230, 156, 136, '2', '1', 230, 151, 165, 239, 188,
    140, 228, 184, 173, 229, 156, 139, 228, 186, 186, 230, 176,
    145, 230, 148, 191, 230, 178, 187, 229, 141, 148, 229, 149,
    134, 230, 156, 131, 232, 173, 176, 231, 172, 172, 228, 184,
    128, 229, 177, 134, 229, 133, 168, 233, 171, 148, 230, 156,
    131, 232, 173, 176, 230, 173, 163, 229, 188, 143, 229, 174,
    163, 229, 184, 131, 230, 136, 144, 231, 171, 139, 228, 184,
    173, 229, 141, 142, 228, 186, 186, 230, 176, 145, 229, 133,
    177, 229, 146, 140, 229, 155, 189, '[', '2', '0', ']', 227,
    128, 130, 228, 188, 154, 232, 174, 174, 233, 128, 154, 233,
    129, 142, 228, 186, 134, 227, 128, 138, 228, 184, 173, 229,
    156, 139, 228, 186, 186, 230, 176, 145, 230, 148, 191, 230,
    178, 187, 229, 141, 148, 229, 149, 134, 230, 156, 131, 232,
    173, 176, 231, 181, 132, 231, 185, 148, 230, 179, 149, 227,
    128, 139, 227, 128, 129, 227, 128, 138, 228, 184, 173, 232,
    143, 175, 228, 186, 186, 230, 176, 145, 229, 133, 177, 229,
    146, 140, 229, 156, 139, 228, 184, 173, 229, 164, 174, 228,
    186, 186, 230, 176, 145, 230, 148, 191, 229, 186, 156, 231,
    181, 132, 231, 185, 148, 230, 179, 149, 227, 128, 139, 229,
    146, 140, 229, 133, 183, 230, 156, 137, 232, 135, 168, 230,
    153, 130, 230, 134, 178, 230, 179, 149, 230, 128, 167, 232,
    179, 170, 231, 154, 132, 227, 128, 138, 228, 184, 173, 229,
    156, 139, 228, 186, 186, 230, 176, 145, 230, 148, 191, 230,
    178, 187, 229, 141, 148, 229, 149, 134, 230, 156, 131, 232,
    173, 176, 229, 133, 177, 229, 144, 140, 231, 182, 177, 233,
    160, 152, 227, 128, 139, 239, 188, 140, 230, 177, 186, 229,
    174, 154, 228, 187, 165, 229, 140, 151, 229, 185, 179, 231,
    130, 186, 233, 166, 150, 233, 131, 189, 228, 184, 166, 230,
    148, 185, 229, 144, 141, 231, 136, 178, 229, 140, 151, 228,
    186, 172, 227, 128, 129, 228, 187, 165, 229, 133, 172, 229,
    133, 131, 231, 180, 128, 229, 185, 180, 227, 128, 129, 228,
    187, 165, 231, 190, 169, 229, 139, 135, 232, 187, 141, 233,
    128, 178, 232, 161, 140, 230, 155, 178, 231, 130, 186, 228,
    187, 163, 229, 156, 139, 230, 173, 140, 227, 128, 129, 228,
    187, 165, 228, 186, 148, 230, 152, 159, 231, 180, 133, 230,
    151, 151, 231, 130, 186, 229, 156, 139, 230, 151, 151, 239,
    188, 140, 233, 128, 154, 233, 129, 142, 228, 186, 134, 231,
    148, 177, '1', '8', '0', 228, 186, 186, 231, 181, 132, 230,
    136, 144, 231, 154, 132, 228, 184, 173, 229, 156, 139, 228,
    186, 186, 230, 176, 145, 230, 148, 191, 230, 178, 187, 229,
    141, 148, 229, 149, 134, 230, 156, 131, 232, 173, 176, 231,
    172, 172, 228, 184, 128, 229, 177, 134, 229, 133, 168, 229,
    156, 139, 229, 167, 148, 229, 147, 161, 230, 156, 131, 229,
    144, 141, 229, 150, 174, 239, 188, 140, 228, 184, 166, 233,
    129, 184, 232, 136, 137, 230, 175, 155, 230, 190, 164, 230,
    157, 177, 231, 130, 186, 228, 184, 173, 229, 164, 174, 228,
    186, 186, 230, 176, 145, 230, 148, 191, 229, 186, 156, 228,
    184, 187, 229, 184, 173, 227, 128, 129, 230, 156, 177, 229,
    190, 183, 227, 128, 129, 229, 136, 152, 229, 176, 145, 229,
    165, 135, 227, 128, 129, 229, 174, 139, 229, 186, 134, 233,
    190, 132, 227, 128, 129, 230, 157, 142, 230, 181, 142, 230,
    183, 177, 227, 128, 129, 229, 188, 160, 230, 190, 156, 227,
    128, 129, 233, 171, 152, 229, 178, 151, 231, 130, 186, 229,
    137, 175, 228, 184, 187, 229, 184, 173, 227, 128, 129, 229,
    143, 166, 229, 164, 150, '5', '6', 228, 189, 141, 231, 130,
    186, 228, 184, 173, 229, 164, 174, 228, 186, 186, 230, 176,
    145, 230, 148, 191, 229, 186, 156, 229, 167, 148, 229, 147,
    161, 227, 128, 130, '1', '0', 230, 156, 136, '1', 230, 151,
    165, 229, 188, 128, 229, 155, 189, 229, 164, 167, 229, 133,
    184, 229, 156, 168, 229, 140, 151, 228, 186, 172, 228, 184,
    190, 232, 161, 140, 239, 188, 140, 230, 175, 155, 230, 190,
    164, 230, 157, 177, 229, 156, 168, 229, 164, 169, 229, 174,
    137, 233, 151, 168, 229, 159, 142, 230, 165, 188, 229, 174,
    163, 229, 145, 138, 228, 184, 173, 229, 141, 142, 228, 186,
    186, 230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 155,
    189, 228, 184, 173, 229, 164, 174, 228, 186, 186, 230, 176,
    145, 230, 148, 191, 229, 186, 156, 230, 136, 144, 231, 171,
    139, 239, 188, 155, '1', '2', 230, 156, 136, '7', 230, 151,
    165, 239, 188, 140, 228, 184, 173, 232, 143, 175, 230, 176,
    145, 229, 156, 139, 230, 148, 191, 229, 186, 156, 230, 173,
    163, 229, 188, 143, 231, 148, 177, 229, 155, 155, 229, 183,
    157, 231, 156, 129, 230, 136, 144, 233, 131, 189, 229, 184,
    130, 233, 129, 183, 229, 190, 128, 229, 143, 176, 230, 185,
    190, 231, 156, 129, 229, 143, 176, 229, 140, 151, 229, 184,
    130, 239, 188, 140, 228, 184, 166, 231, 185, 188, 231, 186,
    140, 231, 181, 177, 230, 178, 187, 229, 143, 176, 231, 129,
    163, 230, 156, 172, 229, 179, 182, 229, 143, 138, 230, 190,
    142, 230, 185, 150, 227, 128, 129, 233, 131, 168, 229, 136,
    134, 231, 166, 143, 229, 187, 186, 233, 155, 162, 229, 179,
    182, 227, 128, 129, 228, 184, 156, 230, 178, 153, 231, 190,
    164, 229, 178, 155, 227, 128, 129, 229, 164, 170, 229, 185,
    179, 229, 178, 155, 231, 173, 137, 232, 135, 179, 228, 187,
    138, 227, 128, 130, 232, 135, 179, 230, 173, 164, 239, 188,
    140, 228, 184, 173, 229, 156, 139, 230, 173, 183, 229, 143,
    178, 228, 184, 138, 230, 150, 188, 230, 181, 183, 229, 179,
    189, 229, 133, 169, 229, 178, 184, 229, 136, 134, 230, 178,
    187, 231, 154, 132, 230, 148, 191, 230, 178, 187, 230, 160,
    188, 229, 177, 128, 230, 173, 163, 229, 188, 143, 229, 189,
    162, 230, 136, 144, 227, 128, 130,  13,  10,  13,  10, 'H',
    'i', 'n', 'd', 'i', ':',  13,  10,  13,  10, 224, 164, 173,
    224, 164, 190, 224, 164, 176, 224, 164, 164, ',', ' ', 224,
    164, 170, 224, 165, 140, 224, 164, 176, 224, 164, 190, 224,
    164, 163, 224, 164, 191, 224, 164, 149, ' ', 224, 164, 156,
    224, 164, 174, 224, 165, 141, 224, 164, 172, 224, 165, 130,
    224, 164, 166, 224, 165, 141, 224, 164, 181, 224, 165, 128,
    224, 164, 170, ',', ' ', 224, 164, 134, 224, 164, 167, 224,
    165, 129, 224, 164, 168, 224, 164, 191, 224, 164, 149, ' ',
    224, 164, 166, 224, 164, 149, 224, 165, 141, 224, 164, 183,
    224, 164, 191, 224, 164, 163, ' ', 224, 164, 143, 224, 164,
    182, 224, 164, 191, 224, 164, 175, 224, 164, 190, ' ', 224,
    164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164, 184,
    224, 165, 141, 224, 164, 165, 224, 164, 191, 224, 164, 164,
    ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164,
    164, 224, 165, 128, 224, 164, 175, ' ', 224, 164, 137, 224,
    164, 170, 224, 164, 174, 224, 164, 185, 224, 164, 190, 224,
    164, 166, 224, 165, 141, 224, 164, 181, 224, 165, 128, 224,
    164, 170, ' ', 224, 164, 149, 224, 164, 190, ' ', 224, 164,
    184, 224, 164, 172, 224, 164, 184, 224, 165, 135, ' ', 224,
    164, 172, 224, 164, 161, 224, 164, 188, 224, 164, 190, ' ',
    224, 164, 166, 224, 165, 135, 224, 164, 182, ' ', 224, 164,
    185, 224, 165, 136, 224, 165, 164, ' ', 224, 164, 173, 224,
    164, 190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 149,
    224, 164, 190, ' ', 224, 164, 173, 224, 165, 140, 224, 164,
    151, 224, 165, 139, 224, 164, 178, 224, 164, 191, 224, 164,
    149, ' ', 224, 164, 171, 224, 165, 136, 224, 164, 178, 224,
    164, 190, 224, 164, 181, ' ', 224, 165, 174, 224, 165, 166,
    ' ', 224, 165, 170,'\'', ' ', 224, 164, 184, 224, 165, 135,
    ' ', 224, 165, 169, 224, 165, 173, 224, 165, 166, ' ', 224,
    165, 172,'\'', ' ', 224, 164, 137, 224, 164, 164, 224, 165,
    141, 224, 164, 164, 224, 164, 176, 224, 165, 128, ' ', 224,
    164, 133, 224, 164, 149, 224, 165, 141, 224, 164, 183, 224,
    164, 190, 224, 164, 130, 224, 164, 182, ' ', 224, 164, 164,
    224, 164, 149, ' ', 224, 164, 164, 224, 164, 165, 224, 164,
    190, ' ', 224, 165, 172, 224, 165, 174, 224, 165, 166, ' ',
    224, 165, 173,'\'', ' ', 224, 164, 184, 224, 165, 135, ' ',
    224, 165, 175, 224, 165, 173, 224, 165, 166, ' ', 224, 165,
    168, 224, 165, 171,'\'', 224, 164, 170, 224, 165, 130, 224,
    164, 176, 224, 165, 141, 224, 164, 181, 224, 165, 128, ' ',
    224, 164, 166, 224, 165, 135, 224, 164, 182, 224, 164, 190,
    224, 164, 168, 224, 165, 141, 224, 164, 164, 224, 164, 176,
    ' ', 224, 164, 164, 224, 164, 149, ' ', 224, 164, 185, 224,
    165, 136, 224, 165, 164, ' ', 224, 164, 173, 224, 164, 190,
    224, 164, 176, 224, 164, 164, ' ', 224, 164, 149, 224, 164,
    190, ' ', 224, 164, 181, 224, 164, 191, 224, 164, 184, 224,
    165, 141, 224, 164, 164, 224, 164, 190, 224, 164, 176, ' ',
    224, 164, 137, 224, 164, 164, 224, 165, 141, 224, 164, 164,
    224, 164, 176, ' ', 224, 164, 184, 224, 165, 135, ' ', 224,
    164, 166, 224, 164, 149, 224, 165, 141, 224, 164, 183, 224,
    164, 191, 224, 164, 163, ' ', 224, 164, 164, 224, 164, 149,
    ' ', 224, 164, 149, 224, 164, 191, '.', ' ', 224, 164, 174,
    224, 165, 128, '.', ' ', 224, 164, 148, 224, 164, 176, ' ',
    224, 164, 170, 224, 165, 130, 224, 164, 176, 224, 165, 141,
    224, 164, 181, ' ', 224, 164, 184, 224, 165, 135, ' ', 224,
    164, 170, 224, 164, 182, 224, 165, 141, 224, 164, 154, 224,
    164, 191, 224, 164, 174, ' ', 224, 164, 164, 224, 164, 149,
    ' ', 224, 165, 168, ',', 224, 165, 175, 224, 165, 169, 224,
    165, 169, ' ', 224, 164, 149, 224, 164, 191, '.', ' ', 224,
    164, 174, 224, 165, 128, '.', ' ', 224, 164, 185, 224, 165,
    136, 224, 165, 164, ' ', 224, 164, 173, 224, 164, 190, 224,
    164, 176, 224, 164, 164, ' ', 224, 164, 149, 224, 165, 128,
    ' ', 224, 164, 184, 224, 164, 174, 224, 165, 129, 224, 164,
    166, 224, 165, 141, 224, 164, 176, ' ', 224, 164, 164, 224,
    164, 159, ' ', 224, 164, 176, 224, 165, 135, 224, 164, 150,
    224, 164, 190, ' ', 224, 165, 173, 224, 165, 171, 224, 165,
    167, 224, 165, 172, '.', 224, 165, 172, ' ', 224, 164, 149,
    224, 164, 191, 224, 164, 178, 224, 165, 139, 224, 164, 174,
    224, 165, 128, 224, 164, 159, 224, 164, 176, ' ', 224, 164,
    178, 224, 164, 174, 224, 165, 141, 224, 164, 172, 224, 165,
    128, ' ', 224, 164, 185, 224, 165, 136, 224, 165, 164, ' ',
    224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164, 164,
    ',', ' ', 224, 164, 173, 224, 165, 140, 224, 164, 151, 224,
    165, 139, 224, 164, 178, 224, 164, 191, 224, 164, 149, ' ',
    224, 164, 166, 224, 165, 131, 224, 164, 183, 224, 165, 141,
    224, 164, 159, 224, 164, 191, ' ', 224, 164, 184, 224, 165,
    135, ' ', 224, 164, 181, 224, 164, 191, 224, 164, 182, 224,
    165, 141, 224, 164, 181, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 184, 224, 164, 190, 224, 164,
    164, 224, 164, 181, 224, 164, 190, 224, 164, 129, ' ', 224,
    164, 184, 224, 164, 172, 224, 164, 184, 224, 165, 135, ' ',
    224, 164, 172, 224, 164, 161, 224, 164, 188, 224, 164, 190,
    ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 156, 224,
    164, 168, 224, 164, 184, 224, 164, 129, 224, 164, 150, 224,
    165, 141, 224, 164, 175, 224, 164, 190, ' ', 224, 164, 149,
    224, 165, 135, ' ', 224, 164, 166, 224, 165, 131, 224, 164,
    183, 224, 165, 141, 224, 164, 159, 224, 164, 191, 224, 164,
    149, 224, 165, 139, 224, 164, 163, ' ', 224, 164, 184, 224,
    165, 135, ' ', 224, 164, 166, 224, 165, 130, 224, 164, 184,
    224, 164, 176, 224, 164, 190, ' ', 224, 164, 184, 224, 164,
    172, ' ', 224, 164, 184, 224, 165, 135, ' ', 224, 164, 172,
    224, 164, 161, 224, 164, 188, 224, 164, 190, ' ', 224, 164,
    166, 224, 165, 135, 224, 164, 182, ' ', 224, 164, 185, 224,
    165, 136, 224, 165, 164, ' ', 224, 164, 173, 224, 164, 190,
    224, 164, 176, 224, 164, 164, ' ', 224, 164, 149, 224, 165,
    135, ' ', 224, 164, 170, 224, 164, 182, 224, 165, 141, 224,
    164, 154, 224, 164, 191, 224, 164, 174, ' ', 224, 164, 174,
    224, 165, 135, 224, 164, 130, ' ', 224, 164, 170, 224, 164,
    190, 224, 164, 149, 224, 164, 191, 224, 164, 184, 224, 165,
    141, 224, 164, 164, 224, 164, 190, 224, 164, 168, ',', ' ',
    224, 164, 137, 224, 164, 164, 224, 165, 141, 224, 164, 164,
    224, 164, 176, '-', 224, 164, 170, 224, 165, 130, 224, 164,
    176, 224, 165, 141, 224, 164, 181, ' ', 224, 164, 174, 224,
    165, 135, 224, 164, 130, ' ', 224, 164, 154, 224, 165, 128,
    224, 164, 168, ',', ' ', 224, 164, 168, 224, 165, 135, 224,
    164, 170, 224, 164, 190, 224, 164, 178, ',', ' ', 224, 164,
    148, 224, 164, 176, ' ', 224, 164, 173, 224, 165, 130, 224,
    164, 159, 224, 164, 190, 224, 164, 168, ' ', 224, 164, 148,
    224, 164, 176, ' ', 224, 164, 170, 224, 165, 130, 224, 164,
    176, 224, 165, 141, 224, 164, 181, ' ', 224, 164, 174, 224,
    165, 135, 224, 164, 130, ' ', 224, 164, 172, 224, 164, 190,
    224, 164, 130, 224, 164, 151, 224, 165, 141, 224, 164, 178,
    224, 164, 190, 224, 164, 166, 224, 165, 135, 224, 164, 182,
    ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 174, 224,
    165, 141, 224, 164, 175, 224, 164, 190, 224, 164, 168, 224,
    165, 141, 224, 164, 174, 224, 164, 190, 224, 164, 176, ' ',
    224, 164, 166, 224, 165, 135, 224, 164, 182, ' ', 224, 164,
    184, 224, 165, 141, 224, 164, 165, 224, 164, 191, 224, 164,
    164, ' ', 224, 164, 185, 224, 165, 136, 224, 164, 130, 224,
    165, 164, ' ', 224, 164, 185, 224, 164, 191, 224, 164, 168,
    224, 165, 141, 224, 164, 166, ' ', 224, 164, 174, 224, 164,
    185, 224, 164, 190, 224, 164, 184, 224, 164, 190, 224, 164,
    151, 224, 164, 176, ' ', 224, 164, 174, 224, 165, 135, 224,
    164, 130, ' ', 224, 164, 135, 224, 164, 184, 224, 164, 149,
    224, 165, 135, ' ', 224, 164, 166, 224, 164, 149, 224, 165,
    141, 224, 164, 183, 224, 164, 191, 224, 164, 163, ' ', 224,
    164, 170, 224, 164, 182, 224, 165, 141, 224, 164, 154, 224,
    164, 191, 224, 164, 174, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 174, 224, 164, 190, 224, 164,
    178, 224, 164, 166, 224, 165, 128, 224, 164, 181, ',', ' ',
    224, 164, 166, 224, 164, 149, 224, 165, 141, 224, 164, 183,
    224, 164, 191, 224, 164, 163, ' ', 224, 164, 174, 224, 165,
    135, 224, 164, 130, ' ', 224, 164, 182, 224, 165, 141, 224,
    164, 176, 224, 165, 128, 224, 164, 178, 224, 164, 130, 224,
    164, 149, 224, 164, 190, ' ', 224, 164, 148, 224, 164, 176,
    ' ', 224, 164, 166, 224, 164, 149, 224, 165, 141, 224, 164,
    183, 224, 164, 191, 224, 164, 163, '-', 224, 164, 170, 224,
    165, 130, 224, 164, 176, 224, 165, 141, 224, 164, 181, ' ',
    224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164,
    135, 224, 164, 130, 224, 164, 161, 224, 165, 139, 224, 164,
    168, 224, 165, 135, 224, 164, 182, 224, 164, 191, 224, 164,
    175, 224, 164, 190, ' ', 224, 164, 185, 224, 165, 136, 224,
    164, 130, 224, 165, 164, ' ', 224, 164, 137, 224, 164, 164,
    224, 165, 141, 224, 164, 164, 224, 164, 176, '-', 224, 164,
    170, 224, 164, 182, 224, 165, 141, 224, 164, 154, 224, 164,
    191, 224, 164, 174, ' ', 224, 164, 174, 224, 165, 135, 224,
    164, 130, ' ', 224, 164, 133, 224, 164, 171, 224, 164, 188,
    224, 164, 151, 224, 164, 190, 224, 164, 168, 224, 164, 191,
    224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 164, 190,
    224, 164, 168, ' ', 224, 164, 149, 224, 165, 135, ' ', 224,
    164, 184, 224, 164, 190, 224, 164, 165, ' ', 224, 164, 173,
    224, 164, 190, 224, 164, 176, 224, 164, 164, ' ', 224, 164,
    149, 224, 165, 128, ' ', 224, 164, 184, 224, 165, 128, 224,
    164, 174, 224, 164, 190, ' ', 224, 164, 185, 224, 165, 136,
    224, 165, 164, ' ', 224, 164, 135, 224, 164, 184, 224, 164,
    149, 224, 165, 135, ' ', 224, 164, 137, 224, 164, 164, 224,
    165, 141, 224, 164, 164, 224, 164, 176, ' ', 224, 164, 174,
    224, 165, 135, 224, 164, 130, ' ', 224, 164, 185, 224, 164,
    191, 224, 164, 174, 224, 164, 190, 224, 164, 178, 224, 164,
    175, ' ', 224, 164, 170, 224, 164, 176, 224, 165, 141, 224,
    164, 181, 224, 164, 164, ' ', 224, 164, 185, 224, 165, 136,
    ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 166, 224,
    164, 149, 224, 165, 141, 224, 164, 183, 224, 164, 191, 224,
    164, 163, ' ', 224, 164, 174, 224, 165, 135, 224, 164, 130,
    ' ', 224, 164, 185, 224, 164, 191, 224, 164, 168, 224, 165,
    141, 224, 164, 166, ' ', 224, 164, 174, 224, 164, 185, 224,
    164, 190, 224, 164, 184, 224, 164, 190, 224, 164, 151, 224,
    164, 176, ' ', 224, 164, 185, 224, 165, 136, 224, 165, 164,
    ' ', 224, 164, 170, 224, 165, 130, 224, 164, 176, 224, 165,
    141, 224, 164, 181, ' ', 224, 164, 174, 224, 165, 135, 224,
    164, 130, ' ', 224, 164, 172, 224, 164, 130, 224, 164, 151,
    224, 164, 190, 224, 164, 178, ' ', 224, 164, 149, 224, 165,
    128, ' ', 224, 164, 150, 224, 164, 190, 224, 164, 161, 224,
    164, 188, 224, 165, 128, ' ', 224, 164, 185, 224, 165, 136,
    ' ', 224, 164, 164, 224, 164, 165, 224, 164, 190, ' ', 224,
    164, 170, 224, 164, 182, 224, 165, 141, 224, 164, 154, 224,
    164, 191, 224, 164, 174, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 133, 224, 164, 176, 224, 164,
    172, ' ', 224, 164, 184, 224, 164, 190, 224, 164, 151, 224,
    164, 176, 224, 164, 184, 224, 164, 174, 224, 165, 129, 224,
    164, 166, 224, 165, 141, 224, 164, 176, ' ', 224, 164, 185,
    224, 165, 136, 224, 164, 130, ' ', 224, 165, 164, ' ', 224,
    164, 173, 224, 164, 190, 224, 164, 176, 224, 164, 164, ' ',
    224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164,
    149, 224, 164, 136, ' ', 224, 164, 172, 224, 164, 161, 224,
    164, 188, 224, 165, 128, ' ', 224, 164, 168, 224, 164, 166,
    224, 164, 191, 224, 164, 175, 224, 164, 190, 224, 164, 129,
    ' ', 224, 164, 185, 224, 165, 136, 224, 164, 130, ' ', 224,
    165, 164, ' ', 224, 164, 151, 224, 164, 130, 224, 164, 151,
    224, 164, 190, ' ', 224, 164, 168, 224, 164, 166, 224, 165,
    128, ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224,
    164, 164, 224, 165, 128, 224, 164, 175, ' ', 224, 164, 184,
    224, 164, 130, 224, 164, 184, 224, 165, 141, 224, 164, 149,
    224, 165, 131, 224, 164, 164, 224, 164, 191, ' ', 224, 164,
    174, 224, 165, 135, 224, 164, 130, ' ', 224, 164, 133, 224,
    164, 164, 224, 165, 141, 224, 164, 175, 224, 164, 130, 224,
    164, 164, ' ', 224, 164, 170, 224, 164, 181, 224, 164, 191,
    224, 164, 164, 224, 165, 141, 224, 164, 176, ' ', 224, 164,
    174, 224, 164, 190, 224, 164, 168, 224, 165, 128, ' ', 224,
    164, 156, 224, 164, 190, 224, 164, 164, 224, 165, 128, ' ',
    224, 164, 185, 224, 165, 136, 224, 165, 164, ' ', 224, 164,
    133, 224, 164, 168, 224, 165, 141, 224, 164, 175, ' ', 224,
    164, 172, 224, 164, 161, 224, 164, 188, 224, 165, 128, ' ',
    224, 164, 168, 224, 164, 166, 224, 164, 191, 224, 164, 175,
    224, 164, 190, 224, 164, 129, ' ', 224, 164, 184, 224, 164,
    191, 224, 164, 168, 224, 165, 141, 224, 164, 167, 224, 165,
    129, ',', ' ', 224, 164, 168, 224, 164, 176, 224, 165, 141,
    224, 164, 174, 224, 164, 166, 224, 164, 190, ',', ' ', 224,
    164, 172, 224, 165, 141, 224, 164, 176, 224, 164, 185, 224,
    165, 141, 224, 164, 174, 224, 164, 170, 224, 165, 129, 224,
    164, 164, 224, 165, 141, 224, 164, 176, ',', ' ', 224, 164,
    175, 224, 164, 174, 224, 165, 129, 224, 164, 168, 224, 164,
    190, ',', ' ', 224, 164, 151, 224, 165, 139, 224, 164, 166,
    224, 164, 190, 224, 164, 181, 224, 164, 176, 224, 165, 128,
    ',', ' ', 224, 164, 149, 224, 164, 190, 224, 164, 181, 224,
    165, 135, 224, 164, 176, 224, 165, 128, ',', ' ', 224, 164,
    149, 224, 165, 131, 224, 164, 183, 224, 165, 141, 224, 164,
    163, 224, 164, 190, ',', ' ', 224, 164, 154, 224, 164, 174,
    224, 165, 141, 224, 164, 172, 224, 164, 178, ',', ' ', 224,
    164, 184, 224, 164, 164, 224, 164, 178, 224, 164, 156, ',',
    ' ', 224, 164, 181, 224, 165, 141, 224, 164, 175, 224, 164,
    190, 224, 164, 184, ' ', 224, 164, 134, 224, 164, 166, 224,
    164, 191, ' ', 224, 164, 185, 224, 165, 136, 224, 164, 130,
    224, 165, 164,  13,  10,  13,  10, 224, 164, 175, 224, 164,
    185, ' ', 224, 164, 181, 224, 164, 191, 224, 164, 182, 224,
    165, 141, 224, 164, 181, ' ', 224, 164, 149, 224, 164, 190,
    ' ', 224, 164, 184, 224, 164, 172, 224, 164, 184, 224, 165,
    135, ' ', 224, 164, 172, 224, 164, 161, 224, 164, 188, 224,
    164, 190, ' ', 224, 164, 178, 224, 165, 139, 224, 164, 149,
    224, 164, 164, 224, 164, 130, 224, 164, 164, 224, 165, 141,
    224, 164, 176, ' ', 224, 164, 185, 224, 165, 136, 224, 165,
    164, ' ', 224, 164, 175, 224, 164, 185, 224, 164, 190, 224,
    164, 129, ' ', 224, 165, 169, 224, 165, 166, 224, 165, 166,
    ' ', 224, 164, 184, 224, 165, 135, ' ', 224, 164, 133, 224,
    164, 167, 224, 164, 191, 224, 164, 149, ' ', 224, 164, 173,
    224, 164, 190, 224, 164, 183, 224, 164, 190, 224, 164, 143,
    224, 164, 129, ' ', 224, 164, 172, 224, 165, 139, 224, 164,
    178, 224, 165, 128, ' ', 224, 164, 156, 224, 164, 190, 224,
    164, 164, 224, 165, 128, ' ', 224, 164, 185, 224, 165, 136,
    224, 164, 130, ' ', '[', '1', ']', 224, 165, 164, ' ', 224,
    164, 175, 224, 164, 185, ' ', 224, 164, 181, 224, 164, 191,
    224, 164, 182, 224, 165, 141, 224, 164, 181, ' ', 224, 164,
    149, 224, 165, 128, ' ', 224, 164, 149, 224, 165, 129, 224,
    164, 155, ' ', 224, 164, 170, 224, 165, 141, 224, 164, 176,
    224, 164, 190, 224, 164, 154, 224, 165, 128, 224, 164, 168,
    224, 164, 164, 224, 164, 174, ' ', 224, 164, 184, 224, 164,
    173, 224, 165, 141, 224, 164, 175, 224, 164, 164, 224, 164,
    190, 224, 164, 147, 224, 164, 130, ' ', 224, 164, 149, 224,
    165, 128, ' ', 224, 164, 156, 224, 164, 168, 224, 164, 168,
    224, 165, 128, ' ', 224, 164, 176, 224, 164, 185, 224, 164,
    190, ' ', 224, 164, 185, 224, 165, 136, ' ', 224, 164, 156,
    224, 165, 136, 224, 164, 184, 224, 165, 135, ' ', '-', ' ',
    224, 164, 184, 224, 164, 191, 224, 164, 168, 224, 165, 141,
    224, 164, 167, 224, 165, 129, ' ', 224, 164, 152, 224, 164,
    190, 224, 164, 159, 224, 165, 128, ' ', 224, 164, 184, 224,
    164, 173, 224, 165, 141, 224, 164, 175, 224, 164, 164, 224,
    164, 190, ',', ' ', 224, 164, 148, 224, 164, 176, ' ', 224,
    164, 174, 224, 164, 185, 224, 164, 164, 224, 165, 141, 224,
    164, 181, 224, 164, 170, 224, 165, 130, 224, 164, 176, 224,
    165, 141, 224, 164, 163, ' ', 224, 164, 144, 224, 164, 164,
    224, 164, 191, 224, 164, 185, 224, 164, 190, 224, 164, 184,
    224, 164, 191, 224, 164, 149, ' ', 224, 164, 181, 224, 165,
    141, 224, 164, 175, 224, 164, 190, 224, 164, 170, 224, 164,
    190, 224, 164, 176, ' ', 224, 164, 170, 224, 164, 165, 224,
    165, 139, 224, 164, 130, ' ', 224, 164, 149, 224, 164, 190,
    ' ', 224, 164, 133, 224, 164, 173, 224, 164, 191, 224, 164,
    168, 224, 165, 141, 224, 164, 168, ' ', 224, 164, 133, 224,
    164, 130, 224, 164, 151, ' ', 224, 164, 173, 224, 165, 128,
    '.', ' ', 224, 164, 181, 224, 164, 191, 224, 164, 182, 224,
    165, 141, 224, 164, 181, ' ', 224, 164, 149, 224, 165, 135,
    ' ', 224, 164, 154, 224, 164, 190, 224, 164, 176, ' ', 224,
    164, 170, 224, 165, 141, 224, 164, 176, 224, 164, 174, 224,
    165, 129, 224, 164, 150, ' ', 224, 164, 167, 224, 164, 176,
    224, 165, 141, 224, 164, 174, ' ', ':', ' ', 224, 164, 184,
    224, 164, 168, 224, 164, 190, 224, 164, 164, 224, 164, 168,
    '-', 224, 164, 185, 224, 164, 191, 224, 164, 168, 224, 165,
    141, 224, 164, 166, 224, 165, 130, ',', ' ', 224, 164, 172,
    224, 165, 140, 224, 164, 166, 224, 165, 141, 224, 164, 167,
    ',', ' ', 224, 164, 156, 224, 165, 136, 224, 164, 168, ' ',
    224, 164, 164, 224, 164, 165, 224, 164, 190, ' ', 224, 164,
    184, 224, 164, 191, 224, 164, 150, ' ', 224, 164, 173, 224,
    164, 190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 174,
    224, 165, 135, 224, 164, 130, ' ', 224, 164, 185, 224, 165,
    128, ' ', 224, 164, 156, 224, 164, 168, 224, 165, 141, 224,
    164, 174, 224, 165, 135, ' ', 224, 164, 148, 224, 164, 176,
    ' ', 224, 164, 181, 224, 164, 191, 224, 164, 149, 224, 164,
    184, 224, 164, 191, 224, 164, 164, ' ', 224, 164, 185, 224,
    165, 129, 224, 164, 143, 224, 165, 164,  13,  10,  13,  10,
    224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164, 164,
    ' ', 224, 164, 173, 224, 165, 140, 224, 164, 151, 224, 165,
    139, 224, 164, 178, 224, 164, 191, 224, 164, 149, ' ', 224,
    164, 149, 224, 165, 141, 224, 164, 183, 224, 165, 135, 224,
    164, 164, 224, 165, 141, 224, 164, 176, 224, 164, 171, 224,
    164, 178, ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164,
    134, 224, 164, 167, 224, 164, 190, 224, 164, 176, ' ', 224,
    164, 170, 224, 164, 176, ' ', 224, 164, 181, 224, 164, 191,
    224, 164, 182, 224, 165, 141, 224, 164, 181, ' ', 224, 164,
    149, 224, 164, 190, ' ', 224, 164, 184, 224, 164, 190, 224,
    164, 164, 224, 164, 181, 224, 164, 190, 224, 164, 129, ' ',
    224, 164, 184, 224, 164, 172, 224, 164, 184, 224, 165, 135,
    ' ', 224, 164, 172, 224, 164, 161, 224, 164, 188, 224, 164,
    190, ' ', 224, 164, 176, 224, 164, 190, 224, 164, 183, 224,
    165, 141, 224, 164, 159, 224, 165, 141, 224, 164, 176, ' ',
    224, 164, 185, 224, 165, 136, 224, 165, 164, ' ', 224, 164,
    173, 224, 164, 190, 224, 164, 176, 224, 164, 164, ' ', 224,
    164, 149, 224, 165, 128, ' ', 224, 164, 176, 224, 164, 190,
    224, 164, 156, 224, 164, 167, 224, 164, 190, 224, 164, 168,
    224, 165, 128, ' ', 224, 164, 168, 224, 164, 136, ' ', 224,
    164, 166, 224, 164, 191, 224, 164, 178, 224, 165, 141, 224,
    164, 178, 224, 165, 128, ' ', 224, 164, 185, 224, 165, 136,
    224, 165, 164, ' ', 224, 164, 173, 224, 164, 190, 224, 164,
    176, 224, 164, 164, ' ', 224, 164, 149, 224, 165, 135, ' ',
    224, 164, 133, 224, 164, 168, 224, 165, 141, 224, 164, 175,
    ' ', 224, 164, 172, 224, 164, 161, 224, 164, 188, 224, 165,
    135, ' ', 224, 164, 174, 224, 164, 185, 224, 164, 190, 224,
    164, 168, 224, 164, 151, 224, 164, 176, ' ', 224, 164, 174,
    224, 165, 129, 224, 164, 174, 224, 165, 141, 224, 164, 172,
    224, 164, 136, ' ', '(', 224, 164, 172, 224, 164, 174, 224,
    165, 141, 224, 164, 172, 224, 164, 136, ')', ',', ' ', 224,
    164, 149, 224, 165, 139, 224, 164, 178, 224, 164, 149, 224,
    164, 190, 224, 164, 164, 224, 164, 190, ' ', '(', 224, 164,
    149, 224, 164, 178, 224, 164, 149, 224, 164, 164, 224, 165,
    141, 224, 164, 164, 224, 164, 190, ')', ' ', 224, 164, 148,
    224, 164, 176, ' ', 224, 164, 154, 224, 165, 135, 224, 164,
    168, 224, 165, 141, 224, 164, 168, 224, 164, 136, ' ', '(',
    224, 164, 174, 224, 164, 166, 224, 165, 141, 224, 164, 176,
    224, 164, 190, 224, 164, 184, ')', ' ', 224, 164, 185, 224,
    165, 136, 224, 164, 130, 224, 165, 164, ' ', 224, 165, 167,
    224, 165, 175, 224, 165, 170, 224, 165, 173, ' ', 224, 164,
    174, 224, 165, 135, 224, 164, 130, ' ', 224, 164, 184, 224,
    165, 141, 224, 164, 181, 224, 164, 164, 224, 164, 130, 224,
    164, 164, 224, 165, 141, 224, 164, 176, 224, 164, 164, 224,
    164, 190, ' ', 224, 164, 170, 224, 165, 141, 224, 164, 176,
    224, 164, 190, 224, 164, 170, 224, 165, 141, 224, 164, 164,
    224, 164, 191, ' ', 224, 164, 184, 224, 165, 135, ' ', 224,
    164, 170, 224, 165, 130, 224, 164, 176, 224, 165, 141, 224,
    164, 181, ' ', 224, 164, 172, 224, 165, 141, 224, 164, 176,
    224, 164, 191, 224, 164, 159, 224, 164, 191, 224, 164, 182,
    ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164,
    164, ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164, 176,
    224, 165, 130, 224, 164, 170, ' ', 224, 164, 174, 224, 165,
    135, 224, 164, 130, ' ', 224, 164, 172, 224, 165, 141, 224,
    164, 176, 224, 164, 191, 224, 164, 159, 224, 164, 191, 224,
    164, 182, ' ', 224, 164, 184, 224, 164, 190, 224, 164, 174,
    224, 165, 141, 224, 164, 176, 224, 164, 190, 224, 164, 156,
    224, 165, 141, 224, 164, 175, ' ', 224, 164, 149, 224, 165,
    135, ' ', 224, 164, 170, 224, 165, 141, 224, 164, 176, 224,
    164, 174, 224, 165, 129, 224, 164, 150, ' ', 224, 164, 133,
    224, 164, 130, 224, 164, 151, ' ', 224, 164, 173, 224, 164,
    190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 168, 224,
    165, 135, ' ', 224, 164, 181, 224, 164, 191, 224, 164, 151,
    224, 164, 164, ' ', 224, 165, 168, 224, 165, 166, ' ', 224,
    164, 181, 224, 164, 176, 224, 165, 141, 224, 164, 183, ' ',
    224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164,
    184, 224, 164, 190, 224, 164, 176, 224, 165, 141, 224, 164,
    165, 224, 164, 149, ' ', 224, 164, 170, 224, 165, 141, 224,
    164, 176, 224, 164, 151, 224, 164, 164, 224, 164, 191, ' ',
    224, 164, 149, 224, 165, 128, ' ', 224, 164, 185, 224, 165,
    136, ',', ' ', 224, 164, 181, 224, 164, 191, 224, 164, 182,
    224, 165, 135, 224, 164, 183, ' ', 224, 164, 176, 224, 165,
    130, 224, 164, 170, ' ', 224, 164, 184, 224, 165, 135, ' ',
    224, 164, 134, 224, 164, 176, 224, 165, 141, 224, 164, 165,
    224, 164, 191, 224, 164, 149, ' ', 224, 164, 148, 224, 164,
    176, ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224,
    164, 164, 224, 165, 128, 224, 164, 175, ' ', 224, 164, 184,
    224, 165, 135, 224, 164, 168, 224, 164, 190, ' ', 224, 164,
    143, 224, 164, 149, ' ', 224, 164, 149, 224, 165, 141, 224,
    164, 183, 224, 165, 135, 224, 164, 164, 224, 165, 141, 224,
    164, 176, 224, 165, 128, 224, 164, 175, ' ', 224, 164, 182,
    224, 164, 149, 224, 165, 141, 224, 164, 164, 224, 164, 191,
    ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 181, 224,
    164, 191, 224, 164, 182, 224, 165, 141, 224, 164, 181, 224,
    164, 181, 224, 165, 141, 224, 164, 175, 224, 164, 190, 224,
    164, 170, 224, 164, 149, ' ', 224, 164, 182, 224, 164, 149,
    224, 165, 141, 224, 164, 164, 224, 164, 191, ' ', 224, 164,
    185, 224, 165, 136, 224, 165, 164, ' ', 224, 164, 173, 224,
    164, 190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 181,
    224, 164, 191, 224, 164, 182, 224, 165, 141, 224, 164, 181,
    ' ', 224, 164, 149, 224, 165, 128, ' ', 224, 164, 166, 224,
    164, 184, 224, 164, 181, 224, 165, 128, 224, 164, 130, ' ',
    224, 164, 184, 224, 164, 172, 224, 164, 184, 224, 165, 135,
    ' ', 224, 164, 172, 224, 164, 161, 224, 164, 188, 224, 165,
    128, ' ', 224, 164, 133, 224, 164, 176, 224, 165, 141, 224,
    164, 165, 224, 164, 181, 224, 165, 141, 224, 164, 175, 224,
    164, 181, 224, 164, 184, 224, 165, 141, 224, 164, 165, 224,
    164, 190, ' ', 224, 164, 185, 224, 165, 136, 224, 165, 164,
    ' ', 224, 164, 185, 224, 164, 190, 224, 164, 178, ' ', 224,
    164, 149, 224, 165, 135, ' ', 224, 164, 181, 224, 164, 176,
    224, 165, 141, 224, 164, 183, 224, 165, 139, 224, 164, 130,
    ' ', 224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224,
    164, 173, 224, 164, 190, 224, 164, 176, 224, 164, 164, ' ',
    224, 164, 149, 224, 165, 128, ' ', 224, 164, 133, 224, 164,
    176, 224, 165, 141, 224, 164, 165, 224, 164, 181, 224, 165,
    141, 224, 164, 175, 224, 164, 181, 224, 164, 184, 224, 165,
    141, 224, 164, 165, 224, 164, 190, ' ', 224, 164, 168, 224,
    165, 135, ' ', 224, 164, 172, 224, 164, 185, 224, 165, 129,
    224, 164, 164, ' ', 224, 164, 170, 224, 165, 141, 224, 164,
    176, 224, 164, 151, 224, 164, 164, 224, 164, 191, ' ', 224,
    164, 149, 224, 165, 128, ' ', 224, 164, 185, 224, 165, 136,
    ',', ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 164,
    224, 164, 190, 224, 164, 156, 224, 164, 188, 224, 164, 190,
    ' ', 224, 164, 184, 224, 165, 141, 224, 164, 165, 224, 164,
    191, 224, 164, 164, 224, 164, 191, ' ', 224, 164, 174, 224,
    165, 135, 224, 164, 130, ' ', 224, 164, 173, 224, 164, 190,
    224, 164, 176, 224, 164, 164, ' ', 224, 164, 181, 224, 164,
    191, 224, 164, 182, 224, 165, 141, 224, 164, 181, ' ', 224,
    164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164, 164,
    224, 165, 128, 224, 164, 184, 224, 164, 176, 224, 165, 135,
    '-', 224, 164, 154, 224, 165, 140, 224, 164, 165, 224, 165,
    135, ' ', 224, 164, 184, 224, 165, 141, 224, 164, 165, 224,
    164, 190, 224, 164, 168, ' ', 224, 164, 170, 224, 164, 176,
    ' ', 224, 164, 185, 224, 165, 139, 224, 164, 168, 224, 165,
    135, ' ', 224, 164, 149, 224, 164, 190, ' ', 224, 164, 166,
    224, 164, 190, 224, 164, 181, 224, 164, 190, ' ', 224, 164,
    149, 224, 164, 176, 224, 164, 164, 224, 164, 190, ' ', 224,
    164, 185, 224, 165, 136, ' ', 224, 165, 164,  13,  10,  13,
     10, 224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164,
    164, ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164, 166,
    224, 165, 139, ' ', 224, 164, 134, 224, 164, 167, 224, 164,
    191, 224, 164, 149, 224, 164, 190, 224, 164, 176, 224, 164,
    191, 224, 164, 149, ' ', 224, 164, 168, 224, 164, 190, 224,
    164, 174, ' ', 224, 164, 185, 224, 165, 136, 224, 164, 130,
    '-', ' ', 224, 164, 185, 224, 164, 191, 224, 164, 168, 224,
    165, 141, 224, 164, 166, 224, 165, 128, ' ', 224, 164, 174,
    224, 165, 135, 224, 164, 130, ' ', 224, 164, 173, 224, 164,
    190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 148, 224,
    164, 176, ' ', 224, 164, 133, 224, 164, 130, 224, 164, 151,
    224, 165, 141, 224, 164, 176, 224, 165, 135, 224, 164, 156,
    224, 164, 188, 224, 165, 128, ' ', 224, 164, 174, 224, 165,
    135, 224, 164, 130, ' ', 224, 164, 135, 224, 164, 163, 224,
    165, 141, 224, 164, 161, 224, 164, 191, 224, 164, 175, 224,
    164, 190, ' ', '(', 'I', 'n', 'd', 'i', 'a', ')', 224, 165,
    164, ' ', 224, 164, 135, 224, 164, 163, 224, 165, 141, 224,
    164, 161, 224, 164, 191, 224, 164, 175, 224, 164, 190, ' ',
    224, 164, 168, 224, 164, 190, 224, 164, 174, ' ', 224, 164,
    149, 224, 165, 128, ' ', 224, 164, 137, 224, 164, 164, 224,
    165, 141, 224, 164, 170, 224, 164, 164, 224, 165, 141, 224,
    164, 164, 224, 164, 191, ' ', 224, 164, 184, 224, 164, 191,
    224, 164, 168, 224, 165, 141, 224, 164, 167, 224, 165, 129,
    ' ', 224, 164, 168, 224, 164, 166, 224, 165, 128, ' ', 224,
    164, 149, 224, 165, 135, ' ', 224, 164, 133, 224, 164, 130,
    224, 164, 151, 224, 165, 141, 224, 164, 176, 224, 165, 135,
    224, 164, 156, 224, 165, 128, ' ', 224, 164, 168, 224, 164,
    190, 224, 164, 174, ' ', '"', 224, 164, 135, 224, 164, 163,
    224, 165, 141, 224, 164, 161, 224, 164, 184, '"', ' ', 224,
    164, 184, 224, 165, 135, ' ', 224, 164, 185, 224, 165, 129,
    224, 164, 136, ' ', 224, 164, 185, 224, 165, 136, 224, 165,
    164, ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224,
    164, 164, ' ', 224, 164, 168, 224, 164, 190, 224, 164, 174,
    ',', ' ', 224, 164, 143, 224, 164, 149, ' ', 224, 164, 170,
    224, 165, 141, 224, 164, 176, 224, 164, 190, 224, 164, 154,
    224, 165, 128, 224, 164, 168, ' ', 224, 164, 185, 224, 164,
    191, 224, 164, 168, 224, 165, 141, 224, 164, 166, 224, 165,
    130, ' ', 224, 164, 184, 224, 164, 174, 224, 165, 141, 224,
    164, 176, 224, 164, 190, 224, 164, 159, ' ', 224, 164, 173,
    224, 164, 176, 224, 164, 164, ' ', 224, 164, 156, 224, 165,
    139, ' ', 224, 164, 149, 224, 164, 191, ' ', 224, 164, 174,
    224, 164, 168, 224, 165, 129, ' ', 224, 164, 149, 224, 165,
    135, ' ', 224, 164, 181, 224, 164, 130, 224, 164, 182, 224,
    164, 156, ' ', 224, 164, 139, 224, 164, 183, 224, 164, 173,
    224, 164, 166, 224, 165, 135, 224, 164, 181, ' ', 224, 164,
    149, 224, 165, 135, ' ', 224, 164, 156, 224, 165, 141, 224,
    164, 175, 224, 165, 135, 224, 164, 183, 224, 165, 141, 224,
    164, 160, ' ', 224, 164, 170, 224, 165, 129, 224, 164, 164,
    224, 165, 141, 224, 164, 176, ' ', 224, 164, 165, 224, 165,
    135, ' ', 224, 164, 164, 224, 164, 165, 224, 164, 190, ' ',
    224, 164, 156, 224, 164, 191, 224, 164, 168, 224, 164, 149,
    224, 165, 128, ' ', 224, 164, 149, 224, 164, 165, 224, 164,
    190, ' ', 224, 164, 182, 224, 165, 141, 224, 164, 176, 224,
    165, 128, 224, 164, 174, 224, 164, 166, 224, 165, 141, 224,
    164, 173, 224, 164, 190, 224, 164, 151, 224, 164, 181, 224,
    164, 164, ' ', 224, 164, 174, 224, 164, 185, 224, 164, 190,
    224, 164, 170, 224, 165, 129, 224, 164, 176, 224, 164, 190,
    224, 164, 163, ' ', 224, 164, 174, 224, 165, 135, 224, 164,
    130, ' ', 224, 164, 185, 224, 165, 136, ',', ' ', 224, 164,
    149, 224, 165, 135, ' ', 224, 164, 168, 224, 164, 190, 224,
    164, 174, ' ', 224, 164, 184, 224, 165, 135, ' ', 224, 164,
    178, 224, 164, 191, 224, 164, 175, 224, 164, 190, ' ', 224,
    164, 151, 224, 164, 175, 224, 164, 190, ' ', 224, 164, 185,
    224, 165, 136, 224, 165, 164, ' ', 224, 164, 173, 224, 164,
    190, 224, 164, 176, 224, 164, 164, ' ', '(', 224, 164, 173,
    224, 164, 190, ' ', '+', ' ', 224, 164, 176, 224, 164, 164,
    ')', ' ', 224, 164, 182, 224, 164, 172, 224, 165, 141, 224,
    164, 166, ' ', 224, 164, 149, 224, 164, 190, ' ', 224, 164,
    174, 224, 164, 164, 224, 164, 178, 224, 164, 172, ' ', 224,
    164, 185, 224, 165, 136, ' ', 224, 164, 134, 224, 164, 168,
    224, 165, 141, 224, 164, 164, 224, 164, 176, 224, 164, 191,
    224, 164, 149, ' ', 224, 164, 170, 224, 165, 141, 224, 164,
    176, 224, 164, 149, 224, 164, 190, 224, 164, 182, ' ', 224,
    164, 175, 224, 164, 190, ' ', 224, 164, 181, 224, 164, 191,
    224, 164, 166, 224, 165, 135, 224, 164, 149, '-', 224, 164,
    176, 224, 165, 130, 224, 164, 170, 224, 165, 128, ' ', 224,
    164, 170, 224, 165, 141, 224, 164, 176, 224, 164, 149, 224,
    164, 190, 224, 164, 182, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 178, 224, 165, 128, 224, 164,
    168, 224, 165, 164, ' ', 224, 164, 143, 224, 164, 149, ' ',
    224, 164, 164, 224, 165, 128, 224, 164, 184, 224, 164, 176,
    224, 164, 190, ' ', 224, 164, 168, 224, 164, 190, 224, 164,
    174, ' ', 224, 164, 185, 224, 164, 191, 224, 164, 168, 224,
    165, 141, 224, 164, 166, 224, 165, 129, 224, 164, 184, 224,
    165, 141, 224, 164, 164, 224, 164, 190, 224, 164, 168, ' ',
    224, 164, 173, 224, 165, 128, ' ', 224, 164, 185, 224, 165,
    136, ' ', 224, 164, 156, 224, 164, 191, 224, 164, 184, 224,
    164, 149, 224, 164, 190, ' ', 224, 164, 133, 224, 164, 176,
    224, 165, 141, 224, 164, 165, ' ', 224, 164, 185, 224, 164,
    191, 224, 164, 168, 224, 165, 141, 224, 164, 166, '(', 224,
    164, 185, 224, 164, 191, 224, 164, 168, 224, 165, 141, 224,
    164, 166, 224, 165, 130, ')', ' ', 224, 164, 149, 224, 165,
    128, ' ', 224, 164, 173, 224, 165, 130, 224, 164, 174, 224,
    164, 191, ' ', 224, 164, 185, 224, 165, 139, 224, 164, 164,
    224, 164, 190, ' ', 224, 164, 185, 224, 165, 136, ' ', 224,
    164, 156, 224, 165, 139, ' ', 224, 164, 149, 224, 164, 191,
    ' ', 224, 164, 170, 224, 165, 141, 224, 164, 176, 224, 164,
    190, 224, 164, 154, 224, 165, 128, 224, 164, 168, ' ', 224,
    164, 149, 224, 164, 190, 224, 164, 178, ' ', 224, 164, 139,
    224, 164, 183, 224, 164, 191, 224, 164, 175, 224, 165, 139,
    224, 164, 130, ' ', 224, 164, 166, 224, 165, 141, 224, 164,
    181, 224, 164, 190, 224, 164, 176, 224, 164, 190, ' ', 224,
    164, 166, 224, 164, 191, 224, 164, 175, 224, 164, 190, ' ',
    224, 164, 151, 224, 164, 175, 224, 164, 190, ' ', 224, 164,
    165, 224, 164, 190, 224, 165, 164, ' ', 224, 164, 170, 224,
    165, 141, 224, 164, 176, 224, 164, 190, 224, 164, 154, 224,
    165, 128, 224, 164, 168, ' ', 224, 164, 149, 224, 164, 190,
    224, 164, 178, ' ', 224, 164, 174, 224, 165, 135, 224, 164,
    130, ' ', 224, 164, 175, 224, 164, 185, ' ', 224, 164, 149,
    224, 164, 174, ' ', 224, 164, 170, 224, 165, 141, 224, 164,
    176, 224, 164, 175, 224, 165, 129, 224, 164, 149, 224, 165,
    141, 224, 164, 164, ' ', 224, 164, 185, 224, 165, 139, 224,
    164, 164, 224, 164, 190, ' ', 224, 164, 165, 224, 164, 190,
    ' ', 224, 164, 164, 224, 164, 165, 224, 164, 190, ' ', 224,
    164, 149, 224, 164, 190, 224, 164, 178, 224, 164, 190, 224,
    164, 168, 224, 165, 141, 224, 164, 164, 224, 164, 176, ' ',
    224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164,
    133, 224, 164, 167, 224, 164, 191, 224, 164, 149, ' ', 224,
    164, 170, 224, 165, 141, 224, 164, 176, 224, 164, 154, 224,
    164, 178, 224, 164, 191, 224, 164, 164, ' ', 224, 164, 185,
    224, 165, 129, 224, 164, 134, ' ', 224, 164, 181, 224, 164,
    191, 224, 164, 182, 224, 165, 135, 224, 164, 183, 224, 164,
    149, 224, 164, 176, ' ', 224, 164, 133, 224, 164, 176, 224,
    164, 172, '/', 224, 164, 136, 224, 164, 176, 224, 164, 190,
    224, 164, 168, ' ', 224, 164, 174, 224, 165, 135, 224, 164,
    130, 224, 165, 164, ' ', 224, 164, 173, 224, 164, 190, 224,
    164, 176, 224, 164, 164, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 175, 224, 164, 185, ' ', 224,
    164, 168, 224, 164, 190, 224, 164, 174, ' ', 224, 164, 174,
    224, 165, 129, 224, 164, 151, 224, 164, 178, ' ', 224, 164,
    149, 224, 164, 190, 224, 164, 178, ' ', 224, 164, 184, 224,
    165, 135, ' ', 224, 164, 133, 224, 164, 167, 224, 164, 191,
    224, 164, 149, ' ', 224, 164, 170, 224, 165, 141, 224, 164,
    176, 224, 164, 154, 224, 164, 178, 224, 164, 191, 224, 164,
    164, ' ', 224, 164, 185, 224, 165, 129, 224, 164, 134, ' ',
    224, 164, 175, 224, 164, 166, 224, 165, 141, 224, 164, 175,
    224, 164, 170, 224, 164, 191, ' ', 224, 164, 135, 224, 164,
    184, 224, 164, 149, 224, 164, 190, ' ', 224, 164, 184, 224,
    164, 174, 224, 164, 149, 224, 164, 190, 224, 164, 178, 224,
    165, 128, 224, 164, 168, ' ', 224, 164, 137, 224, 164, 170,
    224, 164, 175, 224, 165, 139, 224, 164, 151, ' ', 224, 164,
    149, 224, 164, 174, ' ', 224, 164, 148, 224, 164, 176, ' ',
    224, 164, 170, 224, 165, 141, 224, 164, 176, 224, 164, 190,
    224, 164, 175, 224, 164, 131, ' ', 224, 164, 137, 224, 164,
    164, 224, 165, 141, 224, 164, 164, 224, 164, 176, 224, 165,
    128, ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224,
    164, 164, ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164,
    178, 224, 164, 191, 224, 164, 143, ' ', 224, 164, 185, 224,
    165, 139, 224, 164, 164, 224, 164, 190, ' ', 224, 164, 185,
    224, 165, 136, 224, 165, 164, ' ', 224, 164, 135, 224, 164,
    184, 224, 164, 149, 224, 165, 135, ' ', 224, 164, 133, 224,
    164, 164, 224, 164, 191, 224, 164, 176, 224, 164, 191, 224,
    164, 149, 224, 165, 141, 224, 164, 164, ' ', 224, 164, 173,
    224, 164, 190, 224, 164, 176, 224, 164, 164, 224, 164, 181,
    224, 164, 176, 224, 165, 141, 224, 164, 183, ' ', 224, 164,
    149, 224, 165, 139, ' ', 224, 164, 181, 224, 165, 136, 224,
    164, 166, 224, 164, 191, 224, 164, 149, ' ', 224, 164, 149,
    224, 164, 190, 224, 164, 178, ' ', 224, 164, 184, 224, 165,
    135, ' ', 224, 164, 134, 224, 164, 176, 224, 165, 141, 224,
    164, 175, 224, 164, 190, 224, 164, 181, 224, 164, 176, 224,
    165, 141, 224, 164, 164, ' ', '"', 224, 164, 156, 224, 164,
    174, 224, 165, 141, 224, 164, 172, 224, 165, 130, 224, 164,
    166, 224, 165, 141, 224, 164, 181, 224, 165, 128, 224, 164,
    170, '"', ' ', 224, 164, 148, 224, 164, 176, ' ', '"', 224,
    164, 133, 224, 164, 156, 224, 164, 168, 224, 164, 190, 224,
    164, 173, 224, 164, 166, 224, 165, 135, 224, 164, 182, '"',
    ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164, 168, 224,
    164, 190, 224, 164, 174, ' ', 224, 164, 184, 224, 165, 135,
    ' ', 224, 164, 173, 224, 165, 128, ' ', 224, 164, 156, 224,
    164, 190, 224, 164, 168, 224, 164, 190, ' ', 224, 164, 156,
    224, 164, 190, 224, 164, 164, 224, 164, 190, ' ', 224, 164,
    176, 224, 164, 185, 224, 164, 190, ' ', 224, 164, 185, 224,
    165, 136, 224, 165, 164, ' ', 224, 164, 172, 224, 164, 185,
    224, 165, 129, 224, 164, 164, ' ', 224, 164, 170, 224, 164,
    185, 224, 164, 178, 224, 165, 135, ' ', 224, 164, 175, 224,
    164, 185, ' ', 224, 164, 166, 224, 165, 135, 224, 164, 182,
    ' ','\'', 224, 164, 184, 224, 165, 139, 224, 164, 168, 224,
    165, 135, ' ', 224, 164, 149, 224, 165, 128, ' ', 224, 164,
    154, 224, 164, 191, 224, 164, 161, 224, 164, 188, 224, 164,
    191, 224, 164, 175, 224, 164, 190,'\'', ' ', 224, 164, 149,
    224, 165, 135, ' ', 224, 164, 176, 224, 165, 130, 224, 164,
    170, ' ', 224, 164, 174, 224, 165, 135, 224, 164, 130, ' ',
    224, 164, 156, 224, 164, 190, 224, 164, 168, 224, 164, 190,
    ' ', 224, 164, 156, 224, 164, 190, 224, 164, 164, 224, 164,
    190, ' ', 224, 164, 165, 224, 164, 190, 224, 165, 164, '[',
    '2', ']',  13,  10,  13,  10, 'F', 'r', 'e', 'n', 'c', 'h',
    ':',  13,  10,  13,  10, 'L', 'a', ' ', 'F', 'r', 'a', 'n',
    'c', 'e', ',', ' ', 'e', 'n', ' ', 'f', 'o', 'r', 'm', 'e',
    ' ', 'l', 'o', 'n', 'g', 'u', 'e', ' ', 'l', 'a', ' ', 'R',
    195, 169, 'p', 'u', 'b', 'l', 'i', 'q', 'u', 'e', ' ', 'f',
    'r', 'a', 'n', 195, 167, 'a', 'i', 's', 'e', ',', ' ', 'e',
    's', 't', ' ', 'u', 'n', 'e', ' ', 'r', 195, 169, 'p', 'u',
    'b', 'l', 'i', 'q', 'u', 'e', ' ', 'c', 'o', 'n', 's', 't',
    'i', 't', 'u', 't', 'i', 'o', 'n', 'n', 'e', 'l', 'l', 'e',
    ' ', 'u', 'n', 'i', 't', 'a', 'i', 'r', 'e', ' ', 'd', 'o',
    'n', 't', ' ', 'l', 'a', ' ', 'm', 'a', 'j', 'e', 'u', 'r',
    'e', ' ', 'p', 'a', 'r', 't', 'i', 'e', ' ', 'd', 'u', ' ',
    't', 'e', 'r', 'r', 'i', 't', 'o', 'i', 'r', 'e', ' ', 'e',
    't', ' ', 'd', 'e', ' ', 'l', 'a', ' ', 'p', 'o', 'p', 'u',
    'l', 'a', 't', 'i', 'o', 'n', ' ', 's', 'o', 'n', 't', ' ',
    's', 'i', 't', 'u', 195, 169, 's', ' ', 'e', 'n', ' ', 'E',
    'u', 'r', 'o', 'p', 'e', ' ', 'o', 'c', 'c', 'i', 'd', 'e',
    'n', 't', 'a', 'l', 'e', ',', ' ', 'm', 'a', 'i', 's', ' ',
    'q', 'u', 'i', ' ', 'c', 'o', 'm', 'p', 'r', 'e', 'n', 'd',
    ' ', 195, 169, 'g', 'a', 'l', 'e', 'm', 'e', 'n', 't', ' ',
    'p', 'l', 'u', 's', 'i', 'e', 'u', 'r', 's', ' ', 'r', 195,
    169, 'g', 'i', 'o', 'n', 's', ' ', 'e', 't', ' ', 't', 'e',
    'r', 'r', 'i', 't', 'o', 'i', 'r', 'e', 's', ' ', 'r', 195,
    169, 'p', 'a', 'r', 't', 'i', 's', ' ', 'd', 'a', 'n', 's',
    ' ', 'l', 'e', 's', ' ', 'A', 'm', 195, 169, 'r', 'i', 'q',
    'u', 'e', 's', ',', ' ', 'l', 226, 128, 153, 'o', 'c', 195,
    169, 'a', 'n', ' ', 'I', 'n', 'd', 'i', 'e', 'n', ' ', 'e',
    't', ' ', 'l','\'', 'o', 'c', 195, 169, 'a', 'n', ' ', 'P',
    'a', 'c', 'i', 'f', 'i', 'q', 'u', 'e', '.', ' ', 'E', 'l',
    'l', 'e', ' ', 'a', ' ', 'p', 'o', 'u', 'r', ' ', 'c', 'a',
    'p', 'i', 't', 'a', 'l', 'e', ' ', 'P', 'a', 'r', 'i', 's',
    ',', ' ', 'p', 'o', 'u', 'r', ' ', 'l', 'a', 'n', 'g', 'u',
    'e', ' ', 'o', 'f', 'f', 'i', 'c', 'i', 'e', 'l', 'l', 'e',
    ' ', 'l', 'e', ' ', 'f', 'r', 'a', 'n', 195, 167, 'a', 'i',
    's', ' ', 'e', 't', ' ', 'p', 'o', 'u', 'r', ' ', 'm', 'o',
    'n', 'n', 'a', 'i', 'e', ' ', 'l', 226, 128, 153, 'e', 'u',
    'r', 'o', '.', ' ', 'S', 'a', ' ', 'd', 'e', 'v', 'i', 's',
    'e', ' ', 'e', 's', 't', ' ', 194, 171, ' ', 'L', 'i', 'b',
    'e', 'r', 't', 195, 169, ',', ' ', 195, 137, 'g', 'a', 'l',
    'i', 't', 195, 169, ',', ' ', 'F', 'r', 'a', 't', 'e', 'r',
    'n', 'i', 't', 195, 169, ' ', 194, 187, ',', ' ', 'e', 't',
    ' ', 's', 'o', 'n', ' ', 'd', 'r', 'a', 'p', 'e', 'a', 'u',
    ' ', 'e', 's', 't', ' ', 'c', 'o', 'n', 's', 't', 'i', 't',
    'u', 195, 169, ' ', 'd', 'e', ' ', 't', 'r', 'o', 'i', 's',
    ' ', 'b', 'a', 'n', 'd', 'e', 's', ' ', 'v', 'e', 'r', 't',
    'i', 'c', 'a', 'l', 'e', 's', ' ', 'r', 'e', 's', 'p', 'e',
    'c', 't', 'i', 'v', 'e', 'm', 'e', 'n', 't', ' ', 'b', 'l',
    'e', 'u', 'e', ',', ' ', 'b', 'l', 'a', 'n', 'c', 'h', 'e',
    ' ', 'e', 't', ' ', 'r', 'o', 'u', 'g', 'e', '.', ' ', 'S',
    'o', 'n', ' ', 'h', 'y', 'm', 'n', 'e', ' ', 'e', 's', 't',
    ' ', 'L', 'a', ' ', 'M', 'a', 'r', 's', 'e', 'i', 'l', 'l',
    'a', 'i', 's', 'e', '.', ' ', 'S', 'o', 'n', ' ', 'p', 'r',
    'i', 'n', 'c', 'i', 'p', 'e', ' ', 'e', 's', 't', ' ', 'g',
    'o', 'u', 'v', 'e', 'r', 'n', 'e', 'm', 'e', 'n', 't', ' ',
    'd', 'u', ' ', 'p', 'e', 'u', 'p', 'l', 'e', ',', ' ', 'p',
    'a', 'r', ' ', 'l', 'e', ' ', 'p', 'e', 'u', 'p', 'l', 'e',
    ' ', 'e', 't', ' ', 'p', 'o', 'u', 'r', ' ', 'l', 'e', ' ',
    'p', 'e', 'u', 'p', 'l', 'e', '[', '3', ']', '.',  13,  10,
     13,  10, 'L', 'a', ' ', 'F', 'r', 'a', 'n', 'c', 'e', ' ',
    'e', 's', 't', ' ', 'u', 'n', ' ', 'p', 'a', 'y', 's', ' ',
    'a', 'n', 'c', 'i', 'e', 'n', ',', ' ', 'f', 'o', 'r', 'm',
    195, 169, ' ', 'a', 'u', ' ', 'H', 'a', 'u', 't', ' ', 'M',
    'o', 'y', 'e', 'n', ' ', 195, 130, 'g', 'e', '.', ' ', 'A',
    'u', ' ', 'X', 'I', 'X', 'e', ' ', 's', 'i', 195, 168, 'c',
    'l', 'e', ' ', 'e', 't', ' ', 'd', 'a', 'n', 's', ' ', 'l',
    'a', ' ', 'p', 'r', 'e', 'm', 'i', 195, 168, 'r', 'e', ' ',
    'm', 'o', 'i', 't', 'i', 195, 169, ' ', 'd', 'u', ' ', 'X',
    'X', 'e', ' ', 's', 'i', 195, 168, 'c', 'l', 'e', ',', ' ',
    'e', 'l', 'l', 'e', ' ', 'p', 'o', 's', 's', 195, 168, 'd',
    'e', ' ', 'u', 'n', ' ', 'v', 'a', 's', 't', 'e', ' ', 'e',
    'm', 'p', 'i', 'r', 'e', ' ', 'c', 'o', 'l', 'o', 'n', 'i',
    'a', 'l', '.', ' ', 195, 128, ' ', 'p', 'a', 'r', 't', 'i',
    'r', ' ', 'd', 'e', 's', ' ', 'a', 'n', 'n', 195, 169, 'e',
    's', ' ', '1', '9', '5', '0', ',', ' ', 'e', 'l', 'l', 'e',
    ' ', 'e', 's', 't', ' ', 'l', 226, 128, 153, 'u', 'n', ' ',
    'd', 'e', 's', ' ', 'a', 'c', 't', 'e', 'u', 'r', 's', ' ',
    'd', 'e', ' ', 'l', 'a', ' ', 'c', 'o', 'n', 's', 't', 'r',
    'u', 'c', 't', 'i', 'o', 'n', ' ', 'd', 'e', ' ', 'l', 226,
    128, 153, 'U', 'n', 'i', 'o', 'n', ' ', 'e', 'u', 'r', 'o',
    'p', 195, 169, 'e', 'n', 'n', 'e', '.', ' ', 'E', 'l', 'l',
    'e', ' ', 'e', 's', 't', ' ', 'u', 'n', 'e', ' ', 'p', 'u',
    'i', 's', 's', 'a', 'n', 'c', 'e', ' ', 'n', 'u', 'c', 'l',
    195, 169, 'a', 'i', 'r', 'e', ',', ' ', 'e', 't', ' ', 'l',
    226, 128, 153, 'u', 'n', ' ', 'd', 'e', 's', ' ', 'c', 'i',
    'n', 'q', ' ', 'm', 'e', 'm', 'b', 'r', 'e', 's', ' ', 'p',
    'e', 'r', 'm', 'a', 'n', 'e', 'n', 't', 's', ' ', 'd', 'u',
    ' ', 'C', 'o', 'n', 's', 'e', 'i', 'l', ' ', 'd', 'e', ' ',
    's', 195, 169, 'c', 'u', 'r', 'i', 't', 195, 169, ' ', 'd',
    'e', 's', ' ', 'N', 'a', 't', 'i', 'o', 'n', 's', ' ', 'u',
    'n', 'i', 'e', 's', '.', ' ', 'L', 'a', ' ', 'F', 'r', 'a',
    'n', 'c', 'e', ' ', 'j', 'o', 'u', 'e', ' ', 'u', 'n', ' ',
    'r', 195, 180, 'l', 'e', ' ', 'i', 'm', 'p', 'o', 'r', 't',
    'a', 'n', 't', ' ', 'd', 'a', 'n', 's', ' ', 'l', 226, 128,
    153, 'h', 'i', 's', 't', 'o', 'i', 'r', 'e', ' ', 'm', 'o',
    'n', 'd', 'i', 'a', 'l', 'e', ' ', 'p', 'a', 'r', ' ', 'l',
    226, 128, 153, 'i', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e',
    ' ', 'd', 'e', ' ', 's', 'a', ' ', 'c', 'u', 'l', 't', 'u',
    'r', 'e', ' ', 'e', 't', ' ', 'd', 'e', ' ', 's', 'e', 's',
    ' ', 'v', 'a', 'l', 'e', 'u', 'r', 's', ' ', 'd', 195, 169,
    'm', 'o', 'c', 'r', 'a', 't', 'i', 'q', 'u', 'e', 's', ',',
    ' ', 'l', 'a', 195, 175, 'q', 'u', 'e', 's', ' ', 'e', 't',
    ' ', 'r', 195, 169, 'p', 'u', 'b', 'l', 'i', 'c', 'a', 'i',
    'n', 'e', 's', '.',  13,  10,  13,  10, 'L', 'a', ' ', 'F',
    'r', 'a', 'n', 'c', 'e', ' ', 'a', ',', ' ', 'e', 'n', ' ',
    '2', '0', '1', '0', ',', ' ', 'l', 'e', ' ', 'c', 'i', 'n',
    'q', 'u', 'i', 195, 168, 'm', 'e', ' ', 'p', 'l', 'u', 's',
    ' ', 'i', 'm', 'p', 'o', 'r', 't', 'a', 'n', 't', ' ', 'p',
    'r', 'o', 'd', 'u', 'i', 't', ' ', 'i', 'n', 't', 195, 169,
    'r', 'i', 'e', 'u', 'r', ' ', 'b', 'r', 'u', 't', ' ', 'a',
    'u', ' ', 'm', 'o', 'n', 'd', 'e', '.', ' ', 'S', 'o', 'n',
    ' ', 195, 169, 'c', 'o', 'n', 'o', 'm', 'i', 'e', ',', ' ',
    'd', 'e', ' ', 't', 'y', 'p', 'e', ' ', 'c', 'a', 'p', 'i',
    't', 'a', 'l', 'i', 's', 't', 'e', ' ', 'a', 'v', 'e', 'c',
    ' ', 'u', 'n', 'e', ' ', 'i', 'n', 't', 'e', 'r', 'v', 'e',
    'n', 't', 'i', 'o', 'n', ' ', 195, 169, 't', 'a', 't', 'i',
    'q', 'u', 'e', ' ', 'a', 's', 's', 'e', 'z', ' ', 'f', 'o',
    'r', 't', 'e', ',', ' ', 'f', 'a', 'i', 't', ' ', 'd', 226,
    128, 153, 'e', 'l', 'l', 'e', ' ', 'u', 'n', ' ', 'd', 'e',
    's', ' ', 'l', 'e', 'a', 'd', 'e', 'r', 's', ' ', 'm', 'o',
    'n', 'd', 'i', 'a', 'u', 'x', ' ', 'd', 'a', 'n', 's', ' ',
    'l', 'e', 's', ' ', 's', 'e', 'c', 't', 'e', 'u', 'r', 's',
    ' ', 'd', 'e', ' ', 'l', 226, 128, 153, 'a', 'g', 'r', 'o',
    'a', 'l', 'i', 'm', 'e', 'n', 't', 'a', 'i', 'r', 'e', ',',
    ' ', 'd', 'e', ' ', 'l', 226, 128, 153, 'a', 195, 169, 'r',
    'o', 'n', 'a', 'u', 't', 'i', 'q', 'u', 'e', ',', ' ', 'd',
    'e', ' ', 'l', 226, 128, 153, 'a', 'u', 't', 'o', 'm', 'o',
    'b', 'i', 'l', 'e', ',', ' ', 'd', 'e', 's', ' ', 'p', 'r',
    'o', 'd', 'u', 'i', 't', 's', ' ', 'd', 'e', ' ', 'l', 'u',
    'x', 'e', ',', ' ', 'd', 'u', ' ', 't', 'o', 'u', 'r', 'i',
    's', 'm', 'e', ' ', 'e', 't', ' ', 'd', 'u', ' ', 'n', 'u',
    'c', 'l', 195, 169, 'a', 'i', 'r', 'e', '.',  13,  10,  13,
     10, 'P', 'e', 'u', 'p', 'l', 195, 169, 'e', ' ', 'd', 'e',
    ' ', '6', '5', ',', '3', ' ', 'm', 'i', 'l', 'l', 'i', 'o',
    'n', 's', ' ', 'd', 226, 128, 153, 'h', 'a', 'b', 'i', 't',
    'a', 'n', 't', 's', ' ', 'a', 'u', ' ', '1', 'e', 'r', ' ',
    'j', 'a', 'n', 'v', 'i', 'e', 'r', ' ', '2', '0', '1', '2',
    '[', '4', ']', ',', ' ', 'l', 'a', ' ', 'F', 'r', 'a', 'n',
    'c', 'e', ' ', 'e', 's', 't', ' ', 'u', 'n', ' ', 'p', 'a',
    'y', 's', ' ', 'd', 195, 169, 'v', 'e', 'l', 'o', 'p', 'p',
    195, 169, ',', ' ', 'a', 'v', 'e', 'c', ' ', 'u', 'n', ' ',
    'i', 'n', 'd', 'i', 'c', 'e', ' ', 'd', 'e', ' ', 'd', 195,
    169, 'v', 'e', 'l', 'o', 'p', 'p', 'e', 'm', 'e', 'n', 't',
    ' ', 'h', 'u', 'm', 'a', 'i', 'n', ' ', 't', 'r', 195, 168,
    's', ' ', 195, 169, 'l', 'e', 'v', 195, 169, '[', '5', ']',
    '.',  13,  10,  13,  10, 'L', 'a', ' ', 'F', 'r', 'a', 'n',
    'c', 'e', ' ', 'm', 195, 169, 't', 'r', 'o', 'p', 'o', 'l',
    'i', 't', 'a', 'i', 'n', 'e', ' ', 'e', 's', 't', ' ', 's',
    'i', 't', 'u', 195, 169, 'e', ' ', 195, 160, ' ', 'l', 226,
    128, 153, 'u', 'n', 'e', ' ', 'd', 'e', 's', ' ', 'e', 'x',
    't', 'r', 195, 169, 'm', 'i', 't', 195, 169, 's', ' ', 'o',
    'c', 'c', 'i', 'd', 'e', 'n', 't', 'a', 'l', 'e', 's', ' ',
    'd', 'e', ' ', 'l', 226, 128, 153, 'E', 'u', 'r', 'o', 'p',
    'e', '.', ' ', 'E', 'l', 'l', 'e', ' ', 'e', 's', 't', ' ',
    'b', 'o', 'r', 'd', 195, 169, 'e', ' ', 'p', 'a', 'r', ' ',
    'l', 'a', ' ', 'm', 'e', 'r', ' ', 'd', 'u', ' ', 'N', 'o',
    'r', 'd', ' ', 'a', 'u', ' ', 'n', 'o', 'r', 'd', ',', ' ',
    'l', 'a', ' ', 'M', 'a', 'n', 'c', 'h', 'e', ' ', 'a', 'u',
    ' ', 'n', 'o', 'r', 'd', '-', 'o', 'u', 'e', 's', 't', ',',
    ' ', 'l', 226, 128, 153, 'o', 'c', 195, 169, 'a', 'n', ' ',
    'A', 't', 'l', 'a', 'n', 't', 'i', 'q', 'u', 'e', ' ', 195,
    160, ' ', 'l', 226, 128, 153, 'o', 'u', 'e', 's', 't', ' ',
    'e', 't', ' ', 'l', 'a', ' ', 'm', 'e', 'r', ' ', 'M', 195,
    169, 'd', 'i', 't', 'e', 'r', 'r', 'a', 'n', 195, 169, 'e',
    ' ', 'a', 'u', ' ', 's', 'u', 'd', '-', 'e', 's', 't', '.',
    ' ', 'E', 'l', 'l', 'e', ' ', 'e', 's', 't', ' ', 'f', 'r',
    'o', 'n', 't', 'a', 'l', 'i', 195, 168, 'r', 'e', ' ', 'd',
    'e', ' ', 'l', 'a', ' ', 'B', 'e', 'l', 'g', 'i', 'q', 'u',
    'e', ' ', 'e', 't', ' ', 'd', 'u', ' ', 'L', 'u', 'x', 'e',
    'm', 'b', 'o', 'u', 'r', 'g', ' ', 'a', 'u', ' ', 'n', 'o',
    'r', 'd', '-', 'e', 's', 't', ',', ' ', 'd', 'e', ' ', 'l',
    226, 128, 153, 'A', 'l', 'l', 'e', 'm', 'a', 'g', 'n', 'e',
    ' ', 'e', 't', ' ', 'd', 'e', ' ', 'l', 'a', ' ', 'S', 'u',
    'i', 's', 's', 'e', ' ', 195, 160, ' ', 'l', 226, 128, 153,
    'e', 's', 't', ',', ' ', 'd', 'e', ' ', 'l', 226, 128, 153,
    'I', 't', 'a', 'l', 'i', 'e', ' ', 'e', 't', ' ', 'd', 'e',
    ' ', 'M', 'o', 'n', 'a', 'c', 'o', ' ', 'a', 'u', ' ', 's',
    'u', 'd', '-', 'e', 's', 't', ',', ' ', 'd', 'e', ' ', 'l',
    226, 128, 153, 'E', 's', 'p', 'a', 'g', 'n', 'e', ' ', 'e',
    't', ' ', 'd', 226, 128, 153, 'A', 'n', 'd', 'o', 'r', 'r',
    'e', ' ', 'a', 'u', ' ', 's', 'u', 'd', '-', 'o', 'u', 'e',
    's', 't', '.', ' ', 'S', 'i', ' ', 'l', 'e', 's', ' ', 'f',
    'r', 'o', 'n', 't', 'i', 195, 168, 'r', 'e', 's', ' ', 'd',
    'u', ' ', 's', 'u', 'd', ' ', 'd', 'u', ' ', 'p', 'a', 'y',
    's', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd',
    'e', 'n', 't', ' ', 195, 160, ' ', 'd', 'e', 's', ' ', 'm',
    'a', 's', 's', 'i', 'f', 's', ' ', 'm', 'o', 'n', 't', 'a',
    'g', 'n', 'e', 'u', 'x', ',', ' ', 'l', 'e', 's', ' ', 'f',
    'r', 'o', 'n', 't', 'i', 195, 168, 'r', 'e', 's', ' ', 'd',
    'u', ' ', 'n', 'o', 'r', 'd', '-', 'e', 's', 't', ' ', 'n',
    'e', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd',
    'e', 'n', 't', ' ', 195, 160, ' ', 'a', 'u', 'c', 'u', 'n',
    'e', ' ', 'l', 'i', 'm', 'i', 't', 'e', ' ', 'g', 195, 169,
    'o', 'g', 'r', 'a', 'p', 'h', 'i', 'q', 'u', 'e', '[', 'n',
    'o', 't', 'e', ' ', '6', ']', ' ', 'n', 'i', ' ', 'l', 'i',
    'n', 'g', 'u', 'i', 's', 't', 'i', 'q', 'u', 'e', '[', 'n',
    'o', 't', 'e', ' ', '7', ']', '.', ' ', 'L', 'a', ' ', 'F',
    'r', 'a', 'n', 'c', 'e', ' ', 'm', 195, 169, 't', 'r', 'o',
    'p', 'o', 'l', 'i', 't', 'a', 'i', 'n', 'e', ' ', 'c', 'o',
    'm', 'p', 'r', 'e', 'n', 'd', ' ', 'p', 'l', 'u', 's', 'i',
    'e', 'u', 'r', 's', ' ', 195, 174, 'l', 'e', 's', ',', ' ',
    'n', 'o', 't', 'a', 'm', 'm', 'e', 'n', 't', ' ', 'l', 'a',
    ' ', 'C', 'o', 'r', 's', 'e', ' ', 'e', 't', ' ', 'd', 'e',
    's', ' ', 195, 174, 'l', 'e', 's', ' ', 'c', 195, 180, 't',
    'i', 195, 168, 'r', 'e', 's', '.', ' ', 'L', 'a', ' ', 'm',
    195, 169, 't', 'r', 'o', 'p', 'o', 'l', 'e', ' ', 'e', 's',
    't', ' ', 'c', 'o', 'm', 'p', 'r', 'i', 's', 'e', ' ', 'e',
    'n', 't', 'r', 'e', ' ', 'l', 'e', 's', ' ', 'l', 'a', 't',
    'i', 't', 'u', 'd', 'e', 's', ' ', '4', '2', 194, 176, '1',
    '9','\'', '4', '6', '"', ' ', 'N', ' ', 'e', 't', ' ', '5',
    '1', 194, 176, '5','\'', '4', '7', '"', ' ', 'N', ',', ' ',
    'a', 'i', 'n', 's', 'i', ' ', 'q', 'u', 'e', ' ', 'l', 'e',
    's', ' ', 'l', 'o', 'n', 'g', 'i', 't', 'u', 'd', 'e', 's',
    ' ', '4', 194, 176, '4', '6','\'', ' ', 'O', ' ', 'e', 't',
    ' ', '8', 194, 176, '1', '4','\'', '4', '2', '"', ' ', 'E',
    '.',  13,  10,  13,  10, 'L', 'a', ' ', 'F', 'r', 'a', 'n',
    'c', 'e', ' ', 'c', 'o', 'm', 'p', 'r', 'e', 'n', 'd', ' ',
    195, 169, 'g', 'a', 'l', 'e', 'm', 'e', 'n', 't', ' ', 'd',
    'e', ' ', 'n', 'o', 'm', 'b', 'r', 'e', 'u', 'x', ' ', 't',
    'e', 'r', 'r', 'i', 't', 'o', 'i', 'r', 'e', 's', ' ', 's',
    'i', 't', 'u', 195, 169, 's', ' ', 'e', 'n', '-', 'd', 'e',
    'h', 'o', 'r', 's', ' ', 'd', 'u', ' ', 'c', 'o', 'n', 't',
    'i', 'n', 'e', 'n', 't', ' ', 'e', 'u', 'r', 'o', 'p', 195,
    169, 'e', 'n', ',', ' ', 'c', 'o', 'u', 'r', 'a', 'm', 'm',
    'e', 'n', 't', ' ', 'a', 'p', 'p', 'e', 'l', 195, 169, 's',
    ' ', 't', 'e', 'r', 'r', 'i', 't', 'o', 'i', 'r', 'e', 's',
    ' ', 'd', 226, 128, 153, 'o', 'u', 't', 'r', 'e', '-', 'm',
    'e', 'r', ',', ' ', 'n', 'a', 'g', 'u', 195, 168, 'r', 'e',
    ' ', 'D', 'O', 'M', '-', 'T', 'O', 'M', ',', ' ', 'q', 'u',
    'i', ' ', 'l', 'u', 'i', ' ', 'p', 'e', 'r', 'm', 'e', 't',
    't', 'e', 'n', 't', ' ', 'd', 226, 128, 153, 195, 170, 't',
    'r', 'e', ' ', 'p', 'r', 195, 169, 's', 'e', 'n', 't', 'e',
    ' ', 'd', 'a', 'n', 's', ' ', 't', 'o', 'u', 's', ' ', 'l',
    'e', 's', ' ', 'o', 'c', 195, 169, 'a', 'n', 's', '.', ' ',
    'C', 'e', 's', ' ', 't', 'e', 'r', 'r', 'i', 't', 'o', 'i',
    'r', 'e', 's', ' ', 'a', 'u', 'x', ' ', 's', 't', 'a', 't',
    'u', 't', 's', ' ', 'v', 'a', 'r', 'i', 195, 169, 's', ' ',
    's', 'o', 'n', 't', '[', '6', ']', ' ', ':',  13,  10,  13,
     10, 's', 'u', 'r', ' ', 'l', 'e', ' ', 'c', 'o', 'n', 't',
    'i', 'n', 'e', 'n', 't', ' ', 's', 'u', 'd', '-', 'a', 'm',
    195, 169, 'r', 'i', 'c', 'a', 'i', 'n', ' ', ':', ' ', 'l',
    'a', ' ', 'G', 'u', 'y', 'a', 'n', 'e', ' ', ';',  13,  10,
    'd', 'a', 'n', 's', ' ', 'l', 226, 128, 153, 'o', 'c', 195,
    169, 'a', 'n', ' ', 'A', 't', 'l', 'a', 'n', 't', 'i', 'q',
    'u', 'e', ' ', '(', 'A', 'n', 't', 'i', 'l', 'l', 'e', 's',
    ')', ' ', ':', ' ', 'l', 'a', ' ', 'G', 'u', 'a', 'd', 'e',
    'l', 'o', 'u', 'p', 'e', ',', ' ', 'l', 'a', ' ', 'M', 'a',
    'r', 't', 'i', 'n', 'i', 'q', 'u', 'e', ',', ' ', 'S', 'a',
    'i', 'n', 't', '-', 'P', 'i', 'e', 'r', 'r', 'e', '-', 'e',
    't', '-', 'M', 'i', 'q', 'u', 'e', 'l', 'o', 'n', ',', ' ',
    'S', 'a', 'i', 'n', 't', '-', 'M', 'a', 'r', 't', 'i', 'n',
    ' ', 'e', 't', ' ', 'S', 'a', 'i', 'n', 't', '-', 'B', 'a',
    'r', 't', 'h', 195, 169, 'l', 'e', 'm', 'y', ' ', ';',  13,
     10, 'd', 'a', 'n', 's', ' ', 'l', 226, 128, 153, 'o', 'c',
    195, 169, 'a', 'n', ' ', 'P', 'a', 'c', 'i', 'f', 'i', 'q',
    'u', 'e', ' ', ':', ' ', 'l', 'a', ' ', 'P', 'o', 'l', 'y',
    'n', 195, 169, 's', 'i', 'e', ' ', 'f', 'r', 'a', 'n', 195,
    167, 'a', 'i', 's', 'e', ',', ' ', 'l', 'a', ' ', 'N', 'o',
    'u', 'v', 'e', 'l', 'l', 'e', '-', 'C', 'a', 'l', 195, 169,
    'd', 'o', 'n', 'i', 'e', ',', ' ', 'W', 'a', 'l', 'l', 'i',
    's', '-', 'e', 't', '-', 'F', 'u', 't', 'u', 'n', 'a', ' ',
    'e', 't', ' ', 'C', 'l', 'i', 'p', 'p', 'e', 'r', 't', 'o',
    'n', ' ', ';',  13,  10, 'd', 'a', 'n', 's', ' ', 'l', 226,
    128, 153, 'o', 'c', 195, 169, 'a', 'n', ' ', 'I', 'n', 'd',
    'i', 'e', 'n', ' ', ':', ' ', 'L', 'a', ' ', 'R', 195, 169,
    'u', 'n', 'i', 'o', 'n', ',', ' ', 'M', 'a', 'y', 'o', 't',
    't', 'e', ',', ' ', 'l', 'e', 's', ' ', 195, 142, 'l', 'e',
    's', ' ', 195, 137, 'p', 'a', 'r', 's', 'e', 's', ',', ' ',
    'l', 'e', 's', ' ', 195, 142, 'l', 'e', 's', ' ', 'C', 'r',
    'o', 'z', 'e', 't', ',', ' ', 'l', 'e', 's', ' ', 195, 142,
    'l', 'e', 's', ' ', 'K', 'e', 'r', 'g', 'u', 'e', 'l', 'e',
    'n', ' ', 'e', 't', ' ', 'S', 'a', 'i', 'n', 't', '-', 'P',
    'a', 'u', 'l', '-', 'e', 't', '-', 'A', 'm', 's', 't', 'e',
    'r', 'd', 'a', 'm', ' ', ';',  13,  10, 'e', 'n', ' ', 'A',
    'n', 't', 'a', 'r', 'c', 't', 'i', 'q', 'u', 'e', ' ', ':',
    ' ', 'l', 'a', ' ', 'T', 'e', 'r', 'r', 'e', ' ', 'A', 'd',
    195, 169, 'l', 'i', 'e', '[', 'n', 'o', 't', 'e', ' ', '8',
    ']', '.',  13,  10, 195, 128, ' ', 't', 'r', 'a', 'v', 'e',
    'r', 's', ' ', 's', 'e', 's', ' ', 'c', 'o', 'l', 'l', 'e',
    'c', 't', 'i', 'v', 'i', 't', 195, 169, 's', ' ', 'u', 'l',
    't', 'r', 'a', '-', 'm', 'a', 'r', 'i', 'n', 'e', 's', ',',
    ' ', 'l', 'a', ' ', 'F', 'r', 'a', 'n', 'c', 'e', ' ', 'p',
    'o', 's', 's', 195, 168, 'd', 'e', ' ', 195, 169, 'g', 'a',
    'l', 'e', 'm', 'e', 'n', 't', ' ', 'd', 'e', 's', ' ', 'f',
    'r', 'o', 'n', 't', 'i', 195, 168, 'r', 'e', 's', ' ', 't',
    'e', 'r', 'r', 'e', 's', 't', 'r', 'e', 's', ' ', 'a', 'v',
    'e', 'c', ' ', 'l', 'e', ' ', 'B', 'r', 195, 169, 's', 'i',
    'l', ' ', 'e', 't', ' ', 'l', 'e', ' ', 'S', 'u', 'r', 'i',
    'n', 'a', 'm', 'e', ',', ' ', 'a', 'i', 'n', 's', 'i', ' ',
    'q', 'u', 226, 128, 153, 'a', 'v', 'e', 'c', ' ', 'l', 'e',
    's', ' ', 'P', 'a', 'y', 's', '-', 'B', 'a', 's', ' ', 'v',
    'i', 'a', ' ', 'l', 'a', ' ', 'p', 'a', 'r', 't', 'i', 'e',
    ' ', 'f', 'r', 'a', 'n', 195, 167, 'a', 'i', 's', 'e', ' ',
    'd', 'e', ' ', 'S', 'a', 'i', 'n', 't', '-', 'M', 'a', 'r',
    't', 'i', 'n', '.',  13,  10,  13,  10, 'L', 'a', ' ', 's',
    'u', 'p', 'e', 'r', 'f', 'i', 'c', 'i', 'e', ' ', 'd', 'e',
    ' ', 'l', 'a', ' ', 'F', 'r', 'a', 'n', 'c', 'e', ' ', 'e',
    's', 't', ' ', 'd', 'e', ' ', '6', '7', '0', ' ', '9', '2',
    '2', ' ', 'k', 'm', 194, 178, ',', ' ', 'o', 'u', ' ', '5',
    '4', '7', ' ', '0', '3', '0', ' ', 's', 'a', 'n', 's', ' ',
    'c', 'o', 'm', 'p', 't', 'a', 'b', 'i', 'l', 'i', 's', 'e',
    'r', ' ', 'l', 226, 128, 153, 'o', 'u', 't', 'r', 'e', '-',
    'm', 'e', 'r', '[', '7', ']', '.', ' ', 'E', 'l', 'l', 'e',
    ' ', 'e', 's', 't', ' ', 'l', 'e', ' ', '4', '1', 'e', ' ',
    'p', 'l', 'u', 's', ' ', 'g', 'r', 'a', 'n', 'd', ' ', 195,
    137, 't', 'a', 't', ' ', 'd', 'u', ' ', 'm', 'o', 'n', 'd',
    'e', ' ', 'p', 'a', 'r', ' ', 's', 'a', ' ', 's', 'u', 'r',
    'f', 'a', 'c', 'e', ' ', 't', 'e', 'r', 'r', 'e', 's', 't',
    'r', 'e', '[', '7', ']', ' ', 'e', 't', ' ', 'l', 'e', ' ',
    'd', 'e', 'u', 'x', 'i', 195, 168, 'm', 'e', ' ', 'p', 'a',
    'r', ' ', 's', 'a', ' ', 'z', 'o', 'n', 'e', ' ', 195, 169,
    'c', 'o', 'n', 'o', 'm', 'i', 'q', 'u', 'e', ' ', 'e', 'x',
    'c', 'l', 'u', 's', 'i', 'v', 'e', '[', '8', ']', '.', ' ',
    'E', 'l', 'l', 'e', ' ', 'e', 's', 't', ' ', 'e', 'n', ' ',
    'o', 'u', 't', 'r', 'e', ' ', 'l', 'e', ' ', 't', 'r', 'o',
    'i', 's', 'i', 195, 168, 'm', 'e', ' ', 'p', 'l', 'u', 's',
    ' ', 'g', 'r', 'a', 'n', 'd', ' ', 'p', 'a', 'y', 's', ' ',
    'd', 226, 128, 153, 'E', 'u', 'r', 'o', 'p', 'e', ',', ' ',
    'a', 'p', 'r', 195, 168, 's', ' ', 'l', 'a', ' ', 'R', 'u',
    's', 's', 'i', 'e', ' ', 'e', 't', ' ', 'l', 226, 128, 153,
    'U', 'k', 'r', 'a', 'i', 'n', 'e', ',', ' ', 'd', 'e', 'u',
    'x', 'i', 195, 168, 'm', 'e', ' ', 's', 'i', ' ', 'o', 'n',
    ' ', 'i', 'n', 'c', 'l', 'u', 't', ' ', 'l', 'e', 's', ' ',
    'd', 195, 169, 'p', 'a', 'r', 't', 'e', 'm', 'e', 'n', 't',
    's', ' ', 'u', 'l', 't', 'r', 'a', '-', 'm', 'a', 'r', 'i',
    'n', 's', ',', ' ', 'e', 't', ' ', 'l', 'e', ' ', 'p', 'l',
    'u', 's', ' ', 'g', 'r', 'a', 'n', 'd', ' ', 'd', 'e', ' ',
    'l', 226, 128, 153, 'U', 'n', 'i', 'o', 'n', ' ', 'e', 'u',
    'r', 'o', 'p', 195, 169, 'e', 'n', 'n', 'e', '[', '7', ']',
    '.', ' ', 'S', 'o', 'n', ' ', 't', 'e', 'r', 'r', 'i', 't',
    'o', 'i', 'r', 'e', ' ', 'm', 195, 169, 't', 'r', 'o', 'p',
    'o', 'l', 'i', 't', 'a', 'i', 'n', ' ', 'c', 'o', 'n', 't',
    'i', 'n', 'e', 'n', 't', 'a', 'l', ' ', 's', 226, 128, 153,
    195, 169, 't', 'e', 'n', 'd', ' ', 's', 'u', 'r', ' ', 'e',
    'n', 'v', 'i', 'r', 'o', 'n', ' ', '1', ' ', '0', '0', '0',
    ' ', 'k', 'm', ' ', 'd', 'u', ' ', 'n', 'o', 'r', 'd', ' ',
    'a', 'u', ' ', 's', 'u', 'd', ' ', 'e', 't', ' ', 'd', 226,
    128, 153, 'e', 's', 't', ' ', 'e', 'n', ' ', 'o', 'u', 'e',
    's', 't', '.', ' ', 'L', 226, 128, 153, 195, 169, 't', 'e',
    'n', 'd', 'u', 'e', ' ', 'd', 'e', ' ', 's', 'o', 'n', ' ',
    'l', 'i', 't', 't', 'o', 'r', 'a', 'l', ',', ' ', 'o', 'u',
    't', 'r', 'e', '-', 'm', 'e', 'r', ' ', 'i', 'n', 'c', 'l',
    'u', 's', ',', ' ', 'e', 's', 't', ' ', 'd', 'e', ' ', '8',
    ' ', '2', '4', '5', ' ', 'k', 'm', '[', '9', ']', '.',  13,
     10,  13,  10, 'G', 'r', 'e', 'e', 'k', ':',  13,  10,  13,
     10, 206, 151, ' ', 206, 149, 206, 187, 206, 187, 206, 172,
    206, 180, 206, 177, ' ', '(', 207, 128, 206, 177, 206, 187,
    206, 177, 206, 185, 207, 140, 207, 132, 206, 181, 207, 129,
    206, 177, ':', ' ', 225, 188, 153, 206, 187, 206, 187, 206,
    172, 207, 130, ',', ' ', 206, 181, 207, 128, 206, 175, 207,
    131, 206, 183, 206, 188, 206, 177, ':', ' ', 206, 149, 206,
    187, 206, 187, 206, 183, 206, 189, 206, 185, 206, 186, 206,
    174, ' ', 206, 148, 206, 183, 206, 188, 206, 191, 206, 186,
    207, 129, 206, 177, 207, 132, 206, 175, 206, 177, ')', ' ',
    206, 181, 206, 175, 206, 189, 206, 177, 206, 185, ' ', 207,
    135, 207, 142, 207, 129, 206, 177, ' ', 207, 128, 206, 191,
    207, 133, ' ', 206, 178, 207, 129, 206, 175, 207, 131, 206,
    186, 206, 181, 207, 132, 206, 177, 206, 185, ' ', 207, 131,
    207, 132, 206, 183, ' ', 206, 189, 206, 191, 207, 132, 206,
    185, 206, 191, 206, 177, 206, 189, 206, 177, 207, 132, 206,
    191, 206, 187, 206, 185, 206, 186, 206, 174, ' ', 206, 149,
    207, 133, 207, 129, 207, 142, 207, 128, 206, 183, ',', ' ',
    207, 131, 207, 132, 206, 191, ' ', 206, 189, 206, 191, 207,
    132, 206, 185, 207, 140, 207, 132, 206, 181, 207, 129, 206,
    191, ' ', 206, 172, 206, 186, 207, 129, 206, 191, ' ', 207,
    132, 206, 183, 207, 130, ' ', 206, 146, 206, 177, 206, 187,
    206, 186, 206, 177, 206, 189, 206, 185, 206, 186, 206, 174,
    207, 130, ' ', 207, 135, 206, 181, 207, 129, 207, 131, 206,
    191, 206, 189, 206, 174, 207, 131, 206, 191, 207, 133, ',',
    ' ', 207, 131, 207, 132, 206, 183, 206, 189, ' ', 206, 145,
    206, 189, 206, 177, 207, 132, 206, 191, 206, 187, 206, 185,
    206, 186, 206, 174, ' ', 206, 156, 206, 181, 207, 131, 207,
    140, 206, 179, 206, 181, 206, 185, 206, 191, '.', 206, 160,
    207, 129, 207, 137, 207, 132, 206, 181, 207, 141, 206, 191,
    207, 133, 207, 131, 206, 177, ' ', 207, 132, 206, 183, 207,
    130, ' ', 206, 149, 206, 187, 206, 187, 206, 172, 206, 180,
    206, 191, 207, 130, ' ', 206, 186, 206, 177, 206, 185, ' ',
    206, 188, 206, 181, 206, 179, 206, 177, 206, 187, 207, 141,
    207, 132, 206, 181, 207, 129, 206, 183, ' ', 207, 128, 207,
    140, 206, 187, 206, 183, ' ', 206, 181, 206, 175, 206, 189,
    206, 177, 206, 185, ' ', 206, 183, ' ', 206, 145, 206, 184,
    206, 174, 206, 189, 206, 177, '.',  13,  10,  13,  10, 206,
    163, 207, 133, 206, 189, 206, 191, 207, 129, 206, 181, 207,
    141, 206, 181, 206, 185, ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 178, 206, 191, 207, 129, 206, 181, 206, 185, 206,
    191, 206, 180, 207, 133, 207, 132, 206, 185, 206, 186, 206,
    172, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, 206,
    189, ' ', 206, 145, 206, 187, 206, 178, 206, 177, 206, 189,
    206, 175, 206, 177, ',', ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 178, 207, 140, 207, 129, 206, 181, 206, 185, 206,
    177, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, ' ',
    206, 146, 206, 191, 207, 133, 206, 187, 206, 179, 206, 177,
    207, 129, 206, 175, 206, 177, ' ', 206, 186, 206, 177, 206,
    185, ' ', 207, 132, 206, 183, 206, 189, ' ', 207, 128, 207,
    129, 207, 142, 206, 183, 206, 189, ' ', 206, 147, 206, 185,
    206, 191, 207, 133, 206, 179, 206, 186, 206, 191, 207, 131,
    206, 187, 206, 177, 206, 178, 206, 185, 206, 186, 206, 174,
    ' ', 206, 148, 206, 183, 206, 188, 206, 191, 206, 186, 207,
    129, 206, 177, 207, 132, 206, 175, 206, 177, ' ', 207, 132,
    206, 183, 207, 130, ' ', 206, 156, 206, 177, 206, 186, 206,
    181, 206, 180, 206, 191, 206, 189, 206, 175, 206, 177, 207,
    130, ' ', '(', 207, 128, '.', 206, 147, '.', 206, 148, '.',
    206, 156, '.', ')', ' ', 206, 186, 206, 177, 206, 185, ' ',
    207, 131, 207, 132, 206, 177, ' ', 206, 178, 206, 191, 207,
    129, 206, 181, 206, 185, 206, 191, 206, 177, 206, 189, 206,
    177, 207, 132, 206, 191, 206, 187, 206, 185, 206, 186, 206,
    172, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, 206,
    189, ' ', 206, 164, 206, 191, 207, 133, 207, 129, 206, 186,
    206, 175, 206, 177, '.', ' ', 206, 146, 207, 129, 206, 173,
    207, 135, 206, 181, 207, 132, 206, 177, 206, 185, ' ', 207,
    131, 207, 132, 206, 177, ' ', 206, 177, 206, 189, 206, 177,
    207, 132, 206, 191, 206, 187, 206, 185, 206, 186, 206, 172,
    ' ', 206, 177, 207, 128, 207, 140, ' ', 207, 132, 206, 191,
    ' ', 206, 145, 206, 185, 206, 179, 206, 177, 206, 175, 206,
    191, ' ', 206, 160, 206, 173, 206, 187, 206, 177, 206, 179,
    206, 191, 207, 130, ',', ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 180, 207, 133, 207, 132, 206, 185, 206, 186, 206,
    172, ' ', 206, 177, 207, 128, 207, 140, ' ', 207, 132, 206,
    191, ' ', 206, 153, 207, 140, 206, 189, 206, 185, 206, 191,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 189, 207, 140,
    207, 132, 206, 185, 206, 177, ' ', 206, 177, 207, 128, 207,
    140, ' ', 207, 132, 206, 183, ' ', 206, 156, 206, 181, 207,
    131, 207, 140, 206, 179, 206, 181, 206, 185, 206, 191, ' ',
    206, 152, 206, 172, 206, 187, 206, 177, 207, 131, 207, 131,
    206, 177, '.', 206, 151, ' ', 206, 149, 206, 187, 206, 187,
    206, 172, 206, 180, 206, 177, ' ', 206, 186, 206, 177, 207,
    132, 206, 173, 207, 135, 206, 181, 206, 185, ' ', 207, 132,
    206, 183, 206, 189, ' ', '1', '1', 206, 183, ' ', 206, 184,
    206, 173, 207, 131, 206, 183, ' ', 207, 131, 207, 132, 206,
    185, 207, 130, ' ', 207, 135, 207, 142, 207, 129, 206, 181,
    207, 130, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183,
    ' ', 206, 188, 206, 181, 206, 179, 206, 177, 206, 187, 207,
    141, 207, 132, 206, 181, 207, 129, 206, 183, ' ', 206, 177,
    206, 186, 207, 132, 206, 191, 206, 179, 207, 129, 206, 177,
    206, 188, 206, 188, 206, 174, ' ', 207, 131, 207, 132, 206,
    177, ' ', '1', '3', '.', '6', '7', '6', ' ', 207, 135, 206,
    185, 206, 187, 206, 185, 207, 140, 206, 188, 206, 181, 207,
    132, 207, 129, 206, 177, ' ', 206, 186, 206, 177, 206, 184,
    207, 142, 207, 130, ' ', 206, 181, 207, 135, 206, 181, 206,
    185, ' ', 207, 128, 206, 191, 206, 187, 206, 187, 206, 172,
    ' ', 206, 189, 206, 183, 207, 131, 206, 185, 206, 172, ' ',
    '(', 207, 128, 206, 181, 207, 129, 206, 175, 207, 128, 206,
    191, 207, 133, ' ', '1', '.', '4', '0', '0', ',', ' ', 206,
    181, 206, 186, 207, 132, 207, 137, 206, 189, ' ', 206, 191,
    207, 128, 206, 191, 206, 175, 207, 137, 206, 189, ' ', 207,
    132, 206, 177, ' ', '2', '2', '7', ' ', 206, 186, 206, 177,
    207, 132, 206, 191, 206, 185, 206, 186, 206, 191, 207, 133,
    206, 189, 207, 132, 206, 177, 206, 185, ')', ',', ' ', 207,
    131, 207, 133, 206, 188, 207, 128, 206, 181, 207, 129, 206,
    185, 206, 187, 206, 177, 206, 188, 206, 178, 206, 177, 206,
    189, 206, 191, 206, 188, 206, 173, 206, 189, 207, 137, 206,
    189, ' ', 207, 132, 206, 183, 207, 130, ' ', 206, 154, 207,
    129, 206, 183, 207, 132, 206, 183, 207, 130, ',', ' ', 207,
    132, 207, 137, 206, 189, ' ', 206, 148, 207, 137, 206, 180,
    206, 181, 206, 186, 206, 177, 206, 189, 206, 174, 207, 131,
    207, 137, 206, 189, ',', ' ', 207, 132, 207, 137, 206, 189,
    ' ', 206, 154, 207, 133, 206, 186, 206, 187, 206, 172, 206,
    180, 207, 137, 206, 189, ',', ' ', 207, 132, 207, 137, 206,
    189, ' ', 206, 149, 207, 128, 207, 132, 206, 177, 206, 189,
    206, 174, 207, 131, 207, 137, 206, 189, ' ', 206, 186, 206,
    177, 206, 185, ' ', 207, 128, 206, 191, 206, 187, 206, 187,
    207, 142, 206, 189, ' ', 206, 172, 206, 187, 206, 187, 207,
    137, 206, 189, '.', 206, 164, 206, 191, ' ', 207, 136, 206,
    183, 206, 187, 207, 140, 207, 132, 206, 181, 207, 129, 206,
    191, ' ', 206, 178, 206, 191, 207, 133, 206, 189, 207, 140,
    ' ', 206, 181, 206, 175, 206, 189, 206, 177, 206, 185, ' ',
    206, 191, ' ', 206, 140, 206, 187, 207, 133, 206, 188, 207,
    128, 206, 191, 207, 130, ' ', 206, 186, 206, 177, 206, 185,
    ' ', 207, 132, 206, 191, ' ', 206, 188, 206, 181, 206, 179,
    206, 177, 206, 187, 207, 141, 207, 132, 206, 181, 207, 129,
    206, 191, ' ', 207, 128, 206, 191, 207, 132, 206, 172, 206,
    188, 206, 185, ' ', 206, 191, ' ', 206, 145, 206, 187, 206,
    185, 206, 172, 206, 186, 206, 188, 206, 191, 206, 189, 206,
    177, 207, 130, '.',  13,  10,  13,  10, 206, 136, 207, 135,
    206, 181, 206, 185, ' ', 206, 188, 206, 177, 206, 186, 207,
    129, 206, 172, ' ', 206, 186, 206, 177, 206, 185, ' ', 207,
    128, 206, 187, 206, 191, 207, 141, 207, 131, 206, 185, 206,
    177, ' ', 206, 185, 207, 131, 207, 132, 206, 191, 207, 129,
    206, 175, 206, 177, ' ', 206, 186, 206, 177, 207, 132, 206,
    172, ' ', 207, 132, 206, 183, 206, 189, ' ', 206, 191, 207,
    128, 206, 191, 206, 175, 206, 177, ' ', 206, 172, 207, 131,
    206, 186, 206, 183, 207, 131, 206, 181, ' ', 206, 188, 206,
    181, 206, 179, 206, 172, 206, 187, 206, 183, ' ', 207, 128,
    206, 191, 206, 187, 206, 185, 207, 132, 206, 185, 207, 131,
    206, 188, 206, 185, 206, 186, 206, 174, ' ', 206, 181, 207,
    128, 206, 175, 206, 180, 207, 129, 206, 177, 207, 131, 206,
    183, ' ', 207, 131, 206, 181, ' ', 207, 132, 207, 129, 206,
    181, 206, 185, 207, 130, ' ', 206, 183, 207, 128, 206, 181,
    206, 175, 207, 129, 206, 191, 207, 133, 207, 130, '.', 206,
    149, 206, 180, 207, 142, ' ', 206, 179, 206, 181, 206, 189,
    206, 189, 206, 174, 206, 184, 206, 183, 206, 186, 206, 181,
    ' ', 206, 183, ' ', 206, 180, 206, 183, 206, 188, 206, 191,
    206, 186, 207, 129, 206, 177, 207, 132, 206, 175, 206, 177,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 183, ' ', 207,
    134, 206, 185, 206, 187, 206, 191, 207, 131, 206, 191, 207,
    134, 206, 175, 206, 177, '.', 206, 145, 206, 186, 207, 140,
    206, 188, 206, 188, 206, 177, ' ', 206, 183, ' ', 206, 149,
    206, 187, 206, 187, 206, 172, 206, 180, 206, 177, ' ', 206,
    181, 206, 175, 206, 189, 206, 177, 206, 185, ' ', 206, 191,
    ' ', 207, 132, 207, 140, 207, 128, 206, 191, 207, 130, ' ',
    206, 179, 206, 173, 206, 189, 206, 189, 206, 183, 207, 131,
    206, 183, 207, 130, ' ', 207, 132, 207, 137, 206, 189, ' ',
    206, 159, 206, 187, 207, 133, 206, 188, 207, 128, 206, 185,
    206, 177, 206, 186, 207, 142, 206, 189, ' ', 206, 145, 206,
    179, 207, 142, 206, 189, 207, 137, 206, 189, ',', 207, 132,
    206, 191, 207, 133, ' ', 206, 180, 207, 129, 206, 172, 206,
    188, 206, 177, 207, 132, 206, 191, 207, 130, ',', ' ', 207,
    132, 206, 183, 207, 130, ' ', 207, 132, 207, 129, 206, 177,
    206, 179, 207, 137, 206, 180, 206, 175, 206, 177, 207, 130,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 207, 132, 206, 183,
    207, 130, ' ', 206, 186, 207, 137, 206, 188, 206, 188, 207,
    137, 206, 180, 206, 175, 206, 177, 207, 130, ' ', '.',  13,
     10,  13,  10, 206, 151, ' ', 206, 149, 206, 187, 206, 187,
    206, 172, 206, 180, 206, 177, ' ', 206, 181, 206, 175, 206,
    189, 206, 177, 206, 185, ' ', 206, 188, 206, 173, 206, 187,
    206, 191, 207, 130, ' ', 207, 132, 207, 137, 206, 189, ' ',
    206, 149, 207, 133, 207, 129, 207, 137, 207, 128, 206, 177,
    207, 138, 206, 186, 207, 142, 206, 189, ' ', 206, 154, 206,
    191, 206, 185, 206, 189, 206, 191, 207, 132, 206, 174, 207,
    132, 207, 137, 206, 189, '/', 206, 149, 207, 133, 207, 129,
    207, 137, 207, 128, 206, 177, 207, 138, 206, 186, 206, 174,
    207, 130, ' ', 206, 136, 206, 189, 207, 137, 207, 131, 206,
    183, 207, 130, ' ', 206, 177, 207, 128, 207, 140, ' ', 207,
    132, 206, 191, ' ', '1', '9', '8', '1', ',', ' ', 207, 132,
    206, 183, 207, 130, ' ', 206, 149, 207, 133, 207, 129, 207,
    137, 206, 182, 207, 142, 206, 189, 206, 183, 207, 130, ' ',
    206, 177, 207, 128, 207, 140, ' ', 207, 132, 206, 191, ' ',
    '2', '0', '0', '1', ',', ' ', 207, 132, 206, 191, 207, 133,
    ' ', 206, 157, 206, 145, 206, 164, 206, 159, ' ', 206, 177,
    207, 128, 207, 140, ' ', 207, 132, 206, 191, ' ', '1', '9',
    '5', '2', ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 185,
    206, 180, 207, 129, 207, 133, 207, 132, 206, 185, 206, 186,
    207, 140, ' ', 206, 188, 206, 173, 206, 187, 206, 191, 207,
    130, ' ', 207, 132, 206, 191, 207, 133, ' ', 206, 159, 206,
    151, 206, 149, ' ', '(', '1', '9', '4', '5', ')', '.', ' ',
    206, 151, ' ', 206, 149, 206, 187, 206, 187, 206, 172, 206,
    180, 206, 177, ' ', 206, 181, 206, 175, 206, 189, 206, 177,
    206, 185, ' ', 206, 188, 206, 185, 206, 177, ' ', 206, 177,
    206, 189, 206, 181, 207, 128, 207, 132, 207, 133, 206, 179,
    206, 188, 206, 173, 206, 189, 206, 183, ' ', 207, 135, 207,
    142, 207, 129, 206, 177, ' ', 206, 188, 206, 181, ' ', 207,
    133, 207, 136, 206, 183, 206, 187, 207, 140, ' ', 206, 186,
    206, 177, 207, 132, 206, 172, ' ', 206, 186, 206, 181, 207,
    134, 206, 177, 206, 187, 206, 174, 206, 189, ' ', 206, 181,
    206, 185, 207, 131, 207, 140, 206, 180, 206, 183, 206, 188,
    206, 177, ' ', 206, 186, 206, 177, 206, 185, ' ', 207, 128,
    206, 191, 206, 187, 207, 141, ' ', 207, 133, 207, 136, 206,
    183, 206, 187, 207, 140, ' ', 206, 180, 206, 181, 206, 175,
    206, 186, 207, 132, 206, 183, ' ', 206, 177, 206, 189, 206,
    184, 207, 129, 207, 142, 207, 128, 206, 185, 206, 189, 206,
    183, 207, 130, ' ', 206, 177, 206, 189, 206, 172, 207, 128,
    207, 132, 207, 133, 206, 190, 206, 183, 207, 130, '.', ' ',
    206, 154, 206, 177, 207, 132, 206, 173, 207, 135, 206, 181,
    206, 185, ' ', 207, 132, 206, 183, 206, 189, ' ', '2', '2',
    206, 183, ' ', 206, 186, 206, 177, 206, 187, 207, 141, 207,
    132, 206, 181, 207, 129, 206, 183, ' ', 207, 128, 206, 191,
    206, 185, 207, 140, 207, 132, 206, 183, 207, 132, 206, 177,
    ' ', 206, 182, 207, 137, 206, 174, 207, 130, ' ', 207, 131,
    207, 132, 206, 191, 206, 189, ' ', 206, 186, 207, 140, 207,
    131, 206, 188, 206, 191, '.', '[', '4', ']',  13,  10,  13,
     10, 206, 151, ' ', 206, 149, 206, 187, 206, 187, 206, 172,
    206, 180, 206, 177, ' ', '(', 207, 128, 206, 177, 206, 187,
    206, 177, 206, 185, 207, 140, 207, 132, 206, 181, 207, 129,
    206, 177, ':', ' ', 225, 188, 153, 206, 187, 206, 187, 206,
    172, 207, 130, ',', ' ', 206, 181, 207, 128, 206, 175, 207,
    131, 206, 183, 206, 188, 206, 177, ':', ' ', 206, 149, 206,
    187, 206, 187, 206, 183, 206, 189, 206, 185, 206, 186, 206,
    174, ' ', 206, 148, 206, 183, 206, 188, 206, 191, 206, 186,
    207, 129, 206, 177, 207, 132, 206, 175, 206, 177, ')', ' ',
    206, 181, 206, 175, 206, 189, 206, 177, 206, 185, ' ', 207,
    135, 207, 142, 207, 129, 206, 177, ' ', 207, 128, 206, 191,
    207, 133, ' ', 206, 178, 207, 129, 206, 175, 207, 131, 206,
    186, 206, 181, 207, 132, 206, 177, 206, 185, ' ', 207, 131,
    207, 132, 206, 183, ' ', 206, 189, 206, 191, 207, 132, 206,
    185, 206, 191, 206, 177, 206, 189, 206, 177, 207, 132, 206,
    191, 206, 187, 206, 185, 206, 186, 206, 174, ' ', 206, 149,
    207, 133, 207, 129, 207, 142, 207, 128, 206, 183, ',', ' ',
    207, 131, 207, 132, 206, 191, ' ', 206, 189, 206, 191, 207,
    132, 206, 185, 207, 140, 207, 132, 206, 181, 207, 129, 206,
    191, ' ', 206, 172, 206, 186, 207, 129, 206, 191, ' ', 207,
    132, 206, 183, 207, 130, ' ', 206, 146, 206, 177, 206, 187,
    206, 186, 206, 177, 206, 189, 206, 185, 206, 186, 206, 174,
    207, 130, ' ', 207, 135, 206, 181, 207, 129, 207, 131, 206,
    191, 206, 189, 206, 174, 207, 131, 206, 191, 207, 133, ',',
    ' ', 207, 131, 207, 132, 206, 183, 206, 189, ' ', 206, 145,
    206, 189, 206, 177, 207, 132, 206, 191, 206, 187, 206, 185,
    206, 186, 206, 174, ' ', 206, 156, 206, 181, 207, 131, 207,
    140, 206, 179, 206, 181, 206, 185, 206, 191, '.', 206, 160,
    207, 129, 207, 137, 207, 132, 206, 181, 207, 141, 206, 191,
    207, 133, 207, 131, 206, 177, ' ', 207, 132, 206, 183, 207,
    130, ' ', 206, 149, 206, 187, 206, 187, 206, 172, 206, 180,
    206, 191, 207, 130, ' ', 206, 186, 206, 177, 206, 185, ' ',
    206, 188, 206, 181, 206, 179, 206, 177, 206, 187, 207, 141,
    207, 132, 206, 181, 207, 129, 206, 183, ' ', 207, 128, 207,
    140, 206, 187, 206, 183, ' ', 206, 181, 206, 175, 206, 189,
    206, 177, 206, 185, ' ', 206, 183, ' ', 206, 145, 206, 184,
    206, 174, 206, 189, 206, 177, '.',  13,  10,  13,  10, 206,
    163, 207, 133, 206, 189, 206, 191, 207, 129, 206, 181, 207,
    141, 206, 181, 206, 185, ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 178, 206, 191, 207, 129, 206, 181, 206, 185, 206,
    191, 206, 180, 207, 133, 207, 132, 206, 185, 206, 186, 206,
    172, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, 206,
    189, ' ', 206, 145, 206, 187, 206, 178, 206, 177, 206, 189,
    206, 175, 206, 177, ',', ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 178, 207, 140, 207, 129, 206, 181, 206, 185, 206,
    177, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, ' ',
    206, 146, 206, 191, 207, 133, 206, 187, 206, 179, 206, 177,
    207, 129, 206, 175, 206, 177, ' ', 206, 186, 206, 177, 206,
    185, ' ', 207, 132, 206, 183, 206, 189, ' ', 207, 128, 207,
    129, 207, 142, 206, 183, 206, 189, ' ', 206, 147, 206, 185,
    206, 191, 207, 133, 206, 179, 206, 186, 206, 191, 207, 131,
    206, 187, 206, 177, 206, 178, 206, 185, 206, 186, 206, 174,
    ' ', 206, 148, 206, 183, 206, 188, 206, 191, 206, 186, 207,
    129, 206, 177, 207, 132, 206, 175, 206, 177, ' ', 207, 132,
    206, 183, 207, 130, ' ', 206, 156, 206, 177, 206, 186, 206,
    181, 206, 180, 206, 191, 206, 189, 206, 175, 206, 177, 207,
    130, ' ', '(', 207, 128, '.', 206, 147, '.', 206, 148, '.',
    206, 156, '.', ')', ' ', 206, 186, 206, 177, 206, 185, ' ',
    207, 131, 207, 132, 206, 177, ' ', 206, 178, 206, 191, 207,
    129, 206, 181, 206, 185, 206, 191, 206, 177, 206, 189, 206,
    177, 207, 132, 206, 191, 206, 187, 206, 185, 206, 186, 206,
    172, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, 206,
    189, ' ', 206, 164, 206, 191, 207, 133, 207, 129, 206, 186,
    206, 175, 206, 177, '.', ' ', 206, 146, 207, 129, 206, 173,
    207, 135, 206, 181, 207, 132, 206, 177, 206, 185, ' ', 207,
    131, 207, 132, 206, 177, ' ', 206, 177, 206, 189, 206, 177,
    207, 132, 206, 191, 206, 187, 206, 185, 206, 186, 206, 172,
    ' ', 206, 177, 207, 128, 207, 140, ' ', 207, 132, 206, 191,
    ' ', 206, 145, 206, 185, 206, 179, 206, 177, 206, 175, 206,
    191, ' ', 206, 160, 206, 173, 206, 187, 206, 177, 206, 179,
    206, 191, 207, 130, ',', ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 180, 207, 133, 207, 132, 206, 185, 206, 186, 206,
    172, ' ', 206, 177, 207, 128, 207, 140, ' ', 207, 132, 206,
    191, ' ', 206, 153, 207, 140, 206, 189, 206, 185, 206, 191,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 189, 207, 140,
    207, 132, 206, 185, 206, 177, ' ', 206, 177, 207, 128, 207,
    140, ' ', 207, 132, 206, 183, ' ', 206, 156, 206, 181, 207,
    131, 207, 140, 206, 179, 206, 181, 206, 185, 206, 191, ' ',
    206, 152, 206, 172, 206, 187, 206, 177, 207, 131, 207, 131,
    206, 177, '.', 206, 151, ' ', 206, 149, 206, 187, 206, 187,
    206, 172, 206, 180, 206, 177, ' ', 206, 186, 206, 177, 207,
    132, 206, 173, 207, 135, 206, 181, 206, 185, ' ', 207, 132,
    206, 183, 206, 189, ' ', '1', '1', 206, 183, ' ', 206, 184,
    206, 173, 207, 131, 206, 183, ' ', 207, 131, 207, 132, 206,
    185, 207, 130, ' ', 207, 135, 207, 142, 207, 129, 206, 181,
    207, 130, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183,
    ' ', 206, 188, 206, 181, 206, 179, 206, 177, 206, 187, 207,
    141, 207, 132, 206, 181, 207, 129, 206, 183, ' ', 206, 177,
    206, 186, 207, 132, 206, 191, 206, 179, 207, 129, 206, 177,
    206, 188, 206, 188, 206, 174, ' ', 207, 131, 207, 132, 206,
    177, ' ', '1', '3', '.', '6', '7', '6', ' ', 207, 135, 206,
    185, 206, 187, 206, 185, 207, 140, 206, 188, 206, 181, 207,
    132, 207, 129, 206, 177, ' ', 206, 186, 206, 177, 206, 184,
    207, 142, 207, 130, ' ', 206, 181, 207, 135, 206, 181, 206,
    185, ' ', 207, 128, 206, 191, 206, 187, 206, 187, 206, 172,
    ' ', 206, 189, 206, 183, 207, 131, 206, 185, 206, 172, ' ',
    '(', 207, 128, 206, 181, 207, 129, 206, 175, 207, 128, 206,
    191, 207, 133, ' ', '1', '.', '4', '0', '0', ',', ' ', 206,
    181, 206, 186, 207, 132, 207, 137, 206, 189, ' ', 206, 191,
    207, 128, 206, 191, 206, 175, 207, 137, 206, 189, ' ', 207,
    132, 206, 177, ' ', '2', '2', '7', ' ', 206, 186, 206, 177,
    207, 132, 206, 191, 206, 185, 206, 186, 206, 191, 207, 133,
    206, 189, 207, 132, 206, 177, 206, 185, ')', ',', ' ', 207,
    131, 207, 133, 206, 188, 207, 128, 206, 181, 207, 129, 206,
    185, 206, 187, 206, 177, 206, 188, 206, 178, 206, 177, 206,
    189, 206, 191, 206, 188, 206, 173, 206, 189, 207, 137, 206,
    189, ' ', 207, 132, 206, 183, 207, 130, ' ', 206, 154, 207,
    129, 206, 183, 207, 132, 206, 183, 207, 130, ',', ' ', 207,
    132, 207, 137, 206, 189, ' ', 206, 148, 207, 137, 206, 180,
    206, 181, 206, 186, 206, 177, 206, 189, 206, 174, 207, 131,
    207, 137, 206, 189, ',', ' ', 207, 132, 207, 137, 206, 189,
    ' ', 206, 154, 207, 133, 206, 186, 206, 187, 206, 172, 206,
    180, 207, 137, 206, 189, ',', ' ', 207, 132, 207, 137, 206,
    189, ' ', 206, 149, 207, 128, 207, 132, 206, 177, 206, 189,
    206, 174, 207, 131, 207, 137, 206, 189, ' ', 206, 186, 206,
    177, 206, 185, ' ', 207, 128, 206, 191, 206, 187, 206, 187,
    207, 142, 206, 189, ' ', 206, 172, 206, 187, 206, 187, 207,
    137, 206, 189, '.', 206, 164, 206, 191, ' ', 207, 136, 206,
    183, 206, 187, 207, 140, 207, 132, 206, 181, 207, 129, 206,
    191, ' ', 206, 178, 206, 191, 207, 133, 206, 189, 207, 140,
    ' ', 206, 181, 206, 175, 206, 189, 206, 177, 206, 185, ' ',
    206, 191, ' ', 206, 140, 206, 187, 207, 133, 206, 188, 207,
    128, 206, 191, 207, 130, ' ', 206, 186, 206, 177, 206, 185,
    ' ', 207, 132, 206, 191, ' ', 206, 188, 206, 181, 206, 179,
    206, 177, 206, 187, 207, 141, 207, 132, 206, 181, 207, 129,
    206, 191, ' ', 207, 128, 206, 191, 207, 132, 206, 172, 206,
    188, 206, 185, ' ', 206, 191, ' ', 206, 145, 206, 187, 206,
    185, 206, 172, 206, 186, 206, 188, 206, 191, 206, 189, 206,
    177, 207, 130, '.',  13,  10,  13,  10, 206, 136, 207, 135,
    206, 181, 206, 185, ' ', 206, 188, 206, 177, 206, 186, 207,
    129, 206, 172, ' ', 206, 186, 206, 177, 206, 185, ' ', 207,
    128, 206, 187, 206, 191, 207, 141, 207, 131, 206, 185, 206,
    177, ' ', 206, 185, 207, 131, 207, 132, 206, 191, 207, 129,
    206, 175, 206, 177, ' ', 206, 186, 206, 177, 207, 132, 206,
    172, ' ', 207, 132, 206, 183, 206, 189, ' ', 206, 191, 207,
    128, 206, 191, 206, 175, 206, 177, ' ', 206, 172, 207, 131,
    206, 186, 206, 183, 207, 131, 206, 181, ' ', 206, 188, 206,
    181, 206, 179, 206, 172, 206, 187, 206, 183, ' ', 207, 128,
    206, 191, 206, 187, 206, 185, 207, 132, 206, 185, 207, 131,
    206, 188, 206, 185, 206, 186, 206, 174, ' ', 206, 181, 207,
    128, 206, 175, 206, 180, 207, 129, 206, 177, 207, 131, 206,
    183, ' ', 207, 131, 206, 181, ' ', 207, 132, 207, 129, 206,
    181, 206, 185, 207, 130, ' ', 206, 183, 207, 128, 206, 181,
    206, 175, 207, 129, 206, 191, 207, 133, 207, 130, '.', 206,
    149, 206, 180, 207, 142, ' ', 206, 179, 206, 181, 206, 189,
    206, 189, 206, 174, 206, 184, 206, 183, 206, 186, 206, 181,
    ' ', 206, 183, ' ', 206, 180, 206, 183, 206, 188, 206, 191,
    206, 186, 207, 129, 206, 177, 207, 132, 206, 175, 206, 177,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 183, ' ', 207,
    134, 206, 185, 206, 187, 206, 191, 207, 131, 206, 191, 207,
    134, 206, 175, 206, 177, '.', 206, 145, 206, 186, 207, 140,
    206, 188, 206, 188, 206, 177, ' ', 206, 183, ' ', 206, 149,
    206, 187, 206, 187, 206, 172, 206, 180, 206, 177, ' ', 206,
    181, 206, 175, 206, 189, 206, 177, 206, 185, ' ', 206, 191,
    ' ', 207, 132, 207, 140, 207, 128, 206, 191, 207, 130, ' ',
    206, 179, 206, 173, 206, 189, 206, 189, 206, 183, 207, 131,
    206, 183, 207, 130, ' ', 207, 132, 207, 137, 206, 189, ' ',
    206, 159, 206, 187, 207, 133, 206, 188, 207, 128, 206, 185,
    206, 177, 206, 186, 207, 142, 206, 189, ' ', 206, 145, 206,
    179, 207, 142, 206, 189, 207, 137, 206, 189, ',', 207, 132,
    206, 191, 207, 133, ' ', 206, 180, 207, 129, 206, 172, 206,
    188, 206, 177, 207, 132, 206, 191, 207, 130, ',', ' ', 207,
    132, 206, 183, 207, 130, ' ', 207, 132, 207, 129, 206, 177,
    206, 179, 207, 137, 206, 180, 206, 175, 206, 177, 207, 130,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 207, 132, 206, 183,
    207, 130, ' ', 206, 186, 207, 137, 206, 188, 206, 188, 207,
    137, 206, 180, 206, 175, 206, 177, 207, 130, ' ', '.',  13,
     10,  13,  10, 206, 151, ' ', 206, 149, 206, 187, 206, 187,
    206, 172, 206, 180, 206, 177, ' ', 206, 181, 206, 175, 206,
    189, 206, 177, 206, 185, ' ', 206, 188, 206, 173, 206, 187,
    206, 191, 207, 130, ' ', 207, 132, 207, 137, 206, 189, ' ',
    206, 149, 207, 133, 207, 129, 207, 137, 207, 128, 206, 177,
    207, 138, 206, 186, 207, 142, 206, 189, ' ', 206, 154, 206,
    191, 206, 185, 206, 189, 206, 191, 207, 132, 206, 174, 207,
    132, 207, 137, 206, 189, '/', 206, 149, 207, 133, 207, 129,
    207, 137, 207, 128, 206, 177, 207, 138, 206, 186, 206, 174,
    207, 130, ' ', 206, 136, 206, 189, 207, 137, 207, 131, 206,
    183, 207, 130, ' ', 206, 177, 207, 128, 207, 140, ' ', 207,
    132, 206, 191, ' ', '1', '9', '8', '1', ',', ' ', 207, 132,
    206, 183, 207, 130, ' ', 206, 149, 207, 133, 207, 129, 207,
    137, 206, 182, 207, 142, 206, 189, 206, 183, 207, 130, ' ',
    206, 177, 207, 128, 207, 140, ' ', 207, 132, 206, 191, ' ',
    '2', '0', '0', '1', ',', ' ', 207, 132, 206, 191, 207, 133,
    ' ', 206, 157, 206, 145, 206, 164, 206, 159, ' ', 206, 177,
    207, 128, 207, 140, ' ', 207, 132, 206, 191, ' ', '1', '9',
    '5', '2', ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 185,
    206, 180, 207, 129, 207, 133, 207, 132, 206, 185, 206, 186,
    207, 140, ' ', 206, 188, 206, 173, 206, 187, 206, 191, 207,
    130, ' ', 207, 132, 206, 191, 207, 133, ' ', 206, 159, 206,
    151, 206, 149, ' ', '(', '1', '9', '4', '5', ')', '.', ' ',
    206, 151, ' ', 206, 149, 206, 187, 206, 187, 206, 172, 206,
    180, 206, 177, ' ', 206, 181, 206, 175, 206, 189, 206, 177,
    206, 185, ' ', 206, 188, 206, 185, 206, 177, ' ', 206, 177,
    206, 189, 206, 181, 207, 128, 207, 132, 207, 133, 206, 179,
    206, 188, 206, 173, 206, 189, 206, 183, ' ', 207, 135, 207,
    142, 207, 129, 206, 177, ' ', 206, 188, 206, 181, ' ', 207,
    133, 207, 136, 206, 183, 206, 187, 207, 140, ' ', 206, 186,
    206, 177, 207, 132, 206, 172, ' ', 206, 186, 206, 181, 207,
    134, 206, 177, 206, 187, 206, 174, 206, 189, ' ', 206, 181,
    206, 185, 207, 131, 207, 140, 206, 180, 206, 183, 206, 188,
    206, 177, ' ', 206, 186, 206, 177, 206, 185, ' ', 207, 128,
    206, 191, 206, 187, 207, 141, ' ', 207, 133, 207, 136, 206,
    183, 206, 187, 207, 140, ' ', 206, 180, 206, 181, 206, 175,
    206, 186, 207, 132, 206, 183, ' ', 206, 177, 206, 189, 206,
    184, 207, 129, 207, 142, 207, 128, 206, 185, 206, 189, 206,
    183, 207, 130, ' ', 206, 177, 206, 189, 206, 172, 207, 128,
    207, 132, 207, 133, 206, 190, 206, 183, 207, 130, '.', ' ',
    206, 154, 206, 177, 207, 132, 206, 173, 207, 135, 206, 181,
    206, 185, ' ', 207, 132, 206, 183, 206, 189, ' ', '2', '2',
    206, 183, ' ', 206, 186, 206, 177, 206, 187, 207, 141, 207,
    132, 206, 181, 207, 129, 206, 183, ' ', 207, 128, 206, 191,
    206, 185, 207, 140, 207, 132, 206, 183, 207, 132, 206, 177,
    ' ', 206, 182, 207, 137, 206, 174, 207, 130, ' ', 207, 131,
    207, 132, 206, 191, 206, 189, ' ', 206, 186, 207, 140, 207,
    131, 206, 188, 206, 191, '.', '[', '4', ']',  13,  10,  13,
     10, 'R', 'a', 'n', 'd', 'o', 'm', ' ', 'Q', 'u', 'a', 'd',
    ' ', 'V', 'a', 'l', 'u', 'e', 's',  13,  10, 240, 144, 128,
    128, 240, 152, 166, 171, 240, 158, 187, 174, 240, 154, 170,
    170, 240, 154, 132, 163, 240, 155, 132, 163, 243, 187, 174,
    187, 244, 128, 128, 128, 243, 174, 187, 174, 242, 187, 174,
    187,  13,  10,   0
};

const char * const charUtf8MultiLang = (const char *) utf8MultiLang;

static
bsls::Types::Uint64 randAccum = 0;

/// MMIX Linear Congruential Generator algorithm by Donald Knuth
int absMmixRandNum()
{
    randAccum = randAccum * 6364136223846793005LL + 1442695040888963407LL;
    const int ret = static_cast<int>(randAccum >> 32);
    return ret & 0x7fffffff;
}

//=============================================================================
//                 HELPER FUNCTIONS FOR TESTING USAGE EXAMPLE
//-----------------------------------------------------------------------------

///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Basic Operations
///- - - - - - - - - - - - - -
// The following snippets of code illustrate basic and varied use of the
// `bslstl::StringRef` class.
//
// First, we define a function, `getNumBlanks`, that returns the number of
// blank (' ') characters contained in the string referenced by a specified
// `bslstl::StringRef`:
// ```
//  #include <algorithm>

    /// Return the number of blank (' ') characters in the string referenced
    /// by the specified `stringRef`.
    bslstl::StringRef::size_type
    getNumBlanks(const bslstl::StringRef& stringRef)
    {
#if defined(BSLS_LIBRARYFEATURES_STDCPP_LIBCSTD)
        // See <http://tinyurl.com/qz7blzp>.
        bslstl::StringRef::size_type n = 0;
        std::count(stringRef.begin(), stringRef.end(), ' ', n);
        return n;
#else
        return std::count(stringRef.begin(), stringRef.end(), ' ');
#endif
    }
// ```
// Notice that the function delegates the work to the `std::count` STL
// algorithm.  This delegation is made possible by the STL-compatible iterators
// provided by the `begin` and `end` accessors.

//=============================================================================
//                        GLOBAL FUNCTIONS FOR TESTING
//-----------------------------------------------------------------------------

/// Return `true` is `lhs` and `rhs` depict the same string and `false`
/// otherwise.
template <class CHAR_TYPE>
bool areEqual(const bsl::basic_string<CHAR_TYPE>& lhs,
              bsl::basic_string_view<CHAR_TYPE>   rhs)
{
    if (lhs.length() != rhs.length()) {
        return false;                                                 // RETURN
    }

    for (size_t ii = 0; ii < lhs.length(); ++ii) {
        if (lhs[ii] != rhs[ii]) {
            return false;                                             // RETURN
        }
    }

    return true;
}

/// Return `true` is `lhs` and `rhs` depict the same string and `false`
/// otherwise.
template <class CHAR_TYPE>
bool areEqual(const bsl::basic_string<CHAR_TYPE>& lhs,
              bslstl::StringRefImp<CHAR_TYPE>     rhs)
{
    if (lhs.length() != rhs.length()) {
        return false;                                                 // RETURN
    }

    for (size_t ii = 0; ii < lhs.length(); ++ii) {
        if (lhs[ii] != rhs[ii]) {
            return false;                                             // RETURN
        }
    }

    return true;
}

/// Print the specified `c`.  If `1 < sizeof(c)` and `notFirst`, precede it
/// with ", ".
template <class CHAR>
void printChar(CHAR c, bool notFirst)
{
    if (1 == sizeof(CHAR)) {
        if (0 < c && 0 == (c & 0x80)) {
            putchar(static_cast<char>(c));
        }
        else {
            printf("\\x%x", static_cast<int>(c & 0xff));
        }
    }
    else {
        const char *space = notFirst ? ", " : "";
        if (static_cast<CHAR>(-1) < 0) {
            printf("%s%d", space, static_cast<int>(c));
        }
        else {
            printf("%s%u", space, static_cast<unsigned>(c));
        }
    }
}

namespace BloombergLP {
namespace bslstl {

/// Print the specified `value`.
template <class CHAR>
void debugprint(const StringRefImp<CHAR>& value)
{
    BSLMF_ASSERT(sizeof(CHAR) <= sizeof(int));

    printf("{ ");
    for (size_t i = 0; i != value.length(); ++i) {
        printChar(value[i], 0 != i);
    }
    printf(" }");
}

}  // close package namespace
}  // close enterprise namespace

namespace bsl {

template <class CHAR>
void debugprint(const basic_string<CHAR>& value)
{
    BSLMF_ASSERT(sizeof(CHAR) <= sizeof(int));

    printf("{");
    for (size_t i = 0; i != value.length(); ++i) {
        printChar(value[i], 0 != i);
    }
    printf(" }");
}

}  // close namespace bsl

/// Return the specified `value` normalized to -1, 0, or +1 depending upon
/// whether value was negative, zero, or positive, respectively.
int normalizeCompare(int value)
{
    return value > 0
         ? +1
         : value < 0
         ? -1
         : 0;
}
// ============================================================================
//                 Test Case 11: Testing `bsl::string;;operator=`
// ----------------------------------------------------------------------------

/// Return constant string.
struct OpEqualsAssignTestA {
    operator const char *() const
    {
        return "OpEqualsAssignTestA -- loooooong string to provoke allocation";
    }
};

/// Return `StringRef` assembled from constant string.
struct OpEqualsAssignTestB {
    operator bslstl::StringRef() const
    {
        return "OpEqualsAssignTestB -- loooooong string to provoke allocation";
    }
};

// ============================================================================
//                     GLOBAL TEST DRIVER
// ----------------------------------------------------------------------------

/// Load the specified `result` with the specified `asciiInput`, where each
/// input character value is converted to the (template parameter) type
/// `CHAR_TYPE`.  The behavior is undefined unless `asciiInput` is a valid
/// null terminated ascii string.
void copyStringValue(char    *result, const char *asciiInput);
void copyStringValue(wchar_t *result, const char *asciiInput);

void copyStringValue(char *result, const char *asciiInput)
{
    strcpy(result, asciiInput);
}

void copyStringValue(wchar_t *result, const char *asciiInput)
{
    do {
        *result = *asciiInput;
        ++result;
        ++asciiInput;
    } while (*asciiInput);
}

/// Check constructors of the (themplate parameter) `TARGET` type for
/// ambiguity, passing the specified `source` as a parameter.
template <class TARGET, class SOURCE>
void testStringCtorsAmbiguityTemplate(const SOURCE& source)
{
    TARGET target(source);
    (void) target;
}

/// Check constructors of the `bsl::string` for ambiguity, passing the
/// specified `source` as a parameter.
void testStringCtorsAmbiguity(const bslstl::StringRefData<char>& source)
{
    bsl::basic_string<char> target(source);
    (void) target;
}

/// This function is used to check if implicit constructor of the
/// `bsl::string` is called to construct the specified `str`.
void testStringImplicitCtor(bsl::basic_string<char> str)
{
    (void) str;
}

/// This dummy class has an implicit conversion operator to
/// `bslstl::StringRefImp` to check if implicit constructor of the
/// `bsl::string` is called.
template <class CHAR_TYPE>
class ImplicitlyConvertibleToString {

  public:
    // CREATORS

    /// Create an object o fthis type.
    ImplicitlyConvertibleToString()
    {
    }

    // ACCESSORS

    /// Return an empty `StringRefImp` object.
    operator bslstl::StringRefImp<CHAR_TYPE>() const
    {
        const CHAR_TYPE *NULL_PTR = 0;
        return bslstl::StringRefImp<CHAR_TYPE>(NULL_PTR, 0);
    }
};

                 // =================================
                 // class ConvertibleToStringViewType
                 // =================================

/// This test class provides conversion operators to
/// `bsl::basic_string_view` object.  It is used for testing methods that
/// accept `StringViewLike` types.
template <class TYPE,
          class TRAITS = bsl::char_traits<TYPE> >
class ConvertibleToStringViewType
{
    // DATA
    const TYPE *d_value_p;  // value (held, not owned)

  public:
    // CREATORS

    /// Create an object that has the specified `value`.
    explicit ConvertibleToStringViewType(const TYPE *value);

    // ACCESSORS

    /// Convert this object to a `bsl::basic_string_view` object,
    /// instantiated with the same character type and traits type.  The
    /// return string will contain the same sequence of characters as this
    /// object.  Note that this conversion operator can be invoked
    /// implicitly (e.g., during argument passing).
    operator bsl::basic_string_view<TYPE, TRAITS>() const;

    /// Return the value of this object.
    const TYPE *data() const;

    /// Return the length of the underlying string.
    size_t length() const;
};

                 // ---------------------------------
                 // class ConvertibleToStringViewType
                 // ---------------------------------

// CREATORS
template <class TYPE, class TRAITS>
inline
ConvertibleToStringViewType<TYPE, TRAITS>::
ConvertibleToStringViewType(const TYPE *value)
: d_value_p(value)
{
}

// ACCESSORS
template <class TYPE, class TRAITS>
inline
ConvertibleToStringViewType<TYPE, TRAITS>::
operator bsl::basic_string_view<TYPE, TRAITS>() const
{
    return bsl::basic_string_view<TYPE, TRAITS>(d_value_p);
}

template <class TYPE, class TRAITS>
inline
const TYPE *ConvertibleToStringViewType<TYPE, TRAITS>::data() const
{
    return d_value_p;
}

template <class TYPE, class TRAITS>
inline
size_t ConvertibleToStringViewType<TYPE, TRAITS>::length() const
{
    return TRAITS::length(d_value_p);
}

class IncompleteType;
    // Incomplete class to check the correctness of the SFINAE conditions of
    // the `bsl::basic_string` template constructor.

/// This function is the first of a pair of overloads for a SFINAE check.
void overloadedFunction(const bsl::string&)
{
}

/// This function is the second of a pair of overloads for a SFINAE check.
void overloadedFunction(const IncompleteType&)
{
}

/// This function calls the overloaded function name with the specified
/// inclomplete `obj`.
void testIncompleteTypeConversion(const IncompleteType &obj)
{
    overloadedFunction(obj);
}

                            // ====================
                            // class ExceptionGuard
                            // ====================

/// This scoped guard helps to verify the full guarantee of rollback in
/// exception-throwing code.
template <class VALUE_TYPE>
struct ExceptionGuard {

    // DATA
    int               d_lineNum;
    VALUE_TYPE        d_value;
    const VALUE_TYPE *d_object_p;

  public:
    // CREATORS
    ExceptionGuard(const VALUE_TYPE &object, int line)
    : d_lineNum(line)
    , d_value(object)
    , d_object_p(&object)
    {}

    ~ExceptionGuard() {
        if (d_object_p) {
            const int LINE = d_lineNum;
            LOOP3_ASSERT(LINE, d_value, *d_object_p, d_value == *d_object_p);
        }
    }

    // MANIPULATORS
    void release() {
        d_object_p = 0;
    }

    void resetValue(const VALUE_TYPE& value, int line) {
        d_lineNum = line;
        d_value = value;
    }
};

template <class CHAR_TYPE>
class TestDriver {
    // TYPES

    /// Type under testing.
    typedef bslstl::StringRefImp<CHAR_TYPE> Obj;

    typedef bsl::basic_string<CHAR_TYPE> String;

    typedef typename String::allocator_type Allocator;

  public:

    /// Conversions between strings and string view-like types (moved from
    /// bslstl_string_test.t.cpp to prevent cycles).
    static void testCase15();

    /// Testing construction of string views and string refs from different
    /// types.
    static void testCase14();

    /// Testing reverse iterators.
    static void testCase10();

    /// Testing `StringRefImp(const StringRefImp& , size_type, size_type)`
    static void testCase9();

    /// Load the specified `values` with the address of an array containing
    /// initialized values of the parameterized `TYPE` and return the length
    /// of that array.
    static int getValues(const CHAR_TYPE **values);

    /// Using only primary manipulators, extend the length of the specified
    /// `object` by the specified `size` by adding copies of the optionally
    /// specified `value`, or with the null character for the (template
    /// parameter) `TYPE` if `value` is not specified.  The resulting value
    /// is not specified.
    static void stretch(String           *object,
                        size_t            size,
                        const CHAR_TYPE&  value = CHAR_TYPE());

    /// Using only primary manipulators, extend the capacity of the
    /// specified `object` to (at least) the specified `size` by adding
    /// copies of the optionally specified `value` or with the null
    /// character for the (template parameter) `TYPE` if `value` is not
    /// specified; then remove all elements leaving `object` empty.
    static void stretchRemoveAll(String           *object,
                                 size_t            size,
                                 const CHAR_TYPE&  value = CHAR_TYPE());

    /// Configure the specified `object` according to the specified `spec`,
    /// using only the primary manipulator function `push_back` and
    /// white-box manipulator `clear`.  Optionally specify a zero
    /// `verboseFlag` to suppress `spec` syntax error messages.  Return the
    /// index of the first invalid character, and a negative value
    /// otherwise.  Note that this function is used to implement `gg` as
    /// well as allow for verification of syntax error detection.
    static int ggg(String *object, const char *spec, int verboseFlag = 1);

    /// Return, by reference, the specified `object` with its value adjusted
    /// according to the specified `spec`.
    static String& gg(String *object, const char *spec);

    /// Return, by value, a new object corresponding to the specified
    /// `spec`.
    static String g(const char *spec);

    /// Return, by value, a new string object with the specified `length`
    /// and the specified `seed` character.  The actual content of the
    /// string is not important, only the string length and the fact that
    /// two different `seeds` produce two different results.
    static String g(size_t length, CHAR_TYPE seed);
};

template <class TYPE>
void TestDriver<TYPE>::testCase15()
{
    // --------------------------------------------------------------------
    // TESTING CONVERSION of `string_view` W.R.T. `std::basic_string`
    //
    // (This test was migrated here for bslstl_stringview.t.cpp to prevent
    // dependency cycles).
    //
    // Concerns:
    // 1. That it is possible to construct a `string_view` from a
    //    `std::string`.
    //
    // 2. That the source is not modified.
    //
    // 3. That the contents of the constructed object match the original
    //    string.
    //
    // 4. That a variety of string and string view types are constructible and
    //    assignable from each other.
    //
    // Plan:
    // 1. Using a few samples, create strings with those contents, create
    //    string views from them, and verify that the results are consistent.
    //
    // 2. Construct a variety of string-like objects and verify that they
    //    inter-convert properly with string views.
    // --------------------------------------------------------------------

    static const char *DATA[] = {
        "", "woof", "meow", "bow wow",
        "The rain in Spain falls mainly in the plain.",
        "By george, I think she's got it!" };
    enum { k_NUM_DATA = sizeof DATA / sizeof *DATA };

    for (int ti = 0; ti < k_NUM_DATA; ++ti) {
        const char *CHAR_STR = DATA[ti];
        const char *pc;
        TYPE        buffer[100], *pB;

        // Copy from `char` buffer to `TYPE` buffer.

        for (pB = buffer, pc = CHAR_STR; (*pB++ = *pc++); ) {
            ;  // do nothing
        }
        const size_t LEN = pB - 1 - buffer;
        ASSERT(0 == buffer[LEN]);

        pB = buffer;

        const std::basic_string<TYPE> str(pB);
        ASSERT(pB == str);
        const bsl::basic_string_view<TYPE> sv(str);
        ASSERT(pB == str);    // unchanged

        // Compare `sv` with `str`, they should match.

        ASSERT(str.length() == sv.length());
        ASSERT(!sv.data()[sv.length()]);

        for (unsigned ii = 0; ii < LEN; ++ii) {
            ASSERT(sv[ii] == str[ii]);
            ASSERT(sv[ii] == buffer[ii]);
        }

        if (LEN < 4) {
            continue;
        }

        // Now, do it over again with an embedded zero in the string.

        buffer[2] = 0;

        const std::basic_string<TYPE> zStr(pB, LEN);
        ASSERT(LEN == zStr.length());
        ASSERT(zStr != str);
        ASSERT(zStr[2] == 0);

        const std::basic_string<TYPE> zStrB(pB, LEN);
        ASSERT(LEN == zStrB.length());
        ASSERT(zStrB != str);
        ASSERT(zStrB[2] == 0);
        ASSERT(zStr == zStrB);

        const bsl::basic_string_view<TYPE> zSv(zStr);
        ASSERT(LEN == zSv.length());
        ASSERT(zSv.data() == zStr.data());
        ASSERT(zSv[2] == 0);

        ASSERT(LEN == zStr.length());  // unchanged
        ASSERT(zStr == zStrB);         // unchanged

        for (unsigned ii = 0; ii < LEN; ++ii) {
            ASSERT(zSv[ii] == zStr[ii]);
            ASSERT(zSv[ii] == buffer[ii]);
        }

        if (veryVerbose) printf("\tbsl::string vs. string_view\n");
        {
            bsl::basic_string<TYPE> s(pB, pB + LEN);
            bsl::basic_string_view<TYPE> v(s);
            ASSERT(v.data() == s.data());
            ASSERT(s == v);
            ASSERT(v == s);
            v = s;
            ASSERT(v.data() == s.data());
            bsl::basic_string<TYPE> o(v);
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
            o = v;
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
            o.assign(v);
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
        }

        if (veryVerbose) printf("\tstd::string vs. string_view\n");
        {
            std::basic_string<TYPE> s(pB, pB + LEN);
            bsl::basic_string_view<TYPE> v(s);
            ASSERT(v.data() == s.data());
            ASSERT(s == v);
            ASSERT(v == s);
            v = s;
            ASSERT(v.data() == s.data());
            std::basic_string<TYPE> o(v);
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
#ifdef BSLSTL_STRING_VIEW_IS_ALIASED
            // Will not work with `explicit string_view::operator std::string`
            // in our implementation.
            o = v;
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
            o.assign(v);
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
#endif
        }

        if (veryVerbose) printf("\tstd::string vs. string_view\n");
        {
            std::basic_string<TYPE> s(pB, pB + LEN);
            bsl::basic_string_view<TYPE> v(s);
            ASSERT(v.data() == s.data());
            ASSERT(s == v);
            ASSERT(v == s);
            v = s;
            ASSERT(v.data() == s.data());
            std::basic_string<TYPE> o(v);
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
#ifdef BSLSTL_STRING_VIEW_IS_ALIASED
            // Will not work with `explicit string_view::operator std::string`
            // in our implementation.
            o = v;
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
            o.assign(v);
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
#endif
        }

        if (veryVerbose) printf("\tStringRefImp vs. string_view\n");
        {
            bslstl::StringRefImp<TYPE> s(pB, pB + LEN);
            bsl::basic_string_view<TYPE> v(s);
            ASSERT(v.data() == s.data());
            ASSERT(s == v);
            ASSERT(v == s);
            v = s;
            ASSERT(v.data() == s.data());
            bslstl::StringRefImp<TYPE> o(v);
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
            o = v;
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
            o.assign(v);
            ASSERT(0 == memcmp(o.data(), v.data(), (LEN + 1) * sizeof(TYPE)));
        }

        if (veryVerbose) printf("\tStringRefData vs. string_view\n");
        {
            bslstl::StringRefData<TYPE> s(pB, pB + LEN);
            bsl::basic_string_view<TYPE> v(s);
            ASSERT(v.data() == s.data());
            ASSERT(s == v);
            ASSERT(v == s);
            v = s;
            ASSERT(v.data() == s.data());

            // `StringRefData` constructor from `bsl::basic_string_view` was
            // made explicit to solve the problem described in the
            // DRQS 173445931.  We still able to implicitly convert
            // `StringRefData` object to `bsl::basic_string_view` since it is
            // an upcasting conversion, but not vice versa.  So we have to
            // comment out the rest of the test.
            //
            //   bslstl::StringRefData<TYPE> o(v);
            //   ASSERT(0 == memcmp(o.data(),
            //                      v.data(),
            //                      (LEN + 1) * sizeof(TYPE)));
            //   o = v;
            //   ASSERT(0 == memcmp(o.data(),
            //                      v.data(),
            //                      (LEN + 1) * sizeof(TYPE)));
        }
    }
}

template <class CHAR_TYPE>
void TestDriver<CHAR_TYPE>::testCase14()
{
    // ------------------------------------------------------------------------
    // TESTING CONSTRUCTION AND STRING VIEWS
    //
    // Concern:
    // 1. That both `StringRefImp` and `bsl::string_view` are constructible
    //    from a variety of source types.
    //    - from `const CHAR_TYPE *`
    //
    //    - from `(const CHAR_TYPE *, size_t)`
    //
    //    - from `bsl::basic_string<CHAR_TYPE>`
    //
    //    - from `std::basic_string<CHAR_TYPE>`
    //
    //    - from another `const` object of the same type
    //
    // Plan:
    // 1. Have a function `areEqual` which will determine if a `basic_string`
    //    matches a `StringRefImp`, with an overload similarly comparing a
    //    `basic_string` with a `basic_string_view`.
    //
    // 2. Have a table containing a number of strings, some of which are too
    //    long to be stored in the short string optimization.
    //
    // 3. Iterate through the table.
    //
    // 4. Copy the string of `char` to a buffer of `CHAR_TYPE`.
    //
    // 5. With both `StringRefImp<CHAR_TYPE>` and
    //    `basic_string_view<CHAR_TYPE>`, construct from various types, then
    //    compare using `areEqual`:
    //    - from `const CHAR_TYPE *`
    //
    //    - from `(const CHAR_TYPE *, size_t)`
    //
    //    - from `bsl::basic_string<CHAR_TYPE>`
    //
    //    - from `std::basic_string<CHAR_TYPE>`
    //
    //    - from another `const` object of the same type
    //
    // 6. Compare the 5 objects created with `operator==` to ensure they're all
    //    identical.
    //
    // 7. Also create another object from a different string `arf` not in the
    //    table and test that `areEqual` indicates that it does not match other
    //    objects to test the accuracy of `areEqual`.
    //
    // Testing:
    //   bsl::string_view(const char *);
    //   bsl::string_view(const char *, size_t);
    //   bsl::string_view(const bsl::string&);
    //   bsl::string_view(const std::string&);
    //   bsl::string_view(const bsl::string_view&);
    // ------------------------------------------------------------------------

    if (verbose) printf("TESTING CONSTRUCTION AND STRING VIEWS: %s\n",
                                             bsls::NameOf<CHAR_TYPE>().name());

    bslma::TestAllocator ta;
    bslma::TestAllocator da;
    bslma::DefaultAllocatorGuard guard(&da);

    static const char *DATA[] = {
        "",
        "woof",
        "meow",
        "Weasel & the White Boy's Cool - Rickie Lee Jones",
        "Chuck E's in Love - Rickie Lee Jones",
        "Company - Rickie Lee Jones",
      ( "There are more things in heaven and Earth, Horatio, than are dreamt"
                                                    " of in your philosophy." )
    };
    enum { k_NUM_DATA = sizeof DATA / sizeof *DATA };

    for (unsigned ti = 0; ti < k_NUM_DATA; ++ti) {
        const char *C_STR_ORIG = DATA[ti];
        size_t      LEN        = strlen(C_STR_ORIG);

        ASSERT(LEN < 256);

        CHAR_TYPE buffer[256], *pB = buffer;
        const char *pc = C_STR_ORIG;
        while ((*pB++ = *pc++)) {
            ;    // do nothing
        }

        const CHAR_TYPE *C_STR = buffer;
        const CHAR_TYPE ARF[] = { 'a', 'r', 'f', 0 };

        const bsl::basic_string<CHAR_TYPE> str(C_STR, &ta);
        const std::basic_string<CHAR_TYPE> stdStr(C_STR);

        ASSERT(str    == stdStr);
        ASSERT(str    == C_STR);
        ASSERT(stdStr == C_STR);

        ASSERT(str    != ARF);
        ASSERT(stdStr != ARF);

        ASSERT(str.   length() == LEN);
        ASSERT(stdStr.length() == LEN);

        {
            typedef bslstl::StringRefImp<CHAR_TYPE> SR;

            const SR srCStr(C_STR);
            ASSERT(areEqual(str, srCStr));

            const SR srArf(ARF);
            ASSERT(!areEqual(str, srArf));

            const SR srCStrLen(C_STR, LEN);
            ASSERT(areEqual(str, srCStrLen));

            const SR srStr(str);
            ASSERT(areEqual(str, srStr));

            const SR srStdStr(stdStr);
            ASSERT(areEqual(str, srStdStr));

            const SR srCopy(srCStr);
            ASSERT(areEqual(str, srCopy));

            SR srs[] = { srCStr, srCStrLen, srStr, srStdStr, srCopy };
            enum { k_NUM_SRS = sizeof srs / sizeof *srs };

            for (int ii = 0; ii < k_NUM_SRS; ++ii) {
                const bsl::basic_string<CHAR_TYPE>        bs(srs[ii], &ta);

                ASSERT(bs == str);
                ASSERT(areEqual(bs, srs[ii]));

                for (int jj = 0; jj < k_NUM_SRS; ++jj) {
                    ASSERT(areEqual(bs, srs[jj]));
                }
                ASSERT(srArf != srs[ii]);
            }
        }

        {
            typedef bsl::basic_string_view<CHAR_TYPE> SV;

            const SV svCStr(C_STR);
            ASSERT(areEqual(str, svCStr));

            const SV svArf(ARF);
            ASSERT(!areEqual(str, svArf));

            const SV svCStrLen(C_STR, LEN);
            ASSERT(areEqual(str, svCStrLen));

            const SV svStr(str);
            ASSERT(areEqual(str, svStr));

            const SV svStdStr(stdStr);
            ASSERT(areEqual(str, svStdStr));

            const SV svCopy(svCStr);
            ASSERT(areEqual(str, svCopy));

            SV svs[] = { svCStr, svCStrLen, svStr, svStdStr, svCopy };
            enum { k_NUM_SVS = sizeof svs / sizeof *svs };

            for (int ii = 0; ii < k_NUM_SVS; ++ii) {
                const bsl::basic_string<CHAR_TYPE>        bs(svs[ii], &ta);

                ASSERT(bs == str);
                ASSERT(areEqual(bs, svs[ii]));
                ASSERT(!areEqual(bs, svArf));

                for (int jj = 0; jj < k_NUM_SVS; ++jj) {
                    ASSERT(areEqual(bs, svs[jj]));
                }
                ASSERT(svArf != svs[ii]);
            }
        }

        ASSERT(str    == stdStr);
        ASSERT(str    == C_STR);
        ASSERT(stdStr == C_STR);

        ASSERT(str    != ARF);
        ASSERT(stdStr != ARF);

        ASSERT(str.   length() == LEN);
        ASSERT(stdStr.length() == LEN);
    }

    ASSERT(0 == da.numAllocations());
    ASSERT(0 <  ta.numAllocations());
}

template <class CHAR_TYPE>
void TestDriver<CHAR_TYPE>::testCase10()
{
    // ------------------------------------------------------------------------
    // TESTING ITERATORS
    //
    // Concerns:
    // 1. When then string reference is default constructed or the bounded
    //    string is empty, then `rbegin()` compare equals to `rend()`.
    //
    // 2. The range `[rbegin(), rend())` contains all values inserted into the
    //    container in descending order.
    //
    //
    // Plan:
    //   We test the two concerns by manually constructing the appropriate
    //   string reference objects and verify the expected output and behavior.
    //   More exhaustive tests are not required because
    //   `const_reverse_iterator` is implemented by the (fully-tested)
    //   `bslstl_ReverseIterator`.
    //
    // Testing:
    //   const_reverse_iterator rbegin() const;
    //   const_reverse_iterator rend() const;
    // ------------------------------------------------------------------------

    if (verbose) std::cout << "\nTESTING REVERSE ITERATORS"
                           << "\n========================="
                           << std::endl;
    {
        // Default constructed value
        bslstl::StringRefImp<CHAR_TYPE> mX;
        const bslstl::StringRefImp<CHAR_TYPE>& X = mX;
        ASSERT(X.rbegin() == X.rend());

    }
    {
        // Empty string
        bslstl::StringRefImp<CHAR_TYPE> mX(
                                         TestData<CHAR_TYPE>::s_emptyString_p);
        const bslstl::StringRefImp<CHAR_TYPE>& X = mX;
        ASSERT(X.rbegin() == X.rend());
    }

    {
        // None-empty string
        bslstl::StringRefImp<CHAR_TYPE> mX(
            TestData<CHAR_TYPE>::s_nonEmptyString_p);
        const bslstl::StringRefImp<CHAR_TYPE>& X = mX;

        bslstl::StringRef::size_type i = X.length();

        for (typename bslstl::StringRefImp<CHAR_TYPE>::const_reverse_iterator
                                                            riter = X.rbegin();
             riter != X.rend(); ++riter) {
            ASSERT(TestData<CHAR_TYPE>::s_nonEmptyString_p[--i] == *riter);
        }

        ASSERT(0 == i);
    }
}

template <class CHAR_TYPE>
void TestDriver<CHAR_TYPE>::testCase9()
{
    // --------------------------------------------------------------------
    // TESTING: StringRefImp(const StringRefImp&, size_type, size_type)
    //
    // Concerns:
    //
    // 1. Supplying an empty string ref, and `startIndex` 0, `numCharacters`
    //    0, results in an empty string ref.
    //
    // 2. For a non empty string ref, the resulting string ref's `begin`
    //    iterator is at the same address as the `startIndex` character of the
    //    original string ref.
    //
    // 3. If `numCharacters` does next extend beyond the end of the original
    //    string ref, the resulting string ref is `numCharacters` in length.
    //
    // 4. If `numCharacters` extends beyond the end of the original string
    //    ref the resulting string ref is the tail of the original string ref.
    //
    // 5. QoI: Asserted precondition violations are detected when enabled.
    //
    // Plan:
    //
    // 1. Test with an empty string ref as input. (C-1)
    //
    // 2. Test a non-empty input through all possible start indices. (C-2)
    //
    // 3. Test a non-empty input through all possible lengths of the input and
    //    beyond the end of the input range. (C-3,4)
    //
    // 4. Test a non-empty input through possibly start indices and lengths (a
    //    cross product of tests 2 & 3). (C-2..4)
    //
    // 5. Test the asserted preconditions using the `BSLS_ASSERTTEST_*`
    //    macros. (C-5)
    //
    // Testing:
    //   StringRefImp(const StringRefImp&, size_type, size_type)
    //--------------------------------------------------------------------


    if (verbose) printf("\tTest empty string\n");
    {
        Obj x;              const Obj& X = x;
        Obj y(X, 0, 0);     const Obj& Y = y;
        Obj z(X, 0, 32768); const Obj& Z = z;

        ASSERT(Y.isEmpty());
        ASSERT(Z.isEmpty());
    }

    if (verbose) printf("\tTest various values for `startIndex`\n");
    {
        const char value[] = "abcdefg";
        CHAR_TYPE  input[sizeof(value)];
        copyStringValue(input, value);

        const std::size_t LENGTH = sizeof(value);

        Obj original(input, LENGTH); const Obj& ORIGINAL = original;
        for (std::size_t i = 0; i <= LENGTH; ++i) {
            Obj x(ORIGINAL, i, INT_MAX); const Obj& X = x;

            ASSERT(ORIGINAL.begin() + i == X.begin());
            ASSERT(ORIGINAL.end()       == X.end());

            if (veryVerbose && i!= LENGTH) {
                P_(i); P_(ORIGINAL[i]); P(*X.begin());
            }
            else if (veryVerbose) {
                P(i);
            }
        }
    }

    if (verbose) printf("\tTest various values for `numCharacters`\n");
    {
        const char value[] = "abcdefg";
        CHAR_TYPE  input[sizeof(value)];
        copyStringValue(input, value);

        const std::size_t LENGTH = sizeof(value);

        Obj original(input, LENGTH); const Obj& ORIGINAL = original;
        for (std::size_t i = 0; i < LENGTH; ++i) {
            Obj x(ORIGINAL, 0, i); const Obj& X = x;

            ASSERT(ORIGINAL.begin() == X.begin());
            ASSERT(ORIGINAL.end()   == X.end() + (ORIGINAL.length() - i));

            if (veryVerbose) {
                P_(i); P_(ORIGINAL.length()); P(X.length())
            }
        }
        for (std::size_t i = LENGTH; i < LENGTH + 10; ++i) {
            Obj x(ORIGINAL, 0, i); const Obj& X = x;

            ASSERT(ORIGINAL.begin() == X.begin());
            ASSERT(ORIGINAL.end()   == X.end());

            if (veryVerbose) {
                P_(i); P_(ORIGINAL.length()); P(X.length())
            }

        }
        {
            // Test INT_MAX
            Obj x(ORIGINAL, 0, INT_MAX); const Obj& X = x;

            ASSERT(ORIGINAL.begin() == X.begin());
            ASSERT(ORIGINAL.end()   == X.end());

            if (veryVerbose) {
                P_(ORIGINAL.length()); P(X.length())
            }

        }
    }

    if (verbose) printf("\tTest both `startIndex` and `numCharacters`\n");
    {
        const char value[] = "abcdefg";
        CHAR_TYPE  input[sizeof(value)];
        copyStringValue(input, value);

        const std::size_t LENGTH = sizeof(value);
        Obj original(input, LENGTH); const Obj& ORIGINAL = original;

        for (std::size_t startIdx = 0; startIdx <= LENGTH; ++startIdx) {
            for (std::size_t length = 0; length < LENGTH + 1; ++length){

                Obj x(ORIGINAL, startIdx, length); const Obj& X = x;

                ASSERT(ORIGINAL.begin() + startIdx == X.begin());
                if (startIdx + length < LENGTH) {
                    ASSERT(ORIGINAL.end() ==
                           X.end() + LENGTH - (length + startIdx));
                }
                else {
                    ASSERT(ORIGINAL.end() == X.end());
                }

                if (veryVerbose && startIdx != LENGTH) {
                    P_(startIdx); P_(length);
                    P_(ORIGINAL[startIdx]); P_(*X.begin()); P(X.length())
                }
                else if (veryVerbose) {
                    P_(startIdx); P_(length); P(X.length())

                }
            }
        }
    }

    if (verbose) printf("\tNegative Testing.\n");
    {
        bsls::AssertTestHandlerGuard hG;

        const char value[] = "abcdefg";
        CHAR_TYPE  input[sizeof(value)];
        copyStringValue(input, value);
        const std::size_t LENGTH = sizeof(value);

        Obj original(input, LENGTH); const Obj& ORIGINAL = original;

        if (verbose) printf("\tNegative testing `startIndex <= or.length`.\n");
        {
            ASSERT_SAFE_PASS_RAW(Obj(ORIGINAL, ORIGINAL.length(), 0));
#ifdef BSLS_PLATFORM_CMP_GNU
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Warray-bounds="
  // gcc does not understand that `BSLS_ASSERT_SAFE` here throws and gives a
  // warning for essentially unreachable code.
  //
  // array subscript 9 is outside array bounds of 'char [8]'
#endif
            ASSERT_SAFE_FAIL_RAW(Obj(ORIGINAL, ORIGINAL.length() + 1, 0));
#ifdef BSLS_PLATFORM_CMP_GNU
  #pragma GCC diagnostic pop
#endif
        }
    }
}

                               // --------------
                               // TEST APPARATUS
                               // --------------

template <class CHAR_TYPE>
void TestDriver<CHAR_TYPE>::stretch(String           *object,
                                    size_t            size,
                                    const CHAR_TYPE&  value)
{
    ASSERT(object);
    for (size_t i = 0; i < size; ++i) {
        object->push_back(value);
    }
    ASSERT(object->size() >= size);
}

template <class CHAR_TYPE>
void TestDriver<CHAR_TYPE>::stretchRemoveAll(String      *object,
                                             size_t       size,
                                             const CHAR_TYPE&  value)
{
    ASSERT(object);
    stretch(object, size, value);
    object->clear();
    ASSERT(0 == object->size());
}

template <class CHAR_TYPE>
int TestDriver<CHAR_TYPE>::getValues(const CHAR_TYPE **values)
{
    bslma::DefaultAllocatorGuard guard(
                                      &bslma::NewDeleteAllocator::singleton());

    const int NUM_VALUES = 12;
    static const CHAR_TYPE initValues[NUM_VALUES] = {
        CHAR_TYPE(VA),
        CHAR_TYPE(VB),
        CHAR_TYPE(VC),
        CHAR_TYPE(VD),
        CHAR_TYPE(VE),
        CHAR_TYPE(VF),
        CHAR_TYPE(VG),
        CHAR_TYPE(VH),
        CHAR_TYPE(VI),
        CHAR_TYPE(VJ),
        CHAR_TYPE(VK),
        CHAR_TYPE(VL)
    };

    *values = initValues;
    return NUM_VALUES;
}

template <class CHAR_TYPE>
int TestDriver<CHAR_TYPE>::ggg(String     *object,
                               const char *spec,
                               int         verboseFlag)
{
    const CHAR_TYPE *VALUES;
    getValues(&VALUES);
    enum { SUCCESS = -1 };
    for (int i = 0; spec[i]; ++i) {
        if ('A' <= spec[i] && spec[i] <= 'L') {
            object->push_back(VALUES[spec[i] - 'A']);
        }
        else if ('~' == spec[i]) {
            object->clear();
        }
        else {
            if (verboseFlag) {
                printf("Error, bad character ('%c') "
                       "in spec \"%s\" at position %d.\n", spec[i], spec, i);
            }
            return i;  // Discontinue processing this spec.           // RETURN
        }
   }
   return SUCCESS;
}

template <class CHAR_TYPE>
bsl::basic_string<CHAR_TYPE>&
TestDriver<CHAR_TYPE>::gg(String *object, const char *spec)
{
    ASSERT(ggg(object, spec) < 0);
    return *object;
}

template <class CHAR_TYPE>
bsl::basic_string<CHAR_TYPE>
TestDriver<CHAR_TYPE>::g(const char *spec)
{
    String object((bslma::Allocator *)0);
    return gg(&object, spec);
}

template <class CHAR_TYPE>
bsl::basic_string<CHAR_TYPE>
TestDriver<CHAR_TYPE>::g(size_t length, CHAR_TYPE seed)
{
    String object(length, CHAR_TYPE());

    for (size_t i = 0; i < length; ++i) {
        object[i] = CHAR_TYPE(i + seed);
    }

    return object;
}

namespace BloombergLP {
namespace comparisons {
namespace {

template <class CHAR>
const CHAR *ptrFunction(const CHAR *string)
{
    return string;
}

/// Test all the accessor methods, especially including both `compare`
/// methods, and test all free comparison operators between `bsl::string`s,
/// `std::strings`s, `StringRefImp`s, and `const CHAR *`s.
template <class CHAR>
void testAccessorsComparisons()
{
    const char *charTypeName = bsls::NameOf<CHAR>();

    if (verbose) std::cout << "TESTING ACCESSORS AND COMPARISONS: "
                           <<  charTypeName << "\n"
                              "=================================\n";

    // We test to ensure that all comparisons between `basic_strings`,
    // `StringRefImp`s, and `const CHAR *`s yield matching results.
    // We have no strings with embedded '\0's in this example.

    if (verbose) {
        const CHAR minChar = *TestData<CHAR>::minStringFunc();
        const CHAR maxChar = *TestData<CHAR>::maxStringFunc();

        P_(minChar);    P(maxChar);
    }

    static struct Data {
        const int   d_line;
        const CHAR *d_str_p;
        const int   d_len;    // -2:  default construct string & string ref
                              // -1:  pass pointer but no length to string
                              //      constructor
                              // non -ve: pass pointer and length to string
                              //          constructor
    } DATA[] = {
        { L_, TestData<CHAR>::emptyStringFunc(),    -1 },
        { L_, TestData<CHAR>::emptyStringFunc(),    -2 },
        { L_, TestData<CHAR>::nonEmptyStringFunc(), -1 },
        { L_, TestData<CHAR>::nonEmptyStringFunc(), 10 },
        { L_, TestData<CHAR>::stringValue1Func(),    0 },
        { L_, TestData<CHAR>::stringValue1Func(),   -1 },
        { L_, TestData<CHAR>::stringValue1Func(),    3 },
        { L_, TestData<CHAR>::stringValue2Func(),   -1 },
        { L_, TestData<CHAR>::stringValue2Func(),    3 },
        { L_, TestData<CHAR>::maxStringFunc(),      -1 },
        { L_, TestData<CHAR>::minStringFunc(),      -1 }
    };
    enum { k_NUM_DATA = sizeof DATA / sizeof *DATA };

    for (int ti = 0; ti < k_NUM_DATA; ++ti) {
        const Data& idata = DATA[ti];
        const int   IL    = idata.d_line;
        const CHAR *IPC   = idata.d_str_p;
        const int   ILEN  = idata.d_len;

        const bsl::basic_string<CHAR>& IS =
                                       -2 == ILEN
                                       ? bsl::basic_string<CHAR>()
                                       : -1 == ILEN
                                       ? bsl::basic_string<CHAR>(IPC)
                                       : bsl::basic_string<CHAR>(IPC, ILEN);

#define ISF bsl::basic_string<CHAR>(IPC)

        const std::basic_string<CHAR>& INS =
                                       -2 == ILEN
                                       ? std::basic_string<CHAR>()
                                       : -1 == ILEN
                                       ? std::basic_string<CHAR>(IPC)
                                       : std::basic_string<CHAR>(IPC, ILEN);

#define INF std::basic_string<CHAR>(IPC)

        const bslstl::StringRefImp<CHAR>& ISR =
                                       -2 == ILEN
                                       ? bslstl::StringRefImp<CHAR>()
                                       : -1 == ILEN
                                       ? bslstl::StringRefImp<CHAR>(IPC)
                                       : bslstl::StringRefImp<CHAR>(IPC, ILEN);

#define IRF bslstl::StringRefImp<CHAR>(IPC)

        const bsl::basic_string_view<CHAR>& ISV =
                                     -2 == ILEN
                                     ? bsl::basic_string_view<CHAR>()
                                     : -1 == ILEN
                                     ? bsl::basic_string_view<CHAR>(IPC)
                                     : bsl::basic_string_view<CHAR>(IPC, ILEN);

#define IVF bsl::basic_string_view<CHAR>(IPC)

#define IPF ptrFunction(IPC)

        const bsl::basic_string<CHAR> ICOPY(IS);
        if (0 <= ILEN) {
            IPC = ICOPY.c_str();
        }

        if (veryVerbose) { std::cout << "Testing:";    P_(IL);    P(IS); }
        {
            const std::size_t ACTUAL_LEN =
                              -2 == ILEN
                              ? 0
                              : -1 == ILEN
                              ? std::char_traits<CHAR>::length(IPC)
                              : ILEN;

            // Test all the named accessors:

            if (-2 == ILEN) {
                ASSERTV(IL, IS, ISR.begin() == 0);
                ASSERTV(IL, IS, ISR.data()  == 0);
                ASSERTV(IL, IS, ISR.end()   == 0);
            }
            else {
                ASSERTV(IL, IS, ISR.begin() == idata.d_str_p);
                ASSERTV(IL, IS, ISR.data()  == idata.d_str_p);
                ASSERTV(IL, IS, ISR.end()   == idata.d_str_p + ACTUAL_LEN);
            }
            ASSERTV(IL, IS, ISR.data()   == ISR.begin());
            ASSERTV(IL, IS, ISR.length() == ACTUAL_LEN);
            ASSERTV(IL, IS, ISR.size()   == ACTUAL_LEN);
            ASSERTV(IL, IS, (ACTUAL_LEN == 0) == ISR.isEmpty());
            ASSERTV(IL, IS, (ACTUAL_LEN == 0) == ISR.empty());

            // Test `operator[]`:

            for (std::size_t ii = 0; ii < ACTUAL_LEN; ++ii) {
                ASSERTV(IL, IS, ii, IPC[ii], ISR[ii], IPC[ii] == ISR[ii]);
            }
        }

        for (int tj = 0; tj < k_NUM_DATA; ++tj) {
            const Data& jdata = DATA[tj];
            const int   JL    = jdata.d_line;
            const CHAR *JPC   = jdata.d_str_p;
            const int   JLEN  = jdata.d_len;

            const bsl::basic_string<CHAR>& JS =
                                       -2 == JLEN
                                       ? bsl::basic_string<CHAR>()
                                       : -1 == JLEN
                                       ? bsl::basic_string<CHAR>(JPC)
                                       : bsl::basic_string<CHAR>(JPC, JLEN);

#define JSF bsl::basic_string<CHAR>(JPC)

            const std::basic_string<CHAR>& JNS =
                                       -2 == JLEN
                                       ? std::basic_string<CHAR>()
                                       : -1 == JLEN
                                       ? std::basic_string<CHAR>(JPC)
                                       : std::basic_string<CHAR>(JPC, JLEN);

#define JNF std::basic_string<CHAR>(JPC)

            const bslstl::StringRefImp<CHAR>& JSR =
                                       -2 == JLEN
                                       ? bslstl::StringRefImp<CHAR>()
                                       : -1 == JLEN
                                       ? bslstl::StringRefImp<CHAR>(JPC)
                                       : bslstl::StringRefImp<CHAR>(JPC, JLEN);

#define JRF bslstl::StringRefImp<CHAR>(JPC)

            const bsl::basic_string_view<CHAR>& JSV =
                                     -2 == JLEN
                                     ? bsl::basic_string_view<CHAR>()
                                     : -1 == JLEN
                                     ? bsl::basic_string_view<CHAR>(JPC)
                                     : bsl::basic_string_view<CHAR>(JPC, JLEN);

#define JVF bsl::basic_string_view<CHAR>(JPC)

#define JPF ptrFunction(JPC)

            const bsl::basic_string<CHAR> JCOPY(JS);
            if (0 <= JLEN) {
                JPC = JCOPY.c_str();
            }

            const bool EQ = IS == JS, NE = !EQ;
            const bool LT = IS <  JS, GE = !LT;
            const bool GT = IS >  JS, LE = !GT;

            if (veryVeryVerbose) {
                std::cout << "J values:"; P_(JL); P_(JS);
                P_(EQ);    P_(LT);    P(GT);
            }

            ASSERTV(IL, JL, IS, JS, EQ, IL != JL || EQ);

            // Call the two `compare` methods directly:

            typedef bslstl::StringRefImp_CompareUtil CUtil;

            int COMPARE_PC = CUtil::compare(ISR, JPC);
            int COMPARE_SR = ISR.compare(JSR);

            const bool COMPARE_EQ_PC = CUtil::compareEqual(ISR, JPC);
            const bool COMPARE_EQ_SR = CUtil::compareEqual(ISR, JSR);

            ASSERTV(IL, JL, IS, JS, EQ == (COMPARE_PC == 0));
            ASSERTV(IL, JL, IS, JS, EQ == (COMPARE_SR == 0));

            ASSERTV(IL, JL, IS, JS, EQ == COMPARE_EQ_PC);
            ASSERTV(IL, JL, IS, JS, EQ == COMPARE_EQ_SR);

            ASSERTV(IL, JL, IS, JS, NE == (COMPARE_PC != 0));
            ASSERTV(IL, JL, IS, JS, NE == (COMPARE_SR != 0));

            ASSERTV(IL, JL, IS, JS, NE == !COMPARE_EQ_PC);
            ASSERTV(IL, JL, IS, JS, NE == !COMPARE_EQ_SR);

            ASSERTV(IL, JL, IS, JS, LT == (COMPARE_PC <  0));
            ASSERTV(IL, JL, IS, JS, LT == (COMPARE_SR <  0));

            ASSERTV(IL, JL, IS, JS, GE == (COMPARE_PC >= 0));
            ASSERTV(IL, JL, IS, JS, GE == (COMPARE_SR >= 0));

            ASSERTV(IL, JL, IS, JS, GT == (COMPARE_PC >  0));
            ASSERTV(IL, JL, IS, JS, GT == (COMPARE_SR >  0));

            ASSERTV(IL, JL, IS, JS, LE == (COMPARE_PC <= 0));
            ASSERTV(IL, JL, IS, JS, LE == (COMPARE_SR <= 0));

            // Normalize `COMPARE_PC` & `COMPARE_SR` to +1, -1, or 0, at which
            // point they should be equal, if they weren't equal to begin with.

            COMPARE_PC = normalizeCompare(COMPARE_PC);
            COMPARE_SR = normalizeCompare(COMPARE_SR);

            ASSERTV(IL, JL, IS, JS, COMPARE_PC, COMPARE_SR,
                                                     COMPARE_PC == COMPARE_SR);


            // `operator==`

            ASSERTV(IL, JL, IS, JS, EQ, (IS  == JPC), EQ == (IS  == JPC));
            ASSERTV(IL, JL, IS, JS, EQ, (IS  == JS),  EQ == (IS  == JS));
            ASSERTV(IL, JL, IS, JS, EQ, (IS  == JNS), EQ == (IS  == JNS));
            ASSERTV(IL, JL, IS, JS, EQ, (IS  == JSR), EQ == (IS  == JSR));
            ASSERTV(IL, JL, IS, JS, EQ, (IS  == JSV), EQ == (IS  == JSV));

            ASSERTV(IL, JL, IS, JS, EQ, (INS == JPC), EQ == (INS == JPC));
            ASSERTV(IL, JL, IS, JS, EQ, (INS == JS),  EQ == (INS == JS));
            ASSERTV(IL, JL, IS, JS, EQ, (INS == JNS), EQ == (INS == JNS));
            ASSERTV(IL, JL, IS, JS, EQ, (INS == JSR), EQ == (INS == JSR));
            ASSERTV(IL, JL, IS, JS, EQ, (INS == JSV), EQ == (INS == JSV));

            ASSERTV(IL, JL, IS, JS, EQ, (ISR == JPC), EQ == (ISR == JPC));
            ASSERTV(IL, JL, IS, JS, EQ, (ISR == JS),  EQ == (ISR == JS));
            ASSERTV(IL, JL, IS, JS, EQ, (ISR == JNS), EQ == (ISR == JNS));
            ASSERTV(IL, JL, IS, JS, EQ, (ISR == JSR), EQ == (ISR == JSR));
            ASSERTV(IL, JL, IS, JS, EQ, (ISR == JSV), EQ == (ISR == JSV));

            ASSERTV(IL, JL, IS, JS, EQ, (ISV == JPC), EQ == (ISV == JPC));
            ASSERTV(IL, JL, IS, JS, EQ, (ISV == JS),  EQ == (ISV == JS));
            ASSERTV(IL, JL, IS, JS, EQ, (ISV == JNS), EQ == (ISV == JNS));
            ASSERTV(IL, JL, IS, JS, EQ, (ISV == JSR), EQ == (ISV == JSR));
            ASSERTV(IL, JL, IS, JS, EQ, (ISV == JSV), EQ == (ISV == JSV));

            ASSERTV(IL, JL, IS, JS, EQ, (IPC == JNS), EQ == (IPC == JS));
            ASSERTV(IL, JL, IS, JS, EQ, (IPC == JS),  EQ == (IPC == JNS));
            ASSERTV(IL, JL, IS, JS, EQ, (IPC == JSR), EQ == (IPC == JSR));
            ASSERTV(IL, JL, IS, JS, EQ, (IPC == JSV), EQ == (IPC == JSV));

            // `operator!=`

            ASSERTV(IL, JL, IS, JS, NE, (IS  != JPC), NE == (IS  != JPC));
            ASSERTV(IL, JL, IS, JS, NE, (IS  != JS),  NE == (IS  != JS));
            ASSERTV(IL, JL, IS, JS, NE, (IS  != JNS), NE == (IS  != JNS));
            ASSERTV(IL, JL, IS, JS, NE, (IS  != JSR), NE == (IS  != JSR));
            ASSERTV(IL, JL, IS, JS, NE, (IS  != JSV), NE == (IS  != JSV));

            ASSERTV(IL, JL, IS, JS, NE, (INS != JPC), NE == (INS != JPC));
            ASSERTV(IL, JL, IS, JS, NE, (INS != JS),  NE == (INS != JS));
            ASSERTV(IL, JL, IS, JS, NE, (INS != JNS), NE == (INS != JNS));
            ASSERTV(IL, JL, IS, JS, NE, (INS != JSR), NE == (INS != JSR));
            ASSERTV(IL, JL, IS, JS, NE, (INS != JSV), NE == (INS != JSV));

            ASSERTV(IL, JL, IS, JS, NE, (ISR != JPC), NE == (ISR != JPC));
            ASSERTV(IL, JL, IS, JS, NE, (ISR != JS),  NE == (ISR != JS));
            ASSERTV(IL, JL, IS, JS, NE, (ISR != JNS), NE == (ISR != JNS));
            ASSERTV(IL, JL, IS, JS, NE, (ISR != JSR), NE == (ISR != JSR));
            ASSERTV(IL, JL, IS, JS, NE, (ISR != JSV), NE == (ISR != JSV));

            ASSERTV(IL, JL, IS, JS, NE, (ISV != JPC), NE == (ISV != JPC));
            ASSERTV(IL, JL, IS, JS, NE, (ISV != JS),  NE == (ISV != JS));
            ASSERTV(IL, JL, IS, JS, NE, (ISV != JNS), NE == (ISV != JNS));
            ASSERTV(IL, JL, IS, JS, NE, (ISV != JSR), NE == (ISV != JSR));
            ASSERTV(IL, JL, IS, JS, NE, (ISV != JSV), NE == (ISV != JSV));

            ASSERTV(IL, JL, IS, JS, NE, (IPC != JS),  NE == (IPC != JS));
            ASSERTV(IL, JL, IS, JS, NE, (IPC != JNS), NE == (IPC != JNS));
            ASSERTV(IL, JL, IS, JS, NE, (IPC != JSR), NE == (IPC != JSR));
            ASSERTV(IL, JL, IS, JS, NE, (IPC != JSV), NE == (IPC != JSV));

            // `operator<`

            ASSERTV(IL, JL, IS, JS, LT, (IS  <  JPC), LT == (IS  <  JPC));
            ASSERTV(IL, JL, IS, JS, LT, (IS  <  JS),  LT == (IS  <  JS));
            ASSERTV(IL, JL, IS, JS, LT, (IS  <  JNS), LT == (IS  <  JNS));
            ASSERTV(IL, JL, IS, JS, LT, (IS  <  JSR), LT == (IS  <  JSR));
            ASSERTV(IL, JL, IS, JS, LT, (IS  <  JSV), LT == (IS  <  JSV));

            ASSERTV(IL, JL, IS, JS, LT, (INS <  JPC), LT == (INS <  JPC));
            ASSERTV(IL, JL, IS, JS, LT, (INS <  JS),  LT == (INS <  JS));
            ASSERTV(IL, JL, IS, JS, LT, (INS <  JNS), LT == (INS <  JNS));
            ASSERTV(IL, JL, IS, JS, LT, (INS <  JSR), LT == (INS <  JSR));
            ASSERTV(IL, JL, IS, JS, LT, (INS <  JSV), LT == (INS <  JSV));

            ASSERTV(IL, JL, IS, JS, LT, (ISR <  JPC), LT == (ISR <  JPC));
            ASSERTV(IL, JL, IS, JS, LT, (ISR <  JS),  LT == (ISR <  JS));
            ASSERTV(IL, JL, IS, JS, LT, (ISR <  JNS), LT == (ISR <  JNS));
            ASSERTV(IL, JL, IS, JS, LT, (ISR <  JSR), LT == (ISR <  JSR));
            ASSERTV(IL, JL, IS, JS, LT, (ISR <  JSV), LT == (ISR <  JSV));

            ASSERTV(IL, JL, IS, JS, LT, (ISV <  JPC), LT == (ISV <  JPC));
            ASSERTV(IL, JL, IS, JS, LT, (ISV <  JS),  LT == (ISV <  JS));
            ASSERTV(IL, JL, IS, JS, LT, (ISV <  JNS), LT == (ISV <  JNS));
            ASSERTV(IL, JL, IS, JS, LT, (ISV <  JSR), LT == (ISV <  JSR));
            ASSERTV(IL, JL, IS, JS, LT, (ISV <  JSV), LT == (ISV <  JSV));

            ASSERTV(IL, JL, IS, JS, LT, (IPC <  JS),  LT == (IPC <  JS));
            ASSERTV(IL, JL, IS, JS, LT, (IPC <  JNS), LT == (IPC <  JNS));
            ASSERTV(IL, JL, IS, JS, LT, (IPC <  JSR), LT == (IPC <  JSR));
            ASSERTV(IL, JL, IS, JS, LT, (IPC <  JSV), LT == (IPC <  JSV));

            // `operator>=`

            ASSERTV(IL, JL, IS, JS, GE, (IS  >= JPC), GE == (IS  >= JPC));
            ASSERTV(IL, JL, IS, JS, GE, (IS  >= JS),  GE == (IS  >= JS));
            ASSERTV(IL, JL, IS, JS, GE, (IS  >= JNS), GE == (IS  >= JNS));
            ASSERTV(IL, JL, IS, JS, GE, (IS  >= JSR), GE == (IS  >= JSR));
            ASSERTV(IL, JL, IS, JS, GE, (IS  >= JSV), GE == (IS  >= JSV));

            ASSERTV(IL, JL, IS, JS, GE, (INS >= JPC), GE == (INS >= JPC));
            ASSERTV(IL, JL, IS, JS, GE, (INS >= JS),  GE == (INS >= JS));
            ASSERTV(IL, JL, IS, JS, GE, (INS >= JNS), GE == (INS >= JNS));
            ASSERTV(IL, JL, IS, JS, GE, (INS >= JSR), GE == (INS >= JSR));
            ASSERTV(IL, JL, IS, JS, GE, (INS >= JSV), GE == (INS >= JSV));

            ASSERTV(IL, JL, IS, JS, GE, (ISR >= JPC), GE == (ISR >= JPC));
            ASSERTV(IL, JL, IS, JS, GE, (ISR >= JS),  GE == (ISR >= JS));
            ASSERTV(IL, JL, IS, JS, GE, (ISR >= JNS), GE == (ISR >= JNS));
            ASSERTV(IL, JL, IS, JS, GE, (ISR >= JSR), GE == (ISR >= JSR));
            ASSERTV(IL, JL, IS, JS, GE, (ISR >= JSV), GE == (ISR >= JSV));

            ASSERTV(IL, JL, IS, JS, GE, (ISV >= JPC), GE == (ISV >= JPC));
            ASSERTV(IL, JL, IS, JS, GE, (ISV >= JS),  GE == (ISV >= JS));
            ASSERTV(IL, JL, IS, JS, GE, (ISV >= JNS), GE == (ISV >= JNS));
            ASSERTV(IL, JL, IS, JS, GE, (ISV >= JSR), GE == (ISV >= JSR));
            ASSERTV(IL, JL, IS, JS, GE, (ISV >= JSV), GE == (ISV >= JSV));

            ASSERTV(IL, JL, IS, JS, GE, (IPC >= JS),  GE == (IPC >= JS));
            ASSERTV(IL, JL, IS, JS, GE, (IPC >= JNS), GE == (IPC >= JNS));
            ASSERTV(IL, JL, IS, JS, GE, (IPC >= JSR), GE == (IPC >= JSR));
            ASSERTV(IL, JL, IS, JS, GE, (IPC >= JSV), GE == (IPC >= JSV));

            // `operator>`

            ASSERTV(IL, JL, IS, JS, GT, (IS  >  JPC), GT == (IS  >  JPC));
            ASSERTV(IL, JL, IS, JS, GT, (IS  >  JS),  GT == (IS  >  JS));
            ASSERTV(IL, JL, IS, JS, GT, (IS  >  JNS), GT == (IS  >  JNS));
            ASSERTV(IL, JL, IS, JS, GT, (IS  >  JSR), GT == (IS  >  JSR));
            ASSERTV(IL, JL, IS, JS, GT, (IS  >  JSV), GT == (IS  >  JSV));

            ASSERTV(IL, JL, IS, JS, GT, (INS >  JPC), GT == (INS >  JPC));
            ASSERTV(IL, JL, IS, JS, GT, (INS >  JS),  GT == (INS >  JS));
            ASSERTV(IL, JL, IS, JS, GT, (INS >  JNS), GT == (INS >  JNS));
            ASSERTV(IL, JL, IS, JS, GT, (INS >  JSR), GT == (INS >  JSR));
            ASSERTV(IL, JL, IS, JS, GT, (INS >  JSV), GT == (INS >  JSV));

            ASSERTV(IL, JL, IS, JS, GT, (ISR >  JPC), GT == (ISR >  JPC));
            ASSERTV(IL, JL, IS, JS, GT, (ISR >  JS),  GT == (ISR >  JS));
            ASSERTV(IL, JL, IS, JS, GT, (ISR >  JNS), GT == (ISR >  JNS));
            ASSERTV(IL, JL, IS, JS, GT, (ISR >  JSR), GT == (ISR >  JSR));
            ASSERTV(IL, JL, IS, JS, GT, (ISR >  JSV), GT == (ISR >  JSV));

            ASSERTV(IL, JL, IS, JS, GT, (ISV >  JPC), GT == (ISV >  JPC));
            ASSERTV(IL, JL, IS, JS, GT, (ISV >  JS),  GT == (ISV >  JS));
            ASSERTV(IL, JL, IS, JS, GT, (ISV >  JNS), GT == (ISV >  JNS));
            ASSERTV(IL, JL, IS, JS, GT, (ISV >  JSR), GT == (ISV >  JSR));
            ASSERTV(IL, JL, IS, JS, GT, (ISV >  JSV), GT == (ISV >  JSV));

            ASSERTV(IL, JL, IS, JS, GT, (IPC >  JS),  GT == (IPC >  JS));
            ASSERTV(IL, JL, IS, JS, GT, (IPC >  JNS), GT == (IPC >  JNS));
            ASSERTV(IL, JL, IS, JS, GT, (IPC >  JSR), GT == (IPC >  JSR));
            ASSERTV(IL, JL, IS, JS, GT, (IPC >  JSV), GT == (IPC >  JSV));

            // `operator<=`

            ASSERTV(IL, JL, IS, JS, LE, (IS  <= JPC), LE == (IS  <= JPC));
            ASSERTV(IL, JL, IS, JS, LE, (IS  <= JS),  LE == (IS  <= JS));
            ASSERTV(IL, JL, IS, JS, LE, (IS  <= JNS), LE == (IS  <= JNS));
            ASSERTV(IL, JL, IS, JS, LE, (IS  <= JSR), LE == (IS  <= JSR));
            ASSERTV(IL, JL, IS, JS, LE, (IS  <= JSV), LE == (IS  <= JSV));

            ASSERTV(IL, JL, IS, JS, LE, (INS <= JPC), LE == (INS <= JPC));
            ASSERTV(IL, JL, IS, JS, LE, (INS <= JS),  LE == (INS <= JS));
            ASSERTV(IL, JL, IS, JS, LE, (INS <= JNS), LE == (INS <= JNS));
            ASSERTV(IL, JL, IS, JS, LE, (INS <= JSR), LE == (INS <= JSR));
            ASSERTV(IL, JL, IS, JS, LE, (INS <= JSV), LE == (INS <= JSV));

            ASSERTV(IL, JL, IS, JS, LE, (ISR <= JPC), LE == (ISR <= JPC));
            ASSERTV(IL, JL, IS, JS, LE, (ISR <= JS),  LE == (ISR <= JS));
            ASSERTV(IL, JL, IS, JS, LE, (ISR <= JNS), LE == (ISR <= JNS));
            ASSERTV(IL, JL, IS, JS, LE, (ISR <= JSR), LE == (ISR <= JSR));
            ASSERTV(IL, JL, IS, JS, LE, (ISR <= JSV), LE == (ISR <= JSV));

            ASSERTV(IL, JL, IS, JS, LE, (ISV <= JPC), LE == (ISV <= JPC));
            ASSERTV(IL, JL, IS, JS, LE, (ISV <= JS),  LE == (ISV <= JS));
            ASSERTV(IL, JL, IS, JS, LE, (ISV <= JNS), LE == (ISV <= JNS));
            ASSERTV(IL, JL, IS, JS, LE, (ISV <= JSR), LE == (ISV <= JSR));
            ASSERTV(IL, JL, IS, JS, LE, (ISV <= JSV), LE == (ISV <= JSV));

            ASSERTV(IL, JL, IS, JS, LE, (IPC <= JS),  LE == (IPC <= JS));
            ASSERTV(IL, JL, IS, JS, LE, (IPC <= JNS), LE == (IPC <= JNS));
            ASSERTV(IL, JL, IS, JS, LE, (IPC <= JSR), LE == (IPC <= JSR));
            ASSERTV(IL, JL, IS, JS, LE, (IPC <= JSV), LE == (IPC <= JSV));

            // Testing rvalues.

            if (ILEN < -1 || JLEN < -1) {
                continue;
            }

            // `operator==`

            ASSERTV(IL, JL, IS, JS, EQ, (ISF == JPF), EQ == (ISF == JPF));
            ASSERTV(IL, JL, IS, JS, EQ, (ISF == JSF), EQ == (ISF == JSF));
            ASSERTV(IL, JL, IS, JS, EQ, (ISF == JNF), EQ == (ISF == JNF));
            ASSERTV(IL, JL, IS, JS, EQ, (ISF == JRF), EQ == (ISF == JRF));
            ASSERTV(IL, JL, IS, JS, EQ, (ISF == JVF), EQ == (ISF == JVF));

            ASSERTV(IL, JL, IS, JS, EQ, (INF == JPF), EQ == (INF == JPF));
            ASSERTV(IL, JL, IS, JS, EQ, (INF == JSF), EQ == (INF == JSF));
            ASSERTV(IL, JL, IS, JS, EQ, (INF == JNF), EQ == (INF == JNF));
            ASSERTV(IL, JL, IS, JS, EQ, (INF == JRF), EQ == (INF == JRF));
            ASSERTV(IL, JL, IS, JS, EQ, (INF == JVF), EQ == (INF == JVF));

            ASSERTV(IL, JL, IS, JS, EQ, (IRF == JPF), EQ == (IRF == JPF));
            ASSERTV(IL, JL, IS, JS, EQ, (IRF == JSF), EQ == (IRF == JSF));
            ASSERTV(IL, JL, IS, JS, EQ, (IRF == JNF), EQ == (IRF == JNF));
            ASSERTV(IL, JL, IS, JS, EQ, (IRF == JRF), EQ == (IRF == JRF));
            ASSERTV(IL, JL, IS, JS, EQ, (IRF == JVF), EQ == (IRF == JVF));

            ASSERTV(IL, JL, IS, JS, EQ, (IVF == JPF), EQ == (IVF == JPF));
            ASSERTV(IL, JL, IS, JS, EQ, (IVF == JSF), EQ == (IVF == JSF));
            ASSERTV(IL, JL, IS, JS, EQ, (IVF == JNF), EQ == (IVF == JNF));
            ASSERTV(IL, JL, IS, JS, EQ, (IVF == JRF), EQ == (IVF == JRF));
            ASSERTV(IL, JL, IS, JS, EQ, (IVF == JVF), EQ == (IVF == JVF));

            ASSERTV(IL, JL, IS, JS, EQ, (IPF == JNF), EQ == (IPF == JSF));
            ASSERTV(IL, JL, IS, JS, EQ, (IPF == JSF), EQ == (IPF == JNF));
            ASSERTV(IL, JL, IS, JS, EQ, (IPF == JRF), EQ == (IPF == JRF));
            ASSERTV(IL, JL, IS, JS, EQ, (IPF == JVF), EQ == (IPF == JVF));

            // `operator!=`

            ASSERTV(IL, JL, IS, JS, NE, (ISF != JPF), NE == (ISF != JPF));
            ASSERTV(IL, JL, IS, JS, NE, (ISF != JSF), NE == (ISF != JSF));
            ASSERTV(IL, JL, IS, JS, NE, (ISF != JNF), NE == (ISF != JNF));
            ASSERTV(IL, JL, IS, JS, NE, (ISF != JRF), NE == (ISF != JRF));
            ASSERTV(IL, JL, IS, JS, NE, (ISF != JVF), NE == (ISF != JVF));

            ASSERTV(IL, JL, IS, JS, NE, (INF != JPF), NE == (INF != JPF));
            ASSERTV(IL, JL, IS, JS, NE, (INF != JSF), NE == (INF != JSF));
            ASSERTV(IL, JL, IS, JS, NE, (INF != JNF), NE == (INF != JNF));
            ASSERTV(IL, JL, IS, JS, NE, (INF != JRF), NE == (INF != JRF));
            ASSERTV(IL, JL, IS, JS, NE, (INF != JVF), NE == (INF != JVF));

            ASSERTV(IL, JL, IS, JS, NE, (IRF != JPF), NE == (IRF != JPF));
            ASSERTV(IL, JL, IS, JS, NE, (IRF != JSF), NE == (IRF != JSF));
            ASSERTV(IL, JL, IS, JS, NE, (IRF != JNF), NE == (IRF != JNF));
            ASSERTV(IL, JL, IS, JS, NE, (IRF != JRF), NE == (IRF != JRF));
            ASSERTV(IL, JL, IS, JS, NE, (IRF != JVF), NE == (IRF != JVF));

            ASSERTV(IL, JL, IS, JS, NE, (IVF != JPF), NE == (IVF != JPF));
            ASSERTV(IL, JL, IS, JS, NE, (IVF != JSF), NE == (IVF != JSF));
            ASSERTV(IL, JL, IS, JS, NE, (IVF != JNF), NE == (IVF != JNF));
            ASSERTV(IL, JL, IS, JS, NE, (IVF != JRF), NE == (IVF != JRF));
            ASSERTV(IL, JL, IS, JS, NE, (IVF != JVF), NE == (IVF != JVF));

            ASSERTV(IL, JL, IS, JS, NE, (IPF != JSF), NE == (IPF != JSF));
            ASSERTV(IL, JL, IS, JS, NE, (IPF != JNF), NE == (IPF != JNF));
            ASSERTV(IL, JL, IS, JS, NE, (IPF != JRF), NE == (IPF != JRF));
            ASSERTV(IL, JL, IS, JS, NE, (IPF != JVF), NE == (IPF != JVF));

            // `operator<`

            ASSERTV(IL, JL, IS, JS, LT, (ISF <  JPF), LT == (ISF <  JPF));
            ASSERTV(IL, JL, IS, JS, LT, (ISF <  JSF), LT == (ISF <  JSF));
            ASSERTV(IL, JL, IS, JS, LT, (ISF <  JNF), LT == (ISF <  JNF));
            ASSERTV(IL, JL, IS, JS, LT, (ISF <  JRF), LT == (ISF <  JRF));
            ASSERTV(IL, JL, IS, JS, LT, (ISF <  JVF), LT == (ISF <  JVF));

            ASSERTV(IL, JL, IS, JS, LT, (INF <  JPF), LT == (INF <  JPF));
            ASSERTV(IL, JL, IS, JS, LT, (INF <  JSF), LT == (INF <  JSF));
            ASSERTV(IL, JL, IS, JS, LT, (INF <  JNF), LT == (INF <  JNF));
            ASSERTV(IL, JL, IS, JS, LT, (INF <  JRF), LT == (INF <  JRF));
            ASSERTV(IL, JL, IS, JS, LT, (INF <  JVF), LT == (INF <  JVF));

            ASSERTV(IL, JL, IS, JS, LT, (IRF <  JPF), LT == (IRF <  JPF));
            ASSERTV(IL, JL, IS, JS, LT, (IRF <  JSF), LT == (IRF <  JSF));
            ASSERTV(IL, JL, IS, JS, LT, (IRF <  JNF), LT == (IRF <  JNF));
            ASSERTV(IL, JL, IS, JS, LT, (IRF <  JRF), LT == (IRF <  JRF));
            ASSERTV(IL, JL, IS, JS, LT, (IRF <  JVF), LT == (IRF <  JVF));

            ASSERTV(IL, JL, IS, JS, LT, (IVF <  JPF), LT == (IVF <  JPF));
            ASSERTV(IL, JL, IS, JS, LT, (IVF <  JSF), LT == (IVF <  JSF));
            ASSERTV(IL, JL, IS, JS, LT, (IVF <  JNF), LT == (IVF <  JNF));
            ASSERTV(IL, JL, IS, JS, LT, (IVF <  JRF), LT == (IVF <  JRF));
            ASSERTV(IL, JL, IS, JS, LT, (IVF <  JVF), LT == (IVF <  JVF));

            ASSERTV(IL, JL, IS, JS, LT, (IPF <  JSF), LT == (IPF <  JSF));
            ASSERTV(IL, JL, IS, JS, LT, (IPF <  JNF), LT == (IPF <  JNF));
            ASSERTV(IL, JL, IS, JS, LT, (IPF <  JRF), LT == (IPF <  JRF));
            ASSERTV(IL, JL, IS, JS, LT, (IPF <  JVF), LT == (IPF <  JVF));

            // `operator>=`

            ASSERTV(IL, JL, IS, JS, GE, (ISF >= JPF), GE == (ISF >= JPF));
            ASSERTV(IL, JL, IS, JS, GE, (ISF >= JSF), GE == (ISF >= JSF));
            ASSERTV(IL, JL, IS, JS, GE, (ISF >= JNF), GE == (ISF >= JNF));
            ASSERTV(IL, JL, IS, JS, GE, (ISF >= JRF), GE == (ISF >= JRF));
            ASSERTV(IL, JL, IS, JS, GE, (ISF >= JVF), GE == (ISF >= JVF));

            ASSERTV(IL, JL, IS, JS, GE, (INF >= JPF), GE == (INF >= JPF));
            ASSERTV(IL, JL, IS, JS, GE, (INF >= JSF), GE == (INF >= JSF));
            ASSERTV(IL, JL, IS, JS, GE, (INF >= JNF), GE == (INF >= JNF));
            ASSERTV(IL, JL, IS, JS, GE, (INF >= JRF), GE == (INF >= JRF));
            ASSERTV(IL, JL, IS, JS, GE, (INF >= JVF), GE == (INF >= JVF));

            ASSERTV(IL, JL, IS, JS, GE, (IRF >= JPF), GE == (IRF >= JPF));
            ASSERTV(IL, JL, IS, JS, GE, (IRF >= JSF), GE == (IRF >= JSF));
            ASSERTV(IL, JL, IS, JS, GE, (IRF >= JNF), GE == (IRF >= JNF));
            ASSERTV(IL, JL, IS, JS, GE, (IRF >= JRF), GE == (IRF >= JRF));
            ASSERTV(IL, JL, IS, JS, GE, (IRF >= JVF), GE == (IRF >= JVF));

            ASSERTV(IL, JL, IS, JS, GE, (IVF >= JPF), GE == (IVF >= JPF));
            ASSERTV(IL, JL, IS, JS, GE, (IVF >= JSF), GE == (IVF >= JSF));
            ASSERTV(IL, JL, IS, JS, GE, (IVF >= JNF), GE == (IVF >= JNF));
            ASSERTV(IL, JL, IS, JS, GE, (IVF >= JRF), GE == (IVF >= JRF));
            ASSERTV(IL, JL, IS, JS, GE, (IVF >= JVF), GE == (IVF >= JVF));

            ASSERTV(IL, JL, IS, JS, GE, (IPF >= JSF), GE == (IPF >= JSF));
            ASSERTV(IL, JL, IS, JS, GE, (IPF >= JNF), GE == (IPF >= JNF));
            ASSERTV(IL, JL, IS, JS, GE, (IPF >= JRF), GE == (IPF >= JRF));
            ASSERTV(IL, JL, IS, JS, GE, (IPF >= JVF), GE == (IPF >= JVF));

            // `operator>`

            ASSERTV(IL, JL, IS, JS, GT, (ISF >  JPF), GT == (ISF >  JPF));
            ASSERTV(IL, JL, IS, JS, GT, (ISF >  JSF), GT == (ISF >  JSF));
            ASSERTV(IL, JL, IS, JS, GT, (ISF >  JNF), GT == (ISF >  JNF));
            ASSERTV(IL, JL, IS, JS, GT, (ISF >  JRF), GT == (ISF >  JRF));
            ASSERTV(IL, JL, IS, JS, GT, (ISF >  JVF), GT == (ISF >  JVF));

            ASSERTV(IL, JL, IS, JS, GT, (INF >  JPF), GT == (INF >  JPF));
            ASSERTV(IL, JL, IS, JS, GT, (INF >  JSF), GT == (INF >  JSF));
            ASSERTV(IL, JL, IS, JS, GT, (INF >  JNF), GT == (INF >  JNF));
            ASSERTV(IL, JL, IS, JS, GT, (INF >  JRF), GT == (INF >  JRF));
            ASSERTV(IL, JL, IS, JS, GT, (INF >  JVF), GT == (INF >  JVF));

            ASSERTV(IL, JL, IS, JS, GT, (IRF >  JPF), GT == (IRF >  JPF));
            ASSERTV(IL, JL, IS, JS, GT, (IRF >  JSF), GT == (IRF >  JSF));
            ASSERTV(IL, JL, IS, JS, GT, (IRF >  JNF), GT == (IRF >  JNF));
            ASSERTV(IL, JL, IS, JS, GT, (IRF >  JRF), GT == (IRF >  JRF));
            ASSERTV(IL, JL, IS, JS, GT, (IRF >  JVF), GT == (IRF >  JVF));

            ASSERTV(IL, JL, IS, JS, GT, (IVF >  JPF), GT == (IVF >  JPF));
            ASSERTV(IL, JL, IS, JS, GT, (IVF >  JSF), GT == (IVF >  JSF));
            ASSERTV(IL, JL, IS, JS, GT, (IVF >  JNF), GT == (IVF >  JNF));
            ASSERTV(IL, JL, IS, JS, GT, (IVF >  JRF), GT == (IVF >  JRF));
            ASSERTV(IL, JL, IS, JS, GT, (IVF >  JVF), GT == (IVF >  JVF));

            ASSERTV(IL, JL, IS, JS, GT, (IPF >  JSF), GT == (IPF >  JSF));
            ASSERTV(IL, JL, IS, JS, GT, (IPF >  JNF), GT == (IPF >  JNF));
            ASSERTV(IL, JL, IS, JS, GT, (IPF >  JRF), GT == (IPF >  JRF));
            ASSERTV(IL, JL, IS, JS, GT, (IPF >  JVF), GT == (IPF >  JVF));

            // `operator<=`

            ASSERTV(IL, JL, IS, JS, LE, (ISF <= JPF), LE == (ISF <= JPF));
            ASSERTV(IL, JL, IS, JS, LE, (ISF <= JSF), LE == (ISF <= JSF));
            ASSERTV(IL, JL, IS, JS, LE, (ISF <= JNF), LE == (ISF <= JNF));
            ASSERTV(IL, JL, IS, JS, LE, (ISF <= JRF), LE == (ISF <= JRF));
            ASSERTV(IL, JL, IS, JS, LE, (ISF <= JVF), LE == (ISF <= JVF));

            ASSERTV(IL, JL, IS, JS, LE, (INF <= JPF), LE == (INF <= JPF));
            ASSERTV(IL, JL, IS, JS, LE, (INF <= JSF), LE == (INF <= JSF));
            ASSERTV(IL, JL, IS, JS, LE, (INF <= JNF), LE == (INF <= JNF));
            ASSERTV(IL, JL, IS, JS, LE, (INF <= JRF), LE == (INF <= JRF));
            ASSERTV(IL, JL, IS, JS, LE, (INF <= JVF), LE == (INF <= JVF));

            ASSERTV(IL, JL, IS, JS, LE, (IRF <= JPF), LE == (IRF <= JPF));
            ASSERTV(IL, JL, IS, JS, LE, (IRF <= JSF), LE == (IRF <= JSF));
            ASSERTV(IL, JL, IS, JS, LE, (IRF <= JNF), LE == (IRF <= JNF));
            ASSERTV(IL, JL, IS, JS, LE, (IRF <= JRF), LE == (IRF <= JRF));
            ASSERTV(IL, JL, IS, JS, LE, (IRF <= JVF), LE == (IRF <= JVF));

            ASSERTV(IL, JL, IS, JS, LE, (IVF <= JPF), LE == (IVF <= JPF));
            ASSERTV(IL, JL, IS, JS, LE, (IVF <= JSF), LE == (IVF <= JSF));
            ASSERTV(IL, JL, IS, JS, LE, (IVF <= JNF), LE == (IVF <= JNF));
            ASSERTV(IL, JL, IS, JS, LE, (IVF <= JRF), LE == (IVF <= JRF));
            ASSERTV(IL, JL, IS, JS, LE, (IVF <= JVF), LE == (IVF <= JVF));

            ASSERTV(IL, JL, IS, JS, LE, (IPF <= JSF), LE == (IPF <= JSF));
            ASSERTV(IL, JL, IS, JS, LE, (IPF <= JNF), LE == (IPF <= JNF));
            ASSERTV(IL, JL, IS, JS, LE, (IPF <= JRF), LE == (IPF <= JRF));
            ASSERTV(IL, JL, IS, JS, LE, (IPF <= JVF), LE == (IPF <= JVF));

            if      ( IS.empty() && !JS.empty()) {
                ASSERT(LT);
            }
            else if (!IS.empty() &&  JS.empty()) {
                ASSERT(GT);
            }
        }
    }
}

}  // close unnamed namespace
}  // close namespace comparisons
}  // close enterprise namespace

//=============================================================================
//                             MAIN PROGRAM
//-----------------------------------------------------------------------------

int main(int argc, char *argv[])
{
    int            test = argc > 1 ? atoi(argv[1]) : 0;
                verbose = argc > 2;
            veryVerbose = argc > 3;
        veryVeryVerbose = argc > 4;
    veryVeryVeryVerbose = argc > 5;

    std::cout << "TEST " << __FILE__ << " CASE " << test << std::endl;

    switch (test) { case 0:
      case 16: {
        // --------------------------------------------------------------------
        // TESTING USAGE EXAMPLE
        //
        // Concerns:
        //   The usage example provided in the component header file must
        //   compile, link, and run on all platforms as shown.
        //
        // Plan:
        //   Incorporate usage example from header into driver, remove leading
        //   comment characters, and replace `assert` with `ASSERT`.
        //
        // Testing:
        //   USAGE EXAMPLE
        // --------------------------------------------------------------------

        if (verbose) std::cout << "\nTESTING USAGE EXAMPLE"
                               << "\n=====================\n";

// Then, call `getNumBlanks` on a default constructed `bslstl::StringRef`:
// ```
    bslstl::StringRef            emptyRef;
    bslstl::StringRef::size_type numBlanks = getNumBlanks(emptyRef);
    ASSERT(0 == numBlanks);

    ASSERT(""         == emptyRef);
    ASSERT("anything" >= emptyRef);
// ```
// Notice that the behavior a default constructed `bslstl::StringRef` object
// behaves the same as if it referenced an empty string.
//
// Next, we (implicitly) construct a `bsl::string` object from
// `bslstl::StringRef`:
// ```
    bsl::string empty(emptyRef);
    ASSERT(0 == empty.size());
// ```
// Then, we call `getNumBlanks` on a string literal and assert that the number
// of blanks returned is as expected:
// ```
    numBlanks = getNumBlanks("Good things come to those who wait.");
    ASSERT(6 == numBlanks);
// ```
// Next, we define a longer string literal, `poem`, that we will use in the
// rest of this usage example:
// ```
    const char poem[] =                  // by William Butler Yeats (1865-1939)
//      |....5....|....5....|....5....|....5....|   //  length  blanks
                                                    //
        "O love is the crooked thing,\n"            //    29      5
        "There is nobody wise enough\n"             //    28      4
        "To find out all that is in it,\n"          //    31      7
        "For he would be thinking of love\n"        //    33      6
        "Till the stars had run away\n"             //    28      5
        "And the shadows eaten the moon.\n"         //    32      5
        "Ah, penny, brown penny, brown penny,\n"    //    37      5
        "One cannot begin it too soon.";            //    29      5
                                                    //          ----
                                                    //    total: 42
    numBlanks = getNumBlanks(poem);
    ASSERT(42 == numBlanks);
// ```
// Then, we construct a `bslstl::StringRef` object, `line`, that refers to only
// the first line of the `poem`:
// ```
    bslstl::StringRef line(poem, 29);
    numBlanks = getNumBlanks(line);

    ASSERT( 5 == numBlanks);
    ASSERT(29 == line.length());
    ASSERT( 0 == std::strncmp(poem, line.data(), line.length()));
// ```
// Next, we use the `assign` method to make `line` refer to the second line of
// the `poem`:
// ```
    line.assign(poem + 29, poem + 57);
    numBlanks = getNumBlanks(line);
    ASSERT(4 == numBlanks);
    ASSERT((57 - 29) == line.length());
    ASSERT("There is nobody wise enough\n" == line);
// ```
// Then, we call `getNumBlanks` with a `bsl::string` initialized to the
// contents of the `poem`:
// ```
    const bsl::string poemString(poem);
    numBlanks = getNumBlanks(poemString);
    ASSERT(42 == numBlanks);
    ASSERT(bslstl::StringRef(poemString) == poemString);
    ASSERT(bslstl::StringRef(poemString) == poemString.c_str());
// ```
// Next, we make a `bslstl::StringRef` object that refers to a string that will
// be able to hold embedded null characters:
// ```
    char poemWithNulls[512];
    const bslstl::StringRef::size_type poemLength = std::strlen(poem);
    ASSERT(poemLength < 512);

    std::memcpy(poemWithNulls, poem, poemLength + 1);
    ASSERT(0 == std::strcmp(poem, poemWithNulls));
// ```
// Now, we replace each occurrence of a '\n' in `poemWithNulls` with a yielding
// '\0':
// ```
    std::replace(poemWithNulls, poemWithNulls + poemLength, '\n', '\0');
    ASSERT(0 != std::strcmp(poem, poemWithNulls));
// ```
// Finally, we observe that `poemWithNulls` has the same number of blank
// characters as the original `poem`:
// ```
    numBlanks = getNumBlanks(bslstl::StringRef(poemWithNulls, poemLength));
    ASSERT(42 == numBlanks);
// ```
      } break;
      case 15: {
        // --------------------------------------------------------------------
        // CONVERSION of `string_view` W.R.T. `std::basic_string`
        //
        // This test was migrated to from `bslstl_stringview.t.cpp` TC 23 to
        // here to avoid dependency cycles.
        // --------------------------------------------------------------------

        if (verbose) printf(
                   "CONVERSION of `string_view` W.R.T. `std::basic_string`\n"
                   "======================================================\n");

        TestDriver<char>::testCase15();
        TestDriver<wchar_t>::testCase15();

#if defined(BSLS_COMPILERFEATURES_SUPPORT_UTF8_CHAR_TYPE)
        TestDriver<char8_t>::testCase15();
#endif

#if defined(BSLS_COMPILERFEATURES_SUPPORT_UNICODE_CHAR_TYPES)
        TestDriver<char16_t>::testCase15();
        TestDriver<char32_t>::testCase15();
#endif
      } break;
      case 14: {
        // --------------------------------------------------------------------
        // TESTING CONSTRUCTION AND STRING VIEW
        // --------------------------------------------------------------------

        if (verbose) std::cout << "TESTING CONSTRUCTION AND STRING VIEW\n"
                                  "====================================\n";

        RUN_EACH_TYPE(TestDriver, testCase14, char, wchar_t);
      } break;
      case 13: {
        // --------------------------------------------------------------------
        // STRING CONSTRUCTORS COMPATIBILITY
        //   The appearance of the `bsl::string_view` class in the inheritance
        //   chain
        //   "`bsl::string_view`<-`bslstl::StringRefData`<-`bslstl::StringRef`"
        //   has created several potentially dangerous places.  This test is
        //   intended to reveal these problems if any.
        //
        // Concerns:
        // 1. Calls for the `bsl::string` constructors are unambiguous while
        //    passing objects of `bsl::string_view`, `bslstl::StringRefData` or
        //    `bslstl::StringRef` types as a parameter.
        //
        // 2. The `bsl::string` constructor, accepting constant reference to
        //    `bslstl::StringRefData` object can be called implicitly.
        //
        // Plan:
        // 1. Explicitly call `bsl::string` constructor, passing objects of
        //    `bsl::string_view`, `bslstl::StringRefData` or
        //    `bslstl::StringRef` types as a parameter.
        //
        // 2. Call special fuctions, that implicitly or explicitly invoke
        //    `bsl::string` constructors and pass objects of
        //    `bsl::string_view`, `bslstl::StringRefData` or
        //    `bslstl::StringRef` types as a parameter.  (C-1..2)
        //
        // Testing:
        //   STRING CONSTRUCTORS COMPATIBILITY
        // --------------------------------------------------------------------

        if (verbose) printf("\nSTRING CONSTRUCTORS COMPATIBILITY"
                            "\n=================================\n");

        const char   *testStr = "testStr";
        const size_t  TEST_STR_LENGTH =
                                       bsl::char_traits<char>::length(testStr);

        const bsl::basic_string_view<char> SV( testStr,  TEST_STR_LENGTH);
        const bslstl::StringRefData<char>  SRD(testStr,
                                               testStr + TEST_STR_LENGTH);
        const bslstl::StringRefImp<char>   SR( testStr,
                                               testStr + TEST_STR_LENGTH);

        bsl::basic_string<char> strSV( SV );
        bsl::basic_string<char> strSRD(SRD);
        bsl::basic_string<char> strSR( SR );

        // testStringImplicitCtor(SV);  // explicit ctor
        testStringImplicitCtor(SRD);    // implicit ctor
        testStringImplicitCtor(SR);     // implicit ctor

        testStringCtorsAmbiguityTemplate<bsl::basic_string<char> >(SV );
        testStringCtorsAmbiguityTemplate<bsl::basic_string<char> >(SRD);
        testStringCtorsAmbiguityTemplate<bsl::basic_string<char> >(SR );

        // testStringCtorsAmbiguity(SV );
        testStringCtorsAmbiguity(SRD);
        testStringCtorsAmbiguity(SR );

        // Test operator implicit conversion.

        ImplicitlyConvertibleToString<char> icts;
        bsl::basic_string<char>             str(icts);
        (void) str;   // suppress compiler warning

      } break;
      case 12: {
        // --------------------------------------------------------------------
        // TESTING TYPE TRAITS
        //   The object is trivially copyable, and bitwise copyable and should
        //   have appropriate bsl type traits to reflect this.
        //
        // Concerns:
        // 1. The class has the `bsl::is_trivially_copyable` trait.
        //
        // 2. The class has the `bslmf::IsBitwiseMoveable` trait.
        //
        // 3. The class doesn't have the
        //    `bsl::is_trivially_default_constructible` trait.
        //
        // 4. The class doesn't have the `bslma::UsesBslmaAllocator` trait.
        //
        // 5. The class doesn't have the `bslmf::IsBitwiseEqualityComparable`
        //    trait.
        //
        // Plan:
        // 1. ASSERT the presence of each trait required by the type.  (C-1..5)
        //
        // Testing:
        //   TYPE TRAITS
        // --------------------------------------------------------------------

        if (verbose) printf("\nTESTING TYPE TRAITS"
                            "\n===================\n");

        typedef bslstl::StringRefImp<char>    RefImp;
        typedef bslstl::StringRefImp<wchar_t> WRefImp;

        ASSERT( bslmf::IsBitwiseCopyable<RefImp>::value);
#ifdef BSLS_LIBRARYFEATURES_HAS_CPP11_BASELINE_LIBRARY
        ASSERT( std::is_trivially_copyable<RefImp>::value);
#endif
        ASSERT(!bsl::is_trivially_default_constructible<RefImp>::value);
        ASSERT(!bslmf::IsBitwiseEqualityComparable<RefImp>::value);
        ASSERT( bslmf::IsBitwiseMoveable<RefImp>::value);
        ASSERT(!bslma::UsesBslmaAllocator<RefImp>::value);

        ASSERT( bslmf::IsBitwiseCopyable<WRefImp>::value);
        ASSERT(!bsl::is_trivially_default_constructible<WRefImp>::value);
        ASSERT(!bslmf::IsBitwiseEqualityComparable<WRefImp>::value);
#ifdef BSLS_LIBRARYFEATURES_HAS_CPP11_BASELINE_LIBRARY
        ASSERT( std::is_trivially_copyable<WRefImp>::value);
#endif
        ASSERT( bslmf::IsBitwiseMoveable<WRefImp>::value);
        ASSERT(!bslma::UsesBslmaAllocator<WRefImp>::value);

      } break;
      case 11: {
        // --------------------------------------------------------------------
        // TESTING `bsl::string::operator=`
        //
        // Concerns:
        //   That string assignment to a `bsl::string` through the `operator=`
        //   member compiles and works properly.  Of particular interest is
        //   whether any of these conversion failed to compile due to
        //   ambiguities.
        //
        //   Note that this must be done in this component, rather than in
        //   `bslstl_string.t.cpp`, since we want to test assigning from a
        //   `bslstl::StringRef`.
        //
        // Testing:
        //   bsl::string::operator=(const bslstl::StringRefData&);
        // --------------------------------------------------------------------

        if (verbose) printf("\nTESTING `bsl::string::operator=`"
                            "\n================================\n");

        bslma::TestAllocator         ta("test",    veryVeryVeryVerbose);
        bslma::TestAllocator         da("default", veryVeryVeryVerbose);
        bslma::DefaultAllocatorGuard dag(&da);

        OpEqualsAssignTestA a;
        OpEqualsAssignTestB b;

        const char *ca = a;
        Obj         cb = b;

        if (veryVerbose) { P(ca); }

        ASSERTV(ca, ca != cb && ca < cb && cb > ca);

        bsl::string sa(&ta), sb(&ta);

        sa = "woof";    sb.assign("meow");

        ASSERT(0 == ta.numAllocations());    // short strings so far

        sa = a;

        ASSERT(ca == sa);
        ASSERT(1 == ta.numAllocations());    // allocated

        sb = b;

        ASSERT(cb == sb);
        ASSERT(2 == ta.numAllocations());    // allocated
        ASSERT(0 == da.numAllocations());    // no unseen temporary strings
                                             // created
        ASSERTV(sa.c_str(), sb.c_str(), sa != sb && sa < sb && sb > sa);

        if (veryVerbose) { P(sa.c_str()); P(sb.c_str()); }
      } break;
      case 10: {
        // --------------------------------------------------------------------
        // TESTING REVERSE ITERATORS
        // --------------------------------------------------------------------

        //  See `TestDriver::testCase10` for concerns and plan.

        if (verbose) std::cout << "\nTESTING REVERSE ITERATORS"
                                  "\n=========================\n";

        RUN_EACH_TYPE(TestDriver, testCase10, char, wchar_t);

      } break;
      case 9: {
        // --------------------------------------------------------------------
        // TESTING `StringRefImp(StringRefImp&, size_type, size_type)`
        //
        // --------------------------------------------------------------------

        //  See `TestDriver::testCase9` for concerns and plan.

        if (verbose) printf(
            "\nTESTING `StringRefImp(StringRefImp&, size_type, size_type)`"
            "\n===========================================================\n");

        RUN_EACH_TYPE(TestDriver, testCase9, char, wchar_t);

      } break;
      case 8: {
        // --------------------------------------------------------------------
        // TESTING HASH FUNCTION
        //
        // Concerns:
        // 1. The hash function in versions of this component prior to
        //    /main/bb/dev/10 returned `0` for all input strings.  This test
        //    will verify that the hash function returns acceptably distinct
        //    values for a set of input strings, allowing for at most one
        //    collision.
        //
        // 2. The `hashAppend` function should be picked up and used by
        //    bslh:Hash. The whole string should be used in this hash.
        //    `bsl::hash` specialization has been deleted, so calls to
        //    `bsl::hash` should automatically forward to `bslh::Hash`.
        //
        // Plan:
        // 1. Hash a reasonably large number of strings, capturing the hash
        //    values.  Make sure re-hashing the same strings in a different
        //    order returns the same values.  Then make sure that each
        //    resulting hash was not encountered more than twice (so we're
        //    allowing SOME collisions, but not too many).
        //
        //    The strings to be hashed will include some "typical" short
        //    strings including the names of current and past members of the
        //    BDE team and the tickers for the members of the S&P 500 index.
        //
        //    While there are no guarantees that these data sets are
        //    representative, this at least allows us to make sure that our
        //    hash performs in a reasonable manner.
        //
        // 2. Test using both bslh::Hash<> and bsl::hash<StringRef> (both of
        //     which should now give the same result). Hash strings where only
        //     the final value differs to ensure that the full length of the
        //     string is being hashed. Also hash multiple copies of the same
        //     string and ensure they produce the same hash to make sure
        //     nothing beyond the end of the string is being hashed.
        //
        // Testing:
        //   bsl::hash<BloombergLP::bslstl::StringRef>
        //   bslh::Hash<>
        // --------------------------------------------------------------------

        if (verbose) std::cout << "\nTESTING HASH FUNCTION"
                                  "\n=====================\n";

        static const struct {
            int         d_line;
            const char *d_str_p;
        } DATA[] = {
            //line string
            //---- ------

            // the empty string
            { L_,  ""                           },

            // some simple keys
            { L_,  "a"                          },
            { L_,  "aa"                         },
            { L_,  "aaa"                        },
            { L_,  "aaaa"                       },
            { L_,  "aaaaa"                      },
            { L_,  "aaaaaa"                     },
            { L_,  "b"                          },
            { L_,  "bb"                         },
            { L_,  "bbb"                        },
            { L_,  "bbbb"                       },
            { L_,  "bbbbb"                      },
            { L_,  "bbbbbb"                     },
          // Skipped, A and AA are also stock tickers listed below in the "SPX
          // Index".
          //{ L_,  "A"                          },
          //{ L_,  "AA"                         },
            { L_,  "AAA"                        },
            { L_,  "AAAA"                       },
            { L_,  "AAAAA"                      },
            { L_,  "AAAAAA"                     },
          // skipped, also potentially a stock ticker
          //{ L_,  "B"                          },
            { L_,  "BB"                         },
            { L_,  "BBB"                        },
            { L_,  "BBBB"                       },
            { L_,  "BBBBB"                      },
            { L_,  "BBBBBB"                     },
            { L_,  "0"                          },
            { L_,  "00"                         },
            { L_,  "000"                        },
            { L_,  "0000"                       },
            { L_,  "00000"                      },
            { L_,  "000000"                     },
            { L_,  "1"                          },
            { L_,  "11"                         },
            { L_,  "111"                        },
            { L_,  "1111"                       },
            { L_,  "11111"                      },
            { L_,  "111111"                     },
            // Some personal names.  In this case, current and former BDE team
            // members, captured via
            //
            // cat /etc/passwd| grep -i bde | \$
            //  'BEGIN{FS=":"} {print $5}'  | \$
            //   awk '{print $1; print $2; print $1,$2}'|sort -u
            // .
            { L_,  "Case"                       },
            { L_,  "Clear"                      },
            { L_,  "Clear Case"                 },
            { L_,  "Role"                       },
            { L_,  "Verity"                     },
            { L_,  "Verity Role"                },
            { L_,  "abdelaziz"                  },
            { L_,  "abdelmalek"                 },
            { L_,  "ahmed"                      },
            { L_,  "ahmed abdelaziz"            },
            { L_,  "andrei"                     },
            { L_,  "andrei basov"               },
            { L_,  "anthony"                    },
            { L_,  "anthony comerico"           },
            { L_,  "basov"                      },
            { L_,  "bhindwale"                  },
            { L_,  "bill"                       },
            { L_,  "bill chapman"               },
            { L_,  "bob"                        },
            { L_,  "bob deanna"                 },
            { L_,  "breitstein"                 },
            { L_,  "bronnimann"                 },
            { L_,  "bruce"                      },
            { L_,  "bruce szablak"              },
            { L_,  "chapman"                    },
            { L_,  "chen"                       },
            { L_,  "clay"                       },
            { L_,  "clay wilson"                },
            { L_,  "comerico"                   },
            { L_,  "cushing"                    },
            { L_,  "david"                      },
            { L_,  "david rubin"                },
            { L_,  "david schumann"             },
            { L_,  "david winsor"               },
            { L_,  "day"                        },
            { L_,  "deanna"                     },
            { L_,  "dorfman"                    },
            { L_,  "etra"                       },
            { L_,  "farber"                     },
            { L_,  "gang"                       },
            { L_,  "gang chen"                  },
            { L_,  "giroux"                     },
            { L_,  "guillaume"                  },
            { L_,  "guillaume morin"            },
            { L_,  "halpern"                    },
            { L_,  "henry"                      },
            { L_,  "henry verschell"            },
            { L_,  "herve"                      },
            { L_,  "herve bronnimann"           },
            { L_,  "hugh"                       },
            { L_,  "hugh cushing"               },
            { L_,  "hutton"                     },
            { L_,  "jeff"                       },
            { L_,  "jeff hutton"                },
            { L_,  "john"                       },
            { L_,  "john lakos"                 },
            { L_,  "lakos"                      },
            { L_,  "lindrick"                   },
            { L_,  "lindrick outerbridge"       },
            { L_,  "manny"                      },
            { L_,  "manny farber"               },
            { L_,  "marshall"                   },
            { L_,  "matthew"                    },
            { L_,  "matthew millett"            },
            { L_,  "michael"                    },
            { L_,  "michael nusimow"            },
            { L_,  "mike"                       },
            { L_,  "mike giroux"                },
            { L_,  "millett"                    },
            { L_,  "morin"                      },
            { L_,  "nathan"                     },
            { L_,  "nathan dorfman"             },
            { L_,  "nusimow"                    },
            { L_,  "oleg"                       },
            { L_,  "oleg semenov"               },
            { L_,  "olga"                       },
            { L_,  "olga zykova"                },
            { L_,  "outerbridge"                },
            { L_,  "pablo"                      },
            { L_,  "pablo halpern"              },
            { L_,  "revzin"                     },
            { L_,  "robert"                     },
            { L_,  "robert day"                 },
            { L_,  "rohan"                      },
            { L_,  "rohan bhindwale"            },
            { L_,  "roman"                      },
            { L_,  "roman revzin"               },
            { L_,  "rubin"                      },
            { L_,  "schumann"                   },
            { L_,  "semenov"                    },
            { L_,  "sherry"                     },
            { L_,  "sherry sontag"              },
            { L_,  "sontag"                     },
            { L_,  "stan"                       },
            { L_,  "stan etra"                  },
            { L_,  "steven"                     },
            { L_,  "steven breitstein"          },
            { L_,  "szablak"                    },
            { L_,  "thomas"                     },
            { L_,  "thomas marshall"            },
            { L_,  "verschell"                  },
            { L_,  "wilson"                     },
            { L_,  "winsor"                     },
            { L_,  "yasser"                     },
            { L_,  "yasser abdelmalek"          },
            { L_,  "zykova"                     },

            // The first part of the stock tickers of the 499 members of the
            // S&P 500 as reported by {SPX Index MEMB<GO>} on 20081112
            { L_,  "A"                          },
            { L_,  "AA"                         },
            { L_,  "AAPL"                       },
            { L_,  "ABC"                        },
            { L_,  "ABI"                        },
            { L_,  "ABT"                        },
            { L_,  "ACAS"                       },
            { L_,  "ACS"                        },
            { L_,  "ADBE"                       },
            { L_,  "ADI"                        },
            { L_,  "ADM"                        },
            { L_,  "ADP"                        },
            { L_,  "ADSK"                       },
            { L_,  "AEE"                        },
            { L_,  "AEP"                        },
            { L_,  "AES"                        },
            { L_,  "AET"                        },
            { L_,  "AFL"                        },
            { L_,  "AGN"                        },
            { L_,  "AIG"                        },
            { L_,  "AIV"                        },
            { L_,  "AIZ"                        },
            { L_,  "AKAM"                       },
            { L_,  "AKS"                        },
            { L_,  "ALL"                        },
            { L_,  "ALTR"                       },
            { L_,  "AMAT"                       },
            { L_,  "AMD"                        },
            { L_,  "AMGN"                       },
            { L_,  "AMP"                        },
            { L_,  "AMT"                        },
            { L_,  "AMZN"                       },
            { L_,  "AN"                         },
            { L_,  "ANF"                        },
            { L_,  "AOC"                        },
            { L_,  "APA"                        },
            { L_,  "APC"                        },
            { L_,  "APD"                        },
            { L_,  "APH"                        },
            { L_,  "APOL"                       },
            { L_,  "ASH"                        },
            { L_,  "ATI"                        },
            { L_,  "AVB"                        },
            { L_,  "AVP"                        },
            { L_,  "AVY"                        },
            { L_,  "AW"                         },
            { L_,  "AXP"                        },
            { L_,  "AYE"                        },
            { L_,  "AZO"                        },
            { L_,  "BA"                         },
            { L_,  "BAC"                        },
            { L_,  "BAX"                        },
            { L_,  "BBBY"                       },
            { L_,  "BBT"                        },
            { L_,  "BBY"                        },
            { L_,  "BCR"                        },
            { L_,  "BDK"                        },
            { L_,  "BDX"                        },
            { L_,  "BEN"                        },
            { L_,  "BF/B"                       },
            { L_,  "BHI"                        },
            { L_,  "BIG"                        },
            { L_,  "BIIB"                       },
            { L_,  "BJS"                        },
            { L_,  "BK"                         },
            { L_,  "BLL"                        },
            { L_,  "BMC"                        },
            { L_,  "BMS"                        },
            { L_,  "BMY"                        },
            { L_,  "BNI"                        },
            { L_,  "BRCM"                       },
            { L_,  "BRL"                        },
            { L_,  "BSX"                        },
            { L_,  "BTU"                        },
            { L_,  "BUD"                        },
            { L_,  "BXP"                        },
            { L_,  "C"                          },
            { L_,  "CA"                         },
            { L_,  "CAG"                        },
            { L_,  "CAH"                        },
            { L_,  "CAM"                        },
            { L_,  "CAT"                        },
            { L_,  "CB"                         },
            { L_,  "CBE"                        },
            { L_,  "CBG"                        },
            { L_,  "CBS"                        },
            { L_,  "CCE"                        },
            { L_,  "CCL"                        },
            { L_,  "CEG"                        },
            { L_,  "CELG"                       },
            { L_,  "CF"                         },
            { L_,  "CHK"                        },
            { L_,  "CHRW"                       },
            { L_,  "CI"                         },
            { L_,  "CIEN"                       },
            { L_,  "CINF"                       },
            { L_,  "CIT"                        },
            { L_,  "CL"                         },
            { L_,  "CLX"                        },
            { L_,  "CMA"                        },
            { L_,  "CMCSA"                      },
            { L_,  "CME"                        },
            { L_,  "CMI"                        },
            { L_,  "CMS"                        },
            { L_,  "CNP"                        },
            { L_,  "CNX"                        },
            { L_,  "COF"                        },
            { L_,  "COG"                        },
            { L_,  "COH"                        },
            { L_,  "COL"                        },
            { L_,  "COP"                        },
            { L_,  "COST"                       },
            { L_,  "COV"                        },
            { L_,  "CPB"                        },
            { L_,  "CPWR"                       },
            { L_,  "CRM"                        },
            { L_,  "CSC"                        },
            { L_,  "CSCO"                       },
            { L_,  "CSX"                        },
            { L_,  "CTAS"                       },
            { L_,  "CTL"                        },
            { L_,  "CTSH"                       },
            { L_,  "CTX"                        },
            { L_,  "CTXS"                       },
            { L_,  "CVG"                        },
            { L_,  "CVH"                        },
            { L_,  "CVS"                        },
            { L_,  "CVX"                        },
            { L_,  "D"                          },
            { L_,  "DD"                         },
            { L_,  "DDR"                        },
            { L_,  "DE"                         },
            { L_,  "DELL"                       },
            { L_,  "DF"                         },
            { L_,  "DFS"                        },
            { L_,  "DGX"                        },
            { L_,  "DHI"                        },
            { L_,  "DHR"                        },
            { L_,  "DIS"                        },
            { L_,  "DOV"                        },
            { L_,  "DOW"                        },
            { L_,  "DPS"                        },
            { L_,  "DRI"                        },
            { L_,  "DTE"                        },
            { L_,  "DTV"                        },
            { L_,  "DUK"                        },
            { L_,  "DVA"                        },
            { L_,  "DVN"                        },
            { L_,  "DYN"                        },
            { L_,  "EBAY"                       },
            { L_,  "ECL"                        },
            { L_,  "ED"                         },
            { L_,  "EFX"                        },
            { L_,  "EIX"                        },
            { L_,  "EK"                         },
            { L_,  "EL"                         },
            { L_,  "EMC"                        },
            { L_,  "EMN"                        },
            { L_,  "EMR"                        },
            { L_,  "EOG"                        },
            { L_,  "EP"                         },
            { L_,  "EQ"                         },
            { L_,  "EQR"                        },
            { L_,  "ERTS"                       },
            { L_,  "ESRX"                       },
            { L_,  "ESV"                        },
            { L_,  "ETFC"                       },
            { L_,  "ETN"                        },
            { L_,  "ETR"                        },
            { L_,  "EXC"                        },
            { L_,  "EXPD"                       },
            { L_,  "EXPE"                       },
            { L_,  "F"                          },
            { L_,  "FAST"                       },
            { L_,  "FCX"                        },
            { L_,  "FDO"                        },
            { L_,  "FDX"                        },
            { L_,  "FE"                         },
            { L_,  "FHN"                        },
            { L_,  "FII"                        },
            { L_,  "FIS"                        },
            { L_,  "FISV"                       },
            { L_,  "FITB"                       },
            { L_,  "FLR"                        },
            { L_,  "FLS"                        },
            { L_,  "FO"                         },
            { L_,  "FPL"                        },
            { L_,  "FRX"                        },
            { L_,  "FTR"                        },
            { L_,  "GAS"                        },
            { L_,  "GCI"                        },
            { L_,  "GD"                         },
            { L_,  "GE"                         },
            { L_,  "GENZ"                       },
            { L_,  "GGP"                        },
            { L_,  "GILD"                       },
            { L_,  "GIS"                        },
            { L_,  "GLW"                        },
            { L_,  "GM"                         },
            { L_,  "GME"                        },
            { L_,  "GNW"                        },
            { L_,  "GOOG"                       },
            { L_,  "GPC"                        },
            { L_,  "GPS"                        },
            { L_,  "GR"                         },
            { L_,  "GS"                         },
            { L_,  "GT"                         },
            { L_,  "GWW"                        },
            { L_,  "HAL"                        },
            { L_,  "HAR"                        },
            { L_,  "HAS"                        },
            { L_,  "HBAN"                       },
            { L_,  "HCBK"                       },
            { L_,  "HCP"                        },
            { L_,  "HD"                         },
            { L_,  "HES"                        },
            { L_,  "HIG"                        },
            { L_,  "HNZ"                        },
            { L_,  "HOG"                        },
            { L_,  "HON"                        },
            { L_,  "HOT"                        },
            { L_,  "HPC"                        },
            { L_,  "HPQ"                        },
            { L_,  "HRB"                        },
            { L_,  "HRS"                        },
            { L_,  "HSP"                        },
            { L_,  "HST"                        },
            { L_,  "HSY"                        },
            { L_,  "HUM"                        },
            { L_,  "IBM"                        },
            { L_,  "ICE"                        },
            { L_,  "IFF"                        },
            { L_,  "IGT"                        },
            { L_,  "INTC"                       },
            { L_,  "INTU"                       },
            { L_,  "IP"                         },
            { L_,  "IPG"                        },
            { L_,  "IR"                         },
            { L_,  "ISRG"                       },
            { L_,  "ITT"                        },
            { L_,  "ITW"                        },
            { L_,  "IVZ"                        },
            { L_,  "JAVA"                       },
            { L_,  "JBL"                        },
            { L_,  "JCI"                        },
            { L_,  "JCP"                        },
            { L_,  "JDSU"                       },
            { L_,  "JEC"                        },
            { L_,  "JNJ"                        },
            { L_,  "JNPR"                       },
            { L_,  "JNS"                        },
            { L_,  "JNY"                        },
            { L_,  "JPM"                        },
            { L_,  "JWN"                        },
            { L_,  "K"                          },
            { L_,  "KBH"                        },
            { L_,  "KEY"                        },
            { L_,  "KFT"                        },
            { L_,  "KG"                         },
            { L_,  "KIM"                        },
            { L_,  "KLAC"                       },
            { L_,  "KMB"                        },
            { L_,  "KO"                         },
            { L_,  "KR"                         },
            { L_,  "KSS"                        },
            { L_,  "L"                          },
            { L_,  "LEG"                        },
            { L_,  "LEN"                        },
            { L_,  "LH"                         },
            { L_,  "LIZ"                        },
            { L_,  "LLL"                        },
            { L_,  "LLTC"                       },
            { L_,  "LLY"                        },
            { L_,  "LM"                         },
            { L_,  "LMT"                        },
            { L_,  "LNC"                        },
            { L_,  "LO"                         },
            { L_,  "LOW"                        },
            { L_,  "LSI"                        },
            { L_,  "LTD"                        },
            { L_,  "LUK"                        },
            { L_,  "LUV"                        },
            { L_,  "LXK"                        },
            { L_,  "M"                          },
            { L_,  "MA"                         },
            { L_,  "MAR"                        },
            { L_,  "MAS"                        },
            { L_,  "MAT"                        },
            { L_,  "MBI"                        },
            { L_,  "MCD"                        },
            { L_,  "MCHP"                       },
            { L_,  "MCK"                        },
            { L_,  "MCO"                        },
            { L_,  "MDP"                        },
            { L_,  "MDT"                        },
            { L_,  "MEE"                        },
            { L_,  "MER"                        },
            { L_,  "MET"                        },
            { L_,  "MHP"                        },
            { L_,  "MHS"                        },
            { L_,  "MI"                         },
            { L_,  "MIL"                        },
            { L_,  "MKC"                        },
            { L_,  "MMC"                        },
            { L_,  "MMM"                        },
            { L_,  "MO"                         },
            { L_,  "MOLX"                       },
            { L_,  "MON"                        },
            { L_,  "MOT"                        },
            { L_,  "MRK"                        },
            { L_,  "MRO"                        },
            { L_,  "MS"                         },
            { L_,  "MSFT"                       },
            { L_,  "MTB"                        },
            { L_,  "MTW"                        },
            { L_,  "MU"                         },
            { L_,  "MUR"                        },
            { L_,  "MWV"                        },
            { L_,  "MWW"                        },
            { L_,  "MYL"                        },
            { L_,  "NBL"                        },
            { L_,  "NBR"                        },
            { L_,  "NCC"                        },
            { L_,  "NDAQ"                       },
            { L_,  "NE"                         },
            { L_,  "NEM"                        },
            { L_,  "NI"                         },
            { L_,  "NKE"                        },
            { L_,  "NOC"                        },
            { L_,  "NOV"                        },
            { L_,  "NOVL"                       },
            { L_,  "NSC"                        },
            { L_,  "NSM"                        },
            { L_,  "NTAP"                       },
            { L_,  "NTRS"                       },
            { L_,  "NUE"                        },
            { L_,  "NVDA"                       },
            { L_,  "NVLS"                       },
            { L_,  "NWL"                        },
            { L_,  "NWS/A"                      },
            { L_,  "NYT"                        },
            { L_,  "NYX"                        },
            { L_,  "ODP"                        },
            { L_,  "OMC"                        },
            { L_,  "ORCL"                       },
            { L_,  "OXY"                        },
            { L_,  "PAYX"                       },
            { L_,  "PBG"                        },
            { L_,  "PBI"                        },
            { L_,  "PCAR"                       },
            { L_,  "PCG"                        },
            { L_,  "PCL"                        },
            { L_,  "PCP"                        },
            { L_,  "PDCO"                       },
            { L_,  "PEG"                        },
            { L_,  "PEP"                        },
            { L_,  "PFE"                        },
            { L_,  "PFG"                        },
            { L_,  "PG"                         },
            { L_,  "PGN"                        },
            { L_,  "PGR"                        },
            { L_,  "PH"                         },
            { L_,  "PHM"                        },
            { L_,  "PKI"                        },
            { L_,  "PLD"                        },
            { L_,  "PLL"                        },
            { L_,  "PM"                         },
            { L_,  "PNC"                        },
            { L_,  "PNW"                        },
            { L_,  "POM"                        },
            { L_,  "PPG"                        },
            { L_,  "PPL"                        },
            { L_,  "PRU"                        },
            { L_,  "PSA"                        },
            { L_,  "PTV"                        },
            { L_,  "PX"                         },
            { L_,  "PXD"                        },
            { L_,  "Q"                          },
            { L_,  "QCOM"                       },
            { L_,  "QLGC"                       },
            { L_,  "R"                          },
            { L_,  "RAI"                        },
            { L_,  "RDC"                        },
            { L_,  "RF"                         },
            { L_,  "RHI"                        },
            { L_,  "RIG"                        },
            { L_,  "RL"                         },
            { L_,  "ROH"                        },
            { L_,  "ROK"                        },
            { L_,  "RRC"                        },
            { L_,  "RRD"                        },
            { L_,  "RSH"                        },
            { L_,  "RTN"                        },
            { L_,  "RX"                         },
            { L_,  "S"                          },
            { L_,  "SBUX"                       },
            { L_,  "SCHW"                       },
            { L_,  "SE"                         },
            { L_,  "SEE"                        },
            { L_,  "SGP"                        },
            { L_,  "SHLD"                       },
            { L_,  "SHW"                        },
            { L_,  "SIAL"                       },
            { L_,  "SII"                        },
            { L_,  "SJM"                        },
            { L_,  "SLB"                        },
            { L_,  "SLE"                        },
            { L_,  "SLM"                        },
            { L_,  "SNA"                        },
            { L_,  "SNDK"                       },
            { L_,  "SNI"                        },
            { L_,  "SO"                         },
            { L_,  "SOV"                        },
            { L_,  "SPG"                        },
            { L_,  "SPLS"                       },
            { L_,  "SRE"                        },
            { L_,  "STI"                        },
            { L_,  "STJ"                        },
            { L_,  "STR"                        },
            { L_,  "STT"                        },
            { L_,  "STZ"                        },
            { L_,  "SUN"                        },
            { L_,  "SVU"                        },
            { L_,  "SWK"                        },
            { L_,  "SWN"                        },
            { L_,  "SWY"                        },
            { L_,  "SYK"                        },
            { L_,  "SYMC"                       },
            { L_,  "SYY"                        },
            { L_,  "T"                          },
            { L_,  "TAP"                        },
            { L_,  "TDC"                        },
            { L_,  "TE"                         },
            { L_,  "TEG"                        },
            { L_,  "TEL"                        },
            { L_,  "TER"                        },
            { L_,  "TGT"                        },
            { L_,  "THC"                        },
            { L_,  "TIE"                        },
            { L_,  "TIF"                        },
            { L_,  "TJX"                        },
            { L_,  "TLAB"                       },
            { L_,  "TMK"                        },
            { L_,  "TMO"                        },
            { L_,  "TROW"                       },
            { L_,  "TRV"                        },
            { L_,  "TSN"                        },
            { L_,  "TSO"                        },
            { L_,  "TSS"                        },
            { L_,  "TWX"                        },
            { L_,  "TXN"                        },
            { L_,  "TXT"                        },
            { L_,  "TYC"                        },
            { L_,  "UNH"                        },
            { L_,  "UNM"                        },
            { L_,  "UNP"                        },
            { L_,  "UPS"                        },
            { L_,  "USB"                        },
            { L_,  "UST"                        },
            { L_,  "UTX"                        },
            { L_,  "VAR"                        },
            { L_,  "VFC"                        },
            { L_,  "VIA/B"                      },
            { L_,  "VLO"                        },
            { L_,  "VMC"                        },
            { L_,  "VNO"                        },
            { L_,  "VRSN"                       },
            { L_,  "VZ"                         },
            { L_,  "WAG"                        },
            { L_,  "WAT"                        },
            { L_,  "WB"                         },
            { L_,  "WEC"                        },
            { L_,  "WFC"                        },
            { L_,  "WFMI"                       },
            { L_,  "WFR"                        },
            { L_,  "WFT"                        },
            { L_,  "WHR"                        },
            { L_,  "WIN"                        },
            { L_,  "WLP"                        },
            { L_,  "WMB"                        },
            { L_,  "WMI"                        },
            { L_,  "WMT"                        },
            { L_,  "WPI"                        },
            { L_,  "WPO"                        },
            { L_,  "WU"                         },
            { L_,  "WY"                         },
            { L_,  "WYE"                        },
            { L_,  "WYN"                        },
            { L_,  "X"                          },
            { L_,  "XEL"                        },
            { L_,  "XL"                         },
            { L_,  "XLNX"                       },
            { L_,  "XOM"                        },
            { L_,  "XRX"                        },
            { L_,  "XTO"                        },
            { L_,  "YHOO"                       },
            { L_,  "YUM"                        },
            { L_,  "ZION"                       },
            { L_,  "ZMH"                        },


            // The full Bloomberg stock tickers of the 499 members of the S&P
            // 500 as reported by {SPX Index MEMB<GO>} on 20081112
            { L_,  "A UN Equity"                },
            { L_,  "AA UN Equity"               },
            { L_,  "AAPL UW Equity"             },
            { L_,  "ABC UN Equity"              },
            { L_,  "ABI UN Equity"              },
            { L_,  "ABT UN Equity"              },
            { L_,  "ACAS UW Equity"             },
            { L_,  "ACS UN Equity"              },
            { L_,  "ADBE UW Equity"             },
            { L_,  "ADI UN Equity"              },
            { L_,  "ADM UN Equity"              },
            { L_,  "ADP UW Equity"              },
            { L_,  "ADSK UW Equity"             },
            { L_,  "AEE UN Equity"              },
            { L_,  "AEP UN Equity"              },
            { L_,  "AES UN Equity"              },
            { L_,  "AET UN Equity"              },
            { L_,  "AFL UN Equity"              },
            { L_,  "AGN UN Equity"              },
            { L_,  "AIG UN Equity"              },
            { L_,  "AIV UN Equity"              },
            { L_,  "AIZ UN Equity"              },
            { L_,  "AKAM UW Equity"             },
            { L_,  "AKS UN Equity"              },
            { L_,  "ALL UN Equity"              },
            { L_,  "ALTR UW Equity"             },
            { L_,  "AMAT UW Equity"             },
            { L_,  "AMD UN Equity"              },
            { L_,  "AMGN UW Equity"             },
            { L_,  "AMP UN Equity"              },
            { L_,  "AMT UN Equity"              },
            { L_,  "AMZN UW Equity"             },
            { L_,  "AN UN Equity"               },
            { L_,  "ANF UN Equity"              },
            { L_,  "AOC UN Equity"              },
            { L_,  "APA UN Equity"              },
            { L_,  "APC UN Equity"              },
            { L_,  "APD UN Equity"              },
            { L_,  "APH UN Equity"              },
            { L_,  "APOL UW Equity"             },
            { L_,  "ASH UN Equity"              },
            { L_,  "ATI UN Equity"              },
            { L_,  "AVB UN Equity"              },
            { L_,  "AVP UN Equity"              },
            { L_,  "AVY UN Equity"              },
            { L_,  "AW UN Equity"               },
            { L_,  "AXP UN Equity"              },
            { L_,  "AYE UN Equity"              },
            { L_,  "AZO UN Equity"              },
            { L_,  "BA UN Equity"               },
            { L_,  "BAC UN Equity"              },
            { L_,  "BAX UN Equity"              },
            { L_,  "BBBY UW Equity"             },
            { L_,  "BBT UN Equity"              },
            { L_,  "BBY UN Equity"              },
            { L_,  "BCR UN Equity"              },
            { L_,  "BDK UN Equity"              },
            { L_,  "BDX UN Equity"              },
            { L_,  "BEN UN Equity"              },
            { L_,  "BF/B UN Equity"             },
            { L_,  "BHI UN Equity"              },
            { L_,  "BIG UN Equity"              },
            { L_,  "BIIB UW Equity"             },
            { L_,  "BJS UN Equity"              },
            { L_,  "BK UN Equity"               },
            { L_,  "BLL UN Equity"              },
            { L_,  "BMC UN Equity"              },
            { L_,  "BMS UN Equity"              },
            { L_,  "BMY UN Equity"              },
            { L_,  "BNI UN Equity"              },
            { L_,  "BRCM UW Equity"             },
            { L_,  "BRL UN Equity"              },
            { L_,  "BSX UN Equity"              },
            { L_,  "BTU UN Equity"              },
            { L_,  "BUD UN Equity"              },
            { L_,  "BXP UN Equity"              },
            { L_,  "C UN Equity"                },
            { L_,  "CA UW Equity"               },
            { L_,  "CAG UN Equity"              },
            { L_,  "CAH UN Equity"              },
            { L_,  "CAM UN Equity"              },
            { L_,  "CAT UN Equity"              },
            { L_,  "CB UN Equity"               },
            { L_,  "CBE UN Equity"              },
            { L_,  "CBG UN Equity"              },
            { L_,  "CBS UN Equity"              },
            { L_,  "CCE UN Equity"              },
            { L_,  "CCL UN Equity"              },
            { L_,  "CEG UN Equity"              },
            { L_,  "CELG UW Equity"             },
            { L_,  "CF UN Equity"               },
            { L_,  "CHK UN Equity"              },
            { L_,  "CHRW UW Equity"             },
            { L_,  "CI UN Equity"               },
            { L_,  "CIEN UW Equity"             },
            { L_,  "CINF UW Equity"             },
            { L_,  "CIT UN Equity"              },
            { L_,  "CL UN Equity"               },
            { L_,  "CLX UN Equity"              },
            { L_,  "CMA UN Equity"              },
            { L_,  "CMCSA UW Equity"            },
            { L_,  "CME UW Equity"              },
            { L_,  "CMI UN Equity"              },
            { L_,  "CMS UN Equity"              },
            { L_,  "CNP UN Equity"              },
            { L_,  "CNX UN Equity"              },
            { L_,  "COF UN Equity"              },
            { L_,  "COG UN Equity"              },
            { L_,  "COH UN Equity"              },
            { L_,  "COL UN Equity"              },
            { L_,  "COP UN Equity"              },
            { L_,  "COST UW Equity"             },
            { L_,  "COV UN Equity"              },
            { L_,  "CPB UN Equity"              },
            { L_,  "CPWR UW Equity"             },
            { L_,  "CRM UN Equity"              },
            { L_,  "CSC UN Equity"              },
            { L_,  "CSCO UW Equity"             },
            { L_,  "CSX UN Equity"              },
            { L_,  "CTAS UW Equity"             },
            { L_,  "CTL UN Equity"              },
            { L_,  "CTSH UW Equity"             },
            { L_,  "CTX UN Equity"              },
            { L_,  "CTXS UW Equity"             },
            { L_,  "CVG UN Equity"              },
            { L_,  "CVH UN Equity"              },
            { L_,  "CVS UN Equity"              },
            { L_,  "CVX UN Equity"              },
            { L_,  "D UN Equity"                },
            { L_,  "DD UN Equity"               },
            { L_,  "DDR UN Equity"              },
            { L_,  "DE UN Equity"               },
            { L_,  "DELL UW Equity"             },
            { L_,  "DF UN Equity"               },
            { L_,  "DFS UN Equity"              },
            { L_,  "DGX UN Equity"              },
            { L_,  "DHI UN Equity"              },
            { L_,  "DHR UN Equity"              },
            { L_,  "DIS UN Equity"              },
            { L_,  "DOV UN Equity"              },
            { L_,  "DOW UN Equity"              },
            { L_,  "DPS UN Equity"              },
            { L_,  "DRI UN Equity"              },
            { L_,  "DTE UN Equity"              },
            { L_,  "DTV UW Equity"              },
            { L_,  "DUK UN Equity"              },
            { L_,  "DVA UN Equity"              },
            { L_,  "DVN UN Equity"              },
            { L_,  "DYN UN Equity"              },
            { L_,  "EBAY UW Equity"             },
            { L_,  "ECL UN Equity"              },
            { L_,  "ED UN Equity"               },
            { L_,  "EFX UN Equity"              },
            { L_,  "EIX UN Equity"              },
            { L_,  "EK UN Equity"               },
            { L_,  "EL UN Equity"               },
            { L_,  "EMC UN Equity"              },
            { L_,  "EMN UN Equity"              },
            { L_,  "EMR UN Equity"              },
            { L_,  "EOG UN Equity"              },
            { L_,  "EP UN Equity"               },
            { L_,  "EQ UN Equity"               },
            { L_,  "EQR UN Equity"              },
            { L_,  "ERTS UW Equity"             },
            { L_,  "ESRX UW Equity"             },
            { L_,  "ESV UN Equity"              },
            { L_,  "ETFC UW Equity"             },
            { L_,  "ETN UN Equity"              },
            { L_,  "ETR UN Equity"              },
            { L_,  "EXC UN Equity"              },
            { L_,  "EXPD UW Equity"             },
            { L_,  "EXPE UW Equity"             },
            { L_,  "F UN Equity"                },
            { L_,  "FAST UW Equity"             },
            { L_,  "FCX UN Equity"              },
            { L_,  "FDO UN Equity"              },
            { L_,  "FDX UN Equity"              },
            { L_,  "FE UN Equity"               },
            { L_,  "FHN UN Equity"              },
            { L_,  "FII UN Equity"              },
            { L_,  "FIS UN Equity"              },
            { L_,  "FISV UW Equity"             },
            { L_,  "FITB UW Equity"             },
            { L_,  "FLR UN Equity"              },
            { L_,  "FLS UN Equity"              },
            { L_,  "FO UN Equity"               },
            { L_,  "FPL UN Equity"              },
            { L_,  "FRX UN Equity"              },
            { L_,  "FTR UN Equity"              },
            { L_,  "GAS UN Equity"              },
            { L_,  "GCI UN Equity"              },
            { L_,  "GD UN Equity"               },
            { L_,  "GE UN Equity"               },
            { L_,  "GENZ UW Equity"             },
            { L_,  "GGP UP Equity"              },
            { L_,  "GILD UW Equity"             },
            { L_,  "GIS UN Equity"              },
            { L_,  "GLW UN Equity"              },
            { L_,  "GM UN Equity"               },
            { L_,  "GME UN Equity"              },
            { L_,  "GNW UN Equity"              },
            { L_,  "GOOG UW Equity"             },
            { L_,  "GPC UN Equity"              },
            { L_,  "GPS UN Equity"              },
            { L_,  "GR UN Equity"               },
            { L_,  "GS UN Equity"               },
            { L_,  "GT UN Equity"               },
            { L_,  "GWW UN Equity"              },
            { L_,  "HAL UN Equity"              },
            { L_,  "HAR UN Equity"              },
            { L_,  "HAS UN Equity"              },
            { L_,  "HBAN UW Equity"             },
            { L_,  "HCBK UW Equity"             },
            { L_,  "HCP UN Equity"              },
            { L_,  "HD UN Equity"               },
            { L_,  "HES UN Equity"              },
            { L_,  "HIG UN Equity"              },
            { L_,  "HNZ UN Equity"              },
            { L_,  "HOG UN Equity"              },
            { L_,  "HON UN Equity"              },
            { L_,  "HOT UN Equity"              },
            { L_,  "HPC UN Equity"              },
            { L_,  "HPQ UN Equity"              },
            { L_,  "HRB UN Equity"              },
            { L_,  "HRS UN Equity"              },
            { L_,  "HSP UN Equity"              },
            { L_,  "HST UN Equity"              },
            { L_,  "HSY UN Equity"              },
            { L_,  "HUM UN Equity"              },
            { L_,  "IBM UN Equity"              },
            { L_,  "ICE UN Equity"              },
            { L_,  "IFF UN Equity"              },
            { L_,  "IGT UN Equity"              },
            { L_,  "INTC UW Equity"             },
            { L_,  "INTU UW Equity"             },
            { L_,  "IP UN Equity"               },
            { L_,  "IPG UN Equity"              },
            { L_,  "IR UN Equity"               },
            { L_,  "ISRG UW Equity"             },
            { L_,  "ITT UN Equity"              },
            { L_,  "ITW UN Equity"              },
            { L_,  "IVZ UN Equity"              },
            { L_,  "JAVA UW Equity"             },
            { L_,  "JBL UN Equity"              },
            { L_,  "JCI UN Equity"              },
            { L_,  "JCP UN Equity"              },
            { L_,  "JDSU UW Equity"             },
            { L_,  "JEC UN Equity"              },
            { L_,  "JNJ UN Equity"              },
            { L_,  "JNPR UW Equity"             },
            { L_,  "JNS UN Equity"              },
            { L_,  "JNY UN Equity"              },
            { L_,  "JPM UN Equity"              },
            { L_,  "JWN UN Equity"              },
            { L_,  "K UN Equity"                },
            { L_,  "KBH UN Equity"              },
            { L_,  "KEY UN Equity"              },
            { L_,  "KFT UN Equity"              },
            { L_,  "KG UN Equity"               },
            { L_,  "KIM UN Equity"              },
            { L_,  "KLAC UW Equity"             },
            { L_,  "KMB UN Equity"              },
            { L_,  "KO UN Equity"               },
            { L_,  "KR UN Equity"               },
            { L_,  "KSS UN Equity"              },
            { L_,  "L UN Equity"                },
            { L_,  "LEG UN Equity"              },
            { L_,  "LEN UN Equity"              },
            { L_,  "LH UN Equity"               },
            { L_,  "LIZ UN Equity"              },
            { L_,  "LLL UN Equity"              },
            { L_,  "LLTC UW Equity"             },
            { L_,  "LLY UN Equity"              },
            { L_,  "LM UN Equity"               },
            { L_,  "LMT UN Equity"              },
            { L_,  "LNC UN Equity"              },
            { L_,  "LO UN Equity"               },
            { L_,  "LOW UN Equity"              },
            { L_,  "LSI UN Equity"              },
            { L_,  "LTD UN Equity"              },
            { L_,  "LUK UN Equity"              },
            { L_,  "LUV UN Equity"              },
            { L_,  "LXK UN Equity"              },
            { L_,  "M UN Equity"                },
            { L_,  "MA UN Equity"               },
            { L_,  "MAR UN Equity"              },
            { L_,  "MAS UN Equity"              },
            { L_,  "MAT UN Equity"              },
            { L_,  "MBI UN Equity"              },
            { L_,  "MCD UN Equity"              },
            { L_,  "MCHP UW Equity"             },
            { L_,  "MCK UN Equity"              },
            { L_,  "MCO UN Equity"              },
            { L_,  "MDP UN Equity"              },
            { L_,  "MDT UN Equity"              },
            { L_,  "MEE UN Equity"              },
            { L_,  "MER UN Equity"              },
            { L_,  "MET UN Equity"              },
            { L_,  "MHP UN Equity"              },
            { L_,  "MHS UN Equity"              },
            { L_,  "MI UN Equity"               },
            { L_,  "MIL UN Equity"              },
            { L_,  "MKC UN Equity"              },
            { L_,  "MMC UN Equity"              },
            { L_,  "MMM UN Equity"              },
            { L_,  "MO UN Equity"               },
            { L_,  "MOLX UW Equity"             },
            { L_,  "MON UN Equity"              },
            { L_,  "MOT UN Equity"              },
            { L_,  "MRK UN Equity"              },
            { L_,  "MRO UN Equity"              },
            { L_,  "MS UN Equity"               },
            { L_,  "MSFT UW Equity"             },
            { L_,  "MTB UN Equity"              },
            { L_,  "MTW UN Equity"              },
            { L_,  "MU UN Equity"               },
            { L_,  "MUR UN Equity"              },
            { L_,  "MWV UN Equity"              },
            { L_,  "MWW UN Equity"              },
            { L_,  "MYL UN Equity"              },
            { L_,  "NBL UN Equity"              },
            { L_,  "NBR UN Equity"              },
            { L_,  "NCC UN Equity"              },
            { L_,  "NDAQ UW Equity"             },
            { L_,  "NE UN Equity"               },
            { L_,  "NEM UN Equity"              },
            { L_,  "NI UN Equity"               },
            { L_,  "NKE UN Equity"              },
            { L_,  "NOC UN Equity"              },
            { L_,  "NOV UN Equity"              },
            { L_,  "NOVL UW Equity"             },
            { L_,  "NSC UN Equity"              },
            { L_,  "NSM UN Equity"              },
            { L_,  "NTAP UW Equity"             },
            { L_,  "NTRS UW Equity"             },
            { L_,  "NUE UN Equity"              },
            { L_,  "NVDA UW Equity"             },
            { L_,  "NVLS UW Equity"             },
            { L_,  "NWL UN Equity"              },
            { L_,  "NWS/A UN Equity"            },
            { L_,  "NYT UN Equity"              },
            { L_,  "NYX UN Equity"              },
            { L_,  "ODP UN Equity"              },
            { L_,  "OMC UN Equity"              },
            { L_,  "ORCL UW Equity"             },
            { L_,  "OXY UN Equity"              },
            { L_,  "PAYX UW Equity"             },
            { L_,  "PBG UN Equity"              },
            { L_,  "PBI UN Equity"              },
            { L_,  "PCAR UW Equity"             },
            { L_,  "PCG UN Equity"              },
            { L_,  "PCL UN Equity"              },
            { L_,  "PCP UN Equity"              },
            { L_,  "PDCO UW Equity"             },
            { L_,  "PEG UN Equity"              },
            { L_,  "PEP UN Equity"              },
            { L_,  "PFE UN Equity"              },
            { L_,  "PFG UN Equity"              },
            { L_,  "PG UN Equity"               },
            { L_,  "PGN UN Equity"              },
            { L_,  "PGR UN Equity"              },
            { L_,  "PH UN Equity"               },
            { L_,  "PHM UN Equity"              },
            { L_,  "PKI UN Equity"              },
            { L_,  "PLD UN Equity"              },
            { L_,  "PLL UN Equity"              },
            { L_,  "PM UN Equity"               },
            { L_,  "PNC UN Equity"              },
            { L_,  "PNW UN Equity"              },
            { L_,  "POM UN Equity"              },
            { L_,  "PPG UN Equity"              },
            { L_,  "PPL UN Equity"              },
            { L_,  "PRU UN Equity"              },
            { L_,  "PSA UN Equity"              },
            { L_,  "PTV UN Equity"              },
            { L_,  "PX UN Equity"               },
            { L_,  "PXD UN Equity"              },
            { L_,  "Q UN Equity"                },
            { L_,  "QCOM UW Equity"             },
            { L_,  "QLGC UW Equity"             },
            { L_,  "R UN Equity"                },
            { L_,  "RAI UN Equity"              },
            { L_,  "RDC UN Equity"              },
            { L_,  "RF UN Equity"               },
            { L_,  "RHI UN Equity"              },
            { L_,  "RIG UN Equity"              },
            { L_,  "RL UN Equity"               },
            { L_,  "ROH UN Equity"              },
            { L_,  "ROK UN Equity"              },
            { L_,  "RRC UN Equity"              },
            { L_,  "RRD UN Equity"              },
            { L_,  "RSH UN Equity"              },
            { L_,  "RTN UN Equity"              },
            { L_,  "RX UN Equity"               },
            { L_,  "S UN Equity"                },
            { L_,  "SBUX UW Equity"             },
            { L_,  "SCHW UW Equity"             },
            { L_,  "SE UN Equity"               },
            { L_,  "SEE UN Equity"              },
            { L_,  "SGP UN Equity"              },
            { L_,  "SHLD UW Equity"             },
            { L_,  "SHW UN Equity"              },
            { L_,  "SIAL UW Equity"             },
            { L_,  "SII UN Equity"              },
            { L_,  "SJM UN Equity"              },
            { L_,  "SLB UN Equity"              },
            { L_,  "SLE UN Equity"              },
            { L_,  "SLM UN Equity"              },
            { L_,  "SNA UN Equity"              },
            { L_,  "SNDK UW Equity"             },
            { L_,  "SNI UN Equity"              },
            { L_,  "SO UN Equity"               },
            { L_,  "SOV UN Equity"              },
            { L_,  "SPG UN Equity"              },
            { L_,  "SPLS UW Equity"             },
            { L_,  "SRE UN Equity"              },
            { L_,  "STI UN Equity"              },
            { L_,  "STJ UN Equity"              },
            { L_,  "STR UN Equity"              },
            { L_,  "STT UN Equity"              },
            { L_,  "STZ UN Equity"              },
            { L_,  "SUN UN Equity"              },
            { L_,  "SVU UN Equity"              },
            { L_,  "SWK UN Equity"              },
            { L_,  "SWN UN Equity"              },
            { L_,  "SWY UN Equity"              },
            { L_,  "SYK UN Equity"              },
            { L_,  "SYMC UW Equity"             },
            { L_,  "SYY UN Equity"              },
            { L_,  "T UN Equity"                },
            { L_,  "TAP UN Equity"              },
            { L_,  "TDC UN Equity"              },
            { L_,  "TE UN Equity"               },
            { L_,  "TEG UN Equity"              },
            { L_,  "TEL UN Equity"              },
            { L_,  "TER UN Equity"              },
            { L_,  "TGT UN Equity"              },
            { L_,  "THC UN Equity"              },
            { L_,  "TIE UN Equity"              },
            { L_,  "TIF UN Equity"              },
            { L_,  "TJX UN Equity"              },
            { L_,  "TLAB UW Equity"             },
            { L_,  "TMK UN Equity"              },
            { L_,  "TMO UN Equity"              },
            { L_,  "TROW UW Equity"             },
            { L_,  "TRV UN Equity"              },
            { L_,  "TSN UN Equity"              },
            { L_,  "TSO UN Equity"              },
            { L_,  "TSS UN Equity"              },
            { L_,  "TWX UN Equity"              },
            { L_,  "TXN UN Equity"              },
            { L_,  "TXT UN Equity"              },
            { L_,  "TYC UN Equity"              },
            { L_,  "UNH UN Equity"              },
            { L_,  "UNM UN Equity"              },
            { L_,  "UNP UN Equity"              },
            { L_,  "UPS UN Equity"              },
            { L_,  "USB UN Equity"              },
            { L_,  "UST UN Equity"              },
            { L_,  "UTX UN Equity"              },
            { L_,  "VAR UN Equity"              },
            { L_,  "VFC UN Equity"              },
            { L_,  "VIA/B UN Equity"            },
            { L_,  "VLO UN Equity"              },
            { L_,  "VMC UN Equity"              },
            { L_,  "VNO UN Equity"              },
            { L_,  "VRSN UW Equity"             },
            { L_,  "VZ UN Equity"               },
            { L_,  "WAG UN Equity"              },
            { L_,  "WAT UN Equity"              },
            { L_,  "WB UN Equity"               },
            { L_,  "WEC UN Equity"              },
            { L_,  "WFC UN Equity"              },
            { L_,  "WFMI UW Equity"             },
            { L_,  "WFR UN Equity"              },
            { L_,  "WFT UN Equity"              },
            { L_,  "WHR UN Equity"              },
            { L_,  "WIN UN Equity"              },
            { L_,  "WLP UN Equity"              },
            { L_,  "WMB UN Equity"              },
            { L_,  "WMI UN Equity"              },
            { L_,  "WMT UN Equity"              },
            { L_,  "WPI UN Equity"              },
            { L_,  "WPO UN Equity"              },
            { L_,  "WU UN Equity"               },
            { L_,  "WY UN Equity"               },
            { L_,  "WYE UN Equity"              },
            { L_,  "WYN UN Equity"              },
            { L_,  "X UN Equity"                },
            { L_,  "XEL UN Equity"              },
            { L_,  "XL UN Equity"               },
            { L_,  "XLNX UW Equity"             },
            { L_,  "XOM UN Equity"              },
            { L_,  "XRX UN Equity"              },
            { L_,  "XTO UN Equity"              },
            { L_,  "YHOO UW Equity"             },
            { L_,  "YUM UN Equity"              },
            { L_,  "ZION UW Equity"             },
            { L_,  "ZMH UN Equity"              },
            // Some data only differing by the final element to ensure the
            // whole string is hashed
            { L_,  "AAAAAAAAAAAAAAAAAAAAAAAA"   },
            { L_,  "AAAAAAAAAAAAAAAAAAAAAAAB"   },
            { L_,  "AAAAAAAAAAAAAAAAAAAAAAAC"   },
            { L_,  "AAAAAAAAAAAAAAAAAAAAAAAD"   },
            { L_,  "AAAAAAAAAAAAAAAAAAAAAAAE"   },
            { L_,  "AAAAAAAAAAAAAAAAAAAAAAAF"   },
            { L_,  "AAAAAAAAAAAAAAAAAAAAAAAG"   },
            { L_,  "AAAAAAAAAAAAAAAAAAAAAAAH"   },
        };

        enum { NUM_DATA = sizeof DATA / sizeof *DATA };

        std::map<Obj, std::size_t> hash_results;
        std::map<std::size_t, int> hash_value_counts;

        bsl::hash<Obj> bsl_hash_function;
        bslh::Hash<>   bslh_hash_function;

        // Capture all the hash values.
        for (int ti = 0; ti < NUM_DATA; ++ti) {
            const int   LINE  = DATA[ti].d_line;
            const char *STR_p = DATA[ti].d_str_p;
            Obj o(STR_p);

            std::size_t hash_value =
                                    static_cast<size_t>(bslh_hash_function(o));
            std::size_t bsl_hash_value =
                                     static_cast<size_t>(bsl_hash_function(o));

            // Ensure bslh::Hash and bsl::hash produce the same value
            ASSERT(hash_value == bsl_hash_value);

            if (veryVerbose) {
                printf("%4d: STR=%-20s, HASH=" ZU "\n", LINE,STR_p,hash_value);
            }

            hash_results[o] = hash_value;
            hash_value_counts[hash_value]++;
        }

        // Repeat all hashes in reverse order, making sure we get the same
        // values as last time.  Copy the data to ensure we are hashing the
        // same data from different memory locations, ensuring that we get the
        // same hash even when the data is stored elsewhere (will also spot if
        // we are hashing beyond the end of the string).

        for (int ti = NUM_DATA - 1; ti >= 0; --ti) {
            const int   LINE  = DATA[ti].d_line;
            const char *STR_p = DATA[ti].d_str_p;
            char        strCopy [40];
            Obj o(strcpy(strCopy, STR_p));

            std::size_t hash_value = bslh_hash_function(o);
            LOOP_ASSERT(LINE, hash_results[o] == hash_value);
        }

        // Make sure that no particular hash value occurred more than twice.
        //
        std::map<std::size_t, int>::iterator i   = hash_value_counts.begin();
        std::map<std::size_t, int>::iterator end = hash_value_counts.end();
        for (; i != end; ++i) {
            if (verbose && i->second > 1) {
                std::cout << "Hash value "
                          << std::hex << i->first << std::dec
                          << " occurs "
                          << i->second
                          << " time(s)"
                          << std::endl;
            }

            ASSERT(3 > i->second);
        }
      } break;

      case 7: {
        // --------------------------------------------------------------------
        // TESTING ADDITION OPERATORS
        //
        // Concerns:
        //   Each function must return the expected value (consistent with its
        //   nominal primitive-operator counterpart).
        //
        // Plan:
        //   Specify a set of strings and the assert addition operators
        //   return the correct results. The basic_string operator+= is being
        //   tested here because the bslstl_string test driver can not test
        //   using StringRef without introducing cyclic dependencies.
        //
        // Testing:
        //   basic_string operator+(const StringRef& l, const StringRef& r);
        //   basic_string operator+(const bsl::string& l, const StringRef& r);
        //   basic_string operator+(const StringRef& l, const bsl::string& r);
        //   basic_string operator+(const std::string& l, StringRef r);
        //   basic_string operator+(const StringRef& l, std::string r);
        //   basic_string operator+(const char *l, const StringRef& r);
        //   basic_string operator+(const StringRef& l, const char *r);
        //   basic_string operator+(const StringRef& l, const StringRef& r);
        //   basic_string basic_string::operator+=(const StringRefData& strRf);
        // --------------------------------------------------------------------

        if (verbose) std::cout << "\nTESTING ADDITION OPERATORS"
                                  "\n==========================\n";

        static const struct {
            int         d_line;
            const char *d_ca1_p;  // char array 1
            const char *d_ca2_p;  // char array 2
            const char *d_result_p;
        } DATA[] = {
            //line string1 string2 result
            //---- ------- ------- ------
            { L_,    ""  ,   ""  , ""     },
            { L_,    " " ,   " " , "  "   },
            { L_,    "a" ,   ""  , "a"    },
            { L_,    "a" ,   " " , "a "   },
            { L_,    ""  ,   "a" , "a"    },
            { L_,    " " ,   "a" , " a"   },
            { L_,    "a" ,   "a" , "aa"   },
            { L_,    "a" ,   "b" , "ab"   },
            { L_,    "b" ,   "a" , "ba"   },
            { L_,    "ab",   ""  , "ab"   },
            { L_,    "ab",   " " , "ab "  },
            { L_,    "ab",   "c" , "abc"  },
            { L_,    "a" ,   "bc", "abc"  },
            { L_,    "ab",   "cd", "abcd" }
        };

        enum { NUM_DATA = sizeof DATA / sizeof *DATA };

        for (int ti = 0; ti < NUM_DATA; ++ti) {
            const int   LINE         = DATA[ti].d_line;
            const char *CA1_p        = DATA[ti].d_ca1_p;
            const char *CA2_p        = DATA[ti].d_ca2_p;
            const bsl::string RESULT = bsl::string(DATA[ti].d_result_p);

            if (veryVerbose) {
                std::cout << "\nRESULT  = \"" << RESULT  << "\"" << std::endl;
            }

            Obj x1(CA1_p);  const Obj& X1 = x1;
            Obj x2(CA2_p);  const Obj& X2 = x2;

            if (veryVerbose) {
                std::cout << "\tX1 = \"" << X1 << "\", "
                          << "X2 = \""   << X2 << "\", " << std::endl;
            }

            // StringRef versus StringRef
            LOOP_ASSERT(LINE, RESULT == (X1  + X2));

            if (veryVerbose) {
                std::cout << "\tCA1 = \"" << CA1_p << "\", "
                          << "CA2 = \""   << CA2_p << "\", " << std::endl;
            }

            // char * versus StringRef
            LOOP_ASSERT(LINE, RESULT == (CA1_p + X2));

            // StringRef versus char *
            LOOP_ASSERT(LINE, RESULT == (X1  + CA2_p));

            bsl::string s1(CA1_p);  const bsl::string& S1 = s1;
            bsl::string s2(CA2_p);  const bsl::string& S2 = s2;

            if (veryVerbose) {
                std::cout << "\tS1 = \"" << S1 << "\", "
                          << "S2 = \""   << S2 << "\", " << std::endl;
            }

            // bsl::string versus StringRef
            LOOP_ASSERT(LINE, RESULT == (S1  + X2));

            // StringRef versus bsl::string
            LOOP_ASSERT(LINE, RESULT == (X1  + S2));

            std::string s3(CA1_p);  const std::string& S3 = s3;
            std::string s4(CA2_p);  const std::string& S4 = s4;

            if (veryVerbose) {
                std::cout << "\tS3 = \"" << S3 << "\", "
                          << "S4 = \""   << S4 << "\", " << std::endl;
            }

            // `std::string` versus StringRef
            LOOP_ASSERT(LINE, RESULT == (S3  + X2));

            // StringRef versus `std::string`
            LOOP_ASSERT(LINE, RESULT == (X1  + S4));

            // `bsl::string` versus `bsl::string`.  This test is to ensure no
            // overloading ambiguity was introduced.

            LOOP_ASSERT(LINE, RESULT == (S1  + S2));

            // `std::string` versus `bsl::string`.  This test is to
            // ensure no overloading ambiguity was introduced.

            LOOP_ASSERT(LINE, RESULT == (S3  + S4));

            // bsl::string with StringRef concatenated on.  See comments at top
            // of section for explanation.

            // Ensure += returns correctly
            LOOP2_ASSERT(LINE, RESULT, RESULT == (s1 += X2));
            // Ensure += left operand has proper value afterwards
            LOOP3_ASSERT(LINE, RESULT, s1, RESULT == s1);
        }
      } break;
      case 6: {
        // --------------------------------------------------------------------
        // TESTING MANIPULATORS
        //
        // Concerns:
        //   The begin and end members must be correctly set by the different
        //   assignment manipulators.
        //
        // Plan:
        //   Test each of the assignment functions with empty and non-empty
        //   strings.
        //
        // Testing:
        //   void reset();
        //   void assign(const char *begin, const char *end);
        //   void assign(const char *begin, size_type length);
        //   void assign(const char *begin);
        //   void assign(const bsl::string& begin);
        // --------------------------------------------------------------------

        if (verbose) std::cout << "\nTESTING MANIPULATORS"
                                  "\n====================\n";

        if (verbose) std::cout << "\nTesting:\n\t`reset()`\n\t`assign()`"
                               << "\n= = = = = = = = = = = ="
                               << std::endl;
        if (veryVerbose)
            std::cout << "\nreset()"
                      << "\n=  =  ="
                      << std::endl;
        {
            // Empty string (default constructor)
            Obj es1;  const Obj& ES1 = es1;

            ASSERT(ES1.isEmpty());
            ASSERT(ES1.length()  == 0);
            ASSERT(ES1.begin()   == ES1.end());

            es1.reset();

            ASSERT(ES1.isEmpty());
            ASSERT(ES1.length()  == 0);
            ASSERT(ES1.begin()   == ES1.end());

            // Empty string
            Obj es2(EMPTY_STRING);  const Obj& ES2 = es2;

            ASSERT(ES2.isEmpty());
            ASSERT(ES2.length()  == 0);
            ASSERT(ES2.begin()   == ES2.end());

            es2.reset();

            ASSERT(ES2.isEmpty());
            ASSERT(ES2.length()  == 0);
            ASSERT(ES2.begin()   == ES2.end());

            // Non-empty string
            Obj nes(NON_EMPTY_STRING);  const Obj& NES = nes;

            ASSERT(!NES.isEmpty());
            ASSERT(NES.length()  != 0);
            ASSERT(NES.begin()   != NES.end());

            nes.reset();

            ASSERT(NES.isEmpty());
            ASSERT(NES.length()  == 0);
            ASSERT(NES.begin()   == NES.end());

            // Non-empty sub-string
            Obj ness(NON_EMPTY_STRING + 2, NON_EMPTY_STRING + 6);
            const Obj& NESS = ness;

            ASSERT(!NESS.isEmpty());
            ASSERT(NESS.length()  != 0);
            ASSERT(NESS.begin()   != NESS.end());

            ness.reset();

            ASSERT(NESS.isEmpty());
            ASSERT(NESS.length()  == 0);
            ASSERT(NESS.begin()   == NESS.end());
        }

        if (verbose) std::cout << "\nTesting assign functions"
                               << "\n= = = = = = = = = = = = " << std::endl;
        if (veryVerbose)
            std::cout << "\nassign(const char *begin, const char *end)"
                      << "\n=  =  =  =  =  =  =  =  =  =  =  =  =  =  "
                      << std::endl;
        {
            // Empty string to non-empty string
            Obj x1(EMPTY_STRING, EMPTY_STRING + std::strlen(EMPTY_STRING));
            const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()  == 0);
            ASSERT(X1.begin()   == X1.end());
            ASSERT(X1.begin()   == EMPTY_STRING);
            ASSERT(X1.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            x1.assign(NON_EMPTY_STRING,
                      NON_EMPTY_STRING + std::strlen(NON_EMPTY_STRING));

            ASSERT(!X1.isEmpty());
            ASSERT(X1.length()  != 0);
            ASSERT(X1.begin()   != X1.end());
            ASSERT(X1.begin()   == NON_EMPTY_STRING);
            ASSERT(X1.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            // Non-empty string to non-empty sub-string
            Obj x2(NON_EMPTY_STRING,
                   NON_EMPTY_STRING + std::strlen(NON_EMPTY_STRING));
            const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  != 0);
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING);
            ASSERT(X2.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            x2.assign(NON_EMPTY_STRING + 2,
                      NON_EMPTY_STRING + 6);

            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  != 0);
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING + 2);
            ASSERT(X2.end()     == NON_EMPTY_STRING + 6);
        }

        if (veryVerbose)
            std::cout << "\nassign(const char *begin, size_type length)"
                      << "\nassign(const char *begin, INT_TYPE length)"
                      << "\n=  =  =  =  =  =  =  =  =  =  =  =  = = = =\n";
        {
            // Empty string to non-empty string
            Obj x1(EMPTY_STRING, EMPTY_STRING + std::strlen(EMPTY_STRING));
            const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()  == 0);
            ASSERT(X1.begin()   == X1.end());
            ASSERT(X1.begin()   == EMPTY_STRING);
            ASSERT(X1.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            x1.assign(NON_EMPTY_STRING, std::strlen(NON_EMPTY_STRING));

            ASSERT(!X1.isEmpty());
            ASSERT(X1.length()  != 0);
            ASSERT(X1.begin()   != X1.end());
            ASSERT(X1.begin()   == NON_EMPTY_STRING);
            ASSERT(X1.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            // Non-empty string to non-empty sub-string
            Obj x2(NON_EMPTY_STRING,
                   NON_EMPTY_STRING + std::strlen(NON_EMPTY_STRING));
            const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  != 0);
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING);
            ASSERT(X2.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            x2.assign(NON_EMPTY_STRING + 2, 4);

            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  != 0);
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING + 2);
            ASSERT(X2.end()     == NON_EMPTY_STRING + 6);

          // Assorted integer types for length
#define TEST_LITERAL_ZERO(LITERAL_ZERO)                                       \
        {                                                                     \
          if (veryVeryVerbose) {                                              \
              std::cout << "Literal zero " #LITERAL_ZERO "\n";                \
          }                                                                   \
                                                                              \
          Obj y;                                                              \
          const Obj & Y = y;                                                  \
          y.assign(EMPTY_STRING, LITERAL_ZERO);                               \
          ASSERT(Y.length()  == 0);                                           \
          ASSERT(Y.begin()   == Y.end());                                     \
          ASSERT(Y.begin()   == EMPTY_STRING);                                \
          ASSERT(Y.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));    \
        }

#define TEST_TYPE(INT_TYPE)                                                   \
        {                                                                     \
          if (veryVeryVerbose) {                                              \
              std::cout << "Integral type " #INT_TYPE "\n";                   \
          }                                                                   \
                                                                              \
          Obj y;                                                              \
          y.assign(NON_EMPTY_STRING,                                          \
                static_cast<INT_TYPE>(std::strlen(NON_EMPTY_STRING)));        \
          const Obj& Y = y;                                                   \
          ASSERT(!Y.isEmpty());                                               \
          ASSERT(Y.length()  == std::strlen(NON_EMPTY_STRING));               \
          ASSERT(Y.begin()   != Y.end());                                     \
          ASSERT(Y.begin()   == NON_EMPTY_STRING);                            \
          ASSERT(Y.end()     == NON_EMPTY_STRING +                            \
                                std::strlen(NON_EMPTY_STRING));               \
        }

#define TEST_INT_TYPE(INT_TYPE, LITERAL_ZERO)                                 \
        TEST_LITERAL_ZERO(LITERAL_ZERO)                                       \
        TEST_TYPE(INT_TYPE)

            TEST_INT_TYPE(short, (short)0)
            TEST_INT_TYPE(unsigned short, (unsigned short)0)
            TEST_INT_TYPE(int, 0)
            TEST_INT_TYPE(unsigned, 0u)
            TEST_INT_TYPE(long, 0l)
            TEST_INT_TYPE(unsigned long, 0ul)
            TEST_INT_TYPE(long long, 0ll)
            TEST_INT_TYPE(unsigned long long, 0ull)

            enum Enum { k_LOCAL_ENUM_ZERO_VALUE, k_LOCAL_ENUM_MAX = 0xFFFF };
            enum      { k_LOCAL_ZERO_VALUE,      k_LOCAL_MAX      = 0xFFFF };

            TEST_LITERAL_ZERO(TestData<char>::k_ENUM_ZERO_VALUE)
            TEST_TYPE(TestData<char>::Enum)
            TEST_LITERAL_ZERO(TestData<char>::k_ZERO_VALUE)

            TEST_LITERAL_ZERO(k_LOCAL_ENUM_ZERO_VALUE)
            TEST_TYPE(Enum)
            TEST_LITERAL_ZERO(k_LOCAL_ZERO_VALUE)
#undef TEST_LITERAL_ZERO
#undef TEST_TYPE
#undef TEST_INT_TYPE
        }

        if (veryVerbose)
            std::cout << "\nassign(const char *begin)"
                      << "\n=  =  =  =  =  =  =  =  ="
                      << std::endl;
        {
            // Empty string to Null string
            Obj x1(EMPTY_STRING);
            const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()  == 0);
            ASSERT(X1.begin()   == X1.end());
            ASSERT(X1.begin()   == EMPTY_STRING);
            ASSERT(X1.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            // non-empty string to Null string
            Obj x2(NON_EMPTY_STRING);
            const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  != 0);
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING);
            ASSERT(X2.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            // Empty string to non-empty string
            Obj x3(EMPTY_STRING, EMPTY_STRING + std::strlen(EMPTY_STRING));
            const Obj& X3 = x3;
            ASSERT(X3.isEmpty());
            ASSERT(X3.length()  == 0);
            ASSERT(X3.begin()   == X3.end());
            ASSERT(X3.begin()   == EMPTY_STRING);
            ASSERT(X3.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            x3.assign(NON_EMPTY_STRING);

            ASSERT(!X3.isEmpty());
            ASSERT(X3.length()  != 0);
            ASSERT(X3.begin()   != X3.end());
            ASSERT(X3.begin()   == NON_EMPTY_STRING);
            ASSERT(X3.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            // Non-empty string to non-empty sub-string
            Obj x4(NON_EMPTY_STRING,
                   NON_EMPTY_STRING + std::strlen(NON_EMPTY_STRING));
            const Obj& X4 = x4;
            ASSERT(!X4.isEmpty());
            ASSERT(X4.length()  != 0);
            ASSERT(X4.begin()   != X4.end());
            ASSERT(X4.begin()   == NON_EMPTY_STRING);
            ASSERT(X4.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            x4.assign(NON_EMPTY_STRING + 2);

            ASSERT(!X4.isEmpty());
            ASSERT(X4.length()  != 0);
            ASSERT(X4.begin()   != X4.end());
            ASSERT(X4.begin()   == NON_EMPTY_STRING + 2);
            ASSERT(X4.end()     == NON_EMPTY_STRING +
                                 std::strlen(NON_EMPTY_STRING));
        }

        if (veryVerbose)
            std::cout << "\nassign(const bsl::string& begin)"
                      << "\n=  =  =  =  =  =  =  =  =  =  = "
                      << std::endl;
        {
            // Empty string to non-empty string
            Obj x1(EMPTY_STRING, EMPTY_STRING + std::strlen(EMPTY_STRING));
            const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()  == 0);
            ASSERT(X1.begin()   == X1.end());
            ASSERT(X1.begin()   == EMPTY_STRING);
            ASSERT(X1.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            const bsl::string S1(NON_EMPTY_STRING);
            x1.assign(S1);

            ASSERT(!X1.isEmpty());
            ASSERT(X1.length()    != 0);
            ASSERT(X1.begin()     != X1.end());
            ASSERT(&*X1.begin()   == &*S1.begin());
            ASSERT((&*X1.begin() + (X1.end() - X1.begin())) ==
                   (&*S1.begin() + (S1.end() - S1.begin())));

            // Non-empty string to non-empty sub-string
            Obj x2(NON_EMPTY_STRING,
                   NON_EMPTY_STRING + std::strlen(NON_EMPTY_STRING));
            const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  != 0);
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING);
            ASSERT(X2.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            const bsl::string S2(NON_EMPTY_STRING + 2);
            x2.assign(S2);

            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()   != 0);
            ASSERT(X2.begin()    != X2.end());
            ASSERT(&*X2.begin()   == &*S2.begin());
            ASSERT((&*X2.begin() + (X2.end() - X2.begin())) ==
                   (&*S2.begin() + (S2.end() - S2.begin())));
        }
      } break;
      case 5: {
        // --------------------------------------------------------------------
        // TESTING COMPARISON OPERATORS
        //
        // Concerns:
        //   Any subtle variation in value must be detected by the comparison
        //   operators.  This test is now redundant, and less thorough, than
        //   testing done in test case 3.
        //
        // Plan:
        //   Specify a set of strings and the assert comparison operators
        //   return the correct results.
        // --------------------------------------------------------------------

        if (verbose) std::cout << "\nTESTING COMPARISON OPERATORS"
                                  "\n============================\n";

        static const struct {
            int         d_line;
            const char *d_ca1_p;  // char array
            const char *d_ca2_p;  // char array
            bool        d_lt;
            bool        d_gt;
            bool        d_lteq;
            bool        d_gteq;
            bool        d_eq;
        } DATA[] = {
            //line string1 string2   lt     gt    lteq   gteq   eq
            //---- ------- ------- ------ ------ ------ ------  --
            { L_,    ""  ,   ""  , false, false, true , true  , true  },
            { L_,    " " ,   " " , false, false, true , true  , true  },
            { L_,    "a" ,   ""  , false, true , false, true  , false },
            { L_,    "a" ,   " " , false, true , false, true  , false },
            { L_,    ""  ,   "a" , true , false, true , false , false },
            { L_,    " " ,   "a" , true , false, true , false , false },
            { L_,    "a" ,   "a" , false, false, true , true  , true  },
            { L_,    "a" ,   "b" , true , false, true , false , false },
            { L_,    "b" ,   "a" , false, true , false, true  , false },
            { L_,    "ab",   ""  , false, true , false, true  , false },
            { L_,    "ab",   " " , false, true , false, true  , false },
            { L_,    "ab",   "a" , false, true , false, true  , false },
            { L_,    "a" ,   "ab", true , false, true,  false , false },
            { L_,    "ab",   "ab", false, false, true,  true  , true  }
        };

        enum { NUM_DATA = sizeof DATA / sizeof *DATA };

        for (int ti = 0; ti < NUM_DATA; ++ti) {
            const int   LINE  = DATA[ti].d_line;
            const char *CA1_p = DATA[ti].d_ca1_p;
            const char *CA2_p = DATA[ti].d_ca2_p;
            const bool  LT    = DATA[ti].d_lt;
            const bool  GT    = DATA[ti].d_gt;
            const bool  LTEQ  = DATA[ti].d_lteq;
            const bool  GTEQ  = DATA[ti].d_gteq;
            const bool  EQ    = DATA[ti].d_eq;

            if (veryVerbose) {
                std::cout << std::endl;
                P_(LT) P_(GT) P_(LTEQ) P_(GTEQ) P(EQ);
            }

            Obj x1(CA1_p);  const Obj& X1 = x1;
            Obj x2(CA2_p);  const Obj& X2 = x2;

            if (veryVerbose) {
                std::cout << "\tX1 = \"" << X1 << "\", "
                          << "X2 = \"" << X2 << "\", " << std::endl;
            }

            // StringRef versus StringRef
            LOOP_ASSERT(LINE, LT   == (X1 <  X2));
            LOOP_ASSERT(LINE, GT   == (X1 >  X2));
            LOOP_ASSERT(LINE, LTEQ == (X1 <= X2));
            LOOP_ASSERT(LINE, GTEQ == (X1 >= X2));
            LOOP_ASSERT(LINE, EQ   == (X1 == X2));
            LOOP_ASSERT(LINE, EQ   != (X1 != X2));

            if (veryVerbose) {
                std::cout << "\tCA1 = \"" << CA1_p << "\", "
                          << "CA2 = \""   << CA2_p << "\", " << std::endl;
            }

            // char * versus StringRef
            LOOP_ASSERT(LINE, LT   == (CA1_p <  X2));
            LOOP_ASSERT(LINE, GT   == (CA1_p >  X2));
            LOOP_ASSERT(LINE, LTEQ == (CA1_p <= X2));
            LOOP_ASSERT(LINE, GTEQ == (CA1_p >= X2));
            LOOP_ASSERT(LINE, EQ   == (CA1_p == X2));
            LOOP_ASSERT(LINE, EQ   != (CA1_p != X2));

            // StringRef versus char *
            LOOP_ASSERT(LINE, LT   == (X1 <  CA2_p));
            LOOP_ASSERT(LINE, GT   == (X1 >  CA2_p));
            LOOP_ASSERT(LINE, LTEQ == (X1 <= CA2_p));
            LOOP_ASSERT(LINE, GTEQ == (X1 >= CA2_p));
            LOOP_ASSERT(LINE, EQ   == (X1 == CA2_p));
            LOOP_ASSERT(LINE, EQ   != (X1 != CA2_p));

            bsl::string s1(CA1_p);  const bsl::string& S1 = s1;
            bsl::string s2(CA2_p);  const bsl::string& S2 = s2;

            if (veryVerbose) {
                std::cout << "\tS1 = \"" << S1 << "\", "
                          << "S2 = \""   << S2 << "\", " << std::endl;
            }

            // bsl::string versus StringRef
            LOOP_ASSERT(LINE, LT   == (S1 <  X2));
            LOOP_ASSERT(LINE, GT   == (S1 >  X2));
            LOOP_ASSERT(LINE, LTEQ == (S1 <= X2));
            LOOP_ASSERT(LINE, GTEQ == (S1 >= X2));
            LOOP_ASSERT(LINE, EQ   == (S1 == X2));
            LOOP_ASSERT(LINE, EQ   != (S1 != X2));

            // StringRef versus bsl::string
            LOOP_ASSERT(LINE, LT   == (X1 <  S2));
            LOOP_ASSERT(LINE, GT   == (X1 >  S2));
            LOOP_ASSERT(LINE, LTEQ == (X1 <= S2));
            LOOP_ASSERT(LINE, GTEQ == (X1 >= S2));
            LOOP_ASSERT(LINE, EQ   == (X1 == S2));
            LOOP_ASSERT(LINE, EQ   != (X1 != S2));

            std::string s3(CA1_p);  const std::string& S3 = s3;
            std::string s4(CA2_p);  const std::string& S4 = s4;

            if (veryVerbose) {
                std::cout << "\tS3 = \"" << S3 << "\", "
                          << "S4 = \""   << S4 << "\", " << std::endl;
            }

            // `std::string` versus StringRef
            LOOP_ASSERT(LINE, LT   == (S3 <  X2));
            LOOP_ASSERT(LINE, GT   == (S3 >  X2));
            LOOP_ASSERT(LINE, LTEQ == (S3 <= X2));
            LOOP_ASSERT(LINE, GTEQ == (S3 >= X2));
            LOOP_ASSERT(LINE, EQ   == (S3 == X2));
            LOOP_ASSERT(LINE, EQ   != (S3 != X2));

            // StringRef versus `std::string`
            LOOP_ASSERT(LINE, LT   == (X1 <  S4));
            LOOP_ASSERT(LINE, GT   == (X1 >  S4));
            LOOP_ASSERT(LINE, LTEQ == (X1 <= S4));
            LOOP_ASSERT(LINE, GTEQ == (X1 >= S4));
            LOOP_ASSERT(LINE, EQ   == (X1 == S4));
            LOOP_ASSERT(LINE, EQ   != (X1 != S4));

            // bsl::string versus bsl::string.  This test is to ensure no
            // overloading ambiguity was introduced.

            LOOP_ASSERT(LINE, LT   == (S1 <  S2));
            LOOP_ASSERT(LINE, GT   == (S1 >  S2));
            LOOP_ASSERT(LINE, LTEQ == (S1 <= S2));
            LOOP_ASSERT(LINE, GTEQ == (S1 >= S2));
            LOOP_ASSERT(LINE, EQ   == (S1 == S2));
            LOOP_ASSERT(LINE, EQ   != (S1 != S2));

            // `std::string` versus `std::string`.  This test is
            // to ensure no overloading ambiguity was introduced.

            LOOP_ASSERT(LINE, LT   == (S3 <  S4));
            LOOP_ASSERT(LINE, GT   == (S3 >  S4));
            LOOP_ASSERT(LINE, LTEQ == (S3 <= S4));
            LOOP_ASSERT(LINE, GTEQ == (S3 >= S4));
            LOOP_ASSERT(LINE, EQ   == (S3 == S4));
            LOOP_ASSERT(LINE, EQ   != (S3 != S4));
        }
      } break;
      case 4: {
        // --------------------------------------------------------------------
        // TESTING OUTPUT (<<) OPERATOR:
        //
        // Concerns:
        //   Object created from the ty string, non-empty string and substring
        //   stream correctly.  Width reset after output.
        //
        // Plan:
        //   For an empty string, non-empty string and substring, use
        //   `ostringstream` to write that object's value to a character buffer
        //   and then compare the contents of that buffer with the expected
        //   output format.
        //
        // Testing:
        //   operator<<(ostream&, const bslstl::StringRef& string);
        // --------------------------------------------------------------------

        if (verbose) std::cout << "\nTESTING OUTPUT (<<) OPERATOR"
                                  "\n============================\n";

        if (verbose) std::cout << "\nTesting `operator<<` (ostream)."
                               << "\n= = = = = = = = = = = = = = = ="
                               << std::endl;
        {
            const size_t SIZE = 1000;     // max length of output string
            const char XX = static_cast<char>(0xFF);   // value representing an
                                                       // unset `char`
            char mCtrlBuf[SIZE];  memset(mCtrlBuf, XX, SIZE);

            Obj es(EMPTY_STRING);  const Obj& ES = es;

            if (veryVerbose) std::cout << "\tEXPECTED FORMAT: "
                                       << static_cast<bsl::string>(ES)
                                       << std::endl;
            std::ostringstream out;  out << ES;
            if (veryVerbose) std::cout << "\tACTUAL FORMAT:   "
                                       << out.str() << std::endl;

            const Obj::size_type ESSZ = ES.length() + 1;
            ASSERT(ESSZ < SIZE);           // Check buffer is large enough.
            ASSERT(out.str() == ES);
            ASSERT(out.good());

            // test default-constructed empty string ref
            Obj es1;  const Obj& ES1 = es1;

            if (veryVerbose) std::cout << "\tEXPECTED FORMAT: "
                                       << static_cast<bsl::string>(ES1)
                                       << std::endl;
            std::ostringstream out1;  out1 << ES1;
            if (veryVerbose) std::cout << "\tACTUAL FORMAT:   "
                                       << out1.str() << std::endl;

            const Obj::size_type ESSZ1 = ES1.length() + 1;
            ASSERT(ESSZ1 < SIZE);           // Check buffer is large enough.
            ASSERT(out1.str() == ES1);
            ASSERT(out1.good());

            Obj nes(NON_EMPTY_STRING);  const Obj& NES = nes;

            if (veryVerbose) std::cout << "\tEXPECTED FORMAT: "
                                       << NON_EMPTY_STRING << std::endl;
            std::ostringstream nesOut;  nesOut << NES;
            if (veryVerbose) std::cout << "\tACTUAL FORMAT:   "
                                       << nesOut.str() << std::endl;

            const Obj::size_type NESSZ = NES.length() + 1;
            ASSERT(NESSZ < SIZE);           // Check buffer is large enough.
            ASSERT(nesOut.str() == NES);
            ASSERT(nesOut.good());

            Obj ness(NON_EMPTY_STRING + 2, NON_EMPTY_STRING + 6);
            const Obj& NESS = ness;

            if (veryVerbose) std::cout << "\tEXPECTED FORMAT: "
                                       << static_cast<bsl::string>(NESS)
                                       << std::endl;
            std::ostringstream nessOut;  nessOut << NESS;
            if (veryVerbose) std::cout << "\tACTUAL FORMAT:   "
                                       << nessOut.str() << std::endl;

            const Obj::size_type NESSSZ = NESS.length() + 1;
            ASSERT(NESSSZ < SIZE);          // Check buffer is large enough.
            ASSERT(nessOut.str() == NESS);
            ASSERT(nessOut.good());

            // test formatting features
            std::ostringstream fmtOut;
            fmtOut << std::left << ES;
            ASSERT(fmtOut.str() == ES);

            fmtOut.str(std::string());
            fmtOut << std::right << ES;
            ASSERT(fmtOut.str() == ES);

            fmtOut.str(std::string());
            fmtOut << std::left << NES;
            ASSERT(fmtOut.str() == NES);

            fmtOut.str(std::string());
            fmtOut << std::right << NES;
            ASSERT(fmtOut.str() == NES);

            fmtOut.str(std::string());
            fmtOut << std::left
                   << std::setfill('-')
                   << std::setw(10)
                   << ES;
            ASSERT(fmtOut.str() == bsl::string(10, '-'));

            fmtOut.str(std::string());
            fmtOut << std::right
                   << std::setfill('*')
                   << std::setw(10)
                   << ES;
            ASSERT(fmtOut.str() == bsl::string(10, '*'));

            fmtOut.str(std::string());
            fmtOut << std::left
                   << std::setfill(' ')
                   << std::setw(static_cast<int>(NES.length() + 10))
                   << NES;
            ASSERT(fmtOut.str() == NES + bsl::string(10, ' '));

            fmtOut.str(std::string());
            fmtOut << std::right
                   << std::setfill('?')
                   << std::setw(static_cast<int>(NES.length() + 10))
                   << NES;
            ASSERT(fmtOut.str() == bsl::string(10, '?') + NES);

            fmtOut.str(std::string());
            fmtOut << std::left
                   << std::setfill('?')
                   << std::setw(static_cast<int>(NES.length() + 10))
                   << NES
                   << NES;
            ASSERT(fmtOut.str() == NES + bsl::string(10, '?') + NES);

            fmtOut.str(std::string());
            fmtOut << std::right
                   << std::setfill('?')
                   << std::setw(static_cast<int>(NES.length() + 10))
                   << NES
                   << NES;
            ASSERT(fmtOut.str() == bsl::string(10, '?') + NES + NES);
        }
      } break;
      case 3: {
        // --------------------------------------------------------------------
        // TESTING BASIC ACCESSORS AND COMPARISONS
        //
        // Concerns:
        // 1. Each individual `stringRef` field must be correctly forwarded
        //    from the fully-tested underlying constructor.
        //
        // Plan:
        // 1. Define a table of string, `conat CHAR *`, and `StringRegImp`
        //    values that refer to the `TestData` template class of
        //    null-terminated strings.
        //
        // 2. Have a `length` field in the table to indicate that a
        //    `StringRefImp` refers only to a subset of a null-terminated
        //    string, or can be default-constructed.
        //
        // 3. Loop `I` through the table creating I-values of
        //    `bsl::basic_string`, a `std::basic_string`, a
        //    `StringRefImp`, and `const char *` all having the value indicated
        //    by the table.
        //
        // 4. Probe the accessors of the created `StringRefImp` to verify that
        //    they have the proper values.
        //
        // 5. Do a nested loop `J` through the table, creating J-values of all
        //    the types created in the I-Loop.
        //
        // 6. Compare the `bsl::string` I and J values to determine the
        //    booleans `EQ`, `NE`, `LT`, `GT`, `LE`, and `GE` to indicate all
        //    the comparison values of comparing the I-value and J-value.
        //
        // 7. Us the `compare` methods to compare the I `StringRefImp` to both
        //    the J `StringRefImp` and the J `const CHAR *`, observe that the
        //    comparisons match the results from comparing the two
        //    `bsl::string`s.
        //
        // 8. Use the `==`, `!=`, '<', `>=`, '>', and `<=` operators to do all
        //    possible comparisons with the various I values on the left and
        //    J values on the right and confirm they all match the initial
        //    results of comparing the two `bsl::string`s.
        //
        // Testing:
        //   const_iterator begin() const;
        //   const_iterator data() const;
        //   const_iterator end() const;
        //   size_type      length() const;
        //   size_type      size() const;
        //   int            empty() const;
        //   int            isEmpty() const;
        //   int            compare(const StringRefImp&) const;
        //   int            compare(const CHAR *) const;
        //                  operator std::basic_string() const;
        //   const char&    operator[](size_type index) const;
        //   bool operator==(const StringRef& lhs, const StringRef& rhs);
        //   bool operator==(const bsl::string& lhs, const StringRef& rhs);
        //   bool operator==(const StringRef& lhs, const bsl::string& rhs);
        //   bool operator==(const std::string& l, const StringRef& r);
        //   bool operator==(const StringRef& l, const std::string& r);
        //   bool operator==(const char *lhs, const StringRef& rhs);
        //   bool operator==(const StringRef& lhs, const char *rhs);
        //   bool operator==(const StringRef& lhs, string_view rhs);
        //   bool operator==(string_view lhs, const StringRef& rhs);
        //   bool operator!=(const StringRef& lhs, const StringRef& rhs);
        //   bool operator!=(const bsl::string& lhs, const StringRef& rhs);
        //   bool operator!=(const StringRef& lhs, const bsl::string& rhs);
        //   bool operator!=(const std::string& l, const StringRef& r);
        //   bool operator!=(const StringRef& l, const std::string& r);
        //   bool operator!=(const char *lhs, const StringRef& rhs);
        //   bool operator!=(const StringRef& lhs, const char *rhs);
        //   bool operator!=(const StringRef& lhs, string_view rhs);
        //   bool operator!=(string_view lhs, const StringRef& rhs);
        //   bool operator<(const StringRef& lhs, const StringRef& rhs);
        //   bool operator<(const bsl::string& lhs, const StringRef& rhs);
        //   bool operator<(const StringRef& lhs, const bsl::string& rhs);
        //   bool operator<(const std::string& l, const StringRef& r);
        //   bool operator<(const StringRef& l, const std::string& r);
        //   bool operator<(const char *lhs, const StringRef& rhs);
        //   bool operator<(const StringRef& lhs, const char *rhs);
        //   bool operator<(const StringRef& lhs, string_view rhs);
        //   bool operator<(string_view lhs, const StringRef& rhs);
        //   bool operator>(const StringRef& lhs, const StringRef& rhs);
        //   bool operator>(const bsl::string& lhs, const StringRef& rhs);
        //   bool operator>(const StringRef& lhs, const bsl::string& rhs);
        //   bool operator>(const std::string& l, const StringRef& r);
        //   bool operator>(const StringRef& l, const std::string& r);
        //   bool operator>(const char *lhs, const StringRef& rhs);
        //   bool operator>(const StringRef& lhs, const char *rhs);
        //   bool operator>(const StringRef& lhs, string_view rhs);
        //   bool operator>(string_view lhs, const StringRef& rhs);
        //   bool operator<=(const StringRef& lhs, const StringRef& rhs);
        //   bool operator<=(const bsl::string& lhs, const StringRef& rhs);
        //   bool operator<=(const StringRef& lhs, const bsl::string& rhs);
        //   bool operator<=(const std::string& l, const StringRef& r);
        //   bool operator<=(const StringRef& l, const std::string& r);
        //   bool operator<=(const char *lhs, const StringRef& rhs);
        //   bool operator<=(const StringRef& lhs, const char *rhs);
        //   bool operator<=(const StringRef& lhs, string_view rhs);
        //   bool operator<=(string_view lhs, const StringRef& rhs);
        //   bool operator>=(const StringRef& lhs, const StringRef& rhs);
        //   bool operator>=(const bsl::string& lhs, const StringRef& rhs);
        //   bool operator>=(const StringRef& lhs, const bsl::string& rhs);
        //   bool operator>=(const std::string& l, const StringRef& r);
        //   bool operator>=(const StringRef& l, const std::string& r);
        //   bool operator>=(const char *lhs, const StringRef& rhs);
        //   bool operator>=(const StringRef& lhs, const char *rhs);
        //   bool operator>=(const StringRef& lhs, string_view rhs);
        //   bool operator>=(string_view lhs, const StringRef& rhs);
        // --------------------------------------------------------------------

        if (verbose) std::cout <<
                                 "\nTESTING BASIC ACCESSORS AND COMPARISONS"
                                 "\n=======================================\n";

        BloombergLP::comparisons::testAccessorsComparisons<char>();
        BloombergLP::comparisons::testAccessorsComparisons<wchar_t>();

#ifdef BSLS_COMPILERFEATURES_SUPPORT_UNICODE_CHAR_TYPES
        BloombergLP::comparisons::testAccessorsComparisons<char16_t>();
        BloombergLP::comparisons::testAccessorsComparisons<char32_t>();
#endif

#ifdef BSLS_COMPILERFEATURES_SUPPORT_UTF8_CHAR_TYPE
        BloombergLP::comparisons::testAccessorsComparisons<char8_t>();
#endif
      } break;
      case 2: {
        // --------------------------------------------------------------------
        // TESTING BASIC CONSTRUCTORS
        //
        // Concerns:
        // 1. The begin and end members must be correctly set by the different
        //    constructors.
        //
        // Plan:
        // 1. Test each of the constructors with empty and non-empty strings.
        //
        // Testing:
        //   bslstl::StringRefImp();
        //   bslstl::StringRefImp(const CHAR *begin, const CHAR *end);
        //   bslstl::StringRefImp(const CHAR *begin, INT_TYPE length);
        //   bslstl::StringRefImp(const CHAR *begin, size_type length, Nil);
        //   bslstl::StringRefImp(const CHAR *begin, size_type f, size_type l);
        //   bslstl::StringRefImp(const CHAR *begin);
        //   bslstl::StringRefImp(const bsl::string& begin);
        //   bslstl::StringRefImp(const std::string& begin);
        //   bslstl::StringRefImp(const bslstl::StringRefImp& original);
        //   ~bslstl::StringRefImp();
        //   bslstl::StringRefImp& operator=(const bslstl::StringRefImp&);
        // --------------------------------------------------------------------

        if (verbose) std::cout << "\nTESTING BASIC CONSTRUCTORS"
                                  "\n==========================\n";

        if (verbose) std::cout << "\nTesting default constructor"
                               << "\n= = = = = = = = = = = = = =" << std::endl;
        if (veryVerbose)
            std::cout << "\nbslstl_StringRef()"
                 << "\n=  =  =  =  =  = "
                 << std::endl;

        {
            Obj x;  const Obj& X =x;

            ASSERT(X.isEmpty());
            ASSERT(X.length()  == 0);
            ASSERT(X.begin()   == X.end());
        }

        if (verbose) std::cout << "\nTesting other constructors"
                               << "\n= = = = = = = = = = = = = " << std::endl;
        if (veryVerbose)
              std::cout
                  << "\nbslstl_StringRef(const char *begin, const char *end)"
                  << "\n=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  "
                  << std::endl;
        {
            // Empty string
            Obj x1(EMPTY_STRING, EMPTY_STRING + std::strlen(EMPTY_STRING));
            const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()  == 0);
            ASSERT(X1.begin()   == X1.end());
            ASSERT(X1.begin()   == EMPTY_STRING);
            ASSERT(X1.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            // Non-empty string
            Obj x2(NON_EMPTY_STRING,
                   NON_EMPTY_STRING + std::strlen(NON_EMPTY_STRING));
            const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  == std::strlen(NON_EMPTY_STRING));
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING);
            ASSERT(X2.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));
        }

        if (veryVerbose)
            std::cout <<
                "\nbslstl_StringRef(const char *begin, size_type length, Nil)"
                "\nbslstl_StringRef(const char *begin, INT_TYPE length, Nil)"
                "\n=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ="
                "\n";

        {
            // Empty string
            Obj x1(EMPTY_STRING, std::strlen(EMPTY_STRING));
            const Obj& X1 = x1;
            ASSERTV(X1, X1.isEmpty());
            ASSERTV(X1, X1.length() == 0);
            ASSERTV(X1, X1.begin()  == X1.end());
            ASSERTV(X1, X1.begin()  == EMPTY_STRING);
            ASSERTV(X1, X1.end()    == EMPTY_STRING
                                     + std::strlen(EMPTY_STRING));

            // Non-empty string
            Obj x2(NON_EMPTY_STRING, std::strlen(NON_EMPTY_STRING));
            const Obj& X2 = x2;
            ASSERTV(X2, !X2.isEmpty());
            ASSERTV(X2, X2.length(), X2.length()  == 30);
            ASSERTV(X2, X2.begin()   != X2.end());
            ASSERTV(X2, X2.begin()   == NON_EMPTY_STRING);
            ASSERTV(X2, X2.end()     == NON_EMPTY_STRING +
                                        std::strlen(NON_EMPTY_STRING));

           // Assorted integer types for length
#define TEST_LITERAL_ZERO(LITERAL_ZERO)                                       \
        {                                                                     \
          if (veryVeryVerbose) {                                              \
              std::cout << "Literal zero " #LITERAL_ZERO "\n";                \
          }                                                                   \
          Obj x(EMPTY_STRING, LITERAL_ZERO);                                  \
          const Obj& X = x;                                                   \
          ASSERTV(X, X.isEmpty());                                            \
          ASSERTV(X, X.length(), X.length()  == 0);                           \
          ASSERTV(X, X.begin() == X.end());                                   \
          ASSERTV(X, X.begin() == EMPTY_STRING);                              \
          ASSERTV(X, X.end()   == EMPTY_STRING + std::strlen(EMPTY_STRING));  \
        }

#define TEST_TYPE(INT_TYPE)                                                   \
        {                                                                     \
          if (veryVeryVerbose) {                                              \
              std::cout << "Integral type " #INT_TYPE "\n";                   \
          }                                                                   \
          Obj x(NON_EMPTY_STRING,                                             \
                static_cast<INT_TYPE>(std::strlen(NON_EMPTY_STRING)));        \
          const Obj& X = x;                                                   \
          ASSERTV(X, !X.isEmpty());                                           \
          ASSERTV(X, X.length(), X.length()  == 30);                          \
          ASSERTV(X, X.begin()   != X.end());                                 \
          ASSERTV(X, X.begin()   == NON_EMPTY_STRING);                        \
          ASSERTV(X, X.end()     == NON_EMPTY_STRING +                        \
                                 std::strlen(NON_EMPTY_STRING));              \
        }

#define TEST_INT_TYPE(INT_TYPE, LITERAL_ZERO)                                 \
        TEST_LITERAL_ZERO(LITERAL_ZERO)                                       \
        TEST_TYPE(INT_TYPE)

            TEST_INT_TYPE(short, (short)0)
            TEST_INT_TYPE(unsigned short, (unsigned short)0)
            TEST_INT_TYPE(int, 0)
            TEST_INT_TYPE(unsigned, 0u)
            TEST_INT_TYPE(long, 0l)
            TEST_INT_TYPE(unsigned long, 0ul)
            TEST_INT_TYPE(long long, 0ll)
            TEST_INT_TYPE(unsigned long long, 0ull)

            enum Enum { k_LOCAL_ENUM_ZERO_VALUE, k_LOCAL_ENUM_MAX = 0xFFFF };
            enum      { k_LOCAL_ZERO_VALUE,      k_LOCAL_MAX      = 0xFFFF };

            TEST_LITERAL_ZERO(TestData<char>::k_ENUM_ZERO_VALUE)
            TEST_TYPE(TestData<char>::Enum)
            TEST_LITERAL_ZERO(TestData<char>::k_ZERO_VALUE)

            TEST_LITERAL_ZERO(k_LOCAL_ENUM_ZERO_VALUE)
            TEST_TYPE(Enum)
            TEST_LITERAL_ZERO(k_LOCAL_ZERO_VALUE)
#undef TEST_LITERAL_ZERO
#undef TEST_TYPE
#undef TEST_INT_TYPE
        }

        if (veryVerbose) std::cout <<
           "\nbslstl_StringRef(const char *begin, size_type f, size_type l)"
           "\n=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =\n";
        {
            // Empty string
            Obj        x1(EMPTY_STRING, std::strlen(EMPTY_STRING));
            const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()  == 0);
            ASSERT(X1.begin()   == X1.end());
            ASSERT(X1.begin()   == EMPTY_STRING);
            ASSERT(X1.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            for (size_t start = 0, length = 0; length <= 2; ++length) {
                if (veryVeryVerbose) {
                    std::cout << "SR(\"\", " << start << ", 0)\n";
                }
                Obj x3(x1, start, length);  const Obj& X3 = x3;
                ASSERT(X3.isEmpty());
                ASSERT(X3.length()  == 0);
                ASSERT(X3.begin()   == X3.end());
                ASSERT(X3.begin()   == EMPTY_STRING);
                ASSERT(X3.end()     == EMPTY_STRING);
            }

            // Non-empty string
            Obj x2(NON_EMPTY_STRING, std::strlen(NON_EMPTY_STRING));
            const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  == std::strlen(NON_EMPTY_STRING));
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING);
            ASSERT(X2.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));

            for (size_t start = 0;
                        start < std::strlen(NON_EMPTY_STRING);
                      ++start) {
                {
                    if (veryVeryVerbose) {
                        std::cout << "SR(SR, " << start << ", 0)\n";
                    }
                    Obj x3(x2, start, 0);   const Obj& X3 = x3;
                    ASSERT(X3.isEmpty());
                    ASSERT(X3.length() == 0);
                    ASSERT(X3.begin()  == X3.end());
                    ASSERT(X3.begin()  == NON_EMPTY_STRING + start);
                    ASSERT(X3.end()    == NON_EMPTY_STRING + start);
                }
                for (size_t length = 1;
                            length <= std::strlen(NON_EMPTY_STRING) - start;
                          ++length) {
                    if (veryVeryVerbose) {
                        std::cout << "SR(SR, " << start << ", " << length
                                  << ")\n";
                    }
                    Obj x3(x2, start, length);  const Obj& X3 = x3;
                    LOOP2_ASSERT(start, length, !X3.isEmpty());
                    LOOP2_ASSERT(start, length, X3.length() == length);
                    LOOP2_ASSERT(start, length, X3.begin()  != X3.end());
                    LOOP2_ASSERT(start, length, X3.begin()
                                                  == NON_EMPTY_STRING + start);
                    LOOP2_ASSERT(start, length, X3.end()
                                         == NON_EMPTY_STRING + start + length);
                }
                for (size_t length = std::strlen(NON_EMPTY_STRING) - start + 1;
                            length <= 2 * std::strlen(NON_EMPTY_STRING);
                          ++length) {
                    if (veryVeryVerbose) {
                        std::cout << "SR(SR, " << start << ", " << length
                                  << ")\n";
                    }
                    Obj x3(x2, start, length);
                    const Obj& X3 = x3;
                    ASSERT(!X3.isEmpty());
                    ASSERT(
                         X3.length() == std::strlen(NON_EMPTY_STRING) - start);
                    ASSERT(X3.begin()  != X3.end());
                    ASSERT(X3.begin()  == NON_EMPTY_STRING + start);
                    ASSERT(X3.end()    == NON_EMPTY_STRING +
                                          std::strlen(NON_EMPTY_STRING));
                }
            }
            for (size_t length = 0;
                        length <= 2 * std::strlen(NON_EMPTY_STRING);
                      ++length) {
                if (veryVeryVerbose) {
                    std::cout << "SR(SR, end, " << length << ")\n";
                }
                Obj        x3(x2, std::strlen(NON_EMPTY_STRING), length);
                const Obj& X3 = x3;
                ASSERT(X3.isEmpty());
                ASSERT(X3.length() == 0);
                ASSERT(X3.begin()  == X3.end());
                ASSERT(X3.begin()  == NON_EMPTY_STRING +
                                      std::strlen(NON_EMPTY_STRING));
                ASSERT(X3.end()    == NON_EMPTY_STRING +
                                      std::strlen(NON_EMPTY_STRING));
            }

            // Assorted integer types for length and size
#define TEST_LITERAL_ZERO(LITERAL_ZERO_START, LITERAL_ZERO_LENGTH)            \
        {                                                                     \
          if (veryVeryVerbose) {                                              \
              std::cout << "Literal zero start " #LITERAL_ZERO_START "\n";    \
              std::cout << "Literal zero length " #LITERAL_ZERO_LENGTH "\n";  \
          }                                                                   \
          Obj x(EMPTY_STRING, LITERAL_ZERO_START, LITERAL_ZERO_LENGTH);       \
          const Obj& X = x;                                                   \
          ASSERT(X.isEmpty());                                                \
          ASSERT(X.length()  == 0);                                           \
          ASSERT(X.begin()   == X.end());                                     \
          ASSERT(X.begin()   == EMPTY_STRING);                                \
          ASSERT(X.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));    \
        }

#define TEST_TYPE(INT_TYPE_START, INT_TYPE_LENGTH)                            \
        {                                                                     \
          if (veryVeryVerbose) {                                              \
              std::cout << "Integral type start " #INT_TYPE_START "\n";       \
              std::cout << "Integral type length " #INT_TYPE_LENGTH "\n";     \
          }                                                                   \
          Obj x(NON_EMPTY_STRING, static_cast<INT_TYPE_START>(                \
                                        std::strlen(NON_EMPTY_STRING) / 3),   \
                                  static_cast<INT_TYPE_LENGTH>(               \
                                        std::strlen(NON_EMPTY_STRING) / 3));  \
          const Obj& X = x;                                                   \
          ASSERT(!X.isEmpty());                                               \
          ASSERT(X.length()  == std::strlen(NON_EMPTY_STRING) / 3);           \
          ASSERT(X.begin()   != X.end());                                     \
          ASSERT(X.begin()   == NON_EMPTY_STRING +                            \
                                std::strlen(NON_EMPTY_STRING) / 3);           \
          ASSERT(X.end()     == NON_EMPTY_STRING +                            \
                                2 * std::strlen(NON_EMPTY_STRING) / 3);       \
        }

#define TEST_INT_TYPE(INT_TYPE_START, LITERAL_ZERO_START,                     \
                      INT_TYPE_LENGTH, LITERAL_ZERO_LENGTH)                   \
        TEST_LITERAL_ZERO(LITERAL_ZERO_START, LITERAL_ZERO_LENGTH)            \
        TEST_TYPE(INT_TYPE_START, INT_TYPE_LENGTH)

#define T1 short
#define L1 (short)0
#define T2 unsigned short
#define L2 (unsigned short)0
#define T3 int
#define L3 0
#define T4 unsigned
#define L4 0u
#define T5 long
#define L5 0l
#define T6 unsigned long
#define L6 0ul
#define T7 long long
#define L7 0ll
#define T8 unsigned long long
#define L8 0ull
#define T9 TestData<char>::Enum
#define L9 TestData<char>::k_ENUM_ZERO_VALUE
#define T0 Enum
#define L0 k_LOCAL_ENUM_ZERO_VALUE

#define TEST_N(N) \
            TEST_INT_TYPE(T##N, L##N, T1, L1) \
            TEST_INT_TYPE(T##N, L##N, T2, L2) \
            TEST_INT_TYPE(T##N, L##N, T3, L3) \
            TEST_INT_TYPE(T##N, L##N, T4, L4) \
            TEST_INT_TYPE(T##N, L##N, T5, L5) \
            TEST_INT_TYPE(T##N, L##N, T6, L6) \
            TEST_INT_TYPE(T##N, L##N, T7, L7) \
            TEST_INT_TYPE(T##N, L##N, T8, L8) \
            TEST_INT_TYPE(T##N, L##N, T9, L9) \
            TEST_INT_TYPE(T##N, L##N, T0, L0)

            enum Enum { k_LOCAL_ENUM_ZERO_VALUE, k_LOCAL_ENUM_MAX = 0xFFFF };

            TEST_N(1)
            TEST_N(2)
            TEST_N(3)
            TEST_N(4)
            TEST_N(5)
            TEST_N(6)
            TEST_N(7)
            TEST_N(8)
            TEST_N(9)
            TEST_N(0)

#undef TEST_LITERAL_ZERO
#undef TEST_TYPE
#undef TEST_INT_TYPE
#undef TEST_N
#undef T1
#undef L1
#undef T2
#undef L2
#undef T3
#undef L3
#undef T4
#undef L4
#undef T5
#undef L5
#undef T6
#undef L6
#undef T7
#undef L7
#undef T8
#undef L8
#undef T9
#undef L9
#undef T0
#undef L0
        }

        if (veryVerbose)
            std::cout << "\nbslstl_StringRef(const char *begin)"
                      << "\n =  =  =  =  =  =  =  =  =  =  =  ="
                      << std::endl;

        {
            // Empty string
            Obj x1(EMPTY_STRING);  const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()  == 0);
            ASSERT(X1.begin()   == X1.end());
            ASSERT(X1.begin()   == EMPTY_STRING);
            ASSERT(X1.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            // Non-empty string
            Obj x2(NON_EMPTY_STRING);  const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  == std::strlen(NON_EMPTY_STRING));
            ASSERT(X2.begin()   != X2.end());
            ASSERT(X2.begin()   == NON_EMPTY_STRING);
            ASSERT(X2.end()     == NON_EMPTY_STRING +
                                   std::strlen(NON_EMPTY_STRING));
            ASSERT(X1           != X2);
        }

        if (veryVerbose)
            std::cout << "\nbslstl_StringRef(const bsl::string& begin)"
                      << "\n  =  =  =  =  =  =  =  =  =  =  =  =  =  ="
                      << std::endl;

        {
            // Empty string
            bsl::string s_emptyString_p(EMPTY_STRING);
            Obj x1(s_emptyString_p);  const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()    == 0);
            ASSERT(X1.begin()     == X1.end());
            ASSERT(X1.begin()     == s_emptyString_p.data());
            ASSERT(s_emptyString_p.c_str() == X1.end());
            ASSERT(s_emptyString_p.data() +
                                         s_emptyString_p.length() == X1.end());

            // Non-empty string
            bsl::string s_nonEmptyString_p(NON_EMPTY_STRING);
            Obj x2(s_nonEmptyString_p);  const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  == std::strlen(NON_EMPTY_STRING));
            ASSERT(X2.begin()   != X2.end());
            ASSERT(&*X2.begin()   == &*s_nonEmptyString_p.begin());
            ASSERT((&*X2.begin() + (X2.end() - X2.begin())) ==
                  (&*s_nonEmptyString_p.begin() + (s_nonEmptyString_p.end() -
                                                 s_nonEmptyString_p.begin())));
        }

        if (veryVerbose)
            std::cout
                << "\nbslstl_StringRef(const std::string& begin)"
                << "\n=  =  =  =  =  =  =  =  =  =  =  =  =  =  "
                << std::endl;

        {
            // Empty string
            const std::string s_emptyString_p(EMPTY_STRING);
            Obj x1(s_emptyString_p);  const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()    == 0);
            ASSERT(X1.begin()     == X1.end());
            ASSERT(X1.begin()     == s_emptyString_p.data());
            ASSERT(s_emptyString_p.data() +
                                         s_emptyString_p.length() == X1.end());

            // Non-empty string
            std::string s_nonEmptyString_p(NON_EMPTY_STRING);
            Obj x2(s_nonEmptyString_p);  const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  == std::strlen(NON_EMPTY_STRING));
            ASSERT(X2.begin()   != X2.end());
            ASSERT(&*X2.begin()   == &*s_nonEmptyString_p.begin());
            ASSERT((&*X2.begin() + (X2.end() - X2.begin())) ==
                  (&*s_nonEmptyString_p.begin() + (s_nonEmptyString_p.end() -
                                                 s_nonEmptyString_p.begin())));
        }

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_PMR_STRING
        if (veryVerbose)
            std::cout
                << "\nbslstl_StringRef(const std::pmr::string& begin)"
                << "\n=  =  =  =  =  =  =  =  =  =  =  =  =  =  "
                << std::endl;

        {
            // Empty string
            const std::pmr::string s_emptyString_p(EMPTY_STRING);
            Obj x1(s_emptyString_p);  const Obj& X1 = x1;
            ASSERT(X1.isEmpty());
            ASSERT(X1.length()    == 0);
            ASSERT(X1.begin()     == X1.end());
            ASSERT(X1.begin()     == s_emptyString_p.data());
            ASSERT(s_emptyString_p.data() +
                                         s_emptyString_p.length() == X1.end());

            // Non-empty string
            std::pmr::string s_nonEmptyString_p(NON_EMPTY_STRING);
            Obj x2(s_nonEmptyString_p);  const Obj& X2 = x2;
            ASSERT(!X2.isEmpty());
            ASSERT(X2.length()  == std::strlen(NON_EMPTY_STRING));
            ASSERT(X2.begin()   != X2.end());
            ASSERT(&*X2.begin()   == &*s_nonEmptyString_p.begin());
            ASSERT((&*X2.begin() + (X2.end() - X2.begin())) ==
                  (&*s_nonEmptyString_p.begin() + (s_nonEmptyString_p.end() -
                                                 s_nonEmptyString_p.begin())));
        }
#endif

        if (verbose) std::cout << "\nTesting copy constructor"
                               << "\n= = = = = = = = = = = = " << std::endl;
        if (veryVerbose)
            std::cout
                << "\nbslstl_StringRef(const bslstl::StringRef&)"
                << "\n  =  =  =  =  =  =  =  =  =  =  =  =  =  ="
                << std::endl;
        {
            // Empty string
            Obj x1(EMPTY_STRING, EMPTY_STRING + std::strlen(EMPTY_STRING));
                                               const Obj& X1  = x1;
            Obj xc1(X1);                       const Obj& XC1 = xc1;
            ASSERT(XC1.isEmpty());
            ASSERT(XC1.length()  == 0);
            ASSERT(XC1.begin()   == XC1.end());
            ASSERT(XC1.begin()   == EMPTY_STRING);
            ASSERT(XC1.end()     == EMPTY_STRING + std::strlen(EMPTY_STRING));

            // Non-empty string
            Obj x2(NON_EMPTY_STRING,
                   NON_EMPTY_STRING + std::strlen(NON_EMPTY_STRING));
                                               const Obj& X2  = x2;
            Obj xc2(X2);                       const Obj& XC2 = xc2;
            ASSERT(!XC2.isEmpty());
            ASSERT(XC2.length()  == std::strlen(NON_EMPTY_STRING));
            ASSERT(XC2.begin()   != XC2.end());
            ASSERT(XC2.begin()   == NON_EMPTY_STRING);
            ASSERT(XC2.end()     == NON_EMPTY_STRING
                                  + std::strlen(NON_EMPTY_STRING));
        }

        if (verbose) std::cout << "\nNegative Testing." << std::endl;
        {
            bsls::AssertTestHandlerGuard g;

            ASSERT_SAFE_PASS_RAW(Obj(""));
            ASSERT_SAFE_FAIL_RAW(Obj( 0));
        }
      } break;
      case 1: {
        // --------------------------------------------------------------------
        // BREATHING TEST
        //   This Test Case exercises basic functionality.
        //
        // Concerns:
        //   Exercise each method lightly.
        //
        // Plan:
        //   Create several `bsl::string` objects and use them to test various
        //   methods.
        //
        // Testing:
        //  BREATHING TEST
        // --------------------------------------------------------------------

        if (verbose) std::cout << "\nBREATHING TEST"
                               << "\n==============\n";

        bsl::string  s1  = "hello";
        bsl::string  s2  = "Hello";
        bsl::string  s3  = "good-bye";
        bsl::string  s4  = "Good-Bye";

        const char  *cs1 = s1.c_str();
        const char  *cs2 = s2.c_str();
        const char  *cs3 = s3.c_str();

        {
            Obj x1(cs1, cs1 + 3);      const Obj& X1 = x1;
            Obj x2(cs1, 3);            const Obj& X2 = x2;
                                       const Obj  X3(X1);

            ASSERT(3 == X1.length());
            ASSERT(3 == X2.length());
            ASSERT(3 == X3.length());

            ASSERT(1 == (X1 == X1));
            ASSERT(0 == (X1 != X1));
            ASSERT(1 == (X1 == X2));
            ASSERT(0 == (X1 != X2));
            ASSERT(1 == (X1 == X3));
            ASSERT(0 == (X1 != X3));

            ASSERT(0 == (X1 <  X1));
            ASSERT(1 == (X1 <= X1));
            ASSERT(0 == (X1 >  X1));
            ASSERT(1 == (X1 >= X1));

            ASSERT(0 == (X1 <  X2));
            ASSERT(1 == (X1 <= X2));
            ASSERT(0 == (X1 >  X2));
            ASSERT(1 == (X1 >= X2));

            ASSERT(0 == (X1 >  X3));
            ASSERT(1 == (X1 >= X3));
            ASSERT(0 == (X3 >  X2));
            ASSERT(1 == (X3 >= X2));
        }

        {
            Obj x1(s1);               const Obj& X1 = x1;
            Obj x2(cs1);              const Obj& X2 = x2;
            Obj x3(cs1, cs1 + 3);     const Obj& X3 = x3;

            ASSERT(5 == X1.length());
            ASSERT(5 == X2.length());

            ASSERT(1 == (X1 == X1));
            ASSERT(0 == (X1 != X1));
            ASSERT(1 == (X1 == X2));
            ASSERT(0 == (X1 != X2));

            ASSERT(0 == (X1 <  X2));
            ASSERT(1 == (X1 <= X2));
            ASSERT(0 == (X1 >  X2));
            ASSERT(1 == (X1 >= X2));

            ASSERT(0 == (X1 <  X3));
            ASSERT(1 == (X1 >= X3));
            ASSERT(0 == (X1 <= X3));
            ASSERT(1 == (X1 >  X3));
        }

        {
            Obj x1(cs1, cs1 + 3);      const Obj& X1 = x1;
            Obj x2(cs1 + 3, cs1 + 5);  const Obj& X2 = x2;
            Obj x3(X1);                const Obj& X3 = x3;

            ASSERT(3 == X1.length());
            ASSERT(2 == X2.length());
            ASSERT(3 == X3.length());

            ASSERT(X1 == X1);
            ASSERT(X2 == X2);
            ASSERT(X3 == X3);
            ASSERT(X1 != X2);
            ASSERT(X2 != X3);
            ASSERT(X1 == X3);

            x3 = x2;

            ASSERT(X3 == X3);
            ASSERT(X2 == X3);
            ASSERT(X1 != X3);

            bsl::string sx1 = static_cast<bsl::string>(X1);
            if (verbose) { P(sx1.c_str()); }
            ASSERT(3 == sx1.size());

            if (verbose) { P_(X1.begin());  P(X2.begin()); }

            bsl::string sx1x2 = X1 + X2;
            ASSERT(s1 == sx1x2);
            ASSERT(s1 == X1 + X2);
        }

        {
            Obj x1;  const Obj& X1 = x1;
            if (verbose) { P(X1.begin()); }
            ASSERT(0 == X1.length());

            bsl::string s1 = X1;
            if (verbose) { P_(s1.c_str());  P(X1.begin()); }

            Obj x2(cs2, cs2 + 3);  const Obj& X2 = x2;
            if (verbose) { P(X2.begin()); }

            ASSERT(X2 != X1);
            x2.reset();
            ASSERT(X2 == X1);
        }

        {
            Obj x1(cs3, cs3 + 8);  const Obj& X1 = x1;
            Obj x2(cs3, cs3 + 8);  const Obj& X2 = x2;

            ASSERT(8 == X1.length());
            ASSERT(8 == X2.length());

            ASSERT(X1 == X2);
        }
      } break;
      case -1: {
        // --------------------------------------------------------------------
        // SHORT STRINGS PERFORMANCE TEST
        // --------------------------------------------------------------------

        enum { k_NUM_STRINGREFS        = 1024 * 1024,
               k_NUM_UNIQUE_STRINGREFS = k_NUM_STRINGREFS / 32,
               k_NUM_TRIALS            = 250 * 1000 * 1000 };

        std::vector<bsl::string> sv;
        sv.reserve(k_NUM_STRINGREFS);

        const int len   = static_cast<int>(std::strlen(charUtf8MultiLang));
        const int chunk = len / 128;

        ASSERTV(len,   len  > 22 * 1000);
        ASSERTV(chunk, chunk <= 175);
        ASSERTV(chunk, chunk >  170);

        int ii = 0;
        for (; ii < k_NUM_UNIQUE_STRINGREFS; ++ii) {
            const int idx = (absMmixRandNum() % 128) * chunk;
            const int lenGivenIdx = absMmixRandNum() % chunk;
            ASSERT(idx + lenGivenIdx <= len);

            bslstl::StringRef sr(charUtf8MultiLang + idx, lenGivenIdx);
            sv.push_back(sr);
        }
        const bsl::string defaultStr;
        for (; ii < k_NUM_STRINGREFS; ++ii) {
            sv.push_back(defaultStr);
            sv[ii] = sv[ii - k_NUM_UNIQUE_STRINGREFS];
        }
        std::sort(sv.begin(), sv.end());

        std::vector<bslstl::StringRef> srv;
        srv.reserve(k_NUM_STRINGREFS);
        for (ii = 0; ii < k_NUM_STRINGREFS; ++ii) {
            srv.push_back(sv[ii]);
        }

        std::vector<int> eqv;
        eqv.reserve(k_NUM_STRINGREFS);
        eqv.push_back(0);
        for (ii = 1; ii < k_NUM_STRINGREFS; ++ii) {
            const int eqIdx = sv[ii - 1] == sv[ii] ? eqv[ii - 1] : ii;
            eqv.push_back(eqIdx);
        }

        bsls::Stopwatch sw;
        sw.start(true);
        for (int jj = k_NUM_TRIALS; 0 < jj; --jj) {
            const int  idxA = absMmixRandNum() % k_NUM_STRINGREFS;
            const int  idxB = absMmixRandNum() % k_NUM_STRINGREFS;
            const bool EQ   = eqv[idxB] == eqv[idxA];    (void) EQ;
        }
        sw.stop();
        struct Times {
            // DATA
            double d_systemTime;
            double d_userTime;
            double d_wallTime;

            // MANIPULATORS
            Times& operator-=(const Times& rhs)
            {
                d_systemTime -= rhs.d_systemTime;
                d_userTime   -= rhs.d_userTime;
                d_wallTime   -= rhs.d_wallTime;

                return *this;
            }
        };
        Times empty;
        sw.accumulatedTimes(&empty.d_systemTime,
                            &empty.d_userTime,
                            &empty.d_wallTime);
        P_(empty.d_systemTime);    P_(empty.d_userTime);   P(empty.d_wallTime);

        sw.reset();
        sw.start(true);
        for (int jj = k_NUM_TRIALS; 0 < jj; --jj) {
            const int  idxA = absMmixRandNum() % k_NUM_STRINGREFS;
            const int  idxB = absMmixRandNum() % k_NUM_STRINGREFS;
            const bool EQ   = eqv[idxA] == eqv[idxB];

            ASSERTV(EQ == (srv[idxA] == srv[idxB]));
        }
        sw.stop();

        Times eqTime;
        sw.accumulatedTimes(&eqTime.d_systemTime,
                            &eqTime.d_userTime,
                            &eqTime.d_wallTime);
        eqTime -= empty;
        P_(eqTime.d_systemTime);  P_(eqTime.d_userTime);  P(eqTime.d_wallTime);

        sw.reset();
        sw.start(true);
        for (int jj = k_NUM_TRIALS; 0 < jj; --jj) {
            const int  idxA = absMmixRandNum() % k_NUM_STRINGREFS;
            const int  idxB = absMmixRandNum() % k_NUM_STRINGREFS;
            const bool EQ   = eqv[idxA] == eqv[idxB];

            ASSERTV(EQ == (srv[idxA] == sv[idxB].c_str()));
        }
        sw.stop();

        Times eqCTime;
        sw.accumulatedTimes(&eqCTime.d_systemTime,
                            &eqCTime.d_userTime,
                            &eqCTime.d_wallTime);
        eqCTime -= empty;
        P_(eqCTime.d_systemTime);P_(eqCTime.d_userTime);P(eqCTime.d_wallTime);

        sw.reset();
        sw.start(true);
        for (int jj = k_NUM_TRIALS; 0 < jj; --jj) {
            const int  idxA = absMmixRandNum() % k_NUM_STRINGREFS;
            const int  idxB = absMmixRandNum() % k_NUM_STRINGREFS;
            const bool LT   = eqv[idxA] <  eqv[idxB];

            ASSERTV(LT == (srv[idxA] <  srv[idxB]));
        }
        sw.stop();

        Times ltTime;
        sw.accumulatedTimes(&ltTime.d_systemTime,
                            &ltTime.d_userTime,
                            &ltTime.d_wallTime);
        ltTime -= empty;
        P_(ltTime.d_systemTime);  P_(ltTime.d_userTime);  P(ltTime.d_wallTime);

        sw.reset();
        sw.start(true);
        for (int jj = k_NUM_TRIALS; 0 < jj; --jj) {
            const int  idxA = absMmixRandNum() % k_NUM_STRINGREFS;
            const int  idxB = absMmixRandNum() % k_NUM_STRINGREFS;
            const bool LT   = eqv[idxA] <  eqv[idxB];

            ASSERTV(LT == (srv[idxA] <  sv[idxB].c_str()));
        }
        sw.stop();

        Times ltCTime;
        sw.accumulatedTimes(&ltCTime.d_systemTime,
                            &ltCTime.d_userTime,
                            &ltCTime.d_wallTime);
        ltCTime -= empty;
        P_(ltCTime.d_systemTime);P_(ltCTime.d_userTime);P(ltCTime.d_wallTime);
      } break;
      default: {
        std::cerr << "WARNING: CASE `" << test << "' NOT FOUND." << std::endl;
        testStatus = -1;
      }
    }

    if (testStatus > 0) {
        std::cerr << "Error, non-zero test status = "
                  << testStatus
                  << "."
                  << std::endl;
    }
    return testStatus;
}

// ----------------------------------------------------------------------------
// Copyright 2019 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
