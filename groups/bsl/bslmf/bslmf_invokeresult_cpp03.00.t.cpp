// bslmf_invokeresult_cpp03.00.t.cpp                                  -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

//=============================================================================
//                             TEST PLAN
//-----------------------------------------------------------------------------
// This component is the C++03 translation of a C++11 component, generated by
// the 'sim_cpp11_features.pl' program.  If the the original test driver
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivelent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The test
// driver code in this file is designed to be '#include'd into the original
// test driver when compiling with a C++03 compiler.  If there are no
// specially delimited regions of C++11 code, then this test driver is a
// minimal 'main' program that tests nothing and is not '#include'd in the
// original.
//
// Generated on Tue Jul  6 17:05:09 2021
// Command line: sim_cpp11_features.pl bslmf_invokeresult.00.t.cpp

// Expanded test driver only when compiling bslmf_invokeresult.cpp
#ifdef COMPILING_BSLMF_INVOKERESULT_T_CPP

#if defined(BSLS_PLATFORM_CMP_SUN)
# pragma error_messages(off, functypequal)
#endif


using namespace BloombergLP;


//=============================================================================
//                             TEST PLAN
//-----------------------------------------------------------------------------
// This component is a transformation metafunction.  Testing consists primarily
// of instantiating 'bsl::invoke_result<FN, Args...>' with representative
// combinations of 'Fn' and 'Args' and verifying that the resulting 'type' is
// what was expected.  The test is broken up as one test case per category of
// invocable 'Fn' parameter.
//-----------------------------------------------------------------------------
// [2] FUNCTION INVOCABLES
// [3] POINTER-TO-MEMBER-FUNCTION INVOCABLES
// [4] POINTER-TO-MEMBER-OBJECT INVOCABLES
// [5] FUNCTOR CLASS INVOCABLES
// [6] FUNCTION: InvokeResultDeductionFailed
// [7] C++17 SEMANTICS
//-----------------------------------------------------------------------------
// [1] BREATHING TEST
// [8] USAGE EXAMPLE
//-----------------------------------------------------------------------------



// ============================================================================
//                     STANDARD BSL ASSERT TEST FUNCTION
// ----------------------------------------------------------------------------

namespace {

int testStatus = 0;

void aSsErT(bool condition, const char *message, int line)
{
    if (condition) {
        printf("Error " __FILE__ "(%d): %s    (failed)\n", line, message);

        if (0 <= testStatus && testStatus <= 100) {
            ++testStatus;
        }
    }
}

}  // close unnamed namespace


// ============================================================================
//               STANDARD BSL TEST DRIVER MACRO ABBREVIATIONS
// ----------------------------------------------------------------------------

#define ASSERT       BSLS_BSLTESTUTIL_ASSERT
#define ASSERTV      BSLS_BSLTESTUTIL_ASSERTV

#define LOOP_ASSERT  BSLS_BSLTESTUTIL_LOOP_ASSERT
#define LOOP0_ASSERT BSLS_BSLTESTUTIL_LOOP0_ASSERT
#define LOOP1_ASSERT BSLS_BSLTESTUTIL_LOOP1_ASSERT
#define LOOP2_ASSERT BSLS_BSLTESTUTIL_LOOP2_ASSERT
#define LOOP3_ASSERT BSLS_BSLTESTUTIL_LOOP3_ASSERT
#define LOOP4_ASSERT BSLS_BSLTESTUTIL_LOOP4_ASSERT
#define LOOP5_ASSERT BSLS_BSLTESTUTIL_LOOP5_ASSERT
#define LOOP6_ASSERT BSLS_BSLTESTUTIL_LOOP6_ASSERT

#define Q            BSLS_BSLTESTUTIL_Q   // Quote identifier literally.
#define P            BSLS_BSLTESTUTIL_P   // Print identifier and value.
#define P_           BSLS_BSLTESTUTIL_P_  // P(X) without '\n'.
#define T_           BSLS_BSLTESTUTIL_T_  // Print a tab (w/o newline).
#define L_           BSLS_BSLTESTUTIL_L_  // current Line number


//=============================================================================
//                  GLOBAL TYPEDEFS/CONSTANTS FOR TESTING
//-----------------------------------------------------------------------------

#if defined(BSLS_PLATFORM_CMP_MSVC)
#define MSVC 1
#else
#define MSVC 0
#endif

#if defined(BSLS_PLATFORM_CMP_MSVC) && BSLS_PLATFORM_CMP_VERSION == 1800
#define MSVC_2013 1
#else
#define MSVC_2013 0
#endif

#if defined(BSLS_PLATFORM_CMP_MSVC) && BSLS_PLATFORM_CMP_VERSION == 1900
#define MSVC_2015 1
#else
#define MSVC_2015 0
#endif

#if defined(BSLS_PLATFORM_CMP_MSVC)   \
 && BSLS_PLATFORM_CMP_VERSION >= 1910 \
 && BSLS_PLATFORM_CMP_VERSION <= 1916
#define MSVC_2017 1
#else
#define MSVC_2017 0
#endif

#if defined(BSLS_PLATFORM_CMP_MSVC)   \
 && BSLS_PLATFORM_CMP_VERSION >= 1920 \
 && BSLS_PLATFORM_CMP_VERSION <= 1929
#define MSVC_2019 1
#else
#define MSVC_2019 0
#endif

                      // =============================================
                      // Common function for test case banner printing
                      // =============================================

namespace {

BSLA_MAYBE_UNUSED
void referUserToElsewhere(int test, bool verbose)
    // I the specified 'verbose' then print a message referring to the file
    // containing the case for the specified 'test'
{
    if (verbose)
         printf("Test case %d is in another test driver part "
                "bslm_invokeresult.%02d.t.cpp\n"
                "See 'bslstl_invokeresult.00.t.cpp' for the test plan.\n",
                test, test);
}

}  // close unnamed namespace

                      // ===========================================
                      // Set macros to indicate MSVC bug workarounds
                      // ===========================================

#if defined(BSLS_PLATFORM_CMP_MSVC)
// The MSVC 18.0 and 19.0 compilers have a bug whereby an expression like,
// 'func().*ptrtomem', where 'func()' returns 'volatile SomeClass&&' and
// 'ptrtomem' is a declared as 'RET SomeClass::*ptrtomem', yields an lvalue
// instead of an rvalue reference. Defining this macro will disable certain
// tests that would fail using the MSVC compiler.
#   define MSVC_PTR_TO_MEMBER_OF_RVALUE_REF_BUG

// These compilers also have a bug whereby similar expressions where 'func()'
// returns a const- and/or volatile-qualified class type, and 'ptrtomem' is
// declared as a 'RET SomeClass::*ptrtomem' yields an expression of
// reference-to-'RET' type lacking the appropriate qualifiers if 'RET' is an
// array type.
#   define MSVC_PTR_TO_ARRAY_MEMBER_QUALIFIER_PROPAGATION_BUG

#   if BSLS_PLATFORM_CMP_VERSION == 1900
    // MSVC 2015 has compiler version number 1900.  In this version of MSVC,
    // the above mentioned defect affecting pointer-to-member dereference
    // expressions extends to expressions on *unqualified* class types.
#       define MSVC_2015_PTR_TO_ARRAY_MEMBER_QUALIFIER_PROPAGATION_BUG
#   endif
#endif //BSLS_PLATFORM_CMP_MSVC

                      // ===========================================
                      // some compilers require abridged tests
                      // (applies even when the test has been split)
                      // ===========================================

#if defined(BSLS_PLATFORM_CMP_IBM) || defined(BSLS_PLATFORM_CMP_SUN)
# define BSLMF_INVOKERESULT_ABRIDGED_TEST 1
    // Use Abridged set of tests for xlC and Sun CC 5.12. These compilers
    // get overwhelmed with too many template instantiations. They will work
    // fine for a real program, but fail for test programs like this that
    // recursively create hundreds of instantiations. The abridged tests lose
    // a bit of redundancy, but are probably adaquate for testing the
    // component, especially when combined with the full tests on other
    // platforms.
#else
# define BSLMF_INVOKERESULT_ABRIDGED_TEST 0
#endif

namespace {

                      // ================================
                      // class template reference_wrapper
                      // Required for test cases 3,7
                      // ================================

// Required for test cases 3,7
template <class TP>
class stub_reference_wrapper {
    // This class template provides a stub implementation of
    // 'bsl::reference_wrapper' with just enough real interface to allow code
    // within this test driver to compile.  The real 'reference_wrapper' is
    // not available, as it is in a higher-level component than this one.

  public:
    // ACCESSORS
    operator TP&() const BSLS_KEYWORD_NOEXCEPT;
        // This member operator is declared but not defined.

    TP& get() const BSLS_KEYWORD_NOEXCEPT;
        // This member function is declared but not defined.
};

}  // close unnamed namespace


namespace BloombergLP {
namespace bslmf {

// Required for test cases 3,7
template <class TP>
struct IsReferenceWrapper<stub_reference_wrapper<TP> > : bsl::true_type {
};

}  // close package namespace
}  // close enterprise namespace


#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.00.t.cpp
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_A
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_A BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif


namespace {

template <class EXPECTED_INVOKE_RESULT,
          class INVOCABLE
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 0
        , class ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 1
        , class ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 2
        , class ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 3
        , class ARGS_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 4
        , class ARGS_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 5
        , class ARGS_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 6
        , class ARGS_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 7
        , class ARGS_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 8
        , class ARGS_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 9
        , class ARGS_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 10
        , class ARGS_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 11
        , class ARGS_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 12
        , class ARGS_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct IsInvokeResult;

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 0
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 1
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 2
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 3
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 4
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 5
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 6
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05,
                                                         class ARGS_06>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05,
                                                      ARGS_06>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 7
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05,
                                                         class ARGS_06,
                                                         class ARGS_07>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05,
                                                      ARGS_06,
                                                      ARGS_07>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 8
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05,
                                                         class ARGS_06,
                                                         class ARGS_07,
                                                         class ARGS_08>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05,
                                                      ARGS_06,
                                                      ARGS_07,
                                                      ARGS_08>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 9
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05,
                                                         class ARGS_06,
                                                         class ARGS_07,
                                                         class ARGS_08,
                                                         class ARGS_09>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05,
                                                      ARGS_06,
                                                      ARGS_07,
                                                      ARGS_08,
                                                      ARGS_09>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 10
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05,
                                                         class ARGS_06,
                                                         class ARGS_07,
                                                         class ARGS_08,
                                                         class ARGS_09,
                                                         class ARGS_10>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09,
                                                         ARGS_10>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05,
                                                      ARGS_06,
                                                      ARGS_07,
                                                      ARGS_08,
                                                      ARGS_09,
                                                      ARGS_10>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 11
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05,
                                                         class ARGS_06,
                                                         class ARGS_07,
                                                         class ARGS_08,
                                                         class ARGS_09,
                                                         class ARGS_10,
                                                         class ARGS_11>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09,
                                                         ARGS_10,
                                                         ARGS_11>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05,
                                                      ARGS_06,
                                                      ARGS_07,
                                                      ARGS_08,
                                                      ARGS_09,
                                                      ARGS_10,
                                                      ARGS_11>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 12
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05,
                                                         class ARGS_06,
                                                         class ARGS_07,
                                                         class ARGS_08,
                                                         class ARGS_09,
                                                         class ARGS_10,
                                                         class ARGS_11,
                                                         class ARGS_12>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09,
                                                         ARGS_10,
                                                         ARGS_11,
                                                         ARGS_12>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05,
                                                      ARGS_06,
                                                      ARGS_07,
                                                      ARGS_08,
                                                      ARGS_09,
                                                      ARGS_10,
                                                      ARGS_11,
                                                      ARGS_12>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 13
template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class ARGS_01,
                                                         class ARGS_02,
                                                         class ARGS_03,
                                                         class ARGS_04,
                                                         class ARGS_05,
                                                         class ARGS_06,
                                                         class ARGS_07,
                                                         class ARGS_08,
                                                         class ARGS_09,
                                                         class ARGS_10,
                                                         class ARGS_11,
                                                         class ARGS_12,
                                                         class ARGS_13>
struct IsInvokeResult<EXPECTED_INVOKE_RESULT, INVOCABLE, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09,
                                                         ARGS_10,
                                                         ARGS_11,
                                                         ARGS_12,
                                                         ARGS_13>
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS_01,
                                                      ARGS_02,
                                                      ARGS_03,
                                                      ARGS_04,
                                                      ARGS_05,
                                                      ARGS_06,
                                                      ARGS_07,
                                                      ARGS_08,
                                                      ARGS_09,
                                                      ARGS_10,
                                                      ARGS_11,
                                                      ARGS_12,
                                                      ARGS_13>::type> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 13


}
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.


namespace {

template <class EXPECTED_INVOKE_RESULT, class INVOCABLE, class... ARGS>
struct IsInvokeResult
: bsl::is_same<EXPECTED_INVOKE_RESULT,
               typename bsl::invoke_result<INVOCABLE, ARGS...>::type> {
};

}

// }}} END GENERATED CODE
#endif

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.00.t.cpp
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 5
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_B
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_B BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif


namespace {

template <class VOID,
          class INVOCABLE
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
        , class ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
        , class ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
        , class ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
        , class ARGS_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
        , class ARGS_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
        , class = BSLS_COMPILERFEATURES_NILT>
struct IsInvokeResultDefinedImp;


template <class INVOCABLE
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
        , class ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
        , class ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
        , class ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
        , class ARGS_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
        , class ARGS_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
        , class = BSLS_COMPILERFEATURES_NILT>
struct IsInvokeResultDefined;

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
template <class INVOCABLE>
struct IsInvokeResultDefined<INVOCABLE>
: IsInvokeResultDefinedImp<void, INVOCABLE> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
template <class INVOCABLE, class ARGS_1>
struct IsInvokeResultDefined<INVOCABLE, ARGS_1>
: IsInvokeResultDefinedImp<void, INVOCABLE, ARGS_1> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
template <class INVOCABLE, class ARGS_1,
                           class ARGS_2>
struct IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                        ARGS_2>
: IsInvokeResultDefinedImp<void, INVOCABLE, ARGS_1,
                                            ARGS_2> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
template <class INVOCABLE, class ARGS_1,
                           class ARGS_2,
                           class ARGS_3>
struct IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                        ARGS_2,
                                        ARGS_3>
: IsInvokeResultDefinedImp<void, INVOCABLE, ARGS_1,
                                            ARGS_2,
                                            ARGS_3> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
template <class INVOCABLE, class ARGS_1,
                           class ARGS_2,
                           class ARGS_3,
                           class ARGS_4>
struct IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                        ARGS_2,
                                        ARGS_3,
                                        ARGS_4>
: IsInvokeResultDefinedImp<void, INVOCABLE, ARGS_1,
                                            ARGS_2,
                                            ARGS_3,
                                            ARGS_4> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5
template <class INVOCABLE, class ARGS_1,
                           class ARGS_2,
                           class ARGS_3,
                           class ARGS_4,
                           class ARGS_5>
struct IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                        ARGS_2,
                                        ARGS_3,
                                        ARGS_4,
                                        ARGS_5>
: IsInvokeResultDefinedImp<void, INVOCABLE, ARGS_1,
                                            ARGS_2,
                                            ARGS_3,
                                            ARGS_4,
                                            ARGS_5> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5



#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
template <class VOID, class INVOCABLE>
struct IsInvokeResultDefinedImp<VOID, INVOCABLE> : bsl::false_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
template <class VOID, class INVOCABLE, class ARGS_1>
struct IsInvokeResultDefinedImp<VOID, INVOCABLE, ARGS_1> : bsl::false_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
template <class VOID, class INVOCABLE, class ARGS_1,
                                       class ARGS_2>
struct IsInvokeResultDefinedImp<VOID, INVOCABLE, ARGS_1,
                                                 ARGS_2> : bsl::false_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
template <class VOID, class INVOCABLE, class ARGS_1,
                                       class ARGS_2,
                                       class ARGS_3>
struct IsInvokeResultDefinedImp<VOID, INVOCABLE, ARGS_1,
                                                 ARGS_2,
                                                 ARGS_3> : bsl::false_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
template <class VOID, class INVOCABLE, class ARGS_1,
                                       class ARGS_2,
                                       class ARGS_3,
                                       class ARGS_4>
struct IsInvokeResultDefinedImp<VOID, INVOCABLE, ARGS_1,
                                                 ARGS_2,
                                                 ARGS_3,
                                                 ARGS_4> : bsl::false_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5
template <class VOID, class INVOCABLE, class ARGS_1,
                                       class ARGS_2,
                                       class ARGS_3,
                                       class ARGS_4,
                                       class ARGS_5>
struct IsInvokeResultDefinedImp<VOID, INVOCABLE, ARGS_1,
                                                 ARGS_2,
                                                 ARGS_3,
                                                 ARGS_4,
                                                 ARGS_5> : bsl::false_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
template <class INVOCABLE>
struct IsInvokeResultDefinedImp<
    typename bslmf::VoidType<
        typename bsl::invoke_result<INVOCABLE>::type>::type,
    INVOCABLE> : bsl::true_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
template <class INVOCABLE, class ARGS_1>
struct IsInvokeResultDefinedImp<
    typename bslmf::VoidType<
        typename bsl::invoke_result<INVOCABLE, ARGS_1>::type>::type,
    INVOCABLE,
    ARGS_1> : bsl::true_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
template <class INVOCABLE, class ARGS_1,
                           class ARGS_2>
struct IsInvokeResultDefinedImp<
    typename bslmf::VoidType<
        typename bsl::invoke_result<INVOCABLE, ARGS_1,
                                               ARGS_2>::type>::type,
    INVOCABLE,
    ARGS_1,
    ARGS_2> : bsl::true_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
template <class INVOCABLE, class ARGS_1,
                           class ARGS_2,
                           class ARGS_3>
struct IsInvokeResultDefinedImp<
    typename bslmf::VoidType<
        typename bsl::invoke_result<INVOCABLE, ARGS_1,
                                               ARGS_2,
                                               ARGS_3>::type>::type,
    INVOCABLE,
    ARGS_1,
    ARGS_2,
    ARGS_3> : bsl::true_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
template <class INVOCABLE, class ARGS_1,
                           class ARGS_2,
                           class ARGS_3,
                           class ARGS_4>
struct IsInvokeResultDefinedImp<
    typename bslmf::VoidType<
        typename bsl::invoke_result<INVOCABLE, ARGS_1,
                                               ARGS_2,
                                               ARGS_3,
                                               ARGS_4>::type>::type,
    INVOCABLE,
    ARGS_1,
    ARGS_2,
    ARGS_3,
    ARGS_4> : bsl::true_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5
template <class INVOCABLE, class ARGS_1,
                           class ARGS_2,
                           class ARGS_3,
                           class ARGS_4,
                           class ARGS_5>
struct IsInvokeResultDefinedImp<
    typename bslmf::VoidType<
        typename bsl::invoke_result<INVOCABLE, ARGS_1,
                                               ARGS_2,
                                               ARGS_3,
                                               ARGS_4,
                                               ARGS_5>::type>::type,
    INVOCABLE,
    ARGS_1,
    ARGS_2,
    ARGS_3,
    ARGS_4,
    ARGS_5> : bsl::true_type {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5


}
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.


namespace {

template <class VOID, class INVOCABLE, class... ARGS>
struct IsInvokeResultDefinedImp;

template <class INVOCABLE, class... ARGS>
struct IsInvokeResultDefined
: IsInvokeResultDefinedImp<void, INVOCABLE, ARGS...> {
};


template <class VOID, class INVOCABLE, class... ARGS>
struct IsInvokeResultDefinedImp : bsl::false_type {
};

template <class INVOCABLE, class... ARGS>
struct IsInvokeResultDefinedImp<
    typename bslmf::VoidType<
        typename bsl::invoke_result<INVOCABLE, ARGS...>::type>::type,
    INVOCABLE,
    ARGS...> : bsl::true_type {
};

}

// }}} END GENERATED CODE
#endif


#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.00.t.cpp
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 5
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_C
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_C BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif


namespace {

class SfinaeFriendlinessTest {
  public:
    SfinaeFriendlinessTest() {}

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0
    template <bool IS_TYPE_DEFINED, class INVOCABLE>
    void run(int LINE) const
    {
        if (IS_TYPE_DEFINED) {
            ASSERTV(LINE, (IsInvokeResultDefined<INVOCABLE>::value));
        }
        else {
            ASSERTV(LINE, (!IsInvokeResultDefined<INVOCABLE>::value));
        }
    }
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1
    template <bool IS_TYPE_DEFINED, class INVOCABLE, class ARGS_1>
    void run(int LINE) const
    {
        if (IS_TYPE_DEFINED) {
            ASSERTV(LINE, (IsInvokeResultDefined<INVOCABLE, ARGS_1>::value));
        }
        else {
            ASSERTV(LINE, (!IsInvokeResultDefined<INVOCABLE, ARGS_1>::value));
        }
    }
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2
    template <bool IS_TYPE_DEFINED, class INVOCABLE, class ARGS_1,
                                                     class ARGS_2>
    void run(int LINE) const
    {
        if (IS_TYPE_DEFINED) {
            ASSERTV(LINE, (IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                                            ARGS_2>::value));
        }
        else {
            ASSERTV(LINE, (!IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                                             ARGS_2>::value));
        }
    }
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3
    template <bool IS_TYPE_DEFINED, class INVOCABLE, class ARGS_1,
                                                     class ARGS_2,
                                                     class ARGS_3>
    void run(int LINE) const
    {
        if (IS_TYPE_DEFINED) {
            ASSERTV(LINE, (IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                                            ARGS_2,
                                                            ARGS_3>::value));
        }
        else {
            ASSERTV(LINE, (!IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                                             ARGS_2,
                                                             ARGS_3>::value));
        }
    }
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4
    template <bool IS_TYPE_DEFINED, class INVOCABLE, class ARGS_1,
                                                     class ARGS_2,
                                                     class ARGS_3,
                                                     class ARGS_4>
    void run(int LINE) const
    {
        if (IS_TYPE_DEFINED) {
            ASSERTV(LINE, (IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                                            ARGS_2,
                                                            ARGS_3,
                                                            ARGS_4>::value));
        }
        else {
            ASSERTV(LINE, (!IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                                             ARGS_2,
                                                             ARGS_3,
                                                             ARGS_4>::value));
        }
    }
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5
    template <bool IS_TYPE_DEFINED, class INVOCABLE, class ARGS_1,
                                                     class ARGS_2,
                                                     class ARGS_3,
                                                     class ARGS_4,
                                                     class ARGS_5>
    void run(int LINE) const
    {
        if (IS_TYPE_DEFINED) {
            ASSERTV(LINE, (IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                                            ARGS_2,
                                                            ARGS_3,
                                                            ARGS_4,
                                                            ARGS_5>::value));
        }
        else {
            ASSERTV(LINE, (!IsInvokeResultDefined<INVOCABLE, ARGS_1,
                                                             ARGS_2,
                                                             ARGS_3,
                                                             ARGS_4,
                                                             ARGS_5>::value));
        }
    }
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5

};

}
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.


namespace {

class SfinaeFriendlinessTest {
  public:
    SfinaeFriendlinessTest() {}

    template <bool IS_TYPE_DEFINED, class INVOCABLE, class... ARGS>
    void run(int LINE) const
    {
        if (IS_TYPE_DEFINED) {
            ASSERTV(LINE, (IsInvokeResultDefined<INVOCABLE, ARGS...>::value));
        }
        else {
            ASSERTV(LINE, (!IsInvokeResultDefined<INVOCABLE, ARGS...>::value));
        }
    }
};

}

// }}} END GENERATED CODE
#endif


namespace {

// 15 distinct types
//
// Required for test cases 2,3,4
typedef bsl::integral_constant<int,  0> Ic00;
typedef bsl::integral_constant<int,  1> Ic01;
typedef bsl::integral_constant<int,  2> Ic02;
typedef bsl::integral_constant<int,  3> Ic03;
typedef bsl::integral_constant<int,  4> Ic04;
typedef bsl::integral_constant<int,  5> Ic05;
typedef bsl::integral_constant<int,  6> Ic06;
typedef bsl::integral_constant<int,  7> Ic07;
typedef bsl::integral_constant<int,  8> Ic08;
typedef bsl::integral_constant<int,  9> Ic09;
typedef bsl::integral_constant<int, 10> Ic10;
typedef bsl::integral_constant<int, 11> Ic11;
typedef bsl::integral_constant<int, 12> Ic12;
typedef bsl::integral_constant<int, 13> Ic13;
typedef bsl::integral_constant<int, 14> Ic14;

// Required for test cases 1,4,5
template <class TP>
struct MetaType {
    // An object of type 'MetaType<TP>' can represent 'TP' at run-time without
    // actually creating an instance of 'TP'.  Note that 'TP' can be a
    // reference and/or cv-qualified.

    typedef TP type;
};

// Required for test cases 2,3,4,5,6
enum MyEnum {
    // An enumeration type, for testing invocables that return enumerations.
    MY_ENUMERATOR
};


// Required for test cases 1,2,3,4,5,6,7
struct MyClass {
    // Simple class type that can be returned by value and to which member
    // variables and functions that can be referenced via pointer-to-member.

    char *d_str_p;
    int foo();
        // Declared but not defined.

    MyClass() : d_str_p(0) {}
    MyClass(MyClass&);
    MyClass(const MyClass&);
    MyClass(volatile MyClass&);
    MyClass(const volatile MyClass&);
        // Declared but not defined.

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    MyClass(MyClass&&);
    MyClass(const MyClass&&);
    MyClass(volatile MyClass&&);
    MyClass(const volatile MyClass&&);
        // Declared but not defined.
#endif
};

// Required for test cases 2,3,4,5,7
struct MyDerivedClass : MyClass {
    // A class derived from MyClass, for testing pointer-to-base-member.
};

// Required for test cases 3,4,7
template <class TP>
struct SmartPtr {
    // This template has the interface of a smart pointer.  Specifically, the
    // dereference operator returns a reference to 'TP'.

    TP& operator*() const volatile;
    TP* operator->() const volatile;
        // Pointer-like operators (declared but not defined).
};


// Required for test cases 2,3,7
struct ToLongLong
{
    // Objects of this class are convertible to long long.

    operator long long() const;
        // Convertion to 'long long' (declared but not defined).
};


// Required for test cases 1,4,5
struct ManyFunc {
    // Generic functor class with many overloads of 'operator()'.

    bool operator()(float, void*);
    float operator()(float, void*) const;
        // Invocation operators for breathing test (declared but not defined)

    bool  operator()();
    short operator()(int);
    int   operator()(int, float);
    long  operator()(int, float, short, int, int, int, int, int, int, float);
    unsigned int   operator()(int,   int);
    unsigned short operator()(short, int);
        // Invocation overloads based on types and numbers of arguments
        // (declared but not defined)

    bool&  operator()(int, int, int);
    short& operator()(int, int, int) const;
    int&   operator()(int, int, int) volatile;
    long&  operator()(int, int, int) const volatile;
        // Invocation overloads based on 'const' and 'volatile' (declared but
        // not defined)

#if defined(BSLS_PLATFORM_CMP_SUN) || defined(BSLS_PLATFORM_CMP_IBM)
    // sun and xlC do not correctly strip top-level cv qualifiers from return
    // types.
    template <class TP>
    typename bsl::remove_cv<TP>::type operator()(MetaType<TP>, ...);
#else
    template <class TP>
    TP operator()(MetaType<TP>, ...);
#endif
    template <class TP>
    typename bsl::add_const<TP>::type operator()(MetaType<TP>, ...) const;
        // Return type deduced from first argument (declared but not defined)

    template <class TP>
    TP operator()(char*, MetaType<TP>);
        // Return type is 'TP'.  'invoke_result' is specialized for this case
        // (declared but not defined)

    typedef void *P;
    char        operator()(P);
    short       operator()(P,P);
    int         operator()(P,P,P);
    long        operator()(P,P,P,P);
    long long   operator()(P,P,P,P,P);
    float       operator()(P,P,P,P,P,P);
    double      operator()(P,P,P,P,P,P,P);
    long double operator()(P,P,P,P,P,P,P,P);
    const char *operator()(P,P,P,P,P,P,P,P,P);
    void       *operator()(P,P,P,P,P,P,P,P,P,P);
        // Invocation overloads for 1 to 10 pointer arguments (declared but
        // not defined)
};

// Required for test cases 5,7
struct ConvertibleToFunc {
    // Class that is convertible to pointer-to-function or
    // reference-to-function, depending on the overload used.

    typedef bool    (*boolFPtr)();
    typedef short   (*shortFPtr)(int);
    typedef int*    (&intStarFRef)(int, float);
    typedef MyClass (&udtFRef)(int, float, short);

    operator boolFPtr() const;
        // Conversion to pointer to function returning bool.

    operator shortFPtr() const;
        // Conversion to pointer to function taking one argument.

    operator intStarFRef() const;
        // Conversion to reference to function returning pointer.

    operator udtFRef() const;
        // Conversion to reference to function returning pointer.
};

// Required for test cases 5,7
template <class RT>
struct FuncRt1 {
    // Functor type with two overloads of 'operator()': one that returns
    // 'result_type', which is an alias for 'RT', and another overload that
    // always returns 'int', regardless of 'result_type'.

    typedef RT result_type; // Used by 'invoke_result' to determine return type

    result_type operator()(const char*);
        // Used to test return type can be deduced via 'result_type' (declared
        // but not defined)

    int operator()(int);
        // Used to test that deduction of fundamental type 'int' supercedes
        // 'result_type' (declared but not defined)
};

// Required for test cases 5,7
template <class RT>
struct FuncRt2 {
    // Functor type with two overloads of 'operator()', one that returns
    // 'ResultType', which is an alias for 'RT', and another overload that
    // always returns 'int', regardless of 'ResultType'.

    typedef RT ResultType; // Used by 'invoke_result' to determine return type

    ResultType operator()(const char*);
        // Used to test return type can be deduced via 'ResultType' (declared
        // but not defined)

    int operator()(int);
        // Used to test that deduction of fundamental type 'int' supercedes
        // 'ResultType' (declared but not defined)
};

// Required for test cases 5,7
template <class RT>
struct FuncRt3 {
    // Functor type with two overloads of 'operator()', one that returns
    // 'result_type', which is an alias for 'RT', and another overload that
    // always returns 'int', regardless of 'result_type'.  This struct also
    // defines 'ResultType', which should be ignored in preference to
    // 'result_type'.

    typedef RT   result_type; // Used by 'invoke_result' to get return type
    typedef void ResultType;  // Ignored by 'invoke_result'.

    result_type operator()(const char*) const;
        // Used to test return type can be deduced via 'result_type' (declared
        // but not defined)

    int operator()(int) const;
        // Used to test that deduction of fundamental type 'int' supercedes
        // 'result_type' (declared but not defined)
};



// Required for test cases 2,3,4,5
template <class TEST_KERNEL, class RT>
struct ApplyRef {
    // Used by 'applyPtrAndRef' to apply the specified 'TEST_KERNEL' template
    // parameter to each of 'RT', 'RT&', 'const RT&', 'volatile RT&',
    // 'const volatile RT&', and 'RT&&'.  Requires: 'TEST_KERNEL' is a class
    // type with an 'apply<TP>()' static member that tests 'invoke_result' on
    // invocables that return 'TP'.

    static void apply(int LINE)
        // Call, using the specified 'LINE', 'TEST_KERNEL::apply<RT>(LINE)' and
        // 'TEST_KERNEL::apply<cv RT&>(LINE)', where 'cv' is all four
        // combinations of 'const' and 'volatile'.  On compilers that support
        // rvalue references, also call 'TEST_KERNEL::apply<RT&&>(LINE)'.
    {
        TEST_KERNEL::template apply<RT>(LINE);
        TEST_KERNEL::template apply<RT&>(LINE);
        TEST_KERNEL::template apply<const RT&>(LINE);
        TEST_KERNEL::template apply<volatile RT&>(LINE);
        TEST_KERNEL::template apply<const volatile RT&>(LINE);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCE
# ifdef BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE
#  if !MSVC_2013 // MSVC 2013 does not have a sufficiently functional
                 // implementation of expression sfinae for
                 // 'bslmf_invokeresult' to make use of 'decltype'.  This means
                 // that 'bslmf_invokeresult' cannot support
                 // rvalue-reference-qualified types on MSVC 2013.
        TEST_KERNEL::template apply<RT&&>(LINE);
        TEST_KERNEL::template apply<const RT&&>(LINE);
        TEST_KERNEL::template apply<volatile RT&&>(LINE);
        TEST_KERNEL::template apply<const volatile RT&&>(LINE);
#  endif
# else
#  error "Rvalue refs without 'decltype' not supported by 'bsl::invoke_result'"
# endif
#endif
    }
};

// Required for test cases 2,3,4,5
template <class TEST_KERNEL>
struct ApplyRef<TEST_KERNEL, void> {
    // For the specified 'TEST_KERNEL' template parameter, apply 'TEST_KERNEL'
    // such that it tests invocations that should return 'void'.  This
    // specialization avoids trying to create a reference-to-void.

    static void apply(int LINE)
        // Call, using the specified 'LINE', 'TEST_KERNEL::apply<void>(LINE)'.
    {
        TEST_KERNEL::template apply<void>(LINE);
    }
};

// Required for test cases 2,3,4,5
template <class TEST_KERNEL, class RT>
static void applyPtrAndRef(int LINE)
    // Call, using the specified 'LINE', 'TEST_KERNEL::apply<X>(LINE)', where
    // 'X' is each of the following: the specified 'RT' template parameter, a
    // pointer to (cv-qualified) 'RT', a reference to cv-qualified of 'RT', and
    // a reference to a cv-qualified pointer to cv-qualified 'RT' (for every
    // combination of cv qualifications).  Requires: 'TEST_KERNEL' is a class
    // type with an 'apply<TP>()' static member that tests 'invoke_result' on
    // invocables that return 'TP'.
{
    ApplyRef<TEST_KERNEL, RT>::apply(LINE);
    ApplyRef<TEST_KERNEL, RT*>::apply(LINE);
    ApplyRef<TEST_KERNEL, const RT*>::apply(LINE);
    ApplyRef<TEST_KERNEL, volatile RT*>::apply(LINE);
    ApplyRef<TEST_KERNEL, const volatile RT*>::apply(LINE);
}

}  // close unnamed namespace


                        // ===========================================
                        // Macros to enable template pre-instantiation
                        // Required for test cases 2,3,4,5
                        // ===========================================

// On some compilers, the number of template instantiations within a single
// function are limited, so we pre-instantiate a number of templates to ensure
// the tests will compile.
//
// These macros enable templates to be forcibly instantiated in xlc before
// they are required, preventing them from getting re-instantiated when used
// and helping to prevent xlc getting overwhelmed by the number of templates.
// Note: use of explicit template instantiation syntax instead has been tried
// and does not prevent the overwhelming implicit instantiations.

// Firstly the macros for ApplyRef
#define PREINSTANTIATE_AR_IMPL2(prefix, name, ...) \
    void dummyFunction##prefix##_##name(int line) \
    { \
        ApplyRef< __VA_ARGS__ >::apply(line); \
    }

#define PREINSTANTIATE_AR_IMPL(prefix, line, ...) \
    PREINSTANTIATE_AR_IMPL2(prefix, line, __VA_ARGS__)

#define PREINSTANTIATE_AR(...) PREINSTANTIATE_AR_IMPL(0, L_, __VA_ARGS__)

// Secondly the macros for applyPtrAndRef
#define PREINSTANTIATE_APR_IMPL2(prefix, name, ...) \
    void dummyFunction##prefix##_##name() \
    { \
        applyPtrAndRef< __VA_ARGS__ >(0); \
    }

#define PREINSTANTIATE_APR_IMPL(prefix, line, ...) \
    PREINSTANTIATE_APR_IMPL2(prefix, line, __VA_ARGS__)

#define PREINSTANTIATE_APR(...) PREINSTANTIATE_APR_IMPL(0, L_, __VA_ARGS__)

// The following macro is equivalent to calling PREINSTANTIATE_APR repeatedly
// to cover all of the basic types.
#define PREINSTANTIATE_APR_FOR_FUNDAMENTAL_TYPES(...) \
    PREINSTANTIATE_APR_IMPL(_void, L_, __VA_ARGS__, void) \
    PREINSTANTIATE_APR_IMPL(_int, L_, __VA_ARGS__, int) \
    PREINSTANTIATE_APR_IMPL(_float, L_, __VA_ARGS__, float) \
    PREINSTANTIATE_APR_IMPL(Ic01, L_, __VA_ARGS__, Ic01) \
    PREINSTANTIATE_APR_IMPL(Cint, L_, __VA_ARGS__, const int) \
    PREINSTANTIATE_APR_IMPL(Vshort,L_,  __VA_ARGS__, volatile short) \
    PREINSTANTIATE_APR_IMPL(CVenum, L_, __VA_ARGS__, const volatile MyEnum)

#ifndef MSVC_PTR_TO_ARRAY_MEMBER_QUALIFIER_PROPAGATION_BUG
    #define PREINSTANTIATE_APR_FOR_BASIC_TYPES(...)                           \
        PREINSTANTIATE_APR_FOR_FUNDAMENTAL_TYPES(__VA_ARGS__)                 \
        PREINSTANTIATE_APR_IMPL(Arry, L_, __VA_ARGS__, int[10][5])
#else
    #define PREINSTANTIATE_APR_FOR_BASIC_TYPES(...)                           \
        PREINSTANTIATE_APR_FOR_FUNDAMENTAL_TYPES(__VA_ARGS__)
#endif


#ifndef BSLMF_INVOKERESULT_00T_AS_INCLUDE

// ============================================================================
//                              MAIN PROGRAM
// ----------------------------------------------------------------------------

int main()
{
    bool verbose = false;

    int  test = -1;
    int  testStatus = -1;

    // This switch statement does nothing, it is here to satisfy bde_verify.
    switch (test) { case 0:
      case -1: {
        // --------------------------------------------------------------------
        // DUMMY TEST CASE
        //
        // Concerns:
        //: 1 Dummy entry to satisfy bde_verify.
        //
        // Plan:
        //: 1 Dummy entry to satisfy bde_verify.
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) printf("\n" "DUMMY TEST CASE" "\n"
                                 "===============" "\n");
      }  break;
      default: {
        testStatus = -1;
      }  break;
    };

    // Remove the "defined but not used" warning:
    ASSERT(true);

    return testStatus;
}

#endif // not defined 'BSLMF_INVOKERESULT_00T_AS_INCLUDE'

#else // if ! defined(COMPILING_BSLMF_INVOKERESULT_T_CPP)

// Trivial program when not compiling bslmf_invokeresult.t.cpp
int main() {
    return -1;
}

#endif // defined(COMPILING_BSLMF_INVOKERESULT_T_CPP)

// ----------------------------------------------------------------------------
// Copyright 2021 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
