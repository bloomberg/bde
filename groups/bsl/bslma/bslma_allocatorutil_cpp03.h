// bslma_allocatorutil_cpp03.h                                        -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMA_ALLOCATORUTIL_CPP03
#define INCLUDED_BSLMA_ALLOCATORUTIL_CPP03

//@PURPOSE: Provide C++03 implementation for bslma_allocatorutil.h
//
//@CLASSES: See bslma_allocatorutil.h for list of classes
//
//@SEE_ALSO: bslma_allocatorutil
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Sun Sep  1 05:38:38 2024
// Command line: sim_cpp11_features.pl bslma_allocatorutil.h

#ifdef COMPILING_BSLMA_ALLOCATORUTIL_H

namespace BloombergLP {
namespace bslma {

// FORWARD DECLARATIONS
template <class t_ALLOCATOR, class t_TYPE = char>
struct AllocatorUtil_Traits;

                        // ===================
                        // class AllocatorUtil
                        // ===================

/// Namespace for utility functions on allocators
struct AllocatorUtil {

  private:
    // PRIVATE CONSTANTS
    enum { k_MAX_ALIGNMENT = bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT };

    // PRIVATE CLASS METHODS
    template <class t_TYPE>
    static char matchBslAlloc(bsl::allocator<t_TYPE> *, int);
    static long matchBslAlloc(void *,                 ...);
        // DECLARED BUT NOT DEFINED

    /// Return the specified `nbytes` raw bytes having the specified
    /// `alignment` allocated from the specified `allocator`.  If
    /// `alignment` is larger than the largest supported alignment, the
    /// behavior is determined by the allocator.
    template <class t_TYPE>
    static
    void *allocateBytesImp(
                          const bsl::polymorphic_allocator<t_TYPE>& allocator,
                          std::size_t                               nbytes,
                          std::size_t                               alignment);
    template <class t_TYPE>
    static
    void *allocateBytesImp(const bsl::allocator<t_TYPE>& allocator,
                           std::size_t                   nbytes,
                           std::size_t                   alignment);
    template <class t_ALLOCATOR>
    static
    typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer
    allocateBytesImp(const t_ALLOCATOR&          allocator,
                     std::size_t                 nbytes,
                     std::size_t                 alignment);

    /// Return, to the specified `allocator`, the block of raw memory at the
    /// specified `p` address having the specified `nbytes` size and the
    /// specified `alignment`.  The behavior is undefined unless `p` refers
    /// to a block having the same size and alignment allocated from a copy
    /// of `allocator` and not yet deallocated.
    template <class t_TYPE>
    static void
    deallocateBytesImp(const bsl::polymorphic_allocator<t_TYPE>&  allocator,
                       void                                      *p,
                       std::size_t                                nbytes,
                       std::size_t                                alignment);
    template <class t_TYPE>
    static void
    deallocateBytesImp(const bsl::allocator<t_TYPE>&  allocator,
                       void                          *p,
                       std::size_t                    nbytes,
                       std::size_t                    alignment);
    template <class t_ALLOCATOR>
    static void deallocateBytesImp(
        const t_ALLOCATOR&                                       allocator,
        typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer p,
        std::size_t                                              nbytes,
        std::size_t                                              alignment);

    template <class t_ALLOCATOR, class t_POINTER, class t_VALUE_TYPE>
    static void deallocateObjectImp(const t_ALLOCATOR&  allocator,
                                    t_POINTER           p,
                                    std::size_t         n,
                                    const t_VALUE_TYPE& );

    template <class t_ALLOCATOR, class t_POINTER, class t_VALUE_TYPE>
    static void deleteObjectImp(const t_ALLOCATOR&  allocator,
                                t_POINTER           p,
                                const t_VALUE_TYPE& );

    /// Return `true` if the specified `alignment` is a (positive) power of
    /// two; otherwise return false.
    static bool isPowerOf2(std::size_t alignment);

    // PRIVATE TYPES

    /// Metafunction derives from `true_type` if (template argument)
    /// `t_ALLOC` is derived from any specialization of `bsl::allocator`;
    /// else derives from `false_type`.
    template <class t_ALLOC>
    struct IsDerivedFromBslAllocator
        : bsl::integral_constant<bool,
                                 1 == sizeof(matchBslAlloc((t_ALLOC *) 0, 0))>
    {
    };

  public:
    // CLASS METHODS

    /// Return the specified `from` allocator adapted to a type most likely
    /// to be usable for initializing another AA object.  Specifically,
    /// return `from.mechanism()` if `from` is a specialization of
    /// `bsl::allocator` (or a class derived from `bsl::allocator`);
    /// otherwise return `from` unchanged.
    template <class t_ALLOC>
    static typename bsl::enable_if<
        ! IsDerivedFromBslAllocator<t_ALLOC>::value,
        t_ALLOC>::type
    adapt(const t_ALLOC& from);
    template <class t_TYPE>
    static bslma::Allocator *adapt(const bsl::allocator<t_TYPE>& from);

    /// Return a pointer to a block of raw memory allocated from the
    /// specified `allocator` having the specified `nbytes` size and
    /// optionally specified `alignment`.  If `alignment` is larger than the
    /// largest supported alignment, either the block will be aligned to the
    /// maximum supported alignment or an exception will be thrown.  The
    /// specific choice of behavior is determined by the allocator: for
    /// polymorphic allocators the behavior is determined by the memory
    /// resource, whereas for non-polymorphic allocators, the alignment is
    /// always truncated to the maximum non-extended alignment.
    template <class t_ALLOCATOR>
    static typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer
    allocateBytes(const t_ALLOCATOR& allocator,
                  std::size_t        nbytes,
                  std::size_t        alignment = k_MAX_ALIGNMENT);

    /// Return a pointer to a block of raw memory allocated from the
    /// specified `allocator` having a size and alignment appropriate for an
    /// object of (templatize parameter) `t_TYPE`.  Optionally specify `n`
    /// for the number of objects; otherwise space for a single object is
    /// allocated.  Since `t_TYPE` cannot be deduced from the function
    /// parameters, it must be supplied explicitly (in `<>` brackets) by the
    /// caller.
    template <class t_TYPE, class t_ALLOCATOR>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    allocateObject(const t_ALLOCATOR& allocator, std::size_t n = 1);

    /// If the specified `allowed` tag is `bsl::true_type` assign the
    /// allocator object at the specified `lhs` address the value of the
    /// specified `rhs`; otherwise, do nothing, and, in both cases, return a
    /// modifiable reference to `*lhs`.  The `t_TYPE` template parameter is
    /// typically an allocator type and the `allowed` flag is typically a
    /// propagation trait dependant on the calling context, such as
    /// `propagate_on_container_copy_assignment` or
    /// `propagate_on_container_move_assignment`.  Instantiation will fail
    /// if `allowed` is `true_type` and `t_TYPE` lacks a publically
    /// accessible copy assignment operator.  The behavior is undefined
    /// unless `allowed` is `true_type` or `*lhs == rhs` before the call.
    template <class t_TYPE>
    static t_TYPE& assign(t_TYPE         *lhs,
                          const t_TYPE&   rhs,
                          bsl::true_type  allowed);
    template <class t_TYPE>
    static t_TYPE& assign(t_TYPE          *lhs,
                          const t_TYPE&    rhs,
                          bsl::false_type  allowed);

    /// Return to the specified allocator the block raw memory at the
    /// specified `p` address having the specified `nbytes` size and
    /// optionally specified `alignment`.  The behavior is undefined unless
    /// `p` refers to a block having the same size and alignment previously
    /// allocated from a copy of `allocator` and not yet deallocated.
    template <class t_ALLOCATOR>
    static void deallocateBytes(
        const t_ALLOCATOR&                                       allocator,
        typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer p,
        std::size_t                                              nbytes,
        std::size_t                                              alignment
                                                            = k_MAX_ALIGNMENT);

    /// Return to the specified `allocator` a block of raw memory at the
    /// specified `p` address that is suitably sized and aligned to hold an
    /// object of (templatize parameter) `t_TYPE`.  Optionally specify `n`
    /// for the number of objects; otherwise a single object is assumed.
    /// The behavior is undefined unless `p` refers to a block with the same
    /// type and number of objects previously allocated from a copy of
    /// `allocator` and not yet deallocated.
    template <class t_ALLOCATOR, class t_POINTER>
    static void deallocateObject(const t_ALLOCATOR& allocator,
                                 t_POINTER          p,
                                 std::size_t        n = 1);

    /// Destroy the object at the specified `p` address and return the block
    /// of memory at `p` to the specified `allocator`.  The behavior is
    /// undefined unless `p` refers to a fully constructed object allocated
    /// from a copy of `allocator` and not yet destroyed or deallocated.
    template <class t_ALLOCATOR, class t_POINTER>
    static void deleteObject(const t_ALLOCATOR& allocator, t_POINTER p);

    /// Return an object of (template parameter) `t_TYPE` allocated from the
    /// specified `allocator` and constructed with no arguments except that,
    /// for scoped allocator types such as `bsl::allocator` and
    /// `bsl::polymorphic_allocator`, `allocator` may be passed to the
    /// `t_TYPE` constructor (i.e., if `t_TYPE` is AA).
    template <class t_TYPE, class t_ALLOCATOR>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator);

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_allocatorutil.h
#ifndef BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT
#define BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A
#define BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 0
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 0

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 1
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 1

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 2
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 2

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 3
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 3

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 4
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 4

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 5
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 5

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 6
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 6

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 7
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 7

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 8
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 8

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 9
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 9

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 10
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 10

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 11
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 11

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 12
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11,
                                                             class t_ARGS_12>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 12

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 13
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11,
                                                             class t_ARGS_12,
                                                             class t_ARGS_13>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_13) arguments_13);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 13

# endif

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 0
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 0

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 1
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 1

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 2
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 2

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 3
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 3

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 4
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 4

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 5
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 5

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 6
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 6

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 7
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 7

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 8
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 8

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 9
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 9

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 10
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 10

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 11
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 11

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 12
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11,
                                                             class t_ARGS_12>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 12

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 13
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11,
                                                             class t_ARGS_12,
                                                             class t_ARGS_13>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_13) arguments_13);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class... t_ARGS>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS)... arguments);
# endif

    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class... t_ARGS>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS)... arguments);
// }}} END GENERATED CODE
#endif

    /// If the specified `allowed` tag is `bsl::true_type`, swap the values
    /// of allocators at the specified `pa` and `pb` addresses using ADL
    /// swap (with `std::swap` in scope); otherwise, do nothing.  The
    /// `t_TYPE` template parameter is typically an allocator type and the
    /// `allowed` flag is typically a propagation trait dependant on the
    /// calling context, such as `propagate_on_container_swap`.
    /// Instantiation will fail if `allowed` is `false_type` and `t_TYPE` is
    /// not swappable (i.e., because it lacks a publically available
    /// assignment operator).  The behavior is undefined unless `allowed` is
    /// `true_type` or '*pa ==
    /// *pb' before the call.
    template <class t_TYPE>
    static void swap(t_TYPE *pa, t_TYPE *pb, bsl::false_type allowed);
    template <class t_TYPE>
    static void swap(t_TYPE *pa, t_TYPE *pb, bsl::true_type  allowed);
};

// ============================================================================
//                TEMPLATE AND INLINE FUNCTION IMPLEMENTATIONS
// ============================================================================

                    // --------------------------
                    // class AllocatorUtil_Traits
                    // --------------------------

/// Extend the notion of `allocator_traits` to apply to both standard
/// allocator and to pointer-to-memory-resource types.  If the (template
/// parameter) `t_ALLOCATOR` is a non-pointer type (i.e., an allocator
/// class), then inherits from
/// `bsl::allocator_traits<t_ALLOCATOR>::rebind_traits<t_TYPE>`.  However,
/// if `t_ALLOCATOR` is a pointer type, then inherits from
/// `bsl::allocator_traits<bsl::allocator<t_TYPE>>` for pointers to classes
/// derived from `bslma::Allocator` and from
/// `bsl::allocator_traits<bsl::polymorphic_allocator<t_TYPE>>` for pointers
/// to other classes derived from `bsl::memory_resource`.  This primary
/// template is for non-pointer `t_ALLOCATOR` template arguments.
template <class t_ALLOCATOR, class t_TYPE>
struct AllocatorUtil_Traits
    : bsl::allocator_traits<t_ALLOCATOR>::template rebind_traits<t_TYPE> {

    BSLMF_ASSERT(! bsl::is_const<t_TYPE>::value);
    BSLMF_ASSERT(! bsl::is_volatile<t_TYPE>::value);
};

/// This specialization is for allocators expressed as a pointer to class
/// derived from `bsl::memory_resource`.  The base class will be
/// `bsl::allocator_traits<bsl::allocator<t_TYPE>>` if `t_MEMORY_RSRC` is
/// derived from `bsl::Allocator`; otherwise the base class will be
/// `bsl::allocator_traits<bsl::polymorphic_allocator<t_TYPE>>`.
template <class t_MEMORY_RSRC, class t_TYPE>
struct AllocatorUtil_Traits<t_MEMORY_RSRC *, t_TYPE> : bsl::allocator_traits<
    typename bsl::conditional<
            bsl::is_convertible<t_MEMORY_RSRC *, bslma::Allocator *>::value,
            bsl::allocator<t_TYPE>,
            bsl::polymorphic_allocator<t_TYPE> >::type
    >
{

    // MANDATES
    BSLMF_ASSERT((bsl::is_convertible<t_MEMORY_RSRC *,
                                      bsl::memory_resource *>::value));
    BSLMF_ASSERT(! bsl::is_const<t_TYPE>::value);
    BSLMF_ASSERT(! bsl::is_volatile<t_TYPE>::value);
};

                        // -------------------
                        // class AllocatorUtil
                        // -------------------

// PRIVATE CLASS METHODS
template <class t_TYPE>
inline
void *AllocatorUtil::allocateBytesImp(
                       const bsl::polymorphic_allocator<t_TYPE>& allocator,
                       std::size_t                               nbytes,
                       std::size_t                               alignment)
{
    return allocator.resource()->allocate(nbytes, alignment);
}

template <class t_TYPE>
inline
void *AllocatorUtil::allocateBytesImp(const bsl::allocator<t_TYPE>& allocator,
                                      std::size_t                   nbytes,
                                      std::size_t                   alignment)
{
    return allocator.resource()->allocate(nbytes, alignment);
}

template <class t_ALLOCATOR>
typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer
AllocatorUtil::allocateBytesImp(const t_ALLOCATOR& allocator,
                                std::size_t        nbytes,
                                std::size_t        alignment)
{
    BSLMF_ASSERT(4 <= k_MAX_ALIGNMENT && k_MAX_ALIGNMENT <= 32);

    static const int k_8  = k_MAX_ALIGNMENT <  8 ? k_MAX_ALIGNMENT :  8;
    static const int k_16 = k_MAX_ALIGNMENT < 16 ? k_MAX_ALIGNMENT : 16;

    typedef typename bsls::AlignmentToType<  1>::Type             AlignType1;
    typedef typename bsls::AlignmentToType<  2>::Type             AlignType2;
    typedef typename bsls::AlignmentToType<  4>::Type             AlignType4;
    typedef typename bsls::AlignmentToType<k_8>::Type             AlignType8;
    typedef typename bsls::AlignmentToType<k_16>::Type            AlignType16;
    typedef typename bsls::AlignmentToType<k_MAX_ALIGNMENT>::Type AlignTypeMax;

    if (alignment > k_MAX_ALIGNMENT) {
        alignment = k_MAX_ALIGNMENT;
    }

    std::size_t n = (nbytes + alignment - 1) / alignment;

    switch (alignment) {
      case  1: return allocateObject<AlignType1  >(allocator, n);
      case  2: return allocateObject<AlignType2  >(allocator, n);
      case  4: return allocateObject<AlignType4  >(allocator, n);
      case  8: return allocateObject<AlignType8  >(allocator, n);
      case 16: return allocateObject<AlignType16 >(allocator, n);
      default: return allocateObject<AlignTypeMax>(allocator, n);
    }
}

template <class t_TYPE>
inline
void AllocatorUtil::deallocateBytesImp(
                          const bsl::polymorphic_allocator<t_TYPE>&  allocator,
                          void                                      *p,
                          std::size_t                                nbytes,
                          std::size_t                                alignment)
{
    return allocator.resource()->deallocate(p, nbytes, alignment);
}

template <class t_TYPE>
inline
void AllocatorUtil::deallocateBytesImp(
                                      const bsl::allocator<t_TYPE>&  allocator,
                                      void                          *p,
                                      std::size_t                    nbytes,
                                      std::size_t                    alignment)
{
    return allocator.resource()->deallocate(p, nbytes, alignment);
}

template <class t_ALLOCATOR>
void AllocatorUtil::deallocateBytesImp(
    const t_ALLOCATOR&                                       allocator,
    typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer p,
    std::size_t                                              nbytes,
    std::size_t                                              alignment)
{
    BSLMF_ASSERT(4 <= k_MAX_ALIGNMENT && k_MAX_ALIGNMENT <= 32);

    static const int k_8  = k_MAX_ALIGNMENT <  8 ? k_MAX_ALIGNMENT :  8;
    static const int k_16 = k_MAX_ALIGNMENT < 16 ? k_MAX_ALIGNMENT : 16;

    typedef typename bsls::AlignmentToType<  1>::Type             AlignType1;
    typedef typename bsls::AlignmentToType<  2>::Type             AlignType2;
    typedef typename bsls::AlignmentToType<  4>::Type             AlignType4;
    typedef typename bsls::AlignmentToType<k_8>::Type             AlignType8;
    typedef typename bsls::AlignmentToType<k_16>::Type            AlignType16;
    typedef typename bsls::AlignmentToType<k_MAX_ALIGNMENT>::Type AlignTypeMax;

    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType1  >::pointer Ptr1;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType2  >::pointer Ptr2;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType4  >::pointer Ptr4;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType8  >::pointer Ptr8;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType16 >::pointer Ptr16;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignTypeMax>::pointer PtrMax;

    if (alignment > k_MAX_ALIGNMENT) {
        alignment = k_MAX_ALIGNMENT;
    }

    std::size_t n = (nbytes + alignment - 1) / alignment;

    switch (alignment) {
      case  1: deallocateObject(allocator, static_cast<Ptr1  >(p), n); break;
      case  2: deallocateObject(allocator, static_cast<Ptr2  >(p), n); break;
      case  4: deallocateObject(allocator, static_cast<Ptr4  >(p), n); break;
      case  8: deallocateObject(allocator, static_cast<Ptr8  >(p), n); break;
      case 16: deallocateObject(allocator, static_cast<Ptr16 >(p), n); break;
      default: deallocateObject(allocator, static_cast<PtrMax>(p), n); break;
    }
}

template <class t_ALLOCATOR, class t_POINTER, class t_VALUE_TYPE>
inline
void AllocatorUtil::deallocateObjectImp(const t_ALLOCATOR&  allocator,
                                        t_POINTER           p,
                                        std::size_t         n,
                                        const t_VALUE_TYPE& )
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_VALUE_TYPE> Traits;

    BSLMF_ASSERT((bsl::is_same<t_POINTER, typename Traits::pointer>::value));

    typename Traits::allocator_type reboundAlloc(allocator);
    reboundAlloc.deallocate(p, n);
}

template <class t_ALLOCATOR, class t_POINTER, class t_VALUE_TYPE>
inline
void AllocatorUtil::deleteObjectImp(const t_ALLOCATOR&  allocator,
                                    t_POINTER           p,
                                    const t_VALUE_TYPE& )
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_VALUE_TYPE> Traits;

    BSLMF_ASSERT((bsl::is_same<t_POINTER, typename Traits::pointer>::value));

    typename Traits::allocator_type reboundAlloc(allocator);
    Traits::destroy(reboundAlloc, BSLS_UTIL_ADDRESSOF(*p));
    reboundAlloc.deallocate(p, 1);
}

inline
bool AllocatorUtil::isPowerOf2(std::size_t alignment)
{
    return (0 < alignment) && (0 == (alignment & (alignment - 1)));
}


// CLASS METHODS
template <class t_ALLOC>
inline
typename bsl::enable_if<
        ! AllocatorUtil::IsDerivedFromBslAllocator<t_ALLOC>::value,
        t_ALLOC>::type
AllocatorUtil::adapt(const t_ALLOC& from)
{
    return from;
}

template <class t_TYPE>
inline
bslma::Allocator *AllocatorUtil::adapt(const bsl::allocator<t_TYPE>& from)
{
    return from.mechanism();
}

template <class t_ALLOCATOR>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer
AllocatorUtil::allocateBytes(const t_ALLOCATOR& allocator,
                             std::size_t        nbytes,
                             std::size_t        alignment)
{
    BSLS_ASSERT(isPowerOf2(alignment));

    typedef
        typename AllocatorUtil_Traits<t_ALLOCATOR>::allocator_type StdAlloc;
    return allocateBytesImp(StdAlloc(allocator), nbytes, alignment);
}

template <class t_TYPE, class t_ALLOCATOR>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::allocateObject(const t_ALLOCATOR& allocator, std::size_t n)
{
    typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::allocator_type
        reboundAlloc(allocator);
    return reboundAlloc.allocate(n);
}

template <class t_TYPE>
inline
t_TYPE& AllocatorUtil::assign(t_TYPE *lhs, const t_TYPE& rhs, bsl::false_type)
{
    BSLS_ASSERT(*lhs == rhs);
    (void)rhs;
    return *lhs;
}

template <class t_TYPE>
inline
t_TYPE& AllocatorUtil::assign(t_TYPE *lhs, const t_TYPE& rhs, bsl::true_type)
{
    *lhs = rhs;
    return *lhs;
}

template <class t_ALLOCATOR>
inline
void AllocatorUtil::deallocateBytes(
    const t_ALLOCATOR&                                       allocator,
    typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer p,
    std::size_t                                              nbytes,
    std::size_t                                              alignment)
{
    BSLS_ASSERT(isPowerOf2(alignment));

    typedef
        typename AllocatorUtil_Traits<t_ALLOCATOR>::allocator_type StdAlloc;
    deallocateBytesImp(StdAlloc(allocator), p, nbytes, alignment);
}

template <class t_ALLOCATOR, class t_POINTER>
inline
void AllocatorUtil::deallocateObject(const t_ALLOCATOR& allocator,
                                     t_POINTER          p,
                                     std::size_t        n)
{
    BSLS_ASSERT(t_POINTER() != p);
    deallocateObjectImp(allocator, p, n, *p);
}

template <class t_ALLOCATOR, class t_POINTER>
inline void
AllocatorUtil::deleteObject(const t_ALLOCATOR& allocator, t_POINTER p)
{
    BSLS_ASSERT(t_POINTER() != p);
    deleteObjectImp(allocator, p, *p);
}

template <class t_TYPE, class t_ALLOCATOR>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    // Use a 'try' block because the proctor components are at a higher
    // dependency level than this component.  As there is only one possibly
    // throwing statement, correctness of the 'try' block is easily verified.
    BSLS_TRY {
        Traits::construct(reboundAlloc, BSLS_UTIL_ADDRESSOF(*p));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_allocatorutil.h
#ifndef BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT
#define BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B
#define BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 0
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1);
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 1
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 2
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 3
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 4
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 5
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 6
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 7
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 8
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 9
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 10
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 11
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 12
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11,
                                                         class t_ARGS_12>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_12, arguments_12));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 13
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11,
                                                         class t_ARGS_12,
                                                         class t_ARGS_13>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_13) arguments_13)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_12, arguments_12),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_13, arguments_13));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 13

# endif

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 0
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 1
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 2
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 3
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 4
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 5
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 6
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 7
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 8
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 9
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 10
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 11
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 12
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11,
                                                         class t_ARGS_12>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_12, arguments_12));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 13
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11,
                                                         class t_ARGS_12,
                                                         class t_ARGS_13>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_13) arguments_13)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_12, arguments_12),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_13, arguments_13));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class... t_ARGS>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS)... arguments)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                          BSLS_COMPILERFEATURES_FORWARD(t_ARGS, arguments)...);
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
# endif

template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class... t_ARGS>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS)... arguments)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARGS, arguments)...);
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
// }}} END GENERATED CODE
#endif

template <class t_TYPE>
inline
void AllocatorUtil::swap(t_TYPE *pa, t_TYPE *pb, bsl::false_type)
{
    BSLS_ASSERT(*pa == *pb);
    (void)pa; (void)pb;
}

template <class t_TYPE>
inline
void AllocatorUtil::swap(t_TYPE *pa, t_TYPE *pb, bsl::true_type)
{
    using std::swap;
    swap(*pa, *pb);
}

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLMA_ALLOCATORUTIL_H)
# error Not valid except when included from bslma_allocatorutil.h
#endif // ! defined(COMPILING_BSLMA_ALLOCATORUTIL_H)

#endif // ! defined(INCLUDED_BSLMA_ALLOCATORUTIL_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2022 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
