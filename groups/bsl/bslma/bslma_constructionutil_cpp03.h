// bslma_constructionutil_cpp03.h                                     -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMA_CONSTRUCTIONUTIL_CPP03
#define INCLUDED_BSLMA_CONSTRUCTIONUTIL_CPP03

//@PURPOSE: Provide C++03 implementation for bslma_constructionutil.h
//
//@CLASSES: See bslma_constructionutil.h for list of classes
//
//@SEE_ALSO: bslma_constructionutil
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Sun Sep  1 05:38:38 2024
// Command line: sim_cpp11_features.pl bslma_constructionutil.h

#ifdef COMPILING_BSLMA_CONSTRUCTIONUTIL_H

namespace BloombergLP {
namespace bslma {

// Workaround for optimization issue in xlC that mishandles pointer aliasing.
//   IV56864: ALIASING BEHAVIOUR FOR PLACEMENT NEW
//   http://www-01.ibm.com/support/docview.wss?uid=swg1IV56864
// Place this macro following each use of placement new.  Alternatively,
// compile with xlC_r -qalias=noansi, which reduces optimization opportunities
// across entire translation unit instead of simply across optimization fence.
// Update: issue is fixed in xlC 13.1 (__xlC__ >= 0x0d01).

#if defined(BSLS_PLATFORM_CMP_IBM) && BSLS_PLATFORM_CMP_VERSION < 0x0d01
    #define BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX                     \
                             BSLS_PERFORMANCEHINT_OPTIMIZATION_FENCE
#else
    #define BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX
#endif

struct ConstructionUtil_Imp;

                          // =======================
                          // struct ConstructionUtil
                          // =======================

/// This `struct` provides a namespace for utility functions that construct
/// elements of (a template parameter) `TARGET_TYPE`.
struct ConstructionUtil {

  private:
    // PRIVATE TYPES

    /// This `typedef` is a convenient alias for the implementation-specific
    /// utility class defined in this component.
    typedef ConstructionUtil_Imp Imp;

  public:
    // CLASS METHODS

    /// Create a default-constructed object of (template parameter)
    /// `TARGET_TYPE` at the specified `address`.  If `allocator` is a
    /// `bslma`-compatible allocator and `TARGET_TYPE` supports
    /// `bslma`-style allocation, `allocator` is passed to the default
    /// extended constructor; otherwise, `allocator` is ignored.  If the
    /// constructor throws, the memory at `address` is left in an
    /// unspecified state.  The behavior is undefined unless `address`
    /// refers to a block that is of sufficient size and properly aligned
    /// for objects of `TARGET_TYPE`.
    template <class TARGET_TYPE, class ALLOCATOR>
    static void construct(TARGET_TYPE *address, const ALLOCATOR& allocator);

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 13

# endif

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static void construct(TARGET_TYPE             *address,
                          const ALLOCATOR&         allocator,
                          ARG1&                    argument1,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
# endif

    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static void construct(TARGET_TYPE                             *address,
                          const ALLOCATOR&                         allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1)  argument1,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
// }}} END GENERATED CODE
#endif

    /// Create an object of (template parameter) `TARGET_TYPE` at the
    /// specified `address` by moving from the specified `original` object,
    /// then destroy `original`.  The specified `allocator` is unused
    /// (except possibly in precondition checks).  The constructed object
    /// will have the same allocator (if any) as `original`.  If
    /// `bslmf::IsBitwiseMoveable<TARGET_TYPE>::value` is `true`, then the
    /// entire operation is a simple `memcpy` -- no constructors or
    /// destructors are invoked; otherwise, this method move-constructs an
    /// object at `address` from the object at `original` then invokes the
    /// destructor on `original`.  If the move constructor throws an
    /// exception, the memory at `address` is left in an uninitialized state
    /// and `original` is left in a valid but unspecified state.  The
    /// behavior is undefined if `original` uses an allocator other than
    /// `allocator` to supply memory.  Note that if `original` points to an
    /// object of a type derived from `TARGET_TYPE` (i.e., a slicing move)
    /// where `TARGET_TYPE` has a non-`virtual` destructor, then `original`
    /// will be only partially destroyed.
    template <class TARGET_TYPE, class ALLOCATOR>
    static void destructiveMove(TARGET_TYPE      *address,
                                const ALLOCATOR&  allocator,
                                TARGET_TYPE      *original);

#if defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
    /// Return, by value, an object of the specified (template parameter)
    /// `TARGET_TYPE`, having default value.  If `allocator` is a
    /// `bslma`-compatible allocator and `TARGET_TYPE` supports
    /// `bslma`-style allocation, `allocator` is passed to the extended
    /// default constructor; otherwise, `allocator` is ignored.  Note that
    /// this method is available only for compilers that reliably implement
    /// copy/move elision (i.e., RVO) on the returned object.  This
    /// copy/move elision is required starting with C++17 and is widely
    /// implemented, though optional, prior to C++17.
    template <class TARGET_TYPE, class ALLOCATOR>
    static TARGET_TYPE make(const ALLOCATOR& allocator);

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13

# endif

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static TARGET_TYPE make(const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
# endif

    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static TARGET_TYPE make(const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
// }}} END GENERATED CODE
#endif
#endif // defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
};

                        // ===========================
                        // struct ConstructionUtil_Imp
                        // ===========================

/// This `struct` provides a namespace for a suite of utility functions that
/// are used to implement functions in `ConstructionUtil`.  In particular,
/// they provide overloads, resolved at compile-time, for various features
/// (e.g., passing down the allocator to sub-elements of `pair`-like types)
/// and optimizations (e.g., bypassing the call to the constructor for
/// classes with trivial default and copy constructors).  These functions
/// should not be used outside this component.
struct ConstructionUtil_Imp {

    // TYPES
    enum {
        // These constants are used in the overloads below, when the last
        // argument is of type 'bsl::integral_constant<int, N> *', indicating
        // that 'TARGET_TYPE' has the traits for which the enumerator equal to
        // 'N' is named.

        e_NIL_TRAITS                 ,
        e_BITWISE_MOVABLE_TRAITS     ,
        e_USES_ALLOCATOR_TRAITS      ,
        e_USES_ALLOCATOR_ARG_T_TRAITS   // Implies USES_ALLOCATOR
    };

    // CLASS METHODS

    /// Construct a default instance of (template parameter) `TARGET_TYPE`
    /// at the specified `address`, passing to the constructor the specified
    /// `allocator` using the leading or trailing allocator convention,
    /// according to the specified `integral_constant` tag, or ignoring
    /// `allocator` in the `e_NIL_TRAITS` case.  If the constructor throws,
    /// the memory at `address` is left in an unspecified state.
    template <class TARGET_TYPE, class ALLOCATOR>
    static void construct(
             TARGET_TYPE      *address,
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>);
    template <class TARGET_TYPE, class ALLOCATOR>
    static void construct(
             TARGET_TYPE      *address,
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>);
    template <class TARGET_TYPE, class ALLOCATOR>
    static void construct(
             TARGET_TYPE      *address,
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>);

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13

# endif

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static void construct(
             TARGET_TYPE             *address,
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
# endif

    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static void construct(
             TARGET_TYPE                            *address,
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
// }}} END GENERATED CODE
#endif

    /// Move the bitwise movable object of (template parameter)
    /// `TARGET_TYPE` at the specified `original` address to the specified
    /// `address`, eliding the call to the move constructor and destructor
    /// in favor of performing a bitwise copy.  The specified `allocator`
    /// argument is ignored (except possibly for precondition checks).  The
    /// behavior is undefined if `original` uses an allocator other than
    /// `allocator` to supply memory.
    template <class TARGET_TYPE, class ALLOCATOR>
    static void destructiveMove(
              TARGET_TYPE                                           *address,
              const ALLOCATOR&                                       allocator,
              bsl::integral_constant<int, e_BITWISE_MOVABLE_TRAITS>  ,
              TARGET_TYPE                                           *original);

    /// Create an object of (template parameter) `TARGET_TYPE` at the
    /// specified `address` by move construction from the specified
    /// `original` object, then destroy `original`.  The specified
    /// `allocator` is unused (except possibly in precondition checks).  The
    /// constructed object will have the same allocator (if any) as
    /// `original`.  If the move constructor throws an exception, the memory
    /// at `address` is left in an uninitialized state and `original` is
    /// left in a valid but unspecified state.  The behavior is undefined if
    /// `original` uses an allocator other than `allocator` to supply
    /// memory.  Note that, if `original` points to an object of a type
    /// derived from `TARGET_TYPE` (i.e., a slicing move) where
    /// `TARGET_TYPE` has a non-`virtual` destructor, then `original` will
    /// be only partially destroyed.
    template <class TARGET_TYPE, class ALLOCATOR>
    static void destructiveMove(
                          TARGET_TYPE                               *address,
                          const ALLOCATOR&                           allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS>  ,
                          TARGET_TYPE                               *original);

#if defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
    /// Return, by value, a default-constructed object of (template
    /// parameter) `TARGET_TYPE`, passing the specified `allocator` to the
    /// constructor using the leading or trailing allocator convention,
    /// according to the specified `integral_constant` tag, or ignoring
    /// `allocator` in the `e_NIL_TRAITS` case.
    template <class TARGET_TYPE, class ALLOCATOR>
    static TARGET_TYPE make(
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>);
    template <class TARGET_TYPE, class ALLOCATOR>
    static TARGET_TYPE make(
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>);
    template <class TARGET_TYPE, class ALLOCATOR>
    static TARGET_TYPE make(
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>);

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

# endif

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                              class ARGS_02,
                                                              class ARGS_03,
                                                              class ARGS_04,
                                                              class ARGS_05,
                                                              class ARGS_06,
                                                              class ARGS_07,
                                                              class ARGS_08,
                                                              class ARGS_09,
                                                              class ARGS_10,
                                                              class ARGS_11,
                                                              class ARGS_12,
                                                              class ARGS_13>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static TARGET_TYPE make(
             const ALLOCATOR&         allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             ARG1&                    argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
# endif

    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
    static TARGET_TYPE make(
             const ALLOCATOR&                        allocator,
             bsl::integral_constant<int, e_NIL_TRAITS>,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
             BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);

// }}} END GENERATED CODE
#endif
#endif // defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)

    /// Return the specified `address` cast as a pointer to `void`, even if
    /// the (template parameter) `TARGET_TYPE` is cv-qualified.
    template <class TARGET_TYPE>
    static void *voidify(TARGET_TYPE *address);
};

// ============================================================================
//                      TEMPLATE IMPLEMENTATIONS
// ============================================================================

              // -----------------------------------------------
              // struct template ConstructionUtil_IsAllocatorPtr
              // -----------------------------------------------

/// Metafunction that inherits from `true_type` if the `ALLOC` type is a
/// pointer to `bslma::Allocator` or a class derived from it and
/// `false_type` otherwise.
template <class ALLOC>
struct ConstructionUtil_IsAllocatorPtr;

/// This primary template is instantiated only for non-pointer type `ALLOC`
/// and always evaluates false.
template <class ALLOC>
struct ConstructionUtil_IsAllocatorPtr : bsl::false_type {
};

/// This partial specialization is for pointer type `ALLOC *` and evaulates
/// true if and only if `ALLOC` is derived from `bslma::Allocator`.
template <class ALLOC>
struct ConstructionUtil_IsAllocatorPtr<ALLOC *>
    : bsl::is_convertible<ALLOC *, bslma::Allocator *>::type {
};

              // ---------------------------------------------------
              // struct template ConstructionUtil_ConstructionTraits
              // ---------------------------------------------------

/// Metafunction yielding one of the following three `value` constants:
///
///: e_USES_ALLOCATOR_ARG_T_TRAITS  `TARGET_TYPE` supports an allocator as
///:                                its second constructor argument, after
///:                                `bsl::allocator_arg`.
///:
///: e_USES_ALLOCATOR_TRAITS        `TARGET_TYPE` supports an allocator as
///:                                its last constructor argument.
///:
///: e_NIL_TRAITS                   `TARGET_TYPE` does not support an
///:                                allocator and/or `ALLOCATOR` is `void*`
///:                                `int`, or any other non-allocator
///:                                scalar.  The allocator argument to
///:                                `construct` will be ignored.
///
/// `ALLOCATOR` is compatible with an AA `TARGET_TYPE` if `ALLOCATOR` is
/// convertible to the allocator type expected by `TARGET_TYPE`'s
/// constructors.  There are three special cases of incompatible `ALLOCATOR`
/// types:
///
/// 1. If `TARGET_TYPE` expects an allocator of type `bslma::Allocator *`
///    this metafunction yields either `e_USES_ALLOCATOR_ARG_T_TRAITS` or
///    `e_USES_ALLOCATOR_TRAITS`, even if `ALLOCATOR` is not compatible with
///    `TARGET_TYPE`.  The `construct` method will attempt to extract the
///    `bslma::Allocator *` from the allocator using its `mechanism`
///    accessor.  If there is no `mechanism` accessor, compilation will
///    fail.
/// 2. Otherwise, if `bslma::UsesBslmaAllocator<TARGET_TYPE>::value` is
///    `true`, this metafunction yields either
///    `e_USES_ALLOCATOR_ARG_T_TRAITS` or `e_USES_ALLOCATOR_TRAITS`, even if
///    `ALLOCATOR` is not compatible with `TARGET_TYPE`, resulting in a
///    compilation error within `construct`.
/// 3. Otherwise, if `ALLOCATOR` is incompatible with `TARGET_TYPE`, then
///    `ALLOCATOR` is ignored and this metafunction yields `e_NIL_TRAITS`,
///    as though `TARGET_TYPE` were not AA.
///
/// The first two special cases allow mixing and matching between
/// `bsl::allocator` and `bslma::Allocator *` in both directions, but will
/// fail for other allocator types.  The failure is desirable to prevent
/// code accidentally passing an incorrect allocator type.
///
/// The third special case is inconsistent with the other two so as to allow
/// third-party classes that use third-party allocators to be treated as
/// non-AA within containers that use BDE allocators.
///
/// This metafunction also yields a `type` of 'bsl::integral_constant<value,
/// int>'.
template <class TARGET_TYPE, class ALLOCATOR>
struct ConstructionUtil_ConstructionTrait {

  private:
    // PRIVATE TYPES
    typedef ConstructionUtil_Imp Imp;

  public:
    // PUBLIC TYPES
    enum {
        value = ((UsesBslmaAllocator<TARGET_TYPE>::value ||
                  bsl::uses_allocator<TARGET_TYPE, ALLOCATOR>::value) &&
                 (bsl::is_class<ALLOCATOR>::value ||
                  ConstructionUtil_IsAllocatorPtr<ALLOCATOR>::value))
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                   ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                   : Imp::e_USES_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };

    typedef bsl::integral_constant<int, value> type;
};


              // -------------------------------------------------
              // struct template ConstructionUtil_AllocAdaptorUtil
              // -------------------------------------------------

template <class TYPE,
          bool HAS_ALLOC_TYPE = HasAllocatorType<TYPE>::value,
          bool IS_BSLMA_AA    = UsesBslmaAllocator<TYPE>::value>
struct ConstructionUtil_AllocAdaptorUtil;

/// This utility class template provides a static `adapt` method that adapts
/// an allocator object to the type expected by `TYPE`.  This primary
/// template is instantiated only for a non-AA `TYPE`; such types do not
/// expect an allocator, so no `adapt` method is defined.
template <class TYPE>
struct ConstructionUtil_AllocAdaptorUtil<TYPE, false, false> {
};

/// This utility class template provides a static `adapt` method that adapts
/// an allocator object to the type expected by `TYPE`.  This partial
/// specialization is instantiated for types that expect an allocator of
/// type `bslma::Allocator *`.
template <class TYPE>
struct ConstructionUtil_AllocAdaptorUtil<TYPE, false, true> {

    /// Return the `bslma::Allocator` pointer held by the specified `a`
    /// object of non-pointer class.  Compilation will fail if type `ALLOC`
    /// does not provide a `mechanism()` accessor returning a pointer to
    /// type convertible to `bslma::Allocator *`.
    template <class ALLOC>
    static bslma::Allocator *adapt(const ALLOC& a) { return a.mechanism(); }

    /// Return the specified `alloc_p` pointer, implicitly converted to
    /// `bslma::Allocator *`.  Compilation will fail unless `ALLOC` is
    /// derived from `bslma::Allocator`.
    template <class ALLOC>
    static bslma::Allocator *adapt(ALLOC *const &alloc_p) { return alloc_p; }
};

/// This utility class template provides a static `adapt` method that adapts
/// an allocator object to the type expected by `TYPE`.  This partial
/// specialization is instantiated for types that expect an allocator of
/// type `TYPE::allocator_type`.
template <class TYPE, bool IS_BSLMA_AA>
struct ConstructionUtil_AllocAdaptorUtil<TYPE, true, IS_BSLMA_AA> {

    /// Return the specified `a` allocator, implicitly converted to
    /// `TYPE::allocator_type`.  Compilation will fail if implicit
    /// conversion to the return type is invalid.
    template <class ALLOC>
    static typename TYPE::allocator_type adapt(const ALLOC& a) { return a; }
};


                          // -----------------------
                          // struct ConstructionUtil
                          // -----------------------

// CLASS METHODS
template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            const ALLOCATOR&  allocator)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address, allocator, Trait());
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1);
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 13

# endif

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_E >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
void
ConstructionUtil::construct(TARGET_TYPE             *address,
                            const ALLOCATOR&         allocator,
                            ARG1&                    argument1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   argument1,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}
# endif

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
void
ConstructionUtil::construct(TARGET_TYPE                            *address,
                            const ALLOCATOR&                        allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    Imp::construct(address,
                   allocator,
                   Trait(),
                   BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}
// }}} END GENERATED CODE
#endif

template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil::destructiveMove(TARGET_TYPE      *address,
                                  const ALLOCATOR&  allocator,
                                  TARGET_TYPE      *original)
{
    BSLS_ASSERT_SAFE(address);
    BSLS_ASSERT_SAFE(original);

    enum {
        k_VALUE = bslmf::IsBitwiseMoveable<TARGET_TYPE>::value
                ? Imp::e_BITWISE_MOVABLE_TRAITS
                : Imp::e_NIL_TRAITS
    };

    Imp::destructiveMove(address,
                         allocator,
                         bsl::integral_constant<int, k_VALUE>(),
                         original);
}

#if defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
// Suppress bde_verify warnings about return-by-value in this region.
// BDE_VERIFY pragma: push
// BDE_VERIFY pragma: -AR01: Type using allocator is returned by value

template <class TARGET_TYPE, class ALLOCATOR>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&  allocator)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(allocator, Trait());
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1);
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 13

# endif

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_F >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&         allocator,
                       ARG1&                    argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          argument1,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}
# endif

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
TARGET_TYPE
ConstructionUtil::make(const ALLOCATOR&                        allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef typename
        ConstructionUtil_ConstructionTrait<TARGET_TYPE, ALLOCATOR>::type Trait;

    return Imp::make<TARGET_TYPE>(
                          allocator,
                          Trait(),
                          BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}
// }}} END GENERATED CODE
#endif

// BDE_VERIFY pragma: pop
#endif // defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)

                       // ---------------------------
                       // struct ConstructionUtil_Imp
                       // ---------------------------

// CLASS METHODS
template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil_Imp::construct(
             TARGET_TYPE      *address,
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(bsl::allocator_arg,
                                         AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil_Imp::construct(
             TARGET_TYPE      *address,
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil_Imp::construct(
             TARGET_TYPE      *address,
             const ALLOCATOR&  ,
             bsl::integral_constant<int, e_NIL_TRAITS>)
{
    ::new (voidify(address)) TARGET_TYPE();
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13

# endif

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13),
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_G >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...,
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE             *address,
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    ::new (voidify(address)) TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
# endif

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...,
        AllocUtil::adapt(allocator));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                            *address,
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    ::new (voidify(address)) TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
// }}} END GENERATED CODE
#endif

template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil_Imp::destructiveMove(
               TARGET_TYPE                                           *address,
               const ALLOCATOR&                                       ,
               bsl::integral_constant<int, e_BITWISE_MOVABLE_TRAITS>  ,
               TARGET_TYPE                                           *original)
{
    if (bsl::is_fundamental<TARGET_TYPE>::value ||
        bsl::is_pointer<TARGET_TYPE>::value) {
        ::new (voidify(address)) TARGET_TYPE(*original);
        BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
    }
    else {
        // voidify(address) is used here to suppress compiler warning
        // "-Wclass-memaccess".
        memcpy(voidify(address), original, sizeof *original);
    }
}

template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil_Imp::destructiveMove(
                          TARGET_TYPE                               *address,
                          const ALLOCATOR&                           allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS>  ,
                          TARGET_TYPE                               *original)
{
    // TBD: Eventually, we can add a precondition that 'allocator' matches
    // 'original''s allocator, but that is not universally detectable right
    // now, as not all allocator-aware types provide an 'allocator()' method.
    //..
    // BSLS_ASSERT(allocator == original->allocator());

    ConstructionUtil::construct(address,
                                allocator,
                                bslmf::MovableRefUtil::move(*original));
    DestructionUtil::destroy(original);
}

#if defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
// Suppress bde_verify warnings about return-by-value in this region.
// BDE_VERIFY pragma: push
// BDE_VERIFY pragma: -AR01: Type using allocator is returned by value

template <class TARGET_TYPE, class ALLOCATOR>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(bsl::allocator_arg, AllocUtil::adapt(allocator));
}

template <class TARGET_TYPE, class ALLOCATOR>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
             const ALLOCATOR&  allocator,
             bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(AllocUtil::adapt(allocator));
}

template <class TARGET_TYPE, class ALLOCATOR>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
             const ALLOCATOR&  ,
             bsl::integral_constant<int, e_NIL_TRAITS>)
{
    return TARGET_TYPE();
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1);
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1)
{
    return TARGET_TYPE(
        argument1);
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13

# endif

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13),
        AllocUtil::adapt(allocator));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0
template <class TARGET_TYPE, class ALLOCATOR, class ARG1>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class ARGS_01,
                                                          class ARGS_02,
                                                          class ARGS_03,
                                                          class ARGS_04,
                                                          class ARGS_05,
                                                          class ARGS_06,
                                                          class ARGS_07,
                                                          class ARGS_08,
                                                          class ARGS_09,
                                                          class ARGS_10,
                                                          class ARGS_11,
                                                          class ARGS_12,
                                                          class ARGS_13>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
        BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_H >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...,
        AllocUtil::adapt(allocator));
}

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&         ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         ARG1&                    argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    return TARGET_TYPE(
        argument1,
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}
# endif

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        bsl::allocator_arg,
        AllocUtil::adapt(allocator),
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    typedef ConstructionUtil_AllocAdaptorUtil<TARGET_TYPE> AllocUtil;
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...,
        AllocUtil::adapt(allocator));
}

template <class TARGET_TYPE, class ALLOCATOR, class ARG1, class... ARGS>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         const ALLOCATOR&                        ,
         bsl::integral_constant<int, e_NIL_TRAITS>,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    return TARGET_TYPE(
        BSLS_COMPILERFEATURES_FORWARD(ARG1, argument1),
        BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}
// }}} END GENERATED CODE
#endif

// BDE_VERIFY pragma: pop
#endif // defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)

template <class TARGET_TYPE>
inline
void *ConstructionUtil_Imp::voidify(TARGET_TYPE *address)
{
    return static_cast<void *>(
            const_cast<typename bsl::remove_cv<TARGET_TYPE>::type *>(address));
}

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLMA_CONSTRUCTIONUTIL_H)
# error Not valid except when included from bslma_constructionutil.h
#endif // ! defined(COMPILING_BSLMA_CONSTRUCTIONUTIL_H)

#endif // ! defined(INCLUDED_BSLMA_CONSTRUCTIONUTIL_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
