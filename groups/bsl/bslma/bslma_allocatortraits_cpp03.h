// bslma_allocatortraits_cpp03.h                                      -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMA_ALLOCATORTRAITS_CPP03
#define INCLUDED_BSLMA_ALLOCATORTRAITS_CPP03

//@PURPOSE: Provide C++03 implementation for bslma_allocatortraits.h
//
//@CLASSES: See bslma_allocatortraits.h for list of classes
//
//@SEE_ALSO: bslma_allocatortraits
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Thu Dec 15 11:14:32 2022
// Command line: sim_cpp11_features.pl bslma_allocatortraits.h

#ifdef COMPILING_BSLMA_ALLOCATORTRAITS_H

#include <limits>

namespace BloombergLP {
namespace bslma {


                      // ================================
                      // AllocatorTraits_HasIsAlwaysEqual
                      // ================================

template <class ALLOC>
struct AllocatorTraits_HasIsAlwaysEqual {
    // This 'struct' template provides a mechanism for determining whether a
    // given (template parameter) 'ALLOCATOR_TYPE' defines a nested alias named
    //'is_always_equal'.  The static boolean member 'value' (nested alias
    // named 'type') is 'true' ('bsl::true_type') if 'ALLOCATOR_TYPE' defines
    // such an alias, and 'false' ('bsl::false_type') otherwise.

  private:
    // PRIVATE TYPES
    typedef struct { char d_a;    } yes_type;
    typedef struct { char d_a[2]; } no_type;

    // PRIVATE CLASS METHODS
    template <class U>
    static yes_type match(typename U::is_always_equal *);
    template <class U>
    static no_type match(...);
        // Return 'yes_type' if the (template parameter) 'TYPE' defines a
        // nested alias named 'is_always_equal', and 'no_type' otherwise.

  public:
    // PUBLIC CLASS DATA
    static const bool value = sizeof(match<ALLOC>(0)) == sizeof(yes_type);

    // PUBLIC TYPES
    typedef bsl::integral_constant<bool, value> type;
};

                       // =============================
                       // AllocatorTraits_IsAlwaysEqual
                       // =============================

template <class ALLOC, bool = AllocatorTraits_HasIsAlwaysEqual<ALLOC>::value>
struct AllocatorTraits_IsAlwaysEqual : public ALLOC::is_always_equal
{
    // This 'struct' template sets the boolean type for the attribute named
    // 'is_always_equal' to the nested type alias in the given (template
    // parameter) 'ALLOC' if 'ALLOC' defines such an alias (i.e., if
    // 'true == AllocatorTraits_HasIsAlwaysEqual<ALLOCATOR_TYPE>::value').
};

template <class ALLOC>
struct AllocatorTraits_IsAlwaysEqual<ALLOC, false>
                                  : public bsl::is_empty<ALLOC>
{
    // This 'struct' template sets the boolean type for the attribute named
    // 'is_always_equal' to 'bsl::is_empty<ALLOC>' if the given (template
    // parameter) 'ALLOC' does not define such an alias (i.e., if
    // 'false == AllocatorTraits_HasIsAlwaysEqual<ALLOCATOR_TYPE>::value').
};

                   // =====================================
                   // AllocatorTraits_HasSelectOnCopyMethod
                   // =====================================

template <class ALLOCATOR_TYPE>
struct AllocatorTraits_HasSelectOnCopyMethod {
    // This 'struct' template provides a mechanism for determining whether a
    // given (template parameter) 'ALLOCATOR_TYPE' defines a 'const' member
    // function named 'select_on_container_copy_construction' that takes no
    // arguments and returns an 'ALLOCATOR_TYPE' object by value.  The static
    // boolean 'value' (nested 'type' alias) is 'true' ('bsl::true_type') if
    // 'ALLOCATOR_TYPE' defines such a method, and 'false' ('bsl::false_type')
    // otherwise.

  private:
    typedef struct { char a;    } yes_type;
    typedef struct { char a[2]; } no_type;

    template <class T, T> struct MatchType { };
        // This 'struct' template provides a mechanism to check if a type
        // matches an instance within a SFINAE context.

    template <class T>
    struct MethodAlias { typedef T (T::*Method)() const; };

    template <class TYPE>
    static yes_type match(MatchType<typename MethodAlias<TYPE>::Method,
                          &TYPE::select_on_container_copy_construction> *);
    template <class TYPE>
    static no_type match(...);
        // Return 'yes_type' if the (template parameter) 'TYPE' defines a const
        // member function named 'select_on_container_copy_construction' taking
        // no arguments and returning a 'TYPE' object by value, and 'no_type'
        // otherwise.

  public:
    static const bool value =
                          sizeof(match<ALLOCATOR_TYPE>(0)) == sizeof(yes_type);
    typedef bsl::integral_constant<bool, value> type;
};

                    // ===================================
                    // AllocatorTraits_HasPropOnCopyAssign
                    // ===================================

template <class ALLOCATOR_TYPE>
struct AllocatorTraits_HasPropOnCopyAssign {
    // This 'struct' template provides a mechanism for determining whether a
    // given (template parameter) 'ALLOCATOR_TYPE' defines a nested alias named
    //'propagate_on_container_copy_assignment'.  The static boolean member
    // 'value' (nested alias named 'type') is 'true' ('bsl::true_type') if
    // 'ALLOCATOR_TYPE' defines such an alias, and 'false' ('bsl::false_type')
    // otherwise.

  private:
    typedef struct { char a;    } yes_type;
    typedef struct { char a[2]; } no_type;

    template <class U>
    static
    yes_type match(typename U::propagate_on_container_copy_assignment *);
    template <class U>
    static no_type match(...);
        // Return 'yes_type' if the (template parameter) 'TYPE' defines a
        // nested alias named 'propagate_on_container_copy_assignment', and
        // 'no_type' otherwise.

  public:
    static const bool value =
                          sizeof(match<ALLOCATOR_TYPE>(0)) == sizeof(yes_type);
    typedef bsl::integral_constant<bool, value> type;
};

                      // ================================
                      // AllocatorTraits_PropOnCopyAssign
                      // ================================

template <class ALLOCATOR_TYPE,
          bool = AllocatorTraits_HasPropOnCopyAssign<ALLOCATOR_TYPE>::value>
struct AllocatorTraits_PropOnCopyAssign : bsl::false_type
{
    // This 'struct' template sets the boolean type for the attribute named
    // 'propagate_on_container_copy_assignment' to 'bsl::false_type' if the
    // given (template parameter) 'ALLOCATOR_TYPE' does not define such an
    // alias (i.e.,
    // 'false == AllocatorTraits_HasPropOnCopyAssign<ALLOCATOR_TYPE>::value').
};

template <class ALLOC>
struct AllocatorTraits_PropOnCopyAssign<ALLOC, true>
                       : public ALLOC::propagate_on_container_copy_assignment
{
    // This 'struct' template sets the boolean type for the attribute named
    // 'propagate_on_container_copy_assignment' to the nested type alias in the
    // given (template parameter) 'ALLOCATOR_TYPE' if 'ALLOCATOR_TYPE' defines
    // such an alias (i.e.,
    // 'true == AllocatorTraits_HasPropOnCopyAssign<ALLOCATOR_TYPE>::value').
};

                    // ===================================
                    // AllocatorTraits_HasPropOnMoveAssign
                    // ===================================

template <class ALLOC>
struct AllocatorTraits_HasPropOnMoveAssign {
    // This 'struct' template provides a mechanism for determining whether a
    // given (template parameter) 'ALLOCATOR_TYPE' defines a nested alias named
    //'propagate_on_container_move_assignment'.  The static boolean member
    // 'value' (nested alias named 'type') is 'true' ('bsl::true_type') if
    // 'ALLOCATOR_TYPE' defines such an alias, and 'false' ('bsl::false_type')
    // otherwise.

  private:
    typedef struct { char a;    } yes_type;
    typedef struct { char a[2]; } no_type;

    template <class U>
    static
    yes_type match(typename U::propagate_on_container_move_assignment *);
    template <class U>
    static no_type match(...);
        // Return 'yes_type' if the (template parameter) 'TYPE' defines a
        // nested alias named 'propagate_on_container_move_assignment', and
        // 'no_type' otherwise.

  public:
    static const bool value = sizeof(match<ALLOC>(0)) == sizeof(yes_type);
    typedef bsl::integral_constant<bool, value> type;
};

                      // ================================
                      // AllocatorTraits_PropOnMoveAssign
                      // ================================

template <class ALLOC,
          bool = AllocatorTraits_HasPropOnMoveAssign<ALLOC>::value>
struct AllocatorTraits_PropOnMoveAssign : bsl::false_type
{
    // This 'struct' template sets the boolean type for the attribute named
    // 'propagate_on_container_move_assignment' to 'bsl::false_type' if the
    // given (template parameter) 'ALLOCATOR_TYPE' does not define such an
    // alias (i.e.,
    // 'false == AllocatorTraits_HasPropOnMoveAssign<ALLOCATOR_TYPE>::value').
};

template <class ALLOC>
struct AllocatorTraits_PropOnMoveAssign<ALLOC, true>
                       : public ALLOC::propagate_on_container_move_assignment
{
    // This 'struct' template sets the boolean type for the attribute named
    // 'propagate_on_container_move_assignment' to the nested type alias in the
    // given (template parameter) 'ALLOCATOR_TYPE' if 'ALLOCATOR_TYPE' defines
    // such an alias (i.e.,
    // 'true == AllocatorTraits_HasPropOnMoveAssign<ALLOCATOR_TYPE>::value').
};

                       // =============================
                       // AllocatorTraits_HasPropOnSwap
                       // =============================

template <class ALLOC>
struct AllocatorTraits_HasPropOnSwap {
    // This 'struct' template provides a mechanism for determining whether a
    // given (template parameter) 'ALLOCATOR_TYPE' defines a nested alias named
    //'propagate_on_container_swap'.  The static boolean member 'value' (nested
    // alias named 'type') is 'true' ('bsl::true_type') if 'ALLOCATOR_TYPE'
    // defines such an alias, and 'false' ('bsl::false_type') otherwise.

  private:
    typedef struct { char a;    } yes_type;
    typedef struct { char a[2]; } no_type;

    template <class U>
    static
    yes_type match(typename U::propagate_on_container_swap *);
    template <class U>
    static no_type match(...);
        // Return 'yes_type' if the (template parameter) 'TYPE' defines a
        // nested alias named 'propagate_on_container_swap', and 'no_type'
        // otherwise.

  public:
    static const bool value = sizeof(match<ALLOC>(0)) == sizeof(yes_type);
    typedef bsl::integral_constant<bool, value> type;
};

                         // ==========================
                         // AllocatorTraits_PropOnSwap
                         // ==========================

template <class ALLOC, bool = AllocatorTraits_HasPropOnSwap<ALLOC>::value>
struct AllocatorTraits_PropOnSwap : bsl::false_type
{
    // This 'struct' template sets the boolean type for the attribute named
    // 'propagate_on_container_swap' to 'bsl::false_type' if the given
    // (template parameter) 'ALLOCATOR_TYPE' does not define such an alias
    // (i.e., 'false == AllocatorTraits_HasPropOnSwap<ALLOCATOR_TYPE>::value').
};

template <class ALLOC>
struct AllocatorTraits_PropOnSwap<ALLOC, true>
                                  : public ALLOC::propagate_on_container_swap
{
    // This 'struct' template sets the boolean type for the attribute named
    // 'propagate_on_container_swap' to the nested type alias in the given
    // (template parameter) 'ALLOCATOR_TYPE' if 'ALLOCATOR_TYPE' defines such
    // an alias (i.e.,
    // 'false == AllocatorTraits_HasPropOnSwap<ALLOCATOR_TYPE>::value').
};

#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE) &&                        \
    defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)

                     // ==================================
                     // AllocatorTraits_HasConstructMethod
                     // ==================================

template <class T, class Return, class... Args>
struct AllocatorTraits_HasConstructMethod {
  private:
    template <class U>
    static auto match(U *) ->
        typename bsl::is_same<decltype(bslmf::Util::declval<U>().construct(
                                             bslmf::Util::declval<Args>()...)),
                              Return>::type;
    template <class>
    static bsl::false_type match(...);

  public:
    typedef decltype(match<T>(0)) type;
    static const bool value = type::value;
};

                      // ================================
                      // AllocatorTraits_HasDestroyMethod
                      // ================================

template <class T, class Return, class... Args>
struct AllocatorTraits_HasDestroyMethod {
  private:
    template <class U>
    static auto match(U *) ->
        typename bsl::is_same<decltype(bslmf::Util::declval<U>().destroy(
                                             bslmf::Util::declval<Args>()...)),
                              Return>::type;
    template <class>
    static bsl::false_type match(...);

  public:
    typedef decltype(match<T>(0)) type;
    static const bool value = type::value;
};

#endif

                        // ===========================
                        // AllocatorTraits_PointerType
                        // ===========================

template <class T, class = void>
struct AllocatorTraits_PointerType {
    typedef typename T::value_type *type;
};


template <class T>
struct AllocatorTraits_PointerType<T, BSLMF_VOIDTYPE(typename T::pointer)> {
    typedef typename T::pointer type;
};

                      // ================================
                      // AllocatorTraits_ConstPointerType
                      // ================================

template <class T, class = void>
struct AllocatorTraits_ConstPointerType {
    typedef const typename T::value_type *type;
        // should be pointer_traits::rebind of template above
};


template <class T>
struct AllocatorTraits_ConstPointerType<
                                   T,
                                   BSLMF_VOIDTYPE(typename T::const_pointer)> {
    typedef typename T::const_pointer type;
};


                      // ===============================
                      // AllocatorTraits_VoidPointerType
                      // ===============================

template <class T, class = void>
struct AllocatorTraits_VoidPointerType {
    typedef void *type;
        // should be pointer_traits::rebind of template above
};


template <class T>
struct AllocatorTraits_VoidPointerType<
                                   T,
                                   BSLMF_VOIDTYPE(typename T::void_pointer)> {
    typedef typename T::void_pointer type;
};

                    // ====================================
                    // AllocatorTraits_ConstVoidPointerType
                    // ====================================

template <class T, class = void>
struct AllocatorTraits_ConstVoidPointerType {
    typedef const void *type;
        // should be pointer_traits::rebind of template above
};


template <class T>
struct AllocatorTraits_ConstVoidPointerType<
                             T,
                             BSLMF_VOIDTYPE(typename T::const_void_pointer)> {
    typedef typename T::const_void_pointer type;
};

                          // ========================
                          // AllocatorTraits_SizeType
                          // ========================

template <class T, class = void>
struct AllocatorTraits_SizeType {
    typedef std::size_t type;
};


template <class T>
struct AllocatorTraits_SizeType<T, BSLMF_VOIDTYPE(typename T::size_type)> {
    typedef typename T::size_type type;
};

                       // ==============================
                       // AllocatorTraits_DifferenceType
                       // ==============================

template <class T, class = void>
struct AllocatorTraits_DifferenceType {
    // should be pointer_traits::rebind of template above
    typedef std::ptrdiff_t type;

};


template <class T>
struct AllocatorTraits_DifferenceType<
                             T,
                             BSLMF_VOIDTYPE(typename T::difference_type)> {
    typedef typename T::difference_type type;
};

                        // ===========================
                        // AllocatorTraits_RebindFront
                        // ===========================

#if defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
template <class T, class U>
struct AllocatorTraits_RebindFront {
    // There shall be no member named 'type' unless T is a class template with
    // only type parameters.
};

template <template <class, class...> class ALLOC,
	  class T,
	  class ...ARGS,
	  class U>
struct AllocatorTraits_RebindFront<ALLOC<T, ARGS...>, U> {
    using type = ALLOC<U, ARGS...>;
};
#else
template <class T, class U>
struct AllocatorTraits_RebindFront {
    // There shall be no member named 'type' unless T is a class template with
    // only type parameters.
};

template <template <class> class ALLOC,
	  class T,
	  class U>
struct AllocatorTraits_RebindFront<ALLOC<T>, U> {
    typedef ALLOC<U> type;
};
#endif

                        // ===========================
                        // AllocatorTraits_RebindAlloc
                        // ===========================

template <class T, class U, class = void>
struct AllocatorTraits_RebindAlloc {
    // should be pointer_traits::rebind of template above
    typedef typename AllocatorTraits_RebindFront<T, U>::type type;

};

template <class T, class U>
struct AllocatorTraits_RebindAlloc<
                      T,
                      U,
                      BSLMF_VOIDTYPE(typename T::template rebind<U>::other)> {
    typedef typename T::template rebind<U>::other type;
};

                        // ===========================
                        // AllocatorTraits_CallMaxSize
                        // ===========================

#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
template <class T, class = void>
struct AllocatorTraits_CallMaxSize {

    // PUBLIC TYPES
    typedef typename AllocatorTraits_SizeType<T>::type SizeType;

    // PUBLIC CLASS METHODS
    static SizeType max_size(const T &)
        // Return the maximum size of the specified (template) parameter 'T'.
        // Also note that this method is defined inline to work around a
        // Windows compiler bug with SFINAE functions.
    {
        return std::numeric_limits<SizeType>::max() /
               sizeof(typename T::value_type);
    }
};

// Due to the dependence on expression SFINAE to detect the presence of a
// 'max_size' member of the allocator, this is only done on more modern
// platforms.
template <class T>
struct AllocatorTraits_CallMaxSize<
    T,
    BSLMF_VOIDTYPE(decltype(bslmf::Util::declval<T>().max_size()))> {

    // PUBLIC TYPES
    typedef typename AllocatorTraits_SizeType<T>::type SizeType;

    // PUBLIC CLASS METHODS
    static SizeType max_size(const T &alloc)
        // Return the maximum size of the specified 'alloc'.  Also note that
        // this method is defined inline to work around a Windows compiler bug
        // with SFINAE functions.
    {
        return alloc.max_size();
    }
};
#endif

} // close namespace bslma
} // close enterprise namespace

namespace bsl {

                           // ======================
                           // class allocator_traits
                           // ======================

template <class ALLOCATOR_TYPE>
struct allocator_traits {
    // This class supports the complete interface of the C++11
    // 'allocator_traits' class template, which provides a uniform mechanism
    // for accessing nested types within, and operations on, any
    // standard-conforming allocator.  A specialization of this class template
    // for 'bsl::allocator' provides support for Bloomberg's 'bslma' allocator
    // model (see the 'bslma_stdallocator' component for more details).  In
    // C++11 compilation environments, the 'construct' methods forward to the
    // allocator's 'construct' method if such a method matching the (variable
    // number of) specified constructor arguments exists; otherwise, the
    // 'construct' method falls back to invoking the constructor of the element
    // type directly.  In C++03 compilation environments, there is no reliable
    // way to detect if the type provide a method that matches a (variable
    // number of) specified arguments; therefore, we require that standard
    // allocator types define 'construct' methods taking a variable number of
    // arguments in those environments.  This implementation is not
    // fully-standard-conforming in that it does not support deduce data types
    // that are not specified in the allocator.

  private:

    typedef typename BloombergLP::bslma::AllocatorTraits_HasSelectOnCopyMethod<
                                    ALLOCATOR_TYPE>::type DelegateSelectMethod;

    static
    ALLOCATOR_TYPE selectOnCopyConstruct(const ALLOCATOR_TYPE& stdAllocator,
                                         true_type);
        // Return the result of invoking the
        // 'select_on_container_copy_construction' method on the specified
        // 'stdAllocator'.

    static
    ALLOCATOR_TYPE selectOnCopyConstruct(const ALLOCATOR_TYPE& stdAllocator,
                                         false_type);
        // Return the specified 'stdAllocator'.  Note that this behavior
        // enforces a default policy of propagating the allocator on copy
        // construction when using a standard allocator.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE) &&                        \
    defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
    template <class ELEMENT_TYPE, class... Args>
    static typename bsl::enable_if<
        BloombergLP::bslma::AllocatorTraits_HasConstructMethod<ALLOCATOR_TYPE,
                                                               void,
                                                               ELEMENT_TYPE *,
                                                               Args...>::value,
        void>::type
    privateConstruct(ALLOCATOR_TYPE&  basicAllocator,
                     ELEMENT_TYPE    *elementAddr,
                     Args&&...        arguments);
    template <class ELEMENT_TYPE, class... Args>
    static typename bsl::enable_if<
        !BloombergLP::bslma::AllocatorTraits_HasConstructMethod<
            ALLOCATOR_TYPE,
            void,
            ELEMENT_TYPE *,
            Args...>::value,
        void>::type
    privateConstruct(ALLOCATOR_TYPE&  basicAllocator,
                     ELEMENT_TYPE    *elementAddr,
                     Args&&...        arguments);
        // Construct an object of (template parameter) type 'ELEMENT_TYPE' at
        // the specified 'elementAddr', either by 1) calling the 'construct'
        // method on 'basicAllocator' with 'elemAddr' and the specified
        // (variable number of) 'arguments' if the (template parameter) type
        // 'ALLOCATOR_TYPE' defines such a method, or 2) forwarding the
        // specified (variable number of) 'arguments' to the constructor of
        // 'ELEMENT_TYPE' directly (and ignoring 'basicAllocator') otherwise.
        // The behavior is undefined unless 'elementAddr' refers to valid,
        // uninitialized storage.

    template <class ELEMENT_TYPE>
    static typename bsl::enable_if<
        BloombergLP::bslma::AllocatorTraits_HasDestroyMethod<
            ALLOCATOR_TYPE,
            void,
            ELEMENT_TYPE *>::value,
        void>::type
    privateDestroy(ALLOCATOR_TYPE& basicAllocator, ELEMENT_TYPE *elementAddr);

    template <class ELEMENT_TYPE>
    static typename bsl::enable_if<
        !BloombergLP::bslma::AllocatorTraits_HasDestroyMethod<
            ALLOCATOR_TYPE,
            void,
            ELEMENT_TYPE *>::value,
        void>::type
    privateDestroy(ALLOCATOR_TYPE& basicAllocator, ELEMENT_TYPE *elementAddr);
        // Destroy the object of (template parameter) type 'ELEMENT_TYPE' at
        // the specified 'elementAddr', either by 1) calling the 'destroy'
        // method on 'basicAllocator' with 'elemAddr' as the sole argument if
        // the (template parameter) type 'ALLOCATOR_TYPE' defines such a
        // method, or 2) calling the destructor directly on 'elementAddr' (and
        // ignoring 'basicAllocator') otherwise.  The behavior is undefined
        // unless 'elementAddr' refers to a valid, constructed object.
#endif

  public:
    // PUBLIC TYPES
    typedef ALLOCATOR_TYPE                            allocator_type;
    typedef typename ALLOCATOR_TYPE::value_type       value_type;

    typedef typename
         BloombergLP::bslma::AllocatorTraits_PointerType<ALLOCATOR_TYPE>::type
	                                              pointer;
    typedef typename
    BloombergLP::bslma::AllocatorTraits_ConstPointerType<ALLOCATOR_TYPE>::type
	                                              const_pointer;
    typedef typename
     BloombergLP::bslma::AllocatorTraits_VoidPointerType<ALLOCATOR_TYPE>::type
	                                              void_pointer;
    typedef typename BloombergLP::bslma::
                    AllocatorTraits_ConstVoidPointerType<ALLOCATOR_TYPE>::type
	                                              const_void_pointer;

    typedef typename
      BloombergLP::bslma::AllocatorTraits_DifferenceType<ALLOCATOR_TYPE>::type
	                                              difference_type;
    typedef typename
	    BloombergLP::bslma::AllocatorTraits_SizeType<ALLOCATOR_TYPE>::type
	                                              size_type;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_ALIAS_TEMPLATES
    template <class ELEMENT_TYPE>
    using rebind_alloc = typename
           BloombergLP::bslma::AllocatorTraits_RebindAlloc<ALLOCATOR_TYPE,
                                                           ELEMENT_TYPE>::type;

    template <class ELEMENT_TYPE>
    using rebind_traits = allocator_traits<rebind_alloc<ELEMENT_TYPE>>;
#else // !BSLS_COMPILERFEATURES_SUPPORT_ALIAS_TEMPLATES
    template <class ELEMENT_TYPE>
    struct rebind_alloc
        : BloombergLP::bslma::AllocatorTraits_RebindAlloc<ALLOCATOR_TYPE,
                                                          ELEMENT_TYPE>::type
    {
        // Note that this class attempts to emulate an alias template, but is
        // not complete.  In general, code that must support C++03 should use
        // 'rebind_traits<ELEMENT_TYPE>::allocator_type' instead of
        // 'rebind_alloc<ELEMENT_TYPE>' because that nested typedef is the
        // preferred actual allocator type and not a subclass of the desired
        // type.

        typedef typename BloombergLP::bslma::
                AllocatorTraits_RebindAlloc<ALLOCATOR_TYPE, ELEMENT_TYPE>::type
	                                                        allocator_type;

        template <typename ARG>
        rebind_alloc(const ARG& allocatorArg)
            // Convert from anything that can be used to cosntruct the base
            // type.  This might be better if SFINAE-ed out using
            // 'is_convertible', but stressing older compilers more seems
            // unwise.
        : allocator_type(allocatorArg)
        {
        }
    };

    template <class ELEMENT_TYPE>
    struct rebind_traits : allocator_traits<typename allocator_traits::template
                                    rebind_alloc<ELEMENT_TYPE>::allocator_type>
    {
    };
#endif // !BSLS_COMPILERFEATURES_SUPPORT_ALIAS_TEMPLATES

    // Allocation functions

    static pointer allocate(ALLOCATOR_TYPE& basicAllocator, size_type n);
        // Return 'basicAllocator.allocate(n)'.

    static pointer allocate(ALLOCATOR_TYPE&    basicAllocator,
                            size_type          n,
                            const_void_pointer hint);
        // Return 'basicAllocator.allocate(n, hint)'.

    static void deallocate(ALLOCATOR_TYPE& basicAllocator,
                           pointer         elementAddr,
                           size_type       n);
        // Invoke 'basicAllocator.deallocate(elementAddr, n)'.  The behavior is
        // undefined unless the specified 'elementAddr' was returned from a
        // prior call to the 'allocate' method of an allocator that compares
        // equal to the specified 'allocator', and has not yet been passed to a
        // 'deallocate' call of such an allocator object.

    // Element creation functions

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_allocatortraits.h
#ifndef BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT
#define BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT 14
#endif
#ifndef BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A
#define BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT
#endif
#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 0
    template <class ELEMENT_TYPE>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 0

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 1
    template <class ELEMENT_TYPE, class Args_01>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 1

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 2
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 2

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 3
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 3

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 4
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 4

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 5
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 5

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 6
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 6

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 7
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 7

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 8
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 8

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 9
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 9

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 10
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 10

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 11
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 11

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 12
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 12

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 13
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 13

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 14
    template <class ELEMENT_TYPE, class Args_01,
                                  class Args_02,
                                  class Args_03,
                                  class Args_04,
                                  class Args_05,
                                  class Args_06,
                                  class Args_07,
                                  class Args_08,
                                  class Args_09,
                                  class Args_10,
                                  class Args_11,
                                  class Args_12,
                                  class Args_13,
                                  class Args_14>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14);
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_A >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class ELEMENT_TYPE, class... Args>
    static void construct(ALLOCATOR_TYPE&  basicAllocator,
                          ELEMENT_TYPE    *elementAddr,
                         BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments);
// }}} END GENERATED CODE
#endif

    template <class ELEMENT_TYPE>
    static void destroy(ALLOCATOR_TYPE&  basicAllocator,
                        ELEMENT_TYPE    *elementAddr);
        // Destroy the object of (template parameter) type 'ELEMENT_TYPE' at
        // the specified 'elementAddr', either by 1) calling the 'destroy'
        // method on 'basicAllocator' with 'elemAddr' as the sole argument if
        // the (template parameter) type 'ALLOCATOR_TYPE' defines such a
        // method, or 2) calling the destructor directly on 'elementAddr' (and
        // ignoring 'basicAllocator') otherwise.  The behavior is undefined
        // unless 'elementAddr' refers to a valid, constructed object.

    static size_type max_size(const ALLOCATOR_TYPE& basicAllocator)
                                                         BSLS_KEYWORD_NOEXCEPT;
        // Return the largest number of 'value_type' objects that could
        // reasonably be returned by a single invocation of 'allocate' for the
        // specified 'allocator', i.e., 'allocator.max_size()'.

    // Allocator propagation traits
    static ALLOCATOR_TYPE
    select_on_container_copy_construction(const ALLOCATOR_TYPE& rhs);
        // Return a copy of the allocator that should be used to copy-
        // construct one container from another container whose allocator is
        // the specified 'rhs'.  If the parameterized 'ALLOCATOR_TYPE' defines
        // a method 'select_on_container_copy_construction', this function
        // returns the result of calling that method on 'rhs'; otherwise, this
        // method enforces the default policy of propagating the allocator on
        // copy construction, as is standard practice for standard allocators
        // (i.e., returns 'rhs').  Note that the specialization of this class
        // template for 'bsl::allocator' (in the 'bslma_stdallocator'
        // component) provides the alternate default behavior of *not*
        // propagating the allocator on copy construction (i.e., returning a
        // default-constructed allocator object).

    typedef typename BloombergLP::bslma::AllocatorTraits_IsAlwaysEqual<
                             ALLOCATOR_TYPE>::type is_always_equal;
        // Identical to, or derived from 'true_type' if two allocators of
        // parameterized 'ALLOCATOR_TYPE' always compare equal; otherwise
        // identical to or derived from 'false_type'.  This type is
        // 'ALLOCATOR_TYPE::is_always_equal' if such a type is defined, and
        // 'is_empty<ALLOCATOR_TYPE>' otherwise.

    typedef typename BloombergLP::bslma::AllocatorTraits_PropOnCopyAssign<
                  ALLOCATOR_TYPE>::type propagate_on_container_copy_assignment;
        // Identical to, or derived from 'true_type' if an allocator of
        // parameterized 'ALLOCATOR_TYPE' should be copied when a container
        // using that 'ALLOCATOR_TYPE' is copy-assigned; otherwise identical to
        // or derived from 'false_type'.  This type is
        // 'ALLOCATOR_TYPE::propagate_on_container_copy_assignment' if such a
        // type is defined, and 'false_type' otherwise.

    typedef typename BloombergLP::bslma::AllocatorTraits_PropOnMoveAssign<
                  ALLOCATOR_TYPE>::type propagate_on_container_move_assignment;
        // Identical to, or derived from 'true_type' if an allocator of
        // parameterized 'ALLOCATOR_TYPE' should be moved when a container
        // using that 'ALLOCATOR_TYPE' is move-assigned; otherwise identical to
        // or derived from 'false_type'.  This type is
        // 'ALLOCATOR_TYPE::propagate_on_container_move_assignment' if such a
        // type is defined, and 'false_type' otherwise.

    typedef typename BloombergLP::bslma::AllocatorTraits_PropOnSwap<
                             ALLOCATOR_TYPE>::type propagate_on_container_swap;
        // Identical to, or derived from 'true_type' if the allocators of
        // parameterized 'ALLOCATOR_TYPE' should be swapped when containers
        // using that 'ALLOCATOR_TYPE' are swapped; otherwise identical to or
        // derived from 'false_type'.  This type is
        // 'ALLOCATOR_TYPE::propagate_on_container_swap' if such a type is
        // defined, and 'false_type' otherwise.
};

                  // ========================================
                  // class allocator_traits<ALLOCATOR_TYPE *>
                  // ========================================

template <class ALLOCATOR_TYPE>
struct allocator_traits<ALLOCATOR_TYPE *> {
    // TBD: improve comment This is an empty class specialization of
    // 'allocator_traits' for pointer types that (intentionally) does not
    // define any of the traits typedefs.  It's needed in order make
    // unambiguous function overloads that take both a standard allocator by
    // value and a 'bslma::Allocator *'.  By using the typedefs defined in
    // 'allocator_traits' in the signature of functions taking standard
    // allocators, we can ensure that those overloads are not considered when
    // using 'bslma'-style allocators.
};

}  // close namespace bsl

// ============================================================================
//          INLINE AND TEMPLATE STATIC MEMBER FUNCTION DEFINITIONS
// ============================================================================


namespace bsl {

                           // ----------------------
                           // class allocator_traits
                           // ----------------------


template <class ALLOCATOR_TYPE>
inline
ALLOCATOR_TYPE allocator_traits<ALLOCATOR_TYPE>::selectOnCopyConstruct(
                                            const ALLOCATOR_TYPE& stdAllocator,
                                            true_type)
{
    return stdAllocator.select_on_container_copy_construction();
}

template <class ALLOCATOR_TYPE>
inline
ALLOCATOR_TYPE allocator_traits<ALLOCATOR_TYPE>::selectOnCopyConstruct(
                                            const ALLOCATOR_TYPE& stdAllocator,
                                            false_type)
{
    return stdAllocator;
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE) &&                        \
    defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class... Args>
inline
typename bsl::enable_if<
    BloombergLP::bslma::AllocatorTraits_HasConstructMethod<ALLOCATOR_TYPE,
                                                           void,
                                                           ELEMENT_TYPE *,
                                                           Args...>::value,
    void>::type
allocator_traits<ALLOCATOR_TYPE>::privateConstruct(
                                               ALLOCATOR_TYPE&  basicAllocator,
                                               ELEMENT_TYPE    *elementAddr,
                                               Args&&...        arguments)
{
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...);
}

template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class... Args>
inline
typename bsl::enable_if<
    !BloombergLP::bslma::AllocatorTraits_HasConstructMethod<ALLOCATOR_TYPE,
                                                            void,
                                                            ELEMENT_TYPE *,
                                                            Args...>::value,
    void>::type
allocator_traits<ALLOCATOR_TYPE>::privateConstruct(ALLOCATOR_TYPE&,
                                                   ELEMENT_TYPE *elementAddr,
                                                   Args&&...     arguments)
{
    ::new (static_cast<void *>(elementAddr))
        ELEMENT_TYPE(BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...);
}

template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE>
inline
typename bsl::enable_if<BloombergLP::bslma::AllocatorTraits_HasDestroyMethod<
                            ALLOCATOR_TYPE,
                            void,
                            ELEMENT_TYPE *>::value,
                        void>::type
allocator_traits<ALLOCATOR_TYPE>::privateDestroy(
                                               ALLOCATOR_TYPE&  basicAllocator,
                                               ELEMENT_TYPE    *elementAddr)
{
    basicAllocator.destroy(elementAddr);
}

template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE>
inline
typename bsl::enable_if<!BloombergLP::bslma::AllocatorTraits_HasDestroyMethod<
                            ALLOCATOR_TYPE,
                            void,
                            ELEMENT_TYPE *>::value,
                        void>::type
allocator_traits<ALLOCATOR_TYPE>::privateDestroy(ALLOCATOR_TYPE&,
                                                 ELEMENT_TYPE *elementAddr)
{
    elementAddr->~ELEMENT_TYPE();
}
#endif

// Allocation functions

template <class ALLOCATOR_TYPE>
inline
typename allocator_traits<ALLOCATOR_TYPE>::pointer
allocator_traits<ALLOCATOR_TYPE>::allocate(ALLOCATOR_TYPE& basicAllocator,
                                           size_type n)
{
    return basicAllocator.allocate(n);
}

template <class ALLOCATOR_TYPE>
inline
typename allocator_traits<ALLOCATOR_TYPE>::pointer
allocator_traits<ALLOCATOR_TYPE>::allocate(ALLOCATOR_TYPE&    basicAllocator,
                                           size_type          n,
                                           const_void_pointer hint)
{
    return basicAllocator.allocate(n, hint);
}

template <class ALLOCATOR_TYPE>
inline
void
allocator_traits<ALLOCATOR_TYPE>::deallocate(ALLOCATOR_TYPE& basicAllocator,
                                             pointer         elementAddr,
                                             size_type       n)
{
    basicAllocator.deallocate(elementAddr, n);
}

// ELEMENT CREATION FUNCTIONS

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_allocatortraits.h
#ifndef BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT
#define BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT 14
#endif
#ifndef BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B
#define BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT
#endif
#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 0
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr);
#else
    basicAllocator.construct(
        elementAddr);
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 0

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 1
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 1

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 2
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 2

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 3
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 3

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 4
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 4

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 5
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 5

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 6
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 6

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 7
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 7

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 8
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 8

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 9
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 9

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 10
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 10

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 11
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                     BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                     BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 11

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 12
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                     BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                     BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                     BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                     BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 12

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 13
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                     BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                     BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                     BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                     BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                     BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                     BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 13

#if BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 14
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class Args_01,
                              class Args_02,
                              class Args_03,
                              class Args_04,
                              class Args_05,
                              class Args_06,
                              class Args_07,
                              class Args_08,
                              class Args_09,
                              class Args_10,
                              class Args_11,
                              class Args_12,
                              class Args_13,
                              class Args_14>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(Args_14) arguments_14)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                     BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                     BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                     BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13),
                     BSLS_COMPILERFEATURES_FORWARD(Args_14, arguments_14));
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args_01, arguments_01),
                     BSLS_COMPILERFEATURES_FORWARD(Args_02, arguments_02),
                     BSLS_COMPILERFEATURES_FORWARD(Args_03, arguments_03),
                     BSLS_COMPILERFEATURES_FORWARD(Args_04, arguments_04),
                     BSLS_COMPILERFEATURES_FORWARD(Args_05, arguments_05),
                     BSLS_COMPILERFEATURES_FORWARD(Args_06, arguments_06),
                     BSLS_COMPILERFEATURES_FORWARD(Args_07, arguments_07),
                     BSLS_COMPILERFEATURES_FORWARD(Args_08, arguments_08),
                     BSLS_COMPILERFEATURES_FORWARD(Args_09, arguments_09),
                     BSLS_COMPILERFEATURES_FORWARD(Args_10, arguments_10),
                     BSLS_COMPILERFEATURES_FORWARD(Args_11, arguments_11),
                     BSLS_COMPILERFEATURES_FORWARD(Args_12, arguments_12),
                     BSLS_COMPILERFEATURES_FORWARD(Args_13, arguments_13),
                     BSLS_COMPILERFEATURES_FORWARD(Args_14, arguments_14));
#endif
}
#endif  // BSLMA_ALLOCATORTRAITS_VARIADIC_LIMIT_B >= 14

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class... Args>
inline
void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  basicAllocator,
                                            ELEMENT_TYPE    *elementAddr,
                          BSLS_COMPILERFEATURES_FORWARD_REF(Args)... arguments)
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    privateConstruct(basicAllocator,
                     elementAddr,
                     BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...);
#else
    basicAllocator.construct(
        elementAddr, BSLS_COMPILERFEATURES_FORWARD(Args, arguments)...);
#endif
}
// }}} END GENERATED CODE
#endif

template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE>
inline
void
allocator_traits<ALLOCATOR_TYPE>::destroy(ALLOCATOR_TYPE& stdAllocator,
                                          ELEMENT_TYPE    *elementAddr)
{
//  For full C++11 compatibility, this should check for the well-formedness of
//  the allocator-specific code that is commented out below (via some SFINAE
//  trickery), and switch to the 'DestructionUtil' implementation only if the
// 'destroy' member function is not available.

//    allocator.destroy(elementAddr);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE) &&                        \
    defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
    privateDestroy(stdAllocator, elementAddr);
#else
    elementAddr->~ELEMENT_TYPE();
    (void) stdAllocator;
#endif
}

template <class ALLOCATOR_TYPE>
inline
typename allocator_traits<ALLOCATOR_TYPE>::size_type
allocator_traits<ALLOCATOR_TYPE>::max_size(
                    const ALLOCATOR_TYPE& basicAllocator) BSLS_KEYWORD_NOEXCEPT
{
#if defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)
    return BloombergLP::bslma::
	 AllocatorTraits_CallMaxSize<ALLOCATOR_TYPE>::max_size(basicAllocator);
#else
    // Cannot sniff out whether 'basicAllocator.max_size()' is valid in C++03,
    // but for now require that allocators have a 'max_size' method and just
    // call it.
    return basicAllocator.max_size();
#endif
}

template <class ALLOCATOR_TYPE>
inline
ALLOCATOR_TYPE
allocator_traits<ALLOCATOR_TYPE>::select_on_container_copy_construction(
                                                     const ALLOCATOR_TYPE& rhs)
{
    return selectOnCopyConstruct(rhs, DelegateSelectMethod());
}

}  // close namespace bsl

#else // if ! defined(DEFINED_BSLMA_ALLOCATORTRAITS_H)
# error Not valid except when included from bslma_allocatortraits.h
#endif // ! defined(COMPILING_BSLMA_ALLOCATORTRAITS_H)

#endif // ! defined(INCLUDED_BSLMA_ALLOCATORTRAITS_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2022 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
