// baetzo_zoneinfobinaryreader.t.cpp                                  -*-C++-*-
#include <baetzo_zoneinfobinaryreader.h>

#include <baetzo_zoneinfobinaryheader.h>
#include <baetzo_zoneinfo.h>

#include <bael_defaultobserver.h>
#include <bael_log.h>
#include <bael_loggermanager.h>
#include <bael_severity.h>

#include <bdesb_fixedmeminstreambuf.h>
#include <bdeut_stringref.h>
#include <bdeut_bigendian.h>

#include <bsl_iostream.h>
#include <bsl_string.h>
#include <bsl_fstream.h>
#include <bsl_cstring.h>
#include <bsl_cstdlib.h>
#include <bsls_byteorder.h>
#include <bsls_types.h>

using namespace BloombergLP;

using bsl::cout;
using bsl::endl;
using bsl::flush;
using bsl::memcpy;
using bsl::memset;
using bsl::memcmp;
using bsl::atoi;
using bsl::exit;

// ============================================================================
//                                  TEST PLAN
// ----------------------------------------------------------------------------
//                                  Overview
//                                  --------
// The 'baetzo_ZoneinfoBinaryReader' component contains a 'read' function to
// read the Zoneinfo binary data format from a byte stream.  A test apparatus
// is created for testing this component.
//
// The test apparatus contains functions to create an arbitrary Zoneinfo binary
// data.  A byte stream can be created from this data and the 'read' function
// can be called on the byte stream to produce a 'baetzo_Zoneinfo' object.  The
// test apparatus contains the 'verifyTimeZone' function to verify the
// resulting 'baetzo_Zoneinfo' object matches the data in the byte stream.
// ---------------------------------------------------------------------------
// CLASS METHODS
// [ 8] read(baetzo_Zoneinfo *, bsl::istream&, bA=0);
// [ 7] read(baetzo_Zoneinfo *, FileDescription *, bsl::istream&, bA=0);
//
// ----------------------------------------------------------------------------
// TEST APPARATUS
// [ 2] CONCERN: Test apparatus functions as documented.
//
// ----------------------------------------------------------------------------
// [ 1] BREATHING TEST
// [11] USAGE EXAMPLE
// [ 3] CONCERN: 'read' properly process the abbreviation strings
// [ 4] CONCERN: 'read' properly process local time types data
// [ 5] CONCERN: 'read' properly process transition data
// [ 6] CONCERN: 'read' retrieve data with multiple transitions
// [ 9] CONCERN: 'read' retrieve a real-life Zoneinfo data
// [10] CONCERN: 'read' fails when header information is invalid
// ----------------------------------------------------------------------------

// ============================================================================
//                      STANDARD BDE ASSERT TEST MACRO
// ----------------------------------------------------------------------------
static int testStatus = 0;

static void aSsErT(int c, const char *s, int i)
{
    if (c) {
        bsl::cout << "Error " << __FILE__ << "(" << i << "): " << s
                  << "    (failed)" << bsl::endl;
        if (0 <= testStatus && testStatus <= 100) ++testStatus;
    }
}

#define ASSERT(X) { aSsErT(!(X), #X, __LINE__); }

// ============================================================================
//                  STANDARD BDE LOOP-ASSERT TEST MACROS
// ----------------------------------------------------------------------------
#define LOOP_ASSERT(I,X) { \
    if (!(X)) { bsl::cout << #I << ": " << I << "\n"; \
                aSsErT(1, #X, __LINE__); }}

#define LOOP2_ASSERT(I,J,X) { \
    if (!(X)) { bsl::cout << #I << ": " << I << "\t"  \
                          << #J << ": " << J << "\n"; \
                aSsErT(1, #X, __LINE__); } }

#define LOOP3_ASSERT(I,J,K,X) { \
   if (!(X)) { bsl::cout << #I << ": " << I << "\t" \
                         << #J << ": " << J << "\t" \
                         << #K << ": " << K << "\n";\
               aSsErT(1, #X, __LINE__); } }

#define LOOP4_ASSERT(I,J,K,L,X) { \
   if (!(X)) { bsl::cout << #I << ": " << I << "\t" \
                         << #J << ": " << J << "\t" \
                         << #K << ": " << K << "\t" \
                         << #L << ": " << L << "\n";\
               aSsErT(1, #X, __LINE__); } }
// ============================================================================
//                  SEMI-STANDARD TEST OUTPUT MACROS
// ----------------------------------------------------------------------------
#define P(X) bsl::cout << #X " = " << (X) << bsl::endl;
                                              // Print identifier and value.
#define Q(X) bsl::cout << "<| " #X " |>" << bsl::endl;
                                              // Quote identifier literally.
#define P_(X) bsl::cout << #X " = " << (X) << ", " << bsl::flush;
                                              // P(X) without '\n'
#define L_ __LINE__                           // current Line number
#define NL "\n"
#define T_ cout << '\t' << flush;

//=============================================================================
//                  GLOBAL TYPEDEFS/CONSTANTS FOR TESTING
//-----------------------------------------------------------------------------

static const bsls_Types::Int64 FIRST_TRANSITION =
              bdetu_Epoch::convertToTimeT64(bdet_Datetime(1, 1, 1));
// DATA
const char NEW_YORK_DATA[] = {
    // Data from America/New_York

    0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xeb,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x9e, 0xa6, 0x1e, 0x70,
    0x9f, 0xba, 0xeb, 0x60, 0xa0, 0x86, 0x00, 0x70, 0xa1, 0x9a, 0xcd, 0x60,
    0xa2, 0x65, 0xe2, 0x70, 0xa3, 0x83, 0xe9, 0xe0, 0xa4, 0x6a, 0xae, 0x70,
    0xa5, 0x35, 0xa7, 0x60, 0xa6, 0x53, 0xca, 0xf0, 0xa7, 0x15, 0x89, 0x60,
    0xa8, 0x33, 0xac, 0xf0, 0xa8, 0xfe, 0xa5, 0xe0, 0xaa, 0x13, 0x8e, 0xf0,
    0xaa, 0xde, 0x87, 0xe0, 0xab, 0xf3, 0x70, 0xf0, 0xac, 0xbe, 0x69, 0xe0,
    0xad, 0xd3, 0x52, 0xf0, 0xae, 0x9e, 0x4b, 0xe0, 0xaf, 0xb3, 0x34, 0xf0,
    0xb0, 0x7e, 0x2d, 0xe0, 0xb1, 0x9c, 0x51, 0x70, 0xb2, 0x67, 0x4a, 0x60,
    0xb3, 0x7c, 0x33, 0x70, 0xb4, 0x47, 0x2c, 0x60, 0xb5, 0x5c, 0x15, 0x70,
    0xb6, 0x27, 0x0e, 0x60, 0xb7, 0x3b, 0xf7, 0x70, 0xb8, 0x06, 0xf0, 0x60,
    0xb9, 0x1b, 0xd9, 0x70, 0xb9, 0xe6, 0xd2, 0x60, 0xbb, 0x04, 0xf5, 0xf0,
    0xbb, 0xc6, 0xb4, 0x60, 0xbc, 0xe4, 0xd7, 0xf0, 0xbd, 0xaf, 0xd0, 0xe0,
    0xbe, 0xc4, 0xb9, 0xf0, 0xbf, 0x8f, 0xb2, 0xe0, 0xc0, 0xa4, 0x9b, 0xf0,
    0xc1, 0x6f, 0x94, 0xe0, 0xc2, 0x84, 0x7d, 0xf0, 0xc3, 0x4f, 0x76, 0xe0,
    0xc4, 0x64, 0x5f, 0xf0, 0xc5, 0x2f, 0x58, 0xe0, 0xc6, 0x4d, 0x7c, 0x70,
    0xc7, 0x0f, 0x3a, 0xe0, 0xc8, 0x2d, 0x5e, 0x70, 0xc8, 0xf8, 0x57, 0x60,
    0xca, 0x0d, 0x40, 0x70, 0xca, 0xd8, 0x39, 0x60, 0xcb, 0x88, 0xf0, 0x70,
    0xd2, 0x23, 0xf4, 0x70, 0xd2, 0x60, 0xfb, 0xe0, 0xd3, 0x75, 0xe4, 0xf0,
    0xd4, 0x40, 0xdd, 0xe0, 0xd5, 0x55, 0xc6, 0xf0, 0xd6, 0x20, 0xbf, 0xe0,
    0xd7, 0x35, 0xa8, 0xf0, 0xd8, 0x00, 0xa1, 0xe0, 0xd9, 0x15, 0x8a, 0xf0,
    0xd9, 0xe0, 0x83, 0xe0, 0xda, 0xfe, 0xa7, 0x70, 0xdb, 0xc0, 0x65, 0xe0,
    0xdc, 0xde, 0x89, 0x70, 0xdd, 0xa9, 0x82, 0x60, 0xde, 0xbe, 0x6b, 0x70,
    0xdf, 0x89, 0x64, 0x60, 0xe0, 0x9e, 0x4d, 0x70, 0xe1, 0x69, 0x46, 0x60,
    0xe2, 0x7e, 0x2f, 0x70, 0xe3, 0x49, 0x28, 0x60, 0xe4, 0x5e, 0x11, 0x70,
    0xe5, 0x57, 0x2e, 0xe0, 0xe6, 0x47, 0x2d, 0xf0, 0xe7, 0x37, 0x10, 0xe0,
    0xe8, 0x27, 0x0f, 0xf0, 0xe9, 0x16, 0xf2, 0xe0, 0xea, 0x06, 0xf1, 0xf0,
    0xea, 0xf6, 0xd4, 0xe0, 0xeb, 0xe6, 0xd3, 0xf0, 0xec, 0xd6, 0xb6, 0xe0,
    0xed, 0xc6, 0xb5, 0xf0, 0xee, 0xbf, 0xd3, 0x60, 0xef, 0xaf, 0xd2, 0x70,
    0xf0, 0x9f, 0xb5, 0x60, 0xf1, 0x8f, 0xb4, 0x70, 0xf2, 0x7f, 0x97, 0x60,
    0xf3, 0x6f, 0x96, 0x70, 0xf4, 0x5f, 0x79, 0x60, 0xf5, 0x4f, 0x78, 0x70,
    0xf6, 0x3f, 0x5b, 0x60, 0xf7, 0x2f, 0x5a, 0x70, 0xf8, 0x28, 0x77, 0xe0,
    0xf9, 0x0f, 0x3c, 0x70, 0xfa, 0x08, 0x59, 0xe0, 0xfa, 0xf8, 0x58, 0xf0,
    0xfb, 0xe8, 0x3b, 0xe0, 0xfc, 0xd8, 0x3a, 0xf0, 0xfd, 0xc8, 0x1d, 0xe0,
    0xfe, 0xb8, 0x1c, 0xf0, 0xff, 0xa7, 0xff, 0xe0, 0x00, 0x97, 0xfe, 0xf0,
    0x01, 0x87, 0xe1, 0xe0, 0x02, 0x77, 0xe0, 0xf0, 0x03, 0x70, 0xfe, 0x60,
    0x04, 0x60, 0xfd, 0x70, 0x05, 0x50, 0xe0, 0x60, 0x06, 0x40, 0xdf, 0x70,
    0x07, 0x30, 0xc2, 0x60, 0x07, 0x8d, 0x19, 0x70, 0x09, 0x10, 0xa4, 0x60,
    0x09, 0xad, 0x94, 0xf0, 0x0a, 0xf0, 0x86, 0x60, 0x0b, 0xe0, 0x85, 0x70,
    0x0c, 0xd9, 0xa2, 0xe0, 0x0d, 0xc0, 0x67, 0x70, 0x0e, 0xb9, 0x84, 0xe0,
    0x0f, 0xa9, 0x83, 0xf0, 0x10, 0x99, 0x66, 0xe0, 0x11, 0x89, 0x65, 0xf0,
    0x12, 0x79, 0x48, 0xe0, 0x13, 0x69, 0x47, 0xf0, 0x14, 0x59, 0x2a, 0xe0,
    0x15, 0x49, 0x29, 0xf0, 0x16, 0x39, 0x0c, 0xe0, 0x17, 0x29, 0x0b, 0xf0,
    0x18, 0x22, 0x29, 0x60, 0x19, 0x08, 0xed, 0xf0, 0x1a, 0x02, 0x0b, 0x60,
    0x1a, 0xf2, 0x0a, 0x70, 0x1b, 0xe1, 0xed, 0x60, 0x1c, 0xd1, 0xec, 0x70,
    0x1d, 0xc1, 0xcf, 0x60, 0x1e, 0xb1, 0xce, 0x70, 0x1f, 0xa1, 0xb1, 0x60,
    0x20, 0x76, 0x00, 0xf0, 0x21, 0x81, 0x93, 0x60, 0x22, 0x55, 0xe2, 0xf0,
    0x23, 0x6a, 0xaf, 0xe0, 0x24, 0x35, 0xc4, 0xf0, 0x25, 0x4a, 0x91, 0xe0,
    0x26, 0x15, 0xa6, 0xf0, 0x27, 0x2a, 0x73, 0xe0, 0x27, 0xfe, 0xc3, 0x70,
    0x29, 0x0a, 0x55, 0xe0, 0x29, 0xde, 0xa5, 0x70, 0x2a, 0xea, 0x37, 0xe0,
    0x2b, 0xbe, 0x87, 0x70, 0x2c, 0xd3, 0x54, 0x60, 0x2d, 0x9e, 0x69, 0x70,
    0x2e, 0xb3, 0x36, 0x60, 0x2f, 0x7e, 0x4b, 0x70, 0x30, 0x93, 0x18, 0x60,
    0x31, 0x67, 0x67, 0xf0, 0x32, 0x72, 0xfa, 0x60, 0x33, 0x47, 0x49, 0xf0,
    0x34, 0x52, 0xdc, 0x60, 0x35, 0x27, 0x2b, 0xf0, 0x36, 0x32, 0xbe, 0x60,
    0x37, 0x07, 0x0d, 0xf0, 0x38, 0x1b, 0xda, 0xe0, 0x38, 0xe6, 0xef, 0xf0,
    0x39, 0xfb, 0xbc, 0xe0, 0x3a, 0xc6, 0xd1, 0xf0, 0x3b, 0xdb, 0x9e, 0xe0,
    0x3c, 0xaf, 0xee, 0x70, 0x3d, 0xbb, 0x80, 0xe0, 0x3e, 0x8f, 0xd0, 0x70,
    0x3f, 0x9b, 0x62, 0xe0, 0x40, 0x6f, 0xb2, 0x70, 0x41, 0x84, 0x7f, 0x60,
    0x42, 0x4f, 0x94, 0x70, 0x43, 0x64, 0x61, 0x60, 0x44, 0x2f, 0x76, 0x70,
    0x45, 0x44, 0x43, 0x60, 0x45, 0xf3, 0xa8, 0xf0, 0x47, 0x2d, 0x5f, 0xe0,
    0x47, 0xd3, 0x8a, 0xf0, 0x49, 0x0d, 0x41, 0xe0, 0x49, 0xb3, 0x6c, 0xf0,
    0x4a, 0xed, 0x23, 0xe0, 0x4b, 0x9c, 0x89, 0x70, 0x4c, 0xd6, 0x40, 0x60,
    0x4d, 0x7c, 0x6b, 0x70, 0x4e, 0xb6, 0x22, 0x60, 0x4f, 0x5c, 0x4d, 0x70,
    0x50, 0x96, 0x04, 0x60, 0x51, 0x3c, 0x2f, 0x70, 0x52, 0x75, 0xe6, 0x60,
    0x53, 0x1c, 0x11, 0x70, 0x54, 0x55, 0xc8, 0x60, 0x54, 0xfb, 0xf3, 0x70,
    0x56, 0x35, 0xaa, 0x60, 0x56, 0xe5, 0x0f, 0xf0, 0x58, 0x1e, 0xc6, 0xe0,
    0x58, 0xc4, 0xf1, 0xf0, 0x59, 0xfe, 0xa8, 0xe0, 0x5a, 0xa4, 0xd3, 0xf0,
    0x5b, 0xde, 0x8a, 0xe0, 0x5c, 0x84, 0xb5, 0xf0, 0x5d, 0xbe, 0x6c, 0xe0,
    0x5e, 0x64, 0x97, 0xf0, 0x5f, 0x9e, 0x4e, 0xe0, 0x60, 0x4d, 0xb4, 0x70,
    0x61, 0x87, 0x6b, 0x60, 0x62, 0x2d, 0x96, 0x70, 0x63, 0x67, 0x4d, 0x60,
    0x64, 0x0d, 0x78, 0x70, 0x65, 0x47, 0x2f, 0x60, 0x65, 0xed, 0x5a, 0x70,
    0x67, 0x27, 0x11, 0x60, 0x67, 0xcd, 0x3c, 0x70, 0x69, 0x06, 0xf3, 0x60,
    0x69, 0xad, 0x1e, 0x70, 0x6a, 0xe6, 0xd5, 0x60, 0x6b, 0x96, 0x3a, 0xf0,
    0x6c, 0xcf, 0xf1, 0xe0, 0x6d, 0x76, 0x1c, 0xf0, 0x6e, 0xaf, 0xd3, 0xe0,
    0x6f, 0x55, 0xfe, 0xf0, 0x70, 0x8f, 0xb5, 0xe0, 0x71, 0x35, 0xe0, 0xf0,
    0x72, 0x6f, 0x97, 0xe0, 0x73, 0x15, 0xc2, 0xf0, 0x74, 0x4f, 0x79, 0xe0,
    0x74, 0xfe, 0xdf, 0x70, 0x76, 0x38, 0x96, 0x60, 0x76, 0xde, 0xc1, 0x70,
    0x78, 0x18, 0x78, 0x60, 0x78, 0xbe, 0xa3, 0x70, 0x79, 0xf8, 0x5a, 0x60,
    0x7a, 0x9e, 0x85, 0x70, 0x7b, 0xd8, 0x3c, 0x60, 0x7c, 0x7e, 0x67, 0x70,
    0x7d, 0xb8, 0x1e, 0x60, 0x7e, 0x5e, 0x49, 0x70, 0x7f, 0x98, 0x00, 0x60,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x02, 0x03, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xff, 0xff, 0xc7, 0xc0, 0x01,
    0x00, 0xff, 0xff, 0xb9, 0xb0, 0x00, 0x04, 0xff, 0xff, 0xc7, 0xc0, 0x01,
    0x08, 0xff, 0xff, 0xc7, 0xc0, 0x01, 0x0c, 0x45, 0x44, 0x54, 0x00, 0x45,
    0x53, 0x54, 0x00, 0x45, 0x57, 0x54, 0x00, 0x45, 0x50, 0x54, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x54, 0x5a, 0x69, 0x66, 0x32,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0x00, 0x00, 0x00, 0x05, 0x00,
    0x00, 0x00, 0x14, 0xff, 0xff, 0xff, 0xff, 0x5e, 0x03, 0xf0, 0x90, 0xff,
    0xff, 0xff, 0xff, 0x9e, 0xa6, 0x1e, 0x70, 0xff, 0xff, 0xff, 0xff, 0x9f,
    0xba, 0xeb, 0x60, 0xff, 0xff, 0xff, 0xff, 0xa0, 0x86, 0x00, 0x70, 0xff,
    0xff, 0xff, 0xff, 0xa1, 0x9a, 0xcd, 0x60, 0xff, 0xff, 0xff, 0xff, 0xa2,
    0x65, 0xe2, 0x70, 0xff, 0xff, 0xff, 0xff, 0xa3, 0x83, 0xe9, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xa4, 0x6a, 0xae, 0x70, 0xff, 0xff, 0xff, 0xff, 0xa5,
    0x35, 0xa7, 0x60, 0xff, 0xff, 0xff, 0xff, 0xa6, 0x53, 0xca, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xa7, 0x15, 0x89, 0x60, 0xff, 0xff, 0xff, 0xff, 0xa8,
    0x33, 0xac, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xa8, 0xfe, 0xa5, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xaa, 0x13, 0x8e, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xaa,
    0xde, 0x87, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xab, 0xf3, 0x70, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xac, 0xbe, 0x69, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xad,
    0xd3, 0x52, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xae, 0x9e, 0x4b, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xaf, 0xb3, 0x34, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xb0,
    0x7e, 0x2d, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x9c, 0x51, 0x70, 0xff,
    0xff, 0xff, 0xff, 0xb2, 0x67, 0x4a, 0x60, 0xff, 0xff, 0xff, 0xff, 0xb3,
    0x7c, 0x33, 0x70, 0xff, 0xff, 0xff, 0xff, 0xb4, 0x47, 0x2c, 0x60, 0xff,
    0xff, 0xff, 0xff, 0xb5, 0x5c, 0x15, 0x70, 0xff, 0xff, 0xff, 0xff, 0xb6,
    0x27, 0x0e, 0x60, 0xff, 0xff, 0xff, 0xff, 0xb7, 0x3b, 0xf7, 0x70, 0xff,
    0xff, 0xff, 0xff, 0xb8, 0x06, 0xf0, 0x60, 0xff, 0xff, 0xff, 0xff, 0xb9,
    0x1b, 0xd9, 0x70, 0xff, 0xff, 0xff, 0xff, 0xb9, 0xe6, 0xd2, 0x60, 0xff,
    0xff, 0xff, 0xff, 0xbb, 0x04, 0xf5, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xbb,
    0xc6, 0xb4, 0x60, 0xff, 0xff, 0xff, 0xff, 0xbc, 0xe4, 0xd7, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xbd, 0xaf, 0xd0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xbe,
    0xc4, 0xb9, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x8f, 0xb2, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xc0, 0xa4, 0x9b, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xc1,
    0x6f, 0x94, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xc2, 0x84, 0x7d, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xc3, 0x4f, 0x76, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xc4,
    0x64, 0x5f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xc5, 0x2f, 0x58, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xc6, 0x4d, 0x7c, 0x70, 0xff, 0xff, 0xff, 0xff, 0xc7,
    0x0f, 0x3a, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x2d, 0x5e, 0x70, 0xff,
    0xff, 0xff, 0xff, 0xc8, 0xf8, 0x57, 0x60, 0xff, 0xff, 0xff, 0xff, 0xca,
    0x0d, 0x40, 0x70, 0xff, 0xff, 0xff, 0xff, 0xca, 0xd8, 0x39, 0x60, 0xff,
    0xff, 0xff, 0xff, 0xcb, 0x88, 0xf0, 0x70, 0xff, 0xff, 0xff, 0xff, 0xd2,
    0x23, 0xf4, 0x70, 0xff, 0xff, 0xff, 0xff, 0xd2, 0x60, 0xfb, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xd3, 0x75, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xd4,
    0x40, 0xdd, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xd5, 0x55, 0xc6, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xd6, 0x20, 0xbf, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xd7,
    0x35, 0xa8, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x00, 0xa1, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xd9, 0x15, 0x8a, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xd9,
    0xe0, 0x83, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xda, 0xfe, 0xa7, 0x70, 0xff,
    0xff, 0xff, 0xff, 0xdb, 0xc0, 0x65, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xdc,
    0xde, 0x89, 0x70, 0xff, 0xff, 0xff, 0xff, 0xdd, 0xa9, 0x82, 0x60, 0xff,
    0xff, 0xff, 0xff, 0xde, 0xbe, 0x6b, 0x70, 0xff, 0xff, 0xff, 0xff, 0xdf,
    0x89, 0x64, 0x60, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x9e, 0x4d, 0x70, 0xff,
    0xff, 0xff, 0xff, 0xe1, 0x69, 0x46, 0x60, 0xff, 0xff, 0xff, 0xff, 0xe2,
    0x7e, 0x2f, 0x70, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x49, 0x28, 0x60, 0xff,
    0xff, 0xff, 0xff, 0xe4, 0x5e, 0x11, 0x70, 0xff, 0xff, 0xff, 0xff, 0xe5,
    0x57, 0x2e, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xe6, 0x47, 0x2d, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xe7, 0x37, 0x10, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xe8,
    0x27, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xe9, 0x16, 0xf2, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xea, 0x06, 0xf1, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xea,
    0xf6, 0xd4, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xeb, 0xe6, 0xd3, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xec, 0xd6, 0xb6, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xed,
    0xc6, 0xb5, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xee, 0xbf, 0xd3, 0x60, 0xff,
    0xff, 0xff, 0xff, 0xef, 0xaf, 0xd2, 0x70, 0xff, 0xff, 0xff, 0xff, 0xf0,
    0x9f, 0xb5, 0x60, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x8f, 0xb4, 0x70, 0xff,
    0xff, 0xff, 0xff, 0xf2, 0x7f, 0x97, 0x60, 0xff, 0xff, 0xff, 0xff, 0xf3,
    0x6f, 0x96, 0x70, 0xff, 0xff, 0xff, 0xff, 0xf4, 0x5f, 0x79, 0x60, 0xff,
    0xff, 0xff, 0xff, 0xf5, 0x4f, 0x78, 0x70, 0xff, 0xff, 0xff, 0xff, 0xf6,
    0x3f, 0x5b, 0x60, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x2f, 0x5a, 0x70, 0xff,
    0xff, 0xff, 0xff, 0xf8, 0x28, 0x77, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xf9,
    0x0f, 0x3c, 0x70, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x08, 0x59, 0xe0, 0xff,
    0xff, 0xff, 0xff, 0xfa, 0xf8, 0x58, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xfb,
    0xe8, 0x3b, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xd8, 0x3a, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xfd, 0xc8, 0x1d, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xfe,
    0xb8, 0x1c, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa7, 0xff, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x97, 0xfe, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x87, 0xe1, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x77, 0xe0, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x70, 0xfe, 0x60, 0x00, 0x00, 0x00, 0x00, 0x04,
    0x60, 0xfd, 0x70, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0xe0, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x06, 0x40, 0xdf, 0x70, 0x00, 0x00, 0x00, 0x00, 0x07,
    0x30, 0xc2, 0x60, 0x00, 0x00, 0x00, 0x00, 0x07, 0x8d, 0x19, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x09, 0x10, 0xa4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x09,
    0xad, 0x94, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xf0, 0x86, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x0b, 0xe0, 0x85, 0x70, 0x00, 0x00, 0x00, 0x00, 0x0c,
    0xd9, 0xa2, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xc0, 0x67, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x0e, 0xb9, 0x84, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f,
    0xa9, 0x83, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x99, 0x66, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x11, 0x89, 0x65, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x12,
    0x79, 0x48, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x13, 0x69, 0x47, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x14, 0x59, 0x2a, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x15,
    0x49, 0x29, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x16, 0x39, 0x0c, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x17, 0x29, 0x0b, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x18,
    0x22, 0x29, 0x60, 0x00, 0x00, 0x00, 0x00, 0x19, 0x08, 0xed, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x1a, 0x02, 0x0b, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1a,
    0xf2, 0x0a, 0x70, 0x00, 0x00, 0x00, 0x00, 0x1b, 0xe1, 0xed, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x1c, 0xd1, 0xec, 0x70, 0x00, 0x00, 0x00, 0x00, 0x1d,
    0xc1, 0xcf, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xb1, 0xce, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x1f, 0xa1, 0xb1, 0x60, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x76, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x21, 0x81, 0x93, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x22, 0x55, 0xe2, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x23,
    0x6a, 0xaf, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x24, 0x35, 0xc4, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x25, 0x4a, 0x91, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x26,
    0x15, 0xa6, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x27, 0x2a, 0x73, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x27, 0xfe, 0xc3, 0x70, 0x00, 0x00, 0x00, 0x00, 0x29,
    0x0a, 0x55, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x29, 0xde, 0xa5, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x2a, 0xea, 0x37, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x2b,
    0xbe, 0x87, 0x70, 0x00, 0x00, 0x00, 0x00, 0x2c, 0xd3, 0x54, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x2d, 0x9e, 0x69, 0x70, 0x00, 0x00, 0x00, 0x00, 0x2e,
    0xb3, 0x36, 0x60, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x7e, 0x4b, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x30, 0x93, 0x18, 0x60, 0x00, 0x00, 0x00, 0x00, 0x31,
    0x67, 0x67, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x32, 0x72, 0xfa, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x33, 0x47, 0x49, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x34,
    0x52, 0xdc, 0x60, 0x00, 0x00, 0x00, 0x00, 0x35, 0x27, 0x2b, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x36, 0x32, 0xbe, 0x60, 0x00, 0x00, 0x00, 0x00, 0x37,
    0x07, 0x0d, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1b, 0xda, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x38, 0xe6, 0xef, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x39,
    0xfb, 0xbc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3a, 0xc6, 0xd1, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x3b, 0xdb, 0x9e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3c,
    0xaf, 0xee, 0x70, 0x00, 0x00, 0x00, 0x00, 0x3d, 0xbb, 0x80, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x3e, 0x8f, 0xd0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x3f,
    0x9b, 0x62, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x6f, 0xb2, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x41, 0x84, 0x7f, 0x60, 0x00, 0x00, 0x00, 0x00, 0x42,
    0x4f, 0x94, 0x70, 0x00, 0x00, 0x00, 0x00, 0x43, 0x64, 0x61, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x44, 0x2f, 0x76, 0x70, 0x00, 0x00, 0x00, 0x00, 0x45,
    0x44, 0x43, 0x60, 0x00, 0x00, 0x00, 0x00, 0x45, 0xf3, 0xa8, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x47, 0x2d, 0x5f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x47,
    0xd3, 0x8a, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x49, 0x0d, 0x41, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x49, 0xb3, 0x6c, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x4a,
    0xed, 0x23, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x9c, 0x89, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x4c, 0xd6, 0x40, 0x60, 0x00, 0x00, 0x00, 0x00, 0x4d,
    0x7c, 0x6b, 0x70, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xb6, 0x22, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x4f, 0x5c, 0x4d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x50,
    0x96, 0x04, 0x60, 0x00, 0x00, 0x00, 0x00, 0x51, 0x3c, 0x2f, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x52, 0x75, 0xe6, 0x60, 0x00, 0x00, 0x00, 0x00, 0x53,
    0x1c, 0x11, 0x70, 0x00, 0x00, 0x00, 0x00, 0x54, 0x55, 0xc8, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x54, 0xfb, 0xf3, 0x70, 0x00, 0x00, 0x00, 0x00, 0x56,
    0x35, 0xaa, 0x60, 0x00, 0x00, 0x00, 0x00, 0x56, 0xe5, 0x0f, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x58, 0x1e, 0xc6, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x58,
    0xc4, 0xf1, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x59, 0xfe, 0xa8, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x5a, 0xa4, 0xd3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x5b,
    0xde, 0x8a, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x84, 0xb5, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x5d, 0xbe, 0x6c, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x5e,
    0x64, 0x97, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x9e, 0x4e, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x4d, 0xb4, 0x70, 0x00, 0x00, 0x00, 0x00, 0x61,
    0x87, 0x6b, 0x60, 0x00, 0x00, 0x00, 0x00, 0x62, 0x2d, 0x96, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x63, 0x67, 0x4d, 0x60, 0x00, 0x00, 0x00, 0x00, 0x64,
    0x0d, 0x78, 0x70, 0x00, 0x00, 0x00, 0x00, 0x65, 0x47, 0x2f, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x65, 0xed, 0x5a, 0x70, 0x00, 0x00, 0x00, 0x00, 0x67,
    0x27, 0x11, 0x60, 0x00, 0x00, 0x00, 0x00, 0x67, 0xcd, 0x3c, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x69, 0x06, 0xf3, 0x60, 0x00, 0x00, 0x00, 0x00, 0x69,
    0xad, 0x1e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x6a, 0xe6, 0xd5, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x6b, 0x96, 0x3a, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x6c,
    0xcf, 0xf1, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x76, 0x1c, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x6e, 0xaf, 0xd3, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x6f,
    0x55, 0xfe, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8f, 0xb5, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x71, 0x35, 0xe0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x72,
    0x6f, 0x97, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x73, 0x15, 0xc2, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x74, 0x4f, 0x79, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x74,
    0xfe, 0xdf, 0x70, 0x00, 0x00, 0x00, 0x00, 0x76, 0x38, 0x96, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x76, 0xde, 0xc1, 0x70, 0x00, 0x00, 0x00, 0x00, 0x78,
    0x18, 0x78, 0x60, 0x00, 0x00, 0x00, 0x00, 0x78, 0xbe, 0xa3, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x79, 0xf8, 0x5a, 0x60, 0x00, 0x00, 0x00, 0x00, 0x7a,
    0x9e, 0x85, 0x70, 0x00, 0x00, 0x00, 0x00, 0x7b, 0xd8, 0x3c, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x7c, 0x7e, 0x67, 0x70, 0x00, 0x00, 0x00, 0x00, 0x7d,
    0xb8, 0x1e, 0x60, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x5e, 0x49, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x7f, 0x98, 0x00, 0x60, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x03, 0x04, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0xff, 0xff, 0xba, 0x9e, 0x00, 0x00, 0xff, 0xff, 0xc7,
    0xc0, 0x01, 0x04, 0xff, 0xff, 0xb9, 0xb0, 0x00, 0x08, 0xff, 0xff, 0xc7,
    0xc0, 0x01, 0x0c, 0xff, 0xff, 0xc7, 0xc0, 0x01, 0x10, 0x4c, 0x4d, 0x54,
    0x00, 0x45, 0x44, 0x54, 0x00, 0x45, 0x53, 0x54, 0x00, 0x45, 0x57, 0x54,
    0x00, 0x45, 0x50, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x0a, 0x45, 0x53, 0x54, 0x35, 0x45, 0x44, 0x54, 0x2c,
    0x4d, 0x33, 0x2e, 0x32, 0x2e, 0x30, 0x2c, 0x4d, 0x31, 0x31, 0x2e, 0x31,
    0x2e, 0x30, 0x0a
};

const char LONDON_DATA[] = {
    // Data from Europe/London

    0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
    0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2,
    0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0d, 0x9b, 0x26, 0xad, 0xa0,
    0x9b, 0xd6, 0x05, 0x20, 0x9c, 0xcf, 0x30, 0xa0, 0x9d, 0xa4, 0xc3, 0xa0,
    0x9e, 0x9c, 0x9d, 0xa0, 0x9f, 0x97, 0x1a, 0xa0, 0xa0, 0x85, 0xba, 0x20,
    0xa1, 0x76, 0xfc, 0xa0, 0xa2, 0x65, 0x9c, 0x20, 0xa3, 0x7b, 0xc8, 0xa0,
    0xa4, 0x4e, 0xb8, 0xa0, 0xa5, 0x3f, 0xfb, 0x20, 0xa6, 0x25, 0x60, 0x20,
    0xa7, 0x27, 0xc6, 0x20, 0xa8, 0x2a, 0x2c, 0x20, 0xa8, 0xeb, 0xf8, 0xa0,
    0xaa, 0x00, 0xd3, 0xa0, 0xaa, 0xd5, 0x15, 0x20, 0xab, 0xe9, 0xf0, 0x20,
    0xac, 0xc7, 0x6c, 0x20, 0xad, 0xc9, 0xd2, 0x20, 0xae, 0xa7, 0x4e, 0x20,
    0xaf, 0xa0, 0x79, 0xa0, 0xb0, 0x87, 0x30, 0x20, 0xb1, 0x92, 0xd0, 0xa0,
    0xb2, 0x70, 0x4c, 0xa0, 0xb3, 0x72, 0xb2, 0xa0, 0xb4, 0x50, 0x2e, 0xa0,
    0xb5, 0x49, 0x5a, 0x20, 0xb6, 0x30, 0x10, 0xa0, 0xb7, 0x32, 0x76, 0xa0,
    0xb8, 0x0f, 0xf2, 0xa0, 0xb9, 0x12, 0x58, 0xa0, 0xb9, 0xef, 0xd4, 0xa0,
    0xba, 0xe9, 0x00, 0x20, 0xbb, 0xd8, 0xf1, 0x20, 0xbc, 0xdb, 0x57, 0x20,
    0xbd, 0xb8, 0xd3, 0x20, 0xbe, 0xb1, 0xfe, 0xa0, 0xbf, 0x98, 0xb5, 0x20,
    0xc0, 0x9b, 0x1b, 0x20, 0xc1, 0x78, 0x97, 0x20, 0xc2, 0x7a, 0xfd, 0x20,
    0xc3, 0x58, 0x79, 0x20, 0xc4, 0x51, 0xa4, 0xa0, 0xc5, 0x38, 0x5b, 0x20,
    0xc6, 0x3a, 0xc1, 0x20, 0xc7, 0x58, 0xd6, 0xa0, 0xc7, 0xda, 0x09, 0xa0,
    0xca, 0x16, 0x26, 0x90, 0xca, 0x97, 0x59, 0x90, 0xcb, 0xd1, 0x1e, 0x90,
    0xcc, 0x77, 0x3b, 0x90, 0xcd, 0xb1, 0x00, 0x90, 0xce, 0x60, 0x58, 0x10,
    0xcf, 0x90, 0xe2, 0x90, 0xd0, 0x6e, 0x5e, 0x90, 0xd1, 0x72, 0x16, 0x10,
    0xd1, 0xfb, 0x32, 0x10, 0xd2, 0x69, 0xfe, 0x20, 0xd3, 0x63, 0x29, 0xa0,
    0xd4, 0x49, 0xe0, 0x20, 0xd5, 0x1e, 0x21, 0xa0, 0xd5, 0x42, 0xfd, 0x90,
    0xd5, 0xdf, 0xe0, 0x10, 0xd6, 0x4e, 0xac, 0x20, 0xd6, 0xfe, 0x03, 0xa0,
    0xd8, 0x2e, 0x8e, 0x20, 0xd8, 0xf9, 0x95, 0x20, 0xda, 0x0e, 0x70, 0x20,
    0xda, 0xeb, 0xec, 0x20, 0xdb, 0xe5, 0x17, 0xa0, 0xdc, 0xcb, 0xce, 0x20,
    0xdd, 0xc4, 0xf9, 0xa0, 0xde, 0xb4, 0xea, 0xa0, 0xdf, 0xae, 0x16, 0x20,
    0xe0, 0x94, 0xcc, 0xa0, 0xe1, 0x72, 0x48, 0xa0, 0xe2, 0x6b, 0x74, 0x20,
    0xe3, 0x52, 0x2a, 0xa0, 0xe4, 0x54, 0x90, 0xa0, 0xe5, 0x32, 0x0c, 0xa0,
    0xe6, 0x3d, 0xad, 0x20, 0xe7, 0x1b, 0x29, 0x20, 0xe8, 0x14, 0x54, 0xa0,
    0xe8, 0xfb, 0x0b, 0x20, 0xe9, 0xfd, 0x71, 0x20, 0xea, 0xda, 0xed, 0x20,
    0xeb, 0xdd, 0x53, 0x20, 0xec, 0xba, 0xcf, 0x20, 0xed, 0xb3, 0xfa, 0xa0,
    0xee, 0x9a, 0xb1, 0x20, 0xef, 0x81, 0x67, 0xa0, 0xf0, 0x9f, 0x7d, 0x20,
    0xf1, 0x61, 0x49, 0xa0, 0xf2, 0x7f, 0x5f, 0x20, 0xf3, 0x4a, 0x66, 0x20,
    0xf4, 0x5f, 0x41, 0x20, 0xf5, 0x21, 0x0d, 0xa0, 0xf6, 0x3f, 0x23, 0x20,
    0xf7, 0x00, 0xef, 0xa0, 0xf8, 0x1f, 0x05, 0x20, 0xf8, 0xe0, 0xd1, 0xa0,
    0xf9, 0xfe, 0xe7, 0x20, 0xfa, 0xc0, 0xb3, 0xa0, 0xfb, 0xe8, 0x03, 0xa0,
    0xfc, 0x7b, 0xab, 0xa0, 0xfd, 0xc7, 0xbb, 0x70, 0x03, 0x70, 0xc6, 0x20,
    0x04, 0x29, 0x58, 0x20, 0x05, 0x50, 0xa8, 0x20, 0x06, 0x09, 0x3a, 0x20,
    0x07, 0x30, 0x8a, 0x20, 0x07, 0xe9, 0x1c, 0x20, 0x09, 0x10, 0x6c, 0x20,
    0x09, 0xc8, 0xfe, 0x20, 0x0a, 0xf0, 0x4e, 0x20, 0x0b, 0xb2, 0x1a, 0xa0,
    0x0c, 0xd0, 0x30, 0x20, 0x0d, 0x91, 0xfc, 0xa0, 0x0e, 0xb0, 0x12, 0x20,
    0x0f, 0x71, 0xde, 0xa0, 0x10, 0x99, 0x2e, 0xa0, 0x11, 0x51, 0xc0, 0xa0,
    0x12, 0x79, 0x10, 0xa0, 0x13, 0x31, 0xa2, 0xa0, 0x14, 0x58, 0xf2, 0xa0,
    0x15, 0x23, 0xeb, 0x90, 0x16, 0x38, 0xc6, 0x90, 0x17, 0x03, 0xcd, 0x90,
    0x18, 0x18, 0xa8, 0x90, 0x18, 0xe3, 0xaf, 0x90, 0x19, 0xf8, 0x8a, 0x90,
    0x1a, 0xc3, 0x91, 0x90, 0x1b, 0xe1, 0xa7, 0x10, 0x1c, 0xac, 0xae, 0x10,
    0x1d, 0xc1, 0x89, 0x10, 0x1e, 0x8c, 0x90, 0x10, 0x1f, 0xa1, 0x6b, 0x10,
    0x20, 0x6c, 0x72, 0x10, 0x21, 0x81, 0x4d, 0x10, 0x22, 0x4c, 0x54, 0x10,
    0x23, 0x61, 0x2f, 0x10, 0x24, 0x2c, 0x36, 0x10, 0x25, 0x4a, 0x4b, 0x90,
    0x26, 0x0c, 0x18, 0x10, 0x27, 0x2a, 0x2d, 0x90, 0x27, 0xf5, 0x34, 0x90,
    0x29, 0x0a, 0x0f, 0x90, 0x29, 0xd5, 0x16, 0x90, 0x2a, 0xe9, 0xf1, 0x90,
    0x2b, 0xb4, 0xf8, 0x90, 0x2c, 0xc9, 0xd3, 0x90, 0x2d, 0x94, 0xda, 0x90,
    0x2e, 0xa9, 0xb5, 0x90, 0x2f, 0x74, 0xbc, 0x90, 0x30, 0x89, 0x97, 0x90,
    0x30, 0xe7, 0x24, 0x00, 0x31, 0x5d, 0xd9, 0x10, 0x32, 0x72, 0xb4, 0x10,
    0x33, 0x3d, 0xbb, 0x10, 0x34, 0x52, 0x96, 0x10, 0x35, 0x1d, 0x9d, 0x10,
    0x36, 0x32, 0x78, 0x10, 0x36, 0xfd, 0x7f, 0x10, 0x38, 0x1b, 0x94, 0x90,
    0x38, 0xdd, 0x61, 0x10, 0x39, 0xfb, 0x76, 0x90, 0x3a, 0xbd, 0x43, 0x10,
    0x3b, 0xdb, 0x58, 0x90, 0x3c, 0xa6, 0x5f, 0x90, 0x3d, 0xbb, 0x3a, 0x90,
    0x3e, 0x86, 0x41, 0x90, 0x3f, 0x9b, 0x1c, 0x90, 0x40, 0x66, 0x23, 0x90,
    0x41, 0x84, 0x39, 0x10, 0x42, 0x46, 0x05, 0x90, 0x43, 0x64, 0x1b, 0x10,
    0x44, 0x25, 0xe7, 0x90, 0x45, 0x43, 0xfd, 0x10, 0x46, 0x05, 0xc9, 0x90,
    0x47, 0x23, 0xdf, 0x10, 0x47, 0xee, 0xe6, 0x10, 0x49, 0x03, 0xc1, 0x10,
    0x49, 0xce, 0xc8, 0x10, 0x4a, 0xe3, 0xa3, 0x10, 0x4b, 0xae, 0xaa, 0x10,
    0x4c, 0xcc, 0xbf, 0x90, 0x4d, 0x8e, 0x8c, 0x10, 0x4e, 0xac, 0xa1, 0x90,
    0x4f, 0x6e, 0x6e, 0x10, 0x50, 0x8c, 0x83, 0x90, 0x51, 0x57, 0x8a, 0x90,
    0x52, 0x6c, 0x65, 0x90, 0x53, 0x37, 0x6c, 0x90, 0x54, 0x4c, 0x47, 0x90,
    0x55, 0x17, 0x4e, 0x90, 0x56, 0x2c, 0x29, 0x90, 0x56, 0xf7, 0x30, 0x90,
    0x58, 0x15, 0x46, 0x10, 0x58, 0xd7, 0x12, 0x90, 0x59, 0xf5, 0x28, 0x10,
    0x5a, 0xb6, 0xf4, 0x90, 0x5b, 0xd5, 0x0a, 0x10, 0x5c, 0xa0, 0x11, 0x10,
    0x5d, 0xb4, 0xec, 0x10, 0x5e, 0x7f, 0xf3, 0x10, 0x5f, 0x94, 0xce, 0x10,
    0x60, 0x5f, 0xd5, 0x10, 0x61, 0x7d, 0xea, 0x90, 0x62, 0x3f, 0xb7, 0x10,
    0x63, 0x5d, 0xcc, 0x90, 0x64, 0x1f, 0x99, 0x10, 0x65, 0x3d, 0xae, 0x90,
    0x66, 0x08, 0xb5, 0x90, 0x67, 0x1d, 0x90, 0x90, 0x67, 0xe8, 0x97, 0x90,
    0x68, 0xfd, 0x72, 0x90, 0x69, 0xc8, 0x79, 0x90, 0x6a, 0xdd, 0x54, 0x90,
    0x6b, 0xa8, 0x5b, 0x90, 0x6c, 0xc6, 0x71, 0x10, 0x6d, 0x88, 0x3d, 0x90,
    0x6e, 0xa6, 0x53, 0x10, 0x6f, 0x68, 0x1f, 0x90, 0x70, 0x86, 0x35, 0x10,
    0x71, 0x51, 0x3c, 0x10, 0x72, 0x66, 0x17, 0x10, 0x73, 0x31, 0x1e, 0x10,
    0x74, 0x45, 0xf9, 0x10, 0x75, 0x11, 0x00, 0x10, 0x76, 0x2f, 0x15, 0x90,
    0x76, 0xf0, 0xe2, 0x10, 0x78, 0x0e, 0xf7, 0x90, 0x78, 0xd0, 0xc4, 0x10,
    0x79, 0xee, 0xd9, 0x90, 0x7a, 0xb0, 0xa6, 0x10, 0x7b, 0xce, 0xbb, 0x90,
    0x7c, 0x99, 0xc2, 0x90, 0x7d, 0xae, 0x9d, 0x90, 0x7e, 0x79, 0xa4, 0x90,
    0x7f, 0x8e, 0x7f, 0x90, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02,
    0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x03, 0x05, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x04,
    0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04,
    0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04,
    0x05, 0x04, 0x05, 0x04, 0x05, 0x06, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05,
    0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05,
    0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05,
    0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05,
    0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05,
    0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05,
    0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x04, 0x05,
    0x04, 0x05, 0x04, 0x05, 0x04, 0x05, 0x00, 0x00, 0x0e, 0x10, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x1c, 0x20, 0x01, 0x08,
    0x00, 0x00, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
    0x42, 0x53, 0x54, 0x00, 0x47, 0x4d, 0x54, 0x00, 0x42, 0x44, 0x53, 0x54,
    0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x01, 0x00, 0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xf3, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x11, 0xff,
    0xff, 0xff, 0xff, 0x1a, 0x5d, 0x09, 0xcb, 0xff, 0xff, 0xff, 0xff, 0x9b,
    0x26, 0xad, 0xa0, 0xff, 0xff, 0xff, 0xff, 0x9b, 0xd6, 0x05, 0x20, 0xff,
    0xff, 0xff, 0xff, 0x9c, 0xcf, 0x30, 0xa0, 0xff, 0xff, 0xff, 0xff, 0x9d,
    0xa4, 0xc3, 0xa0, 0xff, 0xff, 0xff, 0xff, 0x9e, 0x9c, 0x9d, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0x9f, 0x97, 0x1a, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xa0,
    0x85, 0xba, 0x20, 0xff, 0xff, 0xff, 0xff, 0xa1, 0x76, 0xfc, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xa2, 0x65, 0x9c, 0x20, 0xff, 0xff, 0xff, 0xff, 0xa3,
    0x7b, 0xc8, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xa4, 0x4e, 0xb8, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xa5, 0x3f, 0xfb, 0x20, 0xff, 0xff, 0xff, 0xff, 0xa6,
    0x25, 0x60, 0x20, 0xff, 0xff, 0xff, 0xff, 0xa7, 0x27, 0xc6, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xa8, 0x2a, 0x2c, 0x20, 0xff, 0xff, 0xff, 0xff, 0xa8,
    0xeb, 0xf8, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xaa, 0x00, 0xd3, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xaa, 0xd5, 0x15, 0x20, 0xff, 0xff, 0xff, 0xff, 0xab,
    0xe9, 0xf0, 0x20, 0xff, 0xff, 0xff, 0xff, 0xac, 0xc7, 0x6c, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xad, 0xc9, 0xd2, 0x20, 0xff, 0xff, 0xff, 0xff, 0xae,
    0xa7, 0x4e, 0x20, 0xff, 0xff, 0xff, 0xff, 0xaf, 0xa0, 0x79, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xb0, 0x87, 0x30, 0x20, 0xff, 0xff, 0xff, 0xff, 0xb1,
    0x92, 0xd0, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xb2, 0x70, 0x4c, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xb3, 0x72, 0xb2, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xb4,
    0x50, 0x2e, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xb5, 0x49, 0x5a, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xb6, 0x30, 0x10, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xb7,
    0x32, 0x76, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xb8, 0x0f, 0xf2, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xb9, 0x12, 0x58, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xb9,
    0xef, 0xd4, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xba, 0xe9, 0x00, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xbb, 0xd8, 0xf1, 0x20, 0xff, 0xff, 0xff, 0xff, 0xbc,
    0xdb, 0x57, 0x20, 0xff, 0xff, 0xff, 0xff, 0xbd, 0xb8, 0xd3, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xbe, 0xb1, 0xfe, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xbf,
    0x98, 0xb5, 0x20, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x9b, 0x1b, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xc1, 0x78, 0x97, 0x20, 0xff, 0xff, 0xff, 0xff, 0xc2,
    0x7a, 0xfd, 0x20, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x58, 0x79, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xc4, 0x51, 0xa4, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xc5,
    0x38, 0x5b, 0x20, 0xff, 0xff, 0xff, 0xff, 0xc6, 0x3a, 0xc1, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xc7, 0x58, 0xd6, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xc7,
    0xda, 0x09, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xca, 0x16, 0x26, 0x90, 0xff,
    0xff, 0xff, 0xff, 0xca, 0x97, 0x59, 0x90, 0xff, 0xff, 0xff, 0xff, 0xcb,
    0xd1, 0x1e, 0x90, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x77, 0x3b, 0x90, 0xff,
    0xff, 0xff, 0xff, 0xcd, 0xb1, 0x00, 0x90, 0xff, 0xff, 0xff, 0xff, 0xce,
    0x60, 0x58, 0x10, 0xff, 0xff, 0xff, 0xff, 0xcf, 0x90, 0xe2, 0x90, 0xff,
    0xff, 0xff, 0xff, 0xd0, 0x6e, 0x5e, 0x90, 0xff, 0xff, 0xff, 0xff, 0xd1,
    0x72, 0x16, 0x10, 0xff, 0xff, 0xff, 0xff, 0xd1, 0xfb, 0x32, 0x10, 0xff,
    0xff, 0xff, 0xff, 0xd2, 0x69, 0xfe, 0x20, 0xff, 0xff, 0xff, 0xff, 0xd3,
    0x63, 0x29, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xd4, 0x49, 0xe0, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xd5, 0x1e, 0x21, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xd5,
    0x42, 0xfd, 0x90, 0xff, 0xff, 0xff, 0xff, 0xd5, 0xdf, 0xe0, 0x10, 0xff,
    0xff, 0xff, 0xff, 0xd6, 0x4e, 0xac, 0x20, 0xff, 0xff, 0xff, 0xff, 0xd6,
    0xfe, 0x03, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x2e, 0x8e, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xd8, 0xf9, 0x95, 0x20, 0xff, 0xff, 0xff, 0xff, 0xda,
    0x0e, 0x70, 0x20, 0xff, 0xff, 0xff, 0xff, 0xda, 0xeb, 0xec, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xdb, 0xe5, 0x17, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xdc,
    0xcb, 0xce, 0x20, 0xff, 0xff, 0xff, 0xff, 0xdd, 0xc4, 0xf9, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xde, 0xb4, 0xea, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xdf,
    0xae, 0x16, 0x20, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x94, 0xcc, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xe1, 0x72, 0x48, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xe2,
    0x6b, 0x74, 0x20, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x52, 0x2a, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xe4, 0x54, 0x90, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xe5,
    0x32, 0x0c, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xe6, 0x3d, 0xad, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xe7, 0x1b, 0x29, 0x20, 0xff, 0xff, 0xff, 0xff, 0xe8,
    0x14, 0x54, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xe8, 0xfb, 0x0b, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xe9, 0xfd, 0x71, 0x20, 0xff, 0xff, 0xff, 0xff, 0xea,
    0xda, 0xed, 0x20, 0xff, 0xff, 0xff, 0xff, 0xeb, 0xdd, 0x53, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xec, 0xba, 0xcf, 0x20, 0xff, 0xff, 0xff, 0xff, 0xed,
    0xb3, 0xfa, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xee, 0x9a, 0xb1, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xef, 0x81, 0x67, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xf0,
    0x9f, 0x7d, 0x20, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x61, 0x49, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xf2, 0x7f, 0x5f, 0x20, 0xff, 0xff, 0xff, 0xff, 0xf3,
    0x4a, 0x66, 0x20, 0xff, 0xff, 0xff, 0xff, 0xf4, 0x5f, 0x41, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xf5, 0x21, 0x0d, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xf6,
    0x3f, 0x23, 0x20, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x00, 0xef, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xf8, 0x1f, 0x05, 0x20, 0xff, 0xff, 0xff, 0xff, 0xf8,
    0xe0, 0xd1, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xfe, 0xe7, 0x20, 0xff,
    0xff, 0xff, 0xff, 0xfa, 0xc0, 0xb3, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xfb,
    0xe8, 0x03, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7b, 0xab, 0xa0, 0xff,
    0xff, 0xff, 0xff, 0xfd, 0xc7, 0xbb, 0x70, 0x00, 0x00, 0x00, 0x00, 0x03,
    0x70, 0xc6, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x29, 0x58, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x05, 0x50, 0xa8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x06,
    0x09, 0x3a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x07, 0x30, 0x8a, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x07, 0xe9, 0x1c, 0x20, 0x00, 0x00, 0x00, 0x00, 0x09,
    0x10, 0x6c, 0x20, 0x00, 0x00, 0x00, 0x00, 0x09, 0xc8, 0xfe, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x0a, 0xf0, 0x4e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0b,
    0xb2, 0x1a, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xd0, 0x30, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x0d, 0x91, 0xfc, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x0e,
    0xb0, 0x12, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x71, 0xde, 0xa0, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x99, 0x2e, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x11,
    0x51, 0xc0, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x12, 0x79, 0x10, 0xa0, 0x00,
    0x00, 0x00, 0x00, 0x13, 0x31, 0xa2, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x58, 0xf2, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x15, 0x23, 0xeb, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x16, 0x38, 0xc6, 0x90, 0x00, 0x00, 0x00, 0x00, 0x17,
    0x03, 0xcd, 0x90, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0xa8, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x18, 0xe3, 0xaf, 0x90, 0x00, 0x00, 0x00, 0x00, 0x19,
    0xf8, 0x8a, 0x90, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xc3, 0x91, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x1b, 0xe1, 0xa7, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1c,
    0xac, 0xae, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xc1, 0x89, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x1e, 0x8c, 0x90, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1f,
    0xa1, 0x6b, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x6c, 0x72, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x21, 0x81, 0x4d, 0x10, 0x00, 0x00, 0x00, 0x00, 0x22,
    0x4c, 0x54, 0x10, 0x00, 0x00, 0x00, 0x00, 0x23, 0x61, 0x2f, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x24, 0x2c, 0x36, 0x10, 0x00, 0x00, 0x00, 0x00, 0x25,
    0x4a, 0x4b, 0x90, 0x00, 0x00, 0x00, 0x00, 0x26, 0x0c, 0x18, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x27, 0x2a, 0x2d, 0x90, 0x00, 0x00, 0x00, 0x00, 0x27,
    0xf5, 0x34, 0x90, 0x00, 0x00, 0x00, 0x00, 0x29, 0x0a, 0x0f, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x29, 0xd5, 0x16, 0x90, 0x00, 0x00, 0x00, 0x00, 0x2a,
    0xe9, 0xf1, 0x90, 0x00, 0x00, 0x00, 0x00, 0x2b, 0xb4, 0xf8, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x2c, 0xc9, 0xd3, 0x90, 0x00, 0x00, 0x00, 0x00, 0x2d,
    0x94, 0xda, 0x90, 0x00, 0x00, 0x00, 0x00, 0x2e, 0xa9, 0xb5, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x2f, 0x74, 0xbc, 0x90, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x89, 0x97, 0x90, 0x00, 0x00, 0x00, 0x00, 0x30, 0xe7, 0x24, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x31, 0x5d, 0xd9, 0x10, 0x00, 0x00, 0x00, 0x00, 0x32,
    0x72, 0xb4, 0x10, 0x00, 0x00, 0x00, 0x00, 0x33, 0x3d, 0xbb, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x34, 0x52, 0x96, 0x10, 0x00, 0x00, 0x00, 0x00, 0x35,
    0x1d, 0x9d, 0x10, 0x00, 0x00, 0x00, 0x00, 0x36, 0x32, 0x78, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x36, 0xfd, 0x7f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x38,
    0x1b, 0x94, 0x90, 0x00, 0x00, 0x00, 0x00, 0x38, 0xdd, 0x61, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x39, 0xfb, 0x76, 0x90, 0x00, 0x00, 0x00, 0x00, 0x3a,
    0xbd, 0x43, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3b, 0xdb, 0x58, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x3c, 0xa6, 0x5f, 0x90, 0x00, 0x00, 0x00, 0x00, 0x3d,
    0xbb, 0x3a, 0x90, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x86, 0x41, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x3f, 0x9b, 0x1c, 0x90, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x66, 0x23, 0x90, 0x00, 0x00, 0x00, 0x00, 0x41, 0x84, 0x39, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x42, 0x46, 0x05, 0x90, 0x00, 0x00, 0x00, 0x00, 0x43,
    0x64, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00, 0x44, 0x25, 0xe7, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x45, 0x43, 0xfd, 0x10, 0x00, 0x00, 0x00, 0x00, 0x46,
    0x05, 0xc9, 0x90, 0x00, 0x00, 0x00, 0x00, 0x47, 0x23, 0xdf, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x47, 0xee, 0xe6, 0x10, 0x00, 0x00, 0x00, 0x00, 0x49,
    0x03, 0xc1, 0x10, 0x00, 0x00, 0x00, 0x00, 0x49, 0xce, 0xc8, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x4a, 0xe3, 0xa3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x4b,
    0xae, 0xaa, 0x10, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xcc, 0xbf, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x4d, 0x8e, 0x8c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x4e,
    0xac, 0xa1, 0x90, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x6e, 0x6e, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x50, 0x8c, 0x83, 0x90, 0x00, 0x00, 0x00, 0x00, 0x51,
    0x57, 0x8a, 0x90, 0x00, 0x00, 0x00, 0x00, 0x52, 0x6c, 0x65, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x53, 0x37, 0x6c, 0x90, 0x00, 0x00, 0x00, 0x00, 0x54,
    0x4c, 0x47, 0x90, 0x00, 0x00, 0x00, 0x00, 0x55, 0x17, 0x4e, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x56, 0x2c, 0x29, 0x90, 0x00, 0x00, 0x00, 0x00, 0x56,
    0xf7, 0x30, 0x90, 0x00, 0x00, 0x00, 0x00, 0x58, 0x15, 0x46, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x58, 0xd7, 0x12, 0x90, 0x00, 0x00, 0x00, 0x00, 0x59,
    0xf5, 0x28, 0x10, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xb6, 0xf4, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x5b, 0xd5, 0x0a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x5c,
    0xa0, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x5d, 0xb4, 0xec, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x5e, 0x7f, 0xf3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x5f,
    0x94, 0xce, 0x10, 0x00, 0x00, 0x00, 0x00, 0x60, 0x5f, 0xd5, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x61, 0x7d, 0xea, 0x90, 0x00, 0x00, 0x00, 0x00, 0x62,
    0x3f, 0xb7, 0x10, 0x00, 0x00, 0x00, 0x00, 0x63, 0x5d, 0xcc, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x64, 0x1f, 0x99, 0x10, 0x00, 0x00, 0x00, 0x00, 0x65,
    0x3d, 0xae, 0x90, 0x00, 0x00, 0x00, 0x00, 0x66, 0x08, 0xb5, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x67, 0x1d, 0x90, 0x90, 0x00, 0x00, 0x00, 0x00, 0x67,
    0xe8, 0x97, 0x90, 0x00, 0x00, 0x00, 0x00, 0x68, 0xfd, 0x72, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x69, 0xc8, 0x79, 0x90, 0x00, 0x00, 0x00, 0x00, 0x6a,
    0xdd, 0x54, 0x90, 0x00, 0x00, 0x00, 0x00, 0x6b, 0xa8, 0x5b, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x6c, 0xc6, 0x71, 0x10, 0x00, 0x00, 0x00, 0x00, 0x6d,
    0x88, 0x3d, 0x90, 0x00, 0x00, 0x00, 0x00, 0x6e, 0xa6, 0x53, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x6f, 0x68, 0x1f, 0x90, 0x00, 0x00, 0x00, 0x00, 0x70,
    0x86, 0x35, 0x10, 0x00, 0x00, 0x00, 0x00, 0x71, 0x51, 0x3c, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x72, 0x66, 0x17, 0x10, 0x00, 0x00, 0x00, 0x00, 0x73,
    0x31, 0x1e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x74, 0x45, 0xf9, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x75, 0x11, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x76,
    0x2f, 0x15, 0x90, 0x00, 0x00, 0x00, 0x00, 0x76, 0xf0, 0xe2, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x78, 0x0e, 0xf7, 0x90, 0x00, 0x00, 0x00, 0x00, 0x78,
    0xd0, 0xc4, 0x10, 0x00, 0x00, 0x00, 0x00, 0x79, 0xee, 0xd9, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x7a, 0xb0, 0xa6, 0x10, 0x00, 0x00, 0x00, 0x00, 0x7b,
    0xce, 0xbb, 0x90, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x99, 0xc2, 0x90, 0x00,
    0x00, 0x00, 0x00, 0x7d, 0xae, 0x9d, 0x90, 0x00, 0x00, 0x00, 0x00, 0x7e,
    0x79, 0xa4, 0x90, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x8e, 0x7f, 0x90, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x03, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
    0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
    0x06, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x05, 0x06, 0x05, 0x06, 0x05,
    0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05,
    0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05,
    0x06, 0x07, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06,
    0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06,
    0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06,
    0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06,
    0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06,
    0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06,
    0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06, 0x05, 0x06,
    0x05, 0x06, 0xff, 0xff, 0xff, 0xb5, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10,
    0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x1c, 0x20,
    0x01, 0x0c, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x04, 0x00, 0x00, 0x0e, 0x10,
    0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x08, 0x4c, 0x4d, 0x54, 0x00, 0x42, 0x53, 0x54, 0x00, 0x47, 0x4d,
    0x54, 0x00, 0x42, 0x44, 0x53, 0x54, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00,
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x0a,
    0x47, 0x4d, 0x54, 0x30, 0x42, 0x53, 0x54, 0x2c, 0x4d, 0x33, 0x2e, 0x35,
    0x2e, 0x30, 0x2f, 0x31, 0x2c, 0x4d, 0x31, 0x30, 0x2e, 0x35, 0x2e, 0x30,
    0x0a,
};

const char TOKYO_DATA[] = {
    // Data from Asia/Tokyo

    0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0c, 0xc3, 0xce, 0x85, 0x70,
    0xd7, 0x3e, 0x1e, 0x90, 0xd7, 0xec, 0x16, 0x80, 0xd8, 0xf9, 0x16, 0x90,
    0xd9, 0xcb, 0xf8, 0x80, 0xdb, 0x07, 0x1d, 0x10, 0xdb, 0xab, 0xda, 0x80,
    0xdc, 0xe6, 0xff, 0x10, 0xdd, 0x8b, 0xbc, 0x80, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00, 0x7e, 0x90, 0x00, 0x00, 0x00,
    0x00, 0x8c, 0xa0, 0x01, 0x04, 0x00, 0x00, 0x7e, 0x90, 0x00, 0x08, 0x43,
    0x4a, 0x54, 0x00, 0x4a, 0x44, 0x54, 0x00, 0x4a, 0x53, 0x54, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x10, 0xff, 0xff, 0xff, 0xff, 0x65, 0xc2, 0xa4, 0x70, 0xff, 0xff, 0xff,
    0xff, 0x74, 0xce, 0xe3, 0x70, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xce, 0x85,
    0x70, 0xff, 0xff, 0xff, 0xff, 0xd7, 0x3e, 0x1e, 0x90, 0xff, 0xff, 0xff,
    0xff, 0xd7, 0xec, 0x16, 0x80, 0xff, 0xff, 0xff, 0xff, 0xd8, 0xf9, 0x16,
    0x90, 0xff, 0xff, 0xff, 0xff, 0xd9, 0xcb, 0xf8, 0x80, 0xff, 0xff, 0xff,
    0xff, 0xdb, 0x07, 0x1d, 0x10, 0xff, 0xff, 0xff, 0xff, 0xdb, 0xab, 0xda,
    0x80, 0xff, 0xff, 0xff, 0xff, 0xdc, 0xe6, 0xff, 0x10, 0xff, 0xff, 0xff,
    0xff, 0xdd, 0x8b, 0xbc, 0x80, 0x01, 0x02, 0x04, 0x03, 0x04, 0x03, 0x04,
    0x03, 0x04, 0x03, 0x04, 0x00, 0x00, 0x83, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x7e, 0x90, 0x00, 0x04, 0x00, 0x00, 0x7e, 0x90, 0x00, 0x08, 0x00, 0x00,
    0x8c, 0xa0, 0x01, 0x0c, 0x00, 0x00, 0x7e, 0x90, 0x00, 0x04, 0x4c, 0x4d,
    0x54, 0x00, 0x4a, 0x53, 0x54, 0x00, 0x43, 0x4a, 0x54, 0x00, 0x4a, 0x44,
    0x54, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x0a, 0x4a, 0x53, 0x54, 0x2d, 0x39, 0x0a,
};

const char KIRITIMATI_DATA[] = {
    // Data from Pacific/Kiritimati

    0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x12, 0x55, 0xf2, 0x00,
    0x2f, 0x06, 0x7d, 0x20, 0x01, 0x02, 0xff, 0xff, 0x6a, 0x00, 0x00, 0x00,
    0xff, 0xff, 0x73, 0x60, 0x00, 0x00, 0x00, 0x00, 0xc4, 0xe0, 0x00, 0x00,
    0x4c, 0x49, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
    0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0xff, 0xff, 0xff, 0xff, 0x7e,
    0x37, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x12, 0x55, 0xf2, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x2f, 0x06, 0x7d, 0x20, 0x01, 0x02, 0x03, 0xff, 0xff,
    0x6c, 0x80, 0x00, 0x00, 0xff, 0xff, 0x6a, 0x00, 0x00, 0x04, 0xff, 0xff,
    0x73, 0x60, 0x00, 0x04, 0x00, 0x00, 0xc4, 0xe0, 0x00, 0x04, 0x4c, 0x4d,
    0x54, 0x00, 0x4c, 0x49, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0a, 0x4c, 0x49, 0x4e, 0x54, 0x2d, 0x31, 0x34, 0x0a,
};

const char CHATHAM_DATA[] = {
    //Data from Pacific/Catham

    0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0xe7, 0x8b, 0xc2, 0x04,
    0x09, 0x18, 0xfd, 0xe0, 0x09, 0xac, 0xa5, 0xe0, 0x0a, 0xef, 0xa5, 0x60,
    0x0b, 0x9e, 0xfc, 0xe0, 0x0c, 0xd8, 0xc1, 0xe0, 0x0d, 0x7e, 0xde, 0xe0,
    0x0e, 0xb8, 0xa3, 0xe0, 0x0f, 0x5e, 0xc0, 0xe0, 0x10, 0x98, 0x85, 0xe0,
    0x11, 0x3e, 0xa2, 0xe0, 0x12, 0x78, 0x67, 0xe0, 0x13, 0x1e, 0x84, 0xe0,
    0x14, 0x58, 0x49, 0xe0, 0x14, 0xfe, 0x66, 0xe0, 0x16, 0x38, 0x2b, 0xe0,
    0x16, 0xe7, 0x83, 0x60, 0x18, 0x21, 0x48, 0x60, 0x18, 0xc7, 0x65, 0x60,
    0x1a, 0x01, 0x2a, 0x60, 0x1a, 0xa7, 0x47, 0x60, 0x1b, 0xe1, 0x0c, 0x60,
    0x1c, 0x87, 0x29, 0x60, 0x1d, 0xc0, 0xee, 0x60, 0x1e, 0x67, 0x0b, 0x60,
    0x1f, 0xa0, 0xd0, 0x60, 0x20, 0x46, 0xed, 0x60, 0x21, 0x80, 0xb2, 0x60,
    0x22, 0x30, 0x09, 0xe0, 0x23, 0x69, 0xce, 0xe0, 0x24, 0x0f, 0xeb, 0xe0,
    0x25, 0x2e, 0x01, 0x60, 0x26, 0x02, 0x42, 0xe0, 0x27, 0x0d, 0xe3, 0x60,
    0x27, 0xe2, 0x24, 0xe0, 0x28, 0xed, 0xc5, 0x60, 0x29, 0xc2, 0x06, 0xe0,
    0x2a, 0xcd, 0xa7, 0x60, 0x2b, 0xab, 0x23, 0x60, 0x2c, 0xad, 0x89, 0x60,
    0x2d, 0x8b, 0x05, 0x60, 0x2e, 0x8d, 0x6b, 0x60, 0x2f, 0x6a, 0xe7, 0x60,
    0x30, 0x6d, 0x4d, 0x60, 0x31, 0x4a, 0xc9, 0x60, 0x32, 0x56, 0x69, 0xe0,
    0x33, 0x2a, 0xab, 0x60, 0x34, 0x36, 0x4b, 0xe0, 0x35, 0x0a, 0x8d, 0x60,
    0x36, 0x16, 0x2d, 0xe0, 0x36, 0xf3, 0xa9, 0xe0, 0x37, 0xf6, 0x0f, 0xe0,
    0x38, 0xd3, 0x8b, 0xe0, 0x39, 0xd5, 0xf1, 0xe0, 0x3a, 0xb3, 0x6d, 0xe0,
    0x3b, 0xbf, 0x0e, 0x60, 0x3c, 0x93, 0x4f, 0xe0, 0x3d, 0x9e, 0xf0, 0x60,
    0x3e, 0x73, 0x31, 0xe0, 0x3f, 0x7e, 0xd2, 0x60, 0x40, 0x5c, 0x4e, 0x60,
    0x41, 0x5e, 0xb4, 0x60, 0x42, 0x3c, 0x30, 0x60, 0x43, 0x3e, 0x96, 0x60,
    0x44, 0x1c, 0x12, 0x60, 0x45, 0x1e, 0x78, 0x60, 0x45, 0xfb, 0xf4, 0x60,
    0x46, 0xfe, 0x5a, 0x60, 0x47, 0xf7, 0x85, 0xe0, 0x48, 0xde, 0x3c, 0x60,
    0x49, 0xd7, 0x67, 0xe0, 0x4a, 0xbe, 0x1e, 0x60, 0x4b, 0xb7, 0x49, 0xe0,
    0x4c, 0x9e, 0x00, 0x60, 0x4d, 0x97, 0x2b, 0xe0, 0x4e, 0x7d, 0xe2, 0x60,
    0x4f, 0x77, 0x0d, 0xe0, 0x50, 0x66, 0xfe, 0xe0, 0x51, 0x60, 0x2a, 0x60,
    0x52, 0x46, 0xe0, 0xe0, 0x53, 0x40, 0x0c, 0x60, 0x54, 0x26, 0xc2, 0xe0,
    0x55, 0x1f, 0xee, 0x60, 0x56, 0x06, 0xa4, 0xe0, 0x56, 0xff, 0xd0, 0x60,
    0x57, 0xe6, 0x86, 0xe0, 0x58, 0xdf, 0xb2, 0x60, 0x59, 0xc6, 0x68, 0xe0,
    0x5a, 0xbf, 0x94, 0x60, 0x5b, 0xaf, 0x85, 0x60, 0x5c, 0xa8, 0xb0, 0xe0,
    0x5d, 0x8f, 0x67, 0x60, 0x5e, 0x88, 0x92, 0xe0, 0x5f, 0x6f, 0x49, 0x60,
    0x60, 0x68, 0x74, 0xe0, 0x61, 0x4f, 0x2b, 0x60, 0x62, 0x48, 0x56, 0xe0,
    0x63, 0x2f, 0x0d, 0x60, 0x64, 0x28, 0x38, 0xe0, 0x65, 0x0e, 0xef, 0x60,
    0x66, 0x11, 0x55, 0x60, 0x66, 0xf8, 0x0b, 0xe0, 0x67, 0xf1, 0x37, 0x60,
    0x68, 0xd7, 0xed, 0xe0, 0x69, 0xd1, 0x19, 0x60, 0x6a, 0xb7, 0xcf, 0xe0,
    0x6b, 0xb0, 0xfb, 0x60, 0x6c, 0x97, 0xb1, 0xe0, 0x6d, 0x90, 0xdd, 0x60,
    0x6e, 0x77, 0x93, 0xe0, 0x6f, 0x70, 0xbf, 0x60, 0x70, 0x60, 0xb0, 0x60,
    0x71, 0x59, 0xdb, 0xe0, 0x72, 0x40, 0x92, 0x60, 0x73, 0x39, 0xbd, 0xe0,
    0x74, 0x20, 0x74, 0x60, 0x75, 0x19, 0x9f, 0xe0, 0x76, 0x00, 0x56, 0x60,
    0x76, 0xf9, 0x81, 0xe0, 0x77, 0xe0, 0x38, 0x60, 0x78, 0xd9, 0x63, 0xe0,
    0x79, 0xc0, 0x1a, 0x60, 0x7a, 0xb9, 0x45, 0xe0, 0x7b, 0xa9, 0x36, 0xe0,
    0x7c, 0xa2, 0x62, 0x60, 0x7d, 0x89, 0x18, 0xe0, 0x7e, 0x82, 0x44, 0x60,
    0x7f, 0x68, 0xfa, 0xe0, 0x03, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x00, 0x00, 0xab, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x5c, 0x01, 0x04,
    0x00, 0x00, 0xb3, 0x4c, 0x00, 0x0a, 0x00, 0x00, 0xb3, 0x4c, 0x00, 0x0a,
    0x4c, 0x4d, 0x54, 0x00, 0x43, 0x48, 0x41, 0x44, 0x54, 0x00, 0x43, 0x48,
    0x41, 0x53, 0x54, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0xff, 0xff, 0xff, 0xff,
    0xe7, 0x8b, 0xc2, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x18, 0xfd, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x09, 0xac, 0xa5, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x0a, 0xef, 0xa5, 0x60, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x9e, 0xfc, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x0c, 0xd8, 0xc1, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x0d, 0x7e, 0xde, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xb8, 0xa3, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x0f, 0x5e, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x98, 0x85, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x11, 0x3e, 0xa2, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x78, 0x67, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x1e, 0x84, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x14, 0x58, 0x49, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x14, 0xfe, 0x66, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x16, 0x38, 0x2b, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x16, 0xe7, 0x83, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x21, 0x48, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x18, 0xc7, 0x65, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x2a, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x1a, 0xa7, 0x47, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x1b, 0xe1, 0x0c, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x87, 0x29, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x1d, 0xc0, 0xee, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x1e, 0x67, 0x0b, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xa0, 0xd0, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x46, 0xed, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x21, 0x80, 0xb2, 0x60, 0x00, 0x00, 0x00, 0x00, 0x22, 0x30, 0x09, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x23, 0x69, 0xce, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x24, 0x0f, 0xeb, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x25, 0x2e, 0x01, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x26, 0x02, 0x42, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x27, 0x0d, 0xe3, 0x60, 0x00, 0x00, 0x00, 0x00, 0x27, 0xe2, 0x24, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x28, 0xed, 0xc5, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x29, 0xc2, 0x06, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x2a, 0xcd, 0xa7, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x2b, 0xab, 0x23, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x2c, 0xad, 0x89, 0x60, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x8b, 0x05, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x2e, 0x8d, 0x6b, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x2f, 0x6a, 0xe7, 0x60, 0x00, 0x00, 0x00, 0x00, 0x30, 0x6d, 0x4d, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x31, 0x4a, 0xc9, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x56, 0x69, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x33, 0x2a, 0xab, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x34, 0x36, 0x4b, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x35, 0x0a, 0x8d, 0x60, 0x00, 0x00, 0x00, 0x00, 0x36, 0x16, 0x2d, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x36, 0xf3, 0xa9, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x37, 0xf6, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x38, 0xd3, 0x8b, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x39, 0xd5, 0xf1, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x3a, 0xb3, 0x6d, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3b, 0xbf, 0x0e, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x3c, 0x93, 0x4f, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x3d, 0x9e, 0xf0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x73, 0x31, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0x7e, 0xd2, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x5c, 0x4e, 0x60, 0x00, 0x00, 0x00, 0x00, 0x41, 0x5e, 0xb4, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x42, 0x3c, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x43, 0x3e, 0x96, 0x60, 0x00, 0x00, 0x00, 0x00, 0x44, 0x1c, 0x12, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x45, 0x1e, 0x78, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x45, 0xfb, 0xf4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x46, 0xfe, 0x5a, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x47, 0xf7, 0x85, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x48, 0xde, 0x3c, 0x60, 0x00, 0x00, 0x00, 0x00, 0x49, 0xd7, 0x67, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x4a, 0xbe, 0x1e, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x4b, 0xb7, 0x49, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x9e, 0x00, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x4d, 0x97, 0x2b, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x4e, 0x7d, 0xe2, 0x60, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x77, 0x0d, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x50, 0x66, 0xfe, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x60, 0x2a, 0x60, 0x00, 0x00, 0x00, 0x00, 0x52, 0x46, 0xe0, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x53, 0x40, 0x0c, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x54, 0x26, 0xc2, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x55, 0x1f, 0xee, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x56, 0x06, 0xa4, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x56, 0xff, 0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x57, 0xe6, 0x86, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x58, 0xdf, 0xb2, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x59, 0xc6, 0x68, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xbf, 0x94, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x5b, 0xaf, 0x85, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0xa8, 0xb0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x8f, 0x67, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x5e, 0x88, 0x92, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x5f, 0x6f, 0x49, 0x60, 0x00, 0x00, 0x00, 0x00, 0x60, 0x68, 0x74, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x61, 0x4f, 0x2b, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x62, 0x48, 0x56, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x63, 0x2f, 0x0d, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x64, 0x28, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x65, 0x0e, 0xef, 0x60, 0x00, 0x00, 0x00, 0x00, 0x66, 0x11, 0x55, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x66, 0xf8, 0x0b, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x67, 0xf1, 0x37, 0x60, 0x00, 0x00, 0x00, 0x00, 0x68, 0xd7, 0xed, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x69, 0xd1, 0x19, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x6a, 0xb7, 0xcf, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x6b, 0xb0, 0xfb, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x6c, 0x97, 0xb1, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x6d, 0x90, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x77, 0x93, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x6f, 0x70, 0xbf, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x60, 0xb0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x71, 0x59, 0xdb, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x72, 0x40, 0x92, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x73, 0x39, 0xbd, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x74, 0x20, 0x74, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x75, 0x19, 0x9f, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x76, 0x00, 0x56, 0x60, 0x00, 0x00, 0x00, 0x00, 0x76, 0xf9, 0x81, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x77, 0xe0, 0x38, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xd9, 0x63, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x79, 0xc0, 0x1a, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x7a, 0xb9, 0x45, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x7b, 0xa9, 0x36, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xa2, 0x62, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x7d, 0x89, 0x18, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x7e, 0x82, 0x44, 0x60, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x68, 0xfa, 0xe0,
    0x03, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00, 0xab, 0xfc,
    0x00, 0x00, 0x00, 0x00, 0xc1, 0x5c, 0x01, 0x04, 0x00, 0x00, 0xb3, 0x4c,
    0x00, 0x0a, 0x00, 0x00, 0xb3, 0x4c, 0x00, 0x0a, 0x4c, 0x4d, 0x54, 0x00,
    0x43, 0x48, 0x41, 0x44, 0x54, 0x00, 0x43, 0x48, 0x41, 0x53, 0x54, 0x00,
    0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x43, 0x48, 0x41,
    0x53, 0x54, 0x2d, 0x31, 0x32, 0x3a, 0x34, 0x35, 0x43, 0x48, 0x41, 0x44,
    0x54, 0x2c, 0x4d, 0x39, 0x2e, 0x35, 0x2e, 0x30, 0x2f, 0x32, 0x3a, 0x34,
    0x35, 0x2c, 0x4d, 0x34, 0x2e, 0x31, 0x2e, 0x30, 0x2f, 0x33, 0x3a, 0x34,
    0x35, 0x0a,
};

const char ASIA_BANGKOK_DATA[] = {
    // Data from Asia/Bangkok.

    0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0xa2, 0x6a, 0x67, 0xc4,
    0x01, 0x00, 0x00, 0x5e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x62, 0x70, 0x00,
    0x04, 0x42, 0x4d, 0x54, 0x00, 0x49, 0x43, 0x54, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xff, 0xff,
    0xff, 0x56, 0xb6, 0x85, 0xc4, 0xff, 0xff, 0xff, 0xff, 0xa2, 0x6a, 0x67,
    0xc4, 0x01, 0x02, 0x00, 0x00, 0x5e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x5e,
    0x3c, 0x00, 0x04, 0x00, 0x00, 0x62, 0x70, 0x00, 0x08, 0x4c, 0x4d, 0x54,
    0x00, 0x42, 0x4d, 0x54, 0x00, 0x49, 0x43, 0x54, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0a, 0x49, 0x43, 0x54, 0x2d, 0x37, 0x0a
};

const char TEST_DATA[] = {
    // Expected data for test case 2.

    0x54, 0x5a, 0x69, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// TYPEDEFS
typedef baetzo_ZoneinfoBinaryReader Obj;
typedef baetzo_ZoneinfoBinaryHeader BinHeader;
typedef baetzo_LocalTimeDescriptor  Desc;

class RawHeader;
class RawLocalTimeTypes;
class ZoneinfoData;

static int verifyTimeZone(const ZoneinfoData&    data,
                          const baetzo_Zoneinfo& timeZone,
                          int                    line,
                          bool                   expectToFail = false);
    // Validate description of a time zone based on the specified 'timeZone' is
    // the same as the description based on the specified 'data', and output an
    // error message containing the line number indicated by the specified
    // 'line' when the validation failed.  Optionally, specified 'expectToFail'
    // indicating whether there is a difference between 'timeZone' and 'data.
    // If 'expectToFail' is 'true', 'verifyTimeZone' will not 'ASSERT',
    // otherwise, 'verifyTimeZone' will 'ASSERT' at the location that an error
    // is detected.  The behavior is undefined unless 'data' contains valid
    // Zoneinfo binary data in the buffer.  Return 0 if the validation succeed,
    // and a non-zero value otherwise.

static void writeBigEndian(char *address, int value);
    // Write the specified 'value' into the memory at the specified 'address in
    // big-endian format.

static int readBigEndian(const char *address);
    // Read from the memory at the specified 'address' containing an integer
    // in big-endian format, and return the value of the integer.

// ============================================================================
//               GLOBAL HELPER CLASSES AND FUNCTIONS FOR TESTING
// ----------------------------------------------------------------------------
static void writeBigEndian(char *address, int value)
{
    int hostValue = BSLS_BYTEORDER_HOST_U32_TO_BE(value);
    memcpy(address, &hostValue, sizeof hostValue);
}

// ----------------------------------------------------------------------------

static int readBigEndian(const char *address)
{
    int value;
    memcpy(&value, address, sizeof value);
    return BSLS_BYTEORDER_BE_U32_TO_HOST(value);
}

                        // ===============
                        // class RawHeader
                        // ===============

class RawHeader {
    // The byte sequence of the header of a Zoneinfo binary data format.

    // DATA
    char d_headerId[4];           // must be 'EXPECTED_HEADER_ID'
    char d_version[1];            // must be '\0' or '2' (as of 2005)
    char d_reserved[15];          // unused
    char d_numIsGmt[4];           // number of encoded UTC/local indicators
    char d_numIsStd[4];           // number of encoded standard/wall indicators
    char d_numLeaps[4];           // number of leap info's encoded in the file
    char d_numTransitions[4];     // number of transition times
    char d_numLocalTimeTypes[4];  // number of transition types
    char d_abbrevDataSize[4];     // size of the sequence of abbreviation chars

  public:
    // CREATORS
    RawHeader();
        // Create a Zoneinfo binary header with the properties:
        //..
        // version           == '\0'
        // numIsGmt          == 0
        // numIsStd          == 0
        // numLeaps          == 0
        // numTransitions    == 0
        // numLocalTimeTypes == 1
        // abbrevDataSize    == 1
        //..

    // MANIPULATORS
    void setHeaderId(int index, char value);
        // Set the character at the specified 'index' of the header identifier
        // to the specified 'value'.

    void setVersion(char value);
        // Set the value of the version to the specified 'value'.

    void setNumIsGmt(int value);
        // Set the number of 'isGmt' flag to the specified 'value'.  Note that
        // the value is stored in big-endian format.

    void setNumIsStd(int value);
        // Set the number of 'isStd' flag to the specified 'value'.  Note that
        // the value is stored in big-endian format.

    void setNumLeaps(int value);
        // Set the number of leap corrections to the specified 'value'.  Note
        // that the value is stored in big-endian format.

    void setNumTransitions(int value);
        // Set the number of transitions to the specified 'value'.  Note that
        // the value is stored in big-endian format.

    void setNumLocalTimeTypes(int value);
        // Set the number of local time types to the specified 'value'.  Note
        // that the value is stored in big-endian format.

    void setAbbrevDataSize(int value);
        // Set the number of local time types to the specified 'value'.  Note
        // that the value is stored in big-endian format.

    // ACCESSORS
    char version() const;
        // Return the value of 'version' of this object.

    int numIsGmt() const;
        // Return the value of 'numIsGmt' of this object.

    int numIsStd() const;
        // Return the value of 'numIsStd' of this object.

    int numLeaps() const;
        // Return the value of 'numLeaps' of this object.

    int numTransitions() const;
        // Return the value of 'numTransitions' of this object.

    int numLocalTimeTypes() const;
        // Return the value of 'numLocalTimeTypes' of this object.

    int abbrevDataSize() const;
        // Return the value of 'abbrevDataSize' of this object.

};

BSLMF_ASSERT(44 == sizeof(RawHeader));

                        // ---------------
                        // class RawHeader
                        // ---------------
// CREATORS
RawHeader::RawHeader()
{
    memset(this, 0, sizeof *this);
    d_headerId[0] = 'T';
    d_headerId[1] = 'Z';
    d_headerId[2] = 'i';
    d_headerId[3] = 'f';
    setNumLocalTimeTypes(1);
    setAbbrevDataSize(1);
}

// MANIPULATORS
void RawHeader::setHeaderId(int index, char value)
{
    d_headerId[index] = value;
}

void RawHeader::setVersion(char value)
{
    *d_version = value;
}

void RawHeader::setNumIsGmt(int value)
{
    writeBigEndian(d_numIsGmt, value);
}

void RawHeader::setNumIsStd(int value)
{
    writeBigEndian(d_numIsStd, value);
}

void RawHeader::setNumLeaps(int value)
{
    writeBigEndian(d_numLeaps, value);
}

void RawHeader::setNumTransitions(int value)
{
    writeBigEndian(d_numTransitions, value);
}

void RawHeader::setNumLocalTimeTypes(int value)
{
    writeBigEndian(d_numLocalTimeTypes, value);
}

void RawHeader::setAbbrevDataSize(int value)
{
    writeBigEndian(d_abbrevDataSize, value);
}

// ACCESSORS
char RawHeader::version() const
{
    return *d_version;
}

int RawHeader::numIsGmt() const
{
    return readBigEndian(d_numIsGmt);
}

int RawHeader::numIsStd() const
{
    return readBigEndian(d_numIsStd);
}

int RawHeader::numLeaps() const
{
    return readBigEndian(d_numLeaps);
}

int RawHeader::numTransitions() const
{
    return readBigEndian(d_numTransitions);
}

int RawHeader::numLocalTimeTypes() const
{
    return readBigEndian(d_numLocalTimeTypes);
}

int RawHeader::abbrevDataSize() const
{
    return readBigEndian(d_abbrevDataSize);
}

                        // =======================
                        // class RawLocalTimeTypes
                        // =======================

class RawLocalTimeTypes {
    // The byte sequence of a local-time type in a Zoneinfo binary data format.

    // DATA
    char          d_offset[4];          // UTC offset in number of seconds
    unsigned char d_isDst;              // indicates whether local time is DST
    unsigned char d_abbreviationIndex;  // index to abbreviation string

  public:
    // MANIPULATORS
    void setOffset(int value);
        // Set the value of 'offset' to the specified 'value'.  Note that the
        // value will be stored in big-endian format.

    void setIsDst(unsigned char value);
        // Set the value of 'isDst' flag to the specified 'value'.

    void setAbbreviationIndex(unsigned char value);
        // Set the value of 'abbreviationIndex' to the specified 'value'.

    // ACCESSORS
    int offset() const;
        // Return the value of 'offset' of this object.

    unsigned char isDst() const;
        // Return the value of 'isDst' of this object.

    unsigned char abbreviationIndex() const;
        // Return the value of 'abbreviationIndex' of this object.
};

BSLMF_ASSERT(6 == sizeof(RawLocalTimeTypes));

                        // -----------------------
                        // class RawLocalTimeTypes
                        // -----------------------

// MANIPULATORS
void RawLocalTimeTypes::setOffset(int value)
{
    writeBigEndian(d_offset, value);
}

void RawLocalTimeTypes::setIsDst(unsigned char value)
{
    d_isDst = value;
}

void RawLocalTimeTypes::setAbbreviationIndex(unsigned char value)
{
    d_abbreviationIndex = value;
}

// ACCESSORS
int RawLocalTimeTypes::offset() const
{
    return readBigEndian(d_offset);
}

unsigned char RawLocalTimeTypes::isDst() const
{
    return d_isDst;
}

unsigned char RawLocalTimeTypes::abbreviationIndex() const
{
    return d_abbreviationIndex;
}

                        // =================
                        // class RawLeapInfo
                        // =================

class RawLeapInfo {
    // The byte sequence of a leap correction in a Zoneinfo binary data format.

    // DATA
    char d_transition[4];  // POSIX time at which the leap second occur
    char d_correction[4];  // accumulated leap correction

  public:
    // MANIPULATORS
    void setTransition(int value);
        // Set the value of 'transition' to the specified 'value'.  Note that
        // the value will be stored in big-endian format.

    void setCorrection(int value);
        // Set the value of 'correction' to the specified 'value'.  Note that
        // the value will be stored in big-endian format.

    // ACCESSORS
    int transition() const;
        // Return the value of 'transition' of this object.

    int correction() const;
        // Return the value of 'correction' of this object.
};

                        // -----------------
                        // class RawLeapInfo
                        // -----------------

// MANIPULATORS
void RawLeapInfo::setTransition(int value)
{
    writeBigEndian(d_transition, value);
}

void RawLeapInfo::setCorrection(int value)
{
    writeBigEndian(d_correction, value);
}

// ACCESSORS
int RawLeapInfo::transition() const
{
    return readBigEndian(d_transition);
}

int RawLeapInfo::correction() const
{
    return readBigEndian(d_correction);
}

                        // ==================
                        // class ZoneinfoData
                        // ==================

class ZoneinfoData {
    // This class provides methods to create and store a Zoneinfo binary data
    // format.

    // DATA
    char *d_buffer;  // buffer to store Zoneinfo binary data
    int   d_size;    // size of 'd_buffer'

    // PRIVATE MANIPULATORS
    void populateTransitionTimeBuf();
        // Populate the transition times of Zoneinfo binary data.  A valid
        // header is assumed to exist in 'd_buffer' and the number of
        // transitions can be found in the header.  The transition times starts
        // at 0 and increase by 1 for each subsequent transition.

    void populateTransitionIndexBuf();
        // Populate the index to local time types for each transition.  A valid
        // header is assumed to exist in 'd_buffer' and the number of indexes
        // can be found in the header.  The indexes starts at 0, increase by 1
        // for each subsequent transition, and restarts at 0 when the indexes
        // is equal to the number of local time types.

    void populateLeapCorrectionBuf();
        // Populate the leap correction information of Zoneinfo binary data.  A
        // valid header is assumed to exist in 'd_buffer' and the number of
        // leap corrections can be found in the header.  The leap-correction
        // times starts at 0, increase by 1 for each subsequent correction.
        // Each leap correction increases the accumulated leap correction by 1.

    void populateLocalTimeTypeBuf();
        // Populate the local time type portion of the Zoneinfo binary data.  A
        // valid header is assumed to exist in 'd_buffer' and the number of
        // local-time types can be found in the header.  The first local time
        // type has an offset from UTC of 0 seconds, isDst of 'false' and
        // abbreviation data index of 0.  Subsequent local time type increments
        // the offset and abbreviation data index by 1, and alternate between
        // 'true' and 'false' for isDst settings.

    void populateAbbreviationData();
        // Populate the abbreviation part of the Zoneinfo binary data.  A valid
        // header is assumed to exist in 'd_buffer' and the abbreviation data
        // size can be found in the header.  The abbreviation data will be
        // filled with '\0' character.

    void populateBuffer(const RawHeader& header);
        // Populate 'd_buffer' with synthetic Zoneinfo binary data that matches
        // the file description of the specified 'header.  This function will
        // call all the other 'populate*' functions to fill the buffer with
        // data.

  public:
    // CREATORS
    ZoneinfoData();
        // Create a 'ZoneinfoData' object with the smallest possible valid
        // Zoneinfo binary data.  This object will have the properties:
        //..
        // version           == '\0'
        // numIsGmt          == 0
        // numIsStd          == 0
        // numLeaps          == 0
        // numTransitions    == 0
        // numLocalTimeTypes == 1
        // abbrevDataSize    == 1
        //..
        // The created object will contain a valid Zoneinfo binary data in the
        // buffer.  The local time type will have an offset from UTC of 0,
        // DST is *not* in effect and an abbreviation index of 0.

    ZoneinfoData(const RawHeader& header);
        // Create a 'ZoneinfoData' object with Zoneinfo binary data that
        // matches the file description supplied by the specified 'header'.
        // The created object will contain a valid Zoneinfo binary data in the
        // buffer.  The buffer describes a time zone with the properties:
        //
        //: o Transition times -- starts from 0 and increment by 1 for each
        //:   subsequent transition.
        //:
        //: o Transition indexes -- starts from 0 and increment by 1 for each
        //:   subsequent transition.  Restart from 0 when the index equals to
        //:   the number of local time types.
        //:
        //: o Leap correction -- the time of leap-correction
        //:   times starts at 0, increase by 1 for each subsequent correction.
        //:   Each leap correction increases the accumulated leap correction by
        //:   1.
        //:
        //: o Abbreviation data -- filled with '\0'.

    ZoneinfoData(const char *data, bsl::size_t size);
        // Create a 'ZoneinfoData' object by duplicating the specified 'data'
        // with the specified 'size' into the buffer.  'data' is assumed to
        // contain Zoneinfo binary data.

    ~ZoneinfoData();
        // Destroy this object.

    // ACCESSORS
    char *buffer() const;
        // Return the address of the buffer containing the Zoneinfo data.

    int size() const;
        // Return the size of the buffer containing the Zoneinfo data.

    RawHeader *getRawHeader() const;
        // Return the address of the portion in the buffer containing header
        // information.

    bdeut_BigEndianInt32 *getTransitionTime() const;
        // Return the address of the portion in the buffer containing the times
        // of transitions.

    unsigned char *getTransitionIndex() const;
        // Return the address of the portion in the buffer containing the
        // indexes to local time types for each transition.

    RawLeapInfo *getRawLeapInfo() const;
        // Return the address of the portion in the buffer containing leap
        // correction information.

    RawLocalTimeTypes *getRawLocalTimeTypes() const;
        // Return the address of the portion in the buffer containing local
        // time type information.

    char *getAbbrevData() const;
        // Return the address of the portion in the buffer containing
        // abbreviation string data.
};

                        // ------------------
                        // class ZoneinfoData
                        // ------------------

// PRIVATE MANIPULATORS
void ZoneinfoData::populateBuffer(const RawHeader& header)
{
    d_size = sizeof(RawHeader)
             + header.numIsGmt() * 1
             + header.numIsStd() * 1
             + header.numLeaps() * sizeof(RawLeapInfo)
             + header.numTransitions() * (4 + 1)
             + header.numLocalTimeTypes() * sizeof(RawLocalTimeTypes)
             + header.abbrevDataSize();
    if ('2' == header.version()) {
        d_size += sizeof(RawHeader)
                  + header.numIsGmt() * 1
                  + header.numIsStd() * 1
                  + header.numLeaps() * sizeof(RawLeapInfo)
                  + header.numLeaps() * 4
                  + header.numTransitions() * (8 + 1)
                  + header.numLocalTimeTypes() * sizeof(RawLocalTimeTypes)
                  + header.abbrevDataSize();
    }
    d_buffer = new char[d_size];
    memset(d_buffer, 0, d_size);

    RawHeader *headerBuf = getRawHeader();
    memcpy(headerBuf, &header, sizeof *headerBuf);

    populateTransitionTimeBuf();
    populateTransitionIndexBuf();
    populateLeapCorrectionBuf();
    populateLocalTimeTypeBuf();
    populateAbbreviationData();
}

void ZoneinfoData::populateTransitionTimeBuf()
{
    bdeut_BigEndianInt32 *buffer = getTransitionTime();
    for (int i = 0; i < getRawHeader()->numTransitions(); ++i) {
        buffer[i] = i;
    }
}

void ZoneinfoData::populateTransitionIndexBuf()
{
    unsigned char *buffer = getTransitionIndex();
    for (int i = 0; i < getRawHeader()->numTransitions(); ++i) {
        buffer[i] = i % getRawHeader()->numLocalTimeTypes();
    }
}

void ZoneinfoData::populateLeapCorrectionBuf()
{
    RawLeapInfo *buffer = getRawLeapInfo();
    for (int i = 0; i < getRawHeader()->numLeaps(); ++i) {
        buffer[i].setTransition(i);
        buffer[i].setCorrection(i);
    }
}

void ZoneinfoData::populateLocalTimeTypeBuf()
{
    RawLocalTimeTypes *buffer = getRawLocalTimeTypes();
    for (int i = 0; i < getRawHeader()->numLocalTimeTypes(); ++i) {
        buffer[i].setOffset(i);
        buffer[i].setIsDst(i % 2);
        buffer[i].setAbbreviationIndex(i % getRawHeader()->abbrevDataSize());
    }
}

void ZoneinfoData::populateAbbreviationData()
{
    char *buffer = getAbbrevData();
    memset(buffer, 0, getRawHeader()->abbrevDataSize());
}

// CREATORS
ZoneinfoData::ZoneinfoData()
{
    RawHeader header;
    populateBuffer(header);
}

ZoneinfoData::ZoneinfoData(const RawHeader& header)
{
    populateBuffer(header);
}

ZoneinfoData::ZoneinfoData(const char *data, bsl::size_t size)
{
    d_buffer = new char[size];
    memcpy(d_buffer, data, size);
}

ZoneinfoData::~ZoneinfoData()
{
    delete[](d_buffer);
}

// ACCESSORS
char *ZoneinfoData::buffer() const
{
    return d_buffer;
}

int ZoneinfoData::size() const
{
    return d_size;
}

RawHeader *ZoneinfoData::getRawHeader() const
{
    return reinterpret_cast<RawHeader*>(&d_buffer[0]);
}

bdeut_BigEndianInt32 *ZoneinfoData::getTransitionTime() const
{
    return
         reinterpret_cast<bdeut_BigEndianInt32*>(&d_buffer[sizeof(RawHeader)]);
}

unsigned char *ZoneinfoData::getTransitionIndex() const
{
    return reinterpret_cast<unsigned char *>(
          &d_buffer[sizeof(RawHeader) + getRawHeader()->numTransitions() * 4]);
}

RawLeapInfo *ZoneinfoData::getRawLeapInfo() const
{
    return reinterpret_cast<RawLeapInfo*>(
         &d_buffer[sizeof(RawHeader)
         + getRawHeader()->numTransitions() * 4
         + getRawHeader()->numTransitions()
         + getRawHeader()->numLocalTimeTypes() * sizeof(RawLocalTimeTypes)
         + getRawHeader()->abbrevDataSize()]);
}

RawLocalTimeTypes *ZoneinfoData::getRawLocalTimeTypes() const
{
    return reinterpret_cast<RawLocalTimeTypes*>(
                  &d_buffer[sizeof(RawHeader)
                            + getRawHeader()->numTransitions() * 4
                            + getRawHeader()->numTransitions()]);
}

char *ZoneinfoData::getAbbrevData() const
{
    return &d_buffer[
            sizeof(RawHeader)
            + getRawHeader()->numTransitions() * 4
            + getRawHeader()->numTransitions()
            + getRawHeader()->numLocalTimeTypes() * sizeof(RawLocalTimeTypes)];
}

// ----------------------------------------------------------------------------

static int verifyTimeZone(const ZoneinfoData&    data,
                            const baetzo_Zoneinfo& timeZone,
                            int                    line,
                            bool                   expectToFail)
{

    const int LINE = line;
    const baetzo_Zoneinfo& X = timeZone;

    RawHeader *H = data.getRawHeader();

    char *abbrevDataBuf = data.getAbbrevData();

    RawLocalTimeTypes *localTimeTypeBuf = data.getRawLocalTimeTypes();

    // An extra transition is created for to handle time earlier than the first
    // transition.

    if (H->numTransitions() != X.numTransitions() - 1) {
        if (!expectToFail) {
            LOOP3_ASSERT(LINE, H->numTransitions(), X.numTransitions() - 1,
                        H->numTransitions() == X.numTransitions() - 1);
        }
        return 1;
    }

    baetzo_Zoneinfo::TransitionConstIterator XT = X.beginTransitions();
    if (FIRST_TRANSITION != XT->utcTime()) {
        if (!expectToFail) {
            LOOP2_ASSERT(LINE, XT->utcTime(),
                         FIRST_TRANSITION == XT->utcTime());
        }
        return 2;
    }

    ++XT;

    bdeut_BigEndianInt32 *transitionTimeBuf = data.getTransitionTime();
    unsigned char *transitionIndexBuf = data.getTransitionIndex();
    for (int i = 0; i < H->numTransitions(); ++i) {
        if (X.endTransitions() == XT) {
            if (!expectToFail) {
                LOOP_ASSERT(LINE, X.endTransitions() != XT);
            }
            return 3;
        }

        int TT = *transitionTimeBuf;
        if (TT != XT->utcTime()) {
            if (!expectToFail) {
                LOOP4_ASSERT(LINE, i, TT, XT->utcTime(),
                             TT == XT->utcTime());
            }
            return 4;
        }

        int index = transitionIndexBuf[i];

        baetzo_LocalTimeDescriptor D(
                  localTimeTypeBuf[index].offset(),
                  localTimeTypeBuf[index].isDst(),
                  &abbrevDataBuf[localTimeTypeBuf[index].abbreviationIndex()]);

        if (D != XT->descriptor()) {
            if (!expectToFail) {
                LOOP4_ASSERT(LINE, i, D, XT->descriptor(),
                             D == XT->descriptor());
            }
            return 5;
        }

        ++XT;
        ++transitionTimeBuf;
    }

    return 0;
}

// ----------------------------------------------------------------------------

static int testVerifyTimeZone(int verbose)
    // Run ad-hoc tests on the 'verifyTimeZone' function.  The tests will be
    // based on a Zoneinfo with 5 transitions and 3 local time types.
    // 'verifyTimeZone' will be called on various 'baetzo_Zoneinfo' objects
    // and the return code will be verified.  Return 0 if all the tests passed,
    // and a non-zero value otherwise.
{
    // Create a table of transition time.

    const int TRANSITION_TIMES[] = {
        INT_MIN,
        -1,
        0,
        1,
        INT_MAX
    };

    const int NUM_TRANSITION_TIME =
                            sizeof TRANSITION_TIMES / sizeof *TRANSITION_TIMES;

    static const struct {
        int           d_offset;
        unsigned char d_dstFlag;
        unsigned char d_abbrevIndex;
    } LOCAL_TIME_TYPES[] = {

    // OFFSET  DST_FLAG  AB_INDEX
    // ------  --------  --------

    {  -86399,        0,        0 },
    {       0,        1,        1 },
    {   86399,        0,        3 }

    };

    const int NUM_LOCAL_TIME_TYPES =
                            sizeof LOCAL_TIME_TYPES / sizeof *LOCAL_TIME_TYPES;

    const char AB_DATA[] = "\0A\0AB\0";
    const int  AB_DATA_SIZE = sizeof AB_DATA / sizeof *AB_DATA;

    // Create 'ZoneinfoData'

    RawHeader RH;
    RH.setVersion('\0');
    RH.setNumIsGmt(NUM_LOCAL_TIME_TYPES);
    RH.setNumIsStd(NUM_LOCAL_TIME_TYPES);
    RH.setNumTransitions(NUM_TRANSITION_TIME);
    RH.setNumLocalTimeTypes(NUM_LOCAL_TIME_TYPES);
    RH.setAbbrevDataSize(AB_DATA_SIZE);

    ZoneinfoData ZI(RH);

    bdeut_BigEndianInt32 *transitions = ZI.getTransitionTime();
    for (int i = 0; i < NUM_TRANSITION_TIME; ++i) {
        transitions[i] = TRANSITION_TIMES[i];
    }

    RawLocalTimeTypes *localTimeTypes = ZI.getRawLocalTimeTypes();
    for (int i = 0; i < NUM_TRANSITION_TIME; ++i) {
        localTimeTypes[i].setOffset(LOCAL_TIME_TYPES[i].d_offset);
        localTimeTypes[i].setIsDst(LOCAL_TIME_TYPES[i].d_dstFlag);
        localTimeTypes[i].setAbbreviationIndex(
                                            LOCAL_TIME_TYPES[i].d_abbrevIndex);
    }

    char *buffer = ZI.getAbbrevData();
    memcpy(buffer, AB_DATA, AB_DATA_SIZE);

    baetzo_LocalTimeDescriptor D[NUM_LOCAL_TIME_TYPES];
    for (int i = 0; i < NUM_LOCAL_TIME_TYPES; ++i) {
        D[i].setUtcOffsetInSeconds(LOCAL_TIME_TYPES[i].d_offset);
        D[i].setDstInEffectFlag(LOCAL_TIME_TYPES[i].d_dstFlag);
        D[i].setDescription(&AB_DATA[LOCAL_TIME_TYPES[i].d_abbrevIndex]);
    }

    if (verbose) cout << "\nCorrect Zoneinfo" << endl;
    {
        baetzo_Zoneinfo TZ;
        TZ.addTransition(FIRST_TRANSITION, D[0]);
        TZ.addTransition(TRANSITION_TIMES[0], D[0]);
        TZ.addTransition(TRANSITION_TIMES[1], D[1]);
        TZ.addTransition(TRANSITION_TIMES[2], D[2]);
        TZ.addTransition(TRANSITION_TIMES[3], D[0]);
        TZ.addTransition(TRANSITION_TIMES[4], D[1]);

        ASSERT(0 == verifyTimeZone(ZI, TZ, L_, false));
    }

    if (verbose) cout << "\nMissing transition at 'Jan 1, 1'" << endl;
    {
        baetzo_Zoneinfo TZ;
        TZ.addTransition(TRANSITION_TIMES[0], D[0]);
        TZ.addTransition(TRANSITION_TIMES[1], D[1]);
        TZ.addTransition(TRANSITION_TIMES[2], D[2]);
        TZ.addTransition(TRANSITION_TIMES[3], D[0]);
        TZ.addTransition(TRANSITION_TIMES[4], D[1]);

        ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
    }

    if (verbose) cout << "\nIncorrect first transition" << endl;
    {
        baetzo_Zoneinfo TZ;
        TZ.addTransition(FIRST_TRANSITION + 1, D[0]);
        TZ.addTransition(TRANSITION_TIMES[0], D[0]);
        TZ.addTransition(TRANSITION_TIMES[1], D[1]);
        TZ.addTransition(TRANSITION_TIMES[2], D[2]);
        TZ.addTransition(TRANSITION_TIMES[3], D[0]);
        TZ.addTransition(TRANSITION_TIMES[4], D[1]);

        ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
    }

    if (verbose) cout << "\nMissing one transition" << endl;
    {
        baetzo_Zoneinfo TZ;
        TZ.addTransition(FIRST_TRANSITION, D[0]);
        TZ.addTransition(TRANSITION_TIMES[0], D[0]);
        TZ.addTransition(TRANSITION_TIMES[1], D[1]);
        TZ.addTransition(TRANSITION_TIMES[2], D[2]);

        ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
    }

    if (verbose) cout << "\nOne extra transition" << endl;
    {
        baetzo_Zoneinfo TZ;
        TZ.addTransition(FIRST_TRANSITION, D[0]);
        TZ.addTransition(TRANSITION_TIMES[0],     D[0]);
        TZ.addTransition(TRANSITION_TIMES[1],     D[1]);
        TZ.addTransition(TRANSITION_TIMES[2],     D[2]);
        TZ.addTransition(TRANSITION_TIMES[3],     D[0]);
        TZ.addTransition(TRANSITION_TIMES[4] - 1, D[1]);
        TZ.addTransition(TRANSITION_TIMES[4],     D[1]);

        ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
    }

    if (verbose) cout << "\nIncorrect transition data" << endl;
    {
        {
            baetzo_Zoneinfo TZ;
            TZ.addTransition(FIRST_TRANSITION, D[0]);
            TZ.addTransition(TRANSITION_TIMES[0] + 1, D[0]);
            TZ.addTransition(TRANSITION_TIMES[1],     D[1]);
            TZ.addTransition(TRANSITION_TIMES[2],     D[2]);
            TZ.addTransition(TRANSITION_TIMES[3],     D[0]);
            TZ.addTransition(TRANSITION_TIMES[4],     D[1]);

            ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
        }
        {
            baetzo_Zoneinfo TZ;
            TZ.addTransition(FIRST_TRANSITION, D[0]);
            TZ.addTransition(TRANSITION_TIMES[0],     D[0]);
            TZ.addTransition(TRANSITION_TIMES[1] - 1, D[1]);
            TZ.addTransition(TRANSITION_TIMES[2],     D[2]);

            ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
        }
        {
            baetzo_Zoneinfo TZ;
            TZ.addTransition(FIRST_TRANSITION, D[0]);
            TZ.addTransition(TRANSITION_TIMES[0],     D[0]);
            TZ.addTransition(TRANSITION_TIMES[1],     D[1]);
            TZ.addTransition(TRANSITION_TIMES[2] - 1, D[2]);
            TZ.addTransition(TRANSITION_TIMES[3],     D[0]);
            TZ.addTransition(TRANSITION_TIMES[4],     D[1]);

            ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
        }
    }

    if (verbose) cout << "\nIncorrect index to local time descriptor" << endl;
    {
        baetzo_Zoneinfo TZ;
        TZ.addTransition(FIRST_TRANSITION, D[0]);
        TZ.addTransition(TRANSITION_TIMES[0], D[0]);
        TZ.addTransition(TRANSITION_TIMES[1], D[1]);
        TZ.addTransition(TRANSITION_TIMES[2], D[2]);
        TZ.addTransition(TRANSITION_TIMES[3], D[0]);
        TZ.addTransition(TRANSITION_TIMES[4], D[0]);

        ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
    }

    if (verbose) cout << "\nIncorrect local time descriptor data" << endl;
    {
        {
            baetzo_Zoneinfo TZ;
            baetzo_LocalTimeDescriptor dError(-1, 0, "");
            TZ.addTransition(FIRST_TRANSITION, D[0]);
            TZ.addTransition(TRANSITION_TIMES[0], dError);
            TZ.addTransition(TRANSITION_TIMES[1], D[1]);
            TZ.addTransition(TRANSITION_TIMES[2], D[2]);
            TZ.addTransition(TRANSITION_TIMES[3], D[0]);
            TZ.addTransition(TRANSITION_TIMES[4], D[1]);

            ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
        }
        {
            baetzo_Zoneinfo TZ;
            baetzo_LocalTimeDescriptor dError(1, 2, "A");
            TZ.addTransition(FIRST_TRANSITION, D[0]);
            TZ.addTransition(TRANSITION_TIMES[0], D[0]);
            TZ.addTransition(TRANSITION_TIMES[1], dError);
            TZ.addTransition(TRANSITION_TIMES[2], D[2]);
            TZ.addTransition(TRANSITION_TIMES[3], D[0]);
            TZ.addTransition(TRANSITION_TIMES[4], D[1]);

            ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
        }
        {
            baetzo_Zoneinfo TZ;
            baetzo_LocalTimeDescriptor dError(1, 1, "A");
            TZ.addTransition(FIRST_TRANSITION, D[0]);
            TZ.addTransition(TRANSITION_TIMES[0], D[0]);
            TZ.addTransition(TRANSITION_TIMES[1], D[1]);
            TZ.addTransition(TRANSITION_TIMES[2], D[2]);
            TZ.addTransition(TRANSITION_TIMES[3], D[0]);
            TZ.addTransition(TRANSITION_TIMES[4], dError);

            ASSERT(0 != verifyTimeZone(ZI, TZ, L_, true));
        }
    }
    return 0;
}

// ============================================================================
//                              MAIN PROGRAM
// ----------------------------------------------------------------------------
int main(int argc, char *argv[])
{
    int  test = argc > 1 ? atoi(argv[1]) : 0;
    bool verbose = argc > 2;
    bool veryVerbose = argc > 3;
    bool veryVeryVerbose = argc > 4;

    cout << "TEST " << __FILE__ << " CASE " << test << endl;

    // Turn off logging.

    bael_DefaultObserver observer(&bsl::cout);
    bael_LoggerManagerConfiguration configuration;
    bael_LoggerManager& manager =
                   bael_LoggerManager::initSingleton(&observer, configuration);

    manager.setDefaultThresholdLevels(bael_Severity::BAEL_OFF,
                                      bael_Severity::BAEL_OFF,
                                      bael_Severity::BAEL_OFF,
                                      bael_Severity::BAEL_OFF);

    switch (test) { case 0:
      case 11: {
        // --------------------------------------------------------------------
        // USAGE EXAMPLE TEST
        //
        // Concerns:
        //: 1 The usage example provided in the component header file must
        //:   compile, link, and run on all platforms as shown.
        //
        // Plan:
        //: 1 Incorporate usage example from header into driver, remove leading
        //:   comment characters.
        //
        // Testing:
        //   USAGE EXAMPLE
        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting Usage Example"
                          << "\n=====================" << endl;

///Usage
///-----
// In this section, we illustrate how this component can be used.
//
///Example 1: Reading Zoneinfo binary data
///- - - - - - - - - - - - - - - - - - - -
// The following demonstrates how to read a byte stream in the Zoneinfo binary
// data format into a 'baetzo_Zoneinfo' object.  We start by creating Zoneinfo
// data in memory for "Asia/Bangkok", which was chosen due to its small size.
// Note that this data was generated by the 'zic' compiler, which is publicly
// obtainable as part of the standard Zoneinfo distribution (see
// 'http://www.twinsun.com/tz/tz-link.htm'):
//..
    const char ASIA_BANGKOK_DATA[] = {
        0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0xa2, 0x6a, 0x67, 0xc4,
        0x01, 0x00, 0x00, 0x5e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x62, 0x70, 0x00,
        0x04, 0x42, 0x4d, 0x54, 0x00, 0x49, 0x43, 0x54, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x54, 0x5a, 0x69, 0x66, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xff, 0xff,
        0xff, 0x56, 0xb6, 0x85, 0xc4, 0xff, 0xff, 0xff, 0xff, 0xa2, 0x6a, 0x67,
        0xc4, 0x01, 0x02, 0x00, 0x00, 0x5e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x5e,
        0x3c, 0x00, 0x04, 0x00, 0x00, 0x62, 0x70, 0x00, 0x08, 0x4c, 0x4d, 0x54,
        0x00, 0x42, 0x4d, 0x54, 0x00, 0x49, 0x43, 0x54, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x0a, 0x49, 0x43, 0x54, 0x2d, 0x37, 0x0a
    };
//..
// Then, we load this data into a stream buffer.
//..
    bdesb_FixedMemInStreamBuf inStreamBuf(ASIA_BANGKOK_DATA,
                                          sizeof(ASIA_BANGKOK_DATA));
    bsl::istream inputStream(&inStreamBuf);
//..
// Now, we read the 'inputStream' using 'baetzo_ZoneinfoBinaryReader::read'.
//..
    baetzo_Zoneinfo timeZone;
    if (0 != baetzo_ZoneinfoBinaryReader::read(&timeZone, inputStream)) {
        bsl::cerr << "baetzo_ZoneinfoBinaryReader::load failed"
                  << bsl::endl;
        return 1;                                                      //RETURN
    }
//..
// Finally, we write a description of the loaded Zoneinfo to the console.
//..
    if (verbose) timeZone.print(bsl::cout, 1, 3);
//..
// The output of the preceding statement should look like:
//..
// [
//
//    [
//       [ BMT 24124 DST:N ]
//       [ ICT 25200 DST:N ]
//    ]
//    [
//       [
//       01JAN0001_00:00:00.000
//       [ BMT 24124 DST:N ]
//       ]
//       [
//       31MAR1920_17:17:56.000
//       [ ICT 25200 DST:N ]
//       ]
//    ]
// ]
//..
      } break;
      case 10: {
        // --------------------------------------------------------------------
        // TESTING INVALID HEADER
        //
        // Concerns:
        //: 1 'read' fails when magic characters are invalid
        //: 2 'read' fails when version number are invalid
        //: 3 'read' fails when 'numIsGmt' are invalid
        //: 4 'read' fails when 'numIsStd' are invalid
        //: 5 'read' fails when 'numLeaps' are invalid
        //: 6 'read' fails when 'numTransitions' are invalid
        //: 7 'read' fails when 'numLocalTimeTypes' are invalid
        //: 8 'read' fails when 'abbrevDataSize' are invalid
        //
        // Plan:
        //: 1 Create a string stream with incorrect header information for each
        //:   variable in the header and verify that 'read' returns a non-zero
        //:   value.
        //
        // Testing:
        //   CONCERN: 'read' fails when header information is invalid
        // --------------------------------------------------------------------

        if (verbose) cout << endl
                          << "Testing 'read' failure mode" << endl
                          << "===========================" << endl;

        if (verbose) cout << "\nInvalid header identifier." << endl;
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setHeaderId(0, 'S');
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setHeaderId(3, 'F');
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        if (verbose) cout << "\nInvalid version." << endl;
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setVersion(1);
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setVersion('2' - 1);
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setVersion('2' + 1);
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        if (verbose) cout << "\nInvalid 'numIsGmt'." << endl;
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setNumIsGmt(-1);
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        if (verbose) cout << "\nInvalid 'numIsStd'." << endl;
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setNumIsStd(-1);
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        if (verbose) cout << "\nInvalid 'numTransitions'." << endl;
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setNumTransitions(-1);
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        if (verbose) cout << "\nInvalid 'numLocalTimeTypes'." << endl;
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setNumLocalTimeTypes(0);
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        if (verbose) cout << "\nInvalid 'abbrevDataSize'" << endl;
        {
            ZoneinfoData ZI;
            ZI.getRawHeader()->setAbbrevDataSize(0);
            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);
            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }
      } break;
      case 9: {
        // --------------------------------------------------------------------
        // TESTING REAL LIFE DATA
        //
        // Concerns:
        //: 1 'read' function works for real-life zoneinfo binary file.
        //
        // Plan:
        //: 1 Call the 'read' function on a number of real-life Zoneinfo data.
        //:   Verify the retrieved data with 'verifyTimeZone'.  The chosen time
        //:   zones are:
        //:   o America/New_York -- due to common usage.
        //:   o Europe/London -- due to common usage.
        //:   o Asia/Tokyo -- due to common usage.
        //:   o Pacific/Kiritimati -- due change in offset that is over 24
        //:     hours.
        //:   o Pacific/Chatham -- due to various uncommon properties such as
        //:     greater than 12 hours in offset from UTC and non-whole hour
        //:     offset.
        //
        // Testing:
        //   CONCERN: 'read' retrieve a real-life Zoneinfo data
        // --------------------------------------------------------------------

        if (verbose) cout << endl
                          << "TESTING REAL LIFE DATA" << endl
                          << "======================" << endl;

        {
            static const struct {
                const char   *d_buffer;
                int           d_size;
                int           d_numLocalTimeTypes;
                int           d_numIsGmt;
                int           d_numIsStd;
                int           d_numLeaps;
                int           d_abbrevDataSize;
            } DATA [] = {

            //BUFFER           SIZE                  LLT  GMT  STD LEAP  ABB
            //------           ----                  ---  ---  --- ----  ---

            { NEW_YORK_DATA,   sizeof NEW_YORK_DATA,   4,   4,   4,   0,  16 },
            { LONDON_DATA,     sizeof LONDON_DATA,     7,   7,   7,   0,  13 },
            { TOKYO_DATA,      sizeof TOKYO_DATA,      3,   3,   3,   0,  12 },
            { KIRITIMATI_DATA, sizeof KIRITIMATI_DATA, 3,   3,   3,   0,   5 },
            { CHATHAM_DATA,    sizeof CHATHAM_DATA,    4,   4,   4,   0,  16 },

            };

            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const char *BUFFER = DATA[ti].d_buffer;
                const int SIZE     = DATA[ti].d_size;
                const int LTT      = DATA[ti].d_numLocalTimeTypes;
                const int IS_GMT   = DATA[ti].d_numIsGmt;
                const int IS_STD   = DATA[ti].d_numIsStd;
                const int LEAPS    = DATA[ti].d_numLeaps;
                const int AB_SIZE  = DATA[ti].d_abbrevDataSize;

                bdesb_FixedMemInStreamBuf inStreamBuf(BUFFER, SIZE);
                bsl::istream inputStream(&inStreamBuf);

                baetzo_Zoneinfo TZ;
                BinHeader HD;
                ASSERT(0 == Obj::read(&TZ, &HD, inputStream));

                if (verbose) { T_ P(HD) }

                ASSERT('2'     == HD.version());
                ASSERT(LTT     == HD.numLocalTimeTypes());
                ASSERT(IS_GMT  == HD.numIsGmt());
                ASSERT(IS_STD  == HD.numIsStd());
                ASSERT(LEAPS   == HD.numLeaps());
                ASSERT(AB_SIZE == HD.abbrevDataSize());

                if (verbose) { T_ P(TZ) }

                ZoneinfoData ZI(BUFFER, SIZE);
                ASSERT(0 == verifyTimeZone(ZI, TZ, L_));

            }
        }
      } break;
      case 8: {
        // --------------------------------------------------------------------
        // TESTING 'read' without FileDescription
        //
        // Concerns:
        //: 1 'read' succeed in loading from various configurations of binary
        //:   data into a 'baetzo_Zoneinfo' object.
        //
        // Plan:
        //: 1 Repeat case 7 using read without FileDescription
        //
        // Testing:
        //   read(baetzo_Zoneinfo *, bsl::istream&, bA=0);
        // --------------------------------------------------------------------

        if (verbose) cout << endl
                          << "TESTING 'read'" << endl
                          << "==============" << endl;

        if (verbose) cout <<
                         "\nCreate a table of distinct object values." << endl;

        static const struct {
            int  d_line;
            int  d_numIsGmt;
            int  d_numIsStd;
            int  d_numTransitions;
            int  d_numLocalTimeTypes;
            int  d_abbrevDataSize;
        } DATA[] = {

        //LINE  IS_GMT  IS_STD  TRANS  LCL_T_TYPE  AB_DATA
        //----  ------  ------  -----  ----------  -------

        // depth = 0
        { L_,        0,      0,     0,          1,       1 },

        // depth = 1
        { L_,        1,      0,     0,          1,       1 },
        { L_,        0,      1,     0,          1,       1 },
        { L_,        0,      0,     1,          1,       1 },
        { L_,        0,      0,     0,          2,       1 },
        { L_,        0,      0,     0,          1,       2 },

        // depth = 2
        { L_,        1,      1,     0,          1,       1 },
        { L_,        1,      0,     1,          1,       1 },
        { L_,        1,      0,     0,          2,       1 },
        { L_,        1,      0,     0,          1,       2 },
        { L_,        0,      1,     1,          1,       1 },
        { L_,        0,      1,     0,          2,       1 },
        { L_,        0,      1,     0,          1,       2 },
        { L_,        0,      0,     1,          2,       1 },
        { L_,        0,      0,     1,          1,       2 },
        { L_,        0,      0,     0,          2,       2 },
        { L_,        2,      0,     0,          1,       1 },
        { L_,        0,      2,     0,          1,       1 },
        { L_,        0,      0,     2,          1,       1 },
        { L_,        0,      0,     0,          3,       1 },
        { L_,        0,      0,     0,          1,       3 },

        };

        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        if (verbose) cout << "\nTesting version 0." << endl;
        {
            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int LINE       = DATA[ti].d_line;
                const int IS_GMT     = DATA[ti].d_numIsGmt;
                const int IS_STD     = DATA[ti].d_numIsStd;
                const int TRANS      = DATA[ti].d_numTransitions;
                const int LCL_T_TYPE = DATA[ti].d_numLocalTimeTypes;
                const int AB_DATA    = DATA[ti].d_abbrevDataSize;

                RawHeader RH;
                RH.setNumIsGmt(IS_GMT);
                RH.setNumIsStd(IS_STD);
                RH.setNumTransitions(TRANS);
                RH.setNumLocalTimeTypes(LCL_T_TYPE);
                RH.setAbbrevDataSize(AB_DATA);

                ZoneinfoData ZI(RH);

                bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
                bsl::istream inputStream(&isb);

                baetzo_Zoneinfo TZ;
                LOOP_ASSERT(LINE, 0 == Obj::read(&TZ, inputStream));
                LOOP_ASSERT(LINE, 0 == verifyTimeZone(ZI, TZ, LINE));
            }
        }

        if (verbose) cout << "\nTesting version '2'." << endl;
        {
            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int LINE       = DATA[ti].d_line;
                const int IS_GMT     = DATA[ti].d_numIsGmt;
                const int IS_STD     = DATA[ti].d_numIsStd;
                const int TRANS      = DATA[ti].d_numTransitions;
                const int LCL_T_TYPE = DATA[ti].d_numLocalTimeTypes;
                const int AB_DATA    = DATA[ti].d_abbrevDataSize;

                RawHeader RH;
                RH.setVersion('2');
                RH.setNumIsGmt(IS_GMT);
                RH.setNumIsStd(IS_STD);
                RH.setNumTransitions(TRANS);
                RH.setNumLocalTimeTypes(LCL_T_TYPE);
                RH.setAbbrevDataSize(AB_DATA);

                ZoneinfoData ZI(RH);

                bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
                bsl::istream stream(&isb);

                baetzo_Zoneinfo TZ;

                LOOP_ASSERT(LINE, 0 == Obj::read(&TZ, stream));
                LOOP_ASSERT(LINE, 0 == verifyTimeZone(ZI, TZ, LINE));
            }
        }
      } break;
      case 7: {
        // --------------------------------------------------------------------
        // TESTING 'read' with FileDescription
        //
        // Concerns:
        //: 1 'read' succeed in loading from various configurations of binary
        //:   data into a 'baetzo_Zoneinfo' object and returns the correct
        //:   header information.
        //
        // Plan:
        //: 1 Use a table driven approach with enumeration in five dimension
        //:   for each variable in the header, and verify that 'read'
        //:   successfully load data into a 'baetzo_Zoneinfo'.  process the
        //:   stream.
        //
        // Testing:
        //   read(baetzo_Zoneinfo *, FileDescription *, bsl::istream&, bA=0);
        // --------------------------------------------------------------------

        if (verbose) cout << endl
                          << "TESTING 'read'" << endl
                          << "==============" << endl;

        if (verbose) cout <<
                         "\nCreate a table of distinct object values." << endl;

        static const struct {
            int  d_line;
            int  d_numIsGmt;
            int  d_numIsStd;
            int  d_numTransitions;
            int  d_numLocalTimeTypes;
            int  d_abbrevDataSize;
        } DATA[] = {

        //LINE  IS_GMT  IS_STD  TRANS  LCL_T_TYPE  AB_DATA
        //----  ------  ------  -----  ----------  -------

        // depth = 0
        { L_,        0,      0,     0,          1,       1 },

        // depth = 1
        { L_,        1,      0,     0,          1,       1 },
        { L_,        0,      1,     0,          1,       1 },
        { L_,        0,      0,     1,          1,       1 },
        { L_,        0,      0,     0,          2,       1 },
        { L_,        0,      0,     0,          1,       2 },

        // depth = 2
        { L_,        1,      1,     0,          1,       1 },
        { L_,        1,      0,     1,          1,       1 },
        { L_,        1,      0,     0,          2,       1 },
        { L_,        1,      0,     0,          1,       2 },
        { L_,        0,      1,     1,          1,       1 },
        { L_,        0,      1,     0,          2,       1 },
        { L_,        0,      1,     0,          1,       2 },
        { L_,        0,      0,     1,          2,       1 },
        { L_,        0,      0,     1,          1,       2 },
        { L_,        0,      0,     0,          2,       2 },
        { L_,        2,      0,     0,          1,       1 },
        { L_,        0,      2,     0,          1,       1 },
        { L_,        0,      0,     2,          1,       1 },
        { L_,        0,      0,     0,          3,       1 },
        { L_,        0,      0,     0,          1,       3 },

        };

        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        if (verbose) cout << "\nTesting version 0." << endl;

        {
            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int LINE       = DATA[ti].d_line;
                const int IS_GMT     = DATA[ti].d_numIsGmt;
                const int IS_STD     = DATA[ti].d_numIsStd;
                const int TRANS      = DATA[ti].d_numTransitions;
                const int LCL_T_TYPE = DATA[ti].d_numLocalTimeTypes;
                const int AB_DATA    = DATA[ti].d_abbrevDataSize;

                RawHeader RH;
                RH.setNumIsGmt(IS_GMT);
                RH.setNumIsStd(IS_STD);
                RH.setNumTransitions(TRANS);
                RH.setNumLocalTimeTypes(LCL_T_TYPE);
                RH.setAbbrevDataSize(AB_DATA);

                ZoneinfoData ZI(RH);

                bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
                bsl::istream inputStream(&isb);

                baetzo_Zoneinfo TZ;
                BinHeader HD;

                ASSERT(0 == Obj::read(&TZ, &HD, inputStream));

                ASSERT(0          == HD.version());
                ASSERT(LCL_T_TYPE == HD.numLocalTimeTypes());
                ASSERT(IS_GMT     == HD.numIsGmt());
                ASSERT(IS_STD     == HD.numIsStd());
                ASSERT(0          == HD.numLeaps());
                ASSERT(TRANS      == HD.numTransitions());
                ASSERT(AB_DATA    == HD.abbrevDataSize());

                LOOP_ASSERT(LINE, 0 == verifyTimeZone(ZI, TZ, LINE));
            }
        }

        if (verbose) cout << "\nTesting version '2'." << endl;

        {
            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int LINE       = DATA[ti].d_line;
                const int IS_GMT     = DATA[ti].d_numIsGmt;
                const int IS_STD     = DATA[ti].d_numIsStd;
                const int TRANS      = DATA[ti].d_numTransitions;
                const int LCL_T_TYPE = DATA[ti].d_numLocalTimeTypes;
                const int AB_DATA    = DATA[ti].d_abbrevDataSize;

                RawHeader RH;
                RH.setVersion('2');
                RH.setNumIsGmt(IS_GMT);
                RH.setNumIsStd(IS_STD);
                RH.setNumTransitions(TRANS);
                RH.setNumLocalTimeTypes(LCL_T_TYPE);
                RH.setAbbrevDataSize(AB_DATA);

                ZoneinfoData ZI(RH);

                bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
                bsl::istream inputStream(&isb);

                baetzo_Zoneinfo TZ;
                BinHeader HD;

                ASSERT(0 == Obj::read(&TZ, &HD, inputStream));

                ASSERT('2'        == HD.version());
                ASSERT(LCL_T_TYPE == HD.numLocalTimeTypes());
                ASSERT(IS_GMT     == HD.numIsGmt());
                ASSERT(IS_STD     == HD.numIsStd());
                ASSERT(0          == HD.numLeaps());
                ASSERT(TRANS      == HD.numTransitions());
                ASSERT(AB_DATA    == HD.abbrevDataSize());

                LOOP_ASSERT(LINE, 0 == verifyTimeZone(ZI, TZ, LINE));
            }
        }
      } break;
      case 6: {
        // --------------------------------------------------------------------
        // TESTING MULTIPLE TRANSITIONS
        //
        // Concerns:
        //: 1 'read' succeed in reading the binary data with multiple
        //:   transitions.
        //
        // Plan:
        //: 1 Use a table-based approach to create a string stream with
        //:   multiple transitions and local time types.
        //
        // Testing:
        //   CONCERN: 'read' retrieve data with multiple transitions
        // --------------------------------------------------------------------

        if (verbose) cout << endl
                          << "TESTING TRANSITION" << endl
                          << "==================" << endl;

        if (verbose) cout <<
                      "\nCreate a table of distinct transition times." << endl;

        static const struct {
            int   d_line;
            int   d_numTransitions;
        } DATA[] = {

        //LINE  NUM_TRANSITIONS
        //----  ---------------

        { L_,                 0 },
        { L_,                 1 },
        { L_,                 2 },
        { L_,                 3 },
        { L_,                 4 },
        { L_,                 5 },
        { L_,                 6 },
        { L_,                 7 },
        { L_,                 8 },
        { L_,                 9 },
        { L_,                10 },
        { L_,                11 },
        { L_,                12 },
        { L_,                13 },
        { L_,                14 },
        { L_,                15 },
        { L_,                16 },
        { L_,                17 },
        { L_,                18 },
        { L_,                19 },
        { L_,                20 },

        };
        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        static const struct {
            int   d_line;
            int   d_numLocalTimeTypes;
        } U_DATA[] = {

        //LINE  NUM_LLT
        //----  -------

        { L_,         1 },
        { L_,         2 },
        { L_,         5 },
        { L_,        10 },
        { L_,        15 },
        { L_,        20 },

        };

        const int NUM_U_DATA = sizeof U_DATA / sizeof *U_DATA;

        if (verbose) cout << "\nTesting multiple transitions." << endl;
        {
            for (int ti = 0; ti < NUM_DATA; ++ti) {
                for (int i = 0; i < NUM_U_DATA; ++i) {
                    const int   LINE      = DATA[ti].d_line;
                    const int   NUM_TRANS = DATA[ti].d_numTransitions;
                    const int   LLT_LINE  = U_DATA[ti].d_line;
                    const int   NUM_LLT   = U_DATA[ti].d_numLocalTimeTypes;

                    RawHeader RH;
                    RH.setNumTransitions(NUM_TRANS);
                    RH.setNumLocalTimeTypes(NUM_U_DATA);

                    ZoneinfoData ZI(RH);

                    bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
                    bsl::istream inputStream(&isb);

                    baetzo_Zoneinfo TZ;
                    LOOP2_ASSERT(LINE, LLT_LINE,
                                 0 == Obj::read(&TZ, inputStream));
                    LOOP2_ASSERT(LINE, LLT_LINE,
                                 0 == verifyTimeZone(ZI, TZ, LINE));
                }
            }
        }
      } break;
      case 5: {
        // --------------------------------------------------------------------
        // TESTING 'read' FOR TRANSITIONS
        //
        // Concerns:
        //: 1 'read' succeed in retrieving transition data.
        //:
        //: 2 'read' fails when there are duplicated transition time.
        //:
        //: 3 'read' fails when transitions are not in ascending order of time.
        //:
        //: 4 'read' fails when a index to local time type is out of bound.
        //
        // Plan:
        //: 1 Use a table driven approach to create a string stream with
        //:   boundary values of transition times, and verify that
        //:   'read' successfully load data into a 'baetzo_Zoneinfo'.
        //:
        //: 2 Create a string stream with transition times that are not in
        //:   ascending out of order, and verify that 'read' returns a non-zero
        //:   value.
        //:
        //: 3 Create a string stream with duplicated transition times, and
        //:   verify that 'read' returns a non-zero value.
        //:
        //: 4 Create a string stream with transition that refers to a
        //:   local-time type that is out of bound, and verify that 'read'
        //:   returns a non-zero value.
        //
        // Testing:
        //   CONCERN: 'read' properly process transition data
        // --------------------------------------------------------------------
        if (verbose) cout << endl
                          << "TESTING TRANSITION" << endl
                          << "==================" << endl;

        if (verbose) cout <<
                      "\nCreate a table of distinct transition times." << endl;

        static const struct {
            int   d_line;
            int   d_transitionTime;
        } DATA[] = {

        //LINE  TRANSITION
        //----  ----------

        { L_,            0 },
        { L_,            1 },
        { L_,           -1 },
        { L_,   0x01234567 },
        { L_,   0x76543210 },
        { L_,      INT_MIN },
        { L_,      INT_MAX },

        };

        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        if (verbose) cout << "\nTesting transition time." << endl;
        {
            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int   LINE       = DATA[ti].d_line;
                const int   TRANSITION = DATA[ti].d_transitionTime;

                RawHeader RH;
                RH.setNumTransitions(1);

                ZoneinfoData ZI(RH);
                bdeut_BigEndianInt32 *transitions = ZI.getTransitionTime();
                transitions[0] = TRANSITION;

                bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
                bsl::istream inputStream(&isb);

                baetzo_Zoneinfo TZ;
                LOOP_ASSERT(LINE, 0 == Obj::read(&TZ, inputStream));
                LOOP_ASSERT(LINE, 0 == verifyTimeZone(ZI, TZ, LINE));

                baetzo_Zoneinfo::TransitionConstIterator iter =
                                                         TZ.beginTransitions();
                ++iter;

                LOOP2_ASSERT(LINE, iter->utcTime(),
                             TRANSITION == iter->utcTime());
            }
        }

        if (verbose) cout << "\nTesting unordered transition index." << endl;
        {
            RawHeader RH;
            RH.setNumTransitions(2);
            RH.setNumLocalTimeTypes(2);

            ZoneinfoData ZI(RH);
            unsigned char *indexes = ZI.getTransitionIndex();
            indexes[0] = 1;
            indexes[1] = 0;

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 == Obj::read(&TZ, inputStream));
            ASSERT(0 == verifyTimeZone(ZI, TZ, L_));
        }

        if (verbose) cout << "\nTesting duplicated transition time." << endl;
        {
            RawHeader RH;
            RH.setNumTransitions(2);

            ZoneinfoData ZI(RH);
            bdeut_BigEndianInt32 *transitions = ZI.getTransitionTime();
            transitions[0] = 0;
            transitions[1] = 0;

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        if (verbose) cout << "\nTesting out of order transition time." << endl;
        {
            RawHeader RH;
            RH.setNumTransitions(2);

            ZoneinfoData ZI(RH);
            bdeut_BigEndianInt32 *transitions = ZI.getTransitionTime();
            transitions[0] = 1;
            transitions[1] = 0;

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

        if (verbose) cout <<
                         "\nTesting duplicated local time type index." << endl;
        {
            RawHeader RH;
            RH.setNumTransitions(2);

            ZoneinfoData ZI(RH);
            unsigned char *index = ZI.getTransitionIndex();
            index[0] = 0;
            index[1] = 0;

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 == Obj::read(&TZ, inputStream));
            ASSERT(0 == verifyTimeZone(ZI, TZ, L_));
        }

        if (verbose) cout << "\nTesting invalid local time index." << endl;
        {
            RawHeader RH;
            RH.setNumTransitions(1);

            ZoneinfoData ZI(RH);
            unsigned char *index = ZI.getTransitionIndex();
            index[0] = ZI.getRawHeader()->numLocalTimeTypes();

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

      } break;
      case 4: {
        // --------------------------------------------------------------------
        // TESTING 'read' FOR LOCAL TIME TYPES
        //
        // Concerns:
        //: 1 'read' succeed in retrieving local time types data.
        //:
        //: 2 'read' succeed with duplicated local time types.
        //:
        //: 3 'read' fails when a UTC offset is greater than 24 hours.
        //:
        //: 4 'read' fails when the abbreviation index is out of bound.
        //
        // Plan:
        //: 1 Use a table driven approach to create a string stream with
        //:   boundary values of a local time type, and verify that
        //:   'read' successfully load data into a 'baetzo_Zoneinfo'.
        //:
        //: 2 Create a string stream with duplicated local time types,
        //:   and verify that 'read' successfully load data into a
        //:   'baetzo_Zoneinfo'.
        //:
        //: 3 Create a string stream with UTC offset greater than 24 hours, and
        //:   verify that 'read' returns a non-zero value.
        //:
        //: 4 Create a string stream with local-time type that refers to
        //:   an abbreviation string index that is out of bound, and verify
        //:   that 'read' returns a non-zero value.
        //
        // Testing:
        //   CONCERN: 'read' properly process local time types data
        // --------------------------------------------------------------------
        if (verbose) cout << endl
                          << "TESTING LOCAL TIME TYPES" << endl
                          << "========================" << endl;

        if (verbose) cout <<
                         "\nCreate a table of distinct object values." << endl;

        const int UTC_MIN = -4 * 60 * 60 + 1;
        const int UTC_MAX =  4 * 60 * 60 - 1;

        static const struct {
            int         d_line;
            int         d_offset;
            int         d_dstFlag;
            int         d_descIndex;
            const char *d_abbrevData;
            int         d_abbrevDataSize;
        } DATA[] = {

        //LINE   OFFSET  DST  DESC_INDEX  AB_DATA  AB_DATE_SIZE
        //----   ------  ---  ----------  -------  ------------

        { L_,         0,   0,          0, "",                 1},
        { L_,   UTC_MIN,   0,          0, "",                 1},
        { L_,   UTC_MAX,   0,          0, "",                 1},
        { L_,         0,   1,          0, "",                 1},
        { L_,         0,   0,          0, "A",                2},
        { L_,         0,   0,          1, "A",                2},
        { L_,         0,   0,          2, "A\0BC",            5},

        };

        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        if (verbose) cout << "\nTesting local time types." << endl;

        {
            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int   LINE         = DATA[ti].d_line;
                const int   OFFSET       = DATA[ti].d_offset;
                const int   DST          = DATA[ti].d_dstFlag;
                const int   DESC_IDX     = DATA[ti].d_descIndex;
                const char *AB_DATA      = DATA[ti].d_abbrevData;
                const int   AB_DATA_SIZE = DATA[ti].d_abbrevDataSize;

                RawHeader RH;
                RH.setAbbrevDataSize(AB_DATA_SIZE);

                ZoneinfoData ZI(RH);
                RawLocalTimeTypes& LTT = *ZI.getRawLocalTimeTypes();
                LTT.setOffset(OFFSET);
                LTT.setIsDst(DST);
                LTT.setAbbreviationIndex(DESC_IDX);
                memcpy(ZI.getAbbrevData(), AB_DATA, AB_DATA_SIZE);

                bdesb_FixedMemInStreamBuf isb(ZI.buffer(),
                                              ZI.size());
                bsl::istream inputStream(&isb);

                baetzo_Zoneinfo TZ;

                LOOP_ASSERT(LINE, 0 == Obj::read(&TZ, inputStream));
                LOOP_ASSERT(LINE, 0 == verifyTimeZone(ZI, TZ, LINE));
            }
        }

        if (verbose) cout << "\nTesting duplicated local time types." << endl;
        {
            RawHeader RH;
            RH.setNumTransitions(3);
            RH.setNumLocalTimeTypes(2);

            ZoneinfoData ZI(RH);
            RawLocalTimeTypes *lttPtr = ZI.getRawLocalTimeTypes();
            RawLocalTimeTypes& LTT0 = lttPtr[0];
            LTT0.setOffset(0);
            LTT0.setIsDst(0);
            LTT0.setAbbreviationIndex(0);
            RawLocalTimeTypes& LTT1 = lttPtr[1];
            LTT1.setOffset(0);
            LTT1.setIsDst(0);
            LTT1.setAbbreviationIndex(0);

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 == Obj::read(&TZ, inputStream));
            ASSERT(0 == verifyTimeZone(ZI, TZ, L_));
        }

        if (verbose) cout << "\nTesting invalid UTC offset." << endl;
        {
            ZoneinfoData ZI;
            RawLocalTimeTypes& LTT = *ZI.getRawLocalTimeTypes();
            LTT.setOffset(-86400);

            {
                bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
                bsl::istream inputStream(&isb);

                baetzo_Zoneinfo TZ;
                ASSERT(0 != Obj::read(&TZ, inputStream));
            }

            LTT.setOffset(86400);

            {
                bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
                bsl::istream inputStream(&isb);

                baetzo_Zoneinfo TZ;
                ASSERT(0 != Obj::read(&TZ, inputStream));
            }
        }

        if (verbose) cout <<
                        "\nTesting invalid abbreviation string index." << endl;
        {
            ZoneinfoData ZI;
            RawLocalTimeTypes& LTT = *ZI.getRawLocalTimeTypes();
            LTT.setAbbreviationIndex(ZI.getRawHeader()->abbrevDataSize());

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }

      } break;
      case 3: {
        // --------------------------------------------------------------------
        // TESTING 'read' FOR ABBREVIATION STRINGS
        //
        // Concerns:
        //: 1 'read' successfully retrieve the abbreviation strings.
        //:
        //: 2 'read' successfully retrieve the abbreviation strings when the
        //:   abbreviation string indexes in the local time descriptors are not
        //:   in order
        //:
        //: 3 'read' fails when the abbreviation string is not null terminated.
        //
        // Plan:
        //: 1 Use a table-based approach and test that local time descriptors
        //:   retrieved using the 'read' function has the expected abbreviation
        //:   string.
        //:
        //: 2 Use a table-based approach and create binary data where the
        //:   abbreviation string index of the local time descriptors are in
        //:   reversed order.  Test that descriptors retrieved using the 'read'
        //:   function has the expected abbreviation string.
        //:
        //: 3 Create a string stream with abbreviation string where the last
        //:   character of the abbreviation string buffer is not null, and
        //:   verify that 'read' returns a non-zero value.
        //
        // Testing:
        //   CONCERN: 'read' properly process the abbreviation strings
        // --------------------------------------------------------------------
        if (verbose) cout << endl
                          << "TESTING 'read' FOR ABBREVIATION STRINGS"
                          << "=======================================" << endl;

        const char AB_DATA[] = "A\0BC\0DEF\0";

        static const struct {
            int d_line;
            const char *d_abbrevString;
        } DATA[] = {

        //LINE  AB_STRING
        //----  ---------

        { L_,   "A" },
        { L_,   "" },
        { L_,   "BC" },
        { L_,   "C" },
        { L_,   "" },
        { L_,   "DEF" },
        { L_,   "EF" },
        { L_,   "F" },
        { L_,   "" },

        };

        const int AB_DATA_SIZE = sizeof AB_DATA / sizeof *AB_DATA;
        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        if (verbose) cout << "\nTesting abbreviation data." << endl;
        {
            RawHeader RH;
            RH.setNumTransitions(AB_DATA_SIZE);
            RH.setNumLocalTimeTypes(AB_DATA_SIZE);
            RH.setAbbrevDataSize(AB_DATA_SIZE);

            ZoneinfoData ZI(RH);

            memcpy(ZI.getAbbrevData(), AB_DATA, AB_DATA_SIZE);

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 == Obj::read(&TZ, inputStream));
            ASSERT(0 == verifyTimeZone(ZI, TZ, L_));

            baetzo_Zoneinfo::TransitionConstIterator iter =
                                                         TZ.beginTransitions();

            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int   LINE      = DATA[ti].d_line;
                const char *AB_STRING = DATA[ti].d_abbrevString;

                ++iter;
                if (iter == TZ.endTransitions()) {
                    LOOP_ASSERT(ti, !"Unexpected number of transitions");
                    continue;
                }

                LOOP_ASSERT(LINE,
                            AB_STRING == iter->descriptor().description());
            }
        }

        if (verbose) cout <<
                   "\nTesting out of order abbreviation string index." << endl;
        {
            RawHeader RH;
            RH.setNumTransitions(AB_DATA_SIZE);
            RH.setNumLocalTimeTypes(AB_DATA_SIZE);
            RH.setAbbrevDataSize(AB_DATA_SIZE);

            ZoneinfoData ZI(RH);

            memcpy(ZI.getAbbrevData(), AB_DATA, AB_DATA_SIZE);

            // Set abbreviation indexes in reverse order.

            RawLocalTimeTypes *localTimeTypes = ZI.getRawLocalTimeTypes();
            for (int i = 0; i < AB_DATA_SIZE; ++i) {
                localTimeTypes[i].setAbbreviationIndex(AB_DATA_SIZE - 1 - i);
            }

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 == Obj::read(&TZ, inputStream));
            ASSERT(0 == verifyTimeZone(ZI, TZ, L_));

            baetzo_Zoneinfo::TransitionConstIterator iter =
                                                           TZ.endTransitions();

            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int   LINE      = DATA[ti].d_line;
                const char *AB_STRING = DATA[ti].d_abbrevString;

                --iter;
                if (iter == TZ.beginTransitions()) {
                    LOOP_ASSERT(ti, !"Unexpected number of transitions");
                    continue;
                }

                LOOP_ASSERT(LINE,
                            AB_STRING == iter->descriptor().description());
            }
        }

        if (verbose) cout << "\nTesting non-null terminated string." << endl;
        {
            ZoneinfoData ZI;
            char *abbrevData = ZI.getAbbrevData();
            abbrevData[ZI.getRawHeader()->abbrevDataSize() - 1] = 'A';

            bdesb_FixedMemInStreamBuf isb(ZI.buffer(), ZI.size());
            bsl::istream inputStream(&isb);

            baetzo_Zoneinfo TZ;
            ASSERT(0 != Obj::read(&TZ, inputStream));
        }
      } break;
      case 2: {
        // --------------------------------------------------------------------
        // TESTING APPARATUS
        //
        // Concerns:
        //: 1 A default constructed 'ZoneinfoData' object have the expected
        //:   header values and size.
        //:
        //: 2 A value constructed 'ZoneinfoData' object have the expected
        //:   header values and size.
        //:
        //: 3 'ZoneinfoData' create a buffer with expected data.
        //:
        //: 4 'verifyTimeZone' correctly reports whether a 'baetzo_Zoneinfo'
        //:   matches the Zoneinfo binary data.
        //
        // Plan:
        //: 1 Test that a default constructed 'ZoneinfoData' object have the
        //:   expected header values and size
        //:
        //: 2 Use a table-based approach and test that a value constructed
        //:   'ZoneinfoData' object have the expected header values and size.
        //:
        //: 3 Test that the buffer in 'ZoneinfoData' object is created as
        //:   expected.
        //:
        //: 4 Use an ad hoc approach to test various edge cases of the
        //:   function.
        //
        // Testing:
        //   CONCERN: Test apparatus functions as documented.
        // --------------------------------------------------------------------
        if (verbose) cout << endl
                          << "TESTING 'ZoneinfoData" << endl
                          << "=====================" << endl;

        if (verbose)
                  cout << "\nTesting default values of 'ZoneinfoData'" << endl;
        {
            ZoneinfoData ZI;
            BinHeader HD;
            const RawHeader& ZIH = *ZI.getRawHeader();

            ASSERT(HD.numIsGmt()          == ZIH.numIsGmt());
            ASSERT(HD.numIsStd()          == ZIH.numIsStd());
            ASSERT(HD.numTransitions()    == ZIH.numTransitions());
            ASSERT(HD.numLocalTimeTypes() == ZIH.numLocalTimeTypes());
            ASSERT(HD.abbrevDataSize()    == ZIH.abbrevDataSize());
        }

        if (verbose) cout <<
                         "\nCreate a table of distinct object values." << endl;

        static const struct {
            int  d_line;
            int  d_numIsGmt;
            int  d_numIsStd;
            int  d_numTransitions;
            int  d_numLocalTimeTypes;
            int  d_abbrevDataSize;
            int  d_size;
        } DATA[] = {

        //LINE  IS_GMT  IS_STD  TRANS  LCL_T_TYPE  AB_DATA  SIZE
        //----  ------  ------  -----  ----------  -------  ----

        { L_,        0,      0,     0,          1,       1,   51 },
        { L_,        1,      0,     0,          1,       1,   52 },
        { L_,        0,      1,     0,          1,       1,   52 },
        { L_,        0,      0,     1,          1,       1,   56 },
        { L_,        0,      0,     0,          2,       1,   57 },
        { L_,        0,      0,     0,          1,       2,   52 },

        };

        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        if (verbose) cout <<
                   "\nTesting basic accessor for header information.." << endl;
        {
            for (int ti = 0; ti < NUM_DATA; ++ti) {
                const int LINE       = DATA[ti].d_line;
                const int IS_GMT     = DATA[ti].d_numIsGmt;
                const int IS_STD     = DATA[ti].d_numIsStd;
                const int TRANS      = DATA[ti].d_numTransitions;
                const int LCL_T_TYPE = DATA[ti].d_numLocalTimeTypes;
                const int AB_DATA    = DATA[ti].d_abbrevDataSize;
                const int SIZE       = DATA[ti].d_size;

                RawHeader RH;
                RH.setNumIsGmt(IS_GMT);
                RH.setNumIsStd(IS_STD);
                RH.setNumTransitions(TRANS);
                RH.setNumLocalTimeTypes(LCL_T_TYPE);
                RH.setAbbrevDataSize(AB_DATA);

                ZoneinfoData ZI(RH);

                LOOP3_ASSERT(LINE, SIZE, ZI.size(), SIZE == ZI.size());

                const RawHeader& ZIH = *ZI.getRawHeader();

                LOOP3_ASSERT(LINE, IS_GMT, ZIH.numIsGmt(),
                             IS_GMT == ZIH.numIsGmt());
                LOOP3_ASSERT(LINE, IS_STD, ZIH.numIsStd(),
                             IS_STD == ZIH.numIsStd());
                LOOP3_ASSERT(LINE, TRANS, ZIH.numTransitions(),
                             TRANS == ZIH.numTransitions());
                LOOP3_ASSERT(LINE, LCL_T_TYPE, ZIH.numLocalTimeTypes(),
                             LCL_T_TYPE == ZIH.numLocalTimeTypes());
                LOOP3_ASSERT(LINE, AB_DATA, ZIH.abbrevDataSize(),
                             AB_DATA == ZIH.abbrevDataSize());
            }
        }

        if (verbose) cout << "\nTesting created buffer." << endl;
        {
            RawHeader RH;
            RH.setNumIsGmt(2);
            RH.setNumIsStd(2);
            RH.setNumTransitions(2);
            RH.setNumLocalTimeTypes(2);
            RH.setAbbrevDataSize(2);
            ZoneinfoData ZI(RH);

            const int TEST_DATA_SIZE = sizeof TEST_DATA / sizeof *TEST_DATA;

            ASSERT(TEST_DATA_SIZE == ZI.size());
            ASSERT(0 == memcmp(ZI.buffer(), TEST_DATA, TEST_DATA_SIZE));
        }

        if (verbose) cout << "\nTesting 'verifyTimeZone'." << endl;
        {
            testVerifyTimeZone(verbose);
        }
      } break;
      case 1: {
        // --------------------------------------------------------------------
        // BREATHING TEST
        //   This case exercises (but doesn't fully test) basic functionality.
        //
        // Concerns:
        //: 1 The class is sufficiently functional to enable comprehensive
        //:   testing in subsequent test cases.
        //
        // Plan:
        //: 1 Call 'read' on real-life data, 'Pacific/Chatham', and verify that
        //:   read successfully load data into a 'baetzo_Zoneinfo'.
        //
        // Testing:
        //   BREATHING TEST
        //
        // --------------------------------------------------------------------

        baetzo_Zoneinfo TZ;

        bdesb_FixedMemInStreamBuf inStreamBuf(CHATHAM_DATA,
                                              sizeof(CHATHAM_DATA));
        bsl::istream inputStream(&inStreamBuf);

        BinHeader HD;
        ASSERT(0 == Obj::read(&TZ, &HD, inputStream));
        if (verbose) {
            cout << HD << endl;
            cout << TZ << endl;
        }

        ASSERT('2' == HD.version());
        ASSERT(128 == HD.numTransitions());
        ASSERT(4   == HD.numLocalTimeTypes());
        ASSERT(4   == HD.numIsGmt());
        ASSERT(4   == HD.numIsStd());
        ASSERT(0   == HD.numLeaps());
        ASSERT(16  == HD.abbrevDataSize());

        ZoneinfoData ZI(CHATHAM_DATA, sizeof(CHATHAM_DATA));
        verifyTimeZone(ZI, TZ, L_);
      } break;
      case -1: {
        // --------------------------------------------------------------------
        // DUMP TIMEZONE FILE:
        //   This loads a TZ Database binary file whose name is provided on
        //   the console, and dumps its contents to stdout.
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------
        baetzo_Zoneinfo timeZone;

        if (argc != 3) {
            cout << "Usage " << argv[0] << " -1 [data file path]" << endl;
            exit(-1);
        }

        bsl::ifstream istream(argv[2]);

        if (!istream.good()) {
            cout << "Bad file name: " << argv[2] << endl;
            exit(-1);
        }

        if (0 != Obj::read(&timeZone, istream)) {
            cout << "Failed to read file" << endl;
            exit(-1);
        }

        timeZone.print(cout, 1, 3);
      } break;
      case -2: {
        // --------------------------------------------------------------------
        // TEST TIMEZONE FILE:
        //   This loads a TZ Database binary file whose name is provided on
        //   the console, and validate its contents.  Its purpose is to test
        //   that a Zoneinfo binary data file is in the correct format rather
        //   than testing this class.
        //
        // Plan:
        // Testing:
        // --------------------------------------------------------------------
        baetzo_Zoneinfo timeZone;

        if (argc != 3) {
            cout << "Usage " << argv[0] << " -1 [data file path]" << endl;
            exit(-1);
        }

        cout << argv[2] << endl;
        bsl::ifstream istream(argv[2]);

        if (!istream.good()) {
            cout << "Bad file name: " << argv[2] << endl;
            exit(-1);
        }

        int size;
        istream.seekg(0, std::ios::end);
        size = istream.tellg();
        istream.seekg(0, std::ios::beg);
        char *buffer = new char[size];
        istream.read(buffer, size);
        istream.close();

        bdesb_FixedMemInStreamBuf inStreamBuf(buffer, size);
        bsl::istream inputStream(&inStreamBuf);

        if (0 != Obj::read(&timeZone, inputStream)) {
            cout << "Failed to read file" << endl;
            exit(-1);
        }

        ZoneinfoData data(buffer, size);
        if (0 != verifyTimeZone(data, timeZone, L_)) {
            cout << "Failed to parse file" << endl;
            exit(-1);
        }
      } break;
      default: {
        bsl::cerr << "WARNING: CASE `" << test << "' NOT FOUND." << bsl::endl;
        testStatus = -1;
      }
    }

    if (testStatus > 0) {
        bsl::cerr << "Error, non-zero test status = " << testStatus << "."
                  << bsl::endl;
    }
    return testStatus;
}

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2011
//      All Rights Reserved.
//      Property of Bloomberg L.P.  (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
