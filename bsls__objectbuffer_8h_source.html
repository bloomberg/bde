<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bsls_objectbuffer.h                                                -*-C++-*-
#ifndef INCLUDED_BSLS_OBJECTBUFFER
#define INCLUDED_BSLS_OBJECTBUFFER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide raw buffer with size and alignment of user-specified type.
//
//@CLASSES:
//  bsls::ObjectBuffer: templatized buffer aligned to hold specified type
//
//@SEE_ALSO: bsls_alignmentfromtype
//
//@DESCRIPTION: This component provides a templated buffer type,
// &#39;bsls::ObjectBuffer&#39;, which is compile-time sized and aligned to hold a
// specified object type.  Defining a &#39;bsls::ObjectBuffer&lt;T&gt;&#39; object does not
// cause the constructor for &#39;T&#39; to be called.  Similarly, destroying the
// object buffer does not call the destructor for &#39;T&#39;.  Instead, the user
// instantiates &#39;bsls::ObjectBuffer&#39; with a specific type, then constructs an
// object of that type within that buffer.  When the object is no longer
// needed, the user must explicitly call its destructor.  A
// &#39;bsls::ObjectBuffer&#39; can reside on the stack or within another object,
// including within a &#39;union&#39;.
//
// Typically, a &#39;bsls::ObjectBuffer&#39; is used in situations where efficient
// (e.g., stack-based) storage is required but where straight-forward
// initialization or destruction of an object is not possible.  For example,
// &#39;bsls::ObjectBuffer&#39; can be used to construct an array where the number of
// used elements varies at run-time or where the element type does not have a
// default constructor.  It can also be used to create a &#39;union&#39; containing
// non-POD element types.
//
///Usage
///-----
// The examples below use a value-semantic string class, &#39;my_String&#39; which can
// be constructed from a null-terminated string and contains a member, &#39;c_str&#39;
// which returns a null-terminated string.  &#39;my_String&#39; does not have a default
// constructor and thus cannot be used in C-style arrays or unions.
//
///Usage Example 1:
///- - - - - - - -
// Here we use &#39;bsls::ObjectBuffer&#39; to create a variable-length array of
// &#39;my_String&#39; objects.  For efficiency, the array is created on the stack as
// a fixed-sized array of &#39;bsls::ObjectBuffer&lt;my_String&gt;&#39; objects and the
// length is kept in a separate variable.  Only &#39;len&#39; calls are made to the
// &#39;my_String&#39; constructor, with the unused array elements left as raw
// memory.  An array directly containing &#39;my_String&#39; objects would not have
// been possible because &#39;my_String&#39; does not have a default constructor.
//
// WARNING: the &#39;manipulateStrings&#39; function below is not exception-safe.
// If an exception is thrown anywhere within the function (e.g., from a
// constructor call), the destructor will not be called on the constructed
// string objects.  This logic would typically be augmented with guard objects
// that call destructors in case of exception.
//..
//  void manipulateStrings(const my_String* stringArray, int len)
//  {
//      assert(len &lt;= 10);
//
//      bsls::ObjectBuffer&lt;my_String&gt; tempArray[10];
//      for (int i = 0; i &lt; len; ++i) {
//          new (tempArray[i].buffer()) my_String(stringArray[i]);
//          assert(stringArray[i] == tempArray[i].object())
//      }
//
//      for (int i = 0; i &lt; len; ++i)
//      {
//          my_String&amp; s = tempArray[i].object();
//          // ... String manipulations go here.  &#39;s&#39; might be analyzed,
//          // appended-to, passed to other functions, etc.
//      }
//
//      while (len) {
//          // Destroy strings.  Although not critical to this example, we
//          // follow the general rule of destroying the objects in reverse
//          // order of their construction, thus mimicking the
//          // compiler-generated destruction order for normal array objects.
//          tempArray[--len].object().~my_String();
//      }
//  }
//
//  int main()
//  {
//      const my_String INARRAY[3] = {
//          my_String(&quot;hello&quot;),
//          my_String(&quot;goodbye&quot;),
//          my_String(&quot;Bloomberg&quot;)
//      };
//
//      manipulateStrings(INARRAY, 3);
//
//      return 0;
//  }
//..
///Usage Example 2:
///- - - - - - - -
// Here we use &#39;bsls::ObjectBuffer&#39; to compose a variable-type object capable
// of holding a string or an integer:
//..
//  class my_Union
//  {
//    public:
//      enum TypeTag { INT, STRING };
//
//    private:
//      TypeTag                          d_type;
//      union {
//          int                          d_int;
//          bsls::ObjectBuffer&lt;my_String&gt; d_string;
//      };
//
//    public:
//      my_Union(int i = 0) : d_type(INT) { d_int = i; }
//      my_Union(const my_String&amp; s) : d_type(STRING) {
//          new (d_string.buffer()) my_String(s); }
//      my_Union(const char *s) : d_type(STRING) {
//          new (d_string.buffer()) my_String(s); }
//      my_Union(const my_Union&amp; rhs) : d_type(rhs.d_type) {
//          if (INT == d_type) {
//              d_int = rhs.d_int;
//          }
//          else {
//              new (d_string.buffer()) my_String(rhs.d_string.object());
//          }
//      }
//      ~my_Union() {
//          if (STRING == d_type) d_string.object().~my_String(); }
//
//      my_Union&amp; operator=(const my_Union&amp; rhs) {
//          if (INT == d_type) {
//              if (INT == rhs.d_type) {
//                  d_int = rhs.d_int;
//              }
//              else { // if STRING == rhs.d_type
//                  new (d_string.buffer()) my_String(rhs.d_string.object());
//              }
//          }
//          else { // if (STRING == d_type)
//              if (INT == rhs.d_type) {
//                  d_string.object().~my_String();
//                  d_int = rhs.d_int;
//              }
//              else { // if STRING == rhs.d_type
//                  d_string.object() = rhs.d_string.object();
//              }
//          }
//          d_type = rhs.d_type;
//          return *this;
//      }
//
//      TypeTag typeTag() const { return d_type; }
//
//      int asInt() const {
//          return INT == d_type ?
//              d_int : strtol(d_string.object().c_str(), 0, 0); }
//
//      my_String asString() const {
//          if (INT == d_type) {
//              char temp[15];
//              sprintf(temp, &quot;%d&quot;, d_int);
//              return my_String(temp);
//          }
//          else {
//              return d_string.object();
//          }
//      }
//  };
//
//  int main()
//  {
//      assert(sizeof(bsls::ObjectBuffer&lt;my_String&gt;) == sizeof(my_String));
//
//      // Create a &#39;my_Union&#39; object containing a string.
//      const my_Union U1(&quot;hello&quot;);
//      assert(my_Union::STRING == U1.typeTag());
//      assert(0 == U1.asInt());
//      assert(&quot;hello&quot; == U1.asString());
//
//      // Create a &#39;my_Union&#39; object containing an integer.
//      const my_Union U2(123);
//      assert(my_Union::INT == U2.typeTag());
//      assert(123 == U2.asInt());
//      assert(&quot;123&quot; == U2.asString());
//
//      // Create a &#39;my_Union&#39; object containing a string that can be
//      // interpreted as an integer.
//      const my_Union U3(&quot;0x456&quot;);
//      assert(my_Union::STRING == U3.typeTag());
//      assert(0x456 == U3.asInt());
//      assert(&quot;0x456&quot; == U3.asString());
//
//      // Copy-construct a &#39;my_Union&#39; object containing a string.
//      my_Union u4(U3);
//      assert(my_Union::STRING == u4.typeTag());
//      assert(0x456 == u4.asInt());
//      assert(&quot;0x456&quot; == u4.asString());
//
//      // Use assignment to change &#39;u4&#39; from string to integer.
//      u4 = U2;
//      assert(my_Union::INT == u4.typeTag());
//      assert(123 == u4.asInt());
//      assert(&quot;123&quot; == u4.asString());
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLS_ALIGNMENTFROMTYPE
#include &lt;bsls_alignmentfromtype.h&gt;
#endif

namespace BloombergLP {

namespace bsls {

                        // ==================
                        // union ObjectBuffer
                        // ==================

template &lt;typename TYPE&gt;
union ObjectBuffer {
    // An instance of this union is a raw block of memory suitable for storing
    // an object of type &#39;TYPE&#39;.  Specifically, the size and alignment of this
    // union exactly matches that of &#39;TYPE&#39;.  A &#39;TYPE&#39; object can be
    // constructed into a &#39;ObjectBuffer&#39; using the placement &#39;new&#39;
    // operator and can be destroyed by explicitly calling its destructor,
    // &#39;~TYPE()&#39;.  It is the user&#39;s responsibility to perform this
    // construction and destruction; a &#39;AlignedBuffer&#39; object does not
    // manage the construction or destruction of any other objects.
    //
    // Note that a collaboration is implied between &#39;ObjectBuffer&#39; and
    // the user.  A &#39;ObjectBuffer&#39; provides aligned memory and the user
    // handles construction and destruction of the object contained within
    // that memory.

  private:
    // Buffer correctly sized and aligned for object of type &#39;TYPE&#39;.
    char                                   d_buffer[sizeof(TYPE)];
    typename AlignmentFromType&lt;TYPE&gt;::Type d_align;

  public:
    // CREATORS
    // Note that we deliberately omit defining constructors and destructors in
    // order to keep this union &quot;POD-like&quot;.  In particular, a
    // &#39;ObjectBuffer&#39; may be used as a member in another &#39;union&#39;.
    // Copying a &#39;ObjectBuffer&#39; by assignment or copy construction will
    // result in a bit-wise copy and will not invoke &#39;TYPE&#39;s assignment
    // operator or copy constructor.

    // MANIPULATORS
    TYPE&amp; object();
        // Return a modifiable reference to the &#39;TYPE&#39; object occupying this
        // buffer.  The referenced object has undefined state unless a valid
        // &#39;T&#39; object has been constructed in this buffer.

    char *buffer();
        // Return a the address of the first byte of this object, cast to a
        // &#39;char*&#39; pointer.

    // ACCESSORS
    const TYPE&amp; object() const;
        // Return a const reference to the &#39;TYPE&#39; object occupying this
        // buffer.  The referenced object has undefined state unless a valid
        // &#39;T&#39; object has been constructed in this buffer.

    const char *buffer() const;
        // Return a the address of the first byte of this object, cast to a
        // &#39;const char*&#39; pointer.
};

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

// MANIPULATORS
template &lt;typename TYPE&gt;
inline
TYPE&amp; ObjectBuffer&lt;TYPE&gt;::object()
{
    return *reinterpret_cast&lt;TYPE*&gt;(this);
}

template &lt;typename TYPE&gt;
inline
char *ObjectBuffer&lt;TYPE&gt;::buffer()
{
    return d_buffer;
}

// ACCESSORS
template &lt;typename TYPE&gt;
inline
const TYPE&amp; ObjectBuffer&lt;TYPE&gt;::object() const
{
    return *reinterpret_cast&lt;const TYPE*&gt;(this);
}

template &lt;typename TYPE&gt;
inline
const char *ObjectBuffer&lt;TYPE&gt;::buffer() const
{
    return d_buffer;
}

}  // close package namespace

// ===========================================================================
//                          BACKWARD COMPATIBILITY
// ===========================================================================



}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
