<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslmf_switch Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmf_switch<br/>
<small>
[<a class="el" href="group__bslmf.html">Package bslmf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a compile-time <code>switch</code> meta-function.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmf.html">bslmf</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a compile-time <code>switch</code> meta-function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslmf_1_1Switch.html">bslmf::Switch</a> </td><td><code>switch</code> meta-function (variable number of types)  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1Switch2.html">bslmf::Switch2</a> </td><td><code>switch</code> meta-function (among two types)  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1Switch3.html">bslmf::Switch3</a> </td><td><code>switch</code> meta-function (among three types)  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1Switch4.html">bslmf::Switch4</a> </td><td><code>switch</code> meta-function (among four types)  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1Switch5.html">bslmf::Switch5</a> </td><td><code>switch</code> meta-function (among five types)  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1Switch6.html">bslmf::Switch6</a> </td><td><code>switch</code> meta-function (among six types)  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1Switch7.html">bslmf::Switch7</a> </td><td><code>switch</code> meta-function (among seven types)  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1Switch8.html">bslmf::Switch8</a> </td><td><code>switch</code> meta-function (among eight types)  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1Switch9.html">bslmf::Switch9</a> </td><td><code>switch</code> meta-function (among nine types)  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmf__typelist.html" title="Provide a typelist component.">Component bslmf_typelist</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a compile-time <code>switch</code> meta-function. Its main class, <code><a class="el" href="structbslmf_1_1Switch.html">bslmf::Switch</a></code>, parameterized by an integral <code>SELECTOR</code> and a variable number <code>N</code> of types, <code>T0</code> up to <code>T{N - 1}</code>, contains a single type named <code>Type</code>, which is the result of the meta-function and is an alias to <code>T{SELECTOR}</code> or to <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> if <code>SELECTOR</code> is outside the range <code>[ 0 .. N - 1 ]</code>. The analogy between the following "meta-code" and its valid C++ version using <code><a class="el" href="structbslmf_1_1Switch.html">bslmf::Switch</a></code> may serve as a useful mental picture to understand and memorize the usage of this component. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot;Meta-code&quot;</span> (not C++)               Valid C++ <span class="keyword">using</span> <span class="stringliteral">&#39;bslmf::Switch&#39;</span>
  ---------------------               ------------------------------
  <span class="keyword">typedef</span>                             <span class="keyword">typedef</span> <span class="keyword">typename</span>
    <span class="keywordflow">switch</span> (SELECTOR) {                       <a class="code" href="structbslmf_1_1Switch.html">bslmf::Switch</a>&lt;SELECTOR,
      <span class="keywordflow">case</span> 0:     T0;                                      T0,
      <span class="keywordflow">case</span> 1:     T1;                                      T1,
      <span class="comment">// . . .                                             // . . .</span>
      <span class="keywordflow">case</span> N - 1: T{N - 1};                                T{N - 1}
      <span class="keywordflow">default</span>:    <a class="code" href="structbslmf_1_1Nil.html">bslmf::Nil</a>;                              &gt;
    }                                                      ::
                  Type;                                      Type;
</pre></div><br/>
<br/>
 Note the use of the keyword <code>typename</code>, necessary <em>only</em> if one or more of the <code>SELECTOR</code> or <code>T0</code> up to <code>T{N - 1}</code> is dependent on a template parameter of the local context (i.e., that of the block using <code><a class="el" href="structbslmf_1_1Switch.html">bslmf::Switch</a></code>). In particular, it should be omitted if the <code><a class="el" href="structbslmf_1_1Switch.html">bslmf::Switch</a></code> is not used within a class or function template, as in the usage example below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For most situations, the number <code>N</code> of template type arguments is known and the <code>bslmf::SwitchN</code> meta-functions, which take exactly the indicated number of arguments, should be preferred. Their usage leads to shorter mangled symbol names in object files (e.g., no extra defaulted template type arguments are included in the name), and shorter compilation times, as well. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Assume an external server API for storing and retrieving data: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>data_Server {
      <span class="comment">// Dummy implementation of data server</span>

      <span class="keywordtype">int</span> d_data;

    <span class="keyword">public</span>:
       <span class="keywordtype">void</span> store(<span class="keywordtype">char</span>  data) { d_data = data | 0Xefface00; }
       <span class="keywordtype">void</span> store(<span class="keywordtype">short</span> data) { d_data = data | 0Xdead0000; }
       <span class="keywordtype">void</span> store(<span class="keywordtype">int</span>   data) { d_data = data; }

       <span class="keywordtype">void</span> retrieve(<span class="keywordtype">char</span>  *data) {
          *data = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(d_data &amp; 0x000000ff);
       }
       <span class="keywordtype">void</span> retrieve(<span class="keywordtype">short</span> *data) {
          *data = <span class="keyword">static_cast&lt;</span><span class="keywordtype">short</span><span class="keyword">&gt;</span>(d_data &amp; 0x0000ffff);
       }
       <span class="keywordtype">void</span> retrieve(<span class="keywordtype">int</span>   *data) { *data = d_data; }
  };
</pre></div><br/>
<br/>
 In our application, we need some very small (1, 2, and 4-byte), special-purpose string types, so we create the following <code>ShortString</code> class template: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> LEN&gt;
  <span class="keyword">class </span>ShortString {
      <span class="comment">// Store a short, fixed-length string.</span>

      <span class="keywordtype">char</span> d_buffer[LEN];

    <span class="keyword">public</span>:
      ShortString(<span class="keyword">const</span> <span class="keywordtype">char</span> *s = <span class="stringliteral">&quot;&quot;</span>) { std::strncpy(d_buffer, s, LEN); }
          <span class="comment">// Construct a &#39;ShortString&#39; from a NTCS.</span>

      <span class="keywordtype">void</span> retrieve(data_Server *server);
          <span class="comment">// Retrieve this string from a data server.</span>

      <span class="keywordtype">void</span> store(data_Server *server) <span class="keyword">const</span>;
          <span class="comment">// Store this string to a data server.</span>

      <span class="keywordtype">char</span> operator[](<span class="keywordtype">int</span> n)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_buffer[n]; }
          <span class="comment">// Return the nth byte in this string.</span>
  };

  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> LEN&gt;
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> ShortString&lt;LEN&gt;&amp; lhs, <span class="keyword">const</span> ShortString&lt;LEN&gt;&amp; rhs)
      <span class="comment">// Return true if a &#39;lhs&#39; is equal to &#39;rhs&#39;</span>
  {
      <span class="keywordflow">return</span> 0 == std::memcmp(&amp;lhs, &amp;rhs, LEN);
  }

  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> LEN&gt;
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> ShortString&lt;LEN&gt;&amp; lhs, <span class="keyword">const</span> <span class="keywordtype">char</span> *rhs)
      <span class="comment">// Return true if a &#39;ShortString&#39; &#39;lhs&#39; is equal to a NTCS &#39;rhs&#39;.</span>
  {
      <span class="keywordtype">int</span> i;
      <span class="keywordflow">for</span> (i = 0; LEN &gt; i &amp;&amp; lhs[i]; ++i) {
          <span class="keywordflow">if</span> (lhs[i] != rhs[i]) {
              <span class="keywordflow">return</span> <span class="keyword">false</span>;
          }
      }

      <span class="keywordflow">return</span> (<span class="charliteral">&#39;\0&#39;</span> == rhs[i]);
  }
</pre></div><br/>
<br/>
 We would like to store our short strings in the data server, but the data server only handles <code>char</code>, <code>short</code> and <code>int</code> types. Since our strings fit into these simple types, we can transform <code>ShortString</code> into these integral types when calling <code>store</code> and <code>retrieve</code>, using <code><a class="el" href="structbslmf_1_1Switch5.html">bslmf::Switch5</a></code> to choose which integral type to use for each <code>ShortString</code> type: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> LEN&gt;
  <span class="keywordtype">void</span> ShortString&lt;LEN&gt;::retrieve(data_Server *server)
  {
      <span class="comment">// &#39;transferType will be &#39;char&#39; if &#39;LEN&#39; is 1, &#39;short&#39; if &#39;LEN&#39; is 2,</span>
      <span class="comment">// and &#39;int&#39; if &#39;LEN&#39; 4.  Will choose &#39;void&#39; and thus not compile if</span>
      <span class="comment">// &#39;LEN&#39; is 0 or 3.</span>

      <span class="keyword">typedef</span> <span class="keyword">typename</span>
        <a class="code" href="structbslmf_1_1Nil.html">bslmf::Switch5&lt;LEN, void, char, short, void, int&gt;::Type</a> transferType;

      transferType x = 0;
      server-&gt;retrieve(&amp;x);
      std::memcpy(d_buffer, &amp;x, LEN);
  }

  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> LEN&gt;
  <span class="keywordtype">void</span> ShortString&lt;LEN&gt;::store(data_Server *server)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="comment">// &#39;transferType will be &#39;char&#39; if &#39;LEN&#39; is 1, &#39;short&#39; if &#39;LEN&#39; is 2,</span>
      <span class="comment">// and &#39;int&#39; if &#39;LEN&#39; 4.  Will choose &#39;void&#39; and thus not compile if</span>
      <span class="comment">// &#39;LEN&#39; is 0 or 3.</span>
      <span class="keyword">typedef</span> <span class="keyword">typename</span>
        <a class="code" href="structbslmf_1_1Nil.html">bslmf::Switch5&lt;LEN, void, char, short, void, int&gt;::Type</a> transferType;

      transferType x = 0;
      std::memcpy(&amp;x, d_buffer, LEN);
      server-&gt;store(x);
  }
</pre></div><br/>
<br/>
 In our main program, we first assert our basic assumptions, then we store and retrieve strings using our <code>ShortString</code> template. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      assert(2 == <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
      assert(4 == <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));

      data_Server server;

      ShortString&lt;1&gt; a(<span class="stringliteral">&quot;A&quot;</span>);
      ShortString&lt;1&gt; b(<span class="stringliteral">&quot;B&quot;</span>);
      assert(a == <span class="stringliteral">&quot;A&quot;</span>);
      assert(b == <span class="stringliteral">&quot;B&quot;</span>);
      assert(! (a == b));

      a.store(&amp;server);
      b.retrieve(&amp;server);
      assert(a == <span class="stringliteral">&quot;A&quot;</span>);
      assert(b == <span class="stringliteral">&quot;A&quot;</span>);
      assert(a == b);

      ShortString&lt;2&gt; cd(<span class="stringliteral">&quot;CD&quot;</span>);
      ShortString&lt;2&gt; ef(<span class="stringliteral">&quot;EF&quot;</span>);
      assert(cd == <span class="stringliteral">&quot;CD&quot;</span>);
      assert(ef == <span class="stringliteral">&quot;EF&quot;</span>);
      assert(! (cd == ef));

      cd.store(&amp;server);
      ef.retrieve(&amp;server);
      assert(cd == <span class="stringliteral">&quot;CD&quot;</span>);
      assert(ef == <span class="stringliteral">&quot;CD&quot;</span>);
      assert(cd == ef);

      ShortString&lt;4&gt; ghij(<span class="stringliteral">&quot;GHIJ&quot;</span>);
      ShortString&lt;4&gt; klmn(<span class="stringliteral">&quot;KLMN&quot;</span>);
      assert(ghij == <span class="stringliteral">&quot;GHIJ&quot;</span>);
      assert(klmn == <span class="stringliteral">&quot;KLMN&quot;</span>);
      assert(! (ghij == klmn));

      ghij.store(&amp;server);
      klmn.retrieve(&amp;server);
      assert(ghij == <span class="stringliteral">&quot;GHIJ&quot;</span>);
      assert(klmn == <span class="stringliteral">&quot;GHIJ&quot;</span>);
      assert(ghij == klmn);

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:21 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
