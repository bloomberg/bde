<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlb::Variant4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlb.html">bdlb</a>      </li>
      <li><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4&lt; A1, A2, A3, A4 &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlb::Variant4&lt; A1, A2, A3, A4 &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlb::Variant4" --><!-- doxytag: inherits="VariantImp&lt; bslmf::TypeList4&lt; A1, A2, A3, A4 &gt;::ListType &gt;" -->
<p><code>#include &lt;<a class="el" href="bdlb__variant_8h_source.html">bdlb_variant.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdlb::Variant4&lt; A1, A2, A3, A4 &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdlb_1_1Variant4.png" usemap="#bdlb::Variant4&lt; A1, A2, A3, A4 &gt;_map" alt=""/>
  <map id="bdlb::Variant4&lt; A1, A2, A3, A4 &gt;_map" name="bdlb::Variant4&lt; A1, A2, A3, A4 &gt;_map">
<area href="classbdlb_1_1VariantImp.html" alt="bdlb::VariantImp&lt; bslmf::TypeList4&lt; A1, A2, A3, A4 &gt;::ListType &gt;" shape="rect" coords="0,56,453,80"/>
<area href="classVariantImp__Traits_1_1BaseType.html" alt="BaseType" shape="rect" coords="0,0,453,24"/>
</map>
</div>

<p><a href="classbdlb_1_1Variant4-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#a7223434dab4ec60d30ae2257d2c77918">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>, <a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>, Traits::k_VARIANT_USES_BSLMA_ALLOCATOR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#afb39e230a616123f70a13cbd6e0dd427">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>, <a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>, Traits::k_VARIANT_IS_BITWISE_COPYABLE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#a6c0632f00fa60b210c37252d29d2f3bd">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>, <a class="el" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>, Traits::k_VARIANT_IS_BITWISE_MOVEABLE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#a22a9ce77a23a68f1ee348e46d3c57465">BSLMF_NESTED_TRAIT_DECLARATION</a> (<a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>, <a class="el" href="structbdlb_1_1HasPrintMethod.html">HasPrintMethod</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#ae0cb27beeb87cfbaecdcdec1f6448be8">Variant4</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE_OR_ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#a0f27db7cd19b5ddbb2eb995882e6a455">Variant4</a> (const TYPE_OR_ALLOCATOR &amp;typeOrAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#a58a2ac4d3d5ab5f8f89787a36aa42597">Variant4</a> (const TYPE &amp;value, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#a5951f38da37366555ff881221c10e0a1">Variant4</a> (const <a class="el" href="classbdlb_1_1Variant4.html">Variant4</a> &amp;original, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#ae2d8d741408c154e7348e81759249340">operator=</a> (const TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html#a496ac61d38eb4e60a2871db9f13a7ead">operator=</a> (const <a class="el" href="classbdlb_1_1Variant4.html">Variant4</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ad4cb5a21e55a725a65df694b212153c0">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>, <a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>, Traits::k_VARIANT_USES_BSLMA_ALLOCATOR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a32cab2873477483af8131be1bc07a09b">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>, <a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>, Traits::k_VARIANT_IS_BITWISE_COPYABLE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9cd7543df79ed2407548ee42e90730de">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>, <a class="el" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>, Traits::k_VARIANT_IS_BITWISE_MOVEABLE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9b6c68e8c0b6ee9b71c2341b8bd0cb2e">BSLMF_NESTED_TRAIT_DECLARATION</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>, <a class="el" href="structbdlb_1_1HasPrintMethod.html">HasPrintMethod</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#adb101113e18074b8505b805a41223aca">apply</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a6be1807dfbad0a238ee8e86f04a602ef">apply</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ae026b1ec6ce386f79df27bcae5095e7b">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a4d326b36c512e898c296fc85628f1fd4">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a3498eb7142531106fc2f0fcf0d2da048">apply</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac742413e7dcd96c2616c61687f47fa02">apply</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ae16dc8d814ae0526c4b01afeff2468f9">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9d36ef713685b260c8f49e2f351bb10e">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#af5013ec99d595e043c7bd9c6f4848a1a">apply</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#aac0a70a70a7624c596946ce233568729">apply</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a72244d9987e7cfe977d8886496b1318f">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a1dd418efc55f677c047eaf72515a5296">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#af586fd4ed208906fb5b483a5a3e083cf">apply</a> (VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#aac9e8406f3d1b84e8097e6762176c486">apply</a> (const VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a5ccf228532d68f4268f425fdee18d76d">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a29581a916dde16b7f173ca2cb3a70984">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ab56eb7ec3868f812931515c98d923f8a">apply</a> (VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#af00bd438b8d24bd3e3aa533981e9bb5d">apply</a> (const VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ae96a144d889177e6a8d46c5a0bc5564f">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a98ec3a6c252c6cadf1ae9f3399c5158d">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a8efc00326eb4915f7115b267e18c6d74">apply</a> (VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a40c0b811ebc75e498b4e19c509f7aa48">apply</a> (const VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a5b463b58a2d92ef2967c58ec0a70bcae">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a368a2294b3fecb0c3974b47decb27d0a">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a49a2f2ad828c95f4509968410065902c">applyRaw</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac3dc427ff8b114ca6d9912aeb9a70509">applyRaw</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a95eb485c396800b6ecbbd398a1028def">applyRaw</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9508f2c5f01b2e0f57f60316252b5742">applyRaw</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a1e3fc332e52d38502782757de28fe1c2">applyRaw</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a5f375f4f3550e0edc61334141db24a83">applyRaw</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a273341128334d6bd2e0dc225903fc9e2">applyRaw</a> (VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a601e31b22354bdd8696980217d8f7ece">applyRaw</a> (const VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a62637a61fdc40f1f6cf0c59c5dcc18a0">applyRaw</a> (VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#afdad7a39dd5235a9857a971c7e32e773">applyRaw</a> (const VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9fa5a573fa079eb39e4e3c8b9f760815">applyRaw</a> (VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a399ed4ce14fc0eb57a084f2bf684ffca">applyRaw</a> (const VISITOR &amp;visitor) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac33e36612ea9abffc9dfa36313b28572">assign</a> (const TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac9e7872b8e4a6e0d9369a28b56438e34">assignTo</a> (const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a439d5f8acd4b43a94d16b58131746c53">createInPlace</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ad4f4327412acef29630615a49f3e2b49">createInPlace</a> (const A1 &amp;a1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#aab5f7438ce8b607a3dc2ceae5060713e">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a8e2d13dfd58e838b29030bf286def834">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#acf5cf76575cc460012ccaaddcd908a9a">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a88a84dc69e6d1bfffe8ef7a0bd610ebf">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#adc1b8f2f21a1f452509e6d4734d07162">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a65c1b4932550561a75882315dbe76ab3">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ad8b1980441158ef0a50f2a14db3f6e7c">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#af394aa26741fba5094940f7643077f8f">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9a4bc79b9a7856bc04c33a0040315ede">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a6850996bc498c51d509657e7ab586442">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a11c5fc455e6040e076764ae60306ae72">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a95b79086652841c41a73539c91a0f2b1">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a0d9b0c176c9ea1151d63d07c045e2d94">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a0097d0243c3e44e8ea97a2f68d2cc0f9">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#abfeb64b810b52e56dd14ca7be3535475">swap</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a85b613762bdadf870e483a9991c5e4a9">the</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a1f4fc3faf86c8b1df43c82acc4d5a3c3">the</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a48ae24053b35755570230d2519b5057f">is</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ad651fa0b1d445834f8473b4a6579199a">isUnset</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac0ca6dd8afb4d29339e70c9d32705314">print</a> (bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a46db5dc454d69d36b323347fbea4e68e">typeIndex</a> () const</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class A1, class A2, class A3, class A4&gt;<br/>
 class bdlb::Variant4&lt; A1, A2, A3, A4 &gt;</h3>

<p>This class is a "specialization" of <code><a class="el" href="classbdlb_1_1Variant.html">Variant</a></code> for a fixed number (4) of types. Its 4 template arguments <em>must</em> all be specified (none are defaulted to <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>). It provides the same functionality as <code><a class="el" href="classbdlb_1_1Variant.html">Variant</a>&lt;A1, A2, ..., A4&gt;</code>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae0cb27beeb87cfbaecdcdec1f6448be8"></a><!-- doxytag: member="bdlb::Variant4::Variant4" ref="ae0cb27beeb87cfbaecdcdec1f6448be8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::<a class="el" href="classbdlb_1_1Variant4.html">Variant4</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a variant object in the unset state that uses the currently installed default allocator to supply memory. </p>

</div>
</div>
<a class="anchor" id="a0f27db7cd19b5ddbb2eb995882e6a455"></a><!-- doxytag: member="bdlb::Variant4::Variant4" ref="a0f27db7cd19b5ddbb2eb995882e6a455" args="(const TYPE_OR_ALLOCATOR &amp;typeOrAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
<div class="memtemplate">
template&lt;class TYPE_OR_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::<a class="el" href="classbdlb_1_1Variant4.html">Variant4</a> </td>
          <td>(</td>
          <td class="paramtype">const TYPE_OR_ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>typeOrAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a variant object with the specified <code>typeOrAlloc</code> that can be either a value of a type that the variant can hold or an allocator to supply memory. If <code>typeOrAlloc</code> is not a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>, then the variant will hold the value and type of <code>typeOrAlloc</code>, and use the currently installed default allocator to supply memory. Otherwise, the variant will be unset and use <code>typeOrAlloc</code> to supply memory. Note that this parameterized constructor is defined instead of two constructors (one taking a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> and the other not) because template parameter arguments are always a better match than derived-to-base conversion (a concrete allocator pointer converted to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>). </p>

</div>
</div>
<a class="anchor" id="a58a2ac4d3d5ab5f8f89787a36aa42597"></a><!-- doxytag: member="bdlb::Variant4::Variant4" ref="a58a2ac4d3d5ab5f8f89787a36aa42597" args="(const TYPE &amp;value, bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::<a class="el" href="classbdlb_1_1Variant4.html">Variant4</a> </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a variant object having the specified <code>value</code> and that uses the specified <code>basicAllocator</code> to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a5951f38da37366555ff881221c10e0a1"></a><!-- doxytag: member="bdlb::Variant4::Variant4" ref="a5951f38da37366555ff881221c10e0a1" args="(const Variant4 &amp;original, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::<a class="el" href="classbdlb_1_1Variant4.html">Variant4</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>&lt; A1, A2, A3, A4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a variant object having the type and value of the specified <code>original</code> variant. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7223434dab4ec60d30ae2257d2c77918"></a><!-- doxytag: member="bdlb::Variant4::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="a7223434dab4ec60d30ae2257d2c77918" args="(Variant4, bslma::UsesBslmaAllocator, Traits::k_VARIANT_USES_BSLMA_ALLOCATOR)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>&lt; A1, A2, A3, A4 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_USES_BSLMA_ALLOCATOR&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb39e230a616123f70a13cbd6e0dd427"></a><!-- doxytag: member="bdlb::Variant4::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="afb39e230a616123f70a13cbd6e0dd427" args="(Variant4, bsl::is_trivially_copyable, Traits::k_VARIANT_IS_BITWISE_COPYABLE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>&lt; A1, A2, A3, A4 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_IS_BITWISE_COPYABLE&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c0632f00fa60b210c37252d29d2f3bd"></a><!-- doxytag: member="bdlb::Variant4::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="a6c0632f00fa60b210c37252d29d2f3bd" args="(Variant4, bslmf::IsBitwiseMoveable, Traits::k_VARIANT_IS_BITWISE_MOVEABLE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>&lt; A1, A2, A3, A4 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_IS_BITWISE_MOVEABLE&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22a9ce77a23a68f1ee348e46d3c57465"></a><!-- doxytag: member="bdlb::Variant4::BSLMF_NESTED_TRAIT_DECLARATION" ref="a22a9ce77a23a68f1ee348e46d3c57465" args="(Variant4, HasPrintMethod)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>&lt; A1, A2, A3, A4 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlb_1_1HasPrintMethod.html">HasPrintMethod</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2d8d741408c154e7348e81759249340"></a><!-- doxytag: member="bdlb::Variant4::operator=" ref="ae2d8d741408c154e7348e81759249340" args="(const TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>&lt; A1, A2, A3, A4 &gt; &amp; <a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the specified <code>value</code> of template parameter <code>TYPE</code>, and return a reference providing modifiable access to this object. The value previously held by this variant (if any) will be destroyed if the value's type is different from <code>TYPE</code>. </p>

<p>Reimplemented from <a class="el" href="classbdlb_1_1VariantImp.html#a8f97697cd28feab8391f4c3ec964e490">bdlb::VariantImp&lt; bslmf::TypeList4&lt; A1, A2, A3, A4 &gt;::ListType &gt;</a>.</p>

<p>References <a class="el" href="classbdlb_1_1VariantImp.html#a8f97697cd28feab8391f4c3ec964e490">bdlb::VariantImp&lt; TYPES &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a496ac61d38eb4e60a2871db9f13a7ead"></a><!-- doxytag: member="bdlb::Variant4::operator=" ref="a496ac61d38eb4e60a2871db9f13a7ead" args="(const Variant4 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>&lt; A1, A2, A3, A4 &gt; &amp; <a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a>&lt; A1, A2, A3, A4 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlb_1_1Variant4.html">Variant4</a>&lt; A1, A2, A3, A4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the type and value currently held by the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. The value previously held by this variant (if any) will be destroyed if the value's type is different from the type held by the <code>rhs</code> object. </p>

<p>References <a class="el" href="classbdlb_1_1VariantImp.html#a8f97697cd28feab8391f4c3ec964e490">bdlb::VariantImp&lt; TYPES &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4cb5a21e55a725a65df694b212153c0"></a><!-- doxytag: member="bdlb::Variant4::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="ad4cb5a21e55a725a65df694b212153c0" args="(VariantImp, bslma::UsesBslmaAllocator, Traits::k_VARIANT_USES_BSLMA_ALLOCATOR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_USES_BSLMA_ALLOCATOR&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a32cab2873477483af8131be1bc07a09b"></a><!-- doxytag: member="bdlb::Variant4::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="a32cab2873477483af8131be1bc07a09b" args="(VariantImp, bsl::is_trivially_copyable, Traits::k_VARIANT_IS_BITWISE_COPYABLE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_IS_BITWISE_COPYABLE&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9cd7543df79ed2407548ee42e90730de"></a><!-- doxytag: member="bdlb::Variant4::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="a9cd7543df79ed2407548ee42e90730de" args="(VariantImp, bslmf::IsBitwiseMoveable, Traits::k_VARIANT_IS_BITWISE_MOVEABLE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_IS_BITWISE_MOVEABLE&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b6c68e8c0b6ee9b71c2341b8bd0cb2e"></a><!-- doxytag: member="bdlb::Variant4::BSLMF_NESTED_TRAIT_DECLARATION" ref="a9b6c68e8c0b6ee9b71c2341b8bd0cb2e" args="(VariantImp, HasPrintMethod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlb_1_1HasPrintMethod.html">HasPrintMethod</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb101113e18074b8505b805a41223aca"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="adb101113e18074b8505b805a41223aca" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a6be1807dfbad0a238ee8e86f04a602ef"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a6be1807dfbad0a238ee8e86f04a602ef" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="ae026b1ec6ce386f79df27bcae5095e7b"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="ae026b1ec6ce386f79df27bcae5095e7b" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a4d326b36c512e898c296fc85628f1fd4"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a4d326b36c512e898c296fc85628f1fd4" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a3498eb7142531106fc2f0fcf0d2da048"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a3498eb7142531106fc2f0fcf0d2da048" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="ac742413e7dcd96c2616c61687f47fa02"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="ac742413e7dcd96c2616c61687f47fa02" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="ae16dc8d814ae0526c4b01afeff2468f9"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="ae16dc8d814ae0526c4b01afeff2468f9" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="a9d36ef713685b260c8f49e2f351bb10e"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a9d36ef713685b260c8f49e2f351bb10e" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="af5013ec99d595e043c7bd9c6f4848a1a"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="af5013ec99d595e043c7bd9c6f4848a1a" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aac0a70a70a7624c596946ce233568729"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="aac0a70a70a7624c596946ce233568729" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. </p>

</div>
</div>
<a class="anchor" id="a72244d9987e7cfe977d8886496b1318f"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a72244d9987e7cfe977d8886496b1318f" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1dd418efc55f677c047eaf72515a5296"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a1dd418efc55f677c047eaf72515a5296" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. </p>

</div>
</div>
<a class="anchor" id="af586fd4ed208906fb5b483a5a3e083cf"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="af586fd4ed208906fb5b483a5a3e083cf" args="(VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="aac9e8406f3d1b84e8097e6762176c486"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="aac9e8406f3d1b84e8097e6762176c486" args="(const VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the 'visitor. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a5ccf228532d68f4268f425fdee18d76d"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a5ccf228532d68f4268f425fdee18d76d" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a29581a916dde16b7f173ca2cb3a70984"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a29581a916dde16b7f173ca2cb3a70984" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="ab56eb7ec3868f812931515c98d923f8a"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="ab56eb7ec3868f812931515c98d923f8a" args="(VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="af00bd438b8d24bd3e3aa533981e9bb5d"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="af00bd438b8d24bd3e3aa533981e9bb5d" args="(const VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="ae96a144d889177e6a8d46c5a0bc5564f"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="ae96a144d889177e6a8d46c5a0bc5564f" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="a98ec3a6c252c6cadf1ae9f3399c5158d"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a98ec3a6c252c6cadf1ae9f3399c5158d" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="a8efc00326eb4915f7115b267e18c6d74"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a8efc00326eb4915f7115b267e18c6d74" args="(VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a40c0b811ebc75e498b4e19c509f7aa48"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a40c0b811ebc75e498b4e19c509f7aa48" args="(const VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. </p>

</div>
</div>
<a class="anchor" id="a5b463b58a2d92ef2967c58ec0a70bcae"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a5b463b58a2d92ef2967c58ec0a70bcae" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a368a2294b3fecb0c3974b47decb27d0a"></a><!-- doxytag: member="bdlb::Variant4::apply" ref="a368a2294b3fecb0c3974b47decb27d0a" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. </p>

</div>
</div>
<a class="anchor" id="a49a2f2ad828c95f4509968410065902c"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a49a2f2ad828c95f4509968410065902c" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="ac3dc427ff8b114ca6d9912aeb9a70509"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="ac3dc427ff8b114ca6d9912aeb9a70509" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a95eb485c396800b6ecbbd398a1028def"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a95eb485c396800b6ecbbd398a1028def" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a9508f2c5f01b2e0f57f60316252b5742"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a9508f2c5f01b2e0f57f60316252b5742" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a1e3fc332e52d38502782757de28fe1c2"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a1e3fc332e52d38502782757de28fe1c2" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f375f4f3550e0edc61334141db24a83"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a5f375f4f3550e0edc61334141db24a83" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. </p>

</div>
</div>
<a class="anchor" id="a273341128334d6bd2e0dc225903fc9e2"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a273341128334d6bd2e0dc225903fc9e2" args="(VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a601e31b22354bdd8696980217d8f7ece"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a601e31b22354bdd8696980217d8f7ece" args="(const VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a62637a61fdc40f1f6cf0c59c5dcc18a0"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a62637a61fdc40f1f6cf0c59c5dcc18a0" args="(VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="afdad7a39dd5235a9857a971c7e32e773"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="afdad7a39dd5235a9857a971c7e32e773" args="(const VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a9fa5a573fa079eb39e4e3c8b9f760815"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a9fa5a573fa079eb39e4e3c8b9f760815" args="(VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a399ed4ce14fc0eb57a084f2bf684ffca"></a><!-- doxytag: member="bdlb::Variant4::applyRaw" ref="a399ed4ce14fc0eb57a084f2bf684ffca" args="(const VISITOR &amp;visitor) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. </p>

</div>
</div>
<a class="anchor" id="ac33e36612ea9abffc9dfa36313b28572"></a><!-- doxytag: member="bdlb::Variant4::assign" ref="ac33e36612ea9abffc9dfa36313b28572" args="(const TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the specified <code>value</code> of template parameter <code>TYPE</code>, and return a reference providing modifiable access to this object. The value previously held by this variant (if any) will be destroyed if the value's type is different from <code>TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="ac9e7872b8e4a6e0d9369a28b56438e34"></a><!-- doxytag: member="bdlb::Variant4::assignTo" ref="ac9e7872b8e4a6e0d9369a28b56438e34" args="(const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::assignTo </td>
          <td>(</td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the specified <code>value</code> of template parameter <code>SOURCE_TYPE</code>, and return a reference providing modifiable access to this object. The value previously held by this variant (if any) will be destroyed if the value's type is different from the template parameter <code>TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="a439d5f8acd4b43a94d16b58131746c53"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a439d5f8acd4b43a94d16b58131746c53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4f4327412acef29630615a49f3e2b49"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="ad4f4327412acef29630615a49f3e2b49" args="(const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab5f7438ce8b607a3dc2ceae5060713e"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="aab5f7438ce8b607a3dc2ceae5060713e" args="(const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e2d13dfd58e838b29030bf286def834"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a8e2d13dfd58e838b29030bf286def834" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf5cf76575cc460012ccaaddcd908a9a"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="acf5cf76575cc460012ccaaddcd908a9a" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a88a84dc69e6d1bfffe8ef7a0bd610ebf"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a88a84dc69e6d1bfffe8ef7a0bd610ebf" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adc1b8f2f21a1f452509e6d4734d07162"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="adc1b8f2f21a1f452509e6d4734d07162" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65c1b4932550561a75882315dbe76ab3"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a65c1b4932550561a75882315dbe76ab3" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8b1980441158ef0a50f2a14db3f6e7c"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="ad8b1980441158ef0a50f2a14db3f6e7c" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af394aa26741fba5094940f7643077f8f"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="af394aa26741fba5094940f7643077f8f" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a4bc79b9a7856bc04c33a0040315ede"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a9a4bc79b9a7856bc04c33a0040315ede" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6850996bc498c51d509657e7ab586442"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a6850996bc498c51d509657e7ab586442" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a11c5fc455e6040e076764ae60306ae72"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a11c5fc455e6040e076764ae60306ae72" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a95b79086652841c41a73539c91a0f2b1"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a95b79086652841c41a73539c91a0f2b1" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d9b0c176c9ea1151d63d07c045e2d94"></a><!-- doxytag: member="bdlb::Variant4::createInPlace" ref="a0d9b0c176c9ea1151d63d07c045e2d94" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an instance of the template parameter <code>TYPE</code> in this variant object with up to 14 parameters using the allocator currently held by this variant to supply memory. This method first destroys the current value held by the variant (even if <code>TYPE</code> is the same as the current type held). The behavior is undefined unless <code>TYPE</code> is one of the types that this variant holds. Note the order of the template arguments was chosen so that <code>TYPE</code> must always be specified. </p>

</div>
</div>
<a class="anchor" id="a0097d0243c3e44e8ea97a2f68d2cc0f9"></a><!-- doxytag: member="bdlb::Variant4::reset" ref="a0097d0243c3e44e8ea97a2f68d2cc0f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the current value held by this variant (if any), and reset this variant to the unset state. </p>

</div>
</div>
<a class="anchor" id="abfeb64b810b52e56dd14ca7be3535475"></a><!-- doxytag: member="bdlb::Variant4::swap" ref="abfeb64b810b52e56dd14ca7be3535475" args="(VariantImp &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the value of this object with the value of the specified <code>other</code> object. This method provides the no-throw guarantee if the <code>TYPE</code> template parameter has a no-throw <code>swap</code> and the two variant objects being swapped have the same type; otherwise this method provides the basic guarantee. </p>

</div>
</div>
<a class="anchor" id="a85b613762bdadf870e483a9991c5e4a9"></a><!-- doxytag: member="bdlb::Variant4::the" ref="a85b613762bdadf870e483a9991c5e4a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TYPE&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::the </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the value of the template parameter <code>TYPE</code> held by this variant object. The behavior is undefined unless <code>is&lt;TYPE&gt;()</code> returns <code>true</code> and <code>TYPE</code> is not <code>void</code>. Note that <code>TYPE</code> must be specified explicitly, e.g., <code>myValue.the&lt;int&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="a1f4fc3faf86c8b1df43c82acc4d5a3c3"></a><!-- doxytag: member="bdlb::Variant4::the" ref="a1f4fc3faf86c8b1df43c82acc4d5a3c3" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const TYPE&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::the </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the value of the template parameter <code>TYPE</code> held by this variant object. The behavior is undefined unless <code>is&lt;TYPE&gt;()</code> returns <code>true</code> and <code>TYPE</code> is not <code>void</code>. Note that <code>TYPE</code> must be specified explicitly, e.g., <code>myValue.the&lt;int&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="a48ae24053b35755570230d2519b5057f"></a><!-- doxytag: member="bdlb::Variant4::is" ref="a48ae24053b35755570230d2519b5057f" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::is </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value held by this variant object is of the template parameter <code>TYPE</code>, and <code>false</code> otherwise. Note that <code>TYPE</code> must be specified explicitly, e.g., <code>myValue.is&lt;int&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="ad651fa0b1d445834f8473b4a6579199a"></a><!-- doxytag: member="bdlb::Variant4::isUnset" ref="ad651fa0b1d445834f8473b4a6579199a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::isUnset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this variant is currently unset, and <code>false</code> otherwise. An unset variant does not hold a value or type. Note that this method should be preferred over checking the type index of the variant. </p>

</div>
</div>
<a class="anchor" id="ac0ca6dd8afb4d29339e70c9d32705314"></a><!-- doxytag: member="bdlb::Variant4::print" ref="ac0ca6dd8afb4d29339e70c9d32705314" args="(bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::print </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format this object to the specified output <code>stream</code> at the (absolute value of) the optionally specified indentation <code>level</code> and return a reference to <code>stream</code>. If <code>level</code> is specified, optionally specify <code>spacesPerLevel</code>, the number of spaces per indentation level for this and all of its nested objects. If <code>level</code> is negative, suppress indentation of the first line. If <code>spacesPerLevel</code> is negative, format the entire output on one line, suppressing all but the initial indentation (as governed by <code>level</code>). If <code>stream</code> is not valid on entry, this operation has no effect. Note that the string "(* UNPRINTABLE *)" will be printed if the object held by this variant is not printable, and the string "(* NULL *)" will be printed if this variant holds no object. </p>

</div>
</div>
<a class="anchor" id="a46db5dc454d69d36b323347fbea4e68e"></a><!-- doxytag: member="bdlb::Variant4::typeIndex" ref="a46db5dc454d69d36b323347fbea4e68e" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; <a class="el" href="structbslmf_1_1TypeList4.html">bslmf::TypeList4</a>&lt; A1, A2, A3, A4 &gt;::ListType  &gt;::typeIndex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index in the list of <code>TYPES</code> corresponding to the type of the value currently held by this variant object (starting at 1), or 0 if this object is unset. Note that instead of switching code on the type index, calling <code>apply</code> is the preferred method of manipulating different types stored inside a variant. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlb__variant_8h_source.html">bdlb_variant.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:35 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
