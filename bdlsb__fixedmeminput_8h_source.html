<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlsb_fixedmeminput.h                                              -*-C++-*-
#ifndef INCLUDED_BDLSB_FIXEDMEMINPUT
#define INCLUDED_BDLSB_FIXEDMEMINPUT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a basic input stream buffer using a client buffer.
//
//@CLASSES:
//   bdlsb::FixedMemInput: basic input stream buffer using client memory
//
//@SEE_ALSO: bdesb::fixedmeminstreambuf
//
//@DESCRIPTION: This component provides a mechanism, &#39;bdlsb::FixedMemInput&#39;,
// that implements the input portion of the &#39;bsl::basic_streambuf&#39; protocol
// using a client-supplied memory buffer.  Method names necessarily correspond
// to the protocol-specified method names.  Clients supply the character buffer
// at stream buffer construction, and can later reinitialize the stream buffer
// with a different character buffer by calling the &#39;pubsetbuf&#39; method.  This
// component provides none of the output-related functionality of
// &#39;bsl::basic_streambuf&#39; nor does it use locales in any way.  The only
// difference between this component and &#39;bdlsb::FixedMemInStreamBuf&#39; is that
// the class &#39;bdlsb::FixedMemInput&#39; does *not* derive from a &#39;bsl::streambuf&#39;,
// and is generally more efficient (at initialization and due to the lack of
// virtual functions).  It is especially designed for streaming a very small
// amount of information from a fixed-length buffer using a
// &#39;bslx_genericinstream&#39;.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Use of &#39;bdlsb::FixedMemInput&#39;
/// - - - - - - - - - - - - - - - - - - - - - - -
// The &#39;bdlsb::FixedMemInput&#39; class is intended to be used as a template
// parameter to the &#39;bslx::GenericInStream&#39; class.  Such specialization
// provides user with performance efficient way to unexternalize BDEX encoded
// data from an existing character buffer.
//
// See the &#39;bslx_genericinstream&#39; component usage example for a more practical
// example of using &#39;bslx&#39; streams.
//
// This example demonstrates instantiating a template, &#39;bslx::GenericInStream&#39;,
// on a &#39;bdlsb::FixedMemInput&#39; object and using the &#39;bslx::GenericInStream&#39;
// object to stream in some data.
//
// First, create &#39;bslx::ByteOutStream&#39; &#39;outStream&#39; and externalize some user
// data to it.  Note that this code only prepares the character buffer that is
// used to illustrate the purpose of the &#39;bdlsb::FixedMemInput&#39; class.
//..
//  bslx::ByteOutStream outStream(20131127);
//
//  unsigned int MAGIC = 0x1812;
//
//  outStream.putUint32(MAGIC);
//  outStream.putInt32(83);
//  outStream.putString(bsl::string(&quot;test&quot;));
//  assert(outStream.isValid());
//..
// Next, create a &#39;bdlsb::FixedMemInput&#39; stream buffer initialized with the
// buffer from the &#39;bslx::ByteOutStream&#39; object &#39;outStream&#39;:
//..
//  bdlsb::FixedMemInput streamBuffer(outStream.data(), outStream.length());
//..
// Then, create the &#39;bslx::GenericInStream&#39; stream parametrized with
// &#39;bdlsb::FixedMemInput&#39;:
//..
//  bslx::GenericInStream&lt;bdlsb::FixedMemInput&gt;  inStream(&amp;streamBuffer);
//..
// Now, use resulting &#39;inStream&#39; to unexternalize user data:
//..
//  unsigned int  magic;
//  int           key;
//  bsl::string   value;
//
//  inStream.getUint32(magic);
//  inStream.getInt32(key);
//  inStream.getString(value);
//  assert(inStream.isValid());
//..
// Finally, verify that the data from the supplied buffer was unexternalized
// correctly:
//..
//  assert(MAGIC  == magic);
//  assert(83     == key);
//  assert(&quot;test&quot; == value);
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include &lt;bsl_cstdlib.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#ifndef INCLUDED_BSL_IOS
#include &lt;bsl_ios.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace bdlsb {

                        // ===================
                        // class FixedMemInput
                        // ===================

class FixedMemInput {
    // This class, like &#39;bdlsb::FixedMemInStreamBuf&#39;, implements the input
    // functionality of the &#39;basic_streambuf&#39; interface, using client-supplied
    // &#39;char *&#39; memory.  It has an interface identical to
    // &#39;bdlsb::FixedMemInStreamBuf&#39; but does *not* inherit from
    // &#39;bsl::streambuf&#39;.  This implementation is advantageous for performance
    // reasons, as the overhead of the initialization and virtual function
    // calls of a &#39;bsl::streambuf&#39; can be undesirable.  It is especially
    // designed for streaming a very small amount of information from a
    // fixed-length buffer using a &#39;bslx_genericinstream&#39; when the number of
    // characters read from the input is guaranteed not to exceed the length of
    // the buffer.  Note that this class is not designed to be derived from.

  public:
    // TYPES
    typedef char                    char_type;
    typedef bsl::char_traits&lt;char&gt;  traits_type;
    typedef traits_type::int_type   int_type;
    typedef traits_type::pos_type   pos_type;
    typedef traits_type::off_type   off_type;

  private:
    // PRIVATE DATA MEMBERS
    const char      *d_buffer_p;      // buffer (held, not owned)
    bsl::size_t      d_bufferSize;    // buffer size (not length of stream)
    bsl::size_t      d_pos;           // current read position

  private:
    // NOT IMPLEMENTED
    FixedMemInput(const FixedMemInput&amp;);
    FixedMemInput&amp; operator=(const FixedMemInput&amp;);

  public:
    // CREATORS
    FixedMemInput(const char *buffer, bsl::size_t length);
        // Create a &#39;FixedMemInput&#39; using the specified &#39;buffer&#39; of the
        // specified &#39;length&#39;.  The position indicator is set to the beginning
        // of the &#39;buffer&#39;.  The behavior is undefined unless
        // &#39;buffer != 0 &amp;&amp; length &gt; 0&#39; or &#39;length == 0&#39;.  Note that &#39;buffer&#39; is
        // held but not owned.

    //! ~FixedMemInput();
        // Destroy this stream buffer.  Note that this trivial destructor is
        // generated by the compiler.

    // MANIPULATORS
    bsl::streamsize in_avail();
        // Return the number of characters available from the current read
        // position in this stream buffer.

                             // *** 27.5.2.2.2 buffer and positioning: ***

    FixedMemInput *pubsetbuf(const char *buffer, bsl::streamsize  length);
        // Reinitialize this stream buffer to use the specified character
        // &#39;buffer&#39; having the specified &#39;length&#39;.  Return a pointer providing
        // modifiable access to this stream buffer.  The behaviour is undefined
        // unless &#39;buffer != 0 &amp;&amp; length &gt; 0&#39; or &#39;length == 0&#39;.  Upon
        // reinitialization for use of the new  buffer, the position indicator
        // is set the the beginning of the &#39;buffer&#39;.  Note that &#39;buffer&#39; is
        // held but not owned.

    pos_type pubseekoff(off_type                offset,
                        bsl::ios_base::seekdir  way,
                        bsl::ios_base::openmode which = bsl::ios_base::in);
        // Set the position indicator to the relative specified &#39;offset&#39; from
        // the base position indicated by the specified &#39;way&#39; and return the
        // resulting absolute position on success or pos_type(-1) on failure.
        // Optionally specify &#39;which&#39; area of the stream buffer.  The seek
        // operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::in&#39; or if the resulting absolute position is less
        // than zero or greater than the value returned by &#39;length&#39;.

    pos_type pubseekpos(pos_type                position,
                        bsl::ios_base::openmode which = bsl::ios_base::in);
        // Set the position indicator to the specified &#39;position&#39; and return
        // the resulting absolute position on success or pos_type(-1) on
        // failure.  Optionally specify &#39;which&#39; area of the stream buffer.  The
        // &#39;seekpos&#39; operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::in&#39; or if position is less then zero or greater
        // than the value returned by &#39;length&#39;.

                             // *** 27.5.2.2.3 Get area: ***

    int_type sbumpc();
        // Return the character at the current read position from this buffer,
        // or &#39;traits_type::eof()&#39; if the end of the buffer is reached and
        // advance read position indicator.

    int_type sgetc();
        // Return the character at the current read position from this buffer,
        // or &#39;traits_type::eof()&#39; if the end of the buffer is reached.

    bsl::streamsize sgetn(char_type *destination, bsl::streamsize length);
        // Read the specified &#39;length&#39; characters to the specified
        // &#39;destination&#39;.  Return the number of characters successfully read
        // from this buffer, which is either equal to the &#39;length&#39; parameter or
        // equal to the distance from the current read position to the end of
        // the input buffer, whichever is smaller, and move the read cursor
        // position by this amount.  The behavior is undefined unless &#39;0 &lt;=
        // length&#39;.

    int_type snextc();
        // Advance the current read position and return the character at the
        // resulting position from this buffer, or &#39;traits_type::eof()&#39; if the
        // end of the buffer is reached.

                             // *** 27.5.2.2.4 Putback: ***

    int_type sputbackc(char c);
        // Move the current read position back one character if the current
        // read position is not at the beginning of the buffer and the previous
        // position contains the specified character &#39;c&#39;, and return that
        // character.  Otherwise, return &#39;traits_type::eof()&#39; and do not move
        // the current read position.

    int_type sungetc();
        // Move the current read position back one character if the current
        // read position is not at the beginning of the buffer, and return the
        // character at the resulting current read position from this buffer.
        // Return &#39;traits_type::eof()&#39; otherwise.

    // ACCESSORS
    bsl::size_t capacity() const;
        // Return the size for the buffer held by this buffer, in bytes,
        // supplied at construction.

    const char *data() const;
        // Return the address of the non-modifiable character buffer held by
        // this stream buffer.

    bsl::size_t length() const;
        // Return the number of characters that can be successfully read from
        // this stream buffer before reading &#39;traits_type::eof()&#39; -- i.e., the
        // number of characters between the current read position and the end
        // of this buffer.
};

// ============================================================================
//                               INLINE DEFINITIONS
// ============================================================================

                        // -------------------
                        // class FixedMemInput
                        // -------------------

// CREATORS
inline
FixedMemInput::FixedMemInput(const char *buffer, bsl::size_t length)
: d_buffer_p(const_cast&lt;char *&gt;(buffer))
, d_bufferSize(length)
, d_pos(0)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
}

// MANIPULATORS
inline
bsl::streamsize FixedMemInput::in_avail()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos == d_bufferSize)) {
        return bsl::streamsize(-1);                                   // RETURN
    }
    return static_cast&lt;bsl::streamsize&gt;(d_bufferSize - d_pos);
}

inline
FixedMemInput *FixedMemInput::pubsetbuf(const char      *buffer,
                                        bsl::streamsize  length)

{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    d_buffer_p   = buffer;
    d_bufferSize = static_cast&lt;bsl::size_t&gt;(length);
    d_pos        = 0;
    return this;
}

inline
FixedMemInput::int_type FixedMemInput::sbumpc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos &gt;= d_bufferSize)) {
        return traits_type::eof();                                    // RETURN
    }
    const int_type i = traits_type::to_int_type(d_buffer_p[d_pos]);
    d_pos += 1;
    return i;
}

inline
FixedMemInput::int_type FixedMemInput::sgetc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos &gt;= d_bufferSize)) {
        return traits_type::eof();                                    // RETURN
    }
    //return traits_type::to_int_type(d_buffer_p[static_cast&lt;IntPtr&gt;(d_pos)]);
    return traits_type::to_int_type(d_buffer_p[d_pos]);
}

inline
bsl::streamsize
FixedMemInput::sgetn(char *destination, bsl::streamsize length)
{
    BSLS_ASSERT_SAFE(0 &lt;= length);

    const bsl::size_t current = d_pos;
    d_pos += static_cast&lt;bsl::size_t&gt;(length);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY((d_pos &gt; d_bufferSize) ||
                                              (d_pos &lt; current) )) {
        d_pos    = d_bufferSize;
        length = static_cast&lt;bsl::streamsize&gt;(d_bufferSize - current);
    }
    bsl::memcpy(destination, d_buffer_p+current, length);
    return length;
}

inline
FixedMemInput::int_type FixedMemInput::snextc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos &gt;= d_bufferSize)) {
        return traits_type::eof();                                    // RETURN
    }
    d_pos += 1;
    return sgetc();
}

inline
FixedMemInput::int_type FixedMemInput::sputbackc(char c)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(0 == d_pos)
     || BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(c != d_buffer_p[d_pos-1])) {
        return traits_type::eof();                                    // RETURN
    }
    d_pos -= 1;
    return traits_type::to_int_type(c);
}

inline
FixedMemInput::int_type FixedMemInput::sungetc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(0 == d_pos)) {
        return traits_type::eof();                                    // RETURN
    }
    d_pos -= 1;
    return traits_type::to_int_type(d_buffer_p[d_pos]);
}

// ACCESSORS
inline
bsl::size_t FixedMemInput::capacity() const
{
    return d_bufferSize;
}

inline
const char *FixedMemInput::data() const
{
    return d_buffer_p;
}

inline
bsl::size_t FixedMemInput::length() const
{
    return (d_bufferSize - d_pos);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------

</pre>
</body>
</html>
