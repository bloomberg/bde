<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlmt::ThreadPool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlmt.html">bdlmt</a>      </li>
      <li><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bdlmt::ThreadPool Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlmt::ThreadPool" -->
<p><code>#include &lt;<a class="el" href="bdlmt__threadpool_8h_source.html">bdlmt_threadpool.h</a>&gt;</code></p>

<p><a href="classbdlmt_1_1ThreadPool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a19841ed1f0fcc88d920afac2779280e8">Job</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#adb142db8b790070bfbb0a634f9dd6ec1">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlmt_1_1ThreadPool.html">ThreadPool</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a2d15d2390d65eb2b78e0e2b961782052">ThreadPool</a> (const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;threadAttributes, int minThreads, int maxThreads, int maxIdleTime, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#afff9b0793d0bc244e62fdb55446e623c">~ThreadPool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a2e7611a110cb4d0a1f86e743b08c3bba">drain</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a2aaa37c96f62b34e0defe21546018473">enqueueJob</a> (const <a class="el" href="classbdlmt_1_1ThreadPool.html#a19841ed1f0fcc88d920afac2779280e8">Job</a> &amp;functor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#aa9316eb434623faef36e8cc73afc9a56">enqueueJob</a> (<a class="el" href="namespacebdlmt.html#a3f5c0447dd2db7b73d45ba80b0356913">ThreadPoolJobFunc</a> function, void *userData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#abf05c8aa116cb479303c96d53eb9c99a">resetPercentBusy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#ab32e93359f0079e4f9d9c70e9ab5ecae">shutdown</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a38498e750de889908731d175fab25597">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a77848b243e19487815155c43e0ca3ebe">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a5bc8aaad0142256cc7604519b0c0b50d">maxThreads</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a019d4b74a681cca3a3f5923d5356f246">maxIdleTime</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a903ec2e869023047914906b1781390a4">minThreads</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a68eb240429b8ef63622c1061624de888">numActiveThreads</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#ad206b8ffe192b3e51e500fc916a54f0c">numPendingJobs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a9b4159f06fc8563b48923c97e3c07dea">numWaitingThreads</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#ad7e21e4c83fd5052180df359fc5fd8f0">percentBusy</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#ab99b21c01844d8900fbd98d721b48703">threadFailures</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1ThreadPool.html#a85932f92edcc55ef2b1f42295f7fb991">ThreadPoolEntry</a> (void *)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a thread pool used for concurrently executing multiple user-defined functions ("jobs"). </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a19841ed1f0fcc88d920afac2779280e8"></a><!-- doxytag: member="bdlmt::ThreadPool::Job" ref="a19841ed1f0fcc88d920afac2779280e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void()&gt; <a class="el" href="classbdlmt_1_1ThreadPool.html#a19841ed1f0fcc88d920afac2779280e8">bdlmt::ThreadPool::Job</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2d15d2390d65eb2b78e0e2b961782052"></a><!-- doxytag: member="bdlmt::ThreadPool::ThreadPool" ref="a2d15d2390d65eb2b78e0e2b961782052" args="(const bslmt::ThreadAttributes &amp;threadAttributes, int minThreads, int maxThreads, int maxIdleTime, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threadAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>minThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxIdleTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a thread pool with the specified <code>threadAttributes</code>, <code>minThread</code> and <code>maxThreads</code> minimum and maximum number of threads respectively, the specified <code>maxIdleTime</code> maximum idle time (in milliseconds), and using the optionally specified <code>basicAllocator</code>. </p>

</div>
</div>
<a class="anchor" id="afff9b0793d0bc244e62fdb55446e623c"></a><!-- doxytag: member="bdlmt::ThreadPool::~ThreadPool" ref="afff9b0793d0bc244e62fdb55446e623c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::ThreadPool::~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call <code><a class="el" href="classbdlmt_1_1ThreadPool.html#ab32e93359f0079e4f9d9c70e9ab5ecae">shutdown()</a></code> and destroy this thread pool. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adb142db8b790070bfbb0a634f9dd6ec1"></a><!-- doxytag: member="bdlmt::ThreadPool::BSLALG_DECLARE_NESTED_TRAITS" ref="adb142db8b790070bfbb0a634f9dd6ec1" args="(ThreadPool, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::ThreadPool::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1ThreadPool.html">ThreadPool</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e7611a110cb4d0a1f86e743b08c3bba"></a><!-- doxytag: member="bdlmt::ThreadPool::drain" ref="a2e7611a110cb4d0a1f86e743b08c3bba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::ThreadPool::drain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable queuing on this thread pool and wait until all pending jobs complete. Use <code>start</code> to re-enable queuing. </p>

</div>
</div>
<a class="anchor" id="a2aaa37c96f62b34e0defe21546018473"></a><!-- doxytag: member="bdlmt::ThreadPool::enqueueJob" ref="a2aaa37c96f62b34e0defe21546018473" args="(const Job &amp;functor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::enqueueJob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1ThreadPool.html#a19841ed1f0fcc88d920afac2779280e8">Job</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>functor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue the specified <code>functor</code> to be executed by the next available thread. Return 0 if enqueued successfully, and a non-zero value if queuing is currently disabled. The behavior is undefined unless <code>functor</code> is not "unset". See <code>bsl::function</code> for more information on functors. </p>

</div>
</div>
<a class="anchor" id="aa9316eb434623faef36e8cc73afc9a56"></a><!-- doxytag: member="bdlmt::ThreadPool::enqueueJob" ref="aa9316eb434623faef36e8cc73afc9a56" args="(ThreadPoolJobFunc function, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::enqueueJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebdlmt.html#a3f5c0447dd2db7b73d45ba80b0356913">ThreadPoolJobFunc</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue the specified <code>function</code> to be executed by the next available thread. The specified <code>userData</code> pointer will be passed to the function by the processing thread. Return 0 if enqueued successfully, and a non-zero value if queuing is currently disabled. </p>

</div>
</div>
<a class="anchor" id="abf05c8aa116cb479303c96d53eb9c99a"></a><!-- doxytag: member="bdlmt::ThreadPool::resetPercentBusy" ref="abf05c8aa116cb479303c96d53eb9c99a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double bdlmt::ThreadPool::resetPercentBusy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically report the percentage of wall time spent by each thread of this thread pool executing jobs since the last reset time, and set the reset time to now. The creation of the thread pool is considered a first reset time. This value is calculated as <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">                   sum(jobExecutionTime)       100%
          P_busy = --------------------   x ----------
                    timeSinceLastReset      <a class="code" href="classbdlmt_1_1ThreadPool.html#a5bc8aaad0142256cc7604519b0c0b50d">maxThreads</a>
</pre></div><p><br/>
<br/>
 Note that this percentage reflects the wall time spent per thread, and not CPU time per thread, or not even CPU time per processor. Also note that there is no guarantee that all threads are processed concurrently (e.g., the number of threads could be larger than the number of processors). </p>

</div>
</div>
<a class="anchor" id="ab32e93359f0079e4f9d9c70e9ab5ecae"></a><!-- doxytag: member="bdlmt::ThreadPool::shutdown" ref="ab32e93359f0079e4f9d9c70e9ab5ecae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::ThreadPool::shutdown </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable queuing on this thread pool, cancel all queued jobs, and shut down all processing threads (after all active jobs complete). </p>

</div>
</div>
<a class="anchor" id="a38498e750de889908731d175fab25597"></a><!-- doxytag: member="bdlmt::ThreadPool::start" ref="a38498e750de889908731d175fab25597" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable queuing on this thread pool and spawn <code><a class="el" href="classbdlmt_1_1ThreadPool.html#a903ec2e869023047914906b1781390a4">minThreads()</a></code> processing threads. Return 0 on success, and a non-zero value otherwise. If <code><a class="el" href="classbdlmt_1_1ThreadPool.html#a903ec2e869023047914906b1781390a4">minThreads()</a></code> threads were not successfully started, all threads are stopped. </p>

</div>
</div>
<a class="anchor" id="a77848b243e19487815155c43e0ca3ebe"></a><!-- doxytag: member="bdlmt::ThreadPool::stop" ref="a77848b243e19487815155c43e0ca3ebe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::ThreadPool::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable queuing on this thread pool and wait until all pending jobs complete, then shut down all processing threads. </p>

</div>
</div>
<a class="anchor" id="a5bc8aaad0142256cc7604519b0c0b50d"></a><!-- doxytag: member="bdlmt::ThreadPool::maxThreads" ref="a5bc8aaad0142256cc7604519b0c0b50d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::maxThreads </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of threads that are allowed to be running at given time. </p>

</div>
</div>
<a class="anchor" id="a019d4b74a681cca3a3f5923d5356f246"></a><!-- doxytag: member="bdlmt::ThreadPool::maxIdleTime" ref="a019d4b74a681cca3a3f5923d5356f246" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::maxIdleTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum amount of time (in milliseconds) a thread may remain idle before being shut down when there are more than min threads started. </p>

</div>
</div>
<a class="anchor" id="a903ec2e869023047914906b1781390a4"></a><!-- doxytag: member="bdlmt::ThreadPool::minThreads" ref="a903ec2e869023047914906b1781390a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::minThreads </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the minimum number of threads that must be started at any given time. </p>

</div>
</div>
<a class="anchor" id="a68eb240429b8ef63622c1061624de888"></a><!-- doxytag: member="bdlmt::ThreadPool::numActiveThreads" ref="a68eb240429b8ef63622c1061624de888" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::numActiveThreads </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of threads that are currently processing a job. </p>

</div>
</div>
<a class="anchor" id="ad206b8ffe192b3e51e500fc916a54f0c"></a><!-- doxytag: member="bdlmt::ThreadPool::numPendingJobs" ref="ad206b8ffe192b3e51e500fc916a54f0c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::numPendingJobs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of jobs that are currently queued, but not yet being processed. </p>

</div>
</div>
<a class="anchor" id="a9b4159f06fc8563b48923c97e3c07dea"></a><!-- doxytag: member="bdlmt::ThreadPool::numWaitingThreads" ref="a9b4159f06fc8563b48923c97e3c07dea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::numWaitingThreads </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of threads that are currently waiting for a job. </p>

</div>
</div>
<a class="anchor" id="ad7e21e4c83fd5052180df359fc5fd8f0"></a><!-- doxytag: member="bdlmt::ThreadPool::percentBusy" ref="ad7e21e4c83fd5052180df359fc5fd8f0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double bdlmt::ThreadPool::percentBusy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the percentage of wall time spent by each thread of this thread pool executing jobs since the last reset time. The creation of the thread pool is considered a first reset time. This value is calculated as <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">                   sum(jobExecutionTime)       100%
          P_busy = --------------------   x ----------
                    timeSinceLastReset      <a class="code" href="classbdlmt_1_1ThreadPool.html#a5bc8aaad0142256cc7604519b0c0b50d">maxThreads</a>
</pre></div><p><br/>
<br/>
 Note that this percentage reflects the wall time spent per thread, and not CPU time per thread, or not even CPU time per processor. Also note that there is no guarantee that all threads are processed concurrently (e.g., the number of threads could be larger than the number of processors). </p>

</div>
</div>
<a class="anchor" id="ab99b21c01844d8900fbd98d721b48703"></a><!-- doxytag: member="bdlmt::ThreadPool::threadFailures" ref="ab99b21c01844d8900fbd98d721b48703" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::ThreadPool::threadFailures </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of times that thread creation failed. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a85932f92edcc55ef2b1f42295f7fb991"></a><!-- doxytag: member="bdlmt::ThreadPool::ThreadPoolEntry" ref="a85932f92edcc55ef2b1f42295f7fb991" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ThreadPoolEntry </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Entry point for processing threads. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlmt__threadpool_8h_source.html">bdlmt_threadpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:32 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
