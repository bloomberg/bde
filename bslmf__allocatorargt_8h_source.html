<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmf_allocatorargt.h                                              -*-C++-*-
#ifndef INCLUDED_BSLMF_ALLOCATORARGT
#define INCLUDED_BSLMF_ALLOCATORARGT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a tag type to precede allocator arguments.
//
//@CLASSES:
//  bsl::allocator_arg_t: tag indicating the next parameter is an allocator
//
//@SEE_ALSO: bslalg_scalarprimitives
//
//@DESCRIPTION: The C++11 standard defines the empty class
// &#39;bsl::allocator_arg_t&#39; as a tag that precedes an argument of allocator type
// in circumstances where context alone cannot be used to determine which
// argument is an allocator.  Typically, this disambiguation is needed when a
// class has templated constructors taking variable numbers of arguments, each
// of which is of parameterized type.  If that class also uses an allocator (of
// either STL style or &#39;bslma&#39;/&#39;memory_resource&#39; style), then the allocator
// argument must be flagged as special.  An argument of type
// &#39;std::allocator_arg_t&#39; is used to distinguish constructors that take an
// allocator from constructors that don&#39;t.
//
// In addition to the &#39;allocator_arg_t&#39; class type, this component (and the
// standard) define a constant, &#39;allocator_arg&#39;, of type &#39;allocator_arg_t&#39;.
// That constant is used for passing an &#39;allocator_arg_t&#39; argument to a
// function or constructor.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Disambiguate a constructor invocation
/// - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to define a nullable type that can be in the full state
// (holding an object) or the null state (not holding an object).  When in the
// full state, memory is allocated for the held object using a memory
// allocator.  For simplicity, this memory allocator is not automatically
// propagated to the held object.
//
// First, we define a simple allocator class hierarchy with an abstract
// &#39;xyzma::Allocator&#39; base class and two derived classes:
// &#39;xyzma::NewDeleteAllocator&#39; and &#39;xyzma::TestAllocator&#39;:
//..
//  #include &lt;cstddef&gt;
//
//  namespace xyzma {
//
//  class Allocator {
//      // Abstract allocator base class
//  public:
//      virtual ~Allocator() { }
//
//      virtual void *allocate(std::size_t nbytes) = 0;
//      virtual void deallocate(void *ptr) = 0;
//  };
//
//  class NewDeleteAllocator : public Allocator {
//      // Concrete allocator that uses operators &#39;new&#39; and &#39;delete&#39;
//
//  public:
//      static NewDeleteAllocator* singleton();
//          // Returns a singleton instance of this class
//
//      virtual void *allocate(std::size_t nbytes);
//      virtual void deallocate(void *ptr);
//  };
//
//  NewDeleteAllocator *NewDeleteAllocator::singleton() {
//      static NewDeleteAllocator s;
//      return &amp;s;
//  }
//
//  void *NewDeleteAllocator::allocate(std::size_t nbytes) {
//      return ::operator new(nbytes);
//  }
//
//  void NewDeleteAllocator::deallocate(void *ptr) {
//      ::operator delete(ptr);
//  }
//
//  class TestAllocator : public Allocator {
//      // Concrete allocator that keeps track of number of blocks allocated
//      // and deallocated.
//
//      std::size_t d_allocatedBlocks;
//      std::size_t d_deallocatedBlocks;
//
//  public:
//      TestAllocator() : d_allocatedBlocks(0), d_deallocatedBlocks(0) { }
//
//      virtual void *allocate(std::size_t nbytes);
//      virtual void deallocate(void *ptr);
//
//      // ACCESSORS
//      std::size_t allocatedBlocks() const { return d_allocatedBlocks; }
//      std::size_t deallocatedBlocks() const { return d_deallocatedBlocks; }
//      std::size_t outstandingBlocks() const {
//          return d_allocatedBlocks - d_deallocatedBlocks;
//      }
//  };
//
//  void *TestAllocator::allocate(std::size_t nbytes) {
//      ++d_allocatedBlocks;
//      return ::operator new(nbytes);
//  }
//
//  void TestAllocator::deallocate(void *ptr) {
//      ++d_deallocatedBlocks;
//      ::operator delete(ptr);
//  }
//
//  }  // close namespace xyzma
//..
// Next, we define our nullable class template, declaring two constructors: one
// that constructs the null object, and one that constructs a non-null object
// using the specified constructor argument.  For flexibility, the second
// constructor is a template that takes any type and can therefore construct
// the object without necessarily invoking the copy constructor.  (Ideally,
// this second constructor would be variadic, but that is not necessary for
// this example.):
//..
//  #include &lt;new&gt;
//
//  namespace xyzutl {
//
//  template &lt;class TYPE&gt;
//  class Nullable {
//      xyzma::Allocator *d_alloc_p;
//      TYPE             *d_object_p;
//
//  public:
//      // CREATORS
//      Nullable();
//          // Construct a null object.  Note: this is ctor A.
//
//      template &lt;class ARG&gt;
//      Nullable(const ARG&amp; arg);
//          // Construct a non-null object using the specified &#39;arg&#39; as the
//          // constructor argument for the &#39;TYPE&#39; object.  Note: this is ctor
//          // B.
//..
// Next, we want to add constructors that supply an allocator for use by the
// &#39;Nullable&#39; object.  Our first thought is to add two more constructors like
// the two above, but with an additional allocator argument at the end:
//..
//      // Nullable(xyzma::Allocator *alloc);
//          // ctor C
//
//      // template &lt;class ARG&gt;
//      // Nullable(const ARG&amp; arg, xyzma::Allocator *alloc);
//          // ctor D
//..
// However, ctor C is difficult to invoke, because ctor B is almost always a
// better match.  Nor can we use SFINAE to disqualify ctor B in cases where
// ARG is &#39;xyzma::Allocator*&#39; because &#39;xyzma::Allocator*&#39; is a perfectly valid
// constructor argument for many &#39;TYPE&#39;s.
//
// We solve this problem by using &#39;allocator_arg_t&#39; to explicitly tag the
// constructor that takes an allocator argument:
//..
//      Nullable(bsl::allocator_arg_t, xyzma::Allocator *alloc);
//          // Construct a null object with the specified &#39;alloc&#39; allocator.
//          // Note: this is ctor E
//..
// The &#39;allocator_arg_t&#39; argument disambiguates the constructor.
//
// Next, to make things consistent (which is important for generic
// programming), we use the &#39;allocator_arg_t&#39; tag in the other allocator-aware
// constructor, as well:
//..
//      template &lt;class ARG&gt;
//      Nullable(bsl::allocator_arg_t,
//               xyzma::Allocator *alloc,
//               const ARG&amp;        arg);
//          // Construct a non-null object using the specified &#39;arg&#39; as the
//          // constructor argument for the &#39;TYPE&#39; object, and the specified
//          // &#39;alloc&#39; allocator.  Note: this is ctor F.
//..
// Next, we finish the class interface and implementation:
//..
//      ~Nullable();
//
//      // MANIPULATORS
//      Nullable&amp; operator=(const Nullable&amp; rhs);
//          // Copy assign this object from the specified &#39;rhs&#39;.
//
//      Nullable&amp; operator=(const TYPE&amp; rhs);
//          // Construct a non-null object holding a copy of the specified
//          // &#39;rhs&#39; object.
//
//      // ACCESSORS
//      const TYPE&amp; value() const { return *d_object_p; }
//          // Return the object stored in this Nullable. The behavior is
//          // undefined if this is null.
//
//      bool isNull() const { return ! d_object_p; }
//          // Returns true if this object is not null.
//
//      xyzma::Allocator *allocator() const { return d_alloc_p; }
//  };
//
//  template &lt;class TYPE&gt;
//  Nullable&lt;TYPE&gt;::Nullable()
//      : d_alloc_p(xyzma::NewDeleteAllocator::singleton())
//      , d_object_p(0)
//  {
//  }
//
//  template &lt;class TYPE&gt;
//  template &lt;class ARG&gt;
//  Nullable&lt;TYPE&gt;::Nullable(const ARG&amp; arg)
//      : d_alloc_p(xyzma::NewDeleteAllocator::singleton())
//      , d_object_p(static_cast&lt;TYPE*&gt;(d_alloc_p-&gt;allocate(sizeof(TYPE))))
//  {
//      ::new(d_object_p) TYPE(arg);
//  }
//
//  template &lt;class TYPE&gt;
//  Nullable&lt;TYPE&gt;::Nullable(bsl::allocator_arg_t, xyzma::Allocator *alloc)
//      : d_alloc_p(alloc)
//      , d_object_p(0)
//  {
//  }
//
//  template &lt;class TYPE&gt;
//  template &lt;class ARG&gt;
//  Nullable&lt;TYPE&gt;::Nullable(bsl::allocator_arg_t,
//                           xyzma::Allocator *alloc,
//                           const ARG&amp;        arg)
//      : d_alloc_p(alloc)
//      , d_object_p(static_cast&lt;TYPE*&gt;(d_alloc_p-&gt;allocate(sizeof(TYPE))))
//  {
//      ::new(d_object_p) TYPE(arg);
//  }
//
//  template &lt;class TYPE&gt;
//  Nullable&lt;TYPE&gt;::~Nullable() {
//      if (d_object_p) {
//          d_object_p-&gt;~TYPE();
//          d_alloc_p-&gt;deallocate(d_object_p);
//      }
//  }
//
//  template &lt;class TYPE&gt;
//  Nullable&lt;TYPE&gt;&amp; Nullable&lt;TYPE&gt;::operator=(const Nullable&amp; rhs) {
//      if (&amp;rhs == this) return *this;                               // RETURN
//      if (!isNull() &amp;&amp; !rhs.isNull()) {
//          *d_object_p = *rhs.d_object_p;
//      }
//      else if (!isNull() /* &amp;&amp; rhs.isNull() */) {
//          // Make null
//          d_object_p-&gt;~TYPE();
//          d_alloc_p-&gt;deallocate(d_object_p);
//          d_object_p = 0;
//      }
//      else if (/* isNull() &amp;&amp; */ !rhs.isNull()) {
//          // Allocate and copy from &#39;rhs&#39;
//          d_object_p = static_cast&lt;TYPE*&gt;(d_alloc_p-&gt;allocate(sizeof(TYPE)));
//          ::new(d_object_p) TYPE(*rhs.d_object_p);
//      }
//      // else both are null
//
//      return *this;
//  }
//
//  template &lt;class TYPE&gt;
//  Nullable&lt;TYPE&gt;&amp; Nullable&lt;TYPE&gt;::operator=(const TYPE&amp; rhs) {
//      if (isNull()) {
//          d_object_p = static_cast&lt;TYPE*&gt;(d_alloc_p-&gt;allocate(sizeof(TYPE)));
//          ::new(d_object_p) TYPE(*rhs.d_object_p);
//      }
//      else {
//          *d_object_p = rhs;
//      }
//
//      return *this;
//  }
//
//  }  // close namespace xyzutl
//..
// Now, for testing purposes, we define a class that takes an allocator
// constructor argument:
//..
//  class Obj {
//      xyzma::Allocator *d_alloc_p;
//      int               d_count;
//  public:
//      explicit Obj(xyzma::Allocator *alloc = 0)
//          : d_alloc_p(alloc), d_count(0)
//      {
//      }
//
//      Obj(int count, xyzma::Allocator *alloc = 0)                 // IMPLICIT
//          : d_alloc_p(alloc), d_count(count)
//      {
//      }
//
//      int count() const { return d_count; }
//      xyzma::Allocator *allocator() const { return d_alloc_p; }
//  };
//
//  bool operator==(const Obj&amp; a, const Obj&amp; b) {
//      return a.count() == b.count();
//  }
//
//  bool operator!=(const Obj&amp; a, const Obj&amp; b) {
//      return a.count() != b.count();
//  }
//..
// Finally, we test that our nullable type can be constructed with and without
// an allocator pointer and that the allocator pointer can unambiguously be
// used for the object&#39;s allocator.
//..
//  int main() {
//
//      using xyzutl::Nullable;
//
//      xyzma::TestAllocator ta;
//
//      Nullable&lt;Obj&gt; no1;
//      assert(  no1.isNull());
//      assert(xyzma::NewDeleteAllocator::singleton() == no1.allocator());
//
//      Nullable&lt;Obj&gt; no2(2);
//      assert(! no2.isNull());
//      assert(xyzma::NewDeleteAllocator::singleton() == no2.allocator());
//      assert(2 == no2.value());
//      assert(0 == no2.value().allocator());
//
//      Nullable&lt;Obj&gt; no3(bsl::allocator_arg, &amp;ta);
//      assert(  no3.isNull());
//      assert(&amp;ta == no3.allocator());
//      assert(0 == ta.outstandingBlocks());
//
//      Nullable&lt;Obj&gt; no4(bsl::allocator_arg, &amp;ta, 4);
//      assert(! no4.isNull());
//      assert(&amp;ta == no4.allocator());
//      assert(1 == ta.outstandingBlocks());
//      assert(4 == no4.value());
//      assert(0 == no4.value().allocator());
//
//      // &#39;&amp;ta&#39; used by &#39;Obj&#39;, not by &#39;Nullable&#39;.
//      Nullable&lt;Obj&gt; no5(&amp;ta);
//      assert(! no5.isNull());
//      assert(xyzma::NewDeleteAllocator::singleton() == no5.allocator());
//      assert(1 == ta.outstandingBlocks());  // No change
//      assert(0 == no5.value());
//      assert(&amp;ta == no5.value().allocator());
//
//      // &#39;&amp;ta&#39; used by both &#39;Nullable&#39; and by &#39;Obj&#39;
//      Nullable&lt;Obj&gt; no6(bsl::allocator_arg, &amp;ta, &amp;ta);
//      assert(! no6.isNull());
//      assert(&amp;ta == no6.allocator());
//      assert(2 == ta.outstandingBlocks());
//      assert(0 == no6.value());
//      assert(&amp;ta == no6.value().allocator());
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

namespace bsl {

                        // ======================
                        // struct allocator_arg_t
                        // ======================

struct allocator_arg_t {
    // Tag type indicating that next argument is an allocator.
    // TBD: If native library declares &#39;std::allocator_arg_t&#39;, then this
    // struct should be an replaced by an alias for &#39;std::allocator_arg_t&#39;.

};

static const allocator_arg_t allocator_arg = { };
    // Value of type &#39;allocator_arg_t&#39; used as actual argument to function
    // that takes an allocator argument.  Note that &#39;constexpr&#39; would be better
    // than &#39;const&#39; here, but any compiler that supports &#39;constexpr&#39; would also
    // provide this class and named value, that should be imported into
    // namespace &#39;bsl&#39; with using declarations instead.

}  // close namespace bsl

#endif // ! defined(INCLUDED_BSLMF_ALLOCATORARGT)

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
