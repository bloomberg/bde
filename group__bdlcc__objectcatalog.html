<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlcc_objectcatalog Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlcc_objectcatalog<br/>
<small>
[<a class="el" href="group__bdlcc.html">Package bdlcc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an efficient indexed, thread-safe object container.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlcc.html">bdlcc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Catalog Usage</a> </li>
<li>
<a href="#3.1.2">Example 2: Iterator Usage</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an efficient indexed, thread-safe object container. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlcc_1_1ObjectCatalog.html">bdlcc::ObjectCatalog</a> </td><td>templatized, thread-safe, indexed object container  </td></tr>
<tr>
<td><a class="el" href="classbdlcc_1_1ObjectCatalogIter.html">bdlcc::ObjectCatalogIter</a> </td><td>thread-safe iterator for <code><a class="el" href="classbdlcc_1_1ObjectCatalog.html">bdlcc::ObjectCatalog</a></code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-safe and efficient templatized catalog of objects. A <code><a class="el" href="classbdlcc_1_1ObjectCatalog.html">bdlcc::ObjectCatalog</a></code> supports efficient insertion of objects through the <code>add</code> method, which returns a handle that can be used for further reference to the newly added element. An element can be accessed by providing its handle to the <code>find</code> function. Thread-safe design implies that the element is returned by value into an object buffer rather than by reference (see this package documentation for a discussion of thread-safe container design). Likewise, an element can be modified by providing its handle and a new value to the <code>replace</code> method. Finally, an element can be removed by passing its handle to the <code>remove</code> method; the handle is then no longer valid and subsequent calls to <code>find</code> or <code>remove</code> with this handle will return 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1ObjectCatalogIter.html">bdlcc::ObjectCatalogIter</a></code> provides thread safe iteration through all the objects of an object catalog of parameterized <code>TYPE</code>. The order of the iteration is implementation defined. Thread safe iteration is provided by (read)locking the object catalog during the iterator's construction and unlocking it at the iterator's destruction. This guarantees that during the life time of an iterator, the object catalog can't be modified (however multiple threads can still concurrently read the object catalog). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_catalog_usage"></a> <a class="anchor" id="usage.example_1~3A_catalog_usage"></a> <a class="anchor" id="description.usage.example_1~3A_catalog_usage"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Catalog Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Consider a client sending queries to a server asynchronously. When the response to a query arrives, the client needs to invoke the callback associated with that query. For good performance, the callback should be invoked as quickly as possible. One way to achieve this is as follows. The client creates a catalog for the functors associated with queries. It sends to the server the handle (obtained by passing the callback functor associated with the query to the <code>add</code> method of catalog), along with the query. The server does not interpret this handle in any way and sends it back to the client along with the computed query result. The client, upon receiving the response, gets the functor (associated with the query) back by passing the handle (contained in the response message) to the <code>find</code> method of catalog. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Assume the following declarations (we leave the implementations as undefined, as the definitions are largely irrelevant to this example): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Query {
      <span class="comment">// Class simulating the query.</span>
  };

  <span class="keyword">class </span>QueryResult {
      <span class="comment">// Class simulating the result of a query.</span>
  };

  <span class="keyword">class </span>RequestMsg
      <span class="comment">// Class encapsulating the request message.  It encapsulates the</span>
      <span class="comment">// actual query and the handle associated with the callback for the</span>
      <span class="comment">// query.</span>
  {
      Query d_query;
      <span class="keywordtype">int</span>   d_handle;

    <span class="keyword">public</span>:
      RequestMsg(Query query, <span class="keywordtype">int</span> handle)
          <span class="comment">// Create a request message with the specified &#39;query&#39; and</span>
          <span class="comment">// &#39;handle&#39;.</span>
      : d_query(query)
      , d_handle(handle)
      {
      }

      <span class="keywordtype">int</span> handle() const
          <span class="comment">// Return the handle contained in this response message.</span>
      {
          <span class="keywordflow">return</span> d_handle;
      }
  };

  <span class="keyword">class </span>ResponseMsg
      <span class="comment">// Class encapsulating the response message.  It encapsulates the query</span>
      <span class="comment">// result and the handle associated with the callback for the query.</span>
  {
      <span class="keywordtype">int</span> d_handle;

    <span class="keyword">public</span>:
      <span class="keywordtype">void</span> setHandle(<span class="keywordtype">int</span> handle)
          <span class="comment">// Set the &quot;handle&quot; contained in this response message to the</span>
          <span class="comment">// specified &#39;handle&#39;.</span>
      {
          d_handle = handle;
      }

      QueryResult queryResult() const
          <span class="comment">// Return the query result contained in this response message.</span>
      {
          <span class="keywordflow">return</span> QueryResult();
      }

      <span class="keywordtype">int</span> handle() const
          <span class="comment">// Return the handle contained in this response message.</span>
      {
          <span class="keywordflow">return</span> d_handle;
      }
  };

  <span class="keywordtype">void</span> sendMessage(RequestMsg msg, RemoteAddress peer)
      <span class="comment">// Send the specified &#39;msg&#39; to the specified &#39;peer&#39;.</span>
  {
      serverMutex.lock();
      peer-&gt;push(msg.handle());
      serverNotEmptyCondition.signal();
      serverMutex.unlock();
  }

  <span class="keywordtype">void</span> recvMessage(ResponseMsg *msg, RemoteAddress peer)
      <span class="comment">// Get the response from the specified &#39;peer&#39; into the specified &#39;msg&#39;.</span>
  {
      serverMutex.lock();
      <span class="keywordflow">while</span> (peer-&gt;empty()) {
          serverNotEmptyCondition.wait(&amp;serverMutex);
      }
      msg-&gt;setHandle(peer-&gt;front());
      peer-&gt;pop();
      serverMutex.unlock();
  }

  <span class="keywordtype">void</span> getQueryAndCallback(Query                            *query,
                           bsl::function&lt;<span class="keywordtype">void</span>(QueryResult)&gt; *callBack)
      <span class="comment">// Set the specified &#39;query&#39; and &#39;callBack&#39; to the next &#39;Query&#39; and its</span>
      <span class="comment">// associated functor (the functor to be called when the response to</span>
      <span class="comment">// this &#39;Query&#39; comes in).</span>
  {
      (void)query;
      *callBack = &amp;queryCallBack;
  }
</pre></div><br/>
<br/>
 Furthermore, let also the following variables be declared: <br/>
<br/>
<div class="fragment"><pre class="fragment">  RemoteAddress serverAddress;  <span class="comment">// address of remote server</span>

  <a class="code" href="classbdlcc_1_1ObjectCatalog.html">bdlcc::ObjectCatalog&lt;bsl::function&lt;void(QueryResult)&gt;</a> &gt; catalog;
      <span class="comment">// Catalog of query callbacks, used by the client internally to keep</span>
      <span class="comment">// track of callback functions across multiple queries.  The invariant</span>
      <span class="comment">// is that each element corresponds to a pending query (i.e., the</span>
      <span class="comment">// callback function has not yet been or is in the process of being</span>
      <span class="comment">// invoked).</span>
</pre></div><br/>
<br/>
 Now we define functions that will be used in the thread entry functions: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testClientProcessQueryCpp()
  {
      <span class="keywordtype">int</span> queriesToBeProcessed = NUM_QUERIES_TO_PROCESS;
      <span class="keywordflow">while</span> (queriesToBeProcessed--) {
          Query query;
          bsl::function&lt;void(QueryResult)&gt; callBack;

          <span class="comment">// The following call blocks until a query becomes available.</span>
          getQueryAndCallback(&amp;query, &amp;callBack);

          <span class="comment">// Register &#39;callBack&#39; in the object catalog.</span>
          <span class="keywordtype">int</span> handle = catalog.<a class="code" href="classbdlcc_1_1ObjectCatalog.html#a10c7b874f4d16aa2a308760e9f2406e3">add</a>(callBack);
          assert(handle);

          <span class="comment">// Send query to server in the form of a &#39;RequestMsg&#39;.</span>
          RequestMsg msg(query, handle);
          sendMessage(msg, serverAddress);
      }
  }

  <span class="keywordtype">void</span> testClientProcessResponseCpp()
  {
      <span class="keywordtype">int</span> queriesToBeProcessed = NUM_QUERIES_TO_PROCESS;
      <span class="keywordflow">while</span> (queriesToBeProcessed--) {
          <span class="comment">// The following call blocks until some response is available in</span>
          <span class="comment">// the form of a &#39;ResponseMsg&#39;.</span>

          ResponseMsg msg;
          recvMessage(&amp;msg, serverAddress);
          <span class="keywordtype">int</span> handle = msg.handle();
          QueryResult result = msg.queryResult();

          <span class="comment">// Process query &#39;result&#39; by applying registered &#39;callBack&#39; to it.</span>
          <span class="comment">// The &#39;callBack&#39; function is retrieved from the &#39;catalog&#39; using</span>
          <span class="comment">// the given &#39;handle&#39;.</span>

          bsl::function&lt;void(QueryResult)&gt; callBack;
          assert(0 == catalog.<a class="code" href="classbdlcc_1_1ObjectCatalog.html#a51d4a8bc62d9f045ca228fe8c348be37">find</a>(handle, &amp;callBack));
          callBack(result);

          <span class="comment">// Finally, remove the no-longer-needed &#39;callBack&#39; from the</span>
          <span class="comment">// &#39;catalog&#39;.  Assert so that &#39;catalog&#39; may not grow unbounded if</span>
          <span class="comment">// remove fails.</span>

          assert(0 == catalog.<a class="code" href="classbdlcc_1_1ObjectCatalog.html#a63779dddd5d9a20f5d0db34af1821e4f">remove</a>(handle));
      }
  }
</pre></div><br/>
<br/>
 In some thread, the client executes the following code. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *testClientProcessQuery(<span class="keywordtype">void</span> *)
  {
      testClientProcessQueryCpp();
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 In some other thread, the client executes the following code. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *testClientProcessResponse(<span class="keywordtype">void</span> *)
  {
      testClientProcessResponseCpp();
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_iterator_usage"></a> <a class="anchor" id="usage.example_2~3A_iterator_usage"></a> <a class="anchor" id="description.usage.example_2~3A_iterator_usage"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Iterator Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following code fragment shows how to use <a class="el" href="classbdlcc_1_1ObjectCatalogIter.html">bdlcc::ObjectCatalogIter</a> to iterate through all the objects of <code>catalog</code> (a catalog of objects of type <code>MyType</code>). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> use(bsl::function&lt;<span class="keywordtype">void</span>(QueryResult)&gt; <span class="keywordtype">object</span>)
  {
      (void)<span class="keywordtype">object</span>;
  }
</pre></div><br/>
<br/>
 Now iterate through the <code>catalog</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<a class="code" href="classbdlcc_1_1ObjectCatalogIter.html">bdlcc::ObjectCatalogIter&lt;MyType&gt;</a> it(catalog); it; ++it) {
      <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;int, MyType&gt;</a> p = it(); <span class="comment">// p.first contains the handle and</span>
                                       <span class="comment">// p.second contains the object</span>
      use(p.<a class="code" href="group__bslstl__pair.html#gaf89d2b38598dfb6fa42775f2e135f1d8">second</a>);                   <span class="comment">// the function &#39;use&#39; uses the</span>
                                       <span class="comment">// object in some way</span>
  }
  <span class="comment">// &#39;it&#39; is now destroyed out of the scope, releasing the lock.</span>
</pre></div><br/>
<br/>
 Note that the associated catalog is (read)locked when the iterator is constructed and is unlocked only when the iterator is destroyed. This means that until the iterator is destroyed, all the threads trying to modify the catalog will remain blocked (even though multiple threads can concurrently read the object catalog). So clients must make sure to destroy their iterators after they are done using them. One easy way is to use the <code>for (<a class="el" href="classbdlcc_1_1ObjectCatalogIter.html">bdlcc::ObjectCatalogIter</a>&lt;MyType&gt; it(catalog); ...</code> as above. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:38 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
