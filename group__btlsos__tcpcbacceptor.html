<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsos_tcpcbacceptor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsos_tcpcbacceptor<br/>
<small>
[<a class="el" href="group__btlsos.html">Package btlsos</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a non-blocking acceptor of TCP connections.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsos.html">btlsos</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a non-blocking acceptor of TCP connections. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html">btlsos::TcpCbAcceptor</a> </td><td>non-blocking channel allocator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsos__tcptimedcbchannel.html" title="Provide timed stream-based communication channel over TCP sockets.">Component btlsos_tcptimedcbchannel</a> <a class="el" href="group__btlso__tcptimereventmanager.html" title="Provide a multiplexer of events on sockets and timers.">Component btlso_tcptimereventmanager</a> <a class="el" href="group__btlsos__tcpcbconnector.html" title="Provide a non-blocking connector to TCP servers.">Component btlsos_tcpcbconnector</a> <a class="el" href="group__btlsos__tcpcbchannel.html" title="Provide stream-based communication channel over TCP sockets.">Component btlsos_tcpcbchannel</a> <a class="el" href="group__btlso__socketoptutil.html" title="Provide operations to manipulate socket options.">Component btlso_socketoptutil</a> btesos_streamsocketfactory </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a non-blocking single-port acceptor of TCP connections, <code><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html">btlsos::TcpCbAcceptor</a></code>, with the capability that adheres to the <code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code> protocol. Both timed and non-timed (callback) channels can be allocated in a non-timed fashion as indicated by the following table: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Allocations follow the asynchronous (callback-based) nature of the <code>btesc</code> protocol; the callbacks are invoked when an allocation succeeds or an error occurs. The acceptor uses the user-installed socket event manager in order to monitor (in a non-blocking fashion) the listening socket for incoming connection requests. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The acceptor has the flexibility of opening and closing a listening socket with no effect on any existing channels managed by this object. The enqueued (i.e., not-yet-completed) allocation requests will, however, fail (without invalidating the allocator) and the associated callbacks will be invoked when the listening port is closed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The acceptor is <em>thread</em> <em>safe</em>, meaning that any operation can be called on <em>distinct instances</em> from different threads without any side-effects (which, generally speaking, means that there is no <code>static</code> data), but not <em>thread</em> <em>enabled</em> (i.e., two threads cannot safely call methods on the <em>same</em> <em>instance</em> without external synchronization). This acceptor is not <em>async-safe</em>, meaning that one or more functions cannot be invoked safely from a signal handler. Note that the thread safety of the acceptor is subject to the thread safety of the supplied socket event manager. If distinct instances of acceptor use the <em>same</em> instance of a socket event manager, both acceptors are thread-safe if and only if that socket event manager is <em>THREAD</em> <em>ENABLED</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following usage example shows a possible implementation of a multi-user echo server. An echo server accepts connections and, for every connection, sends any received data back to the client (until the connection is terminated). This server requires that data is read from an accepted connection within a certain time interval or else the connection is dropped on timeout. The echo server is implemented as a separate class (<code>my_EchoServer</code>) that owns the timed callback acceptor. Various configuration parameters such as the timeout values, the queue size and input buffer size, and the default port number (as mandated by RFC 862) are constants within this class. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_EchoServer {
      <span class="comment">// This class implements a simple multi-user echo server as specified</span>
      <span class="comment">// by the RFC 862.</span>

      <span class="keyword">enum</span> {
          k_READ_SIZE           =  200,  <span class="comment">// The number of bytes to be read</span>
                                         <span class="comment">// can be changed, but a larger</span>
                                         <span class="comment">// &#39;k_READ_SIZE&#39; will require the</span>
                                         <span class="comment">// client to input more data to be</span>
                                         <span class="comment">// echoed.</span>
          k_DEFAULT_PORT_NUMBER = 9234,  <span class="comment">// As specified by the RFC 862</span>
          k_QUEUE_SIZE          =   16
      };

      <a class="code" href="classbtlsos_1_1TcpCbAcceptor.html">btlsos::TcpCbAcceptor</a>  d_allocator;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>     d_acceptTimeout;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>     d_readTimeout;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>     d_writeTimeout;

      bsl::function&lt;void(btlsc::TimedCbChannel*, int)&gt;
                             d_allocateFunctor;
                                         <span class="comment">// Cached callback functor.</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>      *d_allocator_p;
      <span class="keywordtype">char</span>                   d_buffer[k_READ_SIZE];

    <span class="keyword">private</span>:
      <span class="comment">// Callbacks</span>
      <span class="keywordtype">void</span> allocateCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel, <span class="keywordtype">int</span> status);
          <span class="comment">// Invoked from the socket event manager when a connection is</span>
          <span class="comment">// allocated (i.e., accepted) or an error occurs when allocating.</span>
          <span class="comment">// [...]</span>

      <span class="keywordtype">void</span> bufferedReadCb(<span class="keyword">const</span> <span class="keywordtype">char</span>            *buffer,
                          <span class="keywordtype">int</span>                    status,
                          <span class="keywordtype">int</span>                    asyncStatus,
                          <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel);
          <span class="comment">// Invoked from the socket event manager when data is read.  [...]</span>

      <span class="keywordtype">void</span> readCb(<span class="keywordtype">int</span>                    status,
                  <span class="keywordtype">int</span>                    asyncStatus,
                  <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel);
          <span class="comment">// Invoked from the socket event manager when data is read.  [...]</span>

      <span class="keywordtype">void</span> writeCb(<span class="keywordtype">int</span>                    status,
                   <span class="keywordtype">int</span>                    asyncStatus,
                   <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                   <span class="keywordtype">int</span>                    numBytes);
          <span class="comment">// Invoked from the socket event manager when data is written.</span>
          <span class="comment">// [...]</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_EchoServer(<span class="keyword">const</span> my_EchoServer&amp;);
      my_EchoServer&amp; operator=(<span class="keyword">const</span> my_EchoServer&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_EchoServer(
             <a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *factory,
             <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>                       *manager,
             <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                               *basicAllocator);
          <span class="comment">// Create an echo server that uses the specified stream socket</span>
          <span class="comment">// &#39;factory&#39; for the system sockets and the specified socket event</span>
          <span class="comment">// &#39;manager&#39; to multiplex the events on these sockets.  The</span>
          <span class="comment">// behavior is undefined if either &#39;factory&#39; or &#39;manager&#39; is 0.</span>

      ~my_EchoServer();
          <span class="comment">// Destroy this server.  The behavior is undefined unless the</span>
          <span class="comment">// server is shut down properly (i.e., via &#39;close&#39;).</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> open(<span class="keywordtype">int</span> portNumber = k_DEFAULT_PORT_NUMBER);
          <span class="comment">// Establish a listening socket on the optionally specified</span>
          <span class="comment">// &#39;portNumber&#39;; return 0 on success, and a non-zero value</span>
          <span class="comment">// otherwise.  The behavior is undefined unless &#39;0 &lt;= portNumber&#39;</span>
          <span class="comment">// and the listening port is not currently open.</span>

      <span class="keywordtype">int</span> close();
          <span class="comment">// Close the listening socket; return 0 on success and a non-zero</span>
          <span class="comment">// value otherwise.  The behavior is undefined unless the listening</span>
          <span class="comment">// socket is currently open.</span>
  };
</pre></div><br/>
<br/>
 The implementation of the public methods of <code>my_EchoServer</code> is trivial. For the constructor, the socket factory and socket event manager are passed to the acceptor, and the allocate callback and (three) event timeouts are initialized. The <code>open</code> and <code>close</code> methods just invoke appropriate methods of the acceptor. The destructor ensures that the state of the acceptor is valid: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  my_EchoServer::my_EchoServer(
              <a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *factory,
              <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>                       *manager,
              <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                               *basicAllocator)
  : d_allocator(factory, manager, basicAllocator)
  , d_acceptTimeout(120, 0)
  , d_readTimeout(5, 0)
  , d_writeTimeout(5.0)
  , d_allocator_p(basicAllocator)
  {
      assert(factory);
      assert(manager);
      d_allocateFunctor = bsl::function&lt;void(btlsc::TimedCbChannel *, int)&gt;(
          <a class="code" href="structbsl_1_1allocator__arg__t.html">bsl::allocator_arg_t</a>(),
          <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;bsl::function&lt;void(btlsc::TimedCbChannel *, int)&gt;</a> &gt;(
              basicAllocator),
          <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoServer::allocateCb, <span class="keyword">this</span>));
  }

  my_EchoServer::~my_EchoServer() {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">int</span> my_EchoServer::open(<span class="keywordtype">int</span> portNumber) {
      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> serverAddress;
      serverAddress.<a class="code" href="classbtlso_1_1IPv4Address.html#a0db9b6717cd8bd435caeeb46a9bbd818">setPortNumber</a>(portNumber);
      <span class="keywordtype">int</span> s = d_allocator.open(serverAddress, k_QUEUE_SIZE);
      <span class="keywordflow">if</span> (s) {
          cout &lt;&lt; <span class="stringliteral">&quot;Failed to open listening port.&quot;</span> &lt;&lt; endl;
          <span class="keywordflow">return</span> s;                                                 <span class="comment">// RETURN</span>
      }
      cout &lt;&lt; <span class="stringliteral">&quot;server&#39;s socket: &quot;</span> &lt;&lt; d_allocator.address() &lt;&lt; endl;
      assert(0 == d_allocator.isInvalid());
      s = d_allocator.allocateTimed(d_allocateFunctor);
      <span class="keywordflow">if</span> (s) {
          cout &lt;&lt; <span class="stringliteral">&quot;Can&#39;t enqueue an allocation request.&quot;</span> &lt;&lt; endl;
          assert(d_allocator.isInvalid());
          d_allocator.close();
          <span class="keywordflow">return</span> s;                                                 <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">return</span> 0;
  }

  <span class="keywordtype">int</span> my_EchoServer::close() {
      <span class="keywordflow">return</span> d_allocator.close();
  }
</pre></div><br/>
<br/>
 All the work of accepting connections and reading/writing the data is done in the (private) callback methods of <code>my_EchoServer</code>. When the connection is established and the <code>allocateCb</code> method is invoked, the buffered read with timeout is initiated on the channel and another allocation request is enqueued. If any error occurs while allocating, the acceptor is shut down. If any error, including timeout, occurs while reading or writing data, the channel is shut down. Note that the allocation functor is cached to improve performance: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_EchoServer::allocateCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                                 <span class="keywordtype">int</span>                    status) {
      <span class="keywordflow">if</span> (channel) {
          <span class="comment">// Accepted a connection.  Issue a read raw request.</span>
          bsl::function&lt;void(int, int)&gt; callback(bdlf::BindUtil::bindA(
                        d_allocator_p,
                        <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoServer::readCb, <span class="keyword">this</span>),
                        <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                        _2,
                        channel));

          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aec7966b1f7b70c043fc7283237b6a316">timedReadRaw</a>(d_buffer,
                                    k_READ_SIZE,
                                    <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                + d_readTimeout, callback)) {
              cout &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue buffered read request.&quot;</span> &lt;&lt; endl;
              d_allocator.deallocate(channel);
          }
          <span class="keywordflow">if</span> (d_allocator.allocateTimed(d_allocateFunctor)) {
              d_allocator.close();
          }
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      assert(0 &gt;= status);    <span class="comment">// Interrupts are not enabled.</span>
      <span class="keywordflow">if</span> (0 == status) {
          <span class="comment">// Re-register the functor</span>
          <span class="keywordflow">if</span> (d_allocator.allocateTimed(d_allocateFunctor)) {
              d_allocator.close();
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (-1 == status) {
          cout &lt;&lt; <span class="stringliteral">&quot;Allocation request was dequeued.&quot;</span> &lt;&lt; endl;
      }
      <span class="keywordflow">else</span> {
          <span class="comment">// Hard-error accepting a connection, invalidate the allocator.</span>
          cout &lt;&lt; <span class="stringliteral">&quot;Hard error while accepting a connection: &quot;</span> &lt;&lt; status
               &lt;&lt; endl;
          d_allocator.invalidate();
      }
  }

  <span class="keywordtype">void</span> my_EchoServer::bufferedReadCb(<span class="keyword">const</span> <span class="keywordtype">char</span>            *buffer,
                                     <span class="keywordtype">int</span>                    status,
                                     <span class="keywordtype">int</span>                    asyncStatus,
                                     <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel)
  {
      cout &lt;&lt; <span class="stringliteral">&quot;my_EchoServer::bufferedReadCb: &quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; read &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; endl;
      assert(channel);
      <span class="keywordflow">if</span> (0 &lt; status) {
          bsl::function&lt;void(int, int)&gt; callback(bdlf::BindUtil::bindA(
                       d_allocator_p,
                       <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoServer::writeCb, <span class="keyword">this</span>),
                       <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                       _2,
                       channel,
                       status));

          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aec7af32d3d17c756292f391f8c5652eb">timedBufferedWrite</a>(buffer,
                                          status,
                                          <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                               + d_writeTimeout, callback)) {
              cout &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue write request&quot;</span> &lt;&lt; endl;
              d_allocator.deallocate(channel);
              <span class="keywordflow">return</span>;                                               <span class="comment">// RETURN</span>
          }
          <span class="comment">// Re-register read request</span>
          bsl::function&lt;void(const char *, int, int)&gt; readCallback(
              bdlf::BindUtil::bindA(
                       d_allocator_p,
                       <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoServer::bufferedReadCb,
                                              <span class="keyword">this</span>),
                       <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                       _2,
                       _3,
                       channel));

          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#a1bcaa5992ed3d03f3f5e983942c6f547">timedBufferedRead</a>(k_READ_SIZE,
                   <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_readTimeout, readCallback)) {
              cout &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue read request.&quot;</span> &lt;&lt; endl;
              d_allocator.deallocate(channel);
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == status) {
          <span class="keywordflow">if</span> (0 &gt; asyncStatus) {
              cout &lt;&lt; <span class="stringliteral">&quot;Callback dequeued&quot;</span> &lt;&lt; endl;
          }
          <span class="keywordflow">else</span> {
              cout &lt;&lt; <span class="stringliteral">&quot;Timed out on read&quot;</span> &lt;&lt; endl;
              d_allocator.deallocate(channel);
          }
      }
      <span class="keywordflow">else</span> {
          <span class="comment">// Either time out or an error on the channel</span>
          cout &lt;&lt; <span class="stringliteral">&quot;Failed to read data.&quot;</span> &lt;&lt; endl;
          d_allocator.deallocate(channel);
      }
  }

  <span class="keywordtype">void</span> my_EchoServer::readCb(<span class="keywordtype">int</span>                    status,
                             <span class="keywordtype">int</span>                    asyncStatus,
                             <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel)
  {
      cout &lt;&lt; <span class="stringliteral">&quot;my_EchoServer::readCb: &quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; read &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; endl;
      assert(channel);
      <span class="keywordflow">if</span> (0 &lt; status) {
          bsl::function&lt;void(int, int)&gt; callback(
              bdlf::BindUtil::bindA(
                       d_allocator_p,
                       <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoServer::writeCb, <span class="keyword">this</span>),
                       <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                       _2,
                       channel,
                       status));

          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aec7af32d3d17c756292f391f8c5652eb">timedBufferedWrite</a>(d_buffer,
                                          status,
                                          <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                 + d_writeTimeout, callback))
              {
                  cout &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue write request&quot;</span> &lt;&lt; endl;
                  d_allocator.deallocate(channel);
                  <span class="keywordflow">return</span>;                                           <span class="comment">// RETURN</span>
              }
          <span class="comment">// Re-register read request</span>
          bsl::function&lt;void(int, int)&gt; readCallback(
                bdlf::BindUtil::bindA(
                        d_allocator_p,
                        <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoServer::readCb, <span class="keyword">this</span>),
                        <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                        _2,
                        channel));

          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aec7966b1f7b70c043fc7283237b6a316">timedReadRaw</a>(d_buffer, k_READ_SIZE,
                                    <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                            + d_readTimeout, readCallback)) {
              cout &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue read request.&quot;</span> &lt;&lt; endl;
              d_allocator.deallocate(channel);
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == status) {
          <span class="keywordflow">if</span> (0 &gt; asyncStatus) {
              cout &lt;&lt; <span class="stringliteral">&quot;Callback dequeued&quot;</span> &lt;&lt; endl;
          }
          <span class="keywordflow">else</span> {
              cout &lt;&lt; <span class="stringliteral">&quot;Timed out on read&quot;</span> &lt;&lt; endl;
              d_allocator.deallocate(channel);
          }
      }
      <span class="keywordflow">else</span> {
          <span class="comment">// Either time out or an error on the channel</span>
          cout &lt;&lt; <span class="stringliteral">&quot;Failed to read data.&quot;</span> &lt;&lt; endl;
          d_allocator.deallocate(channel);
      }
  }

  <span class="keywordtype">void</span> my_EchoServer::writeCb(<span class="keywordtype">int</span>                    status,
                              <span class="keywordtype">int</span>                    asyncStatus,
                              <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                              <span class="keywordtype">int</span>                    numBytes)
  {
      (void)asyncStatus;
      <span class="keywordflow">if</span> (status != numBytes) {
          cout &lt;&lt; <span class="stringliteral">&quot;Failed to send data.&quot;</span> &lt;&lt; endl;
          channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#a4864a8e61648ff1937000b69ee2c721b">invalidate</a>();
          d_allocator.deallocate(channel);
      }
  }
</pre></div><br/>
<br/>
 Finally, we define the <code>main</code> function, which will create the concrete socket factory and concrete socket event manager, create <code>my_EchoServer</code> as required, and go into "infinite" loop dispatching registered callbacks: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> testAllocator;
  testAllocator.<a class="code" href="classbslma_1_1TestAllocator.html#ab558d4e20e4a93c43ea86a4f6cf71042">setNoAbort</a>(1);

  <a class="code" href="classbtlso_1_1InetStreamSocketFactory.html">btlso::InetStreamSocketFactory&lt;btlso::IPv4Address&gt;</a> factory(&amp;testAllocator);

  <a class="code" href="classbtlso_1_1TcpTimerEventManager.html#a5f18754df0ff6cb6af8302df3245a2cf">btlso::TcpTimerEventManager::Hint</a> hint
                                = btlso::TcpTimerEventManager::e_NO_HINT;

  <a class="code" href="classbtlso_1_1TcpTimerEventManager.html">btlso::TcpTimerEventManager</a> manager(hint, &amp;testAllocator);
  my_EchoServer               echoServer(&amp;factory, &amp;manager, &amp;testAllocator);

  <span class="keywordflow">if</span> (echoServer.open()) {
      cout &lt;&lt; <span class="stringliteral">&quot;Can&#39;t open listening socket.&quot;</span> &lt;&lt; endl;
      <span class="keywordflow">break</span>; <span class="comment">// return -1;</span>
  }

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i) {
      <span class="comment">// Do it for the finite number of times.</span>
      <span class="keywordtype">int</span> cbs = manager.<a class="code" href="classbtlso_1_1TcpTimerEventManager.html#a9409088774d044ab30e5bf3d82f78950">dispatch</a>(0);
      assert(0 &lt; cbs);
  }
  echoServer.close();
  <span class="comment">// We need another round of dispatch for cleaning things up.</span>
  <span class="keywordtype">int</span> cbs = manager.<a class="code" href="classbtlso_1_1TcpTimerEventManager.html#a9409088774d044ab30e5bf3d82f78950">dispatch</a>(0);
  assert(0 &lt; cbs);
  assert(0 == testAllocator.<a class="code" href="classbslma_1_1TestAllocator.html#af283f8d8facf0bdfc98f193d06918985">numMismatches</a>());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
