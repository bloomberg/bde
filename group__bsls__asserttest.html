<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_asserttest Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_asserttest<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a test facility for assertion macros.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Negative Testing</a> </li>
<li>
<a href="#4.2">The Test Facility</a> <ul>
<li>
<a href="#4.2.1">Installing the Assert-Failure Handler</a> </li>
<li>
<a href="#4.2.2">Basic Test Macros</a> </li>
<li>
<a href="#4.2.3">Raw Test Macros</a> </li>
<li>
<a href="#4.2.4">Table Driven Negative-Testing</a> </li>
<li>
<a href="#4.2.5">Enabling Negative Testing</a> </li>
</ul>
</li>
<li>
<a href="#4.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a test facility for assertion macros. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsls_1_1AssertTest.html">bsls::AssertTest</a> </td><td>namespace for "assert" validating functions  </td></tr>
<tr>
<td><a class="el" href="classbsls_1_1AssertTestHandlerGuard.html">bsls::AssertTestHandlerGuard</a> </td><td>guard for the negative testing assert-handler  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#aa4e3658fc0ccaee94eabdd7c59ea06ae">BSLS_ASSERTTEST_ASSERT_SAFE_PASS(EXPRESSION)</a> </td><td>"safe" macro success expected  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a593dacbe0f7d29ad6405ad6f6707863e">BSLS_ASSERTTEST_ASSERT_SAFE_PASS_RAW(EXPRESSION)</a> </td><td>no origination check  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a9324550ae5ad76d2cce7c62534b4d960">BSLS_ASSERTTEST_ASSERT_SAFE_FAIL(EXPRESSION)</a> </td><td>"safe" macro failure expected  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#ab4f94d2a49ab456ef972ed4b65f6cbfd">BSLS_ASSERTTEST_ASSERT_SAFE_FAIL_RAW(EXPRESSION)</a> </td><td>no origination check  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a053eecbd08400c8d5e1eb390f21953b5">BSLS_ASSERTTEST_ASSERT_PASS(EXPRESSION)</a> </td><td>macro success expected  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a8bf99bdb70282a32532985d7a7438b0d">BSLS_ASSERTTEST_ASSERT_PASS_RAW(EXPRESSION)</a> </td><td>no origination check  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a70849f0f1ac26e4cd7105abaa1d38350">BSLS_ASSERTTEST_ASSERT_FAIL(EXPRESSION)</a> </td><td>macro failure expected  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a83d3dafc95e3f39e43558cb519c21865">BSLS_ASSERTTEST_ASSERT_FAIL_RAW(EXPRESSION)</a> </td><td>no origination check  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a022aca164d25f5e3e57129f08056054b">BSLS_ASSERTTEST_ASSERT_OPT_PASS(EXPRESSION)</a> </td><td>"opt" macro success expected  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a30c38e91e5f33c8a4b5a7ce5edf6f661">BSLS_ASSERTTEST_ASSERT_OPT_PASS_RAW(EXPRESSION)</a> </td><td>no origination check  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a8fba576d5852256718f9b7ce1ac39b25">BSLS_ASSERTTEST_ASSERT_OPT_FAIL(EXPRESSION)</a> </td><td>"opt macro failure expected  </td></tr>
<tr>
<td><a class="el" href="bsls__asserttest_8h.html#a293067655222d66a6872686b6e7bbd3a">BSLS_ASSERTTEST_ASSERT_OPT_FAIL_RAW(EXPRESSION)</a> </td><td>no origination check  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bsls__assert.html" title="Provide build-specific, runtime-configurable assertion macros.">Component bsls_assert</a>, <a class="el" href="group__bsls__asserttestexception.html" title="Provide an exception type to support testing for failed assertions.">Component bsls_asserttestexception</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a facility to test that <code>BSLS_ASSERT_*</code> macros are used as intended, in the appropriate build modes, and have the expected effects. The class <code><a class="el" href="structbsls_1_1AssertTest.html">bsls::AssertTest</a></code> provides a small set of static methods that can be used to support detailed test cases, especially in table-driven test scenarios. Additionally, a set of macros automate use of these methods to support simple testing of single expressions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="negative_testing"></a> <a class="anchor" id="description.negative_testing"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Negative Testing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>"Negative testing" is the principle of testing for a negative result, which implies the function under test must fail in some way. Testable failures typically occur when a function is called with values outside the defined contract: a well-implemented function will validate function arguments, in appropriate build modes, using the various <code>BSLS_ASSERT</code> macros (see <code>bsls_assert</code>). When a function fails as a result of an assertion, the default behavior is to terminate the program. However, the <code>bsls_assert</code> facility allows a user-supplied assertion-failure handler function to be installed, which can be used to build a test facility for expected assertions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>One important issue to be aware of with negative testing is that you are testing undefined behavior within a program. For the purpose of the test driver, the behavior of calling a function outside its contract is well- defined if it is guarded by assertions that are active in the current build mode. However, it is important that those tests are not run if the assert macros are not active, otherwise truly undefined behavior will result, with potentially disastrous consequences. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_test_facility"></a> <a class="anchor" id="description.the_test_facility"></a> <a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>The Test Facility: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="installing_the_assert-failure_handler"></a> <a class="anchor" id="the_test_facility.installing_the_assert-failure_handler"></a> <a class="anchor" id="description.the_test_facility.installing_the_assert-failure_handler"></a> <a class="anchor" id="4.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Installing the Assert-Failure Handler: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The function <code><a class="el" href="structbsls_1_1AssertTest.html#a67f37106930c1760e599519c2d173020">bsls::AssertTest::failTestDriver</a></code> is provided as the basis for a negative testing facility. It can act as an assertion-failure handler function that throws an exception, of type <code><a class="el" href="classbsls_1_1AssertTestException.html">bsls::AssertTestException</a></code>, containing the text of the failed assertion, the name of the file where it triggered, and the relevant line number within that file. The filename can be tested to ensure that the assertion was raised by the component under test, rather than by some deeper implementation detail as a consequence of the expected assertion not being present in the function under test. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once the function <code><a class="el" href="structbsls_1_1AssertTest.html#a67f37106930c1760e599519c2d173020">bsls::AssertTest::failTestDriver</a></code> has been registered as the active assertion-failure handler, a set of testing macros automate much of the boilerplate code involved in writing a negative test, so that a test can be effectively written as a single line. This is an important quality for reading tests, to clearly see the test logic in action without being distracted by the surrounding machinery. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="basic_test_macros"></a> <a class="anchor" id="the_test_facility.basic_test_macros"></a> <a class="anchor" id="description.the_test_facility.basic_test_macros"></a> <a class="anchor" id="4.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Basic Test Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The six basic test macros are <ul>
<li>
<code>BSLS_ASSERTTEST_ASSERT_SAFE_PASS</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_SAFE_FAIL</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_PASS</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_FAIL</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_OPT_PASS</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_OPT_FAIL</code>  </li>
</ul>
Each of these macros takes a single expression as an argument, tests whether an assertion is raised while evaluating that expression, and, if an assertion is both raised and expected, whether that assertion was raised by the component under test. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A test failure is indicated by invoking <code>ASSERT(EXPRESSION)</code>, where <code>ASSERT</code> is either a macro or function that must be defined by the test driver, and <code>EXPRESSION</code> is an expression that evaluates to <code>true</code> or <code>false</code> according to whether the <code>ASSERTTEST_ASSERT</code> macro was expected to <code>_PASS</code> or <code>_FAIL</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, if we have <code>std::vector&lt;int&gt; v</code> and <code>v</code> is empty, then the macro test <code>BSLS_ASSERTTEST_ASSERT_SAFE_FAIL((v.back()))</code> will fail when the effective assertion-level is <code>BSLS_ASSERT_LEVEL_ASSERT_SAFE</code> unless an assertion is raised. However, if the assertion-level is not <code>BSLS_ASSERT_LEVEL_ASSERT_SAFE</code>, then the test will not be run. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="raw_test_macros"></a> <a class="anchor" id="the_test_facility.raw_test_macros"></a> <a class="anchor" id="description.the_test_facility.raw_test_macros"></a> <a class="anchor" id="4.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Raw Test Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The six "raw" test macros are <ul>
<li>
<code>BSLS_ASSERTTEST_ASSERT_SAFE_PASS_RAW</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_SAFE_FAIL_RAW</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_PASS_RAW</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_FAIL_RAW</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_OPT_PASS_RAW</code>  </li>
<li>
<code>BSLS_ASSERTTEST_ASSERT_OPT_FAIL_RAW</code>  </li>
</ul>
These testing macros perform the same test as the corresponding basic testing macros, except that there is no check to confirm that the assertion originated in the component under test. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="table_driven_negative-testing"></a> <a class="anchor" id="the_test_facility.table_driven_negative-testing"></a> <a class="anchor" id="description.the_test_facility.table_driven_negative-testing"></a> <a class="anchor" id="4.2.4"></a> </dd></dl>
<dl class="user"><dt><b>Table Driven Negative-Testing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The supplied test macros are useful for testing a small set of boundary conditions, but for more detailed contracts a table-driven approach works best. The <code><a class="el" href="structbsls_1_1AssertTest.html">bsls::AssertTest</a></code> class provides a pair of "test probe" functions that can be hooked up as a pair in a <code>try</code>/<code>catch</code> block to validate each row of a supplied test table. See the second usage example below for more details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="enabling_negative_testing"></a> <a class="anchor" id="the_test_facility.enabling_negative_testing"></a> <a class="anchor" id="description.the_test_facility.enabling_negative_testing"></a> <a class="anchor" id="4.2.5"></a> </dd></dl>
<dl class="user"><dt><b>Enabling Negative Testing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to enable the negative testing facility, you must: <ul>
<li>
<code>#include</code> this component header, <code><a class="el" href="bsls__asserttest_8h.html" title="Provide a test facility for assertion macros.">bsls_asserttest.h</a></code>.  </li>
<li>
Supply an implementation of an <code>ASSERT</code> macro in your test driver.  </li>
<li>
Register <code><a class="el" href="structbsls_1_1AssertTest.html#a67f37106930c1760e599519c2d173020">bsls::AssertTest::failTestDriver</a></code> as the active assertion-failure handler.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we will demonstrate how "negative testing" might be used to verify that the correct assertions are in place on <code>std::vector::operator[]</code>. We start by supplying a primitive vector-like class that offers the minimal set of operations necessary to demonstrate the test case. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">class </span>AssertTestVector {
      <span class="comment">// This class simulates a &#39;std::vector&#39; with a fixed capacity of 10</span>
      <span class="comment">// elements.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      T   d_data[10];
      <span class="keywordtype">int</span> d_size;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      AssertTestVector();
          <span class="comment">// Create an empty &#39;AssertTestVector&#39; object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> push_back(<span class="keyword">const</span> T&amp; value);
          <span class="comment">// Append the specified &#39;value&#39; to the back of this object.</span>
          <span class="comment">// The behavior is undefined unless this method has been called</span>
          <span class="comment">// fewer than 10 times on this object.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> T&amp; operator[](<span class="keywordtype">int</span> index) <span class="keyword">const</span>;
          <span class="comment">// Return a reference with non-modifiable access to the object at</span>
          <span class="comment">// the specified &#39;index&#39; in this object.</span>
  };
</pre></div><br/>
<br/>
 Next we implement the support functions. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  AssertTestVector&lt;T&gt;::AssertTestVector()
  : d_data()
  , d_size()
  {
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keywordtype">void</span> AssertTestVector&lt;T&gt;::push_back(<span class="keyword">const</span> T&amp; value)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(d_size &lt; 10);

      d_data[d_size] = value;
      ++d_size;
  }
</pre></div><br/>
<br/>
 We conclude the definition of this support type with the implementation of the <code>operator[]</code> overload. Note the use of <code>BSLS_ASSERT_SAFE</code>, which is typical for function template definitions and inline function definitions. It is most appropriate in this case as the cost of evaluating each test is significant (&gt; ~20%) compared to simply returning a reference to the result. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">const</span> T&amp; AssertTestVector&lt;T&gt;::operator[](<span class="keywordtype">int</span> index)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(0 &lt;= index);
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(     index &lt; d_size);

      <span class="keywordflow">return</span> d_data[d_size];
  }
</pre></div><br/>
<br/>
 Finally, we can write the function to test that the <code>BSLS_ASSERT_SAFE</code> macros placed in <code>operator[]</code> work as expected. We want to validate that the assertions trigger when the function preconditions are violated; we further want to validate that the assertion macros are enabled in the build modes that we expect. We start by defining some macro aliases that will make the test driver more readable. These macro aliases are a common feature of test drivers. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #define ASSERT_SAFE_PASS(EXPR) BSLS_ASSERTTEST_ASSERT_SAFE_PASS(EXPR)</span>
<span class="preprocessor"></span><span class="preprocessor">  #define ASSERT_SAFE_FAIL(EXPR) BSLS_ASSERTTEST_ASSERT_SAFE_FAIL(EXPR)</span>
<span class="preprocessor"></span><span class="preprocessor">  #define ASSERT_PASS(EXPR)      BSLS_ASSERTTEST_ASSERT_PASS(EXPR)</span>
<span class="preprocessor"></span><span class="preprocessor">  #define ASSERT_FAIL(EXPR)      BSLS_ASSERTTEST_ASSERT_FAIL(EXPR)</span>
<span class="preprocessor"></span><span class="preprocessor">  #define ASSERT_OPT_PASS(EXPR)  BSLS_ASSERTTEST_ASSERT_OPT_PASS(EXPR)</span>
<span class="preprocessor">  #define ASSERT_OPT_FAIL(EXPR)  BSLS_ASSERTTEST_ASSERT_OPT_FAIL(EXPR)</span>
</pre></div><br/>
<br/>
 Then we implement the test function itself. Note that we check that exceptions are available in the current build mode, as the test macros rely on the exception facility in order to return their diagnostic results. If exceptions are not available, there is nothing for a "negative test" to do. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testVectorArrayAccess()
  {
<span class="preprocessor">  #ifdef BDE_BUILD_TARGET_EXC</span>
<span class="preprocessor"></span>      <a class="code" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a> g(<a class="code" href="structbsls_1_1AssertTest.html#a67f37106930c1760e599519c2d173020">bsls::AssertTest::failTestDriver</a>);

      AssertTestVector&lt;void *&gt; mA; <span class="keyword">const</span> AssertTestVector&lt;void *&gt; &amp;A = mA;

      ASSERT_SAFE_FAIL(mA[-1]);
      ASSERT_SAFE_FAIL(mA[ 0]);
      ASSERT_SAFE_FAIL(mA[ 1]);

      ASSERT_SAFE_FAIL( A[-1]);
      ASSERT_SAFE_FAIL( A[ 0]);
      ASSERT_SAFE_FAIL( A[ 1]);

      mA.push_back(0);  <span class="comment">// increase the length to one</span>

      ASSERT_SAFE_FAIL(mA[-1]);
      ASSERT_SAFE_PASS(mA[ 0]);
      ASSERT_SAFE_FAIL(mA[ 1]);

      ASSERT_SAFE_FAIL( A[-1]);
      ASSERT_SAFE_PASS( A[ 0]);
      ASSERT_SAFE_FAIL( A[ 1]);

<span class="preprocessor">  #endif  // BDE_BUILD_TARGET_EXC</span>
<span class="preprocessor">  }</span>
</pre></div><br/>
<br/>
 In order to better highlight the tools available for testing assertions, let us consider an arbitrary function in some user-defined component, which conveniently utilizes each of our assertion macros to catch calls outside the behavior defined by its contract. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyUtil {
<span class="preprocessor">  #ifdef BDE_BUILD_TARGET_SAFE_2</span>
<span class="preprocessor"></span>    <span class="keyword">private</span>:

      <span class="keyword">static</span> <span class="keywordtype">void</span> *s_trustedPointers[10];

      <span class="keyword">static</span> <span class="keywordtype">bool</span> isValid(<span class="keywordtype">void</span> *pointer);
          <span class="comment">// Returns &#39;true&#39; if the specified &#39;pointer&#39; is registered in the</span>
          <span class="comment">// array &#39;s_trustedPointers&#39;, and &#39;false&#39; otherwise.</span>

    <span class="keyword">public</span>:
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
      <span class="keyword">static</span> <span class="keywordtype">void</span> f(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c, <span class="keywordtype">void</span> *d);
          <span class="comment">// This function invokes some arbitrary functionality.  The</span>
          <span class="comment">// behavior is undefined unless &#39;0 &lt;= a &lt;= 5&#39;, &#39;0 &lt;= b &lt;= 4&#39;,</span>
          <span class="comment">// &#39;0 &lt;= c &lt;= 3&#39;, and &#39;d&#39; is a valid pointer referring to some</span>
          <span class="comment">// object known by the utility.</span>
  };
</pre></div><br/>
<br/>
 To illustrate the test facilities, we will validate the function arguments <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> with some additional assumptions. We assume the cost of testing <code>a</code> is significant compared to the unspecified body of <code>f</code>. Likewise, we assume that testing the validity of <code>b</code> is relatively efficient, while not only can <code>c</code> be tested efficiently, but the unspecified behavior of <code>f</code> will have potentially catastrophic consequences if <code>c</code> is not valid, such as writing bad/corrupt values to some external data source. Finally, we would like to test that <code>d</code> is a valid pointer. In general, this is a non-trivial problem, but it becomes much simpler if we can afford some extra bookkeeping. Therefore, if we are building in a <code>SAFE_2</code> mode, we will add an additional cache of data, <code>s_trustedPointers</code>, which will maintain a list of known valid pointers that work with this facility. Pointers will be registered and de-registered through calls to other methods in the <code>MyUtil</code> class, and a valid pointer can be detected by searching for its value in this array. Note that this artificial example is modeled after the behavior of some libraries that provide a "safe" STL mode that looks for invalid iterators in a similar way. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #ifdef BDE_BUILD_TARGET_SAFE_2</span>
<span class="preprocessor"></span>  <span class="keywordtype">void</span> *MyUtil::s_trustedPointers[10] = {};

  <span class="keywordtype">bool</span> MyUtil::isValid(<span class="keywordtype">void</span> *pointer)
  {
      <span class="keywordflow">if</span> (0 == pointer) {
          <span class="keywordflow">return</span> <span class="keyword">true</span>;
      }
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 10; ++i) {
          <span class="keywordflow">if</span> (pointer == s_trustedPointers[i]) {
              <span class="keywordflow">return</span> <span class="keyword">true</span>;
          }
      }
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
  <span class="keywordtype">void</span> MyUtil::f(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c, <span class="keywordtype">void</span> *d)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(0 &lt;= a);  <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(a &lt;= 5);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>     (0 &lt;= b);  <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>     (b &lt;= 4);
      <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a> (0 &lt;= c);  <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a> (c &lt;= 3);

<span class="preprocessor">  #ifdef BDE_BUILD_TARGET_SAFE_2</span>
<span class="preprocessor"></span>      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(isValid(d));  <span class="comment">// assume small runtime overhead (&lt; 10%)</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
      <span class="comment">// ...</span>
      <span class="comment">// ...              (body of function &#39;f&#39;)</span>
      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 Now that we have defined the contract for <code>f</code> and the range of undefined behavior we hope to catch with assertions, we are ready to write the test case for this function. In addition to verifying the (unspecified) behavior of <code>f</code> when called with valid function arguments, we also want to verify that calling with invalid arguments triggers an assertion in the appropriate build modes. As this will involve many tests, a table- driven approach is preferred. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testMyUtilF()
  {
      <span class="comment">// ...</span>
      <span class="comment">// ...          (test correct behavior of function &#39;f&#39;)</span>
      <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 First we announce that we are starting the negative testing portion of this test case. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (globalVerbose) printf(<span class="stringliteral">&quot;\nNegative Testing\n&quot;</span>);
</pre></div><br/>
<br/>
 Next we check that exceptions are enabled in the current build mode, as the assertion-testing mechanisms are built on top of exceptions. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #ifdef BDE_BUILD_TARGET_EXC</span>
<span class="preprocessor"></span>      {
          <a class="code" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a> g(
                                           <a class="code" href="structbsls_1_1AssertTest.html#a67f37106930c1760e599519c2d173020">bsls::AssertTest::failTestDriver</a>);
</pre></div><br/>
<br/>
 Then we build the table of test values, listing the expected build mode for the assertion under test to be enabled, whether the assertion should pass or fail, and the set of arguments to pass to <code>f</code> in order to test the relevant assertion. Note that we pick values in the table to test the boundaries of defined behavior, verifying that out-of-band values trigger the assertions while the adjacent in-band values succeed. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>{
      <span class="keywordtype">int</span>         d_lineNumber;       <span class="comment">// line # of row in this table</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *d_assertBuildType;  <span class="comment">// &quot;S&quot;, &quot;S2&quot;, &quot;A&quot;, &quot;A2&quot;, &quot;O&quot;,</span>
                                      <span class="comment">// &quot;O2&quot;</span>
      <span class="keywordtype">char</span>        d_expectedResult;   <span class="comment">// assertion: &#39;P&#39;ass or &#39;F&#39;ail</span>
      <span class="keywordtype">int</span>         d_a;                <span class="comment">// function arg #1</span>
      <span class="keywordtype">int</span>         d_b;                <span class="comment">// function arg #2</span>
      <span class="keywordtype">int</span>         d_c;                <span class="comment">// function arg #3</span>
      <span class="keywordtype">void</span>       *d_d_p;              <span class="comment">// function arg #4</span>
  } DATA[] = {
      <span class="comment">//LINE  TYPE  RESULT   A    B    C    D</span>
      <span class="comment">//----  ----  ------  ---  ---  ---  ---</span>

      <span class="comment">// testing defensive checks for parameter &#39;a&#39;</span>

      { L_,   <span class="stringliteral">&quot;S&quot;</span>,   <span class="charliteral">&#39;F&#39;</span>,   -1,   0,   0,   0 },
      { L_,   <span class="stringliteral">&quot;S&quot;</span>,   <span class="charliteral">&#39;P&#39;</span>,    0,   0,   0,   0 },

      { L_,   <span class="stringliteral">&quot;S&quot;</span>,   <span class="charliteral">&#39;P&#39;</span>,    5,   0,   0,   0 },
      { L_,   <span class="stringliteral">&quot;S&quot;</span>,   <span class="charliteral">&#39;F&#39;</span>,    6,   0,   0,   0 },

      <span class="comment">// testing defensive checks for parameter &#39;b&#39;</span>

      { L_,   <span class="stringliteral">&quot;A&quot;</span>,   <span class="charliteral">&#39;F&#39;</span>,    0,  -1,   0,   0 },
      { L_,   <span class="stringliteral">&quot;A&quot;</span>,   <span class="charliteral">&#39;P&#39;</span>,    0,   0,   0,   0 },

      { L_,   <span class="stringliteral">&quot;A&quot;</span>,   <span class="charliteral">&#39;P&#39;</span>,    0,   4,   0,   0 },
      { L_,   <span class="stringliteral">&quot;A&quot;</span>,   <span class="charliteral">&#39;F&#39;</span>,    0,   5,   0,   0 },

      <span class="comment">// testing defensive checks for parameter &#39;c&#39;</span>

      { L_,   <span class="stringliteral">&quot;O&quot;</span>,   <span class="charliteral">&#39;F&#39;</span>,    0,   0,  -1,   0 },
      { L_,   <span class="stringliteral">&quot;O&quot;</span>,   <span class="charliteral">&#39;P&#39;</span>,    0,   0,   0,   0 },

      { L_,   <span class="stringliteral">&quot;O&quot;</span>,   <span class="charliteral">&#39;P&#39;</span>,    0,   0,   3,   0 },
      { L_,   <span class="stringliteral">&quot;O&quot;</span>,   <span class="charliteral">&#39;F&#39;</span>,    0,   0,   4,   0 },

      <span class="comment">// testing defensive checks for parameter &#39;d&#39;</span>

      { L_,   <span class="stringliteral">&quot;A2&quot;</span>,  <span class="charliteral">&#39;P&#39;</span>,    0,   0,   0,   0             },
      { L_,   <span class="stringliteral">&quot;A2&quot;</span>,  <span class="charliteral">&#39;F&#39;</span>,    0,   0,   0,   (<span class="keywordtype">void</span> *)0xBAD },

  };
  <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_DATA = <span class="keyword">sizeof</span> DATA / <span class="keyword">sizeof</span> *DATA;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ti = 0; ti &lt; NUM_DATA; ++ti) {
      <span class="keyword">const</span> <span class="keywordtype">int</span>         LINE   = DATA[ti].d_lineNumber;
      <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> TYPE   = DATA[ti].d_assertBuildType;
      <span class="keyword">const</span> <span class="keywordtype">char</span>        RESULT = DATA[ti].d_expectedResult;
      <span class="keyword">const</span> <span class="keywordtype">int</span>         A      = DATA[ti].d_a;
      <span class="keyword">const</span> <span class="keywordtype">int</span>         B      = DATA[ti].d_b;
      <span class="keyword">const</span> <span class="keywordtype">int</span>         C      = DATA[ti].d_c;
      <span class="keywordtype">void</span>       *<span class="keyword">const</span> D      = DATA[ti].d_d_p;

      <span class="comment">// Validate test description.</span>
</pre></div><br/>
<br/>
 We should verify that the assert-related parameters describe a valid test configuration before running any tests. <br/>
<br/>
<div class="fragment"><pre class="fragment">  LOOP_ASSERT(LINE, <a class="code" href="structbsls_1_1AssertTest.html#a0cfb717c47bf9984a78d47b36984afc1">bsls::AssertTest::isValidAssertBuild</a>(TYPE));
  LOOP_ASSERT(LINE, <a class="code" href="structbsls_1_1AssertTest.html#a45a8b9f14aef73efde7a560319af7241">bsls::AssertTest::isValidExpected</a>(RESULT));
</pre></div><br/>
<br/>
 Then, if we determine that there is no useful test to perform, continue with the next iteration of the loop. Note that when a 'F'ail is expected, there is no meaningful test unless the build mode enables the relevant assertion. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// Skip this test if the relevant assert is not active in this</span>
  <span class="comment">// build.</span>

  <span class="keywordflow">if</span> (<span class="charliteral">&#39;F&#39;</span> == RESULT &amp;&amp; !<a class="code" href="bsls__asserttest_8h.html#ae23762cb172109adbc1e88a716469574">BSLS_ASSERTTEST_IS_ACTIVE</a>(TYPE)) {
      <span class="keywordflow">continue</span>;
  }

  <span class="comment">// The relevant assert is active in this build.</span>
</pre></div><br/>
<br/>
 Finally, we verify that the assert fires (or not) as expected by hooking up a pair of try/catch probes. We use <code>LOOP_ASSERT</code> to verify that we get the correct behavior from <code>f</code>, whether an assertion throws an exception or not. <br/>
<br/>
<div class="fragment"><pre class="fragment">              <span class="keywordflow">try</span> {
                  <span class="keywordflow">if</span> (globalVeryVerbose) {
                      T_ P_(TYPE) P_(RESULT) P_(A) P_(B) P_(C) P(D)
                  }

                  MyUtil::f(A, B, C, D);

                  LOOP_ASSERT(LINE, bsls::AssertTest::tryProbe(RESULT));
              }
              catch (const bsls::AssertTestException&amp; e) {

                  LOOP_ASSERT(LINE, <a class="code" href="structbsls_1_1AssertTest.html#a3bea889cd92ed04b75fbfcd98cff2bc7">bsls::AssertTest::catchProbe</a>(RESULT,
                                                                 e,
                                                                 __FILE__));
              }

          }  <span class="comment">// table-driven &#39;for&#39; loop</span>
      }
<span class="preprocessor">  #else   // BDE_BUILD_TARGET_EXC</span>
</pre></div><br/>
<br/>
 If exceptions are not available, then we write a diagnostic message to the console alerting the user that this part of the test has not run, without failing the test. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (globalVerbose) printf(
                         <span class="stringliteral">&quot;\tDISABLED in this (non-exception) build mode.\n&quot;</span>);

<span class="preprocessor">  #endif  // BDE_BUILD_TARGET_EXC</span>
<span class="preprocessor"></span>
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
