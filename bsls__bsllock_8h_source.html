<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bsls_bsllock.h                                                     -*-C++-*-
#ifndef INCLUDED_BSLS_BSLLOCK
#define INCLUDED_BSLS_BSLLOCK

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a platform-independent mutex for use below &#39;bslmt&#39;.
//
//@CLASSES:
//  bsls::BslLock: platform-independent mutex
//  bsls::BslLockGuard: RAII mechanism for locking/unlocking a &#39;BslLock&#39;
//
//@SEE_ALSO: bslmt_mutex
//
//@DESCRIPTION: This component provides a mutually exclusive lock primitive
// (&quot;mutex&quot;) by wrapping a suitable platform-specific mechanism.  The
// &#39;bsls::BslLock&#39; class provides &#39;lock&#39; and &#39;unlock&#39; operations.  Note that
// &#39;bsls::BslLock&#39; is not intended for direct client use; see &#39;bslmt_mutex&#39;
// instead.  Also note that &#39;bsls::BslLock&#39; is not recursive.
//
// This component also provides the &#39;bsls::BslLockGuard&#39; class, a mechanism
// that follows the RAII idiom for automatically acquiring and releasing the
// lock on an associated &#39;bsls::BslLock&#39; object.  To ensure exception safety,
// client code should make use of a &#39;bsls::BslLockGuard&#39; object wherever
// appropriate rather than calling the methods on the associated
// &#39;bsls::BslLock&#39; object directly.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Using &#39;bsls::BslLock&#39; to Make a &#39;class&#39; Thread-Safe
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In this example we illustrate the use of &#39;bsls::BslLock&#39; and
// &#39;bsls::BslLockGuard&#39; to write a thread-safe class.
//
// First, we provide an elided definition of the &#39;my_Account&#39; class.  Note the
// &#39;d_lock&#39; data member of type &#39;bsls::BslLock&#39;:
//..
//  class my_Account {
//      // This &#39;class&#39; implements a very simplistic bank account.  It is meant
//      // for illustrative purposes only.
//
//      // DATA
//      double                d_money;  // amount of money in the account
//      mutable bsls::BslLock d_lock;   // ensure exclusive access to &#39;d_money&#39;
//
//    // ...
//
//    public:
//
//      // ...
//
//      // MANIPULATORS
//      void deposit(double amount);
//          // Atomically deposit the specified &#39;amount&#39; of money into this
//          // account.  The behavior is undefined unless &#39;amount &gt;= 0.0&#39;.
//
//      int withdraw(double amount);
//          // Atomically withdraw the specified &#39;amount&#39; of money from this
//          // account.  Return 0 on success, and a non-zero value otherwise.
//          // The behavior is undefined unless &#39;amount &gt;= 0.0&#39;.
//
//      // ...
//  };
//..
// Next, we show the implementation of the two &#39;my_Account&#39; manipulators
// show-casing the use of &#39;bsls::BslLock&#39; and &#39;bsls::BslLockGuard&#39;:
//..
//  // MANIPULATORS
//  void my_Account::deposit(double amount)
//  {
//..
// Here, we use the interface of &#39;bsls::BslLock&#39; directly.  However, wherever
// appropriate, a &#39;bsls::BslLockGuard&#39; object should be used instead to ensure
// that an acquired lock is always properly released, even if an exception is
// thrown:
//..
//      BSLS_ASSERT(amount &gt;= 0.0);
//
//      d_lock.lock();  // consider using &#39;bsls::BslLockGuard&#39; (see &#39;withdraw&#39;)
//      d_money += amount;
//      d_lock.unlock();
//  }
//..
// In contrast, &#39;withdraw&#39; uses a &#39;bsls::BslLockGuard&#39; to automatically acquire
// and release the lock.  The lock is acquired as a side-effect of the
// construction of &#39;guard&#39;, and released when &#39;guard&#39; is destroyed upon
// returning from the function:
//..
//  int my_Account::withdraw(double amount)
//  {
//      BSLS_ASSERT(amount &gt;= 0.0);
//
//      bsls::BslLockGuard guard(&amp;d_lock);  // a very good practice
//
//      if (amount &lt;= d_money) {
//          d_money -= amount;
//          return 0;
//      }
//      else {
//          return -1;
//      }
//  }
//..

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifdef BSLS_PLATFORM_OS_WINDOWS

#ifndef INCLUDED_WTYPES
#include &lt;wtypes.h&gt;
#define INCLUDED_WTYPES
#endif

#ifndef INCLUDED_WINBASE
#include &lt;winbase.h&gt;
#define INCLUDED_WINBASE
#endif

#else

#ifndef INCLUDED_PTHREAD
#include &lt;pthread.h&gt;
#define INCLUDED_PTHREAD
#endif

#endif

namespace BloombergLP {
namespace bsls {

                             // =============
                             // class BslLock
                             // =============

class BslLock {
    // This &#39;class&#39; implements a light-weight, portable wrapper of an OS-level
    // mutex to support intra-process synchronization.  The mutex implemented
    // by this class is *non*-recursive.  Note that &#39;BslLock&#39; is *not* intended
    // for direct use by client code; it is meant for internal use only.

    // DATA
#ifdef BSLS_PLATFORM_OS_WINDOWS
    CRITICAL_SECTION d_lock;  // Windows critical section
#else
    pthread_mutex_t  d_lock;  // pthreads mutex object
#endif

  private:
    // NOT IMPLEMENTED
    BslLock(const BslLock&amp;);             // = delete
    BslLock&amp; operator=(const BslLock&amp;);  // = delete

  public:
    // CREATORS
    BslLock();
        // Create a lock object initialized to the unlocked state.

    ~BslLock();
        // Destroy this lock object.  The behavior is undefined unless this
        // object is in the unlocked state.

    // MANIPULATORS
    void lock();
        // Acquire the lock on this object.  If the lock on this object is
        // currently held by another thread, then suspend execution of the
        // calling thread until the lock can be acquired.  The behavior is
        // undefined unless the calling thread does not already hold the lock
        // on this object.  Note that deadlock may result if this method is
        // invoked while the calling thread holds the lock on the object.

    void unlock();
        // Release the lock on this object that was previously acquired
        // through a call to &#39;lock&#39;, enabling another thread to acquire the
        // lock.  The behavior is undefined unless the calling thread holds the
        // lock on this object.
};

                             // ==================
                             // class BslLockGuard
                             // ==================

class BslLockGuard {
    // This &#39;class&#39; implements a guard for automatically acquiring and
    // releasing the lock on an associated &#39;bsls::BslLock&#39; object.  This
    // mechanism follows the RAII idiom whereby the lock on the &#39;BslLock&#39;
    // associated with a guard object is acquired upon construction and
    // released upon destruction.

    // DATA
    BslLock *d_lock_p;  // lock guarded by this object (held, not owned)

  private:
    // NOT IMPLEMENTED
    BslLockGuard(const BslLockGuard&amp;);             // = delete
    BslLockGuard&amp; operator=(const BslLockGuard&amp;);  // = delete

  public:
    // CREATORS
    explicit BslLockGuard(BslLock *lock);
        // Create a guard object that conditionally manages the specified
        // &#39;lock&#39;, and acquires the lock on &#39;lock&#39; by invoking its &#39;lock&#39;
        // method.  The behavior is undefined unless the calling thread does
        // not already hold the lock on &#39;lock&#39;.  Note that deadlock may result
        // if a guard is created for &#39;lock&#39; while the calling thread holds the
        // lock on &#39;lock&#39;.  Also note that &#39;lock&#39; must remain valid throughout
        // the lifetime of this guard, or until &#39;release&#39; is called.

    ~BslLockGuard();
        // Destroy this guard object and release the lock on the object it
        // manages (if any) by invoking the &#39;unlock&#39; method of the object that
        // was supplied at construction of this guard.  If no lock is currently
        // being managed, this method has no effect.  Note that if this guard
        // object currently manages a lock, this method assumes the behavior
        // of &#39;BslLock::unlock&#39;.

    // MANIPULATORS
    void release();
        // Release from management, with no effect, the object currently
        // managed by this guard, if any.  Note that &#39;unlock&#39; is *not* called
        // on the managed object upon its release.
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                             // -------------
                             // class BslLock
                             // -------------

// CREATORS
inline
BslLock::BslLock()
{
#ifdef BSLS_PLATFORM_OS_WINDOWS
    enum {
        // A Windows critical section has a configurable spin count.  A lock
        // operation spins this many iterations (on, presumably, some atomic
        // integer) before sleeping on the underlying primitive.

        BSLS_SPIN_COUNT = 30
    };

    InitializeCriticalSectionAndSpinCount(&amp;d_lock, BSLS_SPIN_COUNT);
#else
    const int status = pthread_mutex_init(&amp;d_lock, 0);
    (void)status;
    BSLS_ASSERT_SAFE(0 == status);
#endif
}

inline
BslLock::~BslLock()
{
#ifdef BSLS_PLATFORM_OS_WINDOWS
    DeleteCriticalSection(&amp;d_lock);
#else
    const int status = pthread_mutex_destroy(&amp;d_lock);
    (void)status;
    BSLS_ASSERT_SAFE(0 == status);
#endif
}

// MANIPULATORS
inline
void BslLock::lock()
{
#ifdef BSLS_PLATFORM_OS_WINDOWS
    EnterCriticalSection(&amp;d_lock);
#else
    const int status = pthread_mutex_lock(&amp;d_lock);
    (void)status;
    BSLS_ASSERT_SAFE(0 == status);
#endif
}

inline
void BslLock::unlock()
{
#ifdef BSLS_PLATFORM_OS_WINDOWS
    LeaveCriticalSection(&amp;d_lock);
#else
    const int status = pthread_mutex_unlock(&amp;d_lock);
    (void)status;
    BSLS_ASSERT_SAFE(0 == status);
#endif
}

                             // ------------------
                             // class BslLockGuard
                             // ------------------

// CREATORS
inline
BslLockGuard::BslLockGuard(BslLock *lock)
: d_lock_p(lock)
{
    BSLS_ASSERT_SAFE(lock);

    d_lock_p-&gt;lock();
}

inline
BslLockGuard::~BslLockGuard()
{
    if (d_lock_p) {
        d_lock_p-&gt;unlock();
    }
}

// MANIPULATORS
inline
void BslLockGuard::release()
{
    d_lock_p = 0;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
