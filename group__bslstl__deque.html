<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslstl_deque Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_deque<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant deque class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Deque__BlockLengthCalcUtil.html">bsl::Deque_BlockLengthCalcUtil&lt; VALUE_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Deque__Util.html">bsl::Deque_Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1deque.html">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__BlockCreator.html">bsl::Deque_BlockCreator&lt; VALUE_TYPE, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__ClearGuard.html">bsl::Deque_ClearGuard&lt; VALUE_TYPE, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard&lt; VALUE_TYPE, ALLOCATOR &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaf92ab12ce91714ca99230d1abc0ffb6b">bsl::Deque_Base::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE_TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaa2c26dd93fc744406a167200a47209c9">bsl::Deque_Base::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga893500e2905b8db4e3160b609b87ef05">bsl::Deque_Base::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ConstIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8e0d2c4d1f01840fbd6ae0a516f8405c">bsl::Deque_Base::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gabb9a750d060153b5c500eb00328e1184">bsl::Deque_Base::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gafd592361bbe235e45d91302b1a1378d2">bsl::Deque_Base::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8e1e816c9b4313f4b4f065d057df7f46">bsl::Deque_Base::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; Iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga6669228a017636b079a4f050c21cdba3">bsl::Deque_Base::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; ConstIterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga81140b5fcfa468cd06c568e2d41c5af5">bsl::Deque_Base::const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gac761165949bd5218f8ececd53832414c">bsl::deque::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga03df45e6eb90506c85d69093d6480664">bsl::deque::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga628c5c83597c3a26b339290b5f5f0e36">bsl::deque::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ConstIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga08dedf343d7a033d0bafe503f5e2b178">bsl::deque::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">bsl::deque::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga63686535cf116aa446384504aff31581">bsl::deque::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga1dd70eb2463723ff0ba4abe28dbfd297">bsl::deque::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga01ae9d68729afccf453bbacb11e7ab8d">bsl::deque::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8ff440504e5e45dd8a5fd06c917bb1ef">bsl::deque::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga4ba24da32cb961a262dea2ce725c21a4">bsl::deque::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; Iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaa07dc4420c5faf43d9ca3a89d5b24f7e">bsl::deque::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; ConstIterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga12828b085a7d5a4dbe9005db1d7a2b96">bsl::deque::const_reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga018a4c91445cd28eb18da9732d31486e">bsl::Deque_Util::swap</a> (void *a, void *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaf0d8966e45534543b087e20dcfd3c967">bsl::Deque_Base::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga06392aeeb12f1b1f7a0184a27afe1715">bsl::Deque_Base::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8a2d30e8983d64afde5e338491a6d092">bsl::Deque_Base::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gac7d64233042c6b7815d196cc2eb67cb3">bsl::Deque_Base::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga5412b6a0a87c9c71903638c684cafb66">bsl::Deque_Base::operator[]</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga265fe826d97a34cdbadcfb6fe0c8c07f">bsl::Deque_Base::at</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8e67401ebd1517aa2ce368aa48e3c12e">bsl::Deque_Base::front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gac7feaf19b9ab5c8cf0d85d77c3b93ef5">bsl::Deque_Base::back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga13648d976e92f4004442b55845408331">bsl::Deque_Base::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga2c6e306d3a05bbb6a92fde98a67ea250">bsl::Deque_Base::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga3f9eeb0a30d37c62f54dd413f262f31b">bsl::Deque_Base::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga95656641da4e31fb8753108187ebce8c">bsl::Deque_Base::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga004e15c67f3931784d74e51360ffcddb">bsl::Deque_Base::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaff94077a39bcf9f788d8a4db6bb3972b">bsl::Deque_Base::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8b08099b9477ddc5963ce5a780735fa1">bsl::Deque_Base::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga75f53a4cfb1be952b49f0ca6f2f74784">bsl::Deque_Base::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga36a63e5881adc29e970e96c05a6943d4">bsl::Deque_Base::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga60a45c9dd4dd249516613e5cad02cc57">bsl::Deque_Base::capacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga29b51240eeb0568975bd413cd6256596">bsl::Deque_Base::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gae09a8e008e417584f64295811fa70f57">bsl::Deque_Base::operator[]</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaae57bd1c6ae9e41bda281ae759682183">bsl::Deque_Base::at</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8f6c4fadfb6e49a48748a7eeef97e026">bsl::Deque_Base::front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga446a2e68a78e57763e21bcde323b0a4b">bsl::Deque_Base::back</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gabfb904991e3b5dab50f51e496f60d496">bsl::deque::deque</a> (const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gab8c02d34d1080d71da8c60c7c6e2d1be">bsl::deque::deque</a> (size_type numElements, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gac04cb258ca295ab1825f99c81da519f1">bsl::deque::deque</a> (size_type numElements, const VALUE_TYPE &amp;value, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga9a0e189cf4d53e2dc66ba52137db3d4d">bsl::deque::deque</a> (INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga2457713c3d76757e9365348e9b5518d8">bsl::deque::deque</a> (const deque &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga06bad4260ece6537b62cc067dc9549c3">bsl::deque::deque</a> (const deque &amp;original, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gab22a189b19cecc1625b7783192af8d76">bsl::deque::~deque</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">deque &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gad789196795dddda6d15176c905ad8793">bsl::deque::operator=</a> (const deque &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga1bbb5dd6bd46cc1c60b01358aea51872">bsl::deque::assign</a> (INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga295f47875987fd8930201a4554442c39">bsl::deque::assign</a> (size_type numElements, const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gad3396d1bf4b1bdf01ee7648b9b0a5ac5">bsl::deque::reserve</a> (size_type numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaf494586a13b90a8f56ab04aafae10efe">bsl::deque::resize</a> (size_type newLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga2a194837fcdf9bca06467069973d2d7f">bsl::deque::resize</a> (size_type newLength, VALUE_TYPE value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaea8c2a375d44d4848f01a7a54fe727c5">bsl::deque::push_front</a> (const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga5be1a8bbb0476e82b273c473539ab754">bsl::deque::push_back</a> (const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga4768eb160c95f6199e95c89946189c14">bsl::deque::pop_front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga45f80b9ac8c77bde1fd065e6f0031c23">bsl::deque::pop_back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga87880ccf14caac0c41c75e328000ce9b">bsl::deque::insert</a> (const_iterator position, const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga277926e4ec0b2abbadf2cb4f72a4e77b">bsl::deque::insert</a> (const_iterator position, size_type numElements, const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaff1fd52960f5bae4fc47e971281636eb">bsl::deque::insert</a> (const_iterator position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gae2f368e995db63f45cb29017a4548d85">bsl::deque::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8f6b69203e8c8eed2003b193f14ac654">bsl::deque::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga317cdb1d11333d475f04f7b3e7b7ce53">bsl::deque::swap</a> (deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gab43b14a18b1cbd7e78206f489290a729">bsl::deque::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga049190f2cbfd3c4df1760ebaee35cd9b">bsl::deque::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gadd9dc8f3518d0b5382b4c0449c8ce5a7">bsl::deque::max_size</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gae932279610e8893d59e68df4f6968c64">bsl::operator==</a> (const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga323083767092dbeb43ec96ea2eeb44c7">bsl::operator!=</a> (const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">bsl::operator&lt;</a> (const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8f2ff3ac7d315597e6bf4cf3f1376e51">bsl::operator&gt;</a> (const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gacab21200cbc635611051996fa4ce0c71">bsl::operator&lt;=</a> (const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga6c3069d504792f532e25e1d7f1456a15">bsl::operator&gt;=</a> (const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">bsl::swap</a> (deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga026f4dae8ff11b0dfeda04dd69c9117c">bsl::Deque_BlockCreator::Deque_BlockCreator</a> (deque&lt; VALUE_TYPE, ALLOCATOR &gt; *deque_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga910ab7862e3870737e0bf0dc3734bc13">bsl::Deque_BlockCreator::~Deque_BlockCreator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga97d6001bceda68dc684f699d5636f3a5">bsl::Deque_BlockCreator::insertAtFront</a> (size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gacb9c38837de5ddc90b73d099047b181b">bsl::Deque_BlockCreator::insertAtBack</a> (size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BlockPtr *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaea05edb5c3b3fe1357d443d629fa3a0d">bsl::Deque_BlockCreator::reserveBlockSlots</a> (size_type numNewBlocks, bool atFront)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga5d5cac7d3ca03e6efacc4e9d8e317539">bsl::Deque_BlockCreator::release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gab0e1f1423f94ff6aa450b7a8c3aea503">bsl::Deque_ClearGuard::Deque_ClearGuard</a> (deque&lt; VALUE_TYPE, ALLOCATOR &gt; *deque_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga52e7f909d1bab6b6e6de4f1e2a069acd">bsl::Deque_ClearGuard::~Deque_ClearGuard</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga68a7d6c6a097798fd87c2bd8a5a6d1b7">bsl::Deque_ClearGuard::release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gabe488d8e371469367d36891f3fc4850b">bsl::Deque_Guard::Deque_Guard</a> (deque&lt; VALUE_TYPE, ALLOCATOR &gt; *deque_p, bool isTail)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gad0e48efe2bac3632ff953e2962ce8836">bsl::Deque_Guard::~Deque_Guard</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gafbcce8b09c6191d1a5180370794043d0">bsl::Deque_Guard::operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gae5f621c85d12230bdab4397fa4478c3c">bsl::Deque_Guard::operator--</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8190b472ed0485d88be4c65de356e9b4">bsl::Deque_Guard::release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga90a77f046090a502fdd5a7b83a5d4fa1">bsl::Deque_Guard::count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">IteratorImp&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga4a24ba75626617d9d6eaa327c206a67c">bsl::Deque_Guard::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">IteratorImp&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gaba7de8e16eab60ff416b6f36f4696dcf">bsl::Deque_Guard::end</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BlockPtr *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga9576de86cb80f207d2681244f8cd820d">bsl::Deque_Base::d_blocks</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga6a9830701bc1e6442dba82e884c005a0">bsl::Deque_Base::d_blocksLength</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">IteratorImp&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gafca73e1e31f31edcc9e2af9527db4bfa">bsl::Deque_Base::d_start</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">IteratorImp&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga0ffdc5bf3423e893966faf49a1fefc02">bsl::Deque_Base::d_finish</a></td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gae47866dd8a0cb6e661157d1d321921df">bsl::deque::Deque_BlockCreator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gad5d657184b6a85ebf1ffe7d6cd255438">bsl::deque::Deque_Guard</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Exceptional Behavior</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using a <code>deque</code> to Implement a Laundry Queue</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant deque class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslstl_Deque </td><td>standard-compliant <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a></code> implementation  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__vector.html" title="Provide an STL-compliant vector class.">Component bslstl_vector</a>, bsl+stlhdrs </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is for internal use only. Please include <code>&lt;bsl_deque.h&gt;</code> instead and use <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a></code> directly. This component implements a dynamic double-ended array class that supports the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> model and is suitable for use as an implementation of the <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a></code> class template. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exceptional_behavior"></a> <a class="anchor" id="description.exceptional_behavior"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Exceptional Behavior: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since this component is below the BSL STL, we centralize all the exceptional behavior into a <code><a class="el" href="structbslstl_1_1StdExceptUtil.html">bslstl::StdExceptUtil</a></code> class, which has a dual purpose: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
Remove the dependency of this header on the <code>&lt;exception&gt;</code> header, so that this implementation can offer an exception handler with the native exceptions, and so that all the C-strings may be defined in a single library (<code>bsl</code>) and not in all the translation units including this header.  </li>
<li>
Allow installation of exception handlers at a higher level to throw BSL STL exceptions (which differ from the native exceptions) and thus establish a full standard compliance for this component when used as <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a></code> in the BSL STL.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_a_deque_to_implement_a_laundry_queue"></a> <a class="anchor" id="usage.example_1~3A_using_a_deque_to_implement_a_laundry_queue"></a> <a class="anchor" id="description.usage.example_1~3A_using_a_deque_to_implement_a_laundry_queue"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using a deque to Implement a Laundry Queue: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to define a class to maintain a process queue of names of customers who are dropping off their laundry at a drop-off laundry service. We can accomplish this by defining a new class characterizing a laundry-process queue that uses <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a></code> in its implementation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The process queue provides two methods, <code>push</code> and <code>expeditedPush</code>, for inserting names of customers onto the queue. When calling the <code>push</code> method, the customer's name will be inserted at the end of the queue -- his laundry will be done after the laundry of customers previously on the queue. The <code>expeditedPush</code> method is reserved for customers who have bribed the merchant for expedited service. When calling the <code>expeditedPush</code> method, the customer's name will be inserted onto the front of the queue -- his laundry will be done before customers previously on the queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the workers are ready to do some laundry, they call the <code>next</code> method of the queue, which returns the name of the customer whose laundry is to be done next. For brevity of the usage example, we do not show how customers are track while or after their laundry is being done. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, the laundry queue also provides the <code>find</code> method, which returns a <code>bool</code> to indicate whether a given customer is still in the queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we declare a class <code>LaundryQueue</code> based on a deque, to store names of customers at a drop-off laundry: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>LaundryQueue {
      <span class="comment">// This &#39;class&#39; keeps track of customers enqueued to have their laundry</span>
      <span class="comment">// done by a laundromat.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1deque.html">bsl::deque&lt;bsl::string&gt;</a> d_queue;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      LaundryQueue(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;LaundryQueue&#39; object using the specified</span>
          <span class="comment">// &#39;basicAllocator&#39;.  If &#39;basicAllocator&#39; is not provided, use the</span>
          <span class="comment">// default allocator.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> push(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; customerName);
          <span class="comment">// Add the specified &#39;customerName&#39; to the back of the laundry</span>
          <span class="comment">// queue.</span>

      <span class="keywordtype">void</span> expeditedPush(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; customerName);
          <span class="comment">// Add the specified &#39;customerName&#39; to the laundry queue at the</span>
          <span class="comment">// front.</span>

      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> next();
          <span class="comment">// Return the name from the front of the queue, removing it from</span>
          <span class="comment">// the queue.  If the queue is empty, return &#39;(* empty *)&#39; which is</span>
          <span class="comment">// not a valid name for a customer.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">bool</span> find(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; customerName);
          <span class="comment">// Return &#39;true&#39; if &#39;customerName&#39; is in the queue, and &#39;false&#39;</span>
          <span class="comment">// otherwise.</span>
  };
</pre></div><br/>
<br/>
 Then, we define the implementation of the methods of <code>LaundryQueue</code> <br/>
<br/>
<div class="fragment"><pre class="fragment"> CREATORS
  LaundryQueue::LaundryQueue(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_queue(basicAllocator)
  {
      <span class="comment">// Note that the allocator is propagated to the underlying &#39;deque&#39;,</span>
      <span class="comment">// which will use the default allocator is &#39;0 == basicAllocator&#39;.</span>
  }

 MANIPULATORS
  <span class="keywordtype">void</span> LaundryQueue::push(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; customerName)
  {
      d_queue.push_back(customerName);     <span class="comment">// note constant time</span>
  }

  <span class="keywordtype">void</span> LaundryQueue::expeditedPush(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; customerName)
  {
      d_queue.push_front(customerName);    <span class="comment">// note constant time</span>
  }

  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> LaundryQueue::next()
  {
      <span class="keywordflow">if</span> (d_queue.empty()) {
          <span class="keywordflow">return</span> <span class="stringliteral">&quot;(* empty *)&quot;</span>;
      }

      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> ret = d_queue.front();   <span class="comment">// note constant time</span>

      d_queue.pop_front();                 <span class="comment">// note constant time</span>

      <span class="keywordflow">return</span> ret;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keywordtype">bool</span> LaundryQueue::find(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; customerName)
  {
      <span class="comment">// Note &#39;d_queue.empty() || d_queue[0] == d_queue.front()&#39;</span>

      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; d_queue.size(); ++i) {
          <span class="keywordflow">if</span> (customerName == d_queue[i]) {    <span class="comment">// note &#39;[]&#39; is constant time</span>
              <span class="keywordflow">return</span> <span class="keyword">true</span>;
          }
      }

      <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaf92ab12ce91714ca99230d1abc0ffb6b"></a><!-- doxytag: member="bsl::Deque_Base::reference" ref="gaf92ab12ce91714ca99230d1abc0ffb6b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE&amp; <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#gac761165949bd5218f8ececd53832414c">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gaa2c26dd93fc744406a167200a47209c9"></a><!-- doxytag: member="bsl::Deque_Base::const_reference" ref="gaa2c26dd93fc744406a167200a47209c9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const VALUE_TYPE&amp; <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#ga03df45e6eb90506c85d69093d6480664">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga893500e2905b8db4e3160b609b87ef05"></a><!-- doxytag: member="bsl::Deque_Base::iterator" ref="ga893500e2905b8db4e3160b609b87ef05" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#ga628c5c83597c3a26b339290b5f5f0e36">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga8e0d2c4d1f01840fbd6ae0a516f8405c"></a><!-- doxytag: member="bsl::Deque_Base::const_iterator" ref="ga8e0d2c4d1f01840fbd6ae0a516f8405c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstIterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#ga08dedf343d7a033d0bafe503f5e2b178">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gabb9a750d060153b5c500eb00328e1184"></a><!-- doxytag: member="bsl::Deque_Base::size_type" ref="gabb9a750d060153b5c500eb00328e1184" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gafd592361bbe235e45d91302b1a1378d2"></a><!-- doxytag: member="bsl::Deque_Base::difference_type" ref="gafd592361bbe235e45d91302b1a1378d2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#ga63686535cf116aa446384504aff31581">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga8e1e816c9b4313f4b4f065d057df7f46"></a><!-- doxytag: member="bsl::Deque_Base::value_type" ref="ga8e1e816c9b4313f4b4f065d057df7f46" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#ga1dd70eb2463723ff0ba4abe28dbfd297">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga6669228a017636b079a4f050c21cdba3"></a><!-- doxytag: member="bsl::Deque_Base::reverse_iterator" ref="ga6669228a017636b079a4f050c21cdba3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;Iterator&gt; <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#gaa07dc4420c5faf43d9ca3a89d5b24f7e">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga81140b5fcfa468cd06c568e2d41c5af5"></a><!-- doxytag: member="bsl::Deque_Base::const_reverse_iterator" ref="ga81140b5fcfa468cd06c568e2d41c5af5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;ConstIterator&gt; <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__deque.html#ga12828b085a7d5a4dbe9005db1d7a2b96">bsl::deque&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gac761165949bd5218f8ececd53832414c"></a><!-- doxytag: member="bsl::deque::reference" ref="gac761165949bd5218f8ececd53832414c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::reference <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#gaf92ab12ce91714ca99230d1abc0ffb6b">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga03df45e6eb90506c85d69093d6480664"></a><!-- doxytag: member="bsl::deque::const_reference" ref="ga03df45e6eb90506c85d69093d6480664" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_reference <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#gaa2c26dd93fc744406a167200a47209c9">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga628c5c83597c3a26b339290b5f5f0e36"></a><!-- doxytag: member="bsl::deque::iterator" ref="ga628c5c83597c3a26b339290b5f5f0e36" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Iterator <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#ga893500e2905b8db4e3160b609b87ef05">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga08dedf343d7a033d0bafe503f5e2b178"></a><!-- doxytag: member="bsl::deque::const_iterator" ref="ga08dedf343d7a033d0bafe503f5e2b178" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstIterator <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#ga8e0d2c4d1f01840fbd6ae0a516f8405c">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gaef5936f7e31c8079dac4234b36958791"></a><!-- doxytag: member="bsl::deque::size_type" ref="gaef5936f7e31c8079dac4234b36958791" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#gabb9a750d060153b5c500eb00328e1184">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga63686535cf116aa446384504aff31581"></a><!-- doxytag: member="bsl::deque::difference_type" ref="ga63686535cf116aa446384504aff31581" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#gafd592361bbe235e45d91302b1a1378d2">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga1dd70eb2463723ff0ba4abe28dbfd297"></a><!-- doxytag: member="bsl::deque::value_type" ref="ga1dd70eb2463723ff0ba4abe28dbfd297" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#ga8e1e816c9b4313f4b4f065d057df7f46">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga01ae9d68729afccf453bbacb11e7ab8d"></a><!-- doxytag: member="bsl::deque::allocator_type" ref="ga01ae9d68729afccf453bbacb11e7ab8d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8ff440504e5e45dd8a5fd06c917bb1ef"></a><!-- doxytag: member="bsl::deque::pointer" ref="ga8ff440504e5e45dd8a5fd06c917bb1ef" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::pointer <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4ba24da32cb961a262dea2ce725c21a4"></a><!-- doxytag: member="bsl::deque::const_pointer" ref="ga4ba24da32cb961a262dea2ce725c21a4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_pointer <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa07dc4420c5faf43d9ca3a89d5b24f7e"></a><!-- doxytag: member="bsl::deque::reverse_iterator" ref="gaa07dc4420c5faf43d9ca3a89d5b24f7e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;Iterator&gt; <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#ga6669228a017636b079a4f050c21cdba3">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga12828b085a7d5a4dbe9005db1d7a2b96"></a><!-- doxytag: member="bsl::deque::const_reverse_iterator" ref="ga12828b085a7d5a4dbe9005db1d7a2b96" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;ConstIterator&gt; <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__deque.html#ga81140b5fcfa468cd06c568e2d41c5af5">bsl::Deque_Base&lt; VALUE_TYPE &gt;</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga018a4c91445cd28eb18da9732d31486e"></a><!-- doxytag: member="bsl::Deque_Util::swap" ref="ga018a4c91445cd28eb18da9732d31486e" args="(void *a, void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bsl::Deque_Util::swap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of the specified <code>lhs</code> deque with that of the specified <code>rhs</code> deque. </p>

</div>
</div>
<a class="anchor" id="gaf0d8966e45534543b087e20dcfd3c967"></a><!-- doxytag: member="bsl::Deque_Base::begin" ref="gaf0d8966e45534543b087e20dcfd3c967" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this modifiable deque (or the past-the-end iterator if this deque is empty). </p>

</div>
</div>
<a class="anchor" id="ga06392aeeb12f1b1f7a0184a27afe1715"></a><!-- doxytag: member="bsl::Deque_Base::end" ref="ga06392aeeb12f1b1f7a0184a27afe1715" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this modifiable deque. </p>

</div>
</div>
<a class="anchor" id="ga8a2d30e8983d64afde5e338491a6d092"></a><!-- doxytag: member="bsl::Deque_Base::rbegin" ref="ga8a2d30e8983d64afde5e338491a6d092" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this modifiable deque (or the past-the-end reverse iterator if this deque is empty). </p>

</div>
</div>
<a class="anchor" id="gac7d64233042c6b7815d196cc2eb67cb3"></a><!-- doxytag: member="bsl::Deque_Base::rend" ref="gac7d64233042c6b7815d196cc2eb67cb3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this modifiable deque. </p>

</div>
</div>
<a class="anchor" id="ga5412b6a0a87c9c71903638c684cafb66"></a><!-- doxytag: member="bsl::Deque_Base::operator[]" ref="ga5412b6a0a87c9c71903638c684cafb66" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gabb9a750d060153b5c500eb00328e1184">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>position</code> in this deque. The behavior is undefined unless <code>0 &lt;= position &lt; size()</code>. </p>

</div>
</div>
<a class="anchor" id="ga265fe826d97a34cdbadcfb6fe0c8c07f"></a><!-- doxytag: member="bsl::Deque_Base::at" ref="ga265fe826d97a34cdbadcfb6fe0c8c07f" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gabb9a750d060153b5c500eb00328e1184">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>position</code>. Call <code>StdExceptUtil::throwOutOfRange</code> if <code>position &gt;= size()</code>. </p>

</div>
</div>
<a class="anchor" id="ga8e67401ebd1517aa2ce368aa48e3c12e"></a><!-- doxytag: member="bsl::Deque_Base::front" ref="ga8e67401ebd1517aa2ce368aa48e3c12e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable character at the first position in this deque. The behavior is undefined if this deque is empty. </p>

</div>
</div>
<a class="anchor" id="gac7feaf19b9ab5c8cf0d85d77c3b93ef5"></a><!-- doxytag: member="bsl::Deque_Base::back" ref="gac7feaf19b9ab5c8cf0d85d77c3b93ef5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable character at the last position in this deque. The behavior is undefined if this deque is empty. Note that the last position is <code>size() - 1</code>. </p>

</div>
</div>
<a class="anchor" id="ga13648d976e92f4004442b55845408331"></a><!-- doxytag: member="bsl::Deque_Base::begin" ref="ga13648d976e92f4004442b55845408331" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2c6e306d3a05bbb6a92fde98a67ea250"></a><!-- doxytag: member="bsl::Deque_Base::cbegin" ref="ga2c6e306d3a05bbb6a92fde98a67ea250" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing to the first element in this non-modifiable deque (or the past-the-end iterator if this deque is empty). </p>

</div>
</div>
<a class="anchor" id="ga3f9eeb0a30d37c62f54dd413f262f31b"></a><!-- doxytag: member="bsl::Deque_Base::end" ref="ga3f9eeb0a30d37c62f54dd413f262f31b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga95656641da4e31fb8753108187ebce8c"></a><!-- doxytag: member="bsl::Deque_Base::cend" ref="ga95656641da4e31fb8753108187ebce8c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this non-modifiable deque. </p>

</div>
</div>
<a class="anchor" id="ga004e15c67f3931784d74e51360ffcddb"></a><!-- doxytag: member="bsl::Deque_Base::rbegin" ref="ga004e15c67f3931784d74e51360ffcddb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaff94077a39bcf9f788d8a4db6bb3972b"></a><!-- doxytag: member="bsl::Deque_Base::crbegin" ref="gaff94077a39bcf9f788d8a4db6bb3972b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this non-modifiable deque (or the past-the-end reverse iterator if this deque is empty). </p>

</div>
</div>
<a class="anchor" id="ga8b08099b9477ddc5963ce5a780735fa1"></a><!-- doxytag: member="bsl::Deque_Base::rend" ref="ga8b08099b9477ddc5963ce5a780735fa1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga75f53a4cfb1be952b49f0ca6f2f74784"></a><!-- doxytag: member="bsl::Deque_Base::crend" ref="ga75f53a4cfb1be952b49f0ca6f2f74784" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this non-modifiable deque. </p>

</div>
</div>
<a class="anchor" id="ga36a63e5881adc29e970e96c05a6943d4"></a><!-- doxytag: member="bsl::Deque_Base::size" ref="ga36a63e5881adc29e970e96c05a6943d4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the length of this deque. </p>

</div>
</div>
<a class="anchor" id="ga60a45c9dd4dd249516613e5cad02cc57"></a><!-- doxytag: member="bsl::Deque_Base::capacity" ref="ga60a45c9dd4dd249516613e5cad02cc57" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the sum of the current size plus the minimum number of <code>push_front</code> or <code>push_back</code> operations needed to invalidate iterators in this deque. </p>

</div>
</div>
<a class="anchor" id="ga29b51240eeb0568975bd413cd6256596"></a><!-- doxytag: member="bsl::Deque_Base::empty" ref="ga29b51240eeb0568975bd413cd6256596" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this deque has length 0, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gae09a8e008e417584f64295811fa70f57"></a><!-- doxytag: member="bsl::Deque_Base::operator[]" ref="gae09a8e008e417584f64295811fa70f57" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gabb9a750d060153b5c500eb00328e1184">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>position</code> in this deque. The behavior is undefined unless <code>0 &lt;= position &lt; size()</code>. </p>

</div>
</div>
<a class="anchor" id="gaae57bd1c6ae9e41bda281ae759682183"></a><!-- doxytag: member="bsl::Deque_Base::at" ref="gaae57bd1c6ae9e41bda281ae759682183" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gabb9a750d060153b5c500eb00328e1184">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>position</code>. Call <code><a class="el" href="structbslstl_1_1StdExceptUtil.html#a50593e11b2169163835e3d91c2b90251">bslstl::StdExceptUtil::throwOutOfRange</a></code> if <code>position &gt;= size()</code>. </p>

</div>
</div>
<a class="anchor" id="ga8f6c4fadfb6e49a48748a7eeef97e026"></a><!-- doxytag: member="bsl::Deque_Base::front" ref="ga8f6c4fadfb6e49a48748a7eeef97e026" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable character at the first position in this deque. The behavior is undefined if this deque is empty. </p>

</div>
</div>
<a class="anchor" id="ga446a2e68a78e57763e21bcde323b0a4b"></a><!-- doxytag: member="bsl::Deque_Base::back" ref="ga446a2e68a78e57763e21bcde323b0a4b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable character at the last position in this deque. The behavior is undefined if this deque is empty. Note that the last position is <code>size() - 1</code>. </p>

</div>
</div>
<a class="anchor" id="gabfb904991e3b5dab50f51e496f60d496"></a><!-- doxytag: member="bsl::deque::deque" ref="gabfb904991e3b5dab50f51e496f60d496" args="(const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::deque </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty deque. Optionally specified the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, a default-constructed allocator is used. </p>

</div>
</div>
<a class="anchor" id="gab8c02d34d1080d71da8c60c7c6e2d1be"></a><!-- doxytag: member="bsl::deque::deque" ref="gab8c02d34d1080d71da8c60c7c6e2d1be" args="(size_type numElements, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::deque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a deque of the specified <code>numElements</code> length whose every element is default-constructed. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, a default-constructed allocator is used. Throw <code>bsl::length_error</code> if <code>numElements &gt; max_size()</code>. </p>

</div>
</div>
<a class="anchor" id="gac04cb258ca295ab1825f99c81da519f1"></a><!-- doxytag: member="bsl::deque::deque" ref="gac04cb258ca295ab1825f99c81da519f1" args="(size_type numElements, const VALUE_TYPE &amp;value, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::deque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a deque of the specified <code>numElements</code> length whose every element equals the specified <code>value</code>. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, a default-constructed allocator is used. Throw <code>bsl::length_error</code> if <code>numElements &gt; max_size()</code>. </p>

</div>
</div>
<a class="anchor" id="ga9a0e189cf4d53e2dc66ba52137db3d4d"></a><!-- doxytag: member="bsl::deque::deque" ref="ga9a0e189cf4d53e2dc66ba52137db3d4d" args="(INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::deque </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a deque initially containing copies of the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, a default-constructed allocator is used. Throw <code>bsl::length_error</code> if the number of elements in <code>[ first, last )</code> exceeds the size returned by <code>max_size</code>. </p>

</div>
</div>
<a class="anchor" id="ga2457713c3d76757e9365348e9b5518d8"></a><!-- doxytag: member="bsl::deque::deque" ref="ga2457713c3d76757e9365348e9b5518d8" args="(const deque &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::deque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga06bad4260ece6537b62cc067dc9549c3"></a><!-- doxytag: member="bsl::deque::deque" ref="ga06bad4260ece6537b62cc067dc9549c3" args="(const deque &amp;original, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::deque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a deque that has the same value as the specified <code>original</code> deque. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, then if <code>ALLOCATOR</code> is convertible from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>, the currently installed default allocator is used, otherwise the <code>original</code> allocator is used (as mandated per the ISO standard). </p>

</div>
</div>
<a class="anchor" id="gab22a189b19cecc1625b7783192af8d76"></a><!-- doxytag: member="bsl::deque::~deque" ref="gab22a189b19cecc1625b7783192af8d76" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::~deque </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this deque object. </p>

</div>
</div>
<a class="anchor" id="gad789196795dddda6d15176c905ad8793"></a><!-- doxytag: member="bsl::deque::operator=" ref="gad789196795dddda6d15176c905ad8793" args="(const deque &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">deque&amp; <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this deque the value of the specified <code>rhs</code> deque. </p>

</div>
</div>
<a class="anchor" id="ga1bbb5dd6bd46cc1c60b01358aea51872"></a><!-- doxytag: member="bsl::deque::assign" ref="ga1bbb5dd6bd46cc1c60b01358aea51872" args="(INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this deque the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. </p>

</div>
</div>
<a class="anchor" id="ga295f47875987fd8930201a4554442c39"></a><!-- doxytag: member="bsl::deque::assign" ref="ga295f47875987fd8930201a4554442c39" args="(size_type numElements, const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this deque the value of the string of the specified <code>numElements</code> length whose every elements equal the specified <code>value</code>. Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. </p>

</div>
</div>
<a class="anchor" id="gad3396d1bf4b1bdf01ee7648b9b0a5ac5"></a><!-- doxytag: member="bsl::deque::reserve" ref="gad3396d1bf4b1bdf01ee7648b9b0a5ac5" args="(size_type numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the capacity of this deque such that existing iterators remain valid, provided that no more than the specified <code>numElements</code> objects are pushed to the front or back of the deque after this call. If <code>numElements &lt; capacity()</code>, this method has no effect. Note that inserting to the deque may still incur memory allocations. Also note that this method is not part of the C++ standard. </p>

</div>
</div>
<a class="anchor" id="gaf494586a13b90a8f56ab04aafae10efe"></a><!-- doxytag: member="bsl::deque::resize" ref="gaf494586a13b90a8f56ab04aafae10efe" args="(size_type newLength)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2a194837fcdf9bca06467069973d2d7f"></a><!-- doxytag: member="bsl::deque::resize" ref="ga2a194837fcdf9bca06467069973d2d7f" args="(size_type newLength, VALUE_TYPE value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VALUE_TYPE&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the length of this deque to the specified <code>newLength</code>, erasing characters at the end if <code>newLength &lt; size()</code> or appending the appropriate number of copies of the optionally specified <code>value</code> at the end if <code>length() &lt; newLength</code>. If <code>value</code> is not specified, a default-constructed <code>VALUE_TYPE</code> value is used. Throw <code>bsl::length_error</code> if <code>newLength &gt; max_size()</code>. </p>

</div>
</div>
<a class="anchor" id="gaea8c2a375d44d4848f01a7a54fe727c5"></a><!-- doxytag: member="bsl::deque::push_front" ref="gaea8c2a375d44d4848f01a7a54fe727c5" args="(const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a copy of the specified <code>value</code> at the end of this deque. If <code>value</code> has move semantics, then its value is valid but unspecified upon returning from this function. Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. </p>

</div>
</div>
<a class="anchor" id="ga5be1a8bbb0476e82b273c473539ab754"></a><!-- doxytag: member="bsl::deque::push_back" ref="ga5be1a8bbb0476e82b273c473539ab754" args="(const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepend a copy of the specified <code>value</code> before the beginning of this deque. If <code>value</code> has move semantics, then its value is valid but unspecified upon returning from this function. Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. </p>

</div>
</div>
<a class="anchor" id="ga4768eb160c95f6199e95c89946189c14"></a><!-- doxytag: member="bsl::deque::pop_front" ref="ga4768eb160c95f6199e95c89946189c14" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase the first element from this deque. The behavior is undefined if this deque is empty. </p>

</div>
</div>
<a class="anchor" id="ga45f80b9ac8c77bde1fd065e6f0031c23"></a><!-- doxytag: member="bsl::deque::pop_back" ref="ga45f80b9ac8c77bde1fd065e6f0031c23" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase the last element from this deque. The behavior is undefined if this deque is empty. </p>

</div>
</div>
<a class="anchor" id="ga87880ccf14caac0c41c75e328000ce9b"></a><!-- doxytag: member="bsl::deque::insert" ref="ga87880ccf14caac0c41c75e328000ce9b" args="(const_iterator position, const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#ga08dedf343d7a033d0bafe503f5e2b178">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this deque a copy of the specified <code>value</code>, and return an iterator pointing to the newly inserted element. If <code>value</code> has move semantics, then its value is valid but unspecified upon returning from this function. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code>. Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. </p>

</div>
</div>
<a class="anchor" id="ga277926e4ec0b2abbadf2cb4f72a4e77b"></a><!-- doxytag: member="bsl::deque::insert" ref="ga277926e4ec0b2abbadf2cb4f72a4e77b" args="(const_iterator position, size_type numElements, const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#ga08dedf343d7a033d0bafe503f5e2b178">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#gaef5936f7e31c8079dac4234b36958791">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this deque the specified <code>numElements</code> copies of the specified <code>value</code>. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code>. Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. </p>

</div>
</div>
<a class="anchor" id="gaff1fd52960f5bae4fc47e971281636eb"></a><!-- doxytag: member="bsl::deque::insert" ref="gaff1fd52960f5bae4fc47e971281636eb" args="(const_iterator position, INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#ga08dedf343d7a033d0bafe503f5e2b178">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this deque the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code>. Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. </p>

</div>
</div>
<a class="anchor" id="gae2f368e995db63f45cb29017a4548d85"></a><!-- doxytag: member="bsl::deque::erase" ref="gae2f368e995db63f45cb29017a4548d85" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#ga08dedf343d7a033d0bafe503f5e2b178">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this deque the element at the specified <code>position</code>, and return an iterator pointing to the element immediately following the removed element, or the position returned by the method <code>end</code> if the removed element was the last in the sequence. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() )</code>. </p>

</div>
</div>
<a class="anchor" id="ga8f6b69203e8c8eed2003b193f14ac654"></a><!-- doxytag: member="bsl::deque::erase" ref="ga8f6b69203e8c8eed2003b193f14ac654" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#ga08dedf343d7a033d0bafe503f5e2b178">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__deque.html#ga08dedf343d7a033d0bafe503f5e2b178">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this deque the sequence of elements starting at the specified <code>first</code> position and ending before the specified <code>last</code> position, and return an iterator pointing to the element immediately following the last removed element, or the position returned by the method <code>end</code> if the removed elements were last in the sequence. The behavior is undefined unless <code>first</code> is an iterator in the range <code>[ begin(), end() ]</code> and <code>last</code> is an iterator in the range <code>[ first, end() ]</code>. </p>

</div>
</div>
<a class="anchor" id="ga317cdb1d11333d475f04f7b3e7b7ce53"></a><!-- doxytag: member="bsl::deque::swap" ref="ga317cdb1d11333d475f04f7b3e7b7ce53" args="(deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this deque with that of the specified <code>rhs</code> deque, such that each deque has upon return the value of the other deque prior to this call. Note that this method does not throw or invalidate iterators if the method <code>get_allocator</code> invoked on this object and <code>rhs</code> returns the same value. </p>

</div>
</div>
<a class="anchor" id="gab43b14a18b1cbd7e78206f489290a729"></a><!-- doxytag: member="bsl::deque::clear" ref="gab43b14a18b1cbd7e78206f489290a729" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the elements from this deque. Note that this deque is empty after this call, but conserves the same capacity. </p>

</div>
</div>
<a class="anchor" id="ga049190f2cbfd3c4df1760ebaee35cd9b"></a><!-- doxytag: member="bsl::deque::get_allocator" ref="ga049190f2cbfd3c4df1760ebaee35cd9b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the allocator used by this deque to supply memory. </p>

</div>
</div>
<a class="anchor" id="gadd9dc8f3518d0b5382b4c0449c8ce5a7"></a><!-- doxytag: member="bsl::deque::max_size" ref="gadd9dc8f3518d0b5382b4c0449c8ce5a7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum possible length of this deque. This is largely a theoretical maximum (such as the maximum size that can be held by <code>size_type</code>). Note that requests to create a deque longer than this number of elements are guaranteed to raise a <code>bsl::length_error</code> exception. </p>

</div>
</div>
<a class="anchor" id="gae932279610e8893d59e68df4f6968c64"></a><!-- doxytag: member="bsl::operator==" ref="gae932279610e8893d59e68df4f6968c64" args="(const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> deque has the same value as the specified <code>rhs</code> deque. Two deques have the same value if they have the same number of elements and the same element value at each index position in the range 0 to <code>size() - 1</code>. This operator may only be used when the class <code>VALUE_TYPE</code> defines the operator: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> VALUE_TYPE&amp; lhs, <span class="keyword">const</span> VALUE_TYPE&amp; rhs);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga323083767092dbeb43ec96ea2eeb44c7"></a><!-- doxytag: member="bsl::operator!=" ref="ga323083767092dbeb43ec96ea2eeb44c7" args="(const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> deque does not have the same value as the specified <code>rhs</code> deque. Two deques do not have the same value if they have different numbers of elements or different element values in at least one index position in the range 0 to <code>size() - 1</code>. This operator may only be used when the class <code>VALUE_TYPE</code> defines the operator: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> VALUE_TYPE&amp; lhs, <span class="keyword">const</span> VALUE_TYPE&amp; rhs);
</pre></div><p><br/>
<br/>
 Note that this operator returns <code>!(lhs == rhs)</code>. </p>

</div>
</div>
<a class="anchor" id="ga34cf92fee7de6f434633ee726b63fb38"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga34cf92fee7de6f434633ee726b63fb38" args="(const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> deque is lexicographically smaller than the specified <code>rhs</code> deque, and <code>false</code> otherwise. A deque <code>lhs</code> is lexicographically smaller than another deque <code>rhs</code> if there exists an index <code>i</code> between 0 and the minimum of <code>lhs.size()</code> and <code>rhs.size()</code> such that <code>lhs[i] == rhs[j]</code> for every <code>0 &lt;= j &lt; i</code>, <code>i &lt; rhs.size()</code>, and either <code>i == lhs.size()</code> or <code>lhs[i] &lt; rhs[i]</code>. This operator may only be used when the class <code>VALUE_TYPE</code> defines the operator: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">operator&lt;</a>(<span class="keyword">const</span> VALUE_TYPE&amp; lhs, <span class="keyword">const</span> VALUE_TYPE&amp; rhs);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga8f2ff3ac7d315597e6bf4cf3f1376e51"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga8f2ff3ac7d315597e6bf4cf3f1376e51" args="(const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> deque is lexicographically larger than the specified <code>rhs</code> deque, and <code>false</code> otherwise. This operator may only be used when the class <code>VALUE_TYPE</code> defines the operator: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">operator&lt;</a>(<span class="keyword">const</span> VALUE_TYPE&amp; lhs, <span class="keyword">const</span> VALUE_TYPE&amp; rhs);
</pre></div><p><br/>
<br/>
 Note that this operator returns <code>rhs &lt; lhs</code>. </p>

</div>
</div>
<a class="anchor" id="gacab21200cbc635611051996fa4ce0c71"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gacab21200cbc635611051996fa4ce0c71" args="(const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> deque is lexicographically larger than or equal to the specified <code>rhs</code> deque, and <code>false</code> otherwise. This operator may only be used when the class <code>VALUE_TYPE</code> defines the operator: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">operator&lt;</a>(<span class="keyword">const</span> VALUE_TYPE&amp; lhs, <span class="keyword">const</span> VALUE_TYPE&amp; rhs);
</pre></div><p><br/>
<br/>
 Note that this operator returns <code>!(rhs &lt; lhs)</code>. </p>

</div>
</div>
<a class="anchor" id="ga6c3069d504792f532e25e1d7f1456a15"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga6c3069d504792f532e25e1d7f1456a15" args="(const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> deque is lexicographically larger than the specified <code>rhs</code> deque, and <code>false</code> otherwise. This operator may only be used when the class <code>VALUE_TYPE</code> defines the operator: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">operator&lt;</a>(<span class="keyword">const</span> VALUE_TYPE&amp; lhs, <span class="keyword">const</span> VALUE_TYPE&amp; rhs);
</pre></div><p><br/>
<br/>
 Note that this operator returns <code>!(lhs &lt; rhs)</code>. </p>

</div>
</div>
<a class="anchor" id="ga4ffc73dd2ce1f86230d22d2284773f1d"></a><!-- doxytag: member="bsl::swap" ref="ga4ffc73dd2ce1f86230d22d2284773f1d" args="(deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">deque&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of the specified <code>lhs</code> and <code>rhs</code> deque, such that each deque has upon return the value of the other deque prior to this call. Note that this method does not throw or invalidate iterators if <code>lhs.get_allocator()</code> and <code>rhs.get_allocator()</code> have the same value. </p>

</div>
</div>
<a class="anchor" id="ga026f4dae8ff11b0dfeda04dd69c9117c"></a><!-- doxytag: member="bsl::Deque_BlockCreator::Deque_BlockCreator" ref="ga026f4dae8ff11b0dfeda04dd69c9117c" args="(deque&lt; VALUE_TYPE, ALLOCATOR &gt; *deque_p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Deque__BlockCreator.html">bsl::Deque_BlockCreator</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Deque_BlockCreator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; *&nbsp;</td>
          <td class="paramname"> <em>deque_p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a block allocator for the specified <code>deque_p</code>. </p>

</div>
</div>
<a class="anchor" id="ga910ab7862e3870737e0bf0dc3734bc13"></a><!-- doxytag: member="bsl::Deque_BlockCreator::~Deque_BlockCreator" ref="ga910ab7862e3870737e0bf0dc3734bc13" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Deque__BlockCreator.html">bsl::Deque_BlockCreator</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::~Deque_BlockCreator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free any blocks that have been allocated by this allocator but have not yet been used by the deque. </p>

</div>
</div>
<a class="anchor" id="ga97d6001bceda68dc684f699d5636f3a5"></a><!-- doxytag: member="bsl::Deque_BlockCreator::insertAtFront" ref="ga97d6001bceda68dc684f699d5636f3a5" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Deque__BlockCreator.html">bsl::Deque_BlockCreator</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::insertAtFront </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate the specified <code>n</code> blocks at the front of the block array. Note that this method invalidates all iterators except <code>d_deque_p-&gt;d_start</code> and <code>d_deque_p-&gt;d_finish</code>. </p>

</div>
</div>
<a class="anchor" id="gacb9c38837de5ddc90b73d099047b181b"></a><!-- doxytag: member="bsl::Deque_BlockCreator::insertAtBack" ref="gacb9c38837de5ddc90b73d099047b181b" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Deque__BlockCreator.html">bsl::Deque_BlockCreator</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::insertAtBack </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate the specified <code>n</code> blocks at the back of the block array. Note that this method invalidates all iterators except <code>d_deque_p-&gt;d_start</code> and <code>d_deque_p-&gt;d_finish</code>. </p>

</div>
</div>
<a class="anchor" id="gaea05edb5c3b3fe1357d443d629fa3a0d"></a><!-- doxytag: member="bsl::Deque_BlockCreator::reserveBlockSlots" ref="gaea05edb5c3b3fe1357d443d629fa3a0d" args="(size_type numNewBlocks, bool atFront)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BlockPtr* <a class="el" href="classbsl_1_1Deque__BlockCreator.html">bsl::Deque_BlockCreator</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::reserveBlockSlots </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>numNewBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>atFront</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make room for the specified <code>numNewBlocks</code> pointers in the blocks array. If the specified <code>atFront</code> is true, then make room at the front of the array, else make room at the end of the array. Return a pointer to the insertion point, i.e., the point where new blocks can be stored into the array, working backwards if <code>atFront</code> is true, or working forwards if <code>atFront</code> is false. Note that this method invalidates all iterators except <code>d_deque_p-&gt;d_start</code> and <code>d_deque_p-&gt;d_finish</code>. </p>

</div>
</div>
<a class="anchor" id="ga5d5cac7d3ca03e6efacc4e9d8e317539"></a><!-- doxytag: member="bsl::Deque_BlockCreator::release" ref="ga5d5cac7d3ca03e6efacc4e9d8e317539" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Deque__BlockCreator.html">bsl::Deque_BlockCreator</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Relinquish control over any allocated blocks. The destructor will do nothing. </p>

</div>
</div>
<a class="anchor" id="gab0e1f1423f94ff6aa450b7a8c3aea503"></a><!-- doxytag: member="bsl::Deque_ClearGuard::Deque_ClearGuard" ref="gab0e1f1423f94ff6aa450b7a8c3aea503" args="(deque&lt; VALUE_TYPE, ALLOCATOR &gt; *deque_p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Deque__ClearGuard.html">bsl::Deque_ClearGuard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Deque_ClearGuard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; *&nbsp;</td>
          <td class="paramname"> <em>deque_p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes object to guard zero items from the specified <code>deque_p</code>. </p>

</div>
</div>
<a class="anchor" id="ga52e7f909d1bab6b6e6de4f1e2a069acd"></a><!-- doxytag: member="bsl::Deque_ClearGuard::~Deque_ClearGuard" ref="ga52e7f909d1bab6b6e6de4f1e2a069acd" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Deque__ClearGuard.html">bsl::Deque_ClearGuard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::~Deque_ClearGuard </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call the method <code>clear</code> on the deque supplied at construction, unless the method <code>release</code> has been called before. </p>

</div>
</div>
<a class="anchor" id="ga68a7d6c6a097798fd87c2bd8a5a6d1b7"></a><!-- doxytag: member="bsl::Deque_ClearGuard::release" ref="ga68a7d6c6a097798fd87c2bd8a5a6d1b7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Deque__ClearGuard.html">bsl::Deque_ClearGuard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the deque protected by this guard from further management. Note that this guard destructor will do nothing afterwards. </p>

</div>
</div>
<a class="anchor" id="gabe488d8e371469367d36891f3fc4850b"></a><!-- doxytag: member="bsl::Deque_Guard::Deque_Guard" ref="gabe488d8e371469367d36891f3fc4850b" args="(deque&lt; VALUE_TYPE, ALLOCATOR &gt; *deque_p, bool isTail)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Deque_Guard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; *&nbsp;</td>
          <td class="paramname"> <em>deque_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isTail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes object to guard zero items from the specified <code>deque_p</code>. This guards either the tail or the head, as determined by the specified <code>isTail</code> boolean. </p>

</div>
</div>
<a class="anchor" id="gad0e48efe2bac3632ff953e2962ce8836"></a><!-- doxytag: member="bsl::Deque_Guard::~Deque_Guard" ref="gad0e48efe2bac3632ff953e2962ce8836" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::~Deque_Guard </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call the parameterized <code>VALUE_TYPE</code> destructor on objects in the range <code>[d.end(), d.end() + count())</code> if <code>isTail</code> was specified as <code>true</code> during construction, or <code>[d.start() - count(), d.start()]</code> if <code>isTail</code> was specified as <code>false</code> during construction, where <code>d</code> is the deque used to construct this guard. </p>

</div>
</div>
<a class="anchor" id="gafbcce8b09c6191d1a5180370794043d0"></a><!-- doxytag: member="bsl::Deque_Guard::operator++" ref="gafbcce8b09c6191d1a5180370794043d0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the count of this guard, and return new count. </p>

</div>
</div>
<a class="anchor" id="gae5f621c85d12230bdab4397fa4478c3c"></a><!-- doxytag: member="bsl::Deque_Guard::operator&#45;&#45;" ref="gae5f621c85d12230bdab4397fa4478c3c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrement the count of this guard, and return new count. </p>

</div>
</div>
<a class="anchor" id="ga8190b472ed0485d88be4c65de356e9b4"></a><!-- doxytag: member="bsl::Deque_Guard::release" ref="ga8190b472ed0485d88be4c65de356e9b4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the count of this tail guard to zero. Note that this guard destructor will do nothing if count is not incremented again after this call. </p>

</div>
</div>
<a class="anchor" id="ga90a77f046090a502fdd5a7b83a5d4fa1"></a><!-- doxytag: member="bsl::Deque_Guard::count" ref="ga90a77f046090a502fdd5a7b83a5d4fa1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current tail count. </p>

</div>
</div>
<a class="anchor" id="ga4a24ba75626617d9d6eaa327c206a67c"></a><!-- doxytag: member="bsl::Deque_Guard::begin" ref="ga4a24ba75626617d9d6eaa327c206a67c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IteratorImp <a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer after the item the first item in the guarded range. </p>

</div>
</div>
<a class="anchor" id="gaba7de8e16eab60ff416b6f36f4696dcf"></a><!-- doxytag: member="bsl::Deque_Guard::end" ref="gaba7de8e16eab60ff416b6f36f4696dcf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IteratorImp <a class="el" href="classbsl_1_1Deque__Guard.html">bsl::Deque_Guard</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer after the item the last item in the guarded range. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga9576de86cb80f207d2681244f8cd820d"></a><!-- doxytag: member="bsl::Deque_Base::d_blocks" ref="ga9576de86cb80f207d2681244f8cd820d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BlockPtr* <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::d_blocks<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>array of pointer to blocks (owned) </p>

</div>
</div>
<a class="anchor" id="ga6a9830701bc1e6442dba82e884c005a0"></a><!-- doxytag: member="bsl::Deque_Base::d_blocksLength" ref="ga6a9830701bc1e6442dba82e884c005a0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::d_blocksLength<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>length of d_blocks array </p>

</div>
</div>
<a class="anchor" id="gafca73e1e31f31edcc9e2af9527db4bfa"></a><!-- doxytag: member="bsl::Deque_Base::d_start" ref="gafca73e1e31f31edcc9e2af9527db4bfa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IteratorImp <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::d_start<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>iterator to first element </p>

</div>
</div>
<a class="anchor" id="ga0ffdc5bf3423e893966faf49a1fefc02"></a><!-- doxytag: member="bsl::Deque_Base::d_finish" ref="ga0ffdc5bf3423e893966faf49a1fefc02" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IteratorImp <a class="el" href="classbsl_1_1Deque__Base.html">bsl::Deque_Base</a>&lt; VALUE_TYPE &gt;::d_finish<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>iterator to one past last element </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="gae47866dd8a0cb6e661157d1d321921df"></a><!-- doxytag: member="bsl::deque::Deque_BlockCreator" ref="gae47866dd8a0cb6e661157d1d321921df" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class Deque_BlockCreator<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad5d657184b6a85ebf1ffe7d6cd255438"></a><!-- doxytag: member="bsl::deque::Deque_Guard" ref="gad5d657184b6a85ebf1ffe7d6cd255438" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class Deque_Guard<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:22 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
