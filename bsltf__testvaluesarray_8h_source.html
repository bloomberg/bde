<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bsltf_testvaluesarray.h                                            -*-C++-*-
#ifndef INCLUDED_BSLTF_TESTVALUESARRAY
#define INCLUDED_BSLTF_TESTVALUESARRAY

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a container for values used for testing.
//
//@CLASSES:
//           bsltf::TestValuesArray: container for values used for testing.
//   bsltf::TestValuesArrayIterator: iterators for the container
//
//@SEE_ALSO: bsltf_testfacility
//
//@DESCRIPTION: This component defines a class &#39;TestValuesArray&#39; providing a
// a uniform interface for creating and accessing a sequence of test values of
// type that has a copy constructor, and may or may not have a default
// constructor.
//
// This component also defines an iterator class &#39;TestValuesArrayIterator&#39;
// providing access to elements in a &#39;TestValuesArray&#39; object.
// &#39;TestValuesArrayIterator&#39; is designed to satisfies the minimal requirement
// of an input iterator as defined by the C++11 standard [24.2.3].  It uses the
// &#39;BSLS_ASSERT&#39; macro to detect undefined behavior.
//
// The sequence described by this container is an input-range, that may be
// traversed exactly once.  Once an iterator increments, any other iterator
// at the same point in the sequence is invalidated.  The &#39;TestValuesArray&#39;
// object provides a &#39;resetIterators&#39; method that invalidates all existing
// iterators, and allows a new traversal of the sequence to start.
//
///Iterator
///--------
// The requirements of the input iterators as defined by the C++11 standard may
// not be as tight as the users of the input iterators expected.  Incorrect
// assumptions about the properties of the input iterator may result in
// undefined behavior.  &#39;TestValuesArrayIterator&#39; is designed to detect
// possible incorrect usages.  Specifically, &#39;TestValuesArrayIterator&#39; put
// restriction on when it can be dereferenced or compared.  A
// &#39;TestValuesArrayIterator&#39; is considered to be *dereferenceable* if it
// satisfies all of the following:
//
//: 1 The iterator refers to a valid element (not &#39;end&#39;).
//:
//: 2 The iterator has not been dereferenced.  (*)
//:
//: 3 The iterator is not a copy of another iterator of which &#39;operator++&#39;
//:   have been invoked.  (see [table 107] of the C++11 standard)
//
// *note: An input iterator may not be dereferenced more than once is a common
// requirement of a container method that takes input iterators as arguments.
// Other standard algorithms may allow the iterator to be dereferenced more
// than once, in which case, &#39;TestValuesArrayIterator&#39; is not suitable to be
// used to with those algorithms.
//
// &#39;TestValuesArrayIterator&#39; is comparable if the iterator is not a copy of
// another iterator of which &#39;operator++&#39; have been invoked.
//
///Thread-Safety
///-------------
// This component is *not* thread-safe, by any definition of the term, and
// should not be used in test scenarios concerned with concurrent code.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Testing a Simple Template Function
///- - - - - - - - - - - - - - - - - - - - - - -
// Suppose that we have a function that we would like to test.  This function
// take in a range defined by two input iterators and returns the largest value
// in that range.
//
// First, we define the function we would like to test:
//..
//  template &lt;class VALUE, class INPUT_ITERATOR&gt;
//  VALUE myMaxValue(INPUT_ITERATOR first, INPUT_ITERATOR last)
//      // Return the largest value referred to by the iterators in the range
//      // beginning at the specified &#39;first&#39; and up to, but not including, the
//      // specified &#39;last&#39;.  The behavior is undefined unless [first, last)
//      // specifies a valid range and &#39;first != last&#39;.
//  {
//      assert(first != last);
//
//      VALUE largestValue(*first);
//      ++first;
//      for(;first != last; ++first) {
//          // Store in temporary variable to avoid dereferencing twice.
//
//          const VALUE&amp; temp = *first;
//          if (largestValue &lt; temp) {
//              largestValue = temp;
//          }
//      }
//      return largestValue;
//  }
//..
// Next, we implement a test function &#39;runTest&#39; that allows the function to be
// tested with different types:
//..
//  template &lt;class VALUE&gt;
//  void runTest()
//  {
//..
//  Then, we define a set of test values and expected results:
//..
//      struct {
//          const char *d_spec;
//          const char  d_result;
//      } DATA[] = {
//          { &quot;A&quot;,     &#39;A&#39; },
//          { &quot;ABC&quot;,   &#39;C&#39; },
//          { &quot;ADCB&quot;,  &#39;D&#39; },
//          { &quot;EDCBA&quot;, &#39;E&#39; }
//      };
//      const int NUM_DATA = sizeof DATA / sizeof *DATA;
//..
//  Now, for each set of test values, verify that the function return the
//  expected result.
//..
//      for (int i = 0; i &lt; NUM_DATA; ++i) {
//          const char *const SPEC = DATA[i].d_spec;
//          const VALUE       EXP  =
//                bsltf::TemplateTestFacility::create&lt;VALUE&gt;(DATA[i].d_result);
//
//          bsltf::TestValuesArray&lt;VALUE&gt; values(SPEC);
//          assert(EXP == myMaxValue&lt;VALUE&gt;(values.begin(), values.end()));
//      }
//  }
//..
// Finally, we invoke the test function to verify our function is implemented
// correctly.  The test function to run without triggering the &#39;assert&#39;
// statement:
//..
//  runTest&lt;char&gt;();
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLTF_TEMPLATETESTFACILITY
#include &lt;bsltf_templatetestfacility.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MALLOCFREEALLOCATOR
#include &lt;bslma_mallocfreeallocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_ITERATOR
#include &lt;iterator&gt;
#define INCLUDED_ITERATOR
#endif

#ifndef INCLUDED_STDDEF_H
#include &lt;stddef.h&gt;
#define INCLUDED_STDDEF_H
#endif

#ifndef INCLUDED_STRING_H
#include &lt;string.h&gt;
#define INCLUDED_STRING_H
#endif

namespace BloombergLP
{

namespace bsltf
{

template &lt;class VALUE&gt;
struct TestValuesArray_DefaultConverter;

template &lt;class VALUE&gt;
class TestValuesArray_PostIncrementPtr;

                       // =============================
                       // class TestValuesArrayIterator
                       // =============================

template &lt;class VALUE&gt;
class TestValuesArrayIterator {
    // This class provide a STL-conforming input iterator over values used for
    // testing (see section [24.2.3 input.iterators] of the C++11 standard.  A
    // &#39;TestValuesArrayIterator&#39; provide access to elements of parameterized
    // type &#39;VALUE&#39;.  An iterator is considered dereferenceable all of the
    // following are satisfied:
    //: 1 The iterator refers to a valid element (not &#39;end&#39;).
    //:
    //: 2 The iterator has not been dereferenced.
    //:
    //: 3 The iterator is not a copy of another iterator of which &#39;operator++&#39;
    //:   have been invoked.
    // An iterator is comparable if the iterator is not a copy of another
    // iterator of which &#39;operator++&#39; have been invoked.
    //
    // This class is *not* thread-safe: different iterator objects manipulate
    // shared state without synchronization.  This is rarely a concern for the
    // test scenarios supported by this component.

    // DATA
    const VALUE *d_data_p;              // pointer to array of values (held,
                                        // not owned)

    const VALUE *d_end_p;               // end pointer (held, not owned)

    bool        *d_dereferenceable_p;   // indicate if dereferenceable (held,
                                        // not owned)

    bool        *d_isValid_p;           // indicate not yet invalidated (held,
                                        // not owned)

  private:
    // FRIENDS
    template &lt;class OTHER_VALUE&gt;
    friend bool operator==(const TestValuesArrayIterator&lt;OTHER_VALUE&gt;&amp;,
                           const TestValuesArrayIterator&lt;OTHER_VALUE&gt;&amp;);

    template &lt;class OTHER_VALUE&gt;
    friend bool operator!=(const TestValuesArrayIterator&lt;OTHER_VALUE&gt;&amp;,
                           const TestValuesArrayIterator&lt;OTHER_VALUE&gt;&amp;);

  public:
    // TYPES
    typedef native_std::input_iterator_tag  iterator_category;
    typedef VALUE                           value_type;
    typedef ptrdiff_t                       difference_type;
    typedef const VALUE                    *pointer;
    typedef const VALUE&amp;                    reference;
        // Standard iterator defined types [24.4.2].

  public:
    // CREATORS
    TestValuesArrayIterator(const VALUE *object,
                            const VALUE *end,
                            bool        *dereferenceable,
                            bool        *isValid);
        // Create an iterator referring to the specified &#39;object&#39; for a
        // container with the specified &#39;end&#39;, with two arrays of boolean
        // referred to by the specified &#39;dereferenceable&#39; and &#39;isValid&#39; to
        // indicate whether this iterator and its subsequent values until
        // &#39;end&#39; is allowed to be dereferenced and is not yet invalidated
        // respectively.

    TestValuesArrayIterator(const TestValuesArrayIterator&amp; original);

    // MANIPULATORS
    TestValuesArrayIterator&amp; operator=(const TestValuesArrayIterator&amp; other);

    TestValuesArrayIterator&amp; operator++();
        // Move this iterator to the next element in the container.  Any copies
        // of this iterator are no longer dereferenceable or comparable.  The
        // behavior is undefined unless this iterator refers to a valid value
        // in the container.

    TestValuesArray_PostIncrementPtr&lt;VALUE&gt; operator++(int);
        // Move this iterator to the next element in the container, and return
        // an object that can be dereferenced to refer to the same object that
        // this iterator initially points to.  Any copies
        // of this iterator are no longer dereferenceable or comparable.  The
        // behavior is undefined unless this iterator refers to a valid value
        // in the container.

    // ACCESSORS
    const VALUE&amp; operator *() const;
        // Return the value referred to by this object.  This object is no
        // longer dereferenceable after a call to this function.  The
        // behavior is undefined unless this iterator is dereferenceable.

    const VALUE *operator-&gt;() const;
        // Return the address of the value (of the parameterized &#39;VALUE_TYPE&#39;)
        // of the element at which this iterator is positioned.  The behavior
        // is undefined unless this iterator dereferenceable.
};

template &lt;class VALUE&gt;
bool operator==(const TestValuesArrayIterator&lt;VALUE&gt;&amp; lhs,
                const TestValuesArrayIterator&lt;VALUE&gt;&amp; rhs);
    // Return &#39;true&#39; if this object and &#39;rhs&#39; refers to the same element, and
    // &#39;false&#39; otherwise.  The behavior is undefined unless &#39;lhs&#39; and &#39;rhs&#39; are
    // comparable.

template &lt;class VALUE&gt;
bool operator!=(const TestValuesArrayIterator&lt;VALUE&gt;&amp; lhs,
                const TestValuesArrayIterator&lt;VALUE&gt;&amp; rhs);
    // Return &#39;true&#39; if this object and &#39;rhs&#39; does *not* refers to the same
    // element, and &#39;false&#39; otherwise.  The behavior is undefined unless &#39;lhs&#39;
    // and &#39;rhs&#39; are comparable.

                       // ====================
                       // class TestValueArray
                       // ====================

template &lt;class VALUE,
          class CONVERTER = TestValuesArray_DefaultConverter&lt;VALUE&gt; &gt;
class TestValuesArray {
    // This class provide a container to store values of the parameterized
    // &#39;VALUE&#39;, and also provide the iterators to access the values.  The
    // iterators are designed to conform to a standard input iterator, and will
    // report any misuse of the iterator.

    // DATA
    bslma::Allocator *d_allocator_p;      // allocator (held, not owned)

    VALUE            *d_data;             // pointer to memory storing the
                                          // values (owned)

    size_t            d_size;             // number of elements in this object

    bool             *d_dereferenceable;  // pointer to an array to indicate
                                          // which iterator is dereferenceable
                                          // (owned)

    bool             *d_validIterator;       // pointer to an array to indicate
                                          // which iterator is comparable
                                          // (owned)

  private:
    // NOT IMPLEMENTED
    TestValuesArray(const TestValuesArray&amp;);
    TestValuesArray&amp; operator=(const TestValuesArray&amp;);

  private:
    // PRIVATE MANIPULATOR
    void initialize(const char *spec, bslma::Allocator *basicAllocator);
        // Initialize this object with the specified &#39;spec&#39; using the specified
        // &#39;basicAllocator&#39; to supply memory.

  public:
    typedef TestValuesArrayIterator&lt;VALUE&gt; iterator;
        // Iterator for this container.

  public:
    // CREATORS
    explicit TestValuesArray(bslma::Allocator *basicAllocator = 0);
    explicit TestValuesArray(const char      *spec,
                             bslma::Allocator *basicAllocator = 0);
        // Create a &#39;TestValuesArray&#39; object.  Optionally, specify &#39;spec&#39; to
        // indicate the values this object should contain, where the values are
        // created by invoking the &#39;bsltf::TemplateTestFacility::create&#39; method
        // on each character of &#39;spec&#39;.  If no &#39;spec&#39; is supplied, the object
        // will contain 52 distinct values of type &#39;VALUE&#39;.  Optionally,
        // specify &#39;basicAllocator&#39; to used to supply memory.  If no allocator
        // is supplied, a &#39;bslma::MallocFree&#39; allocator will be used to supply
        // memory.

    ~TestValuesArray();
        // Destroy this object and all contained objects.

    // MANIPULATORS
    iterator begin();
        // Return an iterator to the first element.

    iterator index(size_t value);
        // Return an iterator to the element at the specified &#39;index&#39;.

    iterator end();
        // Return an iterator to the past-the-end element.

    void resetIterators();
        // Make all iterators dereferenceable and comparable again.

    // ACCESSORS
    const VALUE *data() const;
        // Return the address of the first element in this object.

    const VALUE&amp; operator[](size_t index) const;
        // Return a reference providing non-modifiable access to the element at
        // the specified &#39;index&#39;.

    size_t size() const;
        // Return number of elements in this object.
};

                       // ======================================
                       // class TestValuesArray_DefaultConverter
                       // ======================================

template &lt;class VALUE&gt;
struct TestValuesArray_DefaultConverter {
    // CLASS METHODS
    static
    void createInplace(VALUE *objPtr, char value, bslma::Allocator *allocator);
};

                       // ======================================
                       // class TestValuesArray_PostIncrementPtr
                       // ======================================

template &lt;class VALUE&gt;
class TestValuesArray_PostIncrementPtr {
  private:
    // DATA
    const VALUE *d_data_p;

  public:
    // CREATORS
    explicit TestValuesArray_PostIncrementPtr(const VALUE* ptr);

    // ACCESSORS
    const VALUE&amp; operator*() const;
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                       // --------------------------------------
                       // class TestValuesArray_PostIncrementPtr
                       // --------------------------------------

template &lt;class VALUE&gt;
inline
TestValuesArray_PostIncrementPtr&lt;VALUE&gt;::
TestValuesArray_PostIncrementPtr(const VALUE* ptr)
: d_data_p(ptr)
{
    BSLS_ASSERT_OPT(ptr);
}

template &lt;class VALUE&gt;
inline
const VALUE&amp;
TestValuesArray_PostIncrementPtr&lt;VALUE&gt;::operator*() const
{
    return *d_data_p;
}

                       // -----------------------------
                       // class TestValuesArrayIterator
                       // -----------------------------

// CREATORS
template &lt;class VALUE&gt;
inline
TestValuesArrayIterator&lt;VALUE&gt;::TestValuesArrayIterator(
                                                  const VALUE *object,
                                                  const VALUE *end,
                                                  bool        *dereferenceable,
                                                  bool        *isValid)
: d_data_p(object)
, d_end_p(end)
, d_dereferenceable_p(dereferenceable)
, d_isValid_p(isValid)
{
    BSLS_ASSERT_SAFE(object);
    BSLS_ASSERT_SAFE(end);
    BSLS_ASSERT_SAFE(dereferenceable);
    BSLS_ASSERT_SAFE(isValid);
    BSLS_ASSERT_SAFE(*isValid);
}

template &lt;class VALUE&gt;
inline
TestValuesArrayIterator&lt;VALUE&gt;::TestValuesArrayIterator(
                                       const TestValuesArrayIterator&amp; original)
: d_data_p(original.d_data_p)
, d_end_p(original.d_end_p)
, d_dereferenceable_p(original.d_dereferenceable_p)
, d_isValid_p(original.d_isValid_p)
{
    BSLS_ASSERT_OPT(*original.d_isValid_p);
}

// MANIPULATORS
template &lt;class VALUE&gt;
TestValuesArrayIterator&lt;VALUE&gt;&amp;
TestValuesArrayIterator&lt;VALUE&gt;::operator=(const TestValuesArrayIterator&amp; other)
{
    BSLS_ASSERT_OPT(*other.d_isValid_p);

    d_data_p            = other.d_data_p;
    d_end_p             = other.d_end_p;
    d_dereferenceable_p = other.d_dereferenceable_p;
    d_isValid_p         = other.d_isValid_p;

    return *this;
}

template &lt;class VALUE&gt;
TestValuesArrayIterator&lt;VALUE&gt;&amp;
TestValuesArrayIterator&lt;VALUE&gt;::operator++()
{
    BSLS_ASSERT_OPT(d_data_p != d_end_p);
    BSLS_ASSERT_OPT(*d_isValid_p);

    *d_dereferenceable_p = false;
    *d_isValid_p = false;

    ++d_data_p;
    ++d_dereferenceable_p;
    ++d_isValid_p;
    return *this;
}

template &lt;class VALUE&gt;
TestValuesArray_PostIncrementPtr&lt;VALUE&gt;
TestValuesArrayIterator&lt;VALUE&gt;::operator++(int)
{
    BSLS_ASSERT_OPT(*d_isValid_p);
    BSLS_ASSERT_OPT(d_data_p != d_end_p);

    TestValuesArray_PostIncrementPtr&lt;VALUE&gt; result(d_data_p);
    this-&gt;operator++();
    return result;
}

// ACCESSORS
template &lt;class VALUE&gt;
inline
const VALUE&amp; TestValuesArrayIterator&lt;VALUE&gt;::operator *() const
{
    BSLS_ASSERT_OPT(*d_isValid_p);
    BSLS_ASSERT_OPT(*d_dereferenceable_p);

    *d_dereferenceable_p = false;
    return *d_data_p;
}

template &lt;class VALUE&gt;
inline
const VALUE *TestValuesArrayIterator&lt;VALUE&gt;::operator-&gt;() const
{
    BSLS_ASSERT_OPT(*d_isValid_p);
    BSLS_ASSERT_OPT(*d_dereferenceable_p);

    *d_dereferenceable_p = false;
    return d_data_p;
}

}  // close package namespace

// FREE OPERATORS
template &lt;class VALUE&gt;
inline
bool bsltf::operator==(const bsltf::TestValuesArrayIterator&lt;VALUE&gt;&amp; lhs,
                       const bsltf::TestValuesArrayIterator&lt;VALUE&gt;&amp; rhs)
{
    BSLS_ASSERT_OPT(*lhs.d_isValid_p);
    BSLS_ASSERT_OPT(*rhs.d_isValid_p);

    return lhs.d_data_p == rhs.d_data_p;
}

template &lt;class VALUE&gt;
inline
bool bsltf::operator!=(const bsltf::TestValuesArrayIterator&lt;VALUE&gt;&amp; lhs,
                       const bsltf::TestValuesArrayIterator&lt;VALUE&gt;&amp; rhs)
{
    BSLS_ASSERT_OPT(*lhs.d_isValid_p);
    BSLS_ASSERT_OPT(*rhs.d_isValid_p);

    return !(lhs == rhs);
}

namespace bsltf
{

                       // --------------------------------------
                       // class TestValuesArray_DefaultConverter
                       // --------------------------------------

template &lt;class VALUE&gt;
inline
void TestValuesArray_DefaultConverter&lt;VALUE&gt;::createInplace(
                                                   VALUE            *objPtr,
                                                   char              value,
                                                   bslma::Allocator *allocator)
{
    bsltf::TemplateTestFacility::emplace(objPtr, value, allocator);
}

                       // --------------------
                       // class TestValueArray
                       // --------------------

// CREATORS
template &lt;class VALUE, class CONVERTER&gt;
TestValuesArray&lt;VALUE, CONVERTER&gt;::TestValuesArray(
                                              bslma::Allocator *basicAllocator)
{
    static const char DEFAULT_SPEC[] =
                        &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;

    initialize(DEFAULT_SPEC, basicAllocator);
}

template &lt;class VALUE, class CONVERTER&gt;
inline
TestValuesArray&lt;VALUE, CONVERTER&gt;::TestValuesArray(
                                              const char       *spec,
                                              bslma::Allocator *basicAllocator)
{
    initialize(spec, basicAllocator);
}

template &lt;class VALUE, class CONVERTER&gt;
TestValuesArray&lt;VALUE, CONVERTER&gt;::~TestValuesArray()
{
    // Optimization - we should run the loop only if the VALUE type has a
    // non-trivial destructor.  Surely we have code for this in &#39;bslalg&#39;?

    for (size_t i = 0; i &lt; d_size; ++i) {
        d_data[i].~VALUE();
    }
    d_allocator_p-&gt;deallocate(d_data);
}

// PRIVATE MANIPULATORS
template &lt;class VALUE, class CONVERTER&gt;
void TestValuesArray&lt;VALUE, CONVERTER&gt;::initialize(
                                              const char       *spec,
                                              bslma::Allocator *basicAllocator)
{
    BSLS_ASSERT_OPT(spec);

    d_size = strlen(spec);

    d_allocator_p = basicAllocator
                  ? basicAllocator
                  : &amp;bslma::MallocFreeAllocator::singleton();

    // Allocate all memory in one go.

    d_data = reinterpret_cast&lt;VALUE *&gt;(d_allocator_p-&gt;allocate(
                    d_size * sizeof(VALUE) + 2 * (d_size + 1) * sizeof(bool)));

    d_dereferenceable = reinterpret_cast&lt;bool *&gt;(d_data + d_size);
    d_validIterator = d_dereferenceable + d_size + 1;

    for (int i = 0; &#39;\0&#39; != spec[i]; ++i) {
        CONVERTER::createInplace(d_data + i, spec[i], d_allocator_p);
    }

    memset(d_dereferenceable, true, d_size * sizeof(bool));
    d_dereferenceable[d_size] = false;  // &#39;end&#39; is never dereferenceable
    memset(d_validIterator, true, (d_size + 1) * sizeof(bool));
}

// MANIPULATORS
template &lt;class VALUE, class CONVERTER&gt;
inline
typename TestValuesArray&lt;VALUE, CONVERTER&gt;::iterator
TestValuesArray&lt;VALUE, CONVERTER&gt;::begin()
{
    return iterator(data(),
                    data() + d_size,
                    d_dereferenceable,
                    d_validIterator);
}

template &lt;class VALUE, class CONVERTER&gt;
inline
typename TestValuesArray&lt;VALUE, CONVERTER&gt;::iterator
TestValuesArray&lt;VALUE, CONVERTER&gt;::index(size_t value)
{
    BSLS_ASSERT_OPT(value &lt;= size());

    return iterator(data() + value,
                    data() + d_size,
                    d_dereferenceable + value,
                    d_validIterator + value);
}

template &lt;class VALUE, class CONVERTER&gt;
inline
typename TestValuesArray&lt;VALUE, CONVERTER&gt;::iterator
TestValuesArray&lt;VALUE, CONVERTER&gt;::end()
{
    return iterator(data() + d_size,
                    data() + d_size,
                    d_dereferenceable + d_size,
                    d_validIterator + d_size);
}

template &lt;class VALUE, class CONVERTER&gt;
void TestValuesArray&lt;VALUE, CONVERTER&gt;::resetIterators()
{
    memset(d_dereferenceable, 1, d_size * sizeof(bool));
    d_dereferenceable[d_size] = false;
    memset(d_validIterator, 1, (d_size + 1) * sizeof(bool));
}

// ACCESSORS
template &lt;class VALUE, class CONVERTER&gt;
inline
const VALUE *TestValuesArray&lt;VALUE, CONVERTER&gt;::data() const
{
    return d_data;
}

template &lt;class VALUE, class CONVERTER&gt;
inline
const VALUE&amp; TestValuesArray&lt;VALUE, CONVERTER&gt;::operator[](size_t index) const
{
    return data()[index];
}

template &lt;class VALUE, class CONVERTER&gt;
inline
size_t TestValuesArray&lt;VALUE, CONVERTER&gt;::size() const
{
    return d_size;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
