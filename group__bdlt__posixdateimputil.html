<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlt_posixdateimputil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlt_posixdateimputil<br/>
<small>
[<a class="el" href="group__bdlt.html">Package bdlt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide low-level support functions for date-value manipulation.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html">bdlt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Representations, Valid Dates, and Leap Years</a> </li>
<li>
<a href="#3.2">Caching</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Creating a General Purpose Utility</a> </li>
<li>
<a href="#3.3.2">Implementing a Value-Semantic Date Type</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide low-level support functions for date-value manipulation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlt_1_1PosixDateImpUtil.html">bdlt::PosixDateImpUtil</a> </td><td>suite of low-level date-related stateless functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a utility class, <code><a class="el" href="structbdlt_1_1PosixDateImpUtil.html">bdlt::PosixDateImpUtil</a></code>, that provides a suite of low-level, date-related functions that can be used to validate, manipulate, and convert among values in three different formats: <br/>
<br/>
<div class="fragment"><pre class="fragment">  YMD: year/month/day
   YD: year/dayOfYear
    S: serialDate
</pre></div><br/>
<br/>
 The supplied functionality can also be used for determining leap years, finding the last day in a month, and for determining the day of the week for a given date. Note that in this component, a "date" is understood to represent a valid day in the range <code>0001JAN01</code> to <code>9999DEC31</code>, according to the standard UNIX date implementation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="representations,_valid_dates,_and_leap_years"></a> <a class="anchor" id="description.representations,_valid_dates,_and_leap_years"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Representations, Valid Dates, and Leap Years: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "Calendar Date", or "year-month-day (ymd)", is the primary representation and is denoted as "yyyy/mm/dd", with valid years being in the range <code>[ 1 .. 9999 ]</code>. Within a valid year, valid months and valid days are confined to the respective ranges <code>[ 1 .. 12 ]</code> and <code>[ 1 .. 31 ]</code>. Valid dates in this representation will range from <code>0001/01/01</code> to <code>9999/12/31</code>, but are also governed by the standard UNIX (Gregorian) calendar convention. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "Day-Of-Year Date", or "year-day (yd)" representation, denoted by "yyyy/ddd", represents dates by their year, again in the range <code>[ 1 .. 9999 ]</code>, and the day of year, in the range <code>[ 1 .. 366 ]</code>. Note that valid date values in this representation range from <code>0001/01</code> to <code>9999/365</code>, with a day-of-year value of 366 permitted for leap years only. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "Serial Date" representation depicts dates as consecutive integers, beginning with 1 (representing <code>0001JAN01</code>). In this representation, valid date value are in the range <code>[ 1 .. 3652061 ]</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In a leap year, February has 29 days instead of the usual 28. For years subsequent to 1752, a year is a leap year if it is divisible by 4, but not divisible by 100, unless it is also divisible by 400. Prior to 1752, all years divisible by 4 were leap years. Note that the year 1752 had only <code>366 - 11 = 355</code> days, as September 3rd through the 13th were omitted (in a one-time correction to the previous, less accurate, leap-year convention). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="caching"></a> <a class="anchor" id="description.caching"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Caching: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>To achieve maximal runtime performance, several of the functions in this component reserve the right to be implemented using statically cached (i.e., tabulated) values (which is inherently thread-safe). In all cases where a cache may be used, <code><a class="el" href="structbdlt_1_1PosixDateImpUtil.html">bdlt::PosixDateImpUtil</a></code> explicitly provides a <code>NoCache</code> version (e.g., <code>ymdToSerialNoCache</code>) that is guaranteed NOT to use a cache. Although the "normal" (potentially cached) functions typically gain huge performance advantages, the <code>NoCache</code> versions may conceivably be preferred by the performance-minded user who is <em>reasonably</em> <em>certain</em> that the vast majority of date values of interest will miss the cache (thus incurring a small, but unnecessary overhead for the cache-hit tests). Note, however, that the <code>NoCache</code> function variants are provided primarily for testing and for generating that cache in the first place (see <code>bdlt_posixdateimputil.t.cpp</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component was created primarily to support the implementation of a general-purpose, value-semantic (vocabulary) "Date" type, but also provides many low-level utility functions suitable for direct use by other clients. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creating_a_general_purpose_utility"></a> <a class="anchor" id="usage.creating_a_general_purpose_utility"></a> <a class="anchor" id="description.usage.creating_a_general_purpose_utility"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Creating a General Purpose Utility: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Many of the functions provided by this component can be used directly by clients that want to ask questions about a particular date in one of the three supported formats. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>What day of the week was January 3, 2010? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(2 == <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a7a6f4345eb960075b9f46dc6736f5f53">bdlt::PosixDateImpUtil::ymdToDayOfWeek</a>(2010, 3, 1));
                                                           <span class="comment">// 2 means Monday.</span>
</pre></div><br/>
<br/>
 Was the year 2000 a leap year? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a9896b9016179c91a98e30c056ac8f388">bdlt::PosixDateImpUtil::isLeapYear</a>(2000));
                                                           <span class="comment">// Yes, it was.</span>
</pre></div><br/>
<br/>
 Was February 29, 1900, a valid date in history? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">false</span> == <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a7edd5ff07f3b616de25804690e727ff7">bdlt::PosixDateImpUtil::isValidYearMonthDay</a>(1900, 2, 29));
                                                           <span class="comment">// No, it was not.</span>
</pre></div><br/>
<br/>
 What was the last day of February in 1600? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(29 == <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#ae80446734112d62af1fa34f52d2432ea">bdlt::PosixDateImpUtil::lastDayOfMonth</a>(1600, 2));
                                                           <span class="comment">// The 29th.</span>
</pre></div><br/>
<br/>
 How many leap years occur from 1959 to 2012 inclusive? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(14 == <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#aa9117261a16f49ead9a6ca96adad1a9f">bdlt::PosixDateImpUtil::numLeapYears</a>(1959, 2012));
                                                           <span class="comment">// There are 14.</span>
</pre></div><br/>
<br/>
 On what day of the year does February 29, 2020 fall? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(60 == <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#ae78539d34052ab20f2e2750bfe40e372">bdlt::PosixDateImpUtil::ymdToDayOfYear</a>(2020, 2, 29));
                                                           <span class="comment">// The 60th one.</span>
</pre></div><br/>
<br/>
 In what month does the 120th day of 2011 fall? <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(4 == <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#af53188c99c0788e379003995ed6e6d8c">bdlt::PosixDateImpUtil::ydToMonth</a>(2011, 120));
                                                           <span class="comment">// 4 means April.</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implementing_a_value-semantic_date_type"></a> <a class="anchor" id="usage.implementing_a_value-semantic_date_type"></a> <a class="anchor" id="description.usage.implementing_a_value-semantic_date_type"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Implementing a Value-Semantic Date Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using the functions supplied in this component, we can easily implement a C++ class that represents abstract (<em>mathematical</em>) date values and performs a few common operations on them. The internal representation could be any of the three supported by this component; in this example, we will choose to represent the date value internally as a "serial date": <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyDate {
      <span class="comment">// This class represents a valid date in the range</span>
      <span class="comment">// &#39;[ 0001/01/01 .. 9999/12/31 ]&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_serialDate;  <span class="comment">// 1 = 0001JAN01, 2 = 0001JAN02, ...</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> MyDate <a class="code" href="namespacebdldfp.html#ab2ecb5051ef405ce62f19e2dd5f09432">operator+</a>(<span class="keyword">const</span> MyDate&amp;, <span class="keywordtype">int</span>);
      <span class="keyword">friend</span> MyDate <a class="code" href="namespacebdldfp.html#ab2ecb5051ef405ce62f19e2dd5f09432">operator+</a>(<span class="keywordtype">int</span>, <span class="keyword">const</span> MyDate&amp;);
      <span class="keyword">friend</span> <span class="keywordtype">int</span>  <a class="code" href="namespacebdlc.html#abb779cb10513bd0b6f09ca6a5acee838">operator- </a>(<span class="keyword">const</span> MyDate&amp;, <span class="keyword">const</span> MyDate&amp;);
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyDate&amp;, <span class="keyword">const</span> MyDate&amp;);

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE CREATORS</span>
      <span class="keyword">explicit</span> MyDate(<span class="keywordtype">int</span> serialDate);
</pre></div><br/>
<br/>
 Next we define the public interface of the class, with function-level documentation conspicuously omitted (note, however, that reference implementations with preconditions asserted will follow): <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> Day {
          SUN = 1,
          MON = 2,
          TUE = 3,
          WED = 4,
          THU = 5,
          FRI = 6,
          SAT = 7
      };

      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">bool</span> isValid(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day);

      <span class="comment">// CREATORS</span>
      MyDate();
      MyDate(<span class="keyword">const</span> MyDate&amp; original);
      ~MyDate();

      <span class="comment">// MANIPULATORS</span>
      MyDate&amp; operator=(<span class="keyword">const</span> MyDate&amp; rhs);
      MyDate&amp; <a class="code" href="namespacebdlb.html#a699612d059aa6db974f220f6823e4c0d">operator++</a>();
      MyDate&amp; <a class="code" href="namespacebdlc.html#ac907e5780fc6951e1d99a105b1218fcb">operator--</a>();
      MyDate&amp; operator+=(<span class="keywordtype">int</span> numDays);
      MyDate&amp; operator-=(<span class="keywordtype">int</span> numDays);
      <span class="keywordtype">void</span> setYearMonthDay(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day);
      <span class="keywordtype">bool</span> setYearMonthDayIfValid(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day);

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">void</span> getYearMonthDay(<span class="keywordtype">int</span> *year, <span class="keywordtype">int</span> *month, <span class="keywordtype">int</span> *day) <span class="keyword">const</span>;
      <span class="keywordtype">int</span> year() <span class="keyword">const</span>;
      <span class="keywordtype">int</span> month() <span class="keyword">const</span>;
      <span class="keywordtype">int</span> day() <span class="keyword">const</span>;
      Day dayOfWeek() <span class="keyword">const</span>;
      <span class="keywordtype">bool</span> isLeapYear() <span class="keyword">const</span>;
      bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(bsl::ostream&amp; stream) <span class="keyword">const</span>;
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs);
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs);

  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> MyDate&amp; rhs);

  MyDate <a class="code" href="namespacebdldfp.html#ab2ecb5051ef405ce62f19e2dd5f09432">operator+</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keywordtype">int</span>           rhs);
  MyDate <a class="code" href="namespacebdldfp.html#ab2ecb5051ef405ce62f19e2dd5f09432">operator+</a>(<span class="keywordtype">int</span>           lhs, <span class="keyword">const</span> MyDate&amp; rhs);

  <span class="keywordtype">int</span> <a class="code" href="namespacebdlc.html#abb779cb10513bd0b6f09ca6a5acee838">operator-</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs);

  MyDate <a class="code" href="namespacebdlb.html#a699612d059aa6db974f220f6823e4c0d">operator++</a>(MyDate&amp; <span class="keywordtype">object</span>, <span class="keywordtype">int</span>);
  MyDate <a class="code" href="namespacebdlc.html#ac907e5780fc6951e1d99a105b1218fcb">operator--</a>(MyDate&amp; <span class="keywordtype">object</span>, <span class="keywordtype">int</span>);
</pre></div><br/>
<br/>
 We now provide a reference implementation of each of the methods and free (operator) functions associated with the <code>MyDate</code> class defined above (using <code>bsls_assert</code> to identify preconditions and invariants where appropriate): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// PRIVATE CREATORS</span>
  <span class="keyword">inline</span>
  MyDate::MyDate(<span class="keywordtype">int</span> serialDate)
  : d_serialDate(serialDate)
  {
  }

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> MyDate::isValid(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day)
  {
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a7edd5ff07f3b616de25804690e727ff7">bdlt::PosixDateImpUtil::isValidYearMonthDay</a>(year, month, day);
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyDate::MyDate()
  : d_serialDate(1)
  {
  }

  <span class="keyword">inline</span>
  MyDate::MyDate(<span class="keyword">const</span> MyDate&amp; original)
  : d_serialDate(original.d_serialDate)
  {
  }

  <span class="keyword">inline</span>
  MyDate::~MyDate()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  MyDate&amp; MyDate::operator=(<span class="keyword">const</span> MyDate&amp; rhs)
  {
      d_serialDate = rhs.d_serialDate;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyDate&amp; <a class="code" href="namespacebdlb.html#a699612d059aa6db974f220f6823e4c0d">MyDate::operator++</a>()
  {
      ++d_serialDate;
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(<a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a9c70414355db9841f936e61252d64876">bdlt::PosixDateImpUtil::isValidSerial</a>(d_serialDate));
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyDate&amp; <a class="code" href="namespacebdlc.html#ac907e5780fc6951e1d99a105b1218fcb">MyDate::operator--</a>()
  {
      --d_serialDate;
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(<a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a9c70414355db9841f936e61252d64876">bdlt::PosixDateImpUtil::isValidSerial</a>(d_serialDate));
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyDate&amp; MyDate::operator+=(<span class="keywordtype">int</span> numDays)
  {
      d_serialDate += numDays;
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(<a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a9c70414355db9841f936e61252d64876">bdlt::PosixDateImpUtil::isValidSerial</a>(d_serialDate));
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyDate&amp; MyDate::operator-=(<span class="keywordtype">int</span> numDays)
  {
      d_serialDate -= numDays;
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(<a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a9c70414355db9841f936e61252d64876">bdlt::PosixDateImpUtil::isValidSerial</a>(d_serialDate));
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> MyDate::setYearMonthDay(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day)
  {
      d_serialDate = <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a46f72550e86b86a16066246e617f3c0b">bdlt::PosixDateImpUtil::ymdToSerial</a>(year, month, day);
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(<a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a9c70414355db9841f936e61252d64876">bdlt::PosixDateImpUtil::isValidSerial</a>(d_serialDate));
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> MyDate::setYearMonthDayIfValid(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day)
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> newDate = <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a46f72550e86b86a16066246e617f3c0b">bdlt::PosixDateImpUtil::ymdToSerial</a>(year,
                                                              month,
                                                              day);
      <span class="keywordflow">if</span> (<a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a9c70414355db9841f936e61252d64876">bdlt::PosixDateImpUtil::isValidSerial</a>(newDate)) {
          d_serialDate = newDate;
          <span class="keywordflow">return</span> <span class="keyword">true</span>;                                              <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> MyDate::getYearMonthDay(<span class="keywordtype">int</span> *year, <span class="keywordtype">int</span> *month, <span class="keywordtype">int</span> *day)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a05091fcfb226ce4ba5b1f6bf3bd17614">bdlt::PosixDateImpUtil::serialToYmd</a>(year, month, day, d_serialDate);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyDate::year()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a1c573464b6e6518c65e1983b9cbb3519">bdlt::PosixDateImpUtil::serialToYear</a>(d_serialDate);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyDate::month()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a27d178ea19b157be8891765a298dc3a3">bdlt::PosixDateImpUtil::serialToMonth</a>(d_serialDate);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyDate::day()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a88952b5f0759538f3ec17dbe42c14b34">bdlt::PosixDateImpUtil::serialToDay</a>(d_serialDate);
  }

  <span class="keyword">inline</span>
  MyDate::Day MyDate::dayOfWeek()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> MyDate::Day(<a class="code" href="structbdlt_1_1PosixDateImpUtil.html#ad8f1b6d3790e013357b896a64d6d3edd">bdlt::PosixDateImpUtil::serialToDayOfWeek</a>(
                                                              d_serialDate));
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> MyDate::isLeapYear()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a9896b9016179c91a98e30c056ac8f388">bdlt::PosixDateImpUtil::isLeapYear</a>(year());
  }

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_serialDate == rhs.d_serialDate;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs)
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }

  <span class="keyword">inline</span>
  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> MyDate&amp; rhs)
  {
      <span class="keywordflow">return</span> rhs.print(stream);
  }

  <span class="keyword">inline</span>
  MyDate <a class="code" href="namespacebdldfp.html#ab2ecb5051ef405ce62f19e2dd5f09432">operator+</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keywordtype">int</span> rhs)
  {
      <span class="keywordflow">return</span> MyDate(lhs.d_serialDate + rhs);
  }

  <span class="keyword">inline</span>
  MyDate <a class="code" href="namespacebdldfp.html#ab2ecb5051ef405ce62f19e2dd5f09432">operator+</a>(<span class="keywordtype">int</span> lhs, <span class="keyword">const</span> MyDate&amp; rhs)
  {
      <span class="keywordflow">return</span> MyDate(lhs + rhs.d_serialDate);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> <a class="code" href="namespacebdlc.html#abb779cb10513bd0b6f09ca6a5acee838">operator-</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_serialDate - rhs.d_serialDate;
  }

  <span class="keyword">inline</span>
  MyDate <a class="code" href="namespacebdlb.html#a699612d059aa6db974f220f6823e4c0d">operator++</a>(MyDate&amp; <span class="keywordtype">object</span>, <span class="keywordtype">int</span>)
  {
      MyDate tmp(<span class="keywordtype">object</span>);
      ++object;
      <span class="keywordflow">return</span> tmp;
  }

  <span class="keyword">inline</span>
  MyDate <a class="code" href="namespacebdlc.html#ac907e5780fc6951e1d99a105b1218fcb">operator--</a>(MyDate&amp; <span class="keywordtype">object</span>, <span class="keywordtype">int</span>)
  {
      MyDate tmp(<span class="keywordtype">object</span>);
      --object;
      <span class="keywordflow">return</span> tmp;
  }
</pre></div><br/>
<br/>
 The following definitions would appropriately appear in the implementation (<code>.cpp</code>) <a href="file:">file:</a> <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> monthNames[] = {
      0, <span class="stringliteral">&quot;JAN&quot;</span>, <span class="stringliteral">&quot;FEB&quot;</span>, <span class="stringliteral">&quot;MAR&quot;</span>, <span class="stringliteral">&quot;APR&quot;</span>,
         <span class="stringliteral">&quot;MAY&quot;</span>, <span class="stringliteral">&quot;JUN&quot;</span>, <span class="stringliteral">&quot;JUL&quot;</span>, <span class="stringliteral">&quot;AUG&quot;</span>,
         <span class="stringliteral">&quot;SEP&quot;</span>, <span class="stringliteral">&quot;OCT&quot;</span>, <span class="stringliteral">&quot;NOV&quot;</span>, <span class="stringliteral">&quot;DEC&quot;</span>
  };

  <span class="comment">// MANIPULATORS</span>
  bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">MyDate::print</a>(bsl::ostream&amp; stream)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">if</span> (!stream) {
          <span class="keywordflow">return</span> stream;                                            <span class="comment">// RETURN</span>
      }

      <span class="comment">// space usage: ddMMMyyyy null</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> SIZE = 2 + 3 + 4 + 1;
      <span class="keywordtype">char</span> buf[SIZE];

      <span class="keywordtype">int</span> y, m, d;
      <a class="code" href="structbdlt_1_1PosixDateImpUtil.html#a05091fcfb226ce4ba5b1f6bf3bd17614">bdlt::PosixDateImpUtil::serialToYmd</a>(&amp;y, &amp;m, &amp;d, d_serialDate);

      buf[0] = d / 10 + <span class="charliteral">&#39;0&#39;</span>;
      buf[1] = d % 10 + <span class="charliteral">&#39;0&#39;</span>;

      bsl::memcpy(&amp;buf[2], monthNames[m], 3);

      buf[5] = y / 1000 + <span class="charliteral">&#39;0&#39;</span>;
      buf[6] = ((y % 1000) / 100) + <span class="charliteral">&#39;0&#39;</span>;
      buf[7] = ((y % 100) / 10) + <span class="charliteral">&#39;0&#39;</span>;
      buf[8] = y % 10 + <span class="charliteral">&#39;0&#39;</span>;
      buf[9] = 0;

      stream &lt;&lt; buf;

      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 The following snippets of code illustrate how to create and use a <code>Mydate</code> object. First create a default object, <code>d1</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyDate d1;                        assert(   1 == d1.year());
                                    assert(   1 == d1.month());
                                    assert(   1 == d1.day());
</pre></div><br/>
<br/>
 Next, set <code>d1</code> to July 4, 1776: <br/>
<br/>
<div class="fragment"><pre class="fragment">  d1.setYearMonthDay(1776, 7, 4);   assert(1776 == d1.year());
                                    assert(   7 == d1.month());
                                    assert(   4 == d1.day());
</pre></div><br/>
<br/>
 Then create <code>d2</code> as a copy of <code>d1</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyDate d2(d1);                    assert(1776 == d2.year());
                                    assert(   7 == d2.month());
                                    assert(   4 == d2.day());
</pre></div><br/>
<br/>
 Now, add six days to the value of <code>d2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  d2 += 6;                          assert(1776 == d2.year());
                                    assert(   7 == d2.month());
                                    assert(  10 == d2.day());
</pre></div><br/>
<br/>
 Next subtract <code>d1</code> from <code>d2</code>, storing the difference (in days) in <code>dDays</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> dDays = d2 - d1;              assert(6 == dDays);
</pre></div><br/>
<br/>
 Finally, stream the value of <code>d2</code> to <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::cout &lt;&lt; d2 &lt;&lt; bsl::endl;
</pre></div><br/>
<br/>
 The streaming operator produces the following output on <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  10JUL1776
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:51 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
