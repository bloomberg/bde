<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslstl_string.h                                                    -*-C++-*-
#ifndef INCLUDED_BSLSTL_STRING
#define INCLUDED_BSLSTL_STRING

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a standard-compliant &#39;basic_string&#39; class template.
//
//@CLASSES:
//  bsl::basic_string: C++ standard compliant &#39;basic_string&#39; implementation
//  bsl::string: &#39;typedef&#39; for &#39;bsl::basic_string&lt;char&gt;&#39;
//  bsl::wstring: &#39;typedef&#39; for &#39;bsl::basic_string&lt;wchar_t&gt;&#39;
//
//@SEE_ALSO: ISO C++ Standard, Section 21 [strings]
//
//@DESCRIPTION: This component defines a single class template &#39;basic_string&#39;,
// implementing standard containers, &#39;std::string&#39; and &#39;std::wstring&#39;, that
// hold a sequence of characters.
//
// An instantiation of &#39;basic_string&#39; is an allocator-aware, value-semantic
// type whose salient attributes are its size (number of characters) and the
// sequence of characters that the string contains.  The &#39;basic_string&#39; &#39;class&#39;
// is parameterized by the character type, &#39;CHAR_TYPE&#39;, that character type&#39;s
// traits, &#39;CHAR_TRAITS&#39;, and an allocator, &#39;ALLOCATOR&#39;.  The traits for each
// character type provide functions that assign, compare, and copy a sequence
// of those characters.
//
// A &#39;basic_string&#39; meets the requirements of a sequential container with
// random access iterators as specified in the [basic.string] section of the
// C++ standard [21.4].  The &#39;basic_string&#39; implemented here adheres to the
// C++11 standard, except that it does not have interfaces that take rvalue
// references or &#39;initializer_lists&#39;, the &#39;shrink_to_fit&#39; method,and template
// specializations &#39;std::u16string&#39; and &#39;std::u32string&#39;.  Note that excluded
// C++11 features are those that require (or are greatly simplified by) C++11
// compiler support.
//
///Memory Allocation
///-----------------
// The type supplied as a &#39;basic_string&#39;s &#39;ALLOCATOR&#39; template parameter
// determines how that &#39;basic_string&#39; will allocate memory.  The &#39;basic_string&#39;
// template supports allocators meeting the requirements of the C++11 standard,
// in addition it supports scoped-allocators derived from the
// &#39;bslma::Allocator&#39; memory allocation protocol.  Clients intending to use
// &#39;bslma&#39; style allocators should use the template&#39;s default &#39;ALLOCATOR&#39; type:
// The default type for the &#39;ALLOCATOR&#39; template parameter, &#39;bsl::allocator&#39;,
// provides a C++11 standard-compatible adapter for a &#39;bslma::Allocator&#39;
// object.
//
///&#39;bslma&#39;-Style Allocators
/// - - - - - - - - - - - -
// If the (template parameter) type &#39;ALLOCATOR&#39; of an &#39;basic_string&#39;
// instantiation is &#39;bsl::allocator&#39;, then objects of that &#39;basic_string&#39; type
// will conform to the standard behavior of a &#39;bslma&#39;-allocator-enabled type.
// Such a &#39;basic_string&#39; accepts an optional &#39;bslma::Allocator&#39; argument at
// construction.  If the address of a &#39;bslma::Allocator&#39; object is explicitly
// supplied at construction, it is used to supply memory for the &#39;basic_string&#39;
// throughout its lifetime; otherwise, the &#39;basic_string&#39; will use the default
// allocator installed at the time of the &#39;basic_string&#39;&#39;s construction (see
// &#39;bslma_default&#39;).
//
///Lexicographical Comparisons
///---------------------------
// Two &#39;basic_string&#39;s &#39;lhs&#39; and &#39;rhs&#39; are lexicographically compared by first
// determining &#39;N&#39;, the smaller of the lengths of &#39;lhs&#39; and &#39;rhs&#39;, and
// comparing characters at each position between 0 and &#39;N - 1&#39;, using
// &#39;CHAR_TRAITS::lt&#39; in lexicographical fashion.  If &#39;CHAR_TRAITS::lt&#39;
// determines that strings are non-equal (smaller or larger), then this is the
// result.  Otherwise, the lengths of the strings are compared and the shorter
// string is declared the smaller.  Lexicographical comparison returns equality
// only when both strings have the same length and the same character value in
// each respective position.
//
///Operations
///----------
// This section describes the run-time complexity of operations on instances of
// &#39;basic_string&#39;:
//..
//  Legend
//  ------
//  &#39;V&#39;              - the &#39;CHAR_TYPE&#39; template parameter type of the
//                     &#39;basic_string&#39;
//  &#39;a&#39;, &#39;b&#39;         - two distinct objects of type &#39;basic_string&lt;V&gt;&#39;
//  &#39;k&#39;              - an integral number
//  &#39;al&#39;             - an STL-style memory allocator
//  &#39;i1&#39;, &#39;i2&#39;       - two iterators defining a sequence of &#39;CHAR_TYPE&#39;
//                     characters
//  &#39;v&#39;              - an object of type &#39;V&#39;
//  &#39;p1&#39;, &#39;p2&#39;       - two iterators belonging to &#39;a&#39;
//  distance(i1,i2)  - the number of values in the range [i1, i2)
//
//  +-----------------------------------------+-------------------------------+
//  | Operation                               | Complexity                    |
//  |=========================================+===============================|
//  | basic_string&lt;V&gt; a (default construction)| O[1]                          |
//  | basic_string&lt;V&gt; a(al)                   |                               |
//  |-----------------------------------------+-------------------------------|
//  | basic_string&lt;V&gt; a(b) (copy construction)| O[n]                          |
//  | basic_string&lt;V&gt; a(b, al)                |                               |
//  |-----------------------------------------+-------------------------------|
//  | basic_string&lt;V&gt; a(std::move(b))         | O[1]                          |
//  | (move construction)                     |                               |
//  |-----------------------------------------+-------------------------------|
//  | basic_string&lt;V&gt; a(std::move(b), a1)     | O[n]                          |
//  | (extended move construction)            |                               |
//  |-----------------------------------------+-------------------------------|
//  | basic_string&lt;V&gt; a(k)                    | O[n]                          |
//  | basic_string&lt;V&gt; a(k, al)                |                               |
//  |-----------------------------------------+-------------------------------|
//  | basic_string&lt;V&gt; a(i1, i2)               | O[distance(i1,i2)]            |
//  | basic_string&lt;V&gt; a(i1, i2, al)           |                               |
//  |-----------------------------------------+-------------------------------|
//  | a.~basic_string&lt;V&gt;()  (destruction)     | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.assign(k, v)                          | O[k]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.assign(i1, i2)                        | O[distance(i1,i2)]            |
//  |-----------------------------------------+-------------------------------|
//  | get_allocator()                         | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.begin(), a.end(),                     | O[1]                          |
//  | a.cbegin(), a.cend(),                   |                               |
//  | a.rbegin(), a.rend(),                   |                               |
//  | a.crbegin(), a.crend()                  |                               |
//  |-----------------------------------------+-------------------------------|
//  | a.size()                                | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.max_size()                            | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.resize(k)                             | O[k]                          |
//  | a.resize(k, v)                          |                               |
//  |-----------------------------------------+-------------------------------|
//  | a.empty()                               | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.reserve(k)                            | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a[k]                                    | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.at(k)                                 | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.front()                               | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.back()                                | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.push_back()                           | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.pop_back()                            | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a.insert(p1, v)                         | O[1 + distance(p1, a.end())]  |
//  |-----------------------------------------+-------------------------------|
//  | a.insert(p1, k, v)                      | O[k + distance(p1, a.end())]  |
//  |-----------------------------------------+-------------------------------|
//  | a.insert(p1, i1, i2)                    | O[distance(i1, i2)            |
//  |                                         |      + distance(p1, a.end())] |
//  |-----------------------------------------+-------------------------------|
//  | a.erase(p1)                             | O[1 + distance(p1, a.end())]  |
//  |-----------------------------------------+-------------------------------|
//  | a.erase(p1, p2)                         | O[1 + distance(p1, a.end())]  |
//  |-----------------------------------------+-------------------------------|
//  | a.swap(b), swap(a,b)                    | O[1] if &#39;a&#39; and &#39;b&#39; use the   |
//  |                                         | same allocator, O[n + m]      |
//  |                                         | otherwise                     |
//  |-----------------------------------------+-------------------------------|
//  | a.clear()                               | O[1]                          |
//  |-----------------------------------------+-------------------------------|
//  | a = b;           (assignment)           | O[n]                          |
//  |-----------------------------------------+-------------------------------|
//  | a == b, a != b                          | O[n]                          |
//  |-----------------------------------------+-------------------------------|
//  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b            | O[n]                          |
//  +-----------------------------------------+-------------------------------+
//..
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Basic Syntax
///- - - - - - - - - - - -
// In this example, we will show how to create and use the &#39;string&#39; typedef.
//
// First, we will default-construct a &#39;string&#39; object:
//..
//  bsl::string s;
//  assert(s.empty());
//  assert(0  == s.size());
//  assert(&quot;&quot; == s);
//..
// Then, we will construct a &#39;string&#39; object from a string literal:
//..
//  bsl::string t = &quot;Hello World&quot;;
//  assert(!t.empty());
//  assert(11 == t.size());
//  assert(&quot;Hello World&quot; == t);
//..
// Next, we will clear the contents of &#39;t&#39; and assign it a couple of values:
// first from a string literal; and second from another &#39;string&#39; object:
//..
//  t.clear();
//  assert(t.empty());
//  assert(&quot;&quot; == t);
//
//  t = &quot;Good Morning&quot;;
//  assert(!t.empty());
//  assert(&quot;Good Morning&quot; == t);
//
//  t = s;
//  assert(t.empty());
//  assert(&quot;&quot; == t);
//  assert(t == s);
//..
// Then, we will create three &#39;string&#39; objects: the first representing a street
// name, the second a state, and the third a zipcode.  We will then concatenate
// them into a single address &#39;string&#39; and print the contents of that &#39;string&#39;
// on standard output:
//..
//  const bsl::string street  = &quot;731 Lexington Avenue&quot;;
//  const bsl::string state   = &quot;NY&quot;;
//  const bsl::string zipcode = &quot;10022&quot;;
//
//  const bsl::string fullAddress = street + &quot; &quot; + state + &quot; &quot; + zipcode;
//
//  bsl::cout &lt;&lt; fullAddress &lt;&lt; bsl::endl;
//..
// The above print statement should produce a single line of output:
//..
//  731 Lexington Avenue NY 10022
//..
// Then, we search the contents of &#39;address&#39; (using the &#39;find&#39; function) to
// determine if it lies on a specified street:
//..
//  const bsl::string streetName = &quot;Lexington&quot;;
//
//  if (bsl::string::npos != fullAddress.find(streetName, 0)) {
//      bsl::cout &lt;&lt; &quot;The address &quot; &lt;&lt; fullAddress &lt;&lt; &quot; is located on &quot;
//                &lt;&lt; streetName &lt;&lt; &quot;.&quot; &lt;&lt; bsl::endl;
//  }
//..
// Next, we show how to get a reference providing modifiable access to the
// null-terminated string literal stored by a &#39;string&#39; object using the &#39;c_str&#39;
// function.  Note that the returned string literal can be passed to various
// standard functions expecting a null-terminated string:
//..
//  const bsl::string  v = &quot;Another string&quot;;
//  const char        *cs = v.c_str();
//  assert(bsl::strlen(cs) == v.size());
//..
// Then, we construct two &#39;string&#39; objects, &#39;x&#39; and &#39;y&#39;, using a user-specified
// allocator:
//..
//  bslma::TestAllocator allocator1, allocator2;
//
//  const char *SHORT_STRING = &quot;A small string&quot;;
//  const char *LONG_STRING  = &quot;This long string would definitely cause &quot;
//                             &quot;memory to be allocated on creation&quot;;
//
//  const bsl::string x(SHORT_STRING, &amp;allocator1);
//  const bsl::string y(LONG_STRING,  &amp;allocator2);
//
//  assert(SHORT_STRING == x);
//  assert(LONG_STRING  == y);
//..
// Notice that, no memory was allocated from the allocator for object &#39;x&#39;
// because of the short-string optimization used in the &#39;string&#39; type.
//
// Finally, we can track memory usage of &#39;x&#39; and &#39;y&#39; using &#39;allocator1&#39; and
// &#39;allocator2&#39; and check that memory was allocated only by &#39;allocator2&#39;:
//..
//  assert(0 == allocator1.numBlocksInUse());
//  assert(1 == allocator2.numBlocksInUse());
//..
//
///Example 2: &#39;string&#39; as a data member
///- - - - - - - - - - - - - - - - - -
// The most common use of &#39;string&#39; objects are as data members in user-defined
// classes.  In this example, we will show how &#39;string&#39; objects can be used as
// data members.
//
// First, we begin to define a &#39;class&#39;, &#39;Employee&#39;, that represents the data
// corresponding to an employee of a company:
//..
//  class Employee {
//      // This simply constrained (value-semantic) attribute class represents
//      // the information about an employee.  An employee&#39;s first and last
//      // name are represented as &#39;string&#39; objects and their employee
//      // identification number is represented by an &#39;int&#39;.  Note that the
//      // class invariants are identically the constraints on the individual
//      // attributes.
//      //
//      // This class:
//      //: o supports a complete set of *value-semantic* operations
//      //:   o except for &#39;bslx&#39; serialization
//      //: o is *exception-neutral* (agnostic)
//      //: o is *alias-safe*
//      //: o is &#39;const&#39; *thread-safe*
//
//      // DATA
//      bsl::string d_firstName;       // first name
//      bsl::string d_lastName;        // last name
//      int         d_id;              // identification number
//..
//  Next, we define the creators for this class:
//..
//    public:
//      // CREATORS
//      Employee(bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;Employee&#39; object having the (default) attribute
//          // values:
//          //..
//          //  firstName() == &quot;&quot;
//          //  lastName()  == &quot;&quot;
//          //  id()        == 0
//          //..
//          // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
//          // &#39;basicAllocator&#39; is 0, the currently installed default
//          // allocator is used.
//
//      Employee(const bslstl::StringRef&amp;  firstName,
//               const bslstl::StringRef&amp;  lastName,
//               int                       id,
//               bslma::Allocator         *basicAllocator = 0);
//          // Create a &#39;Employee&#39; object having the specified &#39;firstName&#39;,
//          // &#39;lastName&#39;, and &#39;id&#39;&#39; attribute values.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      Employee(const Employee&amp;   original,
//               bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;Employee&#39; object having the same value as the
//          // specified &#39;original&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      //! ~Employee() = default;
//          // Destroy this object.
//..
// Notice that all constructors of the &#39;Employee&#39; class are optionally provided
// an allocator that is then passed through to the &#39;string&#39; data members of
// &#39;Employee&#39;.  This allows the user to control how memory is allocated by
// &#39;Employee&#39; objects.  Also note that the type of the &#39;firstName&#39; and
// &#39;lastName&#39; arguments of the value constructor is &#39;bslstl::StringRef&#39;.  The
// &#39;bslstl::StringRef&#39; allows specifying a &#39;string&#39; or a &#39;const char *&#39; to
// represent a string value.  For the sake of brevity its implementation is
// not explored here.
//
// Then, declare the remaining methods of the class:
//..
//      // MANIPULATORS
//      Employee&amp; operator=(const Employee&amp; rhs);
//          // Assign to this object the value of the specified &#39;rhs&#39; object,
//          // and return a reference providing modifiable access to this
//          // object.
//
//      void setFirstName(const bslstl::StringRef&amp; value);
//          // Set the &#39;firstName&#39; attribute of this object to the specified
//          // &#39;value&#39;.
//
//      void setLastName(const bslstl::StringRef&amp; value);
//          // Set the &#39;lastName&#39; attribute of this object to the specified
//          // &#39;value&#39;.
//
//      void setId(int value);
//          // Set the &#39;id&#39; attribute of this object to the specified &#39;value&#39;.
//
//      // ACCESSORS
//      const bsl::string&amp; firstName() const;
//          // Return a reference providing non-modifiable access to the
//          // &#39;firstName&#39; attribute of this object.
//
//      const bsl::string&amp; lastName() const;
//          // Return a reference providing non-modifiable access to the
//          // &#39;lastName&#39; attribute of this object.
//
//      int id() const;
//          // Return the value of the &#39;id&#39; attribute of this object.
//  };
//..
// Next, we declare the free operators for &#39;Employee&#39;:
//..
//  inline
//  bool operator==(const Employee&amp; lhs, const Employee&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
//      // value, and &#39;false&#39; otherwise.  Two &#39;Employee&#39; objects have the
//      // same value if all of their corresponding values of their
//      // &#39;firstName&#39;, &#39;lastName&#39;, and &#39;id&#39; attributes are the same.
//
//  inline
//  bool operator!=(const Employee&amp; lhs, const Employee&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have
//      // the same value, and &#39;false&#39; otherwise.  Two &#39;Employee&#39; objects do
//      // not have the same value if any of the corresponding values of their
//      // &#39;firstName&#39;, &#39;lastName&#39;, or &#39;id&#39; attributes are not the same.
//..
// Then, we implement the various methods of the &#39;Employee&#39; class:
//..
//  // CREATORS
//  inline
//  Employee::Employee(bslma::Allocator *basicAllocator)
//  : d_firstName(basicAllocator)
//  , d_lastName(basicAllocator)
//  , d_id(0)
//  {
//  }
//
//  inline
//  Employee::Employee(const bslstl::StringRef&amp;  firstName,
//                     const bslstl::StringRef&amp;  lastName,
//                     int                       id,
//                     bslma::Allocator         *basicAllocator)
//  : d_firstName(firstName.begin(), firstName.end(), basicAllocator)
//  , d_lastName(lastName.begin(), lastName.end(), basicAllocator)
//  , d_id(id)
//  {
//      BSLS_ASSERT_SAFE(!firstName.isEmpty());
//      BSLS_ASSERT_SAFE(!lastName.isEmpty());
//  }
//
//  inline
//  Employee::Employee(const Employee&amp;   original,
//                     bslma::Allocator *basicAllocator)
//  : d_firstName(original.d_firstName, basicAllocator)
//  , d_lastName(original.d_lastName, basicAllocator)
//  , d_id(original.d_id)
//  {
//  }
//..
// Notice that the &#39;basicAllocator&#39; parameter can simply be passed as an
// argument to the constructor of &#39;bsl::string&#39;.
//
// Now, we implement the remaining manipulators of the &#39;Employee&#39; class:
//..
//  // MANIPULATORS
//  inline
//  Employee&amp; Employee::operator=(const Employee&amp; rhs)
//  {
//      d_firstName = rhs.d_firstName;
//      d_lastName  = rhs.d_lastName;
//      d_id        = rhs.d_id;
//      return *this;
//  }
//
//  inline
//  void Employee::setFirstName(const bslstl::StringRef&amp; value)
//  {
//      BSLS_ASSERT_SAFE(!value.isEmpty());
//
//      d_firstName.assign(value.begin(), value.end());
//  }
//
//  inline
//  void Employee::setLastName(const bslstl::StringRef&amp; value)
//  {
//      BSLS_ASSERT_SAFE(!value.isEmpty());
//
//      d_lastName.assign(value.begin(), value.end());
//  }
//
//  inline
//  void Employee::setId(int value)
//  {
//      d_id = value;
//  }
//
//  // ACCESSORS
//  inline
//  const bsl::string&amp; Employee::firstName() const
//  {
//      return d_firstName;
//  }
//
//  inline
//  const bsl::string&amp; Employee::lastName() const
//  {
//      return d_lastName;
//  }
//
//  inline
//  int Employee::id() const
//  {
//      return d_id;
//  }
//..
// Finally, we implement the free operators for &#39;Employee&#39; class:
//..
//  inline
//  bool operator==(const Employee&amp; lhs, const Employee&amp; rhs)
//  {
//      return lhs.firstName() == rhs.firstName()
//          &amp;&amp; lhs.lastName()  == rhs.lastName()
//          &amp;&amp; lhs.id()        == rhs.id();
//  }
//
//  inline
//  bool operator!=(const Employee&amp; lhs, const Employee&amp; rhs)
//  {
//      return lhs.firstName() != rhs.firstName()
//          || lhs.lastName()  != rhs.lastName()
//          || lhs.id()        != rhs.id();
//  }
//..
//
///Example 3: A stream text replacement filter
///- - - - - - - - - - - - - - - - - - - - - -
// In this example, we will utilize the &#39;string&#39; type and its associated
// utility functions to define a function that reads data from an input stream,
// replaces all occurrences of a specified text fragment with another text
// fragment, and writes the resulting text to an output stream.
//
// First, we define the signature of the function, &#39;replace&#39;:
//..
//  void replace(bsl::ostream&amp;      outputStream,
//               bsl::istream&amp;      inputStream,
//               const bsl::string&amp; oldString,
//               const bsl::string&amp; newString)
//      // Read data from the specified &#39;inputStream&#39; and replace all
//      // occurrences of the text contained in the specified &#39;oldString&#39; in
//      // the stream with the text contained in the specified &#39;newString&#39;.
//      // Write the modified data to the specified &#39;outputStream&#39;.
//..
// Then, we provide the implementation for &#39;replace&#39;:
//..
//  {
//      const int   oldStringSize = oldString.size();
//      const int   newStringSize = newString.size();
//      bsl::string line;
//
//      bsl::getline(inputStream, line);
//..
// Notice that we can use the &#39;getline&#39; free function defined in this component
// to read a single line of data from an input stream into a &#39;bsl::string&#39;.
//..
//      if (!inputStream) {
//          return;                                                   // RETURN
//      }
//
//      do {
//..
// Next, we use the &#39;find&#39; function to search the contents of &#39;line&#39; for
// characters matching the contents of &#39;oldString&#39;:
//..
//          int pos = line.find(oldString);
//          while (bsl::string::npos != pos) {
//..
// Now, we use the &#39;replace&#39; method to modify the contents of &#39;line&#39; matching
// &#39;oldString&#39; to &#39;newString&#39;:
//..
//              line.replace(pos, oldStringSize, newString);
//              pos = line.find(oldString, pos + newStringSize);
//..
// Notice that we provide &#39;find&#39; with the starting position from which to start
// searching.
//..
//          }
//..
// Finally, we write the updated contents of &#39;line&#39; to the output stream:
//..
//          outputStream &lt;&lt; line;
//
//          bsl::getline(inputStream, line);
//      } while (inputStream);
//  }
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;include &lt;bsl_string.h&gt; instead of &lt;bslstl_string.h&gt; in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATOR
#include &lt;bslstl_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASH
#include &lt;bslstl_hash.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ITERATOR
#include &lt;bslstl_iterator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STDEXCEPTUTIL
#include &lt;bslstl_stdexceptutil.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STRINGREFDATA
#include &lt;bslstl_stringrefdata.h&gt;
#endif

#ifndef INCLUDED_BSLALG_CONTAINERBASE
#include &lt;bslalg_containerbase.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITHASSTLITERATORS
#include &lt;bslalg_typetraithasstliterators.h&gt;
#endif

#ifndef INCLUDED_BSLH_HASH
#include &lt;bslh_hash.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISSAME
#include &lt;bslmf_issame.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MATCHANYTYPE
#include &lt;bslmf_matchanytype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MATCHARITHMETICTYPE
#include &lt;bslmf_matcharithmetictype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MOVABLEREF
#include &lt;bslmf_movableref.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NIL
#include &lt;bslmf_nil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNEDBUFFER
#include &lt;bsls_alignedbuffer.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENT
#include &lt;bsls_alignment.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTFROMTYPE
#include &lt;bsls_alignmentfromtype.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_ALGORITHM
#include &lt;algorithm&gt;
#define INCLUDED_ALGORITHM
#endif

#ifndef INCLUDED_ISTREAM
#include &lt;istream&gt;  // for &#39;std::basic_istream&#39;, &#39;sentry&#39;
#define INCLUDED_ISTREAM
#endif

#ifndef INCLUDED_LIMITS
#include &lt;limits&gt;
#define INCLUDED_LIMITS
#endif

#ifndef INCLUDED_OSTREAM
#include &lt;ostream&gt;  // for &#39;std::basic_ostream&#39;, &#39;sentry&#39;
#define INCLUDED_OSTREAM
#endif

#ifndef INCLUDED_STRING
#include &lt;string&gt;  // for &#39;native_std::char_traits&#39;
#define INCLUDED_STRING
#endif


namespace bsl {

// Import &#39;char_traits&#39; into the &#39;bsl&#39; namespace so that &#39;basic_string&#39; and
// &#39;char_traits&#39; are always in the same namespace.
using native_std::char_traits;

template &lt;class CHAR_TYPE,
          class CHAR_TRAITS = char_traits&lt;CHAR_TYPE&gt;,
          class ALLOCATOR = allocator&lt;CHAR_TYPE&gt; &gt;
class basic_string;

// TYPEDEFS
typedef basic_string&lt;char&gt;    string;
typedef basic_string&lt;wchar_t&gt; wstring;

#if defined(BSLS_PLATFORM_CMP_SUN) || defined(BSLS_PLATFORM_CMP_HP)
template &lt;class ORIGINAL_TRAITS&gt;
class String_Traits {
    // This &#39;class&#39; provides an implementation of the &#39;find&#39; function for the
    // parameterized &#39;ORIGINAL_TRAITS&#39; type.  This is an alternate
    // representation for Sun&#39;s &#39;char_traits::find&#39; that returns an incorrect
    // result for character types other than &#39;char&#39; (such as &#39;wchar&#39;).

    // PRIVATE TYPES
    typedef typename ORIGINAL_TRAITS::char_type char_type;
    typedef native_std::size_t                  size_type;

  public:
    // CLASS METHODS
    static const char_type *find(const char_type  *s,
                                 size_type         n,
                                 const char_type&amp;  a);
        // Return an address providing non-modifiable access to the first
        // character that matches the specified character &#39;a&#39; in the specified
        // &#39;n&#39; characters of the specified &#39;s&#39; string.  The behavior is
        // undefined unless &#39;s&#39; holds at least &#39;n&#39; characters.
};

template &lt;&gt;
class String_Traits&lt;native_std::char_traits&lt;char&gt; &gt; {
    // Sun implemented &#39;find&#39; for &#39;char&#39; properly, so this specialization
    // simply forwards the call to Sun.

    // PRIVATE TYPES
    typedef native_std::size_t size_type;

  public:
    // CLASS METHODS
    static const char *find(const char *s, size_type n, const char&amp; a);
        // Return an address providing non-modifiable access to the first
        // character that matches the specified character &#39;a&#39; in the specified
        // &#39;n&#39; characters of the specified &#39;s&#39; string.  The behavior is
        // undefined unless &#39;s&#39; holds at least &#39;n&#39; characters.
};

// CLASS METHODS
template &lt;class ORIGINAL_TRAITS&gt;
const typename ORIGINAL_TRAITS::char_type *
String_Traits&lt;ORIGINAL_TRAITS&gt;::find(const char_type  *s,
                                     size_type         n,
                                     const char_type&amp;  a)
{
    while (n &gt; 0 &amp;&amp; !ORIGINAL_TRAITS::eq(*s, a)) {
        --n;
        ++s;
    }
    return n &gt; 0 ? s : 0;
}

inline
const char *
String_Traits&lt;native_std::char_traits&lt;char&gt; &gt;::find(const char  *s,
                                                    size_type    n,
                                                    const char&amp;  a)
{
    return native_std::char_traits&lt;char&gt;::find(s, n, a);
}

#define BSLSTL_CHAR_TRAITS String_Traits&lt;CHAR_TRAITS&gt;

#else

#define BSLSTL_CHAR_TRAITS CHAR_TRAITS

#endif

                        // ================
                        // class String_Imp
                        // ================

template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
class String_Imp {
    // This component private &#39;class&#39; describes the basic data layout for a
    // string class and provides methods to help encapsulate internal string
    // implementation details.  It is parameterized by &#39;CHAR_TYPE&#39; and
    // &#39;SIZE_TYPE&#39; only, and implements the portion of &#39;basic_string&#39; that does
    // not need to know about its parameterized &#39;CHAR_TRAITS&#39; or &#39;ALLOCATOR&#39;.
    // It contains the following data fields: pointer to string, short string
    // buffer, length, and capacity.  The purpose of the short string buffer is
    // to implement a &quot;short string optimization&quot; such that strings with
    // lengths shorter than a certain number of characters are stored directly
    // inside the string object (inside the short string buffer), and thereby
    // avoid memory allocations/deallocations.

  public:
    // TYPES
    enum ShortBufferConstraints {
        // This &#39;enum&#39; contains values necessary to calculate the size of the
        // short string buffer.  The starting value is
        // &#39;SHORT_BUFFER_MIN_BYTES&#39;, which defines the minimal number of bytes
        // (or &#39;char&#39; values) that the short string buffer should be able to
        // contain.  Then this value is aligned to a word boundary.  Then we
        // make sure that it fits at least one &#39;CHAR_TYPE&#39; character (because
        // the default state of the string object requires that the first
        // character is initialized with a NULL-terminator).  The final output
        // of this enum used by &#39;String_Imp&#39; is the &#39;SHORT_BUFFER_CAPACITY&#39;
        // value.  It defines the capacity of the short string buffer and also
        // the capacity of the default-constructed empty string object.

        SHORT_BUFFER_MIN_BYTES  = 20, // minimum required size of the short
                                      // string buffer in bytes

        SHORT_BUFFER_NEED_BYTES =
                              (SHORT_BUFFER_MIN_BYTES + sizeof(SIZE_TYPE) - 1)
                                                    &amp; ~(sizeof(SIZE_TYPE) - 1),
                                    // round it to a word boundary

        SHORT_BUFFER_BYTES      = sizeof(CHAR_TYPE) &lt; SHORT_BUFFER_NEED_BYTES
                                  ? SHORT_BUFFER_NEED_BYTES
                                  : sizeof(CHAR_TYPE),
                                    // in case &#39;CHAR_TYPE&#39; is very large

        SHORT_BUFFER_LENGTH     = SHORT_BUFFER_BYTES / sizeof(CHAR_TYPE),

        SHORT_BUFFER_CAPACITY   = SHORT_BUFFER_LENGTH - 1
                                    // short string buffer capacity (not
                                    // including the null-terminator)
    };

    // Make sure the buffer is large enough to fit a pointer.
    BSLMF_ASSERT(SHORT_BUFFER_BYTES &gt;= sizeof(CHAR_TYPE *));

    enum ConfigurableParameters {
        // These configurable parameters define various aspects of the string
        // behavior when it&#39;s not strictly defined by the Standard.

        BASIC_STRING_DEALLOCATE_IN_CLEAR  = false,
        BASIC_STRING_HONOR_SHRINK_REQUEST = false
    };

    // DATA
    union {
        // This is the union of the string storage options: it can either be
        // stored inside the short string buffer, &#39;d_short&#39;, or in the
        // externally allocated memory, pointed to by &#39;d_start_p&#39;.

        BloombergLP::bsls::AlignedBuffer&lt;
                        SHORT_BUFFER_BYTES,
                        BloombergLP::bsls::AlignmentFromType&lt;CHAR_TYPE&gt;::VALUE&gt;
                   d_short;     // short string buffer
        CHAR_TYPE *d_start_p;   // pointer to the data on heap
    };

    SIZE_TYPE      d_length;    // length of the string
    SIZE_TYPE      d_capacity;  // capacity to which the string can grow
                                // without reallocation

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(String_Imp,
                                   BloombergLP::bslmf::IsBitwiseMoveable);
        // &#39;CHAR_TYPE&#39; is required to be a POD as per the Standard, which makes
        // &#39;CHAR_TYPE&#39; bitwise-movable, so &#39;String_Imp&#39; is also
        // bitwise-movable.

    // CLASS METHODS
    static SIZE_TYPE computeNewCapacity(SIZE_TYPE newLength,
                                        SIZE_TYPE oldCapacity,
                                        SIZE_TYPE maxSize);
        // Compute and return the capacity required for a string having the
        // specified &#39;newLength&#39; and using the specified &#39;oldCapacity&#39; to
        // exercise an exponential capacity growth necessary to ensure the
        // amortized linear complexity of &#39;push_back&#39; and other operations and
        // ensuring that the new capacity does not exceed the specified
        // &#39;maxSize&#39;.  Note that the behavior is undefined unless
        // &#39;newLength &gt; oldCapacity&#39;, &#39;newLength &lt; maxSize&#39;, and
        // &#39;oldCapacity &lt; maxSize&#39;.

    // CREATORS
    String_Imp();
        // Create a &#39;String_Imp&#39; object having (default) attribute values
        // except that the &#39;d_capacity&#39; attribute is initialized with
        // &#39;SHORT_BUFFER_CAPACITY&#39;.

    String_Imp(SIZE_TYPE length, SIZE_TYPE capacity);
        // Create a &#39;String_Imp&#39; object and initialize the &#39;d_length&#39; and
        // &#39;d_capacity&#39; attributes with the specified &#39;length&#39; and specified
        // &#39;capacity&#39;, respectively.  If &#39;capacity&#39; is less than
        // &#39;SHORT_BUFFER_CAPACITY&#39;, then d_capacity is set to
        // &#39;SHORT_BUFFER_CAPACITY&#39;.  The value of the &#39;d_short&#39; and &#39;d_start_p&#39;
        // fields are left uninitialized.  &#39;basic_string&#39; is required to assign
        // either d_short or d_start_p to a proper value before using any
        // methods of this class.

    //! String_Imp(const String_Imp&amp; original) = default;
        // Create a &#39;String_Imp&#39; object having the same value as the specified
        // &#39;original&#39; object.  Note that this copy constructor is generated by
        // the compiler.

    //! ~String_Imp() = default;
        // Destroy this object.  Note that this destructor is generated by the
        // compiler.

    //! String_Imp&amp; operator=(const String_Imp&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that this assignment operator is generated by the compiler.

    // MANIPULATORS
    void swap(String_Imp&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.

    void resetFields();
        // Reset all fields of this object to their default-constructed state.

    CHAR_TYPE *dataPtr();
        // Return an address providing modifiable access to the NULL-terminated
        // C-string stored by this string object.  Note that the returned
        // address can point to either the internal short string buffer or the
        // externally allocated memory depending on the type of the string
        // defined by the return value of &#39;isShortString&#39;.

    // ACCESSORS
    bool isShortString() const;
        // Return &#39;true&#39; if this object contains a short string and the string
        // data is stored in the short string buffer, and &#39;false&#39; if the object
        // contains a long string (and the short string buffer contains a
        // pointer to the string data allocated externally).

    const CHAR_TYPE *dataPtr() const;
        // Return an address providing non-modifiable access to the
        // NULL-terminated C-string stored by this string object.  Note that
        // the returned address can point to either the internal short string
        // buffer or the externally allocated memory depending on the type of
        // the string defined by the return value of &#39;isShortString&#39;.
};

                        // =======================
                        // class bsl::basic_string
                        // =======================

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
class basic_string
    : private String_Imp&lt;CHAR_TYPE, typename ALLOCATOR::size_type&gt;
    , public BloombergLP::bslalg::ContainerBase&lt;ALLOCATOR&gt;
{
    // This class template provides an STL-compliant &#39;string&#39; that conforms to
    // the &#39;bslma::Allocator&#39; model.  For the requirements of a string class,
    // consult the second revision of the ISO/IEC 14882 Programming Language
    // C++ (2003).  Note that the parameterized &#39;CHAR_TYPE&#39; must be *equal* to
    // &#39;ALLOCATOR::value_type&#39;.  In addition, this implementation offers strong
    // exception guarantees (see below), with the general rules that:
    //
    //: 1 any method that would result in a string of length larger than the
    //:   size returned by &#39;max_size&#39; throws &#39;std::length_error&#39;, and
    //:
    //: 2 any method that attempts to access a position outside the valid range
    //:   of a string throws &#39;std::out_of_range&#39;.
    //
    // Circumstances where a method throws &#39;bsl::length_error&#39; (1) are clear
    // and not repeated in the individual function-level documentations below.
    //
    // More generally, this class supports an almost complete set of *in-core*
    // *value* *semantic* operations, including copy construction, assignment,
    // equality comparison (but excluding &#39;ostream&#39; printing since this
    // component is below STL).  A precise operational definition of when two
    // objects have the same value can be found in the description of
    // &#39;operator==&#39; for the class.  This class is *exception* *neutral* with
    // full guarantee of rollback: if an exception is thrown during the
    // invocation of a method on a pre-existing object, the object is left
    // unchanged.  In no event is memory leaked.
    //
    // Note that *aliasing* (e.g., using all or part of an object as both
    // source and destination) is supported in all cases in the public
    // interface of &#39;basic_string&#39;.  However, the private interface (&#39;...Raw&#39;
    // methods) should be assumed to be not alias-safe unless specifically
    // noted otherwise.

  public:
    // PUBLIC TYPES
    typedef CHAR_TRAITS                            traits_type;
    typedef typename CHAR_TRAITS::char_type        value_type;
    typedef ALLOCATOR                              allocator_type;
    typedef typename ALLOCATOR::size_type          size_type;
    typedef typename ALLOCATOR::difference_type    difference_type;
    typedef value_type&amp;                            reference;
    typedef const value_type&amp;                      const_reference;
    typedef typename ALLOCATOR::pointer            pointer;
    typedef typename ALLOCATOR::const_pointer      const_pointer;
    typedef CHAR_TYPE                             *iterator;
    typedef const CHAR_TYPE                       *const_iterator;
    typedef bsl::reverse_iterator&lt;iterator&gt;        reverse_iterator;
    typedef bsl::reverse_iterator&lt;const_iterator&gt;  const_reverse_iterator;
        // These types satisfy the &#39;ReversibleSequence&#39; requirements.

    // &#39;to_string&#39; functions are made friends to allow access to the internal
    // short string buffer.
    friend string to_string(int);
    friend string to_string(long);
    friend string to_string(long long);
    friend string to_string(unsigned);
    friend string to_string(unsigned long);
    friend string to_string(unsigned long long);

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
                      basic_string,
                      BloombergLP::bslmf::IsBitwiseMoveable,
                      BloombergLP::bslmf::IsBitwiseMoveable&lt;ALLOCATOR&gt;::value);
        // &#39;CHAR_TYPE&#39; is required to be a POD as per the Standard, which makes
        // &#39;CHAR_TYPE&#39; bitwise-movable, so &#39;basic_string&#39; is bitwise-movable as
        // long as the (template parameter) &#39;ALLOCATOR&#39; type is also
        // bitwise-movable.

  private:
    // PRIVATE TYPES
    typedef String_Imp&lt;CHAR_TYPE, typename ALLOCATOR::size_type&gt; Imp;

    // PRIVATE MANIPULATORS

    // Note: &#39;...Raw&#39; functions are low level private manipulators and they do
    // not perform checks for exceptions.  &#39;...Dispatch&#39; functions perform
    // overload selection for iterator types in order to resolve ambiguities
    // between template and non-template method overloads.

    CHAR_TYPE *privateAllocate(size_type numChars);
        // Allocate and return a buffer capable of holding the specified
        // &#39;numChars&#39; number of characters.

    void privateDeallocate();
        // Deallocate the internal string buffer, which was allocated with
        // &#39;privateAllocate&#39; and stored in &#39;String_Imp::d_start_p&#39; without
        // modifying any data members.

    void privateCopyFromOutOfPlaceBuffer(const basic_string&amp; original);
        // Copy the specified &#39;original&#39; string content into this string
        // object, assuming that the default copy constructor of the
        // &#39;String_Imp&#39; base class and the appropriate copy constructor of the
        // &#39;bslstl::ContainerBase&#39; base class have just been run.  The behavior
        // is undefined unless &#39;original&#39; holds an out-of-place representation
        // of a string.  Note that the out-of-place representation may be
        // short enough to fit into the small buffer storage.

    basic_string&amp; privateAppendDispatch(iterator begin,
                                        iterator end);
    basic_string&amp; privateAppendDispatch(const_iterator begin,
                                        const_iterator end);
    template &lt;class INPUT_ITER&gt;
    basic_string&amp; privateAppendDispatch(INPUT_ITER begin,
                                        INPUT_ITER end);
        // Match either &#39;iterator&#39;, &#39;const_iterator&#39;, or an arbitrary iterator
        // (which can also match an integral type).  In the first two cases,
        // use &#39;privateAppendRaw&#39;.  In the last case, forward to
        // &#39;privateReplaceDispatch&#39; to separate the integral type from iterator
        // types.  The behavior is undefined unless the specified &#39;begin&#39; and
        // &#39;end&#39; refer to a sequence of valid values where &#39;begin&#39; is at a
        // position at or before &#39;end&#39;.

    basic_string&amp; privateAssign(const CHAR_TYPE *characterString,
                                size_type        numChars);
        // Assign characters from the specified &#39;characterString&#39; array of
        // characters of the specified &#39;numChars&#39; length to this string
        // discarding the old content of the string, and return a reference
        // providing modifiable access to this string.  The behavior is
        // undefined unless &#39;numChars &lt;= max_size()&#39;, and the &#39;characterString&#39;
        // array is at least &#39;numChars&#39; long.

    basic_string&amp; privateAssign(size_type numChars,
                                CHAR_TYPE character);
        // Assign the specified &#39;numChars&#39; copies of the specified &#39;character&#39;
        // to this string discarding the old content of the string, and return
        // a reference providing modifiable access to this string.  The
        // behavior is undefined unless &#39;numChars &lt;= max_size()&#39;.

    basic_string&amp; privateAppendRaw(const CHAR_TYPE *characterString,
                                   size_type        numChars);
        // Append characters from the specified &#39;characterString&#39; array of
        // characters of the specified &#39;numChars&#39; length to this string, and
        // return a reference providing modifiable access to this string.  The
        // behavior is undefined unless &#39;numChars &lt;= max_size() - length()&#39;,
        // and the &#39;characterString&#39; array is at least &#39;numChars&#39; long.

    basic_string&amp; privateAppendRaw(size_type numChars,
                                   CHAR_TYPE character);
        // Append the specified &#39;numChars&#39; copies of the specified &#39;character&#39;
        // to this string.  Return a reference providing modifiable access to
        // this string.  The behavior is undefined unless and
        // &#39;numChars &lt;= max_size() - length()&#39;.

    Imp&amp; privateBase();
        // Return a reference providing modifiable access to the base object
        // of this string.

    void privateClear(bool deallocateBufferFlag);
        // Reset this string object to its default-constructed value and
        // deallocate its string buffer if the specified &#39;deallocateBufferFlag&#39;
        // is &#39;true&#39;.

    void privateInitDispatch(iterator begin,
                             iterator end);
    void privateInitDispatch(const_iterator begin,
                             const_iterator end);
        // Initialize this object with a string represented by the specified
        // &#39;begin&#39; and &#39;end&#39; iterators using the &#39;privateAppendRaw&#39; method for
        // the initialization.  The behavior is undefined unless &#39;begin&#39; and
        // &#39;end&#39; refer to a sequence of valid values where &#39;begin&#39; is at a
        // position at or before &#39;end&#39;.

    template &lt;class INPUT_ITER&gt;
    void privateInitDispatch(INPUT_ITER begin,
                             INPUT_ITER end);
        // Initialize this object with a string represented by the specified
        // &#39;begin&#39; and &#39;end&#39; iterators.  The behavior is undefined unless
        // &#39;begin&#39; and &#39;end&#39; refer to a sequence of valid values where &#39;begin&#39;
        // is at a position at or before &#39;end&#39;.  Note that since the
        // parameterized &#39;INPUT_ITER&#39; type can also resolve to an integral
        // type, use the &#39;privateReplaceDispatch&#39; to disambiguate between the
        // integral type and iterator types.

    void privateInsertDispatch(const_iterator position,
                               iterator       first,
                               iterator       last);
    void privateInsertDispatch(const_iterator position,
                               const_iterator first,
                               const_iterator last);
        // Insert into this object at the specified &#39;position&#39; a string
        // represented by the specified &#39;first&#39; and &#39;last&#39; iterators using the
        // &#39;privateInsertRaw&#39; method for insertion.  The behavior is undefined
        // unless &#39;first&#39; and &#39;last&#39; refer to a sequence of valid values where
        // &#39;first&#39; is at a position at or before &#39;last&#39;.

    template &lt;class INPUT_ITER&gt;
    void privateInsertDispatch(const_iterator position,
                               INPUT_ITER     first,
                               INPUT_ITER     last);
        // Insert into this object at the specified &#39;position&#39; a string
        // represented by the specified &#39;first&#39; and &#39;last&#39; iterators.  The
        // behavior is undefined unless &#39;first&#39; and &#39;last&#39; refer to a sequence
        // of valid values where &#39;first&#39; is at a position at or before &#39;last&#39;.
        // Note that since the parameterized &#39;INPUT_ITER&#39; type can also resolve
        // to an integral type, use the &#39;privateReplaceDispatch&#39; to
        // disambiguate between the integral type and iterator types.

    basic_string&amp; privateInsertRaw(size_type        outPosition,
                                   const CHAR_TYPE *characterString,
                                   size_type        numChars);
        // Insert into this object at the specified &#39;outPosition&#39; the specified
        // &#39;numChars&#39; starting at the specified &#39;characterString&#39;.  The
        // behavior is undefined unless and &#39;numChars &lt;= max_size() - length()&#39;
        // and &#39;characterString&#39; array is at least &#39;numChars&#39; long.  Note that
        // this method is alias-safe, i.e., it works correctly even if
        // &#39;characterString&#39; points into this string object.

    basic_string&amp; privateReplaceRaw(size_type        outPosition,
                                    size_type        outNumChars,
                                    const CHAR_TYPE *characterString,
                                    size_type        numChars);
        // Replace the specified &#39;outNumChars&#39; characters of this object
        // starting at the specified &#39;outPosition&#39; by the specified &#39;numChars&#39;
        // starting at the specified &#39;characterString&#39;, and return a reference
        // providing modifiable access to this string.  The behavior is
        // undefined unless &#39;outPosition &lt;= length()&#39;,
        // &#39;outNumChars &lt;= length()&#39;, &#39;outPosition &lt;= length() - outNumChars&#39;,
        // &#39;numChars &lt;= max_size()&#39;, and
        // &#39;length() - outNumChars &lt;= max_size() - numChars&#39;.  Note that this
        // method is alias-safe, i.e., it works correctly even if
        // &#39;characterString&#39; points into this string object.

    basic_string&amp; privateReplaceRaw(size_type outPosition,
                                    size_type outNumChars,
                                    size_type numChars,
                                    CHAR_TYPE character);
        // Replace the specified &#39;outNumChars&#39; characters of this string
        // starting at the specified &#39;outPosition&#39; by the specified &#39;numChars&#39;
        // copies of the specified &#39;character&#39;, and return a reference
        // providing modifiable access to this string.  The behavior is
        // undefined unless &#39;outPosition &lt;= length()&#39;,
        // &#39;outNumChars &lt;= length()&#39;, &#39;outPosition &lt;= length() - outNumChars&#39;
        // and &#39;length() &lt;= max_size() - numChars&#39;.

    template &lt;class INPUT_ITER&gt;
    basic_string&amp; privateReplaceDispatch(
                              size_type                               position,
                              size_type                               numChars,
                              INPUT_ITER                              first,
                              INPUT_ITER                              last,
                              BloombergLP::bslmf::MatchArithmeticType ,
                              BloombergLP::bslmf::Nil                 );
        // Match integral type for &#39;INPUT_ITER&#39;.

    template &lt;class INPUT_ITER&gt;
    basic_string&amp; privateReplaceDispatch(
                                     size_type                        position,
                                     size_type                        numChars,
                                     INPUT_ITER                       first,
                                     INPUT_ITER                       last,
                                     BloombergLP::bslmf::MatchAnyType ,
                                     BloombergLP::bslmf::MatchAnyType );
        // Match non-integral type for &#39;INPUT_ITER&#39;.

    template &lt;class INPUT_ITER&gt;
    basic_string&amp; privateReplace(size_type  position,
                                 size_type  numChars,
                                 INPUT_ITER first,
                                 INPUT_ITER last,
                                 std::input_iterator_tag);
        // Specialized replacement for input iterators, using repeated
        // &#39;push_back&#39; operations.

    template &lt;class INPUT_ITER&gt;
    basic_string&amp; privateReplace(size_type  position,
                                 size_type  numChars,
                                 INPUT_ITER first,
                                 INPUT_ITER last,
                                 std::forward_iterator_tag);
        // Specialized replacement for forward, bidirectional, and
        // random-access iterators.  Throw &#39;length_error&#39; if
        // &#39;length() - numChars &gt; max_size() - distance(first, last)&#39;.

    basic_string&amp; privateReplace(size_type      position,
                                 size_type      numChars,
                                 iterator       first,
                                 iterator       last,
                                 std::forward_iterator_tag);
    basic_string&amp; privateReplace(size_type      position,
                                 size_type      numChars,
                                 const_iterator first,
                                 const_iterator last,
                                 std::forward_iterator_tag);
        // Replace the specified &#39;numChars&#39; characters of this object starting
        // at the specified &#39;position&#39; with the string represented by the
        // specified &#39;first&#39; and &#39;last&#39; iterators.  The behavior is undefined
        // unless &#39;first&#39; and &#39;last&#39; refer to a sequence of valid values where
        // &#39;first&#39; is at a position at or before &#39;last&#39;.

    void privateReserveRaw(size_type newCapacity);
        // Update the capacity of this object to be a value greater than or
        // equal to the specified &#39;newCapacity&#39;.  The behavior is undefined
        // unless &#39;newCapacity &lt;= max_size()&#39;.  Note that a null-terminating
        // character is not counted in &#39;newCapacity&#39;, and that this method has
        // no effect unless &#39;newCapacity &gt; capacity()&#39;.

    CHAR_TYPE *privateReserveRaw(size_type *storage,
                                 size_type  newCapacity,
                                 size_type  numChars);
        // Update the capacity of this object and load into the specified
        // &#39;storage&#39; to be a value greater than or equal to the specified
        // &#39;newCapacity&#39;.  Upon reallocation, copy the first specified
        // &#39;numChars&#39; from the previous buffer to the new buffer, and load
        // &#39;storage&#39; with the new capacity.  If &#39;*storage &gt;= newCapacity&#39;, this
        // method has no effect.  Return the new buffer if reallocation, and 0
        // otherwise.  The behavior is undefined unless &#39;numChars &lt;= length()&#39;
        // and &#39;newCapacity &lt;= max_size()&#39;.  Note that a null-terminating
        // character is not counted in &#39;*storage&#39; nor &#39;newCapacity&#39;.  Also note
        // that the previous buffer is *not* deallocated, nor is the string
        // representation changed (in case the previous buffer may contain data
        // that must be copied): it is the responsibility of the caller to do
        // so upon reallocation.

    basic_string&amp; privateResizeRaw(size_type newLength, CHAR_TYPE character);
        // Change the length of this string to the specified &#39;newLength&#39;.  If
        // &#39;newLength &gt; length()&#39;, fill in the new positions by copies of the
        // specified &#39;character&#39;.  Do not change the capacity unless
        // &#39;newLength&#39; exceeds the current capacity.  The behavior is undefined
        // unless &#39;newLength &lt;= max_size()&#39;.

    // PRIVATE ACCESSORS
    int privateCompareRaw(size_type        lhsPosition,
                          size_type        lhsNumChars,
                          const CHAR_TYPE *other,
                          size_type        otherNumChars) const;
        // Lexicographically compare the substring of this string starting at
        // the specified &#39;lhsPosition&#39; of length &#39;lhsNumChars&#39; with the string
        // constructed from the specified &#39;numChars&#39; characters in the array
        // starting at the specified &#39;other&#39; address, and return a negative
        // value if this string is less than &#39;other&#39;, a positive value if it is
        // more than &#39;other&#39;, and 0 in case of equality.  The behavior is
        // undefined unless &#39;lhsPosition &lt;= length()&#39;,
        // &#39;lhsNumChars &lt;= length()&#39;, and
        // &#39;lhsPosition &lt;= length() - lhsNumChars&#39;.

    // INVARIANTS
    BSLMF_ASSERT((bsl::is_same&lt;CHAR_TYPE,
                               typename ALLOCATOR::value_type&gt;::value));
        // This is required by the C++ standard (23.1, clause 1).

  public:
    // PUBLIC CLASS DATA
    static const size_type npos = ~size_type(0);
        // Value used to denote &quot;not-a-position&quot;, guaranteed to be outside the
        // range &#39;[0 .. max_size()]&#39;.

    // CREATORS

                   // *** 21.3.2 construct/copy/destroy: ***

    explicit
    basic_string(const ALLOCATOR&amp; basicAllocator = ALLOCATOR());
        // Create an empty string.  Optionally specify the &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is not specified, a
        // default-constructed allocator is used.

    basic_string(const basic_string&amp; original);
    basic_string(const basic_string&amp; original,
                 const ALLOCATOR&amp;    basicAllocator);
        // Create a string that has the same value as the specified &#39;original&#39;
        // string.  Optionally specify the &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is not specified, then a
        // default-constructed allocator is used.  Note that it is important to
        // have two copy constructors instead of a single:
        //..
        //  basic_string(const basic_string&amp; original,
        //               const ALLCOATOR&amp;    basicAllocator = ALLOCATOR());
        //..
        // When the copy constructor with the default allocator is used, xlC10
        // get confused and refuses to use the return value optimization, which
        // then causes extra allocations when returning by value in
        // &#39;operator+&#39;.

    basic_string(BloombergLP::bslmf::MovableRef&lt;basic_string&gt; original);
    basic_string(BloombergLP::bslmf::MovableRef&lt;basic_string&gt; original,
                 const ALLOCATOR&amp;                             basicAllocator);
        // Create a string that has the same value as the specified &#39;original&#39;
        // string by moving the contents of &#39;original&#39; to the new string.
        // Optionally specify the &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is not specified, then a default-constructed
        // allocator is used.  &#39;original&#39; is left in a valid but unspecified
        // state.

    basic_string(const basic_string&amp; original,
                 size_type           position,
                 size_type           numChars = npos,
                 const ALLOCATOR&amp;    basicAllocator = ALLOCATOR());
        // Create a string that has the same value as the substring of the
        // optionally specified &#39;numChars&#39; length starting at the specified
        // &#39;position&#39; in the specified &#39;original&#39; string.  If &#39;numChars&#39; equals
        // &#39;npos&#39;, then the remaining length of the string is used (i.e.,
        // &#39;numChars&#39; is set to &#39;original.length() - position&#39;).  Optionally
        // specify the &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is not specified, a default-constructed allocator
        // is used.  Throw &#39;out_of_range&#39; if &#39;position &gt; original.length()&#39; or
        // &#39;numChars != npos&#39; and &#39;position + numChars &lt; original.length()&#39;.

    basic_string(const CHAR_TYPE  *characterString,
                 const ALLOCATOR&amp;  basicAllocator = ALLOCATOR());   // IMPLICIT
    basic_string(const CHAR_TYPE  *characterString,
                 size_type         numChars,
                 const ALLOCATOR&amp;  basicAllocator = ALLOCATOR());
        // Create a string that has the same value as the substring of the
        // optionally specified &#39;numChars&#39; length starting at the specified
        // &#39;position&#39; in the specified &#39;characterString&#39;.  If &#39;numChars&#39; is not
        // specified, &#39;CHAR_TRAITS::length(characterString)&#39; is used.
        // Optionally specify the &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is not specified, a default-constructed allocator
        // is used.  Throw &#39;out_of_range&#39; if &#39;numChars &gt;= npos&#39;.

    basic_string(size_type        numChars,
                 CHAR_TYPE        character,
                 const ALLOCATOR&amp; basicAllocator = ALLOCATOR());
        // Create a string of the specified &#39;numChars&#39; length whose every
        // position contains the specified &#39;character&#39;.  Optionally specify the
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is not
        // specified, a default-constructed allocator is used.

    template &lt;class INPUT_ITER&gt;
    basic_string(INPUT_ITER       first,
                 INPUT_ITER       last,
                 const ALLOCATOR&amp; basicAllocator = ALLOCATOR());
        // Create a string from the characters in the range starting at the
        // specified &#39;first&#39; and ending at the specified &#39;last&#39; iterators of
        // the parameterized &#39;INPUT_ITER&#39; type.  Optionally specify the
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is not
        // specified, a default-constructed allocator is used.  The behavior is
        // undefined unless &#39;first&#39; and &#39;last&#39; refer to a sequence of valid
        // values where &#39;first&#39; is at a position at or before &#39;last&#39;.

    template &lt;class ALLOC2&gt;
    basic_string(
        const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; original,
        const ALLOCATOR&amp; basicAllocator = ALLOCATOR());             // IMPLICIT
        // Create a string that has the same value as the specified &#39;original&#39;
        // string, where the type &#39;original&#39; is the string type native to the
        // compiler&#39;s library, instantiated with the same character type and
        // traits type, but not necessarily the same allocator type.  The
        // resulting string will contain the same sequence of characters as
        // &#39;original&#39;.  Optionally specify the &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is not specified, then a
        // default-constructed allocator is used.

    basic_string(const BloombergLP::bslstl::StringRefData&lt;CHAR_TYPE&gt;&amp; strRef,
                 const ALLOCATOR&amp; basicAllocator = ALLOCATOR());    // IMPLICIT
        // Create a string that has the same value as the specified &#39;strRef&#39;
        // string.  The resulting string will contain the same sequence of
        // characters as &#39;strRef&#39;.  Optionally specify the &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is not specified, then a
        // default-constructed allocator is used.

    ~basic_string();
        // Destroy this string object.

    // MANIPULATORS

                    // *** 21.3.2 construct/copy/destroy: ***

    basic_string&amp; operator=(const basic_string&amp; rhs);
        // Assign to this string the value of the specified &#39;rhs&#39; string, and
        // return a reference providing modifiable access to this object.

    basic_string&amp; operator=(BloombergLP::bslmf::MovableRef&lt;basic_string&gt; rhs);
        // Assign to this string the value of the specified &#39;rhs&#39; string, and
        // return a reference providing modifiable access to this object.
        // &#39;rhs&#39; is left in a valid but unspecified state.  No memory
        // allocation is performed if
        // &#39;this-&gt;get_allocator() == rhs.get_allocator()&#39;.

    basic_string&amp; operator=(const CHAR_TYPE *rhs);
        // Assign to this string the value of the specified &#39;rhs&#39; string, and
        // return a reference providing modifiable access to this object.

    basic_string&amp; operator=(CHAR_TYPE character);
        // Assign to this string the value of the string of length one
        // consisting of the specified &#39;character&#39;, and return a reference
        // providing modifiable access to this object.

                          // *** 21.3.4 capacity: ***

    void resize(size_type newLength, CHAR_TYPE character);
        // Change the length of this string to the specified &#39;newLength&#39;,
        // erasing characters at the end if &#39;newLength &lt; length()&#39; or appending
        // the appropriate number of copies of the specified &#39;character&#39; at the
        // end if &#39;length() &lt; newLength&#39;.

    void resize(size_type newLength);
        // Change the length of this string to the specified &#39;newLength&#39;,
        // erasing characters at the end if &#39;newLength &lt; length()&#39; or appending
        // the appropriate number of copies of &#39;CHAR_TYPE()&#39; at the end if
        // &#39;length() &lt; newLength&#39;.

    void reserve(size_type newCapacity = 0);
        // Change the capacity of this string to the specified &#39;newCapacity&#39;.
        // Note that the capacity of a string is the maximum length it can
        // accommodate without reallocation.  The actual storage allocated may
        // be higher.

    void clear();
        // Reset this string to an empty value.  Note that the capacity may
        // change (or not if &#39;BASIC_STRING_DEALLOCATE_IN_CLEAR&#39; is &#39;false&#39;).
        // Note that the Standard doesn&#39;t allow to reduce capacity on &#39;clear&#39;.

                          // *** 21.3.3 iterators: ***

    iterator begin();
        // Return an iterator referring to the first character in this
        // modifiable string (or the past-the-end iterator if this string is
        // empty).

    iterator end();
        // Return the past-the-end iterator for this modifiable string.

    reverse_iterator rbegin();
        // Return a reverse iterator referring to the last character in this
        // modifiable string (or the past-the-end reverse iterator if this
        // string is empty).

    reverse_iterator rend();
        // Return the past-the-end reverse iterator for this modifiable string.

                       // *** 21.3.5 element access: ***

    reference operator[](size_type position);
        // Return a reference providing modifiable access to the character at
        // the specified &#39;position&#39; in this string if &#39;position &lt; length()&#39;, or
        // a reference providing non-modifiable access to the null-terminating
        // character if &#39;position == length()&#39;.  The behavior is undefined
        // unless &#39;position &lt;= length()&#39;, and, in the case of
        // &#39;position == length()&#39;, the null-terminating character is not
        // modified through the returned reference.

    reference at(size_type position);
        // Return a reference providing modifiable access to the character at
        // the specified &#39;position&#39; in this string.  Throw &#39;out_of_range&#39; if
        // &#39;position &gt;= length()&#39;.

    CHAR_TYPE&amp; front();
        // Return a reference providing modifiable access to the character at
        // the first position in this string.  The behavior is undefined if
        // this string is empty.

    CHAR_TYPE&amp; back();
        // Return a reference providing modifiable access to the character at
        // the last position in this string.  The behavior is undefined if this
        // string is empty.  Note that the last position is &#39;length() - 1&#39;.

    template &lt;class ALLOC2&gt;
    operator native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;() const;
        // Convert this object to a string type native to the compiler&#39;s
        // library, instantiated with the same character type and traits type,
        // but not necessarily the same allocator type.  The return string will
        // contain the same sequence of characters as &#39;orig&#39; and will have a
        // default-constructed allocator.  Note that this conversion operator
        // can be invoked implicitly (e.g., during argument passing).

                         // *** 21.3.6 modifiers: ***

    basic_string&amp; operator+=(const basic_string&amp;  rhs);
    basic_string&amp; operator+=(const CHAR_TYPE     *rhs);
        // Append the specified &#39;rhs&#39; at the end of this string, and return a
        // reference providing modifiable access to this string.

    basic_string&amp; operator+=(CHAR_TYPE character);
        // Append the specified &#39;character&#39; at the end of this string, and
        // return a reference providing modifiable access to this string.

    basic_string&amp; operator+=(
                  const BloombergLP::bslstl::StringRefData&lt;CHAR_TYPE&gt;&amp; strRef);
        // Append the specified &#39;strRef&#39; at the end of this string.  Return a
        // reference providing modifiable access to this string.

    basic_string&amp; append(const basic_string&amp; suffix);
    basic_string&amp; append(const basic_string&amp; suffix,
                         size_type           position,
                         size_type           numChars);
        // Append at the end of this string the first specified &#39;numChars&#39;
        // characters starting at the specified &#39;position&#39; in the specified
        // &#39;suffix&#39;, or the tail of &#39;suffix&#39; starting at &#39;position&#39; if
        // &#39;position + numChars&#39; is larger than the length of &#39;suffix&#39;.  Return
        // a reference providing modifiable access to this string.  Throw
        // &#39;out_of_range&#39; if &#39;position &gt; suffix.length()&#39;.

    basic_string&amp; append(const CHAR_TYPE *characterString,
                         size_type        numChars);
        // Append at the end of this string the specified &#39;numChars&#39; characters
        // from the array starting at the specified &#39;characterString&#39; address,
        // and return a reference to this modifiable string.

    basic_string&amp; append(const CHAR_TYPE *characterString);
        // Append the specified &#39;characterString&#39; (of length
        // &#39;CHAR_TRAITS::length(characterString)&#39;) at the end of this string,
        // and return a reference providing modifiable access to this string.

    basic_string&amp; append(size_type numChars, CHAR_TYPE character);
        // Append a number equal to the specified &#39;numChars&#39; of copies of the
        // specified &#39;character&#39; at the end of this string, and return a
        // reference providing modifiable access to this string.

    template &lt;class INPUT_ITER&gt;
    basic_string&amp; append(INPUT_ITER first, INPUT_ITER last);
        // Append to the end of this string a string built from the characters
        // in the range starting at the specified &#39;first&#39; and ending before the
        // specified &#39;last&#39; iterators of the &#39;iterator&#39;, &#39;const_iterator&#39; or
        // parameterized &#39;INPUT_ITER&#39; type, respectively.  Return a reference
        // providing modifiable access to this string.  The behavior is
        // undefined unless &#39;first&#39; and &#39;last&#39; refer to a sequence of valid
        // values where &#39;first&#39; is at a position at or before &#39;last&#39;.

    void push_back(CHAR_TYPE   character);
        // Append the specified &#39;character&#39; at the end of this string.

    basic_string&amp; assign(const basic_string&amp; replacement);
        // Assign to this string the value of the specified &#39;replacement&#39;
        // string, and return a reference providing modifiable access to this
        // string.

    basic_string&amp; assign(
                     BloombergLP::bslmf::MovableRef&lt;basic_string&gt; replacement);
        // Assign to this string the value of the specified &#39;replacement&#39;
        // string, and return a reference providing modifiable access to this
        // string.  &#39;replacement&#39; is left in a valid but unspecified state.
        // If &#39;replacement&#39; and &#39;this&#39; have the same allocator then no
        // allocation will occur.

    basic_string&amp; assign(const basic_string&amp; replacement,
                         size_type           position,
                         size_type           numChars);
        // Assign to this string the value of the substring of the specified
        // &#39;numChars&#39; length or &#39;replacement.length() - position&#39;, whichever is
        // smaller, starting at the specified &#39;position&#39; in the specified
        // &#39;replacement&#39; string, and return a reference providing modifiable
        // access to this string.  Throw &#39;out_of_range&#39; if
        // &#39;position &gt; other.length()&#39;.

    basic_string&amp; assign(const CHAR_TYPE *characterString);
        // Assign to this string the value of the specified null-terminated
        // &#39;characterString&#39;, and return a reference providing modifiable
        // access to this string.

    basic_string&amp; assign(const CHAR_TYPE *characterString,
                         size_type        numChars);
        // Assign to this string the value of the string constructed from the
        // specified &#39;numChars&#39; characters in the array starting at the
        // specified &#39;characterString&#39; address, and return a reference
        // providing modifiable access to this string.

    basic_string&amp; assign(
                  const BloombergLP::bslstl::StringRefData&lt;CHAR_TYPE&gt;&amp; strRef);
        // Assign to this string the value of the specified &#39;strRef&#39; string,
        // and return a reference providing modifiable access to this string.

    basic_string&amp; assign(size_type numChars, CHAR_TYPE character);
        // Assign to this string the value of a string of the specified
        // &#39;numChars&#39; length whose every characters equal the specified
        // &#39;character&#39;, and return a reference providing modifiable access to
        // this string.

    template &lt;class INPUT_ITER&gt;
    basic_string&amp; assign(INPUT_ITER first, INPUT_ITER last);
        // Assign to this string the value of a string built from the
        // characters in the range starting at the specified &#39;first&#39; and ending
        // before the specified &#39;last&#39; iterators of the &#39;iterator&#39;,
        // &#39;const_iterator&#39; or parameterized &#39;INPUT_ITER&#39; type, respectively.
        // Return a reference providing modifiable access to this string.  The
        // behavior is undefined unless &#39;first&#39; and &#39;last&#39; refer to a sequence
        // of valid values where &#39;first&#39; is at a position at or before &#39;last&#39;.

    basic_string&amp; insert(size_type position, const basic_string&amp; other);
        // Insert at the specified &#39;position&#39; in this string a copy of the
        // specified &#39;other&#39; string, and return a reference providing
        // modifiable access to this string.  Throw &#39;out_of_range&#39; if
        // &#39;position &gt; length()&#39;.

    basic_string&amp; insert(size_type           outPosition,
                         const basic_string&amp; other,
                         size_type           position,
                         size_type           numChars);
        // Insert at the specified &#39;outPosition&#39; in this string a copy of the
        // substring of the specified &#39;numChars&#39; length or
        // &#39;other.length() - position&#39;, whichever is smaller, starting at the
        // specified &#39;position&#39; in the specified &#39;other&#39; string, and return a
        // reference providing modifiable access to this string.  Throw
        // &#39;out_of_range&#39; if &#39;position &gt; length()&#39;.

    basic_string&amp; insert(size_type        position,
                         const CHAR_TYPE *characterString,
                         size_type        numChars);
        // Insert at the specified &#39;position&#39; in this string a copy of the
        // string constructed from the specified &#39;numChars&#39; characters in the
        // array starting at the specified &#39;characterString&#39; address, and
        // return a reference providing modifiable access to this string.
        // Throw &#39;out_of_range&#39; if &#39;position &gt; length()&#39;.

    basic_string&amp; insert(size_type        position,
                         const CHAR_TYPE *characterString);
        // Insert at the specified &#39;position&#39; in this string a copy of the
        // string constructed from the specified &#39;characterString&#39; (of length
        // &#39;CHAR_TRAITS::length(characterString)&#39;), and return a reference
        // providing modifiable access to this string.  Throw &#39;out_of_range&#39; if
        // &#39;position &gt; length()&#39;.

    basic_string&amp; insert(size_type position,
                         size_type numChars,
                         CHAR_TYPE character);
        // Insert at the specified &#39;position&#39; in this string a number equal to
        // the specified &#39;numChars&#39; of copies of the specified &#39;character&#39;, and
        // return a reference providing modifiable access to this string.
        // Throw &#39;out_of_range&#39; if &#39;position &gt; length()&#39;.

    iterator insert(const_iterator position, CHAR_TYPE character);
        // Insert at the specified &#39;position&#39; in this string a copy of the
        // specified &#39;character&#39;, and return an iterator providing modifiable
        // access to the inserted character.  The behavior is undefined unless
        // &#39;position&#39; is a valid iterator on this string.

    iterator insert(const_iterator position,
                    size_type      numChars,
                    CHAR_TYPE      character);
        // Insert at the specified &#39;position&#39; in this string a specified
        // &#39;numChars&#39; number of copies of the specified &#39;character&#39;, and return
        // an iterator providing modifiable access to the first inserted
        // character, or a non-const copy of the &#39;position&#39; iterator, if
        // &#39;numChars == 0&#39;.  The behavior is undefined unless &#39;position&#39; is a
        // valid iterator on this string.

    template &lt;class INPUT_ITER&gt;
    iterator insert(const_iterator position,
                    INPUT_ITER     first,
                    INPUT_ITER     last);
        // Insert at the specified &#39;position&#39; in this string a string built
        // from the characters in the range starting at the specified &#39;first&#39;
        // and ending before the specified &#39;last&#39; iterators, and return an
        // iterator providing modifiable access to the first inserted
        // character, or a non-const copy of the &#39;position&#39; iterator, if
        // &#39;first == last&#39;.  The behavior is undefined unless &#39;position&#39; is a
        // valid iterator on this string, and &#39;first&#39; and &#39;last&#39; refer to a
        // sequence of valid values where &#39;first&#39; is at a position at or before
        // &#39;last&#39;.

    basic_string&amp; erase(size_type position = 0, size_type numChars = npos);
        // Erase from this string the substring of length the optionally
        // specified &#39;numChars&#39; or &#39;original.length() - position&#39;, whichever is
        // smaller, starting at the optionally specified &#39;position&#39;.  If
        // &#39;position&#39; is not specified, the first position is used (i.e.,
        // &#39;position&#39; is set to 0).  Return a reference providing modifiable
        // access to this string.  If &#39;numChars&#39; equals &#39;npos&#39;, then the
        // remaining length of the string is erased (i.e., &#39;numChars&#39; is set to
        // &#39;length() - position&#39;).  Throw &#39;out_of_range&#39; if
        // &#39;position &gt; length()&#39;.

    iterator erase(const_iterator position);
        // Erase a character at the specified &#39;position&#39; from this string, and
        // return an iterator providing modifiable access to the character at
        // &#39;position&#39; prior to erasing.  If no such character exists, return
        // &#39;end()&#39;.  The behavior is undefined unless &#39;position&#39; is within the
        // half-open range &#39;[cbegin() .. cend())&#39;.

    iterator erase(const_iterator first, const_iterator last);
        // Erase from this string a substring defined by the specified pair of
        // &#39;first&#39; and &#39;last&#39; iterators within this string.  Return an iterator
        // providing modifiable access to the the character at the &#39;last&#39;
        // position prior to erasing.  If no such character exists, return
        // &#39;end()&#39;.  This method invalidates existing iterators pointing to
        // &#39;first&#39; or a subsequent position.  The behavior is undefined unless
        // &#39;first&#39; and &#39;last&#39; are both within the range &#39;[cbegin() .. cend()]&#39;
        // and &#39;first &lt;= last&#39;.

    void pop_back();
        // Erase the last character from this string.  The behavior is
        // undefined if this string is empty.

    basic_string&amp; replace(size_type           outPosition,
                          size_type           outNumChars,
                          const basic_string&amp; replacement);
        // Replace the substring of this string starting at the specified
        // &#39;outPosition&#39; of length &#39;outNumChars&#39; or &#39;length() - outPosition&#39;,
        // whichever is smaller, by the specified &#39;replacement&#39;, and return a
        // reference providing modifiable access to this string.  Throw
        // &#39;out_of_range&#39; if &#39;outPosition &gt; length()&#39;.

    basic_string&amp; replace(size_type           outPosition,
                          size_type           outNumChars,
                          const basic_string&amp; replacement,
                          size_type           position,
                          size_type           numChars);
        // Replace the substring of this string starting at the specified
        // &#39;outPosition&#39; of length &#39;outNumChars&#39; or &#39;length() - outPosition&#39;,
        // whichever is smaller, by the substring of the specified &#39;numChars&#39;
        // length or &#39;replacement.length() - position&#39;, whichever is smaller,
        // starting at the specified &#39;position&#39; in the specified &#39;replacement&#39;.
        // Return a reference providing modifiable access to this string.
        // Throw &#39;out_of_range&#39; if &#39;outPosition &gt; length()&#39; or
        // &#39;position &gt; string.length()&#39;.

    basic_string&amp; replace(size_type        outPosition,
                          size_type        outNumChars,
                          const CHAR_TYPE *characterString,
                          size_type        numChars);
        // Replace the substring of this string starting at the specified
        // &#39;outPosition&#39; of length &#39;outNumChars&#39; or &#39;length() - outPosition&#39;,
        // whichever is smaller, by a copy of the string constructed from the
        // specified &#39;numChars&#39; characters in the array starting at the
        // specified &#39;characterString&#39; address.  Return a reference providing
        // modifiable access to this string.  Throw &#39;out_of_range&#39; if
        // &#39;outPosition &gt; length()&#39;.

    basic_string&amp; replace(size_type        outPosition,
                          size_type        outNumChars,
                          const CHAR_TYPE *characterString);
        // Replace the substring of this string starting at the specified
        // &#39;outPosition&#39; of length &#39;outNumChars&#39; or &#39;length() - outPosition&#39;,
        // whichever is smaller, by the null-terminated specified
        // &#39;characterString&#39; (of length
        // &#39;CHAR_TRAITS::length(characterString)&#39;).  Return a reference
        // providing modifiable access to this string.  Throw &#39;out_of_range&#39; if
        // &#39;outPosition &gt; length()&#39;.

    basic_string&amp; replace(size_type outPosition,
                          size_type outNumChars,
                          size_type numChars,
                          CHAR_TYPE character);
        // Replace the substring of this string starting at the specified
        // &#39;outPosition&#39; of length &#39;outNumChars&#39; or &#39;length() - outPosition&#39;,
        // whichever is smaller, by a number equal to the specified &#39;numChars&#39;
        // of copies of the specified &#39;character&#39;.  Return a reference
        // providing modifiable access to this string.  Throw &#39;out_of_range&#39; if
        // &#39;outPosition &gt; length()&#39;.

    basic_string&amp; replace(const_iterator      first,
                          const_iterator      last,
                          const basic_string&amp; replacement);
        // Replace the substring in the range starting at the specified &#39;first&#39;
        // position and ending right before the specified &#39;last&#39; position, by
        // the specified &#39;replacement&#39;.  Return a reference providing
        // modifiable access to this string.  The behavior is undefined unless
        // &#39;first&#39; and &#39;last&#39; are both within the range &#39;[cbegin() .. cend()]&#39;
        // and &#39;first &lt;= last&#39;.

    basic_string&amp; replace(const_iterator   first,
                          const_iterator   last,
                          const CHAR_TYPE *characterString,
                          size_type        numChars);
        // Replace the substring in the range starting at the specified &#39;first&#39;
        // position and ending right before the specified &#39;last&#39; position, by a
        // copy of the string constructed from the specified &#39;numChars&#39;
        // characters in the array starting at the specified &#39;characterString&#39;
        // address.  Return a reference providing modifiable access to this
        // string.  The behavior is undefined unless &#39;first&#39; and &#39;last&#39; are
        // both within the range &#39;[cbegin() .. cend()]&#39; and &#39;first &lt;= last&#39;.

    basic_string&amp; replace(const_iterator   first,
                          const_iterator   last,
                          const CHAR_TYPE *characterString);
        // Replace the substring in the range starting at the specified &#39;first&#39;
        // position and ending right before the specified &#39;last&#39; position, by
        // the null-terminated specified &#39;characterString&#39;.  Return a reference
        // providing modifiable access to this string.  The behavior is
        // undefined unless &#39;first&#39; and &#39;last&#39; are both within the range
        // &#39;[cbegin() .. cend()]&#39; and &#39;first &lt;= last&#39;.

    basic_string&amp; replace(const_iterator first,
                          const_iterator last,
                          size_type      numChars,
                          CHAR_TYPE      character);
        // Replace the substring in the range starting at the specified &#39;first&#39;
        // position and ending right before the specified &#39;last&#39; position, by a
        // number equal to the specified &#39;numChars&#39; of copies of the specified
        // &#39;character&#39;.  Return a reference providing modifiable access to this
        // string.  The behavior is undefined unless &#39;first&#39; and &#39;last&#39; are
        // both within the range &#39;[cbegin() .. cend()]&#39; and &#39;first &lt;= last&#39;.

    template &lt;class INPUT_ITER&gt;
    basic_string&amp; replace(const_iterator first,
                          const_iterator last,
                          INPUT_ITER     stringFirst,
                          INPUT_ITER     stringLast);
        // Replace the substring in the range starting at the specified &#39;first&#39;
        // position and ending right before the specified &#39;last&#39; position, by a
        // string built from the characters in the range starting at the
        // specified &#39;stringFirst&#39; and ending before the specified &#39;stringLast&#39;
        // iterators of the &#39;iterator&#39;, &#39;const_iterator&#39;, or parameterized
        // &#39;INPUT_ITER&#39; type, respectively.  Return a reference providing
        // modifiable access to this string.  The behavior is undefined unless
        // &#39;first&#39; and &#39;last&#39; are both within the range &#39;[cbegin() .. cend()]&#39;,
        // &#39;first &lt;= last&#39;, and &#39;[stringFirst .. stringLast)&#39; is a valid
        // iterator range.

    void swap(basic_string&amp; other);
        // Exchange the value of this string with that of the specified
        // &#39;string&#39;, so that the value of this string upon return equals that
        // of &#39;other&#39; prior to this call, and vice-versa.

    // ACCESSORS

                     // *** 21.3.3 iterators: ***

    const_iterator begin() const;
    const_iterator cbegin() const;
        // Return an iterator providing non-modifiable access to the first
        // character of this string (or the past-the-end iterator if this
        // string is empty).

    const_iterator end() const;
    const_iterator cend() const;
        // Return the past-the-end iterator for this string.

    const_reverse_iterator rbegin() const;
    const_reverse_iterator crbegin() const;
        // Return a reverse iterator providing non-modifiable access to the
        // last character of this string (or the past-the-end reverse iterator
        // if this string is empty).

    const_reverse_iterator rend() const;
    const_reverse_iterator crend() const;
        // Return the past-the-end reverse iterator for this string.

                          // *** 21.3.4 capacity: ***

    size_type length() const;
        // Return the length of this string.  Note that this number may differ
        // from &#39;CHAR_TRAITS::length(c_str())&#39; in case the string contains null
        // characters.  Also note that a null-terminating character added by
        // the &#39;c_str&#39; method is *not* counted in this length.

    size_type size() const;
        // Return the length of this string.  Note that this number may differ
        // from &#39;CHAR_TRAITS::length(c_str())&#39; in case the string contains null
        // characters.  Also note that a null-terminating character added by
        // the &#39;c_str&#39; method is *not* counted in this length.

    size_type max_size() const;
        // Return the maximal possible length of this string.  Note that
        // requests to create a string longer than this number of characters
        // are guaranteed to raise a &#39;length_error&#39; exception.

    size_type capacity() const;
        // Return the capacity of this string, i.e., the maximum length for
        // which resizing is guaranteed not to trigger a reallocation.

    bool empty() const;
        // Return &#39;true&#39; if this string has length 0, and &#39;false&#39; otherwise.

                       // *** 21.3.5 element access: ***

    const_reference operator[](size_type position) const;
        // Return a reference providing non-modifiable access to the character
        // at the specified &#39;position&#39; in this string.  The behavior is
        // undefined unless &#39;position &lt;= length()&#39;.  Note that if
        // &#39;position == length()&#39;, a reference to the null-terminating
        // character is returned.

    const_reference at(size_type position) const;
        // Return a reference providing non-modifiable access to the character
        // at the specified &#39;position&#39; in this string.  Throw &#39;out_of_range&#39; if
        // &#39;position &gt;= length()&#39;.

    const CHAR_TYPE&amp; front() const;
        // Return a reference providing non-modifiable access to the character
        // at the first position in this string.  The behavior is undefined if
        // this string is empty.

    const CHAR_TYPE&amp; back() const;
        // Return a reference providing non-modifiable access to the character
        // at the last position in this string.  The behavior is undefined if
        // this string is empty.  Note that the last position is
        // &#39;length() - 1&#39;.

    size_type copy(CHAR_TYPE *characterString,
                   size_type  numChars,
                   size_type  position = 0) const;
        // Copy the specified &#39;numChars&#39; or &#39;length() - position&#39;, whichever is
        // smaller, characters from this string into the specified
        // &#39;characterString&#39; buffer, and return the number of characters
        // copied.  Throw &#39;out_of_range&#39; if &#39;position &gt; length()&#39;.  Note that
        // the output &#39;characterString&#39; is *not* null-terminated.

                     // *** 21.3.7 string operations: ***

    const CHAR_TYPE *c_str() const;
        // Return an address providing non-modifiable access to the
        // null-terminated buffer of &#39;length() + 1&#39; characters whose contents
        // are identical to the value of this string.  Note that any call to
        // the string destructor or any of its manipulators invalidates the
        // returned pointer.

    const CHAR_TYPE *data() const;
        // Return an address providing non-modifiable access to the
        // null-terminated buffer of &#39;length()&#39; characters whose contents are
        // identical to the value of this string.  Note that any call to the
        // string destructor or any of its manipulators invalidates the
        // returned pointer.

    allocator_type get_allocator() const;
        // Return the allocator used by this string to supply memory.

    size_type find(const basic_string&amp; substring,
                   size_type           position = 0) const;
        // Return the starting position of the *first* occurrence of the
        // specified &#39;substring&#39;, if such a substring can be found in this
        // string (on or *after* the optionally specified &#39;position&#39; if such a
        // &#39;position&#39; is specified) using &#39;CHAR_TRAITS::eq&#39; to compare
        // characters, and return &#39;npos&#39; otherwise.

    size_type find(const CHAR_TYPE *substring,
                   size_type        position,
                   size_type        numChars) const;
    size_type find(const CHAR_TYPE *substring,
                   size_type        position = 0) const;
        // Return the starting position of the *first* occurrence of the
        // specified &#39;substring&#39; of the optionally specified &#39;numChars&#39; length,
        // if such a substring can be found in this string (on or *after* the
        // optionally specified &#39;position&#39; if such a &#39;position&#39; is specified)
        // using &#39;CHAR_TRAITS::eq&#39; to compare characters, and return &#39;npos&#39;
        // otherwise.  If &#39;numChars&#39; is not specified,
        // &#39;CHAR_TRAITS::length(substring)&#39; is used.

    size_type find(CHAR_TYPE character, size_type position = 0) const;
        // Return the position of the *first* occurrence of the specified
        // &#39;character&#39;, if such an occurrence can be found in this string (on
        // or *after* the optionally specified &#39;position&#39; if such a &#39;position&#39;
        // is specified), and return &#39;npos&#39; otherwise.

    size_type rfind(const basic_string&amp; substring,
                    size_type           position = npos) const;
        // Return the starting position of the *last* occurrence of the
        // specified &#39;substring&#39; within this string, if such a sequence can be
        // found in this string (on or *before* the optionally specified
        // &#39;position&#39; if such a &#39;position&#39; is specified) using
        // &#39;CHAR_TRAITS::eq&#39; to compare characters, and return &#39;npos&#39;
        // otherwise.

    size_type rfind(const CHAR_TYPE *characterString,
                    size_type        position,
                    size_type        numChars) const;
    size_type rfind(const CHAR_TYPE *characterString,
                    size_type        position = npos) const;
        // Return the starting position of the *last* occurrence of a substring
        // whose value equals that of the specified &#39;characterString&#39; of the
        // optionally specified &#39;numChars&#39; length, if such a substring can be
        // found in this string (on or *before* the optionally specified
        // &#39;position&#39; if such a &#39;position&#39; is specified), and return &#39;npos&#39;
        // otherwise.  If &#39;numChars&#39; is not specified,
        // &#39;CHAR_TRAITS::length(characterString)&#39; is used.

    size_type rfind(CHAR_TYPE character, size_type position = npos) const;
        // Return the position of the *last* occurrence of the specified
        // &#39;character&#39;, if such an occurrence can be found in this string (on
        // or *before* the optionally specified &#39;position&#39; if such a &#39;position&#39;
        // is specified), and return &#39;npos&#39; otherwise.

    size_type find_first_of(const basic_string&amp; characterString,
                            size_type           position = 0) const;
        // Return the position of the *first* occurrence of a character
        // belonging to the specified &#39;characterString&#39;, if such an occurrence
        // can be found in this string (on or *after* the optionally specified
        // &#39;position&#39; if such a &#39;position&#39; is specified), and return &#39;npos&#39;
        // otherwise.

    size_type find_first_of(const CHAR_TYPE *characterString,
                            size_type        position,
                            size_type        numChars) const;
    size_type find_first_of(const CHAR_TYPE *characterString,
                            size_type        position = 0) const;
        // Return the position of the *first* occurrence of a character
        // belonging to the specified &#39;characterString&#39; of the optionally
        // specified &#39;numChars&#39; length, if such an occurrence can be found in
        // this string (on or *after* the optionally specified &#39;position&#39; if
        // such a &#39;position&#39; is specified), and return &#39;npos&#39; otherwise.  If
        // &#39;numChars&#39; is not specified, &#39;CHAR_TRAITS::length(characterString)&#39;
        // is used.

    size_type find_first_of(CHAR_TYPE character,
                            size_type position = 0) const;
        // Return the position of the *first* occurrence of the specified
        // &#39;character&#39;, if such an occurrence can be found in this string (on
        // or *after* the optionally specified &#39;position&#39; if such a &#39;position&#39;
        // is specified), and return &#39;npos&#39; otherwise.

    size_type find_last_of(const basic_string&amp; characterString,
                           size_type           position = npos) const;
        // Return the position of the *last* occurrence of a character
        // belonging to the specified &#39;characterString&#39;, if such an occurrence
        // can be found in this string (on or *before* the optionally specified
        // &#39;position&#39; if such a &#39;position&#39; is specified), and return &#39;npos&#39;
        // otherwise.

    size_type find_last_of(const CHAR_TYPE *characterString,
                           size_type        position,
                           size_type        numChars) const;
    size_type find_last_of(const CHAR_TYPE *characterString,
                           size_type        position = npos) const;
        // Return the position of the *last* occurrence of a character
        // belonging to the specified &#39;characterString&#39; of the optionally
        // specified &#39;numChars&#39; length, if such an occurrence can be found in
        // this string (on or *before* the optionally specified &#39;position&#39; if
        // such a &#39;position&#39; is specified), and return &#39;npos&#39; otherwise.  If
        // &#39;numChars&#39; is not specified, &#39;CHAR_TRAITS::length(characterString)&#39;
        // is used.

    size_type find_last_of(CHAR_TYPE character,
                           size_type position = npos) const;
        // Return the position of the *last* occurrence of the specified
        // &#39;character&#39;, if such an occurrence can be found in this string (on
        // or *before* the optionally specified &#39;position&#39; if such a &#39;position&#39;
        // is specified), and return &#39;npos&#39; otherwise.

    size_type find_first_not_of(const basic_string&amp; characterString,
                                size_type           position = 0) const;
        // Return the position of the *first* occurrence of a character *not*
        // belonging to the specified &#39;characterString&#39;, if such an occurrence
        // can be found in this string (on or *after* the optionally specified
        // &#39;position&#39; if such a &#39;position&#39; is specified), and return &#39;npos&#39;
        // otherwise.

    size_type find_first_not_of(const CHAR_TYPE *characterString,
                                size_type        position,
                                size_type        numChars) const;
    size_type find_first_not_of(const CHAR_TYPE *characterString,
                                size_type        position = 0) const;
        // Return the position of the *first* occurrence of a character *not*
        // belonging to the specified &#39;characterString&#39; of the optionally
        // specified &#39;numChars&#39; length, if such an occurrence can be found in
        // this string (on or *after* the optionally specified &#39;position&#39; if
        // such a &#39;position&#39; is specified), and return &#39;npos&#39; otherwise.  If
        // &#39;numChars&#39; is not specified, &#39;CHAR_TRAITS::length(characterString)&#39;
        // is used.

    size_type find_first_not_of(CHAR_TYPE character,
                                size_type position = 0) const;
        // Return the position of the *first* occurrence of a character
        // *different* from the specified &#39;character&#39;, if such an occurrence
        // can be found in this string (on or *after* the optionally specified
        // &#39;position&#39; if such a &#39;position&#39; is specified), and return &#39;npos&#39;
        // otherwise.

    size_type find_last_not_of(const basic_string&amp; characterString,
                               size_type           position = npos) const;
        // Return the position of the *last* occurrence of a character *not*
        // belonging to the specified &#39;characterString&#39;, if such an occurrence
        // can be found in this string (on or *before* the optionally specified
        // &#39;position&#39; if such a &#39;position&#39; is specified), and return &#39;npos&#39;
        // otherwise.

    size_type find_last_not_of(const CHAR_TYPE *characterString,
                               size_type        position,
                               size_type        numChars) const;
    size_type find_last_not_of(const CHAR_TYPE *characterString,
                               size_type        position = npos) const;
        // Return the position of the *last* occurrence of a character *not*
        // belonging to the specified &#39;characterString&#39; of the optionally
        // specified &#39;numChars&#39; length, if such an occurrence can be found in
        // this string (on or *before* the optionally specified &#39;position&#39; if
        // such a &#39;position&#39; is specified), and return &#39;npos&#39; otherwise.  If
        // &#39;numChars&#39; is not specified, &#39;CHAR_TRAITS::length(characterString)&#39;
        // is used.

    size_type find_last_not_of(CHAR_TYPE character,
                               size_type position = npos) const;
        // Return the position of the *last* occurrence of a character
        // *different* from the specified &#39;character&#39;, if such an occurrence
        // can be found in this string (on or *before* the optionally specified
        // &#39;position&#39; if such a &#39;position&#39; is specified), and return &#39;npos&#39;
        // otherwise.

    basic_string substr(size_type position = 0,
                        size_type numChars = npos) const;
        // Return a string whose value is the substring  starting at the
        // optionally specified &#39;position&#39; in this string, of length the
        // optionally specified &#39;numChars&#39; or &#39;length() - position&#39;, whichever
        // is smaller.  If &#39;position&#39; is not specified, 0 is used (i.e., the
        // substring is from the beginning of this string).  If &#39;numChars&#39; is
        // not specified, &#39;npos&#39; is used (i.e., the entire suffix from
        // &#39;position&#39; to the end of the string is returned).

    int compare(const basic_string&amp; other) const;
        // Lexicographically compare this string with the specified &#39;other&#39;
        // string (using &#39;CHAR_TRAITS::lt&#39; to compare characters), and return a
        // negative value if this string is less than &#39;other&#39;, a positive value
        // if it is more than &#39;other&#39;, and 0 in case of equality.  See
        // &quot;Lexicographical Comparisons&quot; for definitions.

    int compare(size_type           position,
                size_type           numChars,
                const basic_string&amp; other) const;
        // Lexicographically compare the substring of this string starting at
        // the specified &#39;lhsPosition&#39; of length &#39;lhsNumChars&#39; or &#39;length() -
        // lhsPosition&#39;, whichever is smaller, with the specified &#39;other&#39;
        // string (using &#39;CHAR_TRAITS::lt&#39; to compare characters), and return a
        // negative value if this string is less than &#39;other&#39;, a positive value
        // if it is more than &#39;other&#39;, and 0 in case of equality.  See
        // &quot;Lexicographical Comparisons&quot; for definitions.

    int compare(size_type           lhsPosition,
                size_type           lhsNumChars,
                const basic_string&amp; other,
                size_type           otherPosition,
                size_type           otherNumChars) const;
        // Lexicographically compare the substring of this string starting at
        // the specified &#39;lhsPosition&#39; of length &#39;lhsNumChars&#39; or
        // &#39;length() - lhsPosition&#39;, whichever is smaller, with the substring
        // of the specified &#39;other&#39; string starting at the specified
        // &#39;otherPosition&#39; of length &#39;otherNumChars&#39; or
        // &#39;length() - otherPosition&#39;, whichever is smaller, (using
        // &#39;CHAR_TRAITS::lt&#39; to compare characters), and return a negative
        // value if this string is less than &#39;other&#39;, a positive value if it is
        // more than &#39;other&#39;, and 0 in case of equality.  Throw &#39;out_of_range&#39;
        // if &#39;lhsPosition &gt; length()&#39; or &#39;otherPosition &gt; other.length()&#39;.
        // See &quot;Lexicographical Comparisons&quot; for definitions.

    int compare(const CHAR_TYPE *other) const;
        // Lexicographically compare this string with the null-terminated
        // specified &#39;other&#39; string (of length &#39;CHAR_TRAITS::length(other)&#39;,
        // using &#39;CHAR_TRAITS::lt&#39; to compare characters), and return a
        // negative value if this string is less than &#39;other&#39;, a positive value
        // if it is more than &#39;other&#39;, and 0 in case of equality.  See
        // &quot;Lexicographical Comparisons&quot; for definitions.

    int compare(size_type        lhsPosition,
                size_type        lhsNumChars,
                const CHAR_TYPE *other,
                size_type        otherNumChars) const;
        // Lexicographically compare the substring of this string starting at
        // the specified &#39;lhsPosition&#39; of length &#39;lhsNumChars&#39; or
        // &#39;length() - lhsPosition&#39;, whichever is smaller, with the string
        // constructed from the specified &#39;numChars&#39; characters in the array
        // starting at the specified &#39;other&#39; address, and return a negative
        // value if this string is less than &#39;other&#39;, a positive value if it is
        // more than &#39;other&#39;, and 0 in case of equality.  Throw &#39;out_of_range&#39;
        // if &#39;lhsPosition &gt; length()&#39;.  See &quot;Lexicographical Comparisons&quot; for
        // definitions.

    int compare(size_type        lhsPosition,
                size_type        lhsNumChars,
                const CHAR_TYPE *other) const;
        // Lexicographically compare the substring of this string starting at
        // the specified &#39;lhsPosition&#39; of length &#39;lhsNumChars&#39; or
        // &#39;length() - lhsPosition&#39;, whichever is smaller, with the
        // null-terminated specified &#39;other&#39; string (of length
        // &#39;CHAR_TRAITS::length(other)&#39;, using &#39;CHAR_TRAITS::lt&#39; to compare
        // characters), and return a negative value if this string is less than
        // &#39;other&#39;, a positive value if it is more than &#39;other&#39;, and 0 in case
        // of equality.  Throw &#39;out_of_range&#39; if &#39;lhsPosition &gt; length()&#39;.  See
        // &quot;Lexicographical Comparisons&quot; for definitions.
};

// FREE OPERATORS
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator==(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator==(const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
           const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator==(const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
           const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator==(const CHAR_TYPE                                  *lhs,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator==(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                const CHAR_TYPE                                  *rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; string has the same value as the
    // specified &#39;rhs&#39; string, and &#39;false&#39; otherwise.  Two strings have the
    // same value if they have the same length, and the characters at each
    // respective position have the same value according to &#39;CHAR_TRAITS::eq&#39;.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator!=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator!=(const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
           const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator!=(const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
           const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator!=(const CHAR_TYPE                                  *lhs,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator!=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                const CHAR_TYPE                                  *rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; string has a different value from
    // the specified &#39;rhs&#39; string, and &#39;false&#39; otherwise.  Two strings have the
    // same value if they have the same length, and the characters at each
    // respective position have the same value according to &#39;CHAR_TRAITS::eq&#39;.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&lt;(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
               const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator&lt;(const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
          const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator&lt;(const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
          const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&lt;(const CHAR_TYPE                                  *lhs,
               const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&lt;(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
               const CHAR_TYPE                                  *rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; string has a lexicographically
    // smaller value than the specified &#39;rhs&#39; string, and &#39;false&#39; otherwise.
    // See &quot;Lexicographical Comparisons&quot; for definitions.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&gt;(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; lhs,
               const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator&gt;(const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
          const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator&gt;(const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
          const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&gt;(const CHAR_TYPE                                  *lhs,
               const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&gt;(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
               const CHAR_TYPE                                  *rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; string has a lexicographically
    // larger value than the specified &#39;rhs&#39; string, and &#39;false&#39; otherwise.
    // See &quot;Lexicographical Comparisons&quot; for definitions.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&lt;=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator&lt;=(const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
           const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator&lt;=(const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
           const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&lt;=(const CHAR_TYPE                                  *lhs,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&lt;=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                const CHAR_TYPE                                  *rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; string has a value
    // lexicographically smaller than or or equal to the specified &#39;rhs&#39;
    // string, and &#39;false&#39; otherwise.  See &quot;Lexicographical Comparisons&quot; for
    // definitions.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&gt;=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator&gt;=(const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
           const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
operator&gt;=(const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
           const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&gt;=(const CHAR_TYPE                                  *lhs,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool operator&gt;=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                const CHAR_TYPE                                  *rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; string has a value
    // lexicographically larger than or equal to the specified &#39;rhs&#39; string,
    // and &#39;false&#39; otherwise.  See &quot;Lexicographical Comparisons&quot; for
    // definitions.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
operator+(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;  lhs,
          const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;
operator+(const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
          const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;
operator+(const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
          const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
operator+(const CHAR_TYPE                                      *lhs,
          const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
operator+(CHAR_TYPE                                             lhs,
          const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;  rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
operator+(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;  lhs,
          const CHAR_TYPE                                      *rhs);
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
operator+(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;  lhs,
          CHAR_TYPE                                             rhs);
    // Return the concatenation of strings constructed from the specified &#39;lhs&#39;
    // and &#39;rhs&#39; arguments, i.e., &#39;basic_string(lhs).append(rhs)&#39;.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
operator&lt;&lt;(std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;          os,
           const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp; str);
    // Write the string specified by &#39;str&#39; into the output stream specified by
    // &#39;os&#39; and return &#39;os&#39;.  If the string is shorter than &#39;os.width()&#39;, then
    // it is padded to &#39;os.width()&#39; with the current &#39;os.fill()&#39; character.
    // The padding, if any, is output after the string (on the right) if
    // &#39;os.flags() | ios::left&#39; is non-zero and before the string otherwise.
    // This function will do nothing unless &#39;os.good()&#39; is true on entry.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
operator&gt;&gt;(std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;     is,
           basic_string&lt;CHAR_TYPE,CHAR_TRAITS, ALLOCATOR&gt;&amp; str);
    // Replace the contents of the specified &#39;str&#39; string with a word read from
    // the specified &#39;is&#39; input stream and return &#39;is&#39;.  The word begins at the
    // first non-whitespace character on the input stream and ends when another
    // whitespace character (or eof) is found.  The trailing whitespace
    // character is left on the input stream.  If &#39;is.good()&#39; is not true on
    // entry or if eof is found before any non-whitespace characters, then
    // &#39;str&#39; is unchanged and &#39;is.fail()&#39; is becomes true.  If eof is detected
    // after some characters have been read into &#39;str&#39;, then &#39;is.eof()&#39; becomes
    // true, but &#39;is.fail()&#39; does not.

// FREE FUNCTIONS
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
void swap(basic_string&lt;CHAR_TYPE,CHAR_TRAITS, ALLOCATOR&gt;&amp; lhs,
          basic_string&lt;CHAR_TYPE,CHAR_TRAITS, ALLOCATOR&gt;&amp; rhs);
    // Exchange the values of the specified &#39;lhs&#39; and &#39;rhs&#39; strings in constant
    // time without throwing an exception.  The behavior is undefined unless
    // &#39;lhs.get_allocator() == rhs.get_allocator()&#39;.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
getline(std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;     is,
        basic_string&lt;CHAR_TYPE,CHAR_TRAITS, ALLOCATOR&gt;&amp; str,
        CHAR_TYPE                                       delim);
    // Replace the contents of the specified &#39;str&#39; string by extracting
    // characters from the specified &#39;is&#39; stream until the specified &#39;delim&#39;
    // character is extracted and return &#39;is&#39;.  The &#39;delim&#39; character is
    // removed from the input stream but is not appended to &#39;str&#39;.  If an &#39;eof&#39;
    // is detected before &#39;delim&#39;, then the characters up to the &#39;eof&#39; are put
    // into &#39;str&#39; and &#39;is.eof()&#39; becomes true.  If &#39;is.good()&#39; is false on
    // entry, then do nothing, otherwise if no characters are extracted (e.g.,
    // because because the stream is at eof), &#39;str&#39; will become empty and
    // &#39;is.fail()&#39; will become true.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
getline(std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;     is,
        basic_string&lt;CHAR_TYPE,CHAR_TRAITS, ALLOCATOR&gt;&amp; str);
    // Replace the contents of the specified &#39;str&#39; string by extracting
    // characters from the specified &#39;is&#39; stream until a newline character
    // (is.widen(&#39;\n&#39;) is extracted and return &#39;is&#39;.  The newline character is
    // removed from the input stream but is not appended to &#39;str&#39;.  If an &#39;eof&#39;
    // is detected before the newline, then the characters up to the &#39;eof&#39; are
    // put into &#39;str&#39; and &#39;is.eof()&#39; becomes true.  If &#39;is.good()&#39; is false on
    // entry, then do nothing, otherwise if no characters are extracted (e.g.,
    // because because the stream is at eof), &#39;str&#39; will become empty and
    // &#39;is.fail()&#39; will become true.

int  stoi(const string&amp;  str, std::size_t* pos = 0, int base = 10);
int  stoi(const wstring&amp; str, std::size_t* pos = 0, int base = 10);
long stol(const string&amp;  str, std::size_t* pos = 0, int base = 10);
long stol(const wstring&amp; str, std::size_t* pos = 0, int base = 10);
unsigned long stoul(const string&amp;  str, std::size_t* pos = 0, int base = 10);
unsigned long stoul(const wstring&amp; str, std::size_t* pos = 0, int base = 10);

#if !(defined(BSLS_PLATFORM_CMP_MSVC) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &lt; 1800)
long long stoll(const string&amp;  str, std::size_t* pos = 0, int base = 10);
long long stoll(const wstring&amp; str, std::size_t* pos = 0, int base = 10);
unsigned long long stoull(const string&amp;   str,
                          std::size_t    *pos = 0,
                          int             base = 10);
unsigned long long stoull(const wstring&amp;  str,
                          std::size_t    *pos = 0,
                          int             base = 10);
#endif
    // Parses &#39;str&#39; interpreting its content as an integral number. Optionally
    // specify &#39;pos&#39; whose value is set to the position of the next character
    // after the numerical value.  Optionally specify &#39;base&#39; used to change the
    // interpretation of &#39;str&#39; to a integral number written in the specified
    // &#39;base&#39;.  Valid bases are in the range of [0,35] where base 0
    // automatically determines the base of the string; The base will be 16 if
    // the number is prefixed with &#39;0x&#39; or &#39;0X&#39;, base 8 if the number is
    // prefixed with a &#39;0&#39; and base 10 otherwise.  The function ignores leading
    // white space characters and interprets as many characters possible to
    // form a valid base n integral number.  If no conversion could be
    // performed, then an invalid_argument exception is thrown.  If the value
    // read is out of range of the return type, then an out_of_range exception
    // is thrown.

float  stof(const string&amp;  str, std::size_t* pos =0);
float  stof(const wstring&amp; str, std::size_t* pos =0);
double stod(const string&amp;  str, std::size_t* pos =0);
double stod(const wstring&amp; str, std::size_t* pos =0);

#if !(defined(BSLS_PLATFORM_CMP_MSVC) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &lt; 1800)
long double stold(const string&amp;  str, std::size_t* pos =0);
long double stold(const wstring&amp; str, std::size_t* pos =0);
#endif
    // Parses &#39;str&#39; interpreting its contents as a floating point number. In
    // C++11 if the number in &#39;str&#39; is prefixed with &#39;0x&#39; or &#39;0X&#39; the string
    // will be interpreted as a hex number.  If there is no leading 0x or 0X
    // the string will be interpreted as a decimal number.  Optionally specify
    // &#39;pos&#39; whose value is set to the position of the next character after the
    // numerical value.  The function ignores leading white space characters
    // and interprets as many characters possible to form a valid floating
    // point number.  If no conversion could be performed, then an
    // &#39;invalid_argument&#39; exception is thrown.  If the value read is out of
    // range of the return type, then an out_of_range exception is thrown.

string to_string(int value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::sprintf(buf,&quot;%d&quot;, value)&#39; would produce with a sufficiently large
    // buffer.
string to_string(long value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::sprintf(buf,&quot;%ld&quot;, value)&#39; would produce with a sufficiently large
    // buffer.
string to_string(long long value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::sprintf(buf,&quot;%lld&quot;, value)&#39; would produce with a sufficiently
    // large buffer.
string to_string(unsigned value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::sprintf(buf,&quot;%u&quot;, value)&#39; would produce with a sufficiently large
    // buffer.
string to_string(unsigned long value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::sprintf(buf,&quot;%lu&quot;, value)&#39; would produce with a sufficiently large
    // buffer.
string to_string(unsigned long long value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::sprintf(buf,&quot;%llu&quot;, value)&#39; would produce with a sufficiently
    // large buffer.
string to_string(float value);
string to_string(double value);
    // converts a floating point value to a string with the same contents as
    // what &#39;std::sprintf(buf, &quot;%f&quot;, value)&#39; would produce for a suficiently
    // large buffer.
string to_string(long double value);
    // converts a floating point value to a string with the same contents as
    // what &#39;std::sprintf(buf, &quot;%Lf&quot;, value)&#39; would produce for a suficiently
    // large buffer.

wstring to_wstring(int value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::swprintf(buf,L&quot;%d&quot;, value)&#39; would produce with a sufficiently
    // large buffer.
wstring to_wstring(long value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::swprintf(buf,L&quot;%ld&quot;, value)&#39; would produce with a sufficiently
    // large buffer.
wstring to_wstring(long long value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::swprintf(buf,L&quot;%lld&quot;, value)&#39; would produce with a sufficiently
    // large buffer.
wstring to_wstring(unsigned value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::swprintf(buf,L&quot;%u&quot;, value)&#39; would produce with a sufficiently
    // large buffer.
wstring to_wstring(unsigned long value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::swprintf(buf,L&quot;%lu&quot;, value)&#39; would produce with a sufficiently
    // large buffer.
wstring to_wstring(unsigned long long value);
    // Constructs a string with contents equal to the specified &#39;value&#39;. The
    // contents of the string will be the same as what
    // &#39;std::swprintf(buf,L&quot;%llu&quot;, value)&#39; would produce with a sufficiently
    // large buffer.
wstring to_wstring(float value);
wstring to_wstring(double value);
    // converts a floating point value to a string with the same contents as
    // what &#39;std::sprintf(buf, sz, L&quot;%f&quot;, value)&#39; would produce for a
    // suficiently large buffer.
wstring to_wstring(long double value);
    // converts a floating point value to a string with the same contents as
    // &#39;what std::sprintf(buf, sz, L&quot;%Lf&quot;, value)&#39; would produce for a
    // suficiently large buffer.

enum MaxDecimalStringLengths{
    // This &#39;enum&#39; give upper bounds on the maximum string lengths storing each
    // scalar numerical type.  It is safe to use stack-allocated buffers of
    // these sizes for generating decimal representations of the corresponding
    // type, including sign and terminating null character, using the default
    // precision of 6 significant digits for floating point types.

    e_MAX_SHORT_STRLEN10      = 2 + sizeof(short) * 3,
    e_MAX_INT_STRLEN10        = 2 + sizeof(int) * 3,
    e_MAX_INT64_STRLEN10      = 26,
    e_MAX_FLOAT_STRLEN10      = 48,
    e_MAX_DOUBLE_STRLEN10     = 318,
    e_MAX_LONGDOUBLE_STRLEN10 = 318,
    e_MAX_SCALAR_STRLEN10     = e_MAX_INT64_STRLEN10
};

// HASH SPECIALIZATIONS
template &lt;class HASHALG, class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
void hashAppend(HASHALG&amp; hashAlg,
                const basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOCATOR&gt;&amp;  input);
    // Pass the specified &#39;input&#39; string to the specified &#39;hashAlg&#39; hashing
    // algorithm of (template parameter) type &#39;HASHALG&#39;.

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
std::size_t
hashBasicString(const basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOCATOR&gt;&amp; str);
    // Return a hash value for the specified &#39;str&#39;.

std::size_t hashBasicString(const string&amp; str);
    // Return a hash value for the specified &#39;str&#39;.

std::size_t hashBasicString(const wstring&amp; str);
    // Return a hash value for the specified &#39;str&#39;.

}  // close namespace bsl

namespace BloombergLP {
namespace bslh {

template &lt;class HASHALG, class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
void hashAppend(
    HASHALG&amp;                                                           hashAlg,
    const native_std::basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOCATOR&gt;&amp; input);
    // Pass the specified &#39;input&#39; string to the specified &#39;hashAlg&#39; hashing
    // algorithm of (template parameter) type &#39;HASHALG&#39;.  Note that this
    // function violates the BDE coding standard, adding a function for a
    // namespace for a different package, and none of the function parameters
    // are from this package either.  This is necessary in order to provide an
    // implementation of &#39;bslh::hashAppend&#39; for the (native) standard library
    // &#39;string&#39; type as we are not allowed to add overloads directly into
    // namespace &#39;std&#39;, and this component essentially provides the interface
    // between &#39;bsl&#39; and &#39;std&#39; string types.

}  // close namespace bslh
}  // close enterprise namespace

// ============================================================================
//                       FUNCTION TEMPLATE DEFINITIONS
// ============================================================================
// See IMPLEMENTATION NOTES in the &#39;.cpp&#39; before modifying anything below.

namespace bsl {
                          // ----------------
                          // class String_Imp
                          // ----------------

// CLASS METHODS
template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
SIZE_TYPE
String_Imp&lt;CHAR_TYPE, SIZE_TYPE&gt;::computeNewCapacity(SIZE_TYPE newLength,
                                                     SIZE_TYPE oldCapacity,
                                                     SIZE_TYPE maxSize)
{
    BSLS_ASSERT_SAFE(newLength &gt;= oldCapacity);

    SIZE_TYPE newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        // We must exercise an exponential growth, otherwise we cannot
        // guarantee amortized time for &#39;append&#39;, &#39;insert&#39;, &#39;push_back&#39;,
        // &#39;replace&#39;, etc.  1.5 growth factor helps to reuse previously
        // allocated and freed memory blocks on frequent re-allocations due to
        // a continuous string growth (for example, when calling &#39;push_back&#39; in
        // a loop).
        //
        // TBD: consider bounding the exponential growth when &#39;newCapacity&#39; is
        // about several megabytes.

    if (newLength &gt; newCapacity) {
        newCapacity = newLength;
    }

    if (newCapacity &lt; oldCapacity || newCapacity &gt; maxSize) {  // overflow
        newCapacity = maxSize;
    }

    return newCapacity;
}

// CREATORS
template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
String_Imp&lt;CHAR_TYPE, SIZE_TYPE&gt;::String_Imp()
: d_start_p(0)
, d_length(0)
, d_capacity(SHORT_BUFFER_CAPACITY)
{
}

template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
String_Imp&lt;CHAR_TYPE, SIZE_TYPE&gt;::String_Imp(SIZE_TYPE length,
                                             SIZE_TYPE capacity)
: d_start_p(0)
, d_length(length)
, d_capacity(capacity &lt;= static_cast&lt;SIZE_TYPE&gt;(SHORT_BUFFER_CAPACITY)
                      ?  static_cast&lt;SIZE_TYPE&gt;(SHORT_BUFFER_CAPACITY)
                      :  capacity)
{
}

// MANIPULATORS
template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
void String_Imp&lt;CHAR_TYPE, SIZE_TYPE&gt;::swap(String_Imp&amp; other)
{
    if (!isShortString() &amp;&amp; !other.isShortString()) {
        // If both strings are long, swap the individual fields.
        std::swap(d_length,   other.d_length);
        std::swap(d_capacity, other.d_capacity);
        std::swap(d_start_p,  other.d_start_p);
    }
    else {
        // Otherwise bitwise-swap the whole objects (relies on the
        // BitwiseMoveable type trait).
        BloombergLP::bslalg::ScalarPrimitives::swap(*this, other);
    }
}

// PRIVATE MANIPULATORS
template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
inline
void String_Imp&lt;CHAR_TYPE, SIZE_TYPE&gt;::resetFields()
{
    d_start_p  = 0;
    d_length   = 0;
    d_capacity = SHORT_BUFFER_CAPACITY;
}

template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
inline
CHAR_TYPE *String_Imp&lt;CHAR_TYPE, SIZE_TYPE&gt;::dataPtr()
{
    return isShortString()
           ? reinterpret_cast&lt;CHAR_TYPE *&gt;((void *)d_short.buffer())
           : d_start_p;
}

// PRIVATE ACCESSORS
template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
inline
bool String_Imp&lt;CHAR_TYPE, SIZE_TYPE&gt;::isShortString() const
{
    return d_capacity == SHORT_BUFFER_CAPACITY;
}

template &lt;class CHAR_TYPE, class SIZE_TYPE&gt;
inline
const CHAR_TYPE *String_Imp&lt;CHAR_TYPE, SIZE_TYPE&gt;::dataPtr() const
{
    return isShortString()
          ? reinterpret_cast&lt;const CHAR_TYPE *&gt;((const void *)d_short.buffer())
          : d_start_p;
}

                        // -----------------------
                        // class bsl::basic_string
                        // -----------------------

// CLASS DATA
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
const typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::npos;

// PRIVATE MANIPULATORS
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
CHAR_TYPE *
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateAllocate(
                                                            size_type numChars)
{
    return this-&gt;allocateN((CHAR_TYPE *)0, numChars + 1);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateDeallocate()
{
    if (!this-&gt;isShortString()) {
        this-&gt;deallocateN(this-&gt;d_start_p, this-&gt;d_capacity + 1);
    }
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
void
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateCopyFromOutOfPlaceBuffer(
                                                  const basic_string&amp; original)
{
    BSLS_ASSERT_SAFE(!this-&gt;isShortString());
    BSLS_ASSERT_SAFE(!original.isShortString());

    // Note that it is possible that &#39;original&#39; is not a short-string, but its
    // length has been updated to fit in the short-string buffer (so &#39;this&#39;
    // copy should be a short-string).

    static_cast&lt;Imp &amp;&gt;(*this) = Imp(original.length(), original.length());

    if (!this-&gt;isShortString()) {
        this-&gt;d_start_p = privateAllocate(this-&gt;d_capacity);
    }

    CHAR_TRAITS::copy(this-&gt;dataPtr(), original.data(), this-&gt;d_length + 1);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateAppendDispatch(
                                                                iterator begin,
                                                                iterator end)
{
    BSLS_ASSERT_SAFE(begin &lt;= end);

    return privateAppendDispatch(const_iterator(begin), const_iterator(end));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateAppendDispatch(
                                                          const_iterator begin,
                                                          const_iterator end)
{
    BSLS_ASSERT_SAFE(begin &lt;= end);

    size_type numChars = end - begin;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                           numChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                            &quot;string&lt;...&gt;::append&lt;Iter&gt;(i,j): string too long&quot;);
    }
    return privateAppendRaw(&amp;*begin, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateAppendDispatch(
                                                              INPUT_ITER begin,
                                                              INPUT_ITER end)
{
    return privateReplaceDispatch(length(),
                                  size_type(0),
                                  begin,
                                  end,
                                  begin,
                                  BloombergLP::bslmf::Nil()); // disambiguate
                                                              // overloads
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateAssign(
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(numChars &lt;= max_size());

    if (numChars &lt;= capacity()) {
        // no reallocation required, perform assignment in-place

        this-&gt;d_length = 0;
        return privateAppendRaw(characterString, numChars);           // RETURN
    }
    else {
        // reallocation required, ensure strong exception-safety

        basic_string cpy(get_allocator());
        cpy.privateAppendRaw(characterString, numChars);
        cpy.swap(*this);
        return *this;                                                 // RETURN
    }
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateAssign(
                                                           size_type numChars,
                                                           CHAR_TYPE character)
{
    BSLS_ASSERT_SAFE(numChars &lt;= max_size());

    if (numChars &lt;= capacity()) {
        // no reallocation required, perform assignment in-place

        this-&gt;d_length = 0;
        return privateAppendRaw(numChars, character);                 // RETURN
    }
    else {
        // reallocation required, ensure strong exception-safety

        basic_string cpy(get_allocator());
        cpy.privateAppendRaw(numChars, character);
        cpy.swap(*this);
        return *this;                                                 // RETURN
    }
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateAppendRaw(
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(length() &lt;= max_size() - numChars);

    size_type  newLength  = this-&gt;d_length + numChars;
    size_type  newStorage = this-&gt;d_capacity;
    CHAR_TYPE *newBuffer  = privateReserveRaw(&amp;newStorage,
                                              newLength,
                                              this-&gt;d_length);

    if (newBuffer) {
        CHAR_TRAITS::copy(newBuffer + this-&gt;d_length,
                          characterString,
                          numChars);
        CHAR_TRAITS::assign(*(newBuffer + newLength), CHAR_TYPE());

        privateDeallocate();

        this-&gt;d_start_p  = newBuffer;
        this-&gt;d_capacity = newStorage;
    }
    else {
        CHAR_TRAITS::move(this-&gt;dataPtr() + length(),
                          characterString,
                          numChars);
        CHAR_TRAITS::assign(*(this-&gt;dataPtr() + newLength), CHAR_TYPE());
    }

    this-&gt;d_length = newLength;
    return *this;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateAppendRaw(
                                                           size_type numChars,
                                                           CHAR_TYPE character)
{
    BSLS_ASSERT_SAFE(length() &lt;= max_size() - numChars);

    size_type newLength = this-&gt;d_length + numChars;
    privateReserveRaw(newLength);
    CHAR_TRAITS::assign(this-&gt;dataPtr() + this-&gt;d_length, numChars, character);
    this-&gt;d_length = newLength;
    CHAR_TRAITS::assign(*(this-&gt;dataPtr() + newLength), CHAR_TYPE());
    return *this;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOCATOR&gt;::Imp&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateBase()
{
    return *static_cast&lt;Imp *&gt;(this);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateClear(
                                                     bool deallocateBufferFlag)
{
    if (deallocateBufferFlag) {
        privateDeallocate();
        this-&gt;resetFields();
    }
    else {
        this-&gt;d_length = 0;
    }

    CHAR_TRAITS::assign(*begin(), CHAR_TYPE());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
void
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateInitDispatch(
                                                                iterator begin,
                                                                iterator end)
{
    BSLS_ASSERT_SAFE(begin &lt;= end);

    privateInitDispatch((const_iterator)begin, (const_iterator)end);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
void
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateInitDispatch(
                                                        const_iterator   begin,
                                                        const_iterator   end)
{
    BSLS_ASSERT_SAFE(begin &lt;= end);

    size_type numChars = end - begin;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; max_size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                                          &quot;string&lt;...&gt;(i,j): string too long&quot;);
    }
    privateAppendRaw(&amp;*begin, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateInitDispatch(
                                                              INPUT_ITER begin,
                                                              INPUT_ITER end)
{
    privateReplaceDispatch((size_type)0,
                           (size_type)0,
                           begin,
                           end,
                           begin,
                           BloombergLP::bslmf::Nil());  // disambiguate
                                                        // overloads
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateInsertDispatch(
                                                       const_iterator position,
                                                       iterator       first,
                                                       iterator       last)
{
    BSLS_ASSERT_SAFE(first &lt;= last);

    privateInsertDispatch(position,
                          const_iterator(first),
                          const_iterator(last));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateInsertDispatch(
                                                       const_iterator position,
                                                       const_iterator first,
                                                       const_iterator last)
{
    BSLS_ASSERT_SAFE(first &lt;= last);

    size_type pos = position - cbegin();
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(pos &gt; length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                       &quot;string&lt;...&gt;::insert&lt;Iter&gt;(pos,i,j): invalid position&quot;);
    }
    size_type numChars = last - first;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                           numChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                        &quot;string&lt;...&gt;::insert&lt;Iter&gt;(pos,i,j): string too long&quot;);
    }
    privateInsertRaw(pos, &amp;*first, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateInsertDispatch(
                                                       const_iterator position,
                                                       INPUT_ITER     first,
                                                       INPUT_ITER     last)
{
    size_type pos = position - cbegin();
    privateReplaceDispatch(pos,
                           size_type(0),
                           first,
                           last,
                           first,
                           BloombergLP::bslmf::Nil());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateInsertRaw(
                                              size_type        outPosition,
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(outPosition &lt;= length());
    BSLS_ASSERT_SAFE(numChars &lt;= max_size() - length());
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    size_type  newLength  = this-&gt;d_length + numChars;
    size_type  newStorage = this-&gt;d_capacity;
    CHAR_TYPE *newBuffer  = privateReserveRaw(&amp;newStorage,
                                              newLength,
                                              outPosition);

    if (newBuffer) {
        // Source and destination cannot overlap, order of next two copies is
        // arbitrary.  Do it left to right to maintain cache consistency.

        const CHAR_TYPE *tail    = this-&gt;dataPtr() + outPosition;
        size_type        tailLen = this-&gt;d_length - outPosition;

        CHAR_TRAITS::copy(newBuffer + outPosition, characterString, numChars);
        CHAR_TRAITS::copy(newBuffer + outPosition + numChars, tail, tailLen);
        CHAR_TRAITS::assign(*(newBuffer + newLength), CHAR_TYPE());

        privateDeallocate();

        this-&gt;d_start_p  = newBuffer;
        this-&gt;d_capacity = newStorage;
    }
    else {
        // Because of possible aliasing, we have to be very careful in which
        // order to move blocks.  If &#39;characterString&#39; overlaps with tail, or
        // is entirely contained: in the former case, &#39;characterString&#39; is
        // shifted by &#39;numChars&#39; (takes &#39;first&#39; onto &#39;last&#39;); in the latter,
        // the tail moves in by &#39;numChars&#39;, so cannot overwrite
        // &#39;characterString&#39;!

        const CHAR_TYPE *first   = characterString;
        const CHAR_TYPE *last    = characterString + numChars;
        CHAR_TYPE       *tail    = this-&gt;dataPtr() + outPosition;
        size_type        tailLen = this-&gt;d_length - outPosition;
        const CHAR_TYPE *shifted = (tail &lt; first &amp;&amp; last &lt;= tail + tailLen)
                                 ? last    // &#39;first&#39; shifted by &#39;numChars&#39;
                                 : first;  // &#39;no shift

        CHAR_TRAITS::move(tail + numChars, tail, tailLen);
        CHAR_TRAITS::move(tail, shifted, numChars);
        CHAR_TRAITS::assign(*(this-&gt;dataPtr() + newLength), CHAR_TYPE());
    }

    this-&gt;d_length = newLength;
    return *this;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReplaceRaw(
                                              size_type        outPosition,
                                              size_type        outNumChars,
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(outPosition &lt;= length());
    BSLS_ASSERT_SAFE(outNumChars &lt;= length());
    BSLS_ASSERT_SAFE(outPosition &lt;= length() - outNumChars);
    BSLS_ASSERT_SAFE(length() - outNumChars &lt;= max_size() - numChars);
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    const difference_type displacement =
                          static_cast&lt;difference_type&gt;(numChars - outNumChars);

    size_type  newLength  = this-&gt;d_length + displacement;
    size_type  newStorage = this-&gt;d_capacity;
    CHAR_TYPE *newBuffer  = privateReserveRaw(&amp;newStorage,
                                              newLength,
                                              outPosition);

    const CHAR_TYPE *tail    = this-&gt;dataPtr() + outPosition + outNumChars;
    size_type        tailLen = this-&gt;d_length  - outPosition - outNumChars;

    if (newBuffer) {
        // Source and destination cannot overlap, order of next two copies is
        // arbitrary.  Do it left to right to maintain cache consistency.

        CHAR_TRAITS::copy(newBuffer + outPosition, characterString, numChars);
        CHAR_TRAITS::copy(newBuffer + outPosition + numChars, tail, tailLen);
        CHAR_TRAITS::assign(*(newBuffer + newLength), CHAR_TYPE());

        privateDeallocate();

        this-&gt;d_start_p  = newBuffer;
        this-&gt;d_capacity = newStorage;
        this-&gt;d_length = newLength;
        return *this;                                                 // RETURN
    }

    // Because of possible aliasing, we have to be very careful in which order
    // to move blocks.  There are up to three blocks if &#39;characterString&#39;
    // overlaps with the tail.

    CHAR_TYPE       *dest  = this-&gt;dataPtr() + outPosition;
    const CHAR_TYPE *first = characterString;
    const CHAR_TYPE *last  = characterString + numChars;

    if (tail &lt; last &amp;&amp; last &lt;= tail + tailLen) {
        // Either &#39;characterString&#39; overlaps with tail, or is entirely
        // contained.

        if (first &lt; tail) {
            // Not entirely contained: break &#39;[first .. last)&#39; at &#39;tail&#39;, and
            // move it in two steps, the second shifted but not the first.

            size_type prefix = tail - first, suffix = last - tail;
            if (outNumChars &lt; numChars) {
                CHAR_TRAITS::move(dest + numChars, tail, tailLen);
                CHAR_TRAITS::move(dest, first, prefix);
            }
            else {
                CHAR_TRAITS::move(dest, first, prefix);
                CHAR_TRAITS::move(dest + numChars, tail, tailLen);
            }
            CHAR_TRAITS::move(dest + prefix,
                              last - suffix + displacement,
                              suffix);
        }
        else {
            // Entirely contained: copy &#39;tail&#39; first, and copy
            // &#39;[first .. last)&#39; shifted by &#39;displacement&#39;.

            CHAR_TRAITS::move(dest + numChars, tail, tailLen);
            CHAR_TRAITS::copy(dest, first + displacement, numChars);
        }
    }
    else {
        // Note: no aliasing in tail.

        if (outNumChars &lt; numChars) {
            CHAR_TRAITS::move(dest + numChars, tail, tailLen);
            CHAR_TRAITS::move(dest, characterString, numChars);
        }
        else {
            CHAR_TRAITS::move(dest, characterString, numChars);
            CHAR_TRAITS::move(dest + numChars, tail, tailLen);
        }
    }
    CHAR_TRAITS::assign(*(this-&gt;dataPtr() + newLength), CHAR_TYPE());
    this-&gt;d_length = newLength;
    return *this;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReplaceRaw(
                                                         size_type outPosition,
                                                         size_type outNumChars,
                                                         size_type numChars,
                                                         CHAR_TYPE character)
{
    BSLS_ASSERT_SAFE(outPosition &lt;= length());
    BSLS_ASSERT_SAFE(outNumChars &lt;= length());
    BSLS_ASSERT_SAFE(outPosition &lt;= length() - outNumChars);
    BSLS_ASSERT_SAFE(length() &lt;= max_size() - numChars);

    size_type  newLength  = this-&gt;d_length - outNumChars + numChars;
    size_type  newStorage = this-&gt;d_capacity;
    CHAR_TYPE *newBuffer  = privateReserveRaw(&amp;newStorage,
                                              newLength,
                                              outPosition);

    const CHAR_TYPE *tail    = this-&gt;dataPtr() + outPosition + outNumChars;
    size_type        tailLen = this-&gt;d_length  - outPosition - outNumChars;

    if (newBuffer) {
        CHAR_TYPE *dest = newBuffer + outPosition;

        CHAR_TRAITS::assign(dest, numChars, character);
        CHAR_TRAITS::copy(dest + numChars, tail, tailLen);
        CHAR_TRAITS::assign(*(newBuffer + newLength), CHAR_TYPE());

        privateDeallocate();

        this-&gt;d_start_p  = newBuffer;
        this-&gt;d_capacity = newStorage;
    }
    else {
        CHAR_TYPE *dest = this-&gt;dataPtr() + outPosition;

        CHAR_TRAITS::move(dest + numChars, tail, tailLen);
        CHAR_TRAITS::assign(dest, numChars, character);
        CHAR_TRAITS::assign(*(this-&gt;dataPtr() + newLength), CHAR_TYPE());
    }

    this-&gt;d_length = newLength;
    return *this;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReplaceDispatch(
                              size_type                               position,
                              size_type                               numChars,
                              INPUT_ITER                              first,
                              INPUT_ITER                              last,
                              BloombergLP::bslmf::MatchArithmeticType ,
                              BloombergLP::bslmf::Nil                 )
{
    return replace(position, numChars, (size_type)first, (CHAR_TYPE)last);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReplaceDispatch(
                                     size_type                        position,
                                     size_type                        numChars,
                                     INPUT_ITER                       first,
                                     INPUT_ITER                       last,
                                     BloombergLP::bslmf::MatchAnyType ,
                                     BloombergLP::bslmf::MatchAnyType )
{
    typename iterator_traits&lt;INPUT_ITER&gt;::iterator_category tag;
    return privateReplace(position, numChars, first, last, tag);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReplace(
                                                       size_type  outPosition,
                                                       size_type  outNumChars,
                                                       INPUT_ITER first,
                                                       INPUT_ITER last,
                                                       std::input_iterator_tag)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &lt; outPosition)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                 &quot;string&lt;...&gt;::replace&lt;InputIter&gt;(pos,i,j): invalid position&quot;);
    }
    basic_string temp(this-&gt;get_allocator());
    for (; first != last; ++first) {
        temp.push_back(*first);
    }
    if (outPosition == 0 &amp;&amp; length() &lt;= outNumChars) {
        // Note: can potentially shrink the capacity, hence the reserve.

        temp.privateReserveRaw(capacity());
        privateBase().swap(temp.privateBase());
        return *this;                                                 // RETURN
    }
    return privateReplaceRaw(outPosition,
                             outNumChars,
                             temp.data(),
                             temp.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReplace(
                                                     size_type  outPosition,
                                                     size_type  outNumChars,
                                                     INPUT_ITER first,
                                                     INPUT_ITER last,
                                                     std::forward_iterator_tag)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &lt; outPosition)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                      &quot;string&lt;...&gt;::replace&lt;Iter&gt;(pos,i,j): invalid position&quot;);
    }
    size_type numChars = bsl::distance(first, last);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                           max_size() - (length() - outPosition) &lt; numChars)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                     &quot;string&lt;...&gt;::replace&lt;Iter&gt;(pos,n,i,j): string too long&quot;);
    }

    // Create a temp string because the &#39;first&#39;/&#39;last&#39; iterator pair can alias
    // the current string; not using ctor with two iterators because it
    // recurses back here.
    basic_string temp(numChars, CHAR_TYPE());

    for (size_type pos = 0; pos != numChars; ++first, ++pos) {
        temp[pos] = *first;
    }

    return privateReplaceRaw(outPosition,
                             outNumChars,
                             temp.data(),
                             temp.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReplace(
                                                     size_type      position,
                                                     size_type      numChars,
                                                     const_iterator first,
                                                     const_iterator last,
                                                     std::forward_iterator_tag)
{
    BSLS_ASSERT_SAFE(first &lt;= last);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &lt; position)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                      &quot;string&lt;...&gt;::replace&lt;Iter&gt;(pos,i,j): invalid position&quot;);
    }
    size_type numNewChars = bsl::distance(first, last);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                           max_size() - (length() - position) &lt; numNewChars)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                     &quot;string&lt;...&gt;::replace&lt;Iter&gt;(pos,n,i,j): string too long&quot;);
    }

    return privateReplaceRaw(position, numChars, &amp;*first, numNewChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReplace(
                                                     size_type      position,
                                                     size_type      numChars,
                                                     iterator       first,
                                                     iterator       last,
                                                     std::forward_iterator_tag)
{
    BSLS_ASSERT_SAFE(first &lt;= last);

    return privateReplace(position,
                          numChars,
                          const_iterator(first),
                          const_iterator(last),
                          std::forward_iterator_tag());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReserveRaw(
                                                         size_type newCapacity)
{
    BSLS_ASSERT_SAFE(newCapacity &lt;= max_size());

    if (this-&gt;d_capacity &lt; newCapacity) {
        size_type newStorage = this-&gt;computeNewCapacity(newCapacity,
                                                        this-&gt;d_capacity,
                                                        max_size());
        CHAR_TYPE *newBuffer = privateAllocate(newStorage);

        CHAR_TRAITS::copy(newBuffer, this-&gt;dataPtr(), this-&gt;d_length + 1);

        privateDeallocate();

        this-&gt;d_start_p  = newBuffer;
        this-&gt;d_capacity = newStorage;
    }
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
CHAR_TYPE *
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateReserveRaw(
                                                        size_type *storage,
                                                        size_type  newCapacity,
                                                        size_type  numChars)
{
    BSLS_ASSERT_SAFE(numChars &lt;= length());
    BSLS_ASSERT_SAFE(newCapacity &lt;= max_size());
    BSLS_ASSERT_SAFE(storage != 0);

    if (*storage &gt;= newCapacity) {
        return 0;                                                     // RETURN
    }

    *storage = this-&gt;computeNewCapacity(newCapacity,
                                        *storage,
                                        max_size());

    CHAR_TYPE *newBuffer = privateAllocate(*storage);

    CHAR_TRAITS::copy(newBuffer, this-&gt;dataPtr(), numChars);
    return newBuffer;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateResizeRaw(
                                                           size_type newLength,
                                                           CHAR_TYPE character)
{
    BSLS_ASSERT_SAFE(newLength &lt;= max_size());

    privateReserveRaw(newLength);

    if (newLength &gt; this-&gt;d_length) {
        CHAR_TRAITS::assign(this-&gt;dataPtr() + this-&gt;d_length,
                            newLength - this-&gt;d_length,
                            character);
    }
    this-&gt;d_length = newLength;
    CHAR_TRAITS::assign(*(this-&gt;dataPtr() + this-&gt;d_length), CHAR_TYPE());
    return *this;
}

// PRIVATE ACCESSORS
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
int basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::privateCompareRaw(
                                          size_type        lhsPosition,
                                          size_type        lhsNumChars,
                                          const CHAR_TYPE *other,
                                          size_type        otherNumChars) const
{
    BSLS_ASSERT_SAFE(lhsPosition &lt;= length());
    BSLS_ASSERT_SAFE(lhsNumChars &lt;= length());
    BSLS_ASSERT_SAFE(lhsPosition &lt;= length() - lhsNumChars);
    BSLS_ASSERT_SAFE(other);

    size_type numChars  = lhsNumChars &lt; otherNumChars ? lhsNumChars
                                                      : otherNumChars;
    int       cmpResult = CHAR_TRAITS::compare(this-&gt;dataPtr() + lhsPosition,
                                               other,
                                               numChars);
    if (cmpResult) {
        return cmpResult;                                             // RETURN
    }
    if (lhsNumChars &lt; otherNumChars) {
        return -1;                                                    // RETURN
    }
    if (lhsNumChars &gt; otherNumChars) {
        return 1;                                                     // RETURN
    }
    return 0;
}

// CREATORS

                // *** 21.3.2 construct/copy/destroy: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                                               const ALLOCATOR&amp; basicAllocator)
: Imp()
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    CHAR_TRAITS::assign(*begin(), CHAR_TYPE());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                                                  const basic_string&amp; original)
: Imp(original)
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(ALLOCATOR())
{
    if (!this-&gt;isShortString()) {
        // Copy out-of-place string into either short buffer or new long
        // buffer, according to size.

        privateCopyFromOutOfPlaceBuffer(original);
    }
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                                            const basic_string&amp; original,
                                            const ALLOCATOR&amp;    basicAllocator)
: Imp(original)
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    if (!this-&gt;isShortString()) {
        // Copy out-of-plsce string into either short buffer or new long
        // buffer, according to size.

        privateCopyFromOutOfPlaceBuffer(original);
    }
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                         BloombergLP::bslmf::MovableRef&lt;basic_string&gt; original)
: Imp(original)
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(
          BloombergLP::bslmf::MovableRefUtil::access(original).get_allocator())
{
    if (!this-&gt;isShortString()) {   // nothing to fix up if string is short
        basic_string&amp; originalRef =
                          BloombergLP::bslmf::MovableRefUtil::access(original);
        originalRef.resetFields();
    }
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                   BloombergLP::bslmf::MovableRef&lt;basic_string&gt; original,
                   const ALLOCATOR&amp;                             basicAllocator)
: Imp(original)
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    if (!this-&gt;isShortString()) {   // nothing to fix up if string is short
        basic_string&amp; originalRef =
                          BloombergLP::bslmf::MovableRefUtil::access(original);
        if (this-&gt;get_allocator() == originalRef.get_allocator()) {
            originalRef.resetFields();
        }
        else {
            privateCopyFromOutOfPlaceBuffer(originalRef);
        }
    }
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                                            const basic_string&amp; original,
                                            size_type           position,
                                            size_type           numChars,
                                            const ALLOCATOR&amp;    basicAllocator)
: Imp()
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    assign(original, position, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                                             const CHAR_TYPE  *characterString,
                                             const ALLOCATOR&amp;  basicAllocator)
: Imp()
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    BSLS_ASSERT_SAFE(characterString);

    assign(characterString);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                                             const CHAR_TYPE  *characterString,
                                             size_type         numChars,
                                             const ALLOCATOR&amp;  basicAllocator)
: Imp()
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    assign(characterString, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                                              size_type         numChars,
                                              CHAR_TYPE         character,
                                              const ALLOCATOR&amp;  basicAllocator)
: Imp()
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    assign(numChars, character);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
                                               INPUT_ITER       first,
                                               INPUT_ITER       last,
                                               const ALLOCATOR&amp; basicAllocator)
: Imp()
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    privateInitDispatch(first, last);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class ALLOC2&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
  const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; original,
  const ALLOCATOR&amp;                                              basicAllocator)
: Imp()
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    this-&gt;assign(original.data(), original.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::basic_string(
           const BloombergLP::bslstl::StringRefData&lt;CHAR_TYPE&gt;&amp; strRef,
           const ALLOCATOR&amp;                                     basicAllocator)
: Imp()
, BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;(basicAllocator)
{
    assign(strRef.begin(), strRef.end());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::~basic_string()
{
    // perform a validity check
    BSLS_ASSERT_SAFE((*this)[this-&gt;d_length] == CHAR_TYPE());
    BSLS_ASSERT_SAFE(capacity() &gt;= length());

    privateDeallocate();
    this-&gt;d_length = npos;  // invalid length
}

// MANIPULATORS

                // *** 21.3.2 construct/copy/destroy: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator=(
                                                       const basic_string&amp; rhs)
{
    return assign(rhs, size_type(0), npos);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator=(
                              BloombergLP::bslmf::MovableRef&lt;basic_string&gt; rhs)
{
    return assign(BloombergLP::bslmf::MovableRefUtil::move(rhs));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator=(const CHAR_TYPE *rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    return assign(rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator=(CHAR_TYPE character)
{
    return assign(1, character);
}

                      // *** 21.3.4 capacity: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::resize(size_type newLength,
                                                           CHAR_TYPE character)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(newLength &gt; max_size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                                  &quot;string&lt;...&gt;::resize(n,c): string too long&quot;);
    }
    privateResizeRaw(newLength, character);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::resize(size_type newLength)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(newLength &gt; max_size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                                    &quot;string&lt;...&gt;::resize(n): string too long&quot;);
    }
    privateResizeRaw(newLength, CHAR_TYPE());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::reserve(
                                                         size_type newCapacity)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(newCapacity &gt; max_size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                                   &quot;string&lt;...&gt;::reserve(n): string too long&quot;);
    }
    privateReserveRaw(newCapacity);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::clear()
{
    // Note: Stlport and Dinkumware do not deallocate the allocated buffer in
    // long string representation, ApacheSTL does.

    privateClear(Imp::BASIC_STRING_DEALLOCATE_IN_CLEAR);
}

                      // *** 21.3.3 iterators: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::begin()
{
    return this-&gt;dataPtr();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::end()
{
    return begin() + this-&gt;d_length;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::reverse_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::rbegin()
{
    return reverse_iterator(end());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::reverse_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::rend()
{
    return reverse_iterator(begin());
}

                   // *** 21.3.5 element access: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::reference
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator[](size_type position)
{
    BSLS_ASSERT_SAFE(position &lt;= length());

    return *(begin() + position);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::reference
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::at(size_type position)
{
    // Note: deliberately not inline, because 1) this is not a very widely used
    // function, and 2) it is very convenient to have at least one non-inlined
    // element accessor for debugging.

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(position &gt;= length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                                       &quot;string&lt;...&gt;::at(n): invalid position&quot;);
    }
    return *(begin() + position);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
CHAR_TYPE&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::front()
{
    BSLS_ASSERT_SAFE(!empty());

    return *begin();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
CHAR_TYPE&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::back()
{
    BSLS_ASSERT_SAFE(!empty());

    return *(begin() + length() - 1);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class ALLOC2&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::
    operator native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;() const
{
    native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt; result;
    result.assign(data(), length());
    return result;
}

                     // *** 21.3.6 modifiers: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator+=(
                                                       const basic_string&amp; rhs)
{
    return append(rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator+=(
                                                          const CHAR_TYPE *rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    return append(rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator+=(CHAR_TYPE character)
{
    push_back(character);
    return *this;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator+=(
                   const BloombergLP::bslstl::StringRefData&lt;CHAR_TYPE&gt;&amp; strRef)
{
    return append(strRef.begin(),strRef.end());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::append(
                                                   const basic_string&amp;  suffix)
{
    return append(suffix, size_type(0), npos);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::append(
                                                  const basic_string&amp; suffix,
                                                  size_type           position,
                                                  size_type           numChars)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(position &gt; suffix.length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                 &quot;string&lt;...&gt;::append(string const&amp;,pos,n): invalid position&quot;);
    }
    if (numChars &gt; suffix.length() - position) {
        numChars = suffix.length() - position;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                           numChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                     &quot;string&lt;...&gt;::append(string const&amp;...): string too long&quot;);
    }
    return privateAppendRaw(suffix.data() + position, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::append(
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                           numChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                             &quot;string&lt;...&gt;::append(char*...): string too long&quot;);
    }
    return privateAppendRaw(characterString, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::append(
                                              const CHAR_TYPE *characterString)
{
    BSLS_ASSERT_SAFE(characterString);

    return append(characterString, CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::append(size_type numChars,
                                                      CHAR_TYPE character)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                     numChars &gt; max_size() - this-&gt;d_length)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                                  &quot;string&lt;...&gt;::append(n,c): string too long&quot;);
    }
    return privateResizeRaw(length() + numChars, character);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::append(INPUT_ITER first,
                                                      INPUT_ITER last)
{
    return privateAppendDispatch(first, last);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::push_back(
                                                           CHAR_TYPE character)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &gt;= max_size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                              &quot;string&lt;...&gt;::push_back(char): string too long&quot;);
    }
    if (length() + 1 &gt; capacity()) {
        privateReserveRaw(length() + 1);
    }
    CHAR_TRAITS::assign(*(begin() + length()), character);
    ++this-&gt;d_length;
    CHAR_TRAITS::assign(*(begin() + length()), CHAR_TYPE());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::assign(
                                               const basic_string&amp; replacement)
{
    return assign(replacement, size_type(0), npos);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::assign(
                      BloombergLP::bslmf::MovableRef&lt;basic_string&gt; replacement)
{
    basic_string&amp; other = BloombergLP::bslmf::MovableRefUtil::access(
                                                                  replacement);
    if (get_allocator() == other.get_allocator()) {
        basic_string temp(BloombergLP::bslmf::MovableRefUtil::move(other));
        privateBase().swap(temp.privateBase());
    } else {
        this-&gt;privateAssign(other.data(), other.size());
    }
    return *this;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::assign(
                                               const basic_string&amp; replacement,
                                               size_type           position,
                                               size_type           numChars)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                            position &gt; replacement.length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                 &quot;string&lt;...&gt;::assign(string const&amp;,pos,n): invalid position&quot;);
    }
    if (numChars &gt; replacement.length() - position) {
        numChars = replacement.length() - position;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; max_size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                     &quot;string&lt;...&gt;::assign(string const&amp;...): string too long&quot;);
    }

    return privateAssign(replacement.data() + position, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::assign(
                                              const CHAR_TYPE *characterString)
{
    BSLS_ASSERT_SAFE(characterString);

    return assign(characterString, CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::assign(
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; max_size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                             &quot;string&lt;...&gt;::assign(char*...): string too long&quot;);
    }

    return privateAssign(characterString, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::assign(
                   const BloombergLP::bslstl::StringRefData&lt;CHAR_TYPE&gt;&amp; strRef)
{
    return privateAssign(strRef.begin(), strRef.end() - strRef.begin());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::assign(size_type numChars,
                                                      CHAR_TYPE character)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; max_size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                                  &quot;string&lt;...&gt;::assign(n,c): string too long&quot;);
    }

    return privateAssign(numChars, character);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::assign(INPUT_ITER first,
                                                      INPUT_ITER last)
{
    return privateReplaceDispatch(0,
                                  this-&gt;d_length,
                                  first,
                                  last,
                                  first,
                                  BloombergLP::bslmf::Nil());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::insert(
                                                  size_type           position,
                                                  const basic_string&amp; other)
{
    return insert(position, other, size_type(0), npos);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::insert(
                                              size_type            outPosition,
                                              const basic_string&amp;  other,
                                              size_type            position,
                                              size_type            numChars)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(outPosition &gt; length())
     || BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(position &gt; other.length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                &quot;string&lt;...&gt;::insert(pos,string const&amp;...): invalid position&quot;);
    }
    if (numChars &gt; other.length() - position) {
        numChars = other.length() - position;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                           numChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                     &quot;string&lt;...&gt;::insert(string const&amp;...): string too long&quot;);
    }
    return privateInsertRaw(outPosition, other.data() + position, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::insert(
                                              size_type        position,
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(position &gt; length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                        &quot;string&lt;...&gt;::insert(pos,char*...): invalid position&quot;);
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                           numChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                             &quot;string&lt;...&gt;::insert(char*...): string too long&quot;);
    }
    return privateInsertRaw(position, characterString, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::insert(
                                              size_type        position,
                                              const CHAR_TYPE *characterString)
{
    BSLS_ASSERT_SAFE(characterString);

    return insert(position,
                  characterString,
                  CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::insert(size_type position,
                                                      size_type numChars,
                                                      CHAR_TYPE character)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(position &gt; length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                             &quot;string&lt;...&gt;::insert(pos,n,c): invalid position&quot;);
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                           numChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                              &quot;string&lt;...&gt;::insert(pos,n,v): string too long&quot;);
    }
    return privateReplaceRaw(position, size_type(0), numChars, character);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::insert(const_iterator position,
                                                      CHAR_TYPE      character)
{
    BSLS_ASSERT_SAFE(position &gt;= cbegin());
    BSLS_ASSERT_SAFE(position &lt;= cend());

    size_type pos = position - cbegin();
    insert(pos, size_type(1), character);
    return begin() + pos;
}

#if defined(BSLS_PLATFORM_CMP_SUN)
    // Sun CC compiler doesn&#39;t like that &#39;iterator&#39; return type of &#39;insert&#39;
    // method with an additional &#39;INPUT_ITER&#39; template parameter depends on
    // template parameters of the primary template class &#39;basic_string&#39;.
    // However, it happily accepts &#39;CHAR_TYPE *&#39;, which is how &#39;iterator&#39; is
    // currently defined.  It will also accept an inline definition of this
    // method (this workaround should be used when &#39;iterator&#39; becomes a real
    // class and the current workaround stops working).
#   define BSLSTL_INSERT_RETURN_TYPE CHAR_TYPE *
#else
#   define BSLSTL_INSERT_RETURN_TYPE \
    typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator
#endif

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
BSLSTL_INSERT_RETURN_TYPE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::insert(const_iterator position,
                                                      INPUT_ITER     first,
                                                      INPUT_ITER     last)
{
    BSLS_ASSERT_SAFE(position &gt;= cbegin());
    BSLS_ASSERT_SAFE(position &lt;= cend());

    size_type pos = position - cbegin();
    privateInsertDispatch(position, first, last);
    return begin() + pos;
}

#undef BSLSTL_INSERT_RETURN_TYPE

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::insert(const_iterator position,
                                                      size_type      numChars,
                                                      CHAR_TYPE      character)
{
    BSLS_ASSERT_SAFE(position &gt;= cbegin());
    BSLS_ASSERT_SAFE(position &lt;= cend());

    size_type pos = position - cbegin();
    insert(pos, numChars, character);
    return begin() + pos;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::erase(size_type position,
                                                     size_type numChars)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(position &gt; length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                                &quot;string&lt;...&gt;::erase(pos,n): invalid position&quot;);
    }
    if (numChars &gt; length() - position) {
        numChars = length() - position;
    }
    if (numChars) {
        this-&gt;d_length -= numChars;
        CHAR_TRAITS::move(this-&gt;dataPtr() + position,
                          this-&gt;dataPtr() + position + numChars,
                          this-&gt;d_length - position);
        CHAR_TRAITS::assign(*(begin() + length()), CHAR_TYPE());
    }
    return *this;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::erase(const_iterator position)
{
    BSLS_ASSERT_SAFE(position &gt;= cbegin());
    BSLS_ASSERT_SAFE(position &lt; cend());

    const_iterator postPosition = position;
    iterator       dstPosition  = begin() + (position - cbegin());

    ++postPosition;
    CHAR_TRAITS::move(&amp;*dstPosition, &amp;*postPosition, cend() - postPosition);

    --this-&gt;d_length;
    CHAR_TRAITS::assign(*(this-&gt;dataPtr() + length()), CHAR_TYPE());

    return dstPosition;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::erase(const_iterator first,
                                                     const_iterator last)
{
    BSLS_ASSERT_SAFE(first &gt;= cbegin());
    BSLS_ASSERT_SAFE(first &lt;= cend());
    BSLS_ASSERT_SAFE(last &gt;= cbegin());
    BSLS_ASSERT_SAFE(last &lt;= cend());
    BSLS_ASSERT_SAFE(last - first &gt;= 0);

    iterator dstFirst = begin() + (first - cbegin());

    if (first != last) {
        CHAR_TRAITS::move(&amp;*dstFirst, &amp;*last, cend() - last);

        this-&gt;d_length -= last - first;
        CHAR_TRAITS::assign(*(this-&gt;dataPtr() + length()), CHAR_TYPE());
    }

    return dstFirst;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
void basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::pop_back()
{
    BSLS_ASSERT_SAFE(!empty());

    --this-&gt;d_length;
    CHAR_TRAITS::assign(*(begin() + length()), CHAR_TYPE());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                               size_type           outPosition,
                                               size_type           outNumChars,
                                               const basic_string&amp; replacement)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &lt; outPosition)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
               &quot;string&lt;...&gt;::replace(pos,string const&amp;...): invalid position&quot;);
    }
    if (outNumChars &gt; length() - outPosition) {
        outNumChars = length() - outPosition;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                 replacement.length()               &gt; outNumChars
              &amp;&amp; replacement.length() - outNumChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                &quot;string&lt;...&gt;::replace(pos,string const&amp;...): string too long&quot;);
    }
    return privateReplaceRaw(outPosition,
                             outNumChars,
                             replacement.data(),
                             replacement.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                               size_type           outPosition,
                                               size_type           outNumChars,
                                               const basic_string&amp; replacement,
                                               size_type           position,
                                               size_type           numChars)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(outPosition &gt; length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
               &quot;string&lt;...&gt;::replace(pos,string const&amp;...): invalid position&quot;);
    }
    if (outNumChars &gt; length() - outPosition) {
        outNumChars = length() - outPosition;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                            position &gt; replacement.length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
               &quot;string&lt;...&gt;::replace(pos,string const&amp;...): invalid position&quot;);
    }
    if (numChars &gt; replacement.length() - position) {
        numChars = replacement.length() - position;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; outNumChars)
     &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                             numChars - outNumChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                    &quot;string&lt;...&gt;::replace(string const&amp;...): string too long&quot;);
    }
    return privateReplaceRaw(outPosition,
                             outNumChars,
                             replacement.data() + position,
                             numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                              size_type        outPosition,
                                              size_type        outNumChars,
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(outPosition &gt; length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                       &quot;string&lt;...&gt;::replace(pos,char*...): invalid position&quot;);
    }
    if (outNumChars &gt; length() - outPosition) {
        outNumChars = length() - outPosition;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; outNumChars)
     &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                             numChars - outNumChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                            &quot;string&lt;...&gt;::replace(char*...): string too long&quot;);
    }
    return privateReplaceRaw(outPosition,
                             outNumChars,
                             characterString,
                             numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                              size_type        outPosition,
                                              size_type        outNumChars,
                                              const CHAR_TYPE *characterString)
{
    BSLS_ASSERT_SAFE(characterString);

    return replace(outPosition,
                   outNumChars,
                   characterString,
                   CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(size_type outPosition,
                                                       size_type outNumChars,
                                                       size_type numChars,
                                                       CHAR_TYPE character)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(outPosition &gt; length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                            &quot;string&lt;...&gt;::replace(pos,n,c): invalid position&quot;);
    }
    if (outNumChars &gt; length() - outPosition) {
        outNumChars = length() - outPosition;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; outNumChars)
     &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                             numChars - outNumChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                             &quot;string&lt;...&gt;::replace(pos,n,v): string too long&quot;);
    }
    return privateReplaceRaw(outPosition,
                             outNumChars,
                             numChars,
                             character);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                               const_iterator      first,
                                               const_iterator      last,
                                               const basic_string&amp; replacement)
{
    BSLS_ASSERT_SAFE(first &gt;= cbegin());
    BSLS_ASSERT_SAFE(first &lt;= cend());
    BSLS_ASSERT_SAFE(first &lt;= last);
    BSLS_ASSERT_SAFE(last &lt;= cend());

    size_type outPosition = first - cbegin();
    size_type outNumChars = last - first;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                            replacement.length() &gt; outNumChars)
     &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                 replacement.length() - outNumChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                    &quot;string&lt;...&gt;::replace(string const&amp;...): string too long&quot;);
    }
    return privateReplaceRaw(outPosition,
                             outNumChars,
                             replacement.data(),
                             replacement.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                              const_iterator   first,
                                              const_iterator   last,
                                              const CHAR_TYPE *characterString,
                                              size_type        numChars)
{
    BSLS_ASSERT_SAFE(first &gt;= cbegin());
    BSLS_ASSERT_SAFE(first &lt;= cend());
    BSLS_ASSERT_SAFE(first &lt;= last);
    BSLS_ASSERT_SAFE(last &lt;= cend());
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    size_type outPosition = first - cbegin();
    size_type outNumChars = last - first;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; outNumChars)
     &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                             numChars - outNumChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                            &quot;string&lt;...&gt;::replace(char*...): string too long&quot;);
    }
    return privateReplaceRaw(outPosition,
                             outNumChars,
                             characterString,
                             numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                              const_iterator   first,
                                              const_iterator   last,
                                              const CHAR_TYPE *characterString)
{
    BSLS_ASSERT_SAFE(first &gt;= cbegin());
    BSLS_ASSERT_SAFE(first &lt;= cend());
    BSLS_ASSERT_SAFE(first &lt;= last);
    BSLS_ASSERT_SAFE(last &lt;= cend());
    BSLS_ASSERT_SAFE(characterString);

    return replace(first,
                   last,
                   characterString,
                   CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                                      const_iterator first,
                                                      const_iterator last,
                                                      size_type      numChars,
                                                      CHAR_TYPE      character)
{
    BSLS_ASSERT_SAFE(first &gt;= cbegin());
    BSLS_ASSERT_SAFE(first &lt;= cend());
    BSLS_ASSERT_SAFE(first &lt;= last);
    BSLS_ASSERT_SAFE(last &lt;= cend());

    size_type outPosition = first - cbegin();
    size_type outNumChars = last - first;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(numChars &gt; outNumChars)
     &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                             numChars - outNumChars &gt; max_size() - length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwLengthError(
                            &quot;string&lt;...&gt;::replace(char*...): string too long&quot;);
    }
    return privateReplaceRaw(outPosition, outNumChars, numChars, character);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
template &lt;class INPUT_ITER&gt;
inline
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::replace(
                                                    const_iterator first,
                                                    const_iterator last,
                                                    INPUT_ITER     stringFirst,
                                                    INPUT_ITER     stringLast)
{
    BSLS_ASSERT_SAFE(first &gt;= cbegin());
    BSLS_ASSERT_SAFE(first &lt;= cend());
    BSLS_ASSERT_SAFE(first &lt;= last);
    BSLS_ASSERT_SAFE(last &lt;= cend());

    size_type outPosition = first - cbegin();
    size_type outNumChars = last - first;
    return privateReplaceDispatch(outPosition,
                                  outNumChars,
                                  stringFirst,
                                  stringLast,
                                  stringFirst,
                                  BloombergLP::bslmf::Nil());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
void
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::swap(basic_string&amp; other)
{
    if (get_allocator() == other.get_allocator()) {
        privateBase().swap(other.privateBase());
    }
    else {
        basic_string s1(other, this-&gt;get_allocator());
        basic_string s2(*this, other.get_allocator());

        s1.privateBase().swap(this-&gt;privateBase());
        s2.privateBase().swap(other.privateBase());
    }
}

// ACCESSORS

                     // *** 21.3.3 iterators: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::begin() const
{
    return this-&gt;dataPtr();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::cbegin() const
{
    return begin();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::end() const
{
    return begin() + this-&gt;d_length;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::cend() const
{
    return end();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_reverse_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::rbegin() const
{
    return const_reverse_iterator(end());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_reverse_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::crbegin() const
{
    return const_reverse_iterator(end());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_reverse_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::rend() const
{
    return const_reverse_iterator(begin());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_reverse_iterator
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::crend() const
{
    return const_reverse_iterator(begin());
}

                      // *** 21.3.4 capacity: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size() const
{
    return this-&gt;d_length;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::length() const
{
    return this-&gt;d_length;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::max_size() const
{
    // Must take into account the null-terminating character.

    size_type stringMaxSize = ~size_type(0) / sizeof(CHAR_TYPE) - 1;
    size_type allocMaxSize  = get_allocator().max_size() - 1;
    return allocMaxSize &lt; stringMaxSize ? allocMaxSize : stringMaxSize;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::capacity() const
{
    return this-&gt;d_capacity;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
bool basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::empty() const
{
    return this-&gt;d_length == 0;
}

                   // *** 21.3.5 element access: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_reference
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::operator[](
                                                      size_type position) const
{
    BSLS_ASSERT_SAFE(position &lt;= length());

    return *(begin() + position);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::const_reference
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::at(size_type position) const
{
    // Note: deliberately not inlined (see comment in non-const version).

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(position &gt;= length())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                                 &quot;const string&lt;...&gt;::at(n): invalid position&quot;);
    }
    return *(begin() + position);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
const CHAR_TYPE&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::front() const
{
    BSLS_ASSERT_SAFE(!empty());

    return *begin();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
const CHAR_TYPE&amp;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::back() const
{
    BSLS_ASSERT_SAFE(!empty());

    return *(end() - 1);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::copy(CHAR_TYPE *characterString,
                                                    size_type  numChars,
                                                    size_type  position) const
{
    BSLS_ASSERT_SAFE(characterString);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &lt; position)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                       &quot;const string&lt;...&gt;::copy(str,pos,n): invalid position&quot;);
    }
    if (numChars &gt; length() - position) {
        numChars = length() - position;
    }
    CHAR_TRAITS::move(characterString, this-&gt;dataPtr() + position, numChars);
    return numChars;
}

                 // *** 21.3.7 string operations: ***

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
const CHAR_TYPE *
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::c_str() const
{
    return this-&gt;dataPtr();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
const CHAR_TYPE*
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::data() const
{
    return this-&gt;dataPtr();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::allocator_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::get_allocator() const
{
    return BloombergLP::bslalg::ContainerBase&lt;allocator_type&gt;::allocator();
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find(
                                           const basic_string&amp;  substring,
                                           size_type            position) const
{
    return find(substring.data(), position, substring.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find(
                                               const CHAR_TYPE *substring,
                                               size_type        position,
                                               size_type        numChars) const
{
    BSLS_ASSERT_SAFE(substring);

    size_type remChars = length() - position;
    if (position &gt; length() || numChars &gt; remChars) {
        return npos;                                                  // RETURN
    }
    if (0 == numChars) {
        return position;                                              // RETURN
    }
    const CHAR_TYPE *thisString = this-&gt;dataPtr() + position;
    const CHAR_TYPE *nextString;
    for (remChars -= numChars - 1;
         0 != (nextString = BSLSTL_CHAR_TRAITS::find(thisString,
                                                     remChars,
                                                     *substring));
         remChars -= ++nextString - thisString, thisString = nextString)
    {
        if (0 == CHAR_TRAITS::compare(nextString, substring, numChars)) {
            return nextString - this-&gt;dataPtr();                      // RETURN
        }
    }
    return npos;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find(
                                               const CHAR_TYPE *substring,
                                               size_type        position) const
{
    BSLS_ASSERT_SAFE(substring);

    return find(substring, position, CHAR_TRAITS::length(substring));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find(CHAR_TYPE character,
                                                    size_type position) const
{
    if (position &gt;= length()) {
        return npos;                                                  // RETURN
    }
    const CHAR_TYPE *result =
        BSLSTL_CHAR_TRAITS::find(this-&gt;dataPtr() + position,
                                 length() - position,
                                 character);
    return result ? result - this-&gt;dataPtr() : npos;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::rfind(
                                            const basic_string&amp; substring,
                                            size_type           position) const
{
    return rfind(substring.data(), position, substring.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::rfind(
                                              const CHAR_TYPE *characterString,
                                              size_type        position,
                                              size_type        numChars) const
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (0 == numChars) {
        return position &gt; length() ? length() : position;             // RETURN
    }
    if (numChars &lt;= length()) {
        if (position &gt; length() - numChars) {
            position = length() - numChars;
        }
        const CHAR_TYPE *thisString = this-&gt;dataPtr() + position;
        for (; position != npos; --thisString, --position) {
            if (0 == CHAR_TRAITS::compare(thisString,
                                          characterString,
                                          numChars)) {
                return position;                                      // RETURN
            }
        }
    }
    return npos;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::rfind(
                                              const CHAR_TYPE *characterString,
                                              size_type        position) const
{
    BSLS_ASSERT_SAFE(characterString);

    return rfind(characterString,
                 position,
                 CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::rfind(CHAR_TYPE character,
                                                     size_type position) const
{
    return rfind(&amp;character, position, size_type(1));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_first_of(
                                           const basic_string&amp; characterString,
                                           size_type           position) const
{
    return find_first_of(characterString.data(),
                         position,
                         characterString.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_first_of(
                                              const CHAR_TYPE *characterString,
                                              size_type        position,
                                              size_type        numChars) const
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (0 &lt; numChars &amp;&amp; position &lt; length()) {
        for (const CHAR_TYPE *current = this-&gt;dataPtr() + position;
             current != this-&gt;dataPtr() + length();
             ++current)
        {
            if (BSLSTL_CHAR_TRAITS::find(characterString, numChars, *current)
                != 0) {
                return current - this-&gt;dataPtr();                     // RETURN
            }
        }
    }
    return npos;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_first_of(
                                              const CHAR_TYPE *characterString,
                                              size_type        position) const
{
    BSLS_ASSERT_SAFE(characterString);

    return find_first_of(characterString,
                         position,
                         CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_first_of(
                                                      CHAR_TYPE character,
                                                      size_type position) const
{
    return find_first_of(&amp;character, position, size_type(1));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_last_of(
                                           const basic_string&amp; characterString,
                                           size_type           position) const
{
    return find_last_of(characterString.data(),
                        position,
                        characterString.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_last_of(
                                              const CHAR_TYPE *characterString,
                                              size_type        position,
                                              size_type        numChars) const
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (0 &lt; numChars &amp;&amp; 0 &lt; length()) {
        size_type remChars = position &lt; length() ? position : length() - 1;
        for (const CHAR_TYPE *current = this-&gt;dataPtr() + remChars;
             ;
             --current)
        {
            if (BSLSTL_CHAR_TRAITS::find(
                                        characterString, numChars, *current)) {
                return current - this-&gt;dataPtr();                     // RETURN
            }
            if (current == this-&gt;dataPtr()) {
                break;
            }
        }
    }
    return npos;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_last_of(
                                              const CHAR_TYPE *characterString,
                                              size_type        position) const
{
    BSLS_ASSERT_SAFE(characterString);

    return find_last_of(characterString,
                        position,
                        CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_last_of(
                                                      CHAR_TYPE character,
                                                      size_type position) const
{
    return find_last_of(&amp;character, position, size_type(1));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_first_not_of(
                                           const basic_string&amp; characterString,
                                           size_type           position) const
{
    return find_first_not_of(characterString.data(),
                             position,
                             characterString.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_first_not_of(
                                              const CHAR_TYPE *characterString,
                                              size_type        position,
                                              size_type        numChars) const
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (position &lt; length()) {
        const CHAR_TYPE *last = this-&gt;dataPtr() + length();
        for (const CHAR_TYPE *current = this-&gt;dataPtr() + position;
             current != last;
             ++current)
        {
            if (!BSLSTL_CHAR_TRAITS::find(
                                        characterString, numChars, *current)) {
                return current - this-&gt;dataPtr();                     // RETURN
            }
        }
    }
    return npos;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_first_not_of(
                                              const CHAR_TYPE *characterString,
                                              size_type        position) const
{
    BSLS_ASSERT_SAFE(characterString);

    return find_first_not_of(characterString,
                             position,
                             CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_first_not_of(
                                                      CHAR_TYPE character,
                                                      size_type position) const
{
    return find_first_not_of(&amp;character, position, size_type(1));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_last_not_of (
                                           const basic_string&amp; characterString,
                                           size_type           position) const
{
    return find_last_not_of(characterString.data(),
                            position,
                            characterString.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_last_not_of (
                                              const CHAR_TYPE *characterString,
                                              size_type        position,
                                              size_type        numChars) const
{
    BSLS_ASSERT_SAFE(characterString || 0 == numChars);

    if (0 &lt; length()) {
        size_type remChars = position &lt; length() ? position : length() - 1;
        for (const CHAR_TYPE *current = this-&gt;dataPtr() + remChars;
             remChars != npos;
             --current, --remChars)
        {
            if (!BSLSTL_CHAR_TRAITS::find(
                                        characterString, numChars, *current)) {
                return current - this-&gt;dataPtr();                     // RETURN
            }
        }
    }
    return npos;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_last_not_of (
                                              const CHAR_TYPE *characterString,
                                              size_type        position) const
{
    BSLS_ASSERT_SAFE(characterString);

    return find_last_not_of(characterString,
                            position,
                            CHAR_TRAITS::length(characterString));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::find_last_not_of (
                                                      CHAR_TYPE character,
                                                      size_type position) const
{
    return find_last_not_of(&amp;character, position, size_type(1));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::substr(size_type position,
                                                      size_type numChars) const
{
    return basic_string&lt;CHAR_TYPE,
                        CHAR_TRAITS,
                        ALLOCATOR&gt;(*this, position, numChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
int basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::compare(
                                               const basic_string&amp; other) const
{
    return privateCompareRaw(size_type(0),
                             length(),
                             other.data(),
                             other.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
int basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::compare(
                                              size_type            position,
                                              size_type            numChars,
                                              const basic_string&amp;  other) const
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &lt; position)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                    &quot;const string&lt;...&gt;::compare(pos,n,...): invalid position&quot;);
    }
    if (numChars &gt; length() - position) {
        numChars = length() - position;
    }
    return privateCompareRaw(position, numChars, other.data(), other.length());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
int basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::compare(
                                       size_type           lhsPosition,
                                       size_type           lhsNumChars,
                                       const basic_string&amp; other,
                                       size_type           otherPosition,
                                       size_type           otherNumChars) const
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &lt; lhsPosition)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                    &quot;const string&lt;...&gt;::compare(pos,n,...): invalid position&quot;);
    }
    if (lhsNumChars &gt; length() - lhsPosition) {
        lhsNumChars = length() - lhsPosition;
    }
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(other.length() &lt;
                                                              otherPosition)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                    &quot;const string&lt;...&gt;::compare(pos,n,...): invalid position&quot;);
    }
    if (otherNumChars &gt; other.length() - otherPosition) {
        otherNumChars = other.length() - otherPosition;
    }
    return privateCompareRaw(lhsPosition,
                             lhsNumChars,
                             other.dataPtr() + otherPosition,
                             otherNumChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
int basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::compare(
                                                  const CHAR_TYPE *other) const
{
    BSLS_ASSERT_SAFE(other);

    return privateCompareRaw(size_type(0),
                             length(),
                             other,
                             CHAR_TRAITS::length(other));
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
int basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::compare(
                                          size_type        lhsPosition,
                                          size_type        lhsNumChars,
                                          const CHAR_TYPE *other,
                                          size_type        otherNumChars) const
{
    BSLS_ASSERT_SAFE(other);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(length() &lt; lhsPosition)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                    &quot;const string&lt;...&gt;::compare(pos,n,...): invalid position&quot;);
    }
    if (lhsNumChars &gt; length() - lhsPosition) {
        lhsNumChars = length() - lhsPosition;
    }
    return privateCompareRaw(lhsPosition,
                             lhsNumChars,
                             other,
                             otherNumChars);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
int basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::compare(
                                                  size_type        lhsPosition,
                                                  size_type        lhsNumChars,
                                                  const CHAR_TYPE *other) const
{
    BSLS_ASSERT_SAFE(other);

    return compare(lhsPosition,
                   lhsNumChars,
                   other,
                   CHAR_TRAITS::length(other));
}

}  // close namespace bsl

// FREE FUNCTIONS
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
void bsl::swap(basic_string&lt;CHAR_TYPE,CHAR_TRAITS, ALLOCATOR&gt;&amp; lhs,
               basic_string&lt;CHAR_TYPE,CHAR_TRAITS, ALLOCATOR&gt;&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.get_allocator() == rhs.get_allocator());

    lhs.swap(rhs);
}

// FREE OPERATORS
template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator==(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; lhs,
                     const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; rhs)
{
    return lhs.size() == rhs.size()
        &amp;&amp; 0 == CHAR_TRAITS::compare(lhs.data(), rhs.data(), lhs.size());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator==(
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs)
{
    return lhs.size() == rhs.size()
        &amp;&amp; 0 == CHAR_TRAITS::compare(lhs.data(), rhs.data(), lhs.size());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator==(
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs)
{
    return lhs.size() == rhs.size()
        &amp;&amp; 0 == CHAR_TRAITS::compare(lhs.data(), rhs.data(), lhs.size());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator==(const CHAR_TYPE                                  *lhs,
                     const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs)
{
    BSLS_ASSERT_SAFE(lhs);

    std::size_t len = CHAR_TRAITS::length(lhs);
    return len == rhs.size()
        &amp;&amp; 0 == CHAR_TRAITS::compare(lhs, rhs.data(), len);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator==(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; lhs,
                     const CHAR_TYPE*                                 rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    std::size_t len = CHAR_TRAITS::length(rhs);
    return lhs.size() == len
        &amp;&amp; 0 == CHAR_TRAITS::compare(lhs.data(), rhs, len);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator!=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; lhs,
                     const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator!=(
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs)
{
    return !(lhs == rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator!=(
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator!=(const CHAR_TYPE                                  *lhs,
                     const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs)
{
    BSLS_ASSERT_SAFE(lhs);

    return !(lhs == rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator!=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                     const CHAR_TYPE                                  *rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    return !(lhs == rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool bsl::operator&lt;(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; lhs,
                    const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; rhs)
{
    const std::size_t minLen = lhs.length() &lt; rhs.length()
                             ? lhs.length() : rhs.length();

    int ret = CHAR_TRAITS::compare(lhs.data(), rhs.data(), minLen);
    if (0 == ret) {
        return lhs.length() &lt; rhs.length();                           // RETURN
    }
    return ret &lt; 0;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
bsl::operator&lt;(
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs)
{
    const std::size_t minLen = lhs.length() &lt; rhs.length()
                             ? lhs.length() : rhs.length();

    int ret = CHAR_TRAITS::compare(lhs.data(), rhs.data(), minLen);
    if (0 == ret) {
        return lhs.length() &lt; rhs.length();                           // RETURN
    }
    return ret &lt; 0;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bool
bsl::operator&lt;(
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs)
{
    const std::size_t minLen = lhs.length() &lt; rhs.length()
                             ? lhs.length() : rhs.length();

    int ret = CHAR_TRAITS::compare(lhs.data(), rhs.data(), minLen);
    if (0 == ret) {
        return lhs.length() &lt; rhs.length();                           // RETURN
    }
    return ret &lt; 0;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool bsl::operator&lt;(const CHAR_TYPE                                  *lhs,
                    const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs)
{
    BSLS_ASSERT_SAFE(lhs);

    const std::size_t lhsLen = CHAR_TRAITS::length(lhs);
    const std::size_t minLen = lhsLen &lt; rhs.length() ? lhsLen : rhs.length();

    int ret = CHAR_TRAITS::compare(lhs, rhs.data(), minLen);
    if (0 == ret) {
        return lhsLen &lt; rhs.length();                                 // RETURN
    }
    return ret &lt; 0;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
bool bsl::operator&lt;(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                    const CHAR_TYPE                                  *rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    const std::size_t rhsLen = CHAR_TRAITS::length(rhs);
    const std::size_t minLen = rhsLen &lt; lhs.length() ? rhsLen : lhs.length();

    int ret = CHAR_TRAITS::compare(lhs.data(), rhs, minLen);
    if (0 == ret) {
        return lhs.length() &lt; rhsLen;                                 // RETURN
    }
    return ret &lt; 0;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&gt;(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; lhs,
                    const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; rhs)
{
    return rhs &lt; lhs;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator&gt;(
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs)
{
    return rhs &lt; lhs;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator&gt;(
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs)
{
    return rhs &lt; lhs;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&gt;(const CHAR_TYPE                                  *lhs,
                    const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs)
{
    BSLS_ASSERT_SAFE(lhs);

    return rhs &lt; lhs;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&gt;(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                    const CHAR_TYPE                                  *rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    return rhs &lt; lhs;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&lt;=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; lhs,
                     const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; rhs)
{
    return !(rhs &lt; lhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator&lt;=(
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs)
{
    return !(rhs &lt; lhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator&lt;=(
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs)
{
    return !(rhs &lt; lhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&lt;=(const CHAR_TYPE                                  *lhs,
                     const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs)
{
    BSLS_ASSERT_SAFE(lhs);

    return !(rhs &lt; lhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&lt;=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                     const CHAR_TYPE                                  *rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    return !(rhs &lt; lhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&gt;=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; lhs,
                     const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp; rhs)
{
    return !(lhs &lt; rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator&gt;=(
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs)
{
    return !(lhs &lt; rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
inline
bool
bsl::operator&gt;=(
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs)
{
    return !(lhs &lt; rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&gt;=(const CHAR_TYPE                                  *lhs,
                     const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  rhs)
{
    BSLS_ASSERT_SAFE(lhs);

    return !(lhs &lt; rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
inline
bool bsl::operator&gt;=(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC&gt;&amp;  lhs,
                     const CHAR_TYPE                                  *rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    return !(lhs &lt; rhs);
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
bsl::operator+(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp; lhs,
               const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp; rhs)
{
    basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt; result;
    result.reserve(lhs.length() + rhs.length());
    result += lhs;
    result += rhs;
    return result;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;
bsl::operator+(
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp; lhs,
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp;        rhs)
{
    bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt; result;
    result.reserve(lhs.length() + rhs.length());
    result.append(lhs.c_str(), lhs.length());
    result += rhs;
    return result;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC1, class ALLOC2&gt;
bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;
bsl::operator+(
             const bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt;&amp;        lhs,
             const native_std::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC2&gt;&amp; rhs)
{
    bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOC1&gt; result;
    result.reserve(lhs.length() + rhs.length());
    result += lhs;
    result.append(rhs.c_str(), rhs.length());
    return result;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
bsl::operator+(const CHAR_TYPE                                      *lhs,
               const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;  rhs)
{
    BSLS_ASSERT_SAFE(lhs);

    typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
                                          lhsLength = CHAR_TRAITS::length(lhs);

    basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt; result;
    result.reserve(lhsLength + rhs.length());
    result.append(lhs, lhsLength);
    result += rhs;
    return result;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
bsl::operator+(CHAR_TYPE                                            lhs,
               const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp; rhs)
{
    basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt; result;
    result.reserve(1 + rhs.length());
    result.push_back(lhs);
    result += rhs;
    return result;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
bsl::operator+(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp;  lhs,
               const CHAR_TYPE                                      *rhs)
{
    BSLS_ASSERT_SAFE(rhs);

    typename basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;::size_type
                                          rhsLength = CHAR_TRAITS::length(rhs);

    basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt; result;
    result.reserve(lhs.length() + rhsLength);
    result += lhs;
    result.append(rhs, rhsLength);
    return result;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
bsl::basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;
bsl::operator+(const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp; lhs,
               CHAR_TYPE                                            rhs)
{
    basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt; result;
    result.reserve(lhs.length() + 1);
    result += lhs;
    result.push_back(rhs);
    return result;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS&gt;
bool bslstl_string_fill(std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;   os,
                        std::basic_streambuf&lt;CHAR_TYPE, CHAR_TRAITS&gt; *buf,
                        std::size_t                                   n)
    // Do not use, for internal use by &#39;operator&lt;&lt;&#39; only.
{
    BSLS_ASSERT_SAFE(buf);

    CHAR_TYPE fillChar = os.fill();

    for (std::size_t i = 0; i &lt; n; ++i) {
        if (CHAR_TRAITS::eq_int_type(buf-&gt;sputc(fillChar), CHAR_TRAITS::eof()))
        {
            return false;                                             // RETURN
        }
    }

    return true;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
bsl::operator&lt;&lt;(std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;          os,
                const basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp; str)
{
    typedef std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt; Ostrm;
    typename Ostrm::sentry sentry(os);
    bool ok = false;

    if (sentry) {
        ok = true;
        std::size_t     n      = str.size();
        std::size_t     padLen = 0;
        bool            left   = (os.flags() &amp; Ostrm::left) != 0;
        std::streamsize w      = os.width(0);

        std::basic_streambuf&lt;CHAR_TYPE, CHAR_TRAITS&gt;* buf = os.rdbuf();

        if (w &gt; 0 &amp;&amp; std::size_t(w) &gt; n) {
            padLen = std::size_t(w) - n;
        }

        if (!left) {
            ok = bslstl_string_fill(os, buf, padLen);
        }

        ok = ok &amp;&amp; (buf-&gt;sputn(str.data(), std::streamsize(n)) ==
                        std::streamsize(n));

        if (left) {
            ok = ok &amp;&amp; bslstl_string_fill(os, buf, padLen);
        }
    }

    if (!ok) {
        os.setstate(Ostrm::failbit);
    }

    return os;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
bsl::operator&gt;&gt;(std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;     is,
                basic_string&lt;CHAR_TYPE,CHAR_TRAITS, ALLOCATOR&gt;&amp; str)
{
    typedef std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt; Istrm;
    typename Istrm::sentry sentry(is);

    if (sentry) {
        std::basic_streambuf&lt;CHAR_TYPE, CHAR_TRAITS&gt;* buf = is.rdbuf();
        typedef std::ctype&lt;CHAR_TYPE&gt; _C_type;

        const std::locale&amp; loc   = is.getloc();
        const _C_type&amp;     ctype = std::use_facet&lt;_C_type&gt;(loc);

        str.clear();
        std::streamsize n = is.width(0);
        if (n &lt;= 0) {
            n = std::numeric_limits&lt;std::streamsize&gt;::max();
        }
        else {
            str.reserve(n);
        }

        while (n-- &gt; 0) {
            typename CHAR_TRAITS::int_type c1 = buf-&gt;sbumpc();
            if (CHAR_TRAITS::eq_int_type(c1, CHAR_TRAITS::eof())) {
                is.setstate(Istrm::eofbit);
                break;
            }
            else {
                CHAR_TYPE c = CHAR_TRAITS::to_char_type(c1);

                if (ctype.is(_C_type::space, c)) {
                    if (CHAR_TRAITS::eq_int_type(buf-&gt;sputbackc(c),
                                                 CHAR_TRAITS::eof())) {
                        is.setstate(Istrm::failbit);
                    }
                    break;
                }
                else {
                    str.push_back(c);
                }
            }
        }

        // If we have read no characters, then set failbit.

        if (str.size() == 0) {
            is.setstate(Istrm::failbit);
        }
    }
    else {
        is.setstate(Istrm::failbit);
    }

    return is;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
bsl::getline(std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;    is,
             basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp; str,
             CHAR_TYPE                                      delim)
{
    typedef std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt; Istrm;
    std::size_t nread = 0;
    typename Istrm::sentry sentry(is, true);
    if (sentry) {
        std::basic_streambuf&lt;CHAR_TYPE, CHAR_TRAITS&gt;* buf = is.rdbuf();
        str.clear();

        while (nread &lt; str.max_size()) {
            int c1 = buf-&gt;sbumpc();
            if (CHAR_TRAITS::eq_int_type(c1, CHAR_TRAITS::eof())) {
                is.setstate(Istrm::eofbit);
                break;
            }

            ++nread;
            CHAR_TYPE c = CHAR_TRAITS::to_char_type(c1);
            if (!CHAR_TRAITS::eq(c, delim)) {
                str.push_back(c);
            }
            else {
                break;  // character is extracted but not appended
            }
        }
    }
    if (nread == 0 || nread &gt;= str.max_size()) {
        is.setstate(Istrm::failbit);
    }

    return is;
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
bsl::getline(std::basic_istream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;    is,
             basic_string&lt;CHAR_TYPE,CHAR_TRAITS,ALLOCATOR&gt;&amp; str)
{
    return getline(is, str, is.widen(&#39;\n&#39;));
}

// HASH SPECIALIZATIONS
template &lt;class HASHALG, class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
inline
void bsl::hashAppend(
                HASHALG&amp;                                               hashAlg,
                const basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOCATOR&gt;&amp; input)
{
    using ::BloombergLP::bslh::hashAppend;
    hashAlg(input.data(), sizeof(CHAR_TYPE)*input.size());
    hashAppend(hashAlg, input.size());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
std::size_t bsl::hashBasicString(
                    const basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOCATOR&gt;&amp; str)
{
    return ::BloombergLP::bslh::Hash&lt;&gt;()(str);
}

namespace BloombergLP {

template &lt;class HASHALG, class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt;
BSLS_PLATFORM_AGGRESSIVE_INLINE
void bslh::hashAppend(
    HASHALG&amp;                                                           hashAlg,
    const native_std::basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOCATOR&gt;&amp; input)
{
    hashAlg(input.data(), sizeof(CHAR_TYPE)*input.size());
    hashAppend(hashAlg, input.size());
}

}  // close enterprise namespace
// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for STL *sequence* containers:
//: o A sequence container defines STL iterators.
//: o A sequence container is bitwise movable if the allocator is bitwise
//:     movable.
//: o A sequence container uses &#39;bslma&#39; allocators if the parameterized
//:     &#39;ALLOCATOR&#39; is convertible from &#39;bslma::Allocator*&#39;.

namespace BloombergLP {

namespace bslalg {

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
struct HasStlIterators&lt;bsl::basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOC&gt; &gt;
    : bsl::true_type
{};

}  // close namespace bslalg

namespace bslma {

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOC&gt;
struct UsesBslmaAllocator&lt;bsl::basic_string&lt;CHAR_TYPE, CHAR_TRAITS, ALLOC&gt; &gt;
    : bsl::is_convertible&lt;Allocator *, ALLOC&gt;
{};

}  // close namespace bslma

}  // close enterprise namespace

#undef BSLSTL_CHAR_TRAITS

#ifdef BSLS_COMPILERFEATURES_SUPPORT_EXTERN_TEMPLATE
extern template class bsl::String_Imp&lt;char, bsl::string::size_type&gt;;
extern template class bsl::String_Imp&lt;wchar_t, bsl::wstring::size_type&gt;;
extern template class bsl::basic_string&lt;char&gt;;
extern template class bsl::basic_string&lt;wchar_t&gt;;
#endif

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
