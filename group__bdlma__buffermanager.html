<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bdlma_buffermanager Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_buffermanager<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a memory manager that manages an external buffer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a memory manager that manages an external buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a> </td><td>memory manager that manages an external buffer  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__bufferimputil.html" title="Provide pure procedures for allocating memory from a buffer.">Component bdlma_bufferimputil</a>, <a class="el" href="group__bdlma__bufferedsequentialallocator.html" title="Provide an efficient managed allocator using an external buffer.">Component bdlma_bufferedsequentialallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a memory manager ("buffer manager"), <code><a class="el" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a></code>, that dispenses heterogeneous memory blocks (of varying, user-specified sizes) from an external buffer. A <code>BufferManager</code> has a similar interface to a sequential pool in that the two methods <code>allocate</code> and <code>release</code> are provided. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to the <code>allocate</code> method, a less safe but faster variation, <code>allocateRaw</code>, is provided to support memory allocation: If there is insufficient memory remaining in the buffer to satisfy an allocation request, <code>allocate</code> will return 0 while <code>allocateRaw</code> will result in undefined behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The behavior of <code>allocate</code> and <code>allocateRaw</code> illustrates the main difference between this buffer manager and a sequential pool. Once the external buffer runs out of memory, the buffer manager does not self-replenish, whereas a sequential pool will do so. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>release</code> method resets the buffer manager such that the memory within the entire external buffer will be made available for subsequent allocations. Note that individually allocated memory blocks cannot be separately deallocated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a></code> is typically used for fast and efficient memory allocation, when the user knows in advance the maximum amount of memory needed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we need to detect whether there are at least <code>n</code> duplicates within an array of integers. Furthermore, suppose that speed is a concern and we need the fastest possible implementation. A natural solution will be to use a hash table. To further optimize for speed, we can use a custom memory manager, such as <code><a class="el" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a></code>, to speed up memory allocations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, let's define the structure of a node inside our custom hash table structure: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my_Node {
      <span class="comment">// This struct represents a node within a hash table.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span>      d_value;   <span class="comment">// integer value this node holds</span>
      <span class="keywordtype">int</span>      d_count;   <span class="comment">// number of occurrences of this integer value</span>
      my_Node *d_next_p;  <span class="comment">// pointer to the next node</span>

      <span class="comment">// CREATORS</span>
      my_Node(<span class="keywordtype">int</span> value, my_Node *next);
          <span class="comment">// Create a node having the specified &#39;value&#39; that refers to the</span>
          <span class="comment">// specified &#39;next&#39; node.</span>
  };

  <span class="comment">// CREATORS</span>
  my_Node::my_Node(<span class="keywordtype">int</span> value, my_Node *next)
  : d_value(value)
  , d_count(1)
  , d_next_p(next)
  {
  }
</pre></div><br/>
<br/>
 Note that <code>sizeof(my_Node) == 12</code> when compiled in 32-bit mode, and <code>sizeof(my_Node) == 16</code> when compiled in 64-bit mode. This difference affects the amount of memory used under different alignment strategies (see <code>bsls_alignment</code> for more details on alignment strategies). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can then define the structure of our specialized hash table used for integer counting: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_IntegerCountingHashTable {
      <span class="comment">// This class represents a hash table that is used to keep track of the</span>
      <span class="comment">// number of occurrences of various integers.  Note that this is a</span>
      <span class="comment">// highly specialized class that uses a &#39;bdlma::BufferManager&#39; with</span>
      <span class="comment">// sufficient memory for memory allocations.</span>

      <span class="comment">// DATA</span>
      my_Node              **d_nodeArray;  <span class="comment">// array of &#39;my_Node&#39; pointers</span>

      <span class="keywordtype">int</span>                    d_size;       <span class="comment">// size of the node array</span>

      <a class="code" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a>  *d_buffer;     <span class="comment">// buffer manager (held, not</span>
                                           <span class="comment">// owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> calculateBufferSize(<span class="keywordtype">int</span> tableLength, <span class="keywordtype">int</span> numNodes);
          <span class="comment">// Return the memory required by a &#39;my_IntegerCountingHashTable&#39;</span>
          <span class="comment">// that has the specified &#39;tableLength&#39; and &#39;numNodes&#39;.</span>

      <span class="comment">// CREATORS</span>
      my_IntegerCountingHashTable(<span class="keywordtype">int</span> size, <a class="code" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a> *buffer);
          <span class="comment">// Create a hash table of the specified &#39;size&#39;, using the specified</span>
          <span class="comment">// &#39;buffer&#39; to supply memory.  The behavior is undefined unless</span>
          <span class="comment">// &#39;0 &lt; size&#39;, &#39;buffer&#39; is non-zero, and &#39;buffer&#39; has sufficient</span>
          <span class="comment">// memory to support all memory allocations required.</span>

      <span class="comment">// ...</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> insert(<span class="keywordtype">int</span> value);
          <span class="comment">// Insert the specified &#39;value&#39; with a count of 1 into this hash</span>
          <span class="comment">// table if &#39;value&#39; does not currently exist in the hash table, and</span>
          <span class="comment">// increment the count for &#39;value&#39; otherwise.  Return the number of</span>
          <span class="comment">// occurrences of &#39;value&#39; in this hash table.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 The implementation of the rest of <code>my_IntegerCountingHashTable</code> is elided as the class method <code>calculateBufferSize</code>, constructor, and the <code>insert</code> method alone are sufficient to illustrate the use of <code><a class="el" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CLASS METHODS</span>
  <span class="keywordtype">int</span> my_IntegerCountingHashTable::calculateBufferSize(<span class="keywordtype">int</span> tableLength,
                                                       <span class="keywordtype">int</span> numNodes)
  {
      <span class="keywordflow">return</span> tableLength * <span class="keyword">sizeof</span>(my_Node *) + numNodes * <span class="keyword">sizeof</span>(my_Node)
                                   + bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT;
  }
</pre></div><br/>
<br/>
 Note that, in case the allocated buffer is not aligned, the size calculation includes a "fudge" factor equivalent to the maximum alignment requirement of the platform. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  my_IntegerCountingHashTable::my_IntegerCountingHashTable(
                                                <span class="keywordtype">int</span>                   size,
                                                <a class="code" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a> *buffer)
  : d_size(size)
  , d_buffer(buffer)
  {
      <span class="comment">// &#39;d_buffer&#39; must have sufficient memory to satisfy the allocation</span>
      <span class="comment">// request (as specified by the constructor&#39;s contract).</span>

      d_nodeArray = <span class="keyword">static_cast&lt;</span>my_Node **<span class="keyword">&gt;</span>(
                             d_buffer-&gt;allocate(d_size * <span class="keyword">sizeof</span>(my_Node *)));

      bsl::memset(d_nodeArray, 0, d_size * <span class="keyword">sizeof</span>(my_Node *));
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">int</span> my_IntegerCountingHashTable::insert(<span class="keywordtype">int</span> value)
  {
      <span class="comment">// Naive hash function using only mod.</span>

      <span class="keyword">const</span> <span class="keywordtype">int</span> hashValue = value % d_size;
      my_Node **tmp       = &amp;d_nodeArray[hashValue];

      <span class="keywordflow">while</span> (*tmp) {
          <span class="keywordflow">if</span> ((*tmp)-&gt;d_value != value) {
              tmp = &amp;((*tmp)-&gt;d_next_p);
          }
          <span class="keywordflow">else</span> {
              <span class="keywordflow">return</span> ++((*tmp)-&gt;d_count);
          }
      }

      <span class="comment">// &#39;allocate&#39; does not trigger dynamic memory allocation.  Therefore,</span>
      <span class="comment">// we don&#39;t have to worry about exceptions and can use placement &#39;new&#39;</span>
      <span class="comment">// directly with &#39;allocate&#39;.  &#39;d_buffer&#39; must have sufficient memory to</span>
      <span class="comment">// satisfy the allocation request (as specified by the constructor&#39;s</span>
      <span class="comment">// contract).</span>

      *tmp = <span class="keyword">new</span>(d_buffer-&gt;allocate(<span class="keyword">sizeof</span>(my_Node))) my_Node(value, *tmp);

      <span class="keywordflow">return</span> 1;
  }
</pre></div><br/>
<br/>
 Note that <code><a class="el" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a></code> is used to allocate memory blocks of heterogeneous sizes. In the constructor, memory is allocated for the node array. In <code>insert</code>, memory is allocated for the nodes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, in the following <code>detectNOccurrences</code> function, we can use the hash table class to detect whether any integer value occurs at least <code>n</code> times within a specified array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> detectNOccurrences(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">int</span> *array, <span class="keywordtype">int</span> length)
      <span class="comment">// Return &#39;true&#39; if any integer value in the specified &#39;array&#39; having</span>
      <span class="comment">// the specified &#39;length&#39; appears at least the specified &#39;n&#39; times, and</span>
      <span class="comment">// &#39;false&#39; otherwise.</span>
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_SIZE = my_IntegerCountingHashTable::
                                         calculateBufferSize(length, length);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We then allocate an external buffer to be used by <code><a class="el" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a></code>. Normally, this buffer will be created on the program stack if we know the length in advance (for example, if we specify in the contract of this function that we only handle arrays having a length of up to 10,000 integers). However, to make this function more general, we decide to allocate the memory dynamically. This approach is still much more efficient than using the default allocator, say, to allocate memory for individual nodes within <code>insert</code>, since we need only a single dynamic allocation, versus separate dynamic allocations for every single node: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = <a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>();
      <span class="keywordtype">char</span> *buffer = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(allocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>(MAX_SIZE));
</pre></div><br/>
<br/>
 We use a <code><a class="el" href="classbslma_1_1DeallocatorGuard.html">bslma::DeallocatorGuard</a></code> to automatically deallocate the buffer when the function ends: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslma_1_1DeallocatorGuard.html">bslma::DeallocatorGuard&lt;bslma::Allocator&gt;</a> guard(buffer, allocator);

      <a class="code" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a> bufferManager(buffer, MAX_SIZE);
      my_IntegerCountingHashTable table(length, &amp;bufferManager);

      <span class="keywordflow">while</span> (--length &gt;= 0) {
          <span class="keywordflow">if</span> (n == table.insert(array[length])) {
              <span class="keywordflow">return</span> <span class="keyword">true</span>;                                          <span class="comment">// RETURN</span>
          }
      }

      <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }
</pre></div><br/>
<br/>
 Note that the calculation of <code>MAX_SIZE</code> assumes natural alignment. If maximum alignment is used instead, a larger buffer is needed since each node object will then be maximally aligned, which takes up 16 bytes each instead of 12 bytes on a 32-bit architecture. On a 64-bit architecture, there will be no savings using natural alignment since the size of a node will be 16 bytes regardless. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:19 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
