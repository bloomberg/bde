<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bsls_exceptionutil.h                                               -*-C++-*-
#ifndef INCLUDED_BSLS_EXCEPTIONUTIL
#define INCLUDED_BSLS_EXCEPTIONUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide simplified exception constructs for non-exception builds.
//
//@CLASSES:
//
//@MACROS:
//  BSLS_TRY: begin a &#39;try&#39;-block
//  BSLS_CATCH(X): begin a &#39;catch&#39;-block for exception &#39;X&#39;
//  BSLS_THROW(X): &#39;throw&#39; exception &#39;X&#39;
//  BSLS_RETHROW: re-&#39;throw&#39; the current exception
//  BSLS_EXCEPTION_SPEC(SPEC): add &#39;SPEC&#39; to function exception specification
//  BSLS_NOTHROW_SPEC: declare that a function throws no exceptions
//
//@DESCRIPTION: Code that uses &#39;try&#39;, &#39;throw&#39; and &#39;catch&#39; constructs will
// often fail to compile when exceptions are disabled using a compiler switch,
// even if the &#39;throw&#39; statement is unlikely to be executed at run-time or if
// the &#39;catch&#39; clause can safely ignore an exception that will never occur.
// This component provides macros to replace &#39;try&#39;, &#39;throw&#39; and &#39;catch&#39;.
// These macros expand to normal exception constructs when exceptions are
// enabled and reasonable alternatives (usually no-ops) when exceptions are
// disabled.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Using &#39;bsls_exceptionutil&#39; to Implement &#39;vector&#39;
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we wanted to define an implementation of a standard-defined
// &#39;vector&#39; template.  Unfortunately, the C++ standard requires that &#39;vector&#39;
// provide an &#39;at&#39; method that throws an &#39;out_of_range&#39; exception
// if the supplied index is not in the valid range of elements in the vector.
// In this example we show using &#39;BSLS_THROW&#39; so that such an implementation
// will compile in both exception enabled and non-exception enabled builds.
// Note that apart from memory allocation, and where required by the C++
// standard, types defined in the BDE libraries do not throw exceptions, and
// are typically &quot;exception neutral&quot; (see {&#39;bsldoc_glossary&#39;}), meaning they
// behave reasonably in the presence of injected exceptions, but do not
// themselves throw any exceptions.
//
// First we open a namespace &#39;myStd&#39; and define an &#39;out_of_range&#39; exception
// that the &#39;at&#39; method will throw (note that in practice, &#39;out_of_range&#39;
// would inherit from &#39;logic_error&#39;)&#39;:
//..
//  namespace myStd {
//
//  class out_of_range  // ...
//  {
//     // ...
//  };
//..
// Next, we declare the &#39;vector&#39; template and its template parameters (note
// that the majority of the implementation is elided, for clarity):
//..
//  template &lt;class VALUE, class ALLOCATOR /* ... */&gt;
//  class vector {
//      // DATA
//      VALUE *d_begin_p;
//      VALUE *d_end_p;
//      // ...
//
//    public:
//
//      typedef typename ALLOCATOR::size_type size_type;
//
//      //...
//..
// Then, we define the &#39;at&#39; method, which is required to throw an
// &#39;out_of_range&#39; exception.
//..
//      const VALUE&amp; at(size_type index) const
//      {
//          if (d_begin_p + index &lt; d_end_p) {
//              return d_begin_p[index];                              // RETURN
//          }
//..
// Now, we use &#39;BSLS_THROW&#39; to throw an &#39;out_of_range&#39; exception:
//..
//          BSLS_THROW(out_of_range(/* ... */));
//      }
//..
// Finally, we complete the (mostly elided) &#39;vector&#39; implementation:
//..
//      // ...
//
//  };
//
//  }  // close namespace myStd
//..
//
///Example 2: Using &#39;bsls_exceptionutil&#39; to Throw and Catch Exceptions
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// The following example demonstrates the macros defined in the
// &#39;bsls_exceptionutil&#39; component to both throw and catch exceptions in a way
// that will allow the code to compile in non-exception enabled builds.
//
// First, we define a couple of example exception classes (note that we cannot
// use &#39;bsl::exception&#39; in this example, as this component is defined below
//&#39;bsl_exception.h&#39;):
//..
//  class my_ExClass1
//  {
//  };
//
//  class my_ExClass2
//  {
//  };
//..
// Then, we define a function that never throws an exception, and use the
// &#39;BSLS_NOTHROW_SPEC&#39; to ensure the no-throw exception specification will be
// present in exception enabled builds, and elided in non-exception enabled
// builds:
//..
//  int noThrowFunc() BSLS_NOTHROW_SPEC
//  {
//      return -1;
//  }
//..
// Next, we define a function that might throw &#39;my_ExClass1&#39; or &#39;my_ExClass2&#39;,
// and we use the &#39;BSLS_EXCEPTION_SPEC&#39; to ensure the exception specification
// will be present in exception enabled builds, and elided in non-exception
// builds:
//..
//  int mightThrowFunc(int i) BSLS_EXCEPTION_SPEC((my_ExClass1, my_ExClass2))
//  {
//      switch (i) {
//        case 0: break;
//        case 1: BSLS_THROW(my_ExClass1());
//        case 2: BSLS_THROW(my_ExClass2());
//      }
//      return i;
//  }
//..
// Then, we start the definition of a &#39;testMain&#39; function:
//..
//  int testMain()
//  {
//..
// Next, we use the &#39;BDE_BUILD_TARGET_EXC&#39; exception build flag to determine,
// at compile time, whether to initialize &#39;ITERATIONS&#39; to 3 (for exception
// enabled builds) or 1 (for non-exception enabled builds).  The different
// values of the &#39;ITERATOR&#39; ensure the subsequent for-loop calls
// &#39;mightThrowFunc&#39; in a way that generates exceptions for only exception
// enabled builds:
//..
//  #ifdef BDE_BUILD_TARGET_EXC
//      const int ITERATIONS = 3;
//  #else
//      const int ITERATIONS = 1;
//  #endif
//
//      for (int i = 0; i &lt; ITERATIONS; ++i) {
//..
// Then, we use a pair of nested &#39;try&#39; blocks constructed using
// &#39;BSLS_TRY&#39;, so that the code will compile whether or not exceptions are
// enabled (note that the curly brace placement is identical to normal
// &#39;try&#39; and &#39;catch&#39; constructs):
//..
//          int caught = -1;
//          BSLS_TRY {
//
//              BSLS_TRY {
//                  noThrowFunc();
//                  mightThrowFunc(i);
//..
// Notice that this example is careful to call &#39;mightThrowFunc&#39; in such a way
// that it will not throw in non-exception builds.  Although the use of
// &#39;BSLS_TRY&#39;, &#39;BSLS_THROW&#39;, and &#39;BSLS_CATCH&#39; ensures the code *compiles* in
// both exception, and non-exception enabled builds, attempting to
// &#39;BSLS_THROW&#39; an exception in a non-exception enabled build will invoke the
// assert handler and will typically abort the task.
//..
//                  caught = 0; // Got here if no throw
//              }
//..
// Next, we use &#39;BSLS_CATCH&#39; to define blocks for handling exceptions that may
// have been thrown from the preceding &#39;BSLS_TRY&#39;:
//..
//              BSLS_CATCH(my_ExClass1) {
//                  caught = 1;
//              }
//              BSLS_CATCH(...) {
//..
// Here, within the catch-all handler, we use the &#39;BSLS_RETHROW&#39; macro to
// re-throw the exception to the outer &#39;try&#39; block:
//..
//                  BSLS_RETHROW;
//              } // end inner try-catch
//          }
//          BSLS_CATCH(my_ExClass2) {
//              caught = 2;
//          }
//          BSLS_CATCH(...) {
//              assert(&quot;Should not get here&quot; &amp;&amp; 0);
//          } // end outer try-catch
//
//          if (0 != caught) {
//              if (verbose)
//              printf(&quot;Caught exception my_ExClass: %d\n&quot;, caught);
//          }
//          else {
//              if (verbose)
//              printf(&quot;Caught no exceptions: %d\n&quot;, caught);
//          }
//          assert(i == caught);
//
//      } // end for (i)
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

                        // ======
                        // macros
                        // ======

#ifdef BDE_BUILD_TARGET_EXC

        // ------------------
        // Exceptions enabled
        // ------------------

#   define BSLS_TRY try
        // Start a try block.
        // Exceptions enabled: &#39;try&#39;
        // Exceptions disabled: start of a normal (non-try) block

#   define BSLS_CATCH(X) catch (X)
        // Catch exception &#39;X&#39;.  &#39;X&#39; must be a type with optional variable name
        // Exceptions enabled: &#39;catch (X)&#39;
        // Exceptions disabled: ignore following block

#   define BSLS_THROW(X) throw X
        // Throw exception object &#39;X&#39;.
        // Exceptions enabled: &#39;throw (X)&#39;
        // Exceptions disabled: abort with a message

#   define BSLS_RETHROW throw
        // Within a &#39;BSLS_CATCH&#39; clause, re-throw the last exception
        // Exceptions enabled: &#39;throw&#39;
        // Exceptions disabled: abort with a message

#   define BSLS_EXCEPTION_SPEC(SPEC) throw SPEC
        // Declare the exception specification for a function.
        // Usage:
        //..
        //  void f() BSLS_EXCEPTION_SPEC((std::logic_error));
        //..
        // &#39;SPEC&#39; must be a comma-separated list of one or more exception
        // types enclosed in parenthesis.  (Double parenthesis are mandatory)
        // Use &#39;BSLS_NOTHROW_SPEC&#39; (below) to declare that a function does not
        // throw.
        // Exceptions enabled: &#39;throw SPEC&#39;
        // Exceptions disabled: empty

#   define BSLS_NOTHROW_SPEC throw ()
        // Declare that a function does not throw any exceptions:
        // Usage:
        //..
        //  void f() BSLS_NOTHROW_SPEC;
        //..
        // Exceptions enabled: &#39;throw ()&#39;
        // Exceptions disabled: empty

#else // If exceptions are disabled

        // -------------------
        // Exceptions disabled
        // -------------------

#   define BSLS_TRY if (1)

#   define BSLS_CATCH(X) else if (0)

#   define BSLS_THROW(X)                                                    \
    BloombergLP::bsls::Assert::invokeHandler(&quot;Tried to throw &quot; #X           \
                                            &quot; with exceptions disabled&quot;,    \
                                            __FILE__, __LINE__)

#   define BSLS_RETHROW                                                     \
    BloombergLP::bsls::Assert::invokeHandler(&quot;Tried to re-throw exception &quot; \
                                            &quot;with exceptions disabled&quot;,     \
                                            __FILE__, __LINE__)

#   define BSLS_EXCEPTION_SPEC(SPEC)

#   define BSLS_NOTHROW_SPEC

#endif // BDE_BUILD_TARGET_EXC

namespace BloombergLP
{
}  // close namespace BloombergLP

#endif // ! defined(INCLUDED_BSLS_EXCEPTIONUTIL)

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
