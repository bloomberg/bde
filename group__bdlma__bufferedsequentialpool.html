<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_bufferedsequentialpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_bufferedsequentialpool<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide sequential memory using an external buffer and a fallback.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__bufferedsequentialpool.html#gae18335d3caf814f9f9cd5250ec6696ad">operator new</a> (bsl::size_t size, BloombergLP::bdlma::BufferedSequentialPool &amp;pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__bufferedsequentialpool.html#gaa564d26c9804cdedf140db32da6c1ca7">operator delete</a> (void *address, BloombergLP::bdlma::BufferedSequentialPool &amp;pool)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
&nbsp; <ul>
<li>
<a href="#3.0.1">Optional <code>maxBufferSize</code> Parameter</a> </li>
</ul>
</li>
<li>
<a href="#3.1">Warning</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using <code>bdlma::BufferedSequentialPool</code> for Efficient Allocations</a> </li>
<li>
<a href="#3.2.2">Example 2: Implementing an Allocator Using <code>bdlma::BufferedSequentialPool</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide sequential memory using an external buffer and a fallback. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a> </td><td>pool using an external buffer and a fallback  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__buffermanager.html" title="Provide a memory manager that manages an external buffer.">Component bdlma_buffermanager</a>, <a class="el" href="group__bdlma__sequentialpool.html" title="Provide sequential memory using dynamically-allocated buffers.">Component bdlma_sequentialpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a maximally efficient sequential memory pool, <code><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a></code>, that dispenses heterogeneous memory blocks (of varying, user-specified sizes) from an external buffer. If an allocation request exceeds the remaining free memory space in the external buffer, the pool will fall back to a sequence of dynamically allocated buffers. Users can optionally specify a growth strategy at construction that governs the growth rate of the dynamically-allocated buffers. If no growth strategy is specified at construction, geometric growth is used. Users can also optionally specify an alignment strategy at construction that governs the alignment of allocated memory blocks. If no alignment strategy is specified, natural alignment is used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a></code> is typically used when users have a reasonable estimation of the amount of memory needed. This amount of memory would typically be created directly on the program stack, and used as the initial external buffer of the pool for fast memory allocation. While the buffer has sufficient capacity, memory allocations using the pool will not trigger <em>any</em> dynamic memory allocation, will have optimal locality of reference, and will not require deallocation upon destruction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once the external buffer is exhausted, subsequent allocation requests require dynamic memory allocation, and the performance of the pool degrades. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="optional_maxbuffersize_parameter"></a> <a class="anchor" id=".optional_maxbuffersize_parameter"></a> <a class="anchor" id="description..optional_maxbuffersize_parameter"></a> <a class="anchor" id="3.0.1"></a> </dd></dl>
<dl class="user"><dt><b>Optional maxBufferSize Parameter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An optional <code>maxBufferSize</code> parameter can be supplied at construction to specify the maximum size (in bytes) of the dynamically-allocated buffers for geometric growth. Once the internal buffer grows up to the <code>maxBufferSize</code>, further requests that exceed this size will be served by a separate memory block instead of the internal buffer. The behavior is undefined unless <code>size &lt;= maxBufferSize</code>, where <code>size</code> is the extent (in bytes) of the external buffer supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="warning"></a> <a class="anchor" id="description.warning"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Warning: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that, even when a buffer having <code>n</code> bytes of memory is supplied at construction, it does <em>not</em> mean that <code>n</code> bytes of memory are available before dynamic memory allocation is triggered. This is due to memory alignment requirements. If the buffer supplied is not aligned, the first call to the <code>allocate</code> method may automatically skip one or more bytes such that the memory allocated is properly aligned. The number of bytes that are wasted depends on whether natural alignment, maximum alignment, or 1-byte alignment is used (see <code>bsls_alignment</code> for more details). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_bdlma~3A~3Abufferedsequentialpool_for_efficient_allocations"></a> <a class="anchor" id="usage.example_1~3A_using_bdlma~3A~3Abufferedsequentialpool_for_efficient_allocations"></a> <a class="anchor" id="description.usage.example_1~3A_using_bdlma~3A~3Abufferedsequentialpool_for_efficient_allocations"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using bdlma::BufferedSequentialPool for Efficient Allocations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we define a container class, <code>my_BufferedIntDoubleArray</code>, that holds both <code>int</code> and <code>double</code> values. The class can be implemented using two parallel arrays: one storing the type information, and the other storing pointers to the <code>int</code> and <code>double</code> values. Furthermore, if we can approximate the amount of memory needed, we can use a <code><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a></code> for memory allocation for maximum efficiency: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_bufferedintdoublearray.h</span>

  <span class="keyword">class </span>my_BufferedIntDoubleArray {
      <span class="comment">// This class implements an efficient container for an array that</span>
      <span class="comment">// stores both &#39;int&#39; and &#39;double&#39; values.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span>  *d_typeArray_p;   <span class="comment">// array indicating the type of corresponding</span>
                              <span class="comment">// values stored in &#39;d_valueArray_p&#39;</span>

      <span class="keywordtype">void</span> **d_valueArray_p;  <span class="comment">// array of pointers to the values stored</span>

      <span class="keywordtype">int</span>    d_length;        <span class="comment">// number of values stored</span>

      <span class="keywordtype">int</span>    d_capacity;      <span class="comment">// physical capacity of the type and value</span>
                              <span class="comment">// arrays</span>

      <a class="code" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a>
             d_pool;          <span class="comment">// buffered sequential memory pool used to</span>
                              <span class="comment">// supply memory</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> increaseCapacity();
          <span class="comment">// Increase the capacity of the internal arrays used to store</span>
          <span class="comment">// elements added to this array by at least one element.</span>

      <span class="comment">// Not implemented:</span>
      my_BufferedIntDoubleArray(<span class="keyword">const</span> my_BufferedIntDoubleArray&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a> { k_MY_INT, k_MY_DOUBLE };

      <span class="comment">// CREATORS</span>
      my_BufferedIntDoubleArray(<span class="keywordtype">char</span>             *buffer,
                                <span class="keywordtype">int</span>               size,
                                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a fast &#39;int&#39;-&#39;double&#39; array that initially allocates</span>
          <span class="comment">// memory sequentially from the specified &#39;buffer&#39; having the</span>
          <span class="comment">// specified &#39;size&#39; (in bytes).  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory if &#39;buffer&#39; capacity is</span>
          <span class="comment">// exceeded.  If &#39;basicAllocator&#39; is 0, the currently installed</span>
          <span class="comment">// default allocator is used.</span>

      ~my_BufferedIntDoubleArray();
          <span class="comment">// Destroy this array and all elements held by it.</span>

      <span class="comment">// ...</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> appendInt(<span class="keywordtype">int</span> value);
          <span class="comment">// Append the specified &#39;int&#39; &#39;value&#39; to this array.</span>

      <span class="keywordtype">void</span> appendDouble(<span class="keywordtype">double</span> value);
          <span class="comment">// Append the specified &#39;double&#39; &#39;value&#39; to this array.</span>

      <span class="keywordtype">void</span> removeAll();
          <span class="comment">// Remove all elements from this array.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 The use of a buffered sequential pool and the <code>release</code> method allows the <code>removeAll</code> method to quickly deallocate memory of all elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_BufferedIntDoubleArray::removeAll()
  {
      d_pool.<a class="code" href="classbdlma_1_1Pool.html#afd51c71be6e7ab898b79e8a0b61090b0">release</a>();  <span class="comment">// *very* efficient if &#39;d_pool&#39; has not exhausted</span>
                         <span class="comment">// the buffer supplied at construction</span>

      d_length = 0;
  }
</pre></div><br/>
<br/>
 The buffered sequential pool optimizes the allocation of memory by using a buffer supplied at construction. As described in the "DESCRIPTION" section, the need for <em>all</em> dynamic memory allocations are eliminated provided that the buffer is not exhausted. The pool provides maximal memory allocation efficiency: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_bufferedintdoublearray.cpp</span>

  <span class="keyword">enum</span> { k_INITIAL_SIZE = 1 };

  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keywordtype">void</span> my_BufferedIntDoubleArray::increaseCapacity()
  {
      <span class="comment">// Implementation elided.</span>
      <span class="comment">// ...</span>
  }

  <span class="comment">// CREATORS</span>
  my_BufferedIntDoubleArray::my_BufferedIntDoubleArray(
                                            <span class="keywordtype">char</span>             *buffer,
                                            <span class="keywordtype">int</span>               size,
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_length(0)
  , d_capacity(k_INITIAL_SIZE)
  , d_pool(buffer, size, basicAllocator)
  {
      d_typeArray_p  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(
                       d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(d_capacity * <span class="keyword">sizeof</span> *d_typeArray_p));
      d_valueArray_p = <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> **<span class="keyword">&gt;</span>(
                       d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(d_capacity * <span class="keyword">sizeof</span> *d_valueArray_p));
  }
</pre></div><br/>
<br/>
 Note that in the destructor, all outstanding memory blocks are deallocated automatically when <code>d_pool</code> is destroyed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_BufferedIntDoubleArray::~my_BufferedIntDoubleArray()
  {
      assert(0 &lt;= d_length);
      assert(0 &lt;= d_capacity);
      assert(d_length &lt;= d_capacity);
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> my_BufferedIntDoubleArray::appendInt(<span class="keywordtype">int</span> value)
  {
      <span class="keywordflow">if</span> (d_length &gt;= d_capacity) {
          increaseCapacity();
      }

      <span class="keywordtype">int</span> *item = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(<span class="keyword">sizeof</span> *item));
      *item = value;

      d_typeArray_p[d_length]  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(k_MY_INT);
      d_valueArray_p[d_length] = item;

      ++d_length;
  }

  <span class="keywordtype">void</span> my_BufferedIntDoubleArray::appendDouble(<span class="keywordtype">double</span> value)
  {
      <span class="keywordflow">if</span> (d_length &gt;= d_capacity) {
          increaseCapacity();
      }

      <span class="keywordtype">double</span> *item = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span> *<span class="keyword">&gt;</span>(d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(<span class="keyword">sizeof</span> *item));
      *item = value;

      d_typeArray_p[d_length]  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(k_MY_DOUBLE);
      d_valueArray_p[d_length] = item;

      ++d_length;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_implementing_an_allocator_using_bdlma~3A~3Abufferedsequentialpool"></a> <a class="anchor" id="usage.example_2~3A_implementing_an_allocator_using_bdlma~3A~3Abufferedsequentialpool"></a> <a class="anchor" id="description.usage.example_2~3A_implementing_an_allocator_using_bdlma~3A~3Abufferedsequentialpool"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Implementing an Allocator Using bdlma::BufferedSequentialPool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> is used throughout the interfaces of BDE components. Suppose we would like to create a fast allocator, <code>my_FastAllocator</code>, that allocates memory from a buffer in a similar fashion to <code><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a></code>. <code><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a></code> can be used directly to implement such an allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the documentation for this class is simplified for this usage example. Please see <code>bdlma_bufferedsequentialallocator</code> for full documentation of a similar class. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_FastAllocator : <span class="keyword">public</span> bslma::Allocator {
      <span class="comment">// This class implements the &#39;bslma::Allocator&#39; protocol to provide a</span>
      <span class="comment">// fast allocator of heterogeneous blocks of memory (of varying,</span>
      <span class="comment">// user-specified sizes) from an external buffer whose address and size</span>
      <span class="comment">// are supplied at construction.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a> d_pool;  <span class="comment">// memory manager for allocated</span>
                                             <span class="comment">// memory blocks</span>

      <span class="comment">// CREATORS</span>
      my_FastAllocator(<span class="keywordtype">char</span>             *buffer,
                       <span class="keywordtype">int</span>               size,
                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an allocator for allocating memory blocks from the</span>
          <span class="comment">// specified external &#39;buffer&#39; of the specified &#39;size&#39; (in bytes).</span>
          <span class="comment">// Optionally specify a &#39;basicAllocator&#39; used to supply memory</span>
          <span class="comment">// should the capacity of &#39;buffer&#39; be exhausted.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

      ~my_FastAllocator();
          <span class="comment">// Destroy this allocator.  All memory allocated from this</span>
          <span class="comment">// allocator is released.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(size_type size);
          <span class="comment">// Return the address of a contiguous block of memory of the</span>
          <span class="comment">// specified &#39;size&#39; (in bytes).</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
          <span class="comment">// This method has no effect on the memory block at the specified</span>
          <span class="comment">// &#39;address&#39; as all memory allocated by this allocator is managed.</span>
          <span class="comment">// The behavior is undefined unless &#39;address&#39; was allocated by this</span>
          <span class="comment">// allocator, and has not already been deallocated.</span>
  };

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_FastAllocator::my_FastAllocator(<span class="keywordtype">char</span>             *buffer,
                                     <span class="keywordtype">int</span>               size,
                                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_pool(buffer, size, basicAllocator)
  {
  }

  <span class="keyword">inline</span>
  my_FastAllocator::~my_FastAllocator()
  {
      d_pool.<a class="code" href="classbdlma_1_1Pool.html#afd51c71be6e7ab898b79e8a0b61090b0">release</a>();
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> *my_FastAllocator::allocate(size_type size)
  {
      <span class="keywordflow">return</span> d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(size);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_FastAllocator::deallocate(<span class="keywordtype">void</span> *)
  {
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae18335d3caf814f9f9cd5250ec6696ad"></a><!-- doxytag: member="bdlma_bufferedsequentialpool.h::operator new" ref="gae18335d3caf814f9f9cd5250ec6696ad" args="(bsl::size_t size, BloombergLP::bdlma::BufferedSequentialPool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::BufferedSequentialPool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a block of memory of the specified <code>size</code> (in bytes) allocated from the specified <code>pool</code>. Note that an object may allocate additional memory internally, requiring the allocator to be passed in as a constructor argument: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      my_Type *newMyType(<a class="code" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a> *pool,
                         <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>              *basicAllocator)
      {
          <span class="keywordflow">return</span> <span class="keyword">new</span> (*pool) my_Type(..., basicAllocator);
      }
</pre></div><p><br/>
<br/>
 Also note that the analogous version of <code>operator delete</code> should not be called directly. Instead, this component provides a static template member function, <code>deleteObject</code>, parameterized by <code>TYPE</code> that performs the following: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> deleteMyType(<a class="code" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a> *pool, my_Type *t)
      {
          t-&gt;~my_Type();
      }
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="gaa564d26c9804cdedf140db32da6c1ca7"></a><!-- doxytag: member="bdlma_bufferedsequentialpool.h::operator delete" ref="gaa564d26c9804cdedf140db32da6c1ca7" args="(void *address, BloombergLP::bdlma::BufferedSequentialPool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::BufferedSequentialPool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the specified <code>pool</code> to deallocate the memory at the specified <code>address</code>. The behavior is undefined unless <code>address</code> was allocated using <code>pool</code> and has not already been deallocated. This operator is supplied solely to allow the compiler to arrange for it to be called in case of an exception. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:44 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
