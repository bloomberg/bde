<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bslx::TestOutStream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslx.html">bslx</a>      </li>
      <li><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bslx::TestOutStream Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslx::TestOutStream" -->
<p><code>#include &lt;<a class="el" href="bslx__testoutstream_8h_source.html">bslx_testoutstream.h</a>&gt;</code></p>

<p><a href="classbslx_1_1TestOutStream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a7c4f031d01d08e26340d1dd2305efe2d">TestOutStream</a> (int versionSelector, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a0f1e01d6b55576577608bf5f6c11918a">TestOutStream</a> (int versionSelector, bsl::size_t initialCapacity, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a9efa46b6bdf387c01963ae74d1a265a5">~TestOutStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a494de2710973ccbb96fdbcedf8d63d31">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a4b189fd3bc057323ff58839ce0fad81e">makeNextInvalid</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a6d9e2f5efe1496491368d0be72532dc8">putLength</a> (int length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#aeed8e1b9b65bbbbcc13b2bfc9e59e14d">putVersion</a> (int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a69f30c1bc7462a4e3bc4e741fcead126">reserveCapacity</a> (bsl::size_t newCapacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a70e0904e6f0c9804d1e0232654329b38">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#af9e9af7d6aa95e84f4824702bf9b8434">putInt64</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#aa5a989d81baaaf97f8823c72590a1995">putUint64</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a0b11aa747a7adfda2f59890e1607162f">putInt56</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#af74a104e81a18350d5a792ec5bebfb02">putUint56</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a6b712424f82ab0dc2d75a4e11d62b8de">putInt48</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a6ec3e673fe28c724c057b3aee47aa0be">putUint48</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a2639a2144f23e28fa6830792ab32a1c1">putInt40</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a4fb30967ec89103a4a68fd4264f16a3d">putUint40</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#af1de706eb9c2599df01f28a911a4894f">putInt32</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a69d66fcf74987797c57c0d9ac92e0fa4">putUint32</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a108cf88fde4669be09e38d35d1ed593a">putInt24</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a17cc89bc3ac8da68c64d863c28b059d4">putUint24</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#ab597270c34c45a281c2b978b678171f4">putInt16</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#aebd03c4cb89876afbe6c7e5882a4608e">putUint16</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a31874baa04197a23195d07cc0508bde2">putInt8</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a5e1d8e7f655f1fe77a7448df7021cf14">putUint8</a> (unsigned int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a904dd4dfe8ca1745db3d8d30e4393290">putFloat64</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#af8c40f4a18f1b2d82cdb8528d3d7ba89">putFloat32</a> (float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a85a7cc3dd4332e47a0a558df1ad98cdf">putString</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a2141ef79bbfd72289caf7368f02412c7">putArrayInt64</a> (const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a786d8365abc0bbb5eed3ec4611010a83">putArrayUint64</a> (const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#afc4177f52fc9cd2622da8f8145ba5261">putArrayInt56</a> (const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a733dffceae4917af1a2984db0e2d6c43">putArrayUint56</a> (const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a36c075b811fc3ee5187362306ef924dd">putArrayInt48</a> (const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#adc4617934559dce282eafaa43c698abf">putArrayUint48</a> (const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a95ed566a841da2c403d52c71a1279b51">putArrayInt40</a> (const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#afd1b9b4128fce70255292b4f6c772178">putArrayUint40</a> (const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a22fd5470f18ed91191904149da75adf5">putArrayInt32</a> (const int *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#acbbd83ccfd85c990ccfb960377bdba58">putArrayUint32</a> (const unsigned int *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#aa9724467d45228d730c1ebf0a0f94c83">putArrayInt24</a> (const int *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a6bb269d8e6a79001e034cd02475f5c95">putArrayUint24</a> (const unsigned int *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a95609a7221dac2af8cf3f7ba763efa24">putArrayInt16</a> (const short *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a6e4b17ddde4188b4dce1a5c40cc2af9e">putArrayUint16</a> (const unsigned short *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#aa1a9862b9416de5997d5714b56936859">putArrayInt8</a> (const char *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a648f2dd41a2e99e06a7dda3e15fec1a2">putArrayInt8</a> (const signed char *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a0900a1e282b80e52351d5195daf5acaf">putArrayUint8</a> (const char *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a19edaa486ba520351b39e72861ab6d23">putArrayUint8</a> (const unsigned char *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a66782be5f1046f0f1cfd8d86f4d8775b">putArrayFloat64</a> (const double *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a2f40f31c6c4f015577a3fc3eee22196b">putArrayFloat32</a> (const float *values, int numValues)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a351c7de8dcf603a102813931fd74275f">operator const void *</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#ace8bee7cdf0f7e2b28b51c5bc9b68623">bdexVersionSelector</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a4b1c0b8eb7d22f4627efd54770202a63">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a959853b3ab2db13d1095337f9358dc15">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#a15029840cde5d4010229263c52a96b50">length</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestOutStream.html#ab2e61e763bcb9d2633ba5706df04725f">operator&lt;&lt;</a> (bsl::ostream &amp;, const <a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements output methods to externalize fundamental types and their associated type identification data. It stores the accumulated result in network byte order. See the <code>bslx</code> package-level documentation for the definition of the BDEX <code>OutStream</code> protocol. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c4f031d01d08e26340d1dd2305efe2d"></a><!-- doxytag: member="bslx::TestOutStream::TestOutStream" ref="a7c4f031d01d08e26340d1dd2305efe2d" args="(int versionSelector, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestOutStream::TestOutStream </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty output byte stream that will use the specified (<em>compile</em>-time-defined) <code>versionSelector</code> as needed (see <a href="group__bslx__testoutstream.html#versioning" class="el">Versioning</a>). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Note that the <code>versionSelector</code> is expected to be formatted as "YYYYMMDD", a date representation. </p>

</div>
</div>
<a class="anchor" id="a0f1e01d6b55576577608bf5f6c11918a"></a><!-- doxytag: member="bslx::TestOutStream::TestOutStream" ref="a0f1e01d6b55576577608bf5f6c11918a" args="(int versionSelector, bsl::size_t initialCapacity, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestOutStream::TestOutStream </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>initialCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty output byte stream having an initial buffer capacity of at least the specified <code>initialCapacity</code> (in bytes) and that will use the specified (<em>compile</em>-time-defined) <code>versionSelector</code> as needed (see <a href="group__bslx__testoutstream.html#versioning" class="el">Versioning</a>). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Note that the <code>versionSelector</code> is expected to be formatted as "YYYYMMDD", a date representation. </p>

</div>
</div>
<a class="anchor" id="a9efa46b6bdf387c01963ae74d1a265a5"></a><!-- doxytag: member="bslx::TestOutStream::~TestOutStream" ref="a9efa46b6bdf387c01963ae74d1a265a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestOutStream::~TestOutStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a494de2710973ccbb96fdbcedf8d63d31"></a><!-- doxytag: member="bslx::TestOutStream::invalidate" ref="a494de2710973ccbb96fdbcedf8d63d31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestOutStream::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put this output stream in an invalid state. This function has no effect if this stream is already invalid. </p>

</div>
</div>
<a class="anchor" id="a4b189fd3bc057323ff58839ce0fad81e"></a><!-- doxytag: member="bslx::TestOutStream::makeNextInvalid" ref="a4b189fd3bc057323ff58839ce0fad81e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestOutStream::makeNextInvalid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make the next output operation externalize the invalid data indicator, as opposed to the actual type indicator, to this output stream; the data associated with the next output operation is still externalized. Note that the invalid data indicator can be detected by a corresponding <code><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a6d9e2f5efe1496491368d0be72532dc8"></a><!-- doxytag: member="bslx::TestOutStream::putLength" ref="a6d9e2f5efe1496491368d0be72532dc8" args="(int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the specified <code>length</code> is less than 128, write to this stream the one-byte type indicator for a one-byte integer and the one-byte integer comprised of the least-significant one byte of the <code>length</code>; otherwise, write to this stream the one-byte type indicator for a four-byte integer and the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the <code>length</code> (in host byte order) with the most-significant bit set. Return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= length</code>. </p>

</div>
</div>
<a class="anchor" id="aeed8e1b9b65bbbbcc13b2bfc9e59e14d"></a><!-- doxytag: member="bslx::TestOutStream::putVersion" ref="aeed8e1b9b65bbbbcc13b2bfc9e59e14d" args="(int version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putVersion </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a one-byte unsigned integer and the one-byte, two's complement unsigned integer comprised of the least-significant one byte of the specified <code>version</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a69f30c1bc7462a4e3bc4e741fcead126"></a><!-- doxytag: member="bslx::TestOutStream::reserveCapacity" ref="a69f30c1bc7462a4e3bc4e741fcead126" args="(bsl::size_t newCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestOutStream::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>newCapacity</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the internal buffer size of this stream to be at least the specified <code>newCapacity</code> (in bytes). </p>

</div>
</div>
<a class="anchor" id="a70e0904e6f0c9804d1e0232654329b38"></a><!-- doxytag: member="bslx::TestOutStream::reset" ref="a70e0904e6f0c9804d1e0232654329b38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestOutStream::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all content in this stream and validate this stream if it is currently invalid. </p>

</div>
</div>
<a class="anchor" id="af9e9af7d6aa95e84f4824702bf9b8434"></a><!-- doxytag: member="bslx::TestOutStream::putInt64" ref="af9e9af7d6aa95e84f4824702bf9b8434" args="(bsls::Types::Int64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for an eight-byte integer and the eight-byte, two's complement integer (in network byte order) comprised of the least-significant eight bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="aa5a989d81baaaf97f8823c72590a1995"></a><!-- doxytag: member="bslx::TestOutStream::putUint64" ref="aa5a989d81baaaf97f8823c72590a1995" args="(bsls::Types::Uint64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for an eight-byte unsigned integer and the eight-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant eight bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a0b11aa747a7adfda2f59890e1607162f"></a><!-- doxytag: member="bslx::TestOutStream::putInt56" ref="a0b11aa747a7adfda2f59890e1607162f" args="(bsls::Types::Int64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putInt56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a seven-byte integer and the seven-byte, two's complement integer (in network byte order) comprised of the least-significant seven bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="af74a104e81a18350d5a792ec5bebfb02"></a><!-- doxytag: member="bslx::TestOutStream::putUint56" ref="af74a104e81a18350d5a792ec5bebfb02" args="(bsls::Types::Uint64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putUint56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a seven-byte unsigned integer and the seven-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant seven bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a6b712424f82ab0dc2d75a4e11d62b8de"></a><!-- doxytag: member="bslx::TestOutStream::putInt48" ref="a6b712424f82ab0dc2d75a4e11d62b8de" args="(bsls::Types::Int64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putInt48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a six-byte integer and the six-byte, two's complement integer (in network byte order) comprised of the least-significant six bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a6ec3e673fe28c724c057b3aee47aa0be"></a><!-- doxytag: member="bslx::TestOutStream::putUint48" ref="a6ec3e673fe28c724c057b3aee47aa0be" args="(bsls::Types::Uint64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putUint48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a six-byte unsigned integer and the six-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant six bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a2639a2144f23e28fa6830792ab32a1c1"></a><!-- doxytag: member="bslx::TestOutStream::putInt40" ref="a2639a2144f23e28fa6830792ab32a1c1" args="(bsls::Types::Int64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putInt40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a five-byte integer and the five-byte, two's complement integer (in network byte order) comprised of the least-significant five bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a4fb30967ec89103a4a68fd4264f16a3d"></a><!-- doxytag: member="bslx::TestOutStream::putUint40" ref="a4fb30967ec89103a4a68fd4264f16a3d" args="(bsls::Types::Uint64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putUint40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a five-byte unsigned integer and the five-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant five bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="af1de706eb9c2599df01f28a911a4894f"></a><!-- doxytag: member="bslx::TestOutStream::putInt32" ref="af1de706eb9c2599df01f28a911a4894f" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putInt32 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a four-byte integer and the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a69d66fcf74987797c57c0d9ac92e0fa4"></a><!-- doxytag: member="bslx::TestOutStream::putUint32" ref="a69d66fcf74987797c57c0d9ac92e0fa4" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putUint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a four-byte unsigned integer and the four-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant four bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a108cf88fde4669be09e38d35d1ed593a"></a><!-- doxytag: member="bslx::TestOutStream::putInt24" ref="a108cf88fde4669be09e38d35d1ed593a" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putInt24 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a three-byte integer and the three-byte, two's complement integer (in network byte order) comprised of the least-significant three bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a17cc89bc3ac8da68c64d863c28b059d4"></a><!-- doxytag: member="bslx::TestOutStream::putUint24" ref="a17cc89bc3ac8da68c64d863c28b059d4" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putUint24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a three-byte unsigned integer and the three-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant three bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="ab597270c34c45a281c2b978b678171f4"></a><!-- doxytag: member="bslx::TestOutStream::putInt16" ref="ab597270c34c45a281c2b978b678171f4" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putInt16 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a two-byte integer and the two-byte, two's complement integer (in network byte order) comprised of the least-significant two bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="aebd03c4cb89876afbe6c7e5882a4608e"></a><!-- doxytag: member="bslx::TestOutStream::putUint16" ref="aebd03c4cb89876afbe6c7e5882a4608e" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putUint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a two-byte unsigned integer and the two-byte, two's complement unsigned integer (in network byte order) comprised of the least-significant two bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a31874baa04197a23195d07cc0508bde2"></a><!-- doxytag: member="bslx::TestOutStream::putInt8" ref="a31874baa04197a23195d07cc0508bde2" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putInt8 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a one-byte integer and the one-byte, two's complement integer comprised of the least-significant one byte of the specified <code>value</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a5e1d8e7f655f1fe77a7448df7021cf14"></a><!-- doxytag: member="bslx::TestOutStream::putUint8" ref="a5e1d8e7f655f1fe77a7448df7021cf14" args="(unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putUint8 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a one-byte unsigned integer and the one-byte, two's complement unsigned integer comprised of the least-significant one byte of the specified <code>value</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a904dd4dfe8ca1745db3d8d30e4393290"></a><!-- doxytag: member="bslx::TestOutStream::putFloat64" ref="a904dd4dfe8ca1745db3d8d30e4393290" args="(double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putFloat64 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for an eight-byte double-precision floating-point number and the eight-byte IEEE double-precision floating-point number (in network byte order) comprised of the most-significant eight bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="af8c40f4a18f1b2d82cdb8528d3d7ba89"></a><!-- doxytag: member="bslx::TestOutStream::putFloat32" ref="af8c40f4a18f1b2d82cdb8528d3d7ba89" args="(float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putFloat32 </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a four-byte single-precision floating-point number and the four-byte IEEE single-precision floating-point number (in network byte order) comprised of the most-significant four bytes of the specified <code>value</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="a85a7cc3dd4332e47a0a558df1ad98cdf"></a><!-- doxytag: member="bslx::TestOutStream::putString" ref="a85a7cc3dd4332e47a0a558df1ad98cdf" args="(const bsl::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a length (see <code>putLength</code>), the length of the specified <code>value</code> (see <code>putLength</code>), the one-byte type indicator for an array of one-byte unsigned integers, and an array of one-byte, two's complement unsigned integers comprised of the least-significant one byte of each character in the <code>value</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. </p>

</div>
</div>
<a class="anchor" id="a2141ef79bbfd72289caf7368f02412c7"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt64" ref="a2141ef79bbfd72289caf7368f02412c7" args="(const bsls::Types::Int64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for an eight-byte integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive eight-byte, two's complement integers (in network byte order) comprised of the least-significant eight bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a786d8365abc0bbb5eed3ec4611010a83"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint64" ref="a786d8365abc0bbb5eed3ec4611010a83" args="(const bsls::Types::Uint64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for an eight-byte unsigned integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive eight-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant eight bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="afc4177f52fc9cd2622da8f8145ba5261"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt56" ref="afc4177f52fc9cd2622da8f8145ba5261" args="(const bsls::Types::Int64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt56 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a seven-byte integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive seven-byte, two's complement integers (in network byte order) comprised of the least-significant seven bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a733dffceae4917af1a2984db0e2d6c43"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint56" ref="a733dffceae4917af1a2984db0e2d6c43" args="(const bsls::Types::Uint64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint56 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a seven-byte unsigned integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive seven-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant seven bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a36c075b811fc3ee5187362306ef924dd"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt48" ref="a36c075b811fc3ee5187362306ef924dd" args="(const bsls::Types::Int64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt48 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a six-byte integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive six-byte, two's complement integers (in network byte order) comprised of the least-significant six bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="adc4617934559dce282eafaa43c698abf"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint48" ref="adc4617934559dce282eafaa43c698abf" args="(const bsls::Types::Uint64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint48 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a six-byte unsigned integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive six-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant six bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a95ed566a841da2c403d52c71a1279b51"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt40" ref="a95ed566a841da2c403d52c71a1279b51" args="(const bsls::Types::Int64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt40 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a five-byte integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive five-byte, two's complement integers (in network byte order) comprised of the least-significant five bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="afd1b9b4128fce70255292b4f6c772178"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint40" ref="afd1b9b4128fce70255292b4f6c772178" args="(const bsls::Types::Uint64 *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint40 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a five-byte unsigned integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive five-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant five bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a22fd5470f18ed91191904149da75adf5"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt32" ref="a22fd5470f18ed91191904149da75adf5" args="(const int *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt32 </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a four-byte integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive four-byte, two's complement integers (in network byte order) comprised of the least-significant four bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="acbbd83ccfd85c990ccfb960377bdba58"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint32" ref="acbbd83ccfd85c990ccfb960377bdba58" args="(const unsigned int *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint32 </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a four-byte unsigned integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive four-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant four bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="aa9724467d45228d730c1ebf0a0f94c83"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt24" ref="aa9724467d45228d730c1ebf0a0f94c83" args="(const int *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt24 </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a three-byte integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive three-byte, two's complement integers (in network byte order) comprised of the least-significant three bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a6bb269d8e6a79001e034cd02475f5c95"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint24" ref="a6bb269d8e6a79001e034cd02475f5c95" args="(const unsigned int *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint24 </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a three-byte unsigned integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive three-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant three bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a95609a7221dac2af8cf3f7ba763efa24"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt16" ref="a95609a7221dac2af8cf3f7ba763efa24" args="(const short *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt16 </td>
          <td>(</td>
          <td class="paramtype">const short *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a two-byte integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive two-byte, two's complement integers (in network byte order) comprised of the least-significant two bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a6e4b17ddde4188b4dce1a5c40cc2af9e"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint16" ref="a6e4b17ddde4188b4dce1a5c40cc2af9e" args="(const unsigned short *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint16 </td>
          <td>(</td>
          <td class="paramtype">const unsigned short *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a two-byte unsigned integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive two-byte, two's complement unsigned integers (in network byte order) comprised of the least-significant two bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="aa1a9862b9416de5997d5714b56936859"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt8" ref="aa1a9862b9416de5997d5714b56936859" args="(const char *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a648f2dd41a2e99e06a7dda3e15fec1a2"></a><!-- doxytag: member="bslx::TestOutStream::putArrayInt8" ref="a648f2dd41a2e99e06a7dda3e15fec1a2" args="(const signed char *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">const signed char *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a one-byte integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive one-byte, two's complement integers comprised of the least-significant one byte of each of the <code>numValues</code> leading entries in the specified <code>values</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a0900a1e282b80e52351d5195daf5acaf"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint8" ref="a0900a1e282b80e52351d5195daf5acaf" args="(const char *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a19edaa486ba520351b39e72861ab6d23"></a><!-- doxytag: member="bslx::TestOutStream::putArrayUint8" ref="a19edaa486ba520351b39e72861ab6d23" args="(const unsigned char *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a one-byte unsigned integer, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive one-byte, two's complement unsigned integers comprised of the least-significant one byte of each of the <code>numValues</code> leading entries in the specified <code>values</code>, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. </p>

</div>
</div>
<a class="anchor" id="a66782be5f1046f0f1cfd8d86f4d8775b"></a><!-- doxytag: member="bslx::TestOutStream::putArrayFloat64" ref="a66782be5f1046f0f1cfd8d86f4d8775b" args="(const double *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayFloat64 </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for an eight-byte double-precision floating-point number, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive eight-byte IEEE double-precision floating-point numbers (in network byte order) comprised of the most-significant eight bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="a2f40f31c6c4f015577a3fc3eee22196b"></a><!-- doxytag: member="bslx::TestOutStream::putArrayFloat32" ref="a2f40f31c6c4f015577a3fc3eee22196b" args="(const float *values, int numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a>&amp; bslx::TestOutStream::putArrayFloat32 </td>
          <td>(</td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this stream the one-byte type indicator for a four-byte single-precision floating-point number, the four-byte, two's complement integer (in network byte order) comprised of the least-significant four bytes of the specified <code>numValues</code> (in host byte order), and the consecutive four-byte IEEE single-precision floating-point numbers (in network byte order) comprised of the most-significant four bytes of each of the <code>numValues</code> leading entries in the specified <code>values</code> (in host byte order), and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If the next output operation has been set to be marked invalid (see <code>makeNextInvalid</code>), reset this marking and emit the invalid indicator instead of the type indicator. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>values</code> has sufficient contents. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="a351c7de8dcf603a102813931fd74275f"></a><!-- doxytag: member="bslx::TestOutStream::operator const void *" ref="a351c7de8dcf603a102813931fd74275f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestOutStream::operator const void * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-zero value if this stream is valid, and 0 otherwise. An invalid stream is a stream for which an output operation was detected to have failed or <code>invalidate</code> was called. </p>

</div>
</div>
<a class="anchor" id="ace8bee7cdf0f7e2b28b51c5bc9b68623"></a><!-- doxytag: member="bslx::TestOutStream::bdexVersionSelector" ref="ace8bee7cdf0f7e2b28b51c5bc9b68623" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bslx::TestOutStream::bdexVersionSelector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the <code>versionSelector</code> to be used with <code>operator&lt;&lt;</code> for BDEX streaming as per the <code>bslx</code> package-level documentation. </p>

</div>
</div>
<a class="anchor" id="a4b1c0b8eb7d22f4627efd54770202a63"></a><!-- doxytag: member="bslx::TestOutStream::data" ref="a4b1c0b8eb7d22f4627efd54770202a63" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* bslx::TestOutStream::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the contiguous, non-modifiable internal memory buffer of this stream. The address will remain valid as long as this array is not destroyed or modified (i.e., the current capacity is not exceeded). The behavior of accessing elements outside the range <code>[ <a class="el" href="classbslx_1_1TestOutStream.html#a4b1c0b8eb7d22f4627efd54770202a63">data()</a> .. <a class="el" href="classbslx_1_1TestOutStream.html#a4b1c0b8eb7d22f4627efd54770202a63">data()</a> + (<a class="el" href="classbslx_1_1TestOutStream.html#a15029840cde5d4010229263c52a96b50">length()</a> - 1) ]</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a959853b3ab2db13d1095337f9358dc15"></a><!-- doxytag: member="bslx::TestOutStream::isValid" ref="a959853b3ab2db13d1095337f9358dc15" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslx::TestOutStream::isValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stream is valid, and <code>false</code> otherwise. An invalid stream is a stream for which an output operation was detected to have failed or <code>invalidate</code> was called. </p>

</div>
</div>
<a class="anchor" id="a15029840cde5d4010229263c52a96b50"></a><!-- doxytag: member="bslx::TestOutStream::length" ref="a15029840cde5d4010229263c52a96b50" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::size_t bslx::TestOutStream::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes in this stream. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ab2e61e763bcb9d2633ba5706df04725f"></a><!-- doxytag: member="bslx::TestOutStream::operator&lt;&lt;" ref="ab2e61e763bcb9d2633ba5706df04725f" args="(bsl::ostream &amp;, const TestOutStream &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslx_1_1TestOutStream.html">TestOutStream</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>object</code> to the specified output <code>stream</code> in some reasonable (multi-line) format, and return a reference to <code>stream</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslx__testoutstream_8h_source.html">bslx_testoutstream.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:12 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
