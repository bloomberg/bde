<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Namespace bsl</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>bsl Namespace Reference<br/>
<small>
[<a class="el" href="group__bslmf__addconst.html">Component bslmf_addconst</a>,&nbsp;<a class="el" href="group__bslmf__addvolatile.html">Component bslmf_addvolatile</a>,&nbsp;<a class="el" href="group__bslmf__integralconstant.html">Component bslmf_integralconstant</a>,&nbsp;<a class="el" href="group__bslmf__isclass.html">Component bslmf_isclass</a>,&nbsp;<a class="el" href="group__bslmf__isconvertible.html">Component bslmf_isconvertible</a>,&nbsp;<a class="el" href="group__bslmf__isenum.html">Component bslmf_isenum</a>,&nbsp;<a class="el" href="group__bslmf__isfloatingpoint.html">Component bslmf_isfloatingpoint</a>,&nbsp;<a class="el" href="group__bslmf__isfundamental.html">Component bslmf_isfundamental</a>,&nbsp;<a class="el" href="group__bslmf__isintegral.html">Component bslmf_isintegral</a>,&nbsp;<a class="el" href="group__bslmf__ismemberfunctionpointer.html">Component bslmf_ismemberfunctionpointer</a>,&nbsp;<a class="el" href="group__bslmf__ismemberobjectpointer.html">Component bslmf_ismemberobjectpointer</a>,&nbsp;<a class="el" href="group__bslmf__ispointer.html">Component bslmf_ispointer</a>,&nbsp;<a class="el" href="group__bslmf__ispolymorphic.html">Component bslmf_ispolymorphic</a>,&nbsp;<a class="el" href="group__bslmf__isvoid.html">Component bslmf_isvoid</a>,&nbsp;<a class="el" href="group__bslmf__removepointer.html">Component bslmf_removepointer</a>,&nbsp;<a class="el" href="group__bsls__nullptr.html">Component bsls_nullptr</a>,&nbsp;<a class="el" href="group__bslstl__badweakptr.html">Component bslstl_badweakptr</a>,&nbsp;<a class="el" href="group__bslstl__priorityqueue.html">Component bslstl_priorityqueue</a>,&nbsp;<a class="el" href="group__bslstl__queue.html">Component bslstl_queue</a>,&nbsp;<a class="el" href="group__bslstl__sharedptr.html">Component bslstl_sharedptr</a>,&nbsp;<a class="el" href="group__btlso__defaulteventmanagerimpl.html">Component btlso_defaulteventmanagerimpl</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__const.html">add_const</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__cv.html">add_cv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01TYPE_01_6_01_4.html">add_lvalue_reference&lt; TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01void_01_4.html">add_lvalue_reference&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01void_01const_01_01_4.html">add_lvalue_reference&lt; void const  &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01void_01volatile_01_4.html">add_lvalue_reference&lt; void volatile &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01void_01const_01volatile_01_4.html">add_lvalue_reference&lt; void const volatile &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__pointer.html">add_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__volatile.html">add_volatile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator__arg__t.html">allocator_arg_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1conditional.html">conditional</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1conditional_3_01false_00_01TRUE__TYPE_00_01FALSE__TYPE_01_4.html">conditional&lt; false, TRUE_TYPE, FALSE_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1enable__if.html">enable_if</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1enable__if_3_01false_00_01TYPE_01_4.html">enable_if&lt; false, TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1integral__constant_3_01bool_00_01VAL_01_4.html">integral_constant&lt; bool, VAL &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__array.html">is_array</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__array_3_01TYPE[NUM__ELEMENTS]_4.html">is_array&lt; TYPE[NUM_ELEMENTS]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__array_3_01TYPE[]_4.html">is_array&lt; TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__class.html">is_class</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__const.html">is_const</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__const_3_01const_01TYPE_01_4.html">is_const&lt; const TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch.html">is_convertible_dispatch</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01TYPE_00_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; TYPE, TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01TYPE_00_01const_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; TYPE, const TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01TYPE_00_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; TYPE, volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01TYPE_00_01const_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; TYPE, const volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01TYPE_00_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const TYPE, TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01TYPE_00_01const_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const TYPE, const TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01TYPE_00_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const TYPE, volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01TYPE_00_01const_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const TYPE, const volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_00_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile TYPE, TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_00_01const_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile TYPE, const TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_00_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile TYPE, volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_00_01const_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile TYPE, const volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01volatile_01TYPE_00_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const volatile TYPE, TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01volatile_01TYPE_00_01const_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const volatile TYPE, const TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01volatile_01TYPE_00_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const volatile TYPE, volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01volatile_01TYPE_00_01const_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const volatile TYPE, const volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01TYPE_01_6_00_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; TYPE &amp;, TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01TYPE_01_6_00_01const_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; TYPE &amp;, const TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01TYPE_01_6_00_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; TYPE &amp;, volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01TYPE_01_6_00_01const_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; TYPE &amp;, const volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01TYPE_01_6_00_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const TYPE &amp;, TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01TYPE_01_6_00_01const_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const TYPE &amp;, const TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01TYPE_01_6_00_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const TYPE &amp;, volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01TYPE_01_6_00_01const_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const TYPE &amp;, const volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_01_6_00_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile TYPE &amp;, TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_01_6_00_01const_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile TYPE &amp;, const TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_01_6_00_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile TYPE &amp;, volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_01_6_00_01const_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile TYPE &amp;, const volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01volatile_01TYPE_01_6_00_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const volatile TYPE &amp;, TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01volatile_01TYPE_01_6_00_01const_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const volatile TYPE &amp;, const TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01volatile_01TYPE_01_6_00_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const volatile TYPE &amp;, volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01const_01volatile_01TYPE_01_6_00_01const_01volatile_01TYPE_01_6_01_4.html">is_convertible_dispatch&lt; const volatile TYPE &amp;, const volatile TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01TYPE_00_01TYPE_01_4.html">is_convertible_dispatch&lt; volatile TYPE, TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01FROM__TYPE_00_01volatile_01TO__TYPE_01_6_01_4.html">is_convertible_dispatch&lt; FROM_TYPE, volatile TO_TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01FROM__TYPE_00_01const_01volatile_01TO__TYPE_01_6_01_4.html">is_convertible_dispatch&lt; FROM_TYPE, const volatile TO_TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01FROM__TYPE_01_6_00_01volatile_01TO__TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile FROM_TYPE &amp;, volatile TO_TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01FROM__TYPE_01_6_00_01const_01volatile_01TO__TYPE_01_6_01_4.html">is_convertible_dispatch&lt; volatile FROM_TYPE &amp;, const volatile TO_TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1EffectiveFromType.html">EffectiveFromType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible__dispatch_3_01volatile_01FROM__TYPE_01_6_00_01TO__TYPE_01_4.html">is_convertible_dispatch&lt; volatile FROM_TYPE &amp;, TO_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible.html">is_convertible</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Size.html">Is_Empty_Size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Class__Imp.html">Is_Empty_Class_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Class__Imp_3_01TYPE_00_01true_01_4.html">Is_Empty_Class_Imp&lt; TYPE, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Imp.html">Is_Empty_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Imp_3_01TYPE_00_01true_01_4.html">Is_Empty_Imp&lt; TYPE, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__empty.html">is_empty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__enum.html">is_enum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__enum_3_01TYPE_01_5_01_4.html">is_enum&lt; TYPE * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__enum_3_01void_01_4.html">is_enum&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__enum_3_01const_01TYPE_01_4.html">is_enum&lt; const TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__enum_3_01volatile_01TYPE_01_4.html">is_enum&lt; volatile TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__enum_3_01const_01volatile_01TYPE_01_4.html">is_enum&lt; const volatile TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__function.html">is_function</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__fundamental.html">is_fundamental</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__integral.html">is_integral</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__lvalue__reference.html">is_lvalue_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__lvalue__reference_3_01TYPE_01_6_01_4.html">is_lvalue_reference&lt; TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__polymorphic.html">is_polymorphic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__reference.html">is_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__rvalue__reference.html">is_rvalue_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__same.html">is_same</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__same_3_01TYPE_00_01TYPE_01_4.html">is_same&lt; TYPE, TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable.html">is_trivially_copyable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01BloombergLP_1_1bsls_1_1TimeInterval_01_4.html">is_trivially_copyable&lt; BloombergLP::bsls::TimeInterval &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01const_01TYPE_01_4.html">is_trivially_copyable&lt; const TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01volatile_01TYPE_01_4.html">is_trivially_copyable&lt; volatile TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01const_01volatile_01TYPE_01_4.html">is_trivially_copyable&lt; const volatile TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01TYPE[LEN]_4.html">is_trivially_copyable&lt; TYPE[LEN]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01const_01TYPE[LEN]_4.html">is_trivially_copyable&lt; const TYPE[LEN]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01volatile_01TYPE[LEN]_4.html">is_trivially_copyable&lt; volatile TYPE[LEN]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01const_01volatile_01TYPE[LEN]_4.html">is_trivially_copyable&lt; const volatile TYPE[LEN]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01TYPE[]_4.html">is_trivially_copyable&lt; TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01const_01TYPE[]_4.html">is_trivially_copyable&lt; const TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01volatile_01TYPE[]_4.html">is_trivially_copyable&lt; volatile TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01const_01volatile_01TYPE[]_4.html">is_trivially_copyable&lt; const volatile TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01const_01TYPE_01_4.html">is_trivially_default_constructible&lt; const TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01volatile_01TYPE_01_4.html">is_trivially_default_constructible&lt; volatile TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01const_01volatile_01TYPE_01_4.html">is_trivially_default_constructible&lt; const volatile TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01TYPE[LEN]_4.html">is_trivially_default_constructible&lt; TYPE[LEN]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01const_01TYPE[LEN]_4.html">is_trivially_default_constructible&lt; const TYPE[LEN]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01volatile_01TYPE[LEN]_4.html">is_trivially_default_constructible&lt; volatile TYPE[LEN]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01const_01volatile_01TYPE[LEN]_4.html">is_trivially_default_constructible&lt; const volatile TYPE[LEN]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01TYPE[]_4.html">is_trivially_default_constructible&lt; TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01const_01TYPE[]_4.html">is_trivially_default_constructible&lt; const TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01volatile_01TYPE[]_4.html">is_trivially_default_constructible&lt; volatile TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01const_01volatile_01TYPE[]_4.html">is_trivially_default_constructible&lt; const volatile TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__void.html">is_void</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__volatile.html">is_volatile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__volatile_3_01TYPE_01volatile_01_4.html">is_volatile&lt; TYPE volatile &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__const.html">remove_const</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__const_3_01TYPE_01const_01_01_4.html">remove_const&lt; TYPE const  &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__reference_3_01TYPE_01_6_01_4.html">remove_reference&lt; TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__volatile_3_01TYPE_01volatile_01_4.html">remove_volatile&lt; TYPE volatile &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1allocator.html">allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1allocator_3_01void_01_4.html">allocator&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1bitset.html">bitset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Deque__BlockLengthCalcUtil.html">Deque_BlockLengthCalcUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Deque__Util.html">Deque_Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__Base.html">Deque_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1deque.html">deque</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__BlockCreator.html">Deque_BlockCreator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__ClearGuard.html">Deque_ClearGuard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__Guard.html">Deque_Guard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1equal__to.html">equal_to</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C++11-compliant binary functor applying <code>operator==</code>  <a href="structbsl_1_1equal__to.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Function__NothrowWrapper.html">Function_NothrowWrapper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Function__SmallObjectOptimization.html">Function_SmallObjectOptimization</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Function__Rep.html">Function_Rep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1function_3_01RET_07ARGS_8_8_8_08_4.html">function&lt; RET(ARGS...)&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash.html">hash</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01const_01BSLSTL__KEY_01_4.html">hash&lt; const BSLSTL_KEY &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01bool_01_4.html">hash&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01char_01_4.html">hash&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01signed_01char_01_4.html">hash&lt; signed char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01char_01_4.html">hash&lt; unsigned char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01wchar__t_01_4.html">hash&lt; wchar_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01short_01_4.html">hash&lt; short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01short_01_4.html">hash&lt; unsigned short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01int_01_4.html">hash&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01int_01_4.html">hash&lt; unsigned int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01long_01_4.html">hash&lt; long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01long_01_4.html">hash&lt; unsigned long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01long_01long_01_4.html">hash&lt; long long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01long_01long_01_4.html">hash&lt; unsigned long long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__istringstream.html">basic_istringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1List__Node.html">List_Node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1list.html">list</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1map.html">map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1multimap.html">multimap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1multiset.html">multiset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__ostringstream.html">basic_ostringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1owner__less_3_01shared__ptr_3_01ELEMENT__TYPE_01_4_01_4.html">owner_less&lt; shared_ptr&lt; ELEMENT_TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1owner__less_3_01weak__ptr_3_01ELEMENT__TYPE_01_4_01_4.html">owner_less&lt; weak_ptr&lt; ELEMENT_TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_011_00_010_01_4.html">Pair_Imp&lt; T1, T2, 1, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_010_00_011_01_4.html">Pair_Imp&lt; T1, T2, 0, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_011_00_011_01_4.html">Pair_Imp&lt; T1, T2, 1, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1pair.html">pair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1priority__queue.html">priority_queue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1queue.html">queue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1set.html">set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1enable__shared__from__this.html">enable_shared_from_this</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Stack__HasAllocatorType.html">Stack_HasAllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1stack.html">stack</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1StringBufContainer.html">StringBufContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__stringstream.html">basic_stringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__Util.html">Vector_Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Vector__ImpBase.html">Vector_ImpBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector.html">vector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector_3_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.html">vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector_3_01const_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.html">vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__DeduceIteratorCategory.html">Vector_DeduceIteratorCategory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__DeduceIteratorCategory_3_01BSLSTL__ITERATOR_00_01true_01_4.html">Vector_DeduceIteratorCategory&lt; BSLSTL_ITERATOR, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__IsRandomAccessIterator.html">Vector_IsRandomAccessIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__RangeCheck.html">Vector_RangeCheck</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01pollfd_01_4.html">is_trivially_copyable&lt; pollfd &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a><br class="typebreak"/>
&lt; bool, false &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a><br class="typebreak"/>
&lt; bool, true &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bsls::Nullptr_Impl::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::BloombergLP::bslstl::BadWeakPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a906ad194bab928ecbd8b3c6bbc08405c">bad_weak_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a>&lt; char, <br class="typebreak"/>
char_traits&lt; char &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga91edb302fcc1bc234d5537139e3240f9">stringbuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__istringstream.html">basic_istringstream</a><br class="typebreak"/>
&lt; char, char_traits&lt; char &gt;<br class="typebreak"/>
, <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga294e494cba97738d8e493e190f768ad6">istringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__ostringstream.html">basic_ostringstream</a><br class="typebreak"/>
&lt; char, char_traits&lt; char &gt;<br class="typebreak"/>
, <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#gab9a0f4d1fbd8bc1aaf5d375a4ef030b1">ostringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__stringstream.html">basic_stringstream</a><br class="typebreak"/>
&lt; char, char_traits&lt; char &gt;<br class="typebreak"/>
, <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga57f57361aba424d879e8dccd9d11e5dd">stringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a><br class="typebreak"/>
&lt; wchar_t, char_traits<br class="typebreak"/>
&lt; wchar_t &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; wchar_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga354bf749fb252b9beaa5e4ad5d1261d7">wstringbuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__istringstream.html">basic_istringstream</a><br class="typebreak"/>
&lt; wchar_t, char_traits<br class="typebreak"/>
&lt; wchar_t &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; wchar_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga0310a8dbbfcaae3db66ba63771f99b80">wistringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__ostringstream.html">basic_ostringstream</a><br class="typebreak"/>
&lt; wchar_t, char_traits<br class="typebreak"/>
&lt; wchar_t &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; wchar_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga4cbf750ba4f9c875c74a82e1cad7dbb4">wostringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__stringstream.html">basic_stringstream</a><br class="typebreak"/>
&lt; wchar_t, char_traits<br class="typebreak"/>
&lt; wchar_t &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; wchar_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga211eb259cf31d2a9fc31add134d8b3ce">wstringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab67de1ebe0184939129507efe5c86bb1">string</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; wchar_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab3b4e0ebb1e917062e2cc0a71d69fa81">wstring</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaef611bddffc03eb3b52c57ffaa780662">MaxDecimalStringLengths</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__bslstl__string.html#ggaef611bddffc03eb3b52c57ffaa780662a9ecea6b21648c172f194d3c86417d19e">e_MAX_SHORT_STRLEN10</a> =  2 + sizeof(short) * 3, 
<a class="el" href="group__bslstl__string.html#ggaef611bddffc03eb3b52c57ffaa780662a6d6978188c8444b7e62a3e4e5d94879a">e_MAX_INT_STRLEN10</a> =  2 + sizeof(int) * 3, 
<a class="el" href="group__bslstl__string.html#ggaef611bddffc03eb3b52c57ffaa780662aa121a27205ae17ad8a99feb705516979">e_MAX_INT64_STRLEN10</a> =  26, 
<a class="el" href="group__bslstl__string.html#ggaef611bddffc03eb3b52c57ffaa780662aae8e584e57a0cf01fd1cda3dae28663a">e_MAX_FLOAT_STRLEN10</a> =  48, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__bslstl__string.html#ggaef611bddffc03eb3b52c57ffaa780662ae5d35cabdddc6fce086d2b6cf9cb5d62">e_MAX_DOUBLE_STRLEN10</a> =  318, 
<a class="el" href="group__bslstl__string.html#ggaef611bddffc03eb3b52c57ffaa780662a4953cf120543c8f55d67a002d4dc6676">e_MAX_LONGDOUBLE_STRLEN10</a> =  318, 
<a class="el" href="group__bslstl__string.html#ggaef611bddffc03eb3b52c57ffaa780662ae92fad6094aaee12545dae9926049328">e_MAX_SCALAR_STRLEN10</a> =  e_MAX_INT64_STRLEN10
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a> (const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a> (const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gae7e32e402ee00db811d0becfcdea85c8">operator==</a> (const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; TYPE &gt; &amp;lhs, const BloombergLP::bslma::Allocator *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga872377f6fe8aea4ec3b1867924565961">operator!=</a> (const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; TYPE &gt; &amp;lhs, const BloombergLP::bslma::Allocator *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gae3b2d12147f538f3f1cd984619a43af8">operator==</a> (const BloombergLP::bslma::Allocator *lhs, const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga5638b2b9fa7ce3999147ea3b7f2acbaf">operator!=</a> (const BloombergLP::bslma::Allocator *lhs, const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga060694dd688617141953e388c40853ab">operator&amp;</a> (const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;lhs, const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga600580f51a11bd8cebfc76701b8b95fd">operator|</a> (const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;lhs, const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga647dad04e0c0bc7a4878b53acc99fb40">operator^</a> (const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;lhs, const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga9594d63ffa3d8d079eb96e3ff77ee16e">operator&gt;&gt;</a> (std::basic_istream&lt; CHAR_TYPE, TRAITS &gt; &amp;is, <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR_TYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga85fb82ba96cea34775f63b967f323931">operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR_TYPE, TRAITS &gt; &amp;os, const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gae932279610e8893d59e68df4f6968c64">operator==</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga323083767092dbeb43ec96ea2eeb44c7">operator!=</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">operator&lt;</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8f2ff3ac7d315597e6bf4cf3f1376e51">operator&gt;</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gacab21200cbc635611051996fa4ce0c71">operator&lt;=</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga6c3069d504792f532e25e1d7f1456a15">operator&gt;=</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a> (<a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET , class... ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__function.html#ga821a843526bb5ad4ec086001a7bcf579">operator==</a> (const function&lt; RET(ARGS...)&gt; &amp;, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>) BSLS_NOTHROW_SPEC</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET , class... ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__function.html#ga44ef332889f7e6270b9774a34bf90b04">operator==</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>, const function&lt; RET(ARGS...)&gt; &amp;) BSLS_NOTHROW_SPEC</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET , class... ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__function.html#ga896613fa77a2a33574a6f8d968a92108">operator!=</a> (const function&lt; RET(ARGS...)&gt; &amp;, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>) BSLS_NOTHROW_SPEC</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET , class... ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__function.html#ga9667a794d9858c681034a6d8b5cb66d6">operator!=</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>, const function&lt; RET(ARGS...)&gt; &amp;) BSLS_NOTHROW_SPEC</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET , class... ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__function.html#ga9582cd207f11a8595e23bd53507876d7">swap</a> (function&lt; RET(ARGS...)&gt; &amp;a, function&lt; RET(ARGS...)&gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class NODEPTR , class DIFFTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga4d35eb893ce83ba11f7e4dac35ee2a2d">operator==</a> (<a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T1, NODEPTR, DIFFTYPE &gt; lhs, <a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T2, NODEPTR, DIFFTYPE &gt; rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class NODEPTR , class DIFFTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8fa345b57fb8278d8760d1fd90157eae">operator!=</a> (<a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T1, NODEPTR, DIFFTYPE &gt; lhs, <a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T2, NODEPTR, DIFFTYPE &gt; rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga39c2b71f4356c6f9f1a69d441dda4c26">operator==</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacea9175011d9b18a01cb38e6e23d56e0">operator!=</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacd1873ee9d29582411de3abe4a3e79ee">operator&lt;</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8f4598ceb1aee9f39781704c381ed8d1">operator&gt;</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga7e448645b21786d13f6377a64adfce1f">operator&lt;=</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga009bc1ba641b09a01e9e0c516cba7092">operator&gt;=</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8a4fac7379d969587e69a3186c91f583">swap</a> (<a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga22facc5669cef057868333b50b07be3c">operator==</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga50c4f19d172d7814a397ca2aedd4b74f">operator!=</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga13fe89539cf5b17b8cd39c1ef71eade9">operator&lt;</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga7d03b6985f6885cdf2fbe566bd7468bb">operator&gt;</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaf0de3e7790300393e630816813ec1c9a">operator&lt;=</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gafd6033641c01e3b3fb8b955f75676901">operator&gt;=</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga8ffecdad6636be8054c6ff5d8c772cb2">swap</a> (<a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gae27bff9d448ee8c63a9171d2a395720b">operator==</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga4fc52a0082eb837264b9de4d1d92db60">operator!=</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gac9b2f689b4da8f5b466377d30fe65d96">operator&lt;</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga94a2b9a893c655bcd903fd31f0ef14cb">operator&gt;</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga4efa7f5e34b40ac39190468e744f969a">operator&lt;=</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gad512a2f22b260bcb81daf71a51c63c37">operator&gt;=</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga153c934515e350c6786edec5a81b7be5">swap</a> (<a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga6b27ce014d210bdab4dcc0e8eb313262">operator==</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaa9e0287e54abb4f45c0b5d6d81e138cd">operator!=</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga5f75f92a4ad3cea69cc8d4dd81f1a892">operator&lt;</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga0202c754266ad01bd8e5fb5bf3eb0f4b">operator&gt;</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gae4d913748cdddae30ae432d7407d94e0">operator&gt;=</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaad5b6eb4abdefb9a20e2af663b822573">operator&lt;=</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gab649ed015369ea41b6e05bc6b524dcd8">swap</a> (<a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a9a7785279a114a5b6cf645ff59f2ad85">operator==</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga50b4aea952721acf5ad54aa2bc758c8d">operator!=</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga97c477e75c90f40b8122aa0702fb652c">operator&lt;</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaecdfed596ebac61d4ebfda51e911b916">operator&gt;</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gade131fc530151248b67d2c88522832e3">operator&lt;=</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaa19d2c4a4e8788af13eab13f37c5e53e">operator&gt;=</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga8dd0a3f8324bcc657bc448230e8f5b4b">swap</a> (<a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;a, <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class HASHALG , class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a> (HASHALG &amp;hashAlg, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;input)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER , class COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aae3cf461eb5ab91a840a7c5971e73d2e">swap</a> (<a class="el" href="classbsl_1_1priority__queue.html">priority_queue</a>&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;lhs, <a class="el" href="classbsl_1_1priority__queue.html">priority_queue</a>&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aea945e62f1d56d6de8d18add7a69032c">operator==</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a09400e14804ca7e312c982f2d0d70f9e">operator!=</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a3c8ac4f5467823210019acdfd464cc44">operator&lt;</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a20fa0ded3c1fc13bfb2d30241a52348c">operator&gt;</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4cfd370cd9654f11d99e8dd27f8d4b3d">operator&gt;=</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad9ecc25aa91817ea5f6914f8217c5098">operator&lt;=</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#acb5d1f34e06e5f7e51389f184262b86d">swap</a> (<a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a>&lt; const T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__referencewrapper.html#gacbcf068f4823cd3ffe9d15110f9363e6">cref</a> (const T &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a>&lt; const T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__referencewrapper.html#ga807bbaf9fdf602c644286d99a53fac80">cref</a> (<a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; original)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__referencewrapper.html#ga76ebecda2ba89ed1e46b563220a60043">ref</a> (T &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__referencewrapper.html#gad93ed296883ae5c29067cd940550c388">ref</a> (<a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; original)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gadc5c97041a3b7c06863fa093d37152f7">operator==</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga64f502a1498b19207f1e7812832dc833">operator!=</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gadcabb714950bc28dba72240a6a95324d">operator&lt;</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga2768d770127ea7018262726328633342">operator&gt;</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga5fad735708a2c5e2d67581a840f71f26">operator&lt;=</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga009ed5fb1156f5d23e0bc6a51386d986">operator&gt;=</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaac71b5ac0a4c5e73c7c96f14046f3e8f">swap</a> (<a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a36b4aa9f9925d1d9f9f7297c915a92e9">operator==</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a90940769febd50cde38a76da31c915e5">operator!=</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac531f6429890d83e82c83dac3a6776ed">operator&lt;</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a94af00ba80c7a84924b99d0dbd7b44d0">operator&gt;</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aaee3cde0e6fcda97ac8c57bc637e7192">operator&lt;=</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad316d6f05143100522091b4d5e37d3ad">operator&gt;=</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#abd4c5e54b916c43a945190edca70a9e5">operator==</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1bf2d8f755e49f78baca17d7a014fb35">operator==</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0287efe214011c1cb8fff02b90d8cf0d">operator!=</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa97b807f35b62c78de48a4f344693d0f">operator!=</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5b71dab1c31b3334dd3b50ef50527777">operator&lt;</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0162c0baa4977386783312ca9f3ba5a6">operator&lt;</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a90a5294ef3c4eb943bda11ef74143739">operator&lt;=</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aebe7692dec1f847014d9c7f988a8d3e5">operator&lt;=</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae021e641c18eebaeea4d9218242cc3ec">operator&gt;</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1bd32b153cc9f7bbb6f077af1811cae5">operator&gt;</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a774f64ba9770b76509f41a4744c9fc20">operator&gt;=</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; LHS_TYPE &gt; &amp;lhs, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a2468bd66d8e4760f073842ce322f03e4">operator&gt;=</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">native_std::basic_ostream<br class="typebreak"/>
&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aef9191e2d4f9e99421de794cfa210c63">operator&lt;&lt;</a> (native_std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;stream, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class HASHALG , class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#afe12b0f6723f7f260ec2c37f78ecc034">hashAppend</a> (HASHALG &amp;hashAlg, const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;input)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a3bcc8b79130499e03edce7ff146e4fdc">swap</a> (<a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;a, <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;b) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DELETER , class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DELETER *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a348124fee690b6d7ddb89ac5163d472b">get_deleter</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;p) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TO_TYPE , class FROM_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; TO_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a18c4ffd947492bcd664a0748de461e77">const_pointer_cast</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; FROM_TYPE &gt; &amp;source) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TO_TYPE , class FROM_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; TO_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a3f15ce3b15ab5edbb6d3f557387244eb">dynamic_pointer_cast</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; FROM_TYPE &gt; &amp;source) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TO_TYPE , class FROM_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; TO_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a50eab0a8106cddb7fb5834139f0a1c76">static_pointer_cast</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; FROM_TYPE &gt; &amp;source) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a842124bb63d969e2caf74d9acab97fc5">allocate_shared</a> (ALLOC basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#af2cdad3ee884ea8b77ab9c1426f56fbd">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aafac01371f305d61c5c78789e1e7946d">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#af290055ca0d2dd2a1cb63b87b45c1150">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a01d65a5dc53c7e2eb8e3611e26eb97bc">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a2bd5e0e636661483155a7c1c8b3e38ae">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a53ddafd51e59bf1e423a926039c54b52">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5c2325b69b0e632dce693eef38ec06b8">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a2a65a4a51652aba5a8bba984d8619ae9">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ace3929d2362de8b5b52094a9f6d6eed2">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aac721eeddc042f80302f2b9f4785b53a">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a9606c6f277d02bbfcc74c06f7cba41d1">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ab59fe722c57eec981284f58d5d20cd29">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa1da907c0dbd8b80f8a3c768e85e7d5d">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ab57cfb5ad98e1adf035316e35672077a">allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa5cf03e39a028e9896de9a8c08df1445">allocate_shared</a> (ALLOC *basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a7f487dab167660990e57e8f6dd4ce8e6">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a952b9d0f95d7a0f91f485d1146beb191">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a2168d1fe1563beb5029888bf7f64f2ec">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0e189e4547a008770d94657320a19757">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#affcd074404490763a00537270d15a919">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4074c4cc4167a9ed7c6c2dc5f88e7d29">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5d1ed3d2127b1f90ee4f088e236b98aa">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a777ca6cbbff46d15b499a10a901d7d11">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a9075db3c0bc09d1fb7fbcca6f8109392">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a43c7f93dad387f6c22e352c18e4ebf21">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a6a16b6a4c819dfbd9fb72dd3e1e7580a">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4b455a513f5fa28d4199646af210ef14">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a3cdaf66722173632cf99dcba808fe7a4">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a852abbdd03b262816ec5f706e78daa66">allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0afacd0aecba8ee3341580f6e696bee5">make_shared</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a948481509b5773206e5ea25c52b61283">make_shared</a> (const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aed83c08eabc1f22ff41be3d7949b016a">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5b3b07f21e4b038a58efa13ea2583d18">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5ccdad6d77d6f91c4d26d36a2a1c9933">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad70fcbb076fc7c7c9e75f297f2149c58">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a41fdc22eb8ffb9ac386b266e2b100f47">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0a18cef762683586ddcf554750974540">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5386aae75c602403e22c26f58d9aa3f2">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0c90eba2b70dc7509f69950d04bfee31">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a98eed9180e3758990ff0bda0b0f41683">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a47afd18d2ac49909d2f78359550bcd65">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae7f8b8e43681cb4423673c7dce5488b1">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a72666c8cd2da3ed6ce6bd6c27f0cd189">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a3876caafb24bb32d3300754b741cd7a6">make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1e192ddeb52d359284e9b3fde2e54fd4">swap</a> (<a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;a, <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;b) BSLS_CPP11_NOEXCEPT</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga4de7c661423b992c4efac216574915f1">operator==</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga585bf4a1dfbacb8e796ceee38e0b667e">operator!=</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaf40f0bba0cda8cd451cefafd1e09cf8b">operator&lt;</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga5400f7f0238a7c6c2ab6e880686473a9">operator&gt;</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gad92196ff0aec88dd3db886ea825d6645">operator&lt;=</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga083c333856bdb6110947f806405c1cda">operator&gt;=</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga69a3b02c7015296255025773a76d7a8c">swap</a> (<a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga018249bd88b8a5cabef70d879d83f4e2">operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga174c18650388ebbfaf65903622e8d411">operator==</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaeea3e40017b0b91afde35924cacd0236">operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae4236ec7ed54aad1d2ab459c07272686">operator==</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga94f4f2fcc02cea9d859bc6fc590c37ce">operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4a515bec807795fc9c397df08143ece3">operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf2fe09d66ed45e7186d3662d19098ee1">operator!=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf17352aafac44a780c4527aff83cbd3d">operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga53ac23905daba69217f6395b18a18c48">operator!=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga099e3847d670070b532e1656f6949c6f">operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3c67cfa96cea8409daeb261194224055">operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga31d7c587dc965a9d5bacf1c7804e8419">operator&lt;</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9b607b0f429d7d06fdb1ea217e029624">operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga53520ad4579b0e7ebe3a330ea3aef1a6">operator&lt;</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf6dc55ce3ecacb8f1ee81c6d19f77a05">operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacda2be81859ae7036eedca64e4231345">operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga88796fccdc9069c252a2f2da21b42a38">operator&gt;</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2970f100d7b208f34a4422d55683f661">operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf9104abf11faaf9942d7ffd2b8de967a">operator&gt;</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga577e4a2c400b379888b612dd6cb99e7f">operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaccc781f81a2995d86f0343dc53b91029">operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa0808c8a264435c0e68d22105dafdf4c">operator&lt;=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga09517e1c94cbeb09c0f7726db39a4cba">operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa248cb81f7d2915d3bc73db7dc8347a2">operator&lt;=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga88654fdf68b7f294544efe5f5137e24c">operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga64a1cad020be5478c3bcda0e2f1d492c">operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4824e50e3103d3fcaf2c967d611c9bf2">operator&gt;=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gafd58b60d5dfbc0dce3b941af777ddaf3">operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1e50fd9fe50da05263c7474dc28274af">operator&gt;=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga41cc8642f854de72b026f8c0de3df3e8">operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga42197abe6c669cfcf5e211bc67ccb1de">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOC2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga97bb5679b8f377f9f7b4adf209877bfa">operator+</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOC1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga8f23e8d049a5cb515b7b8fdb7cdaf3e3">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4301c3876b38e775f230c9ba35f7bfbd">operator+</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4ecd2946e7b0398dcba71635a16a852c">operator+</a> (CHAR_TYPE lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7cded745bebd361db3e7e55b8b076ba8">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga25f5e63d2fba83da95d42bfb3dbbb4ff">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, CHAR_TYPE rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3b963747c8b48daf1d8d2fe51c145ea8">operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;os, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga570c44378d37d8894351c13c5791babf">operator&gt;&gt;</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa85645c85b7e6553fc597a2fa2ddf31d">swap</a> (<a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga541ba270c84fdb45c5df71a668aa5d9d">getline</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str, CHAR_TYPE delim)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3950d8911fd8b8b58fbee74bb76dda0f">getline</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3077399ad479cdd99e019952bff52d5c">stoi</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str, std::size_t *pos=0, int base=10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1c806df13cef80e557e67c9fb81e7584">stol</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str, std::size_t *pos=0, int base=10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga017076c1385a354b3ec07b13329a5bef">stoul</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str, std::size_t *pos=0, int base=10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3b7919aec24aa17d15b0c95b7a2efcea">stoll</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str, std::size_t *pos=0, int base=10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga15fdd28d0b31f2aef03232c5adf69c1f">stoull</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str, std::size_t *pos=0, int base=10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga308af944ea4ad09d95f842a0e977c2c1">stof</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str, std::size_t *pos=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga974d5193cce5be4030e024d1fabe8f9e">stod</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str, std::size_t *pos=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gad03a41be5c1e91bc85b0ce6d71fae0d3">stold</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str, std::size_t *pos=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9d6e332df6fdad6887e8978cca90bd53">to_string</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac1dc65359eaba7e85db44dbf3f307b83">to_string</a> (long value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga80a9fc78f62b245982bce536f52edbac">to_string</a> (long long value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga59793d4b1890b9f056359dabb3bb0abc">to_string</a> (unsigned value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gac0eae9aa22cd9c20021c7955d447b222">to_string</a> (unsigned long value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3bdfdf8c732ed0cd929c64bd68a363dc">to_string</a> (unsigned long long value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga86213338e0ca489dfaaeb944c53d0cda">to_string</a> (float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga93ed7741b6b168c5af47b85310e48fe8">to_string</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaef063f65c5428b7264625515ee8df91d">to_string</a> (long double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga6bf247b4e139b65f1fe8a6540924e9ee">to_wstring</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga6488bcb6abbe84aec6f5a8708bc71ce8">to_wstring</a> (long value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3ae643872ee3867228be2a14b3e8f052">to_wstring</a> (long long value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaeff31d022b3aba42f50c58f25f18fb4c">to_wstring</a> (unsigned value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga6a91e80ab18cfae0b26eafcdcc85d4a0">to_wstring</a> (unsigned long value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2309169225fa7d82f8011aa29f8d603e">to_wstring</a> (unsigned long long value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3df1db09a5c6cada159908a20560a04a">to_wstring</a> (float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga8dca184138f505db2b0c83679f1ec044">to_wstring</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">wstring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa26a1d8a3eef81bc0c657f55ef133d7c">to_wstring</a> (long double value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class HASHALG , class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga121160f409beb7dd37c2f94730f95f35">hashAppend</a> (HASHALG &amp;hashAlg, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;input)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga466018873ba5698c6e628a7a53a2b6bd">hashBasicString</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1ab59c0071935cd8bb0ad6036b167505">hashBasicString</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga0c4f54461a359b055782b5a6a3bcb14c">operator==</a> (const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga631ea915746fe2b1f2664f2b2306d4d2">operator!=</a> (const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga2c1a5c101ec75196e300c49d54a40833">swap</a> (<a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga601a88fd6f232d89827226c779166c7c">operator==</a> (const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gace2f15b7cbef1336dd4dd63794e3f1dd">operator!=</a> (const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga390f9783cd0c4c7c8be26e37b2b052c6">swap</a> (<a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga8e9c9a9220ff75ddc73acee85bfa7392">operator==</a> (const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gae0f2b56046e1efc815e5637ed81ce7a8">operator!=</a> (const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaeeaace5c7f41430040e55f54044dd311">swap</a> (<a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedset.html#gaadd1e9430a785482668e49d4bfb0ccea">operator==</a> (const <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedset.html#gab692dbfdc45954204c1b0876a8879d48">operator!=</a> (const <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedset.html#ga0bfbbced6a1f70073436bf67122fb8fb">swap</a> (<a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae1cf7ebaf57b20ad849f3cec698e88b9">operator==</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3b21b4b523ef349a450e774e69fba3a2">operator!=</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafae8e5536e4d0104153320a37e8c1e3a">operator&lt;</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga625351fd0ddd03d582652b3aae6ebbc9">operator&gt;</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9300705f377d58094c8b40530816ffb7">operator&lt;=</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4310a39a792a2712adaa5104a67a0bf8">operator&gt;=</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga73c7729c8388a194029dab1d69d08360">swap</a> (<a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1829ad82eb519b1fb7c79a803af91153">operator==</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae2296fbb2872dbb82c90f7c41ab6ca41">operator!=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaaa78d320fb70553c12c5ac664ef03e4e">operator&lt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9fefac8bbb8472a45f2f021b3045b886">operator&gt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad43a151e8130ffa1975e64bceae4cfef">operator&lt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga926b2d565333233f7bca60072014322a">operator&gt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab76628a7a0c98d331cb819c2a350eb66">operator==</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa050f07faffd38620497590ae4a99b4d">operator!=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad44b0030adeab48da89a630cd9dbda69">operator&lt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga06eed7e12572f6abb9838f1737348bd6">operator&gt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga43dfb63a5e8e2518d34771637f3b3815">operator&lt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae74b32df8b2eebf0034d006226553379">operator&gt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab53faa313dc32ebffbfb834e8f6bc923">swap</a> (<a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6bc33a80f40864c84d527e1dba8ea0f7">operator==</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga70e39ecc5bb6b312e77055ab69db74e9">operator!=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1d962f9bb93e44002b825909c6f5481c">operator&lt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga55051a5f21e7701e046a08080015b9d9">operator&gt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga229794ea813dde0fe7160991fccb5253">operator&lt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac48a0847b58ba26910284d521f2dfb4f">operator&gt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga11c0d5aedac133a4c9fd2a2404471c2c">swap</a> (<a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbsl_1_1allocator__arg__t.html">allocator_arg_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmf__allocatorargt.html#ga6cebd63bf4531f3f05c924cbdc04a12b">allocator_arg</a> = { }</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a072205c212218b4b4cccaf66052c99a4"></a><!-- doxytag: member="bsl::false_type" ref="a072205c212218b4b4cccaf66052c99a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a>&lt;bool, false&gt; <a class="el" href="structbsl_1_1integral__constant.html">bsl::false_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a124171e6663dfc2b3c10256844c8dc3b"></a><!-- doxytag: member="bsl::true_type" ref="a124171e6663dfc2b3c10256844c8dc3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a>&lt;bool, true&gt; <a class="el" href="structbsl_1_1integral__constant.html">bsl::true_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a15d68a87901fa9543f847ada4ee76fd3"></a><!-- doxytag: member="bsl::nullptr_t" ref="a15d68a87901fa9543f847ada4ee76fd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bsls::Nullptr_Impl::Type <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a906ad194bab928ecbd8b3c6bbc08405c"></a><!-- doxytag: member="bsl::bad_weak_ptr" ref="a906ad194bab928ecbd8b3c6bbc08405c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::BloombergLP::bslstl::BadWeakPtr <a class="el" href="namespacebsl.html#a906ad194bab928ecbd8b3c6bbc08405c">bsl::bad_weak_ptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9a7785279a114a5b6cf645ff59f2ad85"></a><!-- doxytag: member="bsl::operator==" ref="a9a7785279a114a5b6cf645ff59f2ad85" args="(const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified <code>lhs</code> and <code>rhs</code> pair objects have the same value and false otherwise. <code>lhs</code> has the same value as <code>rhs</code> if <code>lhs.first == rhs.first</code> and <code>lhs.second == rhs.second</code>. A call to this operator will not compile unless both <code>T1</code> and <code>T2</code> supply <code>operator==</code>. </p>

</div>
</div>
<a class="anchor" id="aae3cf461eb5ab91a840a7c5971e73d2e"></a><!-- doxytag: member="bsl::swap" ref="aae3cf461eb5ab91a840a7c5971e73d2e" args="(priority_queue&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;lhs, priority_queue&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER , class COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">priority_queue&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">priority_queue&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea945e62f1d56d6de8d18add7a69032c"></a><!-- doxytag: member="bsl::operator==" ref="aea945e62f1d56d6de8d18add7a69032c" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code>queue</code> objects have the same value if the containers they adapt are compared equal. </p>

</div>
</div>
<a class="anchor" id="a09400e14804ca7e312c982f2d0d70f9e"></a><!-- doxytag: member="bsl::operator!=" ref="a09400e14804ca7e312c982f2d0d70f9e" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code>queue</code> objects do not have the same value if the containers they adapt are not compared equal. </p>

</div>
</div>
<a class="anchor" id="a3c8ac4f5467823210019acdfd464cc44"></a><!-- doxytag: member="bsl::operator&lt;" ref="a3c8ac4f5467823210019acdfd464cc44" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> queue is lexicographically less than the specified <code>rhs</code> queue, and <code>false</code> otherwise. A queue <code>lhs</code> is lexicographically less than another queue <code>rhs</code> if the container adapted by <code>lhs</code> is lexicographically less than that adapted by <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="a20fa0ded3c1fc13bfb2d30241a52348c"></a><!-- doxytag: member="bsl::operator&gt;" ref="a20fa0ded3c1fc13bfb2d30241a52348c" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> queue is lexicographically greater than the specified <code>rhs</code> queue, and <code>false</code> otherwise. A queue <code>lhs</code> is lexicographically greater than another queue <code>rhs</code> if the container adapted by <code>lhs</code> is lexicographically greater than that adapted by <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="a4cfd370cd9654f11d99e8dd27f8d4b3d"></a><!-- doxytag: member="bsl::operator&gt;=" ref="a4cfd370cd9654f11d99e8dd27f8d4b3d" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> queue is lexicographically greater-than or equal-to the specified <code>rhs</code> queue, and <code>false</code> otherwise. A queue <code>lhs</code> is lexicographically greater-than or equal-to another queue <code>rhs</code> if the container adapted by <code>lhs</code> is lexicographically greater-than or equal-to that adapted by <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="ad9ecc25aa91817ea5f6914f8217c5098"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ad9ecc25aa91817ea5f6914f8217c5098" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> queue is lexicographically less-than or equal-to the specified <code>rhs</code> queue, and <code>false</code> otherwise. A queue <code>lhs</code> is lexicographically less-than or equal-to another queue <code>rhs</code> if the container adapted by <code>lhs</code> is lexicographically less-than or equal-to that adapted by <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="acb5d1f34e06e5f7e51389f184262b86d"></a><!-- doxytag: member="bsl::swap" ref="acb5d1f34e06e5f7e51389f184262b86d" args="(queue&lt; VALUE, CONTAINER &gt; &amp;lhs, queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the value of the specified <code>lhs</code> queue with the value of the specified <code>rhs</code> queue. </p>

</div>
</div>
<a class="anchor" id="a36b4aa9f9925d1d9f9f7297c915a92e9"></a><!-- doxytag: member="bsl::operator==" ref="a36b4aa9f9925d1d9f9f7297c915a92e9" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer refers to the same object (if any) as that referred to by the specified <code>rhs</code> shared pointer (if any), and <code>false</code> otherwise; a compiler diagnostic will be emitted indicating the error unless a (raw) pointer to <code>LHS_TYPE</code> can be compared to a (raw) pointer to <code>RHS_TYPE</code>. Note that two shared pointers that compare equal do not necessarily manage the same object due to aliasing. </p>

</div>
</div>
<a class="anchor" id="a90940769febd50cde38a76da31c915e5"></a><!-- doxytag: member="bsl::operator!=" ref="a90940769febd50cde38a76da31c915e5" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer does not refer to the same object (if any) as that referred to by the specified <code>rhs</code> shared pointer (if any), and <code>false</code> otherwise; a compiler diagnostic will be emitted indicating the error unless a (raw) pointer to <code>LHS_TYPE</code> can be compared to a (raw) pointer to <code>RHS_TYPE</code>. Note that two shared pointers that do not compare equal may manage the same object due to aliasing. </p>

</div>
</div>
<a class="anchor" id="ac531f6429890d83e82c83dac3a6776ed"></a><!-- doxytag: member="bsl::operator&lt;" ref="ac531f6429890d83e82c83dac3a6776ed" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object that the specified <code>lhs</code> shared pointer refers to is ordered before the address of the object that the specified <code>rhs</code> shared pointer refers to under the total ordering supplied by <code>std::less&lt;T *&gt;</code>, where <code>T *</code> is the composite pointer type of <code>LHS_TYPE *</code> and <code>RHS_TYPE *</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a94af00ba80c7a84924b99d0dbd7b44d0"></a><!-- doxytag: member="bsl::operator&gt;" ref="a94af00ba80c7a84924b99d0dbd7b44d0" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object that the specified <code>lhs</code> shared pointer refers to is ordered after the address of the object that the specified <code>rhs</code> shared pointer refers to under the total ordering supplied by <code>std::less&lt;T *&gt;</code>, where <code>T *</code> is the composite pointer type of <code>LHS_TYPE *</code> and <code>RHS_TYPE *</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aaee3cde0e6fcda97ac8c57bc637e7192"></a><!-- doxytag: member="bsl::operator&lt;=" ref="aaee3cde0e6fcda97ac8c57bc637e7192" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer refers to the same object as the specified <code>rhs</code> shared pointer, or if the address of the object referred to by <code>lhs</code> (if any) is ordered before the address of the object referred to by <code>rhs</code> (if any) under the total ordering supplied by <code>std::less&lt;T *&gt;</code>, where <code>T *</code> is the composite pointer type of <code>LHS_TYPE *</code> and <code>RHS_TYPE *</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ad316d6f05143100522091b4d5e37d3ad"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ad316d6f05143100522091b4d5e37d3ad" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer refers to the same object as the specified <code>rhs</code> shared pointer, or if the address of the object referred to by <code>lhs</code> (if any) is ordered after the address of the object referred to by <code>rhs</code> (if any) under the total ordering supplied by <code>std::less&lt;T *&gt;</code>, where <code>T *</code> is the composite pointer type of <code>LHS_TYPE *</code> and <code>RHS_TYPE *</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="abd4c5e54b916c43a945190edca70a9e5"></a><!-- doxytag: member="bsl::operator==" ref="abd4c5e54b916c43a945190edca70a9e5" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer does not refer to an object, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a1bf2d8f755e49f78baca17d7a014fb35"></a><!-- doxytag: member="bsl::operator==" ref="a1bf2d8f755e49f78baca17d7a014fb35" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> shared pointer does not refer to an object, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a0287efe214011c1cb8fff02b90d8cf0d"></a><!-- doxytag: member="bsl::operator!=" ref="a0287efe214011c1cb8fff02b90d8cf0d" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer refers to an object, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aa97b807f35b62c78de48a4f344693d0f"></a><!-- doxytag: member="bsl::operator!=" ref="aa97b807f35b62c78de48a4f344693d0f" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> shared pointer refers to an object, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a5b71dab1c31b3334dd3b50ef50527777"></a><!-- doxytag: member="bsl::operator&lt;" ref="a5b71dab1c31b3334dd3b50ef50527777" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object referred to by the specified <code>lhs</code> shared pointer is ordered before the null-pointer value under the total ordering supplied by <code>std::less&lt;LHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a0162c0baa4977386783312ca9f3ba5a6"></a><!-- doxytag: member="bsl::operator&lt;" ref="a0162c0baa4977386783312ca9f3ba5a6" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object referred to by the specified <code>rhs</code> shared pointer is ordered after the null-pointer value under the total ordering supplied by <code>std::less&lt;RHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a90a5294ef3c4eb943bda11ef74143739"></a><!-- doxytag: member="bsl::operator&lt;=" ref="a90a5294ef3c4eb943bda11ef74143739" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer does not refer to an object, or if the address of the object referred to by <code>lhs</code> is ordered before the null-pointer value under the total ordering supplied by <code>std::less&lt;LHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aebe7692dec1f847014d9c7f988a8d3e5"></a><!-- doxytag: member="bsl::operator&lt;=" ref="aebe7692dec1f847014d9c7f988a8d3e5" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> shared pointer does not refer to an object, or if the address of the object referred to by <code>rhs</code> is ordered after the null-pointer value under the total ordering supplied by <code>std::less&lt;RHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ae021e641c18eebaeea4d9218242cc3ec"></a><!-- doxytag: member="bsl::operator&gt;" ref="ae021e641c18eebaeea4d9218242cc3ec" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object referred to by the specified <code>lhs</code> shared pointer is ordered after the null-pointer value under the total ordering supplied by <code>std::less&lt;LHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a1bd32b153cc9f7bbb6f077af1811cae5"></a><!-- doxytag: member="bsl::operator&gt;" ref="a1bd32b153cc9f7bbb6f077af1811cae5" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object referred to by the specified <code>rhs</code> shared pointer is ordered before the null-pointer value under the total ordering supplied by <code>std::less&lt;RHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a774f64ba9770b76509f41a4744c9fc20"></a><!-- doxytag: member="bsl::operator&gt;=" ref="a774f64ba9770b76509f41a4744c9fc20" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer does not refer to an object, or if the address of the object referred to by <code>lhs</code> is ordered after the null-pointer value under the total ordering supplied by <code>std::less&lt;LHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a2468bd66d8e4760f073842ce322f03e4"></a><!-- doxytag: member="bsl::operator&gt;=" ref="a2468bd66d8e4760f073842ce322f03e4" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> shared pointer does not refer to an object, or if the address of the object referred to by <code>rhs</code> is ordered before the null-pointer value under the total ordering supplied by <code>std::less&lt;RHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aef9191e2d4f9e99421de794cfa210c63"></a><!-- doxytag: member="bsl::operator&lt;&lt;" ref="aef9191e2d4f9e99421de794cfa210c63" args="(native_std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;stream, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">native_std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp; bsl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">native_std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print to the specified <code>stream</code> the address of the shared object referred to by the specified <code>rhs</code> shared pointer and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="afe12b0f6723f7f260ec2c37f78ecc034"></a><!-- doxytag: member="bsl::hashAppend" ref="afe12b0f6723f7f260ec2c37f78ecc034" args="(HASHALG &amp;hashAlg, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;input)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HASHALG , class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::hashAppend </td>
          <td>(</td>
          <td class="paramtype">HASHALG &amp;&nbsp;</td>
          <td class="paramname"> <em>hashAlg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass the address of the object referred to by the specified <code>input</code> shared pointer to the specified <code>hashAlg</code> hashing algorithm of (template parameter) type <code>HASHALG</code>. </p>

</div>
</div>
<a class="anchor" id="a3bcc8b79130499e03edce7ff146e4fdc"></a><!-- doxytag: member="bsl::swap" ref="a3bcc8b79130499e03edce7ff146e4fdc" args="(shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the states of the specified <code>a</code> and <code>b</code> shared pointers such that each will refer to the object formerly referred to by the other, and each will manage the object formerly managed by the other. </p>

</div>
</div>
<a class="anchor" id="a348124fee690b6d7ddb89ac5163d472b"></a><!-- doxytag: member="bsl::get_deleter" ref="a348124fee690b6d7ddb89ac5163d472b" args="(const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;p) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DELETER , class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DELETER* bsl::get_deleter </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of deleter used by the specified <code>p</code> shared pointer if the (template parameter) type <code>DELETER</code> is the type of the deleter installed in <code>p</code>, and a null pointer value otherwise. </p>

</div>
</div>
<a class="anchor" id="a18c4ffd947492bcd664a0748de461e77"></a><!-- doxytag: member="bsl::const_pointer_cast" ref="a18c4ffd947492bcd664a0748de461e77" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TO_TYPE , class FROM_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt; bsl::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>FROM_TYPE</code>, and referring to <code>const_cast&lt;TO_TYPE *&gt;(source.get())</code>. Note that if <code>source</code> cannot be <code>const</code>-cast to <code>TO_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="a3f15ce3b15ab5edbb6d3f557387244eb"></a><!-- doxytag: member="bsl::dynamic_pointer_cast" ref="a3f15ce3b15ab5edbb6d3f557387244eb" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TO_TYPE , class FROM_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt; bsl::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>FROM_TYPE</code>, and referring to <code>dynamic_cast&lt;TO_TYPE*&gt;(source.get())</code>. If <code>source</code> cannot be dynamically cast to <code>TO_TYPE *</code>, then an empty <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt;</code> object is returned. </p>

</div>
</div>
<a class="anchor" id="a50eab0a8106cddb7fb5834139f0a1c76"></a><!-- doxytag: member="bsl::static_pointer_cast" ref="a50eab0a8106cddb7fb5834139f0a1c76" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TO_TYPE , class FROM_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt; bsl::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>FROM_TYPE</code>, and referring to <code>static_cast&lt;TO_TYPE *&gt;(source.get())</code>. Note that if <code>source</code> cannot be statically cast to <code>TO_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="a842124bb63d969e2caf74d9acab97fc5"></a><!-- doxytag: member="bsl::allocate_shared" ref="a842124bb63d969e2caf74d9acab97fc5" args="(ALLOC basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af2cdad3ee884ea8b77ab9c1426f56fbd"></a><!-- doxytag: member="bsl::allocate_shared" ref="af2cdad3ee884ea8b77ab9c1426f56fbd" args="(ALLOC basicAllocator, const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aafac01371f305d61c5c78789e1e7946d"></a><!-- doxytag: member="bsl::allocate_shared" ref="aafac01371f305d61c5c78789e1e7946d" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af290055ca0d2dd2a1cb63b87b45c1150"></a><!-- doxytag: member="bsl::allocate_shared" ref="af290055ca0d2dd2a1cb63b87b45c1150" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a01d65a5dc53c7e2eb8e3611e26eb97bc"></a><!-- doxytag: member="bsl::allocate_shared" ref="a01d65a5dc53c7e2eb8e3611e26eb97bc" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2bd5e0e636661483155a7c1c8b3e38ae"></a><!-- doxytag: member="bsl::allocate_shared" ref="a2bd5e0e636661483155a7c1c8b3e38ae" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53ddafd51e59bf1e423a926039c54b52"></a><!-- doxytag: member="bsl::allocate_shared" ref="a53ddafd51e59bf1e423a926039c54b52" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c2325b69b0e632dce693eef38ec06b8"></a><!-- doxytag: member="bsl::allocate_shared" ref="a5c2325b69b0e632dce693eef38ec06b8" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a65a4a51652aba5a8bba984d8619ae9"></a><!-- doxytag: member="bsl::allocate_shared" ref="a2a65a4a51652aba5a8bba984d8619ae9" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ace3929d2362de8b5b52094a9f6d6eed2"></a><!-- doxytag: member="bsl::allocate_shared" ref="ace3929d2362de8b5b52094a9f6d6eed2" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aac721eeddc042f80302f2b9f4785b53a"></a><!-- doxytag: member="bsl::allocate_shared" ref="aac721eeddc042f80302f2b9f4785b53a" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9606c6f277d02bbfcc74c06f7cba41d1"></a><!-- doxytag: member="bsl::allocate_shared" ref="a9606c6f277d02bbfcc74c06f7cba41d1" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab59fe722c57eec981284f58d5d20cd29"></a><!-- doxytag: member="bsl::allocate_shared" ref="ab59fe722c57eec981284f58d5d20cd29" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1da907c0dbd8b80f8a3c768e85e7d5d"></a><!-- doxytag: member="bsl::allocate_shared" ref="aa1da907c0dbd8b80f8a3c768e85e7d5d" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab57cfb5ad98e1adf035316e35672077a"></a><!-- doxytag: member="bsl::allocate_shared" ref="ab57cfb5ad98e1adf035316e35672077a" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object referring to and managing a new <code>ELEMENT_TYPE</code> object. The specified <code>basicAllocator</code> will be used to supply a single contiguous region of memory holding the returned shared pointer's internal representation and the new <code>ELEMENT_TYPE</code> object, which is initialized by calling <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a>&lt;ALLOC&gt;construct</code> passing <code>basicAllocator</code>, an <code>ELEMENT_TYPE *</code> pointer to space for the new shared object, and the specified arguments <code>a1</code> up to <code>aN</code> where <code>N</code> (at most 14) is the number of arguments passed to this method. Note that the allocator argument is <em>not</em> implicitly passed to the constructor for <code>ELEMENT_TYPE</code>; typically, to construct an object of <code>ELEMENT_TYPE</code> with an allocator, pass the allocator as one of the arguments (frequently the last argument), but note that some allocators will perform this customization in their <code>construct</code> implementation. </p>

</div>
</div>
<a class="anchor" id="aa5cf03e39a028e9896de9a8c08df1445"></a><!-- doxytag: member="bsl::allocate_shared" ref="aa5cf03e39a028e9896de9a8c08df1445" args="(ALLOC *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f487dab167660990e57e8f6dd4ce8e6"></a><!-- doxytag: member="bsl::allocate_shared" ref="a7f487dab167660990e57e8f6dd4ce8e6" args="(ALLOC *basicAllocator, const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a952b9d0f95d7a0f91f485d1146beb191"></a><!-- doxytag: member="bsl::allocate_shared" ref="a952b9d0f95d7a0f91f485d1146beb191" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2168d1fe1563beb5029888bf7f64f2ec"></a><!-- doxytag: member="bsl::allocate_shared" ref="a2168d1fe1563beb5029888bf7f64f2ec" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0e189e4547a008770d94657320a19757"></a><!-- doxytag: member="bsl::allocate_shared" ref="a0e189e4547a008770d94657320a19757" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="affcd074404490763a00537270d15a919"></a><!-- doxytag: member="bsl::allocate_shared" ref="affcd074404490763a00537270d15a919" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4074c4cc4167a9ed7c6c2dc5f88e7d29"></a><!-- doxytag: member="bsl::allocate_shared" ref="a4074c4cc4167a9ed7c6c2dc5f88e7d29" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d1ed3d2127b1f90ee4f088e236b98aa"></a><!-- doxytag: member="bsl::allocate_shared" ref="a5d1ed3d2127b1f90ee4f088e236b98aa" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a777ca6cbbff46d15b499a10a901d7d11"></a><!-- doxytag: member="bsl::allocate_shared" ref="a777ca6cbbff46d15b499a10a901d7d11" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9075db3c0bc09d1fb7fbcca6f8109392"></a><!-- doxytag: member="bsl::allocate_shared" ref="a9075db3c0bc09d1fb7fbcca6f8109392" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a43c7f93dad387f6c22e352c18e4ebf21"></a><!-- doxytag: member="bsl::allocate_shared" ref="a43c7f93dad387f6c22e352c18e4ebf21" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a16b6a4c819dfbd9fb72dd3e1e7580a"></a><!-- doxytag: member="bsl::allocate_shared" ref="a6a16b6a4c819dfbd9fb72dd3e1e7580a" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b455a513f5fa28d4199646af210ef14"></a><!-- doxytag: member="bsl::allocate_shared" ref="a4b455a513f5fa28d4199646af210ef14" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3cdaf66722173632cf99dcba808fe7a4"></a><!-- doxytag: member="bsl::allocate_shared" ref="a3cdaf66722173632cf99dcba808fe7a4" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a852abbdd03b262816ec5f706e78daa66"></a><!-- doxytag: member="bsl::allocate_shared" ref="a852abbdd03b262816ec5f706e78daa66" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object referring to and managing a new <code>ELEMENT_TYPE</code> object. The specified <code>basicAllocator</code> will be used to supply a single contiguous region of memory holding the returned shared pointer's internal representation and the new <code>ELEMENT_TYPE</code> object, which is initialized using the <code>ELEMENT_TYPE</code> constructor that takes the specified arguments <code>a1</code> up to <code>aN</code> where <code>N</code> (at most 14) is the number of arguments passed to this method. If <code>ELEMENT_TYPE</code> uses <code>blsma</code> allocators, then the default allocator is passed as an extra argument in the final position. </p>

</div>
</div>
<a class="anchor" id="a0afacd0aecba8ee3341580f6e696bee5"></a><!-- doxytag: member="bsl::make_shared" ref="a0afacd0aecba8ee3341580f6e696bee5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a948481509b5773206e5ea25c52b61283"></a><!-- doxytag: member="bsl::make_shared" ref="a948481509b5773206e5ea25c52b61283" args="(const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed83c08eabc1f22ff41be3d7949b016a"></a><!-- doxytag: member="bsl::make_shared" ref="aed83c08eabc1f22ff41be3d7949b016a" args="(const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b3b07f21e4b038a58efa13ea2583d18"></a><!-- doxytag: member="bsl::make_shared" ref="a5b3b07f21e4b038a58efa13ea2583d18" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ccdad6d77d6f91c4d26d36a2a1c9933"></a><!-- doxytag: member="bsl::make_shared" ref="a5ccdad6d77d6f91c4d26d36a2a1c9933" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad70fcbb076fc7c7c9e75f297f2149c58"></a><!-- doxytag: member="bsl::make_shared" ref="ad70fcbb076fc7c7c9e75f297f2149c58" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a41fdc22eb8ffb9ac386b266e2b100f47"></a><!-- doxytag: member="bsl::make_shared" ref="a41fdc22eb8ffb9ac386b266e2b100f47" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a18cef762683586ddcf554750974540"></a><!-- doxytag: member="bsl::make_shared" ref="a0a18cef762683586ddcf554750974540" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5386aae75c602403e22c26f58d9aa3f2"></a><!-- doxytag: member="bsl::make_shared" ref="a5386aae75c602403e22c26f58d9aa3f2" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c90eba2b70dc7509f69950d04bfee31"></a><!-- doxytag: member="bsl::make_shared" ref="a0c90eba2b70dc7509f69950d04bfee31" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a98eed9180e3758990ff0bda0b0f41683"></a><!-- doxytag: member="bsl::make_shared" ref="a98eed9180e3758990ff0bda0b0f41683" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a47afd18d2ac49909d2f78359550bcd65"></a><!-- doxytag: member="bsl::make_shared" ref="a47afd18d2ac49909d2f78359550bcd65" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae7f8b8e43681cb4423673c7dce5488b1"></a><!-- doxytag: member="bsl::make_shared" ref="ae7f8b8e43681cb4423673c7dce5488b1" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a72666c8cd2da3ed6ce6bd6c27f0cd189"></a><!-- doxytag: member="bsl::make_shared" ref="a72666c8cd2da3ed6ce6bd6c27f0cd189" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3876caafb24bb32d3300754b741cd7a6"></a><!-- doxytag: member="bsl::make_shared" ref="a3876caafb24bb32d3300754b741cd7a6" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object referring to and managing a new <code>ELEMENT_TYPE</code> object. The default allocator will be used to supply a single contiguous region of memory holding the returned shared pointer's internal representation and the new <code>ELEMENT_TYPE</code> object, which is initialized using the <code>ELEMENT_TYPE</code> constructor that takes the specified arguments <code>a1</code> up to <code>aN</code> where <code>N</code> (at most 14) is the number of arguments passed to this method. If <code>ELEMENT_TYPE</code> uses <code>blsma</code> allocators, then the default allocator is passed as an extra argument in the final position. </p>

</div>
</div>
<a class="anchor" id="a1e192ddeb52d359284e9b3fde2e54fd4"></a><!-- doxytag: member="bsl::swap" ref="a1e192ddeb52d359284e9b3fde2e54fd4" args="(weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b) BSLS_CPP11_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the states of the specified <code>a</code> and <code>b</code> weak pointers such that each will refer to the object (if any) and representation formerly referred to by the other. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:35 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
