<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Namespace bsl</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bsl Namespace Reference<br/>
<small>
[<a class="el" href="group__bslalg__dequeiterator.html">Component bslalg_dequeiterator</a>,&nbsp;<a class="el" href="group__bslmf__addconst.html">Component bslmf_addconst</a>,&nbsp;<a class="el" href="group__bslmf__addvolatile.html">Component bslmf_addvolatile</a>,&nbsp;<a class="el" href="group__bslmf__integralconstant.html">Component bslmf_integralconstant</a>,&nbsp;<a class="el" href="group__bslmf__isclass.html">Component bslmf_isclass</a>,&nbsp;<a class="el" href="group__bslmf__isconvertible.html">Component bslmf_isconvertible</a>,&nbsp;<a class="el" href="group__bslmf__isenum.html">Component bslmf_isenum</a>,&nbsp;<a class="el" href="group__bslmf__isfloatingpoint.html">Component bslmf_isfloatingpoint</a>,&nbsp;<a class="el" href="group__bslmf__isfundamental.html">Component bslmf_isfundamental</a>,&nbsp;<a class="el" href="group__bslmf__isintegral.html">Component bslmf_isintegral</a>,&nbsp;<a class="el" href="group__bslmf__ismemberfunctionpointer.html">Component bslmf_ismemberfunctionpointer</a>,&nbsp;<a class="el" href="group__bslmf__ismemberobjectpointer.html">Component bslmf_ismemberobjectpointer</a>,&nbsp;<a class="el" href="group__bslmf__ispointer.html">Component bslmf_ispointer</a>,&nbsp;<a class="el" href="group__bslmf__ispolymorphic.html">Component bslmf_ispolymorphic</a>,&nbsp;<a class="el" href="group__bslmf__isvoid.html">Component bslmf_isvoid</a>,&nbsp;<a class="el" href="group__bslmf__removepointer.html">Component bslmf_removepointer</a>,&nbsp;<a class="el" href="group__bslstl__priorityqueue.html">Component bslstl_priorityqueue</a>,&nbsp;<a class="el" href="group__bslstl__queue.html">Component bslstl_queue</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01BloombergLP_1_1bslalg_1_1DequeIterator_3_01VALUE__TYPE_00_01BLOCK__LENGTH_01_4_01_4.html">is_trivially_copyable&lt; BloombergLP::bslalg::DequeIterator&lt; VALUE_TYPE, BLOCK_LENGTH &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__const.html">add_const</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__cv.html">add_cv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01TYPE_01_6_01_4.html">add_lvalue_reference&lt; TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01void_01_4.html">add_lvalue_reference&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01void_01const_01_01_4.html">add_lvalue_reference&lt; void const  &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01void_01volatile_01_4.html">add_lvalue_reference&lt; void volatile &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference_3_01void_01const_01volatile_01_4.html">add_lvalue_reference&lt; void const volatile &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__pointer.html">add_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__volatile.html">add_volatile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1conditional.html">conditional</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1conditional_3_01false_00_01TRUE__TYPE_00_01FALSE__TYPE_01_4.html">conditional&lt; false, TRUE_TYPE, FALSE_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1enable__if.html">enable_if</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1enable__if_3_01false_00_01TYPE_01_4.html">enable_if&lt; false, TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1integral__constant_3_01bool_00_01VAL_01_4.html">integral_constant&lt; bool, VAL &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__array.html">is_array</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__array_3_01TYPE[NUM__ELEMENTS]_4.html">is_array&lt; TYPE[NUM_ELEMENTS]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__array_3_01TYPE[]_4.html">is_array&lt; TYPE[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__array_3_01TYPE_01_6_01_4.html">is_array&lt; TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__class.html">is_class</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__const.html">is_const</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__const_3_01TYPE_01const_01_01_4.html">is_const&lt; TYPE const  &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible.html">is_convertible</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01FROM__TYPE_00_01TO__TYPE_01_6_01_4.html">is_convertible&lt; FROM_TYPE, TO_TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01FROM__TYPE_00_01void_01_4.html">is_convertible&lt; FROM_TYPE, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01volatile_01FROM__TYPE_00_01TO__TYPE_01_4.html">is_convertible&lt; volatile FROM_TYPE, TO_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01volatile_01FROM__TYPE_00_01TO__TYPE_01_6_01_4.html">is_convertible&lt; volatile FROM_TYPE, TO_TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01volatile_01FROM__TYPE_00_01void_01_4.html">is_convertible&lt; volatile FROM_TYPE, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01volatile_01FROM__TYPE_01_6_00_01TO__TYPE_01_4.html">is_convertible&lt; volatile FROM_TYPE &amp;, TO_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01volatile_01FROM__TYPE_01_6_00_01TO__TYPE_01_6_01_4.html">is_convertible&lt; volatile FROM_TYPE &amp;, TO_TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01volatile_01FROM__TYPE_01_6_00_01void_01_4.html">is_convertible&lt; volatile FROM_TYPE &amp;, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01void_00_01TO__TYPE_01_4.html">is_convertible&lt; void, TO_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01void_00_01TO__TYPE_01_6_01_4.html">is_convertible&lt; void, TO_TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__convertible_3_01void_00_01void_01_4.html">is_convertible&lt; void, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__enum.html">is_enum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__function.html">is_function</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__fundamental.html">is_fundamental</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__integral.html">is_integral</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__lvalue__reference.html">is_lvalue_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__lvalue__reference_3_01TYPE_01_6_01_4.html">is_lvalue_reference&lt; TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__polymorphic.html">is_polymorphic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__reference.html">is_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__rvalue__reference.html">is_rvalue_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__same.html">is_same</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__same_3_01TYPE_00_01TYPE_01_4.html">is_same&lt; TYPE, TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable.html">is_trivially_copyable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__void.html">is_void</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__volatile.html">is_volatile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__volatile_3_01TYPE_01volatile_01_4.html">is_volatile&lt; TYPE volatile &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__const.html">remove_const</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__const_3_01TYPE_01const_01_01_4.html">remove_const&lt; TYPE const  &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__reference_3_01TYPE_01_6_01_4.html">remove_reference&lt; TYPE &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__volatile_3_01TYPE_01volatile_01_4.html">remove_volatile&lt; TYPE volatile &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1allocator.html">allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1allocator_3_01void_01_4.html">allocator&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Deque__BlockLengthCalcUtil.html">Deque_BlockLengthCalcUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Deque__Util.html">Deque_Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__Base.html">Deque_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1deque.html">deque</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__BlockCreator.html">Deque_BlockCreator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__ClearGuard.html">Deque_ClearGuard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Deque__Guard.html">Deque_Guard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1equal__to.html">equal_to</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C++11-compliant binary functor applying <code>operator==</code>  <a href="structbsl_1_1equal__to.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01equal__to_3_01VALUE__TYPE_01_4_01_4.html">is_trivially_default_constructible&lt; equal_to&lt; VALUE_TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01equal__to_3_01VALUE__TYPE_01_4_01_4.html">is_trivially_copyable&lt; equal_to&lt; VALUE_TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01hash_3_01TYPE_01_4_01_4.html">is_trivially_default_constructible&lt; hash&lt; TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01hash_3_01TYPE_01_4_01_4.html">is_trivially_copyable&lt; hash&lt; TYPE &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01const_01BSLSTL__KEY_01_4.html">hash&lt; const BSLSTL_KEY &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01TYPE_01_5_01_4.html">hash&lt; TYPE * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01bool_01_4.html">hash&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01char_01_4.html">hash&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01signed_01char_01_4.html">hash&lt; signed char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01char_01_4.html">hash&lt; unsigned char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01wchar__t_01_4.html">hash&lt; wchar_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01short_01_4.html">hash&lt; short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01short_01_4.html">hash&lt; unsigned short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01int_01_4.html">hash&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01int_01_4.html">hash&lt; unsigned int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01long_01_4.html">hash&lt; long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01long_01_4.html">hash&lt; unsigned long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01long_01long_01_4.html">hash&lt; long long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01long_01long_01_4.html">hash&lt; unsigned long long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01float_01_4.html">hash&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01double_01_4.html">hash&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01long_01double_01_4.html">hash&lt; long double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__istringstream.html">basic_istringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1List__Node.html">List_Node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1list.html">list</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1map.html">map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1multimap.html">multimap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1multiset.html">multiset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__ostringstream.html">basic_ostringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_011_00_010_01_4.html">Pair_Imp&lt; T1, T2, 1, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_010_00_011_01_4.html">Pair_Imp&lt; T1, T2, 0, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_011_00_011_01_4.html">Pair_Imp&lt; T1, T2, 1, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1pair.html">pair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__copyable_3_01pair_3_01T1_00_01T2_01_4_01_4.html">is_trivially_copyable&lt; pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01bsl_1_1pair_3_01T1_00_01T2_01_4_01_4.html">is_trivially_default_constructible&lt; bsl::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1priority__queue.html">priority_queue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1queue.html">queue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1set.html">set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Stack__HasAllocatorType.html">Stack_HasAllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1stack.html">stack</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1String__Imp.html">String_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01basic__string_3_01CHAR__TYPE_00_01CHAR__TRAITS_00_01ALLOCATOR_01_4_01_4.html">hash&lt; basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1StringBufContainer.html">StringBufContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__stringstream.html">basic_stringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__Util.html">Vector_Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Vector__ImpBase.html">Vector_ImpBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector.html">vector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector_3_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.html">vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector_3_01const_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.html">vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__DeduceIteratorCategory.html">Vector_DeduceIteratorCategory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__DeduceIteratorCategory_3_01BSLSTL__ITERATOR_00_01true_01_4.html">Vector_DeduceIteratorCategory&lt; BSLSTL_ITERATOR, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__IsRandomAccessIterator.html">Vector_IsRandomAccessIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__RangeCheck.html">Vector_RangeCheck</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a><br class="typebreak"/>
&lt; bool, false &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a><br class="typebreak"/>
&lt; bool, true &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bsls::Nullptr_Impl::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a>&lt; char, <br class="typebreak"/>
char_traits&lt; char &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga91edb302fcc1bc234d5537139e3240f9">stringbuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__istringstream.html">basic_istringstream</a><br class="typebreak"/>
&lt; char, char_traits&lt; char &gt;<br class="typebreak"/>
, <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga294e494cba97738d8e493e190f768ad6">istringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__ostringstream.html">basic_ostringstream</a><br class="typebreak"/>
&lt; char, char_traits&lt; char &gt;<br class="typebreak"/>
, <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#gab9a0f4d1fbd8bc1aaf5d375a4ef030b1">ostringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__stringstream.html">basic_stringstream</a><br class="typebreak"/>
&lt; char, char_traits&lt; char &gt;<br class="typebreak"/>
, <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga57f57361aba424d879e8dccd9d11e5dd">stringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a><br class="typebreak"/>
&lt; wchar_t, char_traits<br class="typebreak"/>
&lt; wchar_t &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; wchar_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga354bf749fb252b9beaa5e4ad5d1261d7">wstringbuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__istringstream.html">basic_istringstream</a><br class="typebreak"/>
&lt; wchar_t, char_traits<br class="typebreak"/>
&lt; wchar_t &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; wchar_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga0310a8dbbfcaae3db66ba63771f99b80">wistringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__ostringstream.html">basic_ostringstream</a><br class="typebreak"/>
&lt; wchar_t, char_traits<br class="typebreak"/>
&lt; wchar_t &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; wchar_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga4cbf750ba4f9c875c74a82e1cad7dbb4">wostringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__stringstream.html">basic_stringstream</a><br class="typebreak"/>
&lt; wchar_t, char_traits<br class="typebreak"/>
&lt; wchar_t &gt;, <a class="el" href="classbsl_1_1allocator.html">allocator</a><br class="typebreak"/>
&lt; wchar_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__iosfwd.html#ga211eb259cf31d2a9fc31add134d8b3ce">wstringstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab67de1ebe0184939129507efe5c86bb1">string</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; wchar_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gab3b4e0ebb1e917062e2cc0a71d69fa81">wstring</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a> (const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a> (const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gac670def83951dc213e173ca26625f3d0">operator==</a> (const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt; &amp;lhs, const BloombergLP::bslma::Allocator *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gabdcd355a6885da0eb7d47aa7410aee04">operator!=</a> (const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt; &amp;lhs, const BloombergLP::bslma::Allocator *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga61cb1e180a4ddd04c182bb7bc91384e8">operator==</a> (const BloombergLP::bslma::Allocator *lhs, const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga0a4465ac5dff39c1acd5cb17efb89dab">operator!=</a> (const BloombergLP::bslma::Allocator *lhs, const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gae932279610e8893d59e68df4f6968c64">operator==</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga323083767092dbeb43ec96ea2eeb44c7">operator!=</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">operator&lt;</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga8f2ff3ac7d315597e6bf4cf3f1376e51">operator&gt;</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#gacab21200cbc635611051996fa4ce0c71">operator&lt;=</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga6c3069d504792f532e25e1d7f1456a15">operator&gt;=</a> (const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a> (<a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, <a class="el" href="classbsl_1_1deque.html">deque</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class NODEPTR , class DIFFTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga4d35eb893ce83ba11f7e4dac35ee2a2d">operator==</a> (<a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T1, NODEPTR, DIFFTYPE &gt; lhs, <a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T2, NODEPTR, DIFFTYPE &gt; rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class NODEPTR , class DIFFTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8fa345b57fb8278d8760d1fd90157eae">operator!=</a> (<a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T1, NODEPTR, DIFFTYPE &gt; lhs, <a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T2, NODEPTR, DIFFTYPE &gt; rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga39c2b71f4356c6f9f1a69d441dda4c26">operator==</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacea9175011d9b18a01cb38e6e23d56e0">operator!=</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacd1873ee9d29582411de3abe4a3e79ee">operator&lt;</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8f4598ceb1aee9f39781704c381ed8d1">operator&gt;</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga7e448645b21786d13f6377a64adfce1f">operator&lt;=</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga009bc1ba641b09a01e9e0c516cba7092">operator&gt;=</a> (const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8a4fac7379d969587e69a3186c91f583">swap</a> (<a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;lhs, <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga22facc5669cef057868333b50b07be3c">operator==</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga50c4f19d172d7814a397ca2aedd4b74f">operator!=</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga13fe89539cf5b17b8cd39c1ef71eade9">operator&lt;</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga7d03b6985f6885cdf2fbe566bd7468bb">operator&gt;</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaf0de3e7790300393e630816813ec1c9a">operator&lt;=</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gafd6033641c01e3b3fb8b955f75676901">operator&gt;=</a> (const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga8ffecdad6636be8054c6ff5d8c772cb2">swap</a> (<a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gae27bff9d448ee8c63a9171d2a395720b">operator==</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga4fc52a0082eb837264b9de4d1d92db60">operator!=</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gac9b2f689b4da8f5b466377d30fe65d96">operator&lt;</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga94a2b9a893c655bcd903fd31f0ef14cb">operator&gt;</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga4efa7f5e34b40ac39190468e744f969a">operator&lt;=</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#gad512a2f22b260bcb81daf71a51c63c37">operator&gt;=</a> (const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multimap.html#ga153c934515e350c6786edec5a81b7be5">swap</a> (<a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1multimap.html">multimap</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga6b27ce014d210bdab4dcc0e8eb313262">operator==</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaa9e0287e54abb4f45c0b5d6d81e138cd">operator!=</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga5f75f92a4ad3cea69cc8d4dd81f1a892">operator&lt;</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga0202c754266ad01bd8e5fb5bf3eb0f4b">operator&gt;</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gae4d913748cdddae30ae432d7407d94e0">operator&gt;=</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaad5b6eb4abdefb9a20e2af663b822573">operator&lt;=</a> (const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gab649ed015369ea41b6e05bc6b524dcd8">swap</a> (<a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a9a7785279a114a5b6cf645ff59f2ad85">operator==</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga50b4aea952721acf5ad54aa2bc758c8d">operator!=</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga97c477e75c90f40b8122aa0702fb652c">operator&lt;</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaecdfed596ebac61d4ebfda51e911b916">operator&gt;</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gade131fc530151248b67d2c88522832e3">operator&lt;=</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaa19d2c4a4e8788af13eab13f37c5e53e">operator&gt;=</a> (const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga8dd0a3f8324bcc657bc448230e8f5b4b">swap</a> (<a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;a, <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER , class COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aae3cf461eb5ab91a840a7c5971e73d2e">swap</a> (<a class="el" href="classbsl_1_1priority__queue.html">priority_queue</a>&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;lhs, <a class="el" href="classbsl_1_1priority__queue.html">priority_queue</a>&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aea945e62f1d56d6de8d18add7a69032c">operator==</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a09400e14804ca7e312c982f2d0d70f9e">operator!=</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a3c8ac4f5467823210019acdfd464cc44">operator&lt;</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a20fa0ded3c1fc13bfb2d30241a52348c">operator&gt;</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4cfd370cd9654f11d99e8dd27f8d4b3d">operator&gt;=</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad9ecc25aa91817ea5f6914f8217c5098">operator&lt;=</a> (const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#acb5d1f34e06e5f7e51389f184262b86d">swap</a> (<a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, <a class="el" href="classbsl_1_1queue.html">queue</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gadc5c97041a3b7c06863fa093d37152f7">operator==</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga64f502a1498b19207f1e7812832dc833">operator!=</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gadcabb714950bc28dba72240a6a95324d">operator&lt;</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga2768d770127ea7018262726328633342">operator&gt;</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga5fad735708a2c5e2d67581a840f71f26">operator&lt;=</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga009ed5fb1156f5d23e0bc6a51386d986">operator&gt;=</a> (const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaac71b5ac0a4c5e73c7c96f14046f3e8f">swap</a> (<a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga4de7c661423b992c4efac216574915f1">operator==</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga585bf4a1dfbacb8e796ceee38e0b667e">operator!=</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaf40f0bba0cda8cd451cefafd1e09cf8b">operator&lt;</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga5400f7f0238a7c6c2ab6e880686473a9">operator&gt;</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gad92196ff0aec88dd3db886ea825d6645">operator&lt;=</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga083c333856bdb6110947f806405c1cda">operator&gt;=</a> (const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga69a3b02c7015296255025773a76d7a8c">swap</a> (<a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;lhs, <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga018249bd88b8a5cabef70d879d83f4e2">operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga174c18650388ebbfaf65903622e8d411">operator==</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaeea3e40017b0b91afde35924cacd0236">operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae4236ec7ed54aad1d2ab459c07272686">operator==</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga94f4f2fcc02cea9d859bc6fc590c37ce">operator==</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4a515bec807795fc9c397df08143ece3">operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf2fe09d66ed45e7186d3662d19098ee1">operator!=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf17352aafac44a780c4527aff83cbd3d">operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga53ac23905daba69217f6395b18a18c48">operator!=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga099e3847d670070b532e1656f6949c6f">operator!=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga3c67cfa96cea8409daeb261194224055">operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga31d7c587dc965a9d5bacf1c7804e8419">operator&lt;</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga9b607b0f429d7d06fdb1ea217e029624">operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga53520ad4579b0e7ebe3a330ea3aef1a6">operator&lt;</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf6dc55ce3ecacb8f1ee81c6d19f77a05">operator&lt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacda2be81859ae7036eedca64e4231345">operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga88796fccdc9069c252a2f2da21b42a38">operator&gt;</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga2970f100d7b208f34a4422d55683f661">operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaf9104abf11faaf9942d7ffd2b8de967a">operator&gt;</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga577e4a2c400b379888b612dd6cb99e7f">operator&gt;</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaccc781f81a2995d86f0343dc53b91029">operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa0808c8a264435c0e68d22105dafdf4c">operator&lt;=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga09517e1c94cbeb09c0f7726db39a4cba">operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa248cb81f7d2915d3bc73db7dc8347a2">operator&lt;=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga88654fdf68b7f294544efe5f5137e24c">operator&lt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga64a1cad020be5478c3bcda0e2f1d492c">operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4824e50e3103d3fcaf2c967d611c9bf2">operator&gt;=</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gafd58b60d5dfbc0dce3b941af777ddaf3">operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1e50fd9fe50da05263c7474dc28274af">operator&gt;=</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga41cc8642f854de72b026f8c0de3df3e8">operator&gt;=</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga7002308bb0f4bda8f778835534b42c77">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOC2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae8d80734fc3cc567b156eb41cd1ef2f9">operator+</a> (const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOC1 , class ALLOC2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOC1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga23ab81de15e0a819eabd833d4e772cce">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC1 &gt; &amp;lhs, const native_std::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOC2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaec70661d55ff3e072f49adf62a79089a">operator+</a> (const CHAR_TYPE *lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae5d2808b6aedbe18b59d79f836bd6d81">operator+</a> (CHAR_TYPE lhs, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gae571b4cf326a6c1e456bd254b6c3828f">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, const CHAR_TYPE *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR_TYPE , typename CHAR_TRAITS , typename ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gacffc0ca7ec91947c737e86c00ae095e0">operator+</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, CHAR_TYPE rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga651fb2835be5936337f1ced5d2d23167">operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;os, const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga389ca2ea44531dc5577498403eee4aa1">operator&gt;&gt;</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#gaa85645c85b7e6553fc597a2fa2ddf31d">swap</a> (<a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;lhs, <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga65b2dba7122e31d8454685fb771f6063">getline</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str, CHAR_TYPE delim)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1ca512eae66e91d9165a0d5486f49520">getline</a> (std::basic_istream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;is, <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga466018873ba5698c6e628a7a53a2b6bd">hashBasicString</a> (const <a class="el" href="classbsl_1_1basic__string.html">basic_string</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt; &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga1ab59c0071935cd8bb0ad6036b167505">hashBasicString</a> (const <a class="el" href="classbsl_1_1basic__string.html">string</a> &amp;str)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__string.html#ga4b3fce5dc0cd144fbc681a1858813f82">bslstl_string_fill</a> (std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;os, std::basic_streambuf&lt; CHAR_TYPE, CHAR_TRAITS &gt; *buf, size_t n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga0c4f54461a359b055782b5a6a3bcb14c">operator==</a> (const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga631ea915746fe2b1f2664f2b2306d4d2">operator!=</a> (const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga2c1a5c101ec75196e300c49d54a40833">swap</a> (<a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga601a88fd6f232d89827226c779166c7c">operator==</a> (const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gace2f15b7cbef1336dd4dd63794e3f1dd">operator!=</a> (const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gab05428af9fd5f4e0b126c742b056fa73">swap</a> (<a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;x, <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga8e9c9a9220ff75ddc73acee85bfa7392">operator==</a> (const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gae0f2b56046e1efc815e5637ed81ce7a8">operator!=</a> (const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gad7ead0881f1289594de31f274644e068">swap</a> (<a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;x, <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedset.html#gaadd1e9430a785482668e49d4bfb0ccea">operator==</a> (const <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedset.html#gab692dbfdc45954204c1b0876a8879d48">operator!=</a> (const <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedset.html#ga4af72681395b77c7e322921268cf320d">swap</a> (<a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;x, <a class="el" href="classbsl_1_1unordered__set.html">unordered_set</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae1cf7ebaf57b20ad849f3cec698e88b9">operator==</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3b21b4b523ef349a450e774e69fba3a2">operator!=</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafae8e5536e4d0104153320a37e8c1e3a">operator&lt;</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga625351fd0ddd03d582652b3aae6ebbc9">operator&gt;</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9300705f377d58094c8b40530816ffb7">operator&lt;=</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4310a39a792a2712adaa5104a67a0bf8">operator&gt;=</a> (const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga73c7729c8388a194029dab1d69d08360">swap</a> (<a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1829ad82eb519b1fb7c79a803af91153">operator==</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae2296fbb2872dbb82c90f7c41ab6ca41">operator!=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaaa78d320fb70553c12c5ac664ef03e4e">operator&lt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9fefac8bbb8472a45f2f021b3045b886">operator&gt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad43a151e8130ffa1975e64bceae4cfef">operator&lt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga926b2d565333233f7bca60072014322a">operator&gt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab76628a7a0c98d331cb819c2a350eb66">operator==</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa050f07faffd38620497590ae4a99b4d">operator!=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad44b0030adeab48da89a630cd9dbda69">operator&lt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga06eed7e12572f6abb9838f1737348bd6">operator&gt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga43dfb63a5e8e2518d34771637f3b3815">operator&lt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae74b32df8b2eebf0034d006226553379">operator&gt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab53faa313dc32ebffbfb834e8f6bc923">swap</a> (<a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6bc33a80f40864c84d527e1dba8ea0f7">operator==</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga70e39ecc5bb6b312e77055ab69db74e9">operator!=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1d962f9bb93e44002b825909c6f5481c">operator&lt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga55051a5f21e7701e046a08080015b9d9">operator&gt;</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga229794ea813dde0fe7160991fccb5253">operator&lt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac48a0847b58ba26910284d521f2dfb4f">operator&gt;=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga11c0d5aedac133a4c9fd2a2404471c2c">swap</a> (<a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;a, <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;b)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a072205c212218b4b4cccaf66052c99a4"></a><!-- doxytag: member="bsl::false_type" ref="a072205c212218b4b4cccaf66052c99a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a>&lt;bool, false&gt; <a class="el" href="structbsl_1_1integral__constant.html">bsl::false_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a124171e6663dfc2b3c10256844c8dc3b"></a><!-- doxytag: member="bsl::true_type" ref="a124171e6663dfc2b3c10256844c8dc3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsl_1_1integral__constant.html">integral_constant</a>&lt;bool, true&gt; <a class="el" href="structbsl_1_1integral__constant.html">bsl::true_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a15d68a87901fa9543f847ada4ee76fd3"></a><!-- doxytag: member="bsl::nullptr_t" ref="a15d68a87901fa9543f847ada4ee76fd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bsls::Nullptr_Impl::Type <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9a7785279a114a5b6cf645ff59f2ad85"></a><!-- doxytag: member="bsl::operator==" ref="a9a7785279a114a5b6cf645ff59f2ad85" args="(const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified <code>lhs</code> and <code>rhs</code> pair objects have the same value and false otherwise. <code>lhs</code> has the same value as <code>rhs</code> if <code>lhs.first == rhs.first</code> and <code>lhs.second == rhs.second</code>. A call to this operator will not compile unless both <code>T1</code> and <code>T2</code> supply <code>operator==</code>. </p>

</div>
</div>
<a class="anchor" id="aae3cf461eb5ab91a840a7c5971e73d2e"></a><!-- doxytag: member="bsl::swap" ref="aae3cf461eb5ab91a840a7c5971e73d2e" args="(priority_queue&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;lhs, priority_queue&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER , class COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">priority_queue&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">priority_queue&lt; VALUE, CONTAINER, COMPARATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea945e62f1d56d6de8d18add7a69032c"></a><!-- doxytag: member="bsl::operator==" ref="aea945e62f1d56d6de8d18add7a69032c" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code>queue</code> objects have the same value if the containers they adapt are compared equal. </p>

</div>
</div>
<a class="anchor" id="a09400e14804ca7e312c982f2d0d70f9e"></a><!-- doxytag: member="bsl::operator!=" ref="a09400e14804ca7e312c982f2d0d70f9e" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code>queue</code> objects do not have the same value if the containers they adapt are not compared equal. </p>

</div>
</div>
<a class="anchor" id="a3c8ac4f5467823210019acdfd464cc44"></a><!-- doxytag: member="bsl::operator&lt;" ref="a3c8ac4f5467823210019acdfd464cc44" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> queue is lexicographically less than the specified <code>rhs</code> queue, and <code>false</code> otherwise. A queue <code>lhs</code> is lexicographically less than another queue <code>rhs</code> if the container adapted by <code>lhs</code> is lexicographically less than that adapted by <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="a20fa0ded3c1fc13bfb2d30241a52348c"></a><!-- doxytag: member="bsl::operator&gt;" ref="a20fa0ded3c1fc13bfb2d30241a52348c" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> queue is lexicographically greater than the specified <code>rhs</code> queue, and <code>false</code> otherwise. A queue <code>lhs</code> is lexicographically greater than another queue <code>rhs</code> if the container adapted by <code>lhs</code> is lexicographically greater than that adapted by <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="a4cfd370cd9654f11d99e8dd27f8d4b3d"></a><!-- doxytag: member="bsl::operator&gt;=" ref="a4cfd370cd9654f11d99e8dd27f8d4b3d" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> queue is lexicographically greater-than or equal-to the specified <code>rhs</code> queue, and <code>false</code> otherwise. A queue <code>lhs</code> is lexicographically greater-than or equal-to another queue <code>rhs</code> if the container adapted by <code>lhs</code> is lexicographically greater-than or equal-to that adapted by <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="ad9ecc25aa91817ea5f6914f8217c5098"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ad9ecc25aa91817ea5f6914f8217c5098" args="(const queue&lt; VALUE, CONTAINER &gt; &amp;lhs, const queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> queue is lexicographically less-than or equal-to the specified <code>rhs</code> queue, and <code>false</code> otherwise. A queue <code>lhs</code> is lexicographically less-than or equal-to another queue <code>rhs</code> if the container adapted by <code>lhs</code> is lexicographically less-than or equal-to that adapted by <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="acb5d1f34e06e5f7e51389f184262b86d"></a><!-- doxytag: member="bsl::swap" ref="acb5d1f34e06e5f7e51389f184262b86d" args="(queue&lt; VALUE, CONTAINER &gt; &amp;lhs, queue&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">queue&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the value of the specified <code>lhs</code> queue with the value of the specified <code>rhs</code> queue. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:45 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
