<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlt_time.h                                                        -*-C++-*-
#ifndef INCLUDED_BDLT_TIME
#define INCLUDED_BDLT_TIME

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a value-semantic time-of-day type (millisecond resolution).
//
//@CLASSES:
//  bdlt::Time: time-of-day type &#39;hh:mm:ss.sss&#39; (having millisecond resolution)
//
//@DESCRIPTION: This component implements a value-semantic time class,
// &#39;bdlt::Time&#39;, that can represent the time of day to a resolution of one
// millisecond (using a 24-hour clock).  Valid time values range from
// 00:00:00.000 (i.e., midnight) through 23:59:59.999.  A time value can be
// specified via four separate integer attribute values denoting hours
// &#39;[ 0 .. 23 ]&#39;, minutes &#39;[ 0 .. 59 ]&#39;, seconds &#39;[ 0 .. 59 ]&#39;, and
// milliseconds &#39;[ 0 ..  999 ]&#39;.  In addition, the &#39;bdlt::Time&#39; type has one
// more valid value, 24:00:00.000, which can be set explicitly and accessed.
// The value 24:00:00.000 behaves, in most cases, as if it were the value
// 00:00:00.000; however, for all relational comparison operators,
// 24:00:00.000 is not a valid argument and, therefore, would result in
// undefined behavior.  Each of the &#39;add&#39; manipulators, along with modifying
// the value of the object, return the (signed) number of times that the
// 23:59:59.999 - 00:00:00.000 boundary was crossed in performing the
// addition.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic &#39;bdlt::Time&#39; Usage
///- - - - - - - - - - - - - - - - - -
// This example demonstrates how to create and use a &#39;bdlt::Time&#39; object.
//
// First, create an object &#39;t1&#39; having the default value, and then verify that
// it represents the value 24:00:00.000:
//..
//  bdlt::Time t1;               assert(24 == t1.hour());
//                               assert( 0 == t1.minute());
//                               assert( 0 == t1.second());
//                               assert( 0 == t1.millisecond());
//..
// Then, set &#39;t1&#39; to the value 2:34pm (14:34:00.000):
//..
//  t1.setTime(14, 34);          assert(14 == t1.hour());
//                               assert(34 == t1.minute());
//                               assert( 0 == t1.second());
//                               assert( 0 == t1.millisecond());
//..
// Next, use &#39;setTimeIfValid&#39; to attempt to assign the invalid value 24:15 to
// &#39;t1&#39;, then verify the method returns an error status and the value of &#39;t1&#39;
// is unmodified:
//..
//  int ret = t1.setTimeIfValid(24, 15);
//                               assert( 0 != ret);          // 24:15 is not
//                                                           // valid
//
//                               assert(14 == t1.hour());    // no effect
//                               assert(34 == t1.minute());  // on the
//                               assert( 0 == t1.second());  // object
//                               assert( 0 == t1.millisecond());
//..
// Then, create &#39;t2&#39; as a copy of &#39;t1&#39;:
//..
//  bdlt::Time t2(t1);            assert(t1 == t2);
//..
// Next, add 5 minutes and 7 seconds to the value of &#39;t2&#39; (in two steps), and
// confirm the value of &#39;t2&#39;:
//..
//  t2.addMinutes(5);
//  t2.addSeconds(7);
//                               assert(14 == t2.hour());
//                               assert(39 == t2.minute());
//                               assert( 7 == t2.second());
//                               assert( 0 == t2.millisecond());
//..
// Then, subtract &#39;t1&#39; from &#39;t2&#39; to yield a &#39;bdlt::DatetimeInterval&#39; &#39;dt&#39;
// representing the time-interval between those two times, and verify the value
// of &#39;dt&#39; is 5 minutes and 7 seconds (or 307 seconds):
//..
//  bdlt::DatetimeInterval dt = t2 - t1;
//                               assert(307 == dt.totalSeconds());
//..
// Finally, stream the value of &#39;t2&#39; to &#39;stdout&#39;:
//..
//  bsl::cout &lt;&lt; t2 &lt;&lt; bsl::endl;
//..
// The streaming operator produces the following output on &#39;stdout&#39;:
//..
//  14:39:07.000
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIMEINTERVAL
#include &lt;bdlt_datetimeinterval.h&gt;
#endif

#ifndef INCLUDED_BDLT_TIMEUNITRATIO
#include &lt;bdlt_timeunitratio.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace bdlt {

                        // ==========
                        // class Time
                        // ==========

class Time {
    // This class implements a value-semantic type that represents the time of
    // day to a resolution of one millisecond.  Each object of this (almost)
    // simply constrained attribute class *always* represents a valid time
    // value to a resolution of one millisecond.  The valid range for times is
    // 00:00:00.000 through 23:59:59.999, except that 24:00:00.000 represents
    // the default-constructed value.  The value 24:00:00.000 behaves, in most
    // cases, as if it were the value 00:00:00.000; however for all relational
    // comparison operators, 24:00:00.000 is not a valid argument and,
    // therefore, would result in undefined behavior.  Each add operation on a
    // &#39;Time&#39; object will return the (signed) number of times that the
    // 23:59:59.999 - 00:00:00.000 boundary was crossed while performing the
    // operation.  Attempting to construct a &#39;Time&#39; with any attribute outside
    // its valid range (or with an hour attribute value of 24, and any other
    // attribute non-zero) will result in undefined behavior.

    // DATA
    int d_milliseconds;  // offset from 00:00:00.000; 86,400 is the default

    // FRIENDS
    friend DatetimeInterval operator-(const Time&amp;, const Time&amp;);
    friend bool operator==(const Time&amp;, const Time&amp;);
    friend bool operator!=(const Time&amp;, const Time&amp;);
    friend bool operator&lt; (const Time&amp;, const Time&amp;);
    friend bool operator&lt;=(const Time&amp;, const Time&amp;);
    friend bool operator&gt;=(const Time&amp;, const Time&amp;);
    friend bool operator&gt; (const Time&amp;, const Time&amp;);

  public:
    // CLASS METHODS
    static bool isValid(int hour,
                        int minute      = 0,
                        int second      = 0,
                        int millisecond = 0);
        // Return &#39;true&#39; if the specified &#39;hour&#39;, and the optionally specified
        // &#39;minute&#39;, &#39;second&#39;, and &#39;millisecond&#39;, represent a valid &#39;Time&#39;
        // value, and &#39;false&#39; otherwise.  Unspecified arguments default to 0.
        // The &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;, and &#39;millisecond&#39; attributes
        // comprise a valid &#39;Time&#39; value if &#39;0 &lt;= hour &lt; 24&#39;,
        // &#39;0 &lt;= minute &lt; 60&#39;, &#39;0 &lt;= second &lt; 60&#39;, and
        // &#39;0 &lt;= millisecond &lt; 1000&#39;.  Additionally, 24:00:00.000 also
        // represents a valid &#39;Time&#39; value.

                                  // Aspects

    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    // CREATORS
    Time();
        // Create a &#39;Time&#39; object having the value 24:00:00.000.

    explicit
    Time(int hour, int minute = 0, int second = 0, int millisecond = 0);
        // Create a &#39;Time&#39; object having the (valid) value represented by the
        // specified &#39;hour&#39;, and the optionally specified &#39;minute&#39;, &#39;second&#39;,
        // and &#39;millisecond&#39;.  Unspecified arguments default to 0.  The
        // behavior is undefined unless all of the specified values are within
        // their valid ranges (see &#39;isValid&#39;).

    Time(const Time&amp; original);
        // Create a &#39;Time&#39; object having the value of the specified &#39;original&#39;
        // time.

    ~Time();
        // Destroy this time object.

    // MANIPULATORS
    Time&amp; operator=(const Time&amp; rhs);
        // Assign to this time object the value of the specified &#39;rhs&#39; object,
        // and return a reference providing modifiable access to this object.

    Time&amp; operator+=(const DatetimeInterval&amp; rhs);
        // Add to this time object the value of the specified &#39;rhs&#39; datetime
        // interval, and return a reference providing modifiable access to this
        // object.

    Time&amp; operator-=(const DatetimeInterval&amp; rhs);
        // Subtract from this time object the value of the specified &#39;rhs&#39;
        // datetime interval, and return a reference providing modifiable
        // access to this object.

    int addHours(int hours);
        // Increase the value of this time object by the specified number of
        // &#39;hours&#39;, and return the (signed) number of times that the
        // 23:59:59.999 - 00:00:00.000 boundary was crossed in performing the
        // operation.  Note that &#39;hours&#39; may be negative.

    int addMinutes(int minutes);
        // Increase the value of this time object by the specified number of
        // &#39;minutes&#39;, and return the (signed) number of times that the
        // 23:59:59.999 - 00:00:00.000 boundary was crossed in performing the
        // operation.  Note that &#39;minutes&#39; may be negative.

    int addSeconds(int seconds);
        // Increase the value of this time object by the specified number of
        // &#39;seconds&#39;, and return the (signed) number of times that the
        // 23:59:59.999 - 00:00:00.000 boundary was crossed in performing the
        // operation.  Note that &#39;seconds&#39; may be negative.

    int addMilliseconds(int milliseconds);
        // Increase the value of this time object by the specified number of
        // &#39;milliseconds&#39;, and return the (signed) number of times that the
        // 23:59:59.999 - 00:00:00.000 boundary was crossed in performing the
        // operation.  Note that &#39;milliseconds&#39; may be negative.

    int addInterval(const DatetimeInterval&amp; interval);
        // Increase the value of this time object by the specified &#39;interval&#39;
        // of time, and return the (signed) number of times that the
        // 23:59:59.999 - 00:00:00.000 boundary was crossed in performing the
        // operation.  The behavior is undefined unless the number of crossings
        // that would be returned can be represented by an &#39;int&#39;.

    int addTime(int hours,
                int minutes      = 0,
                int seconds      = 0,
                int milliseconds = 0);
        // Add to the value of this time object the specified (signed) number
        // of &#39;hours&#39; and optionally specified (signed) numbers of &#39;minutes&#39;,
        // &#39;seconds&#39;, and &#39;milliseconds&#39;; return the (signed) number of times
        // that the 23:59:59.999 - 00:00:00.000 boundary was crossed in
        // performing the operation.  Unspecified arguments default to 0.

    void setHour(int hour);
        // Set the &#39;hour&#39; attribute of this time object to the specified
        // &#39;hour&#39;; if &#39;hour&#39; is 24, set the remaining attributes of this object
        // to 0.  The behavior is undefined unless &#39;0 &lt;= hour &lt;= 24&#39;.

    void setMinute(int minute);
        // Set the &#39;minute&#39; attribute of this time object to the specified
        // &#39;minute&#39;; if the &#39;hour&#39; attribute is 24, set the &#39;hour&#39; attribute to
        // 0.  The behavior is undefined unless &#39;0 &lt;= minute &lt; 60&#39;.

    void setSecond(int second);
        // Set the &#39;second&#39; attribute of this time object to the specified
        // &#39;second&#39;; if the &#39;hour&#39; attribute is 24, set the &#39;hour&#39; attribute to
        // 0.  The behavior is undefined unless &#39;0 &lt;= second &lt; 60&#39;.

    void setMillisecond(int millisecond);
        // Set the &#39;millisecond&#39; attribute of this time object to the specified
        // &#39;millisecond&#39;; if the &#39;hour&#39; attribute is 24, set the &#39;hour&#39;
        // attribute to 0.  The behavior is undefined unless
        // &#39;0 &lt;= millisecond &lt; 1000&#39;.

    void setTime(int hour,
                 int minute      = 0,
                 int second      = 0,
                 int millisecond = 0);
        // Set the value of this time object to the specified &#39;hour&#39;, and the
        // optionally specified &#39;minute&#39;, &#39;second&#39;, and &#39;millisecond&#39;.
        // Unspecified arguments default to 0.  The behavior is undefined
        // unless all of the specified value are within their valid ranges (see
        // &#39;isValid&#39;).

    int setTimeIfValid(int hour,
                       int minute      = 0,
                       int second      = 0,
                       int millisecond = 0);
        // Set the value of this time object to the specified &#39;hour&#39;, and the
        // optionally specified &#39;minute&#39;, &#39;second&#39;, and &#39;millisecond&#39;, if they
        // would comprise a valid &#39;Time&#39; value (see &#39;isValid&#39;).  Return 0 on
        // success, and a non-zero value (with no effect) otherwise.
        // Unspecified arguments default to 0.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    void getTime(int *hour,
                 int *minute = 0,
                 int *second = 0,
                 int *millisecond = 0) const;
        // Load, into the specified &#39;hour&#39;, and the optionally specified
        // &#39;minute&#39;, &#39;second&#39; and &#39;millisecond&#39;, the respective &#39;hour&#39;,
        // &#39;minute&#39;, &#39;second&#39;, and &#39;millisecond&#39; attribute values from this
        // time object.  Unspecified arguments default to 0.  Supplying 0 for
        // an address argument suppresses the loading of the value for the
        // corresponding attribute, but has no effect on the loading of other
        // attribute values.

    int hour() const;
        // Return the value of the &#39;hour&#39; attribute of this time object.

    int minute() const;
        // Return the value of the &#39;minute&#39; attribute of this time object.

    int second() const;
        // Return the value of the &#39;second&#39; attribute of this time object.

    int millisecond() const;
        // Return the value of the &#39;millisecond&#39; attribute of this time object.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Write the value of this object to the specified output &#39;stream&#39; in a
        // human-readable format, and return a reference to &#39;stream&#39;.
        // Optionally specify an initial indentation &#39;level&#39;, whose absolute
        // value is incremented recursively for nested objects.  If &#39;level&#39; is
        // specified, optionally specify &#39;spacesPerLevel&#39;, whose absolute value
        // indicates the number of spaces per indentation level for this and
        // all of its nested objects.  If &#39;level&#39; is negative, suppress
        // indentation of the first line.  If &#39;spacesPerLevel&#39; is negative,
        // format the entire output on one line, suppressing all but the
        // initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is not
        // valid on entry, this operation has no effect.  Note that this
        // human-readable format is not fully specified, and can change without
        // notice.


};

// FREE OPERATORS
Time operator+(const Time&amp; lhs, const DatetimeInterval&amp; rhs);
    // Return a &#39;Time&#39; value that is the sum of the specified &#39;lhs&#39; time and
    // the specified &#39;rhs&#39; datetime interval.

Time operator+(const DatetimeInterval&amp; lhs, const Time&amp; rhs);
    // Return a &#39;Time&#39; value that is the sum of the specified &#39;lhs&#39; datetime
    // interval and the specified &#39;rhs&#39; time.

Time operator-(const Time&amp; lhs, const DatetimeInterval&amp; rhs);
    // Return a &#39;Time&#39; value that is the difference between the specified &#39;lhs&#39;
    // time and the specified &#39;rhs&#39; datetime interval.

DatetimeInterval operator-(const Time&amp; lhs, const Time&amp; rhs);
    // Return a &#39;DatetimeInterval&#39; object initialized with the difference
    // between the specified &#39;lhs&#39; and &#39;rhs&#39; time values.

bool operator==(const Time&amp; lhs, const Time&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; time objects have the
    // same value, and &#39;false&#39; otherwise.  Two time objects have the same value
    // if each of their corresponding &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;, and
    // &#39;millisecond&#39; attributes respectively have the same value.

bool operator!=(const Time&amp; lhs, const Time&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; time objects do not have
    // the same value, and &#39;false&#39; otherwise.  Two time objects do not have the
    // same value if any of their corresponding &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;, and
    // &#39;millisecond&#39; attributes respectively do not have the same value.

bool operator&lt;(const Time&amp; lhs, const Time&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; time value is less than the
    // specified &#39;rhs&#39; time value, and &#39;false&#39; otherwise.  The behavior is
    // undefined unless &#39;lhs != Time()&#39; and &#39;rhs != Time()&#39; (i.e., they do not
    // have the, default, value 24:00:00.000).

bool operator&lt;=(const Time&amp; lhs, const Time&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; time value is less than or equal to
    // the specified &#39;rhs&#39; time value, and &#39;false&#39; otherwise.  The behavior is
    // undefined unless &#39;lhs != Time()&#39; and &#39;rhs != Time()&#39; (i.e., they do not
    // have the, default, value 24:00:00.000).

bool operator&gt;(const Time&amp; lhs, const Time&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; time value is greater than the
    // specified &#39;rhs&#39; time value, and &#39;false&#39; otherwise.  The behavior is
    // undefined unless &#39;lhs != Time()&#39; and &#39;rhs != Time()&#39; (i.e., they do not
    // have the, default, value 24:00:00.000).

bool operator&gt;=(const Time&amp; lhs, const Time&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; time value is greater than or equal
    // to the specified &#39;rhs&#39; time value, and &#39;false&#39; otherwise.  The behavior
    // is undefined unless &#39;lhs != Time()&#39; and &#39;rhs != Time()&#39; (i.e., they do
    // not have the, default, value 24:00:00.000).

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Time&amp; time);
    // Write the value of the specified &#39;time&#39; object to the specified output
    // &#39;stream&#39; in a single-line format, and return a reference to &#39;stream&#39;.
    // If &#39;stream&#39; is not valid on entry, this operation has no effect.  Note
    // that this human-readable format is not fully specified, can change
    // without notice, and is logically equivalent to:
    //..
    //  print(stream, 0, -1);
    //..

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                                 // ----------
                                 // class Time
                                 // ----------

// CLASS METHODS
inline
bool Time::isValid(int hour, int minute, int second, int millisecond)
{
    return (0 &lt;= hour        &amp;&amp; hour     &lt; bdlt::TimeUnitRatio::k_H_PER_D_32 &amp;&amp;
            0 &lt;= minute      &amp;&amp; minute   &lt; bdlt::TimeUnitRatio::k_M_PER_H_32 &amp;&amp;
            0 &lt;= second      &amp;&amp; second   &lt; bdlt::TimeUnitRatio::k_S_PER_M_32 &amp;&amp;
            0 &lt;= millisecond &amp;&amp; millisecond
                                         &lt; bdlt::TimeUnitRatio::k_MS_PER_S_32)
        || (bdlt::TimeUnitRatio::k_H_PER_D_32 == hour &amp;&amp;
            0                                 == minute &amp;&amp;
            0                                 == second &amp;&amp;
            0                                 == millisecond);
}

                                  // Aspects

inline
int Time::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// CREATORS
inline
Time::Time()
: d_milliseconds(bdlt::TimeUnitRatio::k_MS_PER_D_32)
{
}

inline
Time::Time(int hour, int minute, int second, int millisecond)
{
    BSLS_ASSERT_SAFE(isValid(hour, minute, second, millisecond));

    d_milliseconds = millisecond
                   + second * bdlt::TimeUnitRatio::k_MS_PER_S_32
                   + minute * bdlt::TimeUnitRatio::k_MS_PER_M_32
                   + hour * bdlt::TimeUnitRatio::k_MS_PER_H_32;
}

inline
Time::Time(const Time&amp; original)
: d_milliseconds(original.d_milliseconds)
{
}

inline
Time::~Time()
{
    BSLS_ASSERT_SAFE(0 &lt;= d_milliseconds);
    BSLS_ASSERT_SAFE(     d_milliseconds
                                        &lt;= bdlt::TimeUnitRatio::k_MS_PER_D_32);
}

// MANIPULATORS
inline
Time&amp; Time::operator=(const Time&amp; rhs)
{
    d_milliseconds = rhs.d_milliseconds;
    return *this;
}

inline
Time&amp; Time::operator+=(const DatetimeInterval&amp; rhs)
{
    addMilliseconds(static_cast&lt;int&gt;(rhs.totalMilliseconds()
                                     % bdlt::TimeUnitRatio::k_MS_PER_D));
    return *this;
}

inline
Time&amp; Time::operator-=(const DatetimeInterval&amp; rhs)
{
    addMilliseconds(static_cast&lt;int&gt;(-rhs.totalMilliseconds()
                                     % bdlt::TimeUnitRatio::k_MS_PER_D));
    return *this;
}

inline
int Time::setTimeIfValid(int hour,
                         int minute,
                         int second,
                         int millisecond)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    if (isValid(hour, minute, second, millisecond)) {
        setTime(hour, minute, second, millisecond);
        return k_SUCCESS;                                             // RETURN
    }

    return k_FAILURE;
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; Time::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            int tmp;
            stream.getInt32(tmp);

            if (   stream
                &amp;&amp; static_cast&lt;unsigned int&gt;(tmp) &lt;=
                   static_cast&lt;unsigned int&gt;(
                                         bdlt::TimeUnitRatio::k_MS_PER_D_32)) {
                d_milliseconds = tmp;
            }
            else {
                stream.invalidate();
            }
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }
    return stream;
}

// ACCESSORS
inline
int Time::hour() const
{
    return d_milliseconds / bdlt::TimeUnitRatio::k_MS_PER_H_32;
}

inline
int Time::minute() const
{
    return (d_milliseconds % bdlt::TimeUnitRatio::k_MS_PER_H_32)
                           / bdlt::TimeUnitRatio::k_MS_PER_M_32;
}

inline
int Time::second() const
{
    return (d_milliseconds % bdlt::TimeUnitRatio::k_MS_PER_M_32)
                           / bdlt::TimeUnitRatio::k_MS_PER_S_32;
}

inline
int Time::millisecond() const
{
    return d_milliseconds % bdlt::TimeUnitRatio::k_MS_PER_S_32;
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; Time::bdexStreamOut(STREAM&amp; stream, int version) const
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            stream.putInt32(d_milliseconds);
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }
    return stream;
}


}  // close package namespace

// FREE OPERATORS
inline
bdlt::Time bdlt::operator+(const Time&amp; lhs, const DatetimeInterval&amp; rhs)
{
    Time result(lhs);
    return result += rhs;
}

inline
bdlt::Time bdlt::operator+(const DatetimeInterval&amp; lhs, const Time&amp; rhs)
{
    Time result(rhs);
    return result += lhs;
}

inline
bdlt::Time bdlt::operator-(const Time&amp; lhs, const DatetimeInterval&amp; rhs)
{
    Time result(lhs);
    return result -= rhs;
}

inline
bdlt::DatetimeInterval bdlt::operator-(const Time&amp; lhs, const Time&amp; rhs)
{
    DatetimeInterval timeInterval;
    timeInterval.setTotalMilliseconds(
                      lhs.d_milliseconds % bdlt::TimeUnitRatio::k_MS_PER_D_32
                    - rhs.d_milliseconds % bdlt::TimeUnitRatio::k_MS_PER_D_32);
    return timeInterval;
}

inline
bool bdlt::operator==(const Time&amp; lhs, const Time&amp; rhs)
{
    return lhs.d_milliseconds == rhs.d_milliseconds;
}

inline
bool bdlt::operator!=(const Time&amp; lhs, const Time&amp; rhs)
{
    return lhs.d_milliseconds != rhs.d_milliseconds;
}

inline
bool bdlt::operator&lt;(const Time&amp; lhs, const Time&amp; rhs)
{
    BSLS_ASSERT_SAFE(bdlt::TimeUnitRatio::k_MS_PER_D_32 != lhs.d_milliseconds);
    BSLS_ASSERT_SAFE(bdlt::TimeUnitRatio::k_MS_PER_D_32 != rhs.d_milliseconds);

    return lhs.d_milliseconds &lt; rhs.d_milliseconds;
}

inline
bool bdlt::operator&lt;=(const Time&amp; lhs, const Time&amp; rhs)
{
    BSLS_ASSERT_SAFE(bdlt::TimeUnitRatio::k_MS_PER_D_32 != lhs.d_milliseconds);
    BSLS_ASSERT_SAFE(bdlt::TimeUnitRatio::k_MS_PER_D_32 != rhs.d_milliseconds);

    return lhs.d_milliseconds &lt;= rhs.d_milliseconds;
}

inline
bool bdlt::operator&gt;(const Time&amp; lhs, const Time&amp; rhs)
{
    BSLS_ASSERT_SAFE(bdlt::TimeUnitRatio::k_MS_PER_D_32 != lhs.d_milliseconds);
    BSLS_ASSERT_SAFE(bdlt::TimeUnitRatio::k_MS_PER_D_32 != rhs.d_milliseconds);

    return lhs.d_milliseconds &gt; rhs.d_milliseconds;
}

inline
bool bdlt::operator&gt;=(const Time&amp; lhs, const Time&amp; rhs)
{
    BSLS_ASSERT_SAFE(bdlt::TimeUnitRatio::k_MS_PER_D_32 != lhs.d_milliseconds);
    BSLS_ASSERT_SAFE(bdlt::TimeUnitRatio::k_MS_PER_D_32 != rhs.d_milliseconds);

    return lhs.d_milliseconds &gt;= rhs.d_milliseconds;
}

inline
bsl::ostream&amp; bdlt::operator&lt;&lt;(bsl::ostream&amp; stream, const Time&amp; time)
{
    return time.print(stream, 0, -1);
}

}  // close enterprise namespace

namespace bsl {

// TRAITS
template &lt;&gt;
struct is_trivially_copyable&lt;BloombergLP::bdlt::Time&gt; : bsl::true_type {
    // This template specialization for &#39;is_trivially_copyable&#39; indicates that
    // &#39;bdlt::Time&#39; is a trivially copyable type.
};

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
