<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bdlma::BufferedSequentialPool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlma.html">bdlma</a>      </li>
      <li><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlma::BufferedSequentialPool Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlma::BufferedSequentialPool" -->
<p><code>#include &lt;<a class="el" href="bdlma__bufferedsequentialpool_8h_source.html">bdlma_bufferedsequentialpool.h</a>&gt;</code></p>

<p><a href="classbdlma_1_1BufferedSequentialPool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a0ed630bf04f9f284a5a88cee44d17c48">BufferedSequentialPool</a> (char *buffer, int size, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#aa868a1f5844c1ac1033dbe092a85215f">BufferedSequentialPool</a> (char *buffer, int size, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a68da7ed5f0b8622f3404fa2bd5280396">BufferedSequentialPool</a> (char *buffer, int size, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a724ff1ad15c6550158a82e4e4b280c6d">BufferedSequentialPool</a> (char *buffer, int size, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a89fd98906b3f4b5a390b2ada9353150e">BufferedSequentialPool</a> (char *buffer, int size, int maxBufferSize, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a39d19e62dbd0fc2130a877f12b749c37">BufferedSequentialPool</a> (char *buffer, int size, int maxBufferSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a1b3cce882680ae924204434c36a00ab7">BufferedSequentialPool</a> (char *buffer, int size, int maxBufferSize, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a54f1b62a5836c461ea956905a117023d">BufferedSequentialPool</a> (char *buffer, int size, int maxBufferSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a09dc89905dd6e3c7396410cedda86b8f">~BufferedSequentialPool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a307704615a90c04c6bc1dc411e3bdec2">allocate</a> (<a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> size)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#ad7ae567a6d557df026ad510931f96551">deleteObjectRaw</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a6cadddce13b6211b1c82f60b6488579b">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialPool.html#a8fa58ba6532daa3a687b55a537a120ef">release</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a fast memory pool that efficiently dispenses heterogeneous blocks of memory (of varying, user-specified sizes) from an external buffer whose address and size (in bytes) are supplied at construction. If an allocation request exceeds the remaining free memory space in the external buffer, memory will be supplied by an (optional) allocator supplied also at construction; if no allocator is supplied, the currently installed default allocator will be used. This class is <em>exception</em> <em>neutral</em>: If memory cannot be allocated, the behavior is defined by the (optional) allocator supplied at construction. Note that in no case will the buffered sequential pool attempt to deallocate the external buffer. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0ed630bf04f9f284a5a88cee44d17c48"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::BufferedSequentialPool" ref="a0ed630bf04f9f284a5a88cee44d17c48" args="(char *buffer, int size, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa868a1f5844c1ac1033dbe092a85215f"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::BufferedSequentialPool" ref="aa868a1f5844c1ac1033dbe092a85215f" args="(char *buffer, int size, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68da7ed5f0b8622f3404fa2bd5280396"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::BufferedSequentialPool" ref="a68da7ed5f0b8622f3404fa2bd5280396" args="(char *buffer, int size, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a724ff1ad15c6550158a82e4e4b280c6d"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::BufferedSequentialPool" ref="a724ff1ad15c6550158a82e4e4b280c6d" args="(char *buffer, int size, bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a buffered sequential pool for allocating memory blocks from the specified external <code>buffer</code> having the specified <code>size</code> (in bytes), or from an internal buffer (after the external <code>buffer</code> is exhausted). Optionally specify a <code>growthStrategy</code> used to control buffer growth. If a <code>growthStrategy</code> is not specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to align allocated memory blocks. If an <code>alignmentStrategy</code> is not specified, natural alignment is used. Optionally specify a <code>basicAllocator</code> used to supply memory should the capacity of <code>buffer</code> be exhausted. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt; size</code>, and <code>buffer</code> has at least <code>size</code> bytes. Note that, due to alignment effects, it is possible that not all <code>size</code> bytes of memory in <code>buffer</code> can be used for allocation. Also note that no limit is imposed on the size of the internal buffers when geometric growth is used. Also note that when constant growth is used, the size of the internal buffers will always be the same as <code>size</code>. </p>

</div>
</div>
<a class="anchor" id="a89fd98906b3f4b5a390b2ada9353150e"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::BufferedSequentialPool" ref="a89fd98906b3f4b5a390b2ada9353150e" args="(char *buffer, int size, int maxBufferSize, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a39d19e62dbd0fc2130a877f12b749c37"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::BufferedSequentialPool" ref="a39d19e62dbd0fc2130a877f12b749c37" args="(char *buffer, int size, int maxBufferSize, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b3cce882680ae924204434c36a00ab7"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::BufferedSequentialPool" ref="a1b3cce882680ae924204434c36a00ab7" args="(char *buffer, int size, int maxBufferSize, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a54f1b62a5836c461ea956905a117023d"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::BufferedSequentialPool" ref="a54f1b62a5836c461ea956905a117023d" args="(char *buffer, int size, int maxBufferSize, bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a buffered sequential pool for allocating memory blocks from the specified external <code>buffer</code> having the specified <code>size</code> (in bytes), or from an internal buffer (after the external <code>buffer</code> is exhausted) where the buffer growth is limited to the specified <code>maxBufferSize</code> (in bytes). Optionally specify a <code>growthStrategy</code> used to control buffer growth. If a <code>growthStrategy</code> is not specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to align allocated memory blocks. If an <code>alignmentStrategy</code> is not specified, natural alignment is used. Optionally specify a <code>basicAllocator</code> used to supply memory should the capacity of <code>buffer</code> be exhausted. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt; size</code>, <code>size &lt;= maxBufferSize</code>, and <code>buffer</code> has at least <code>size</code> bytes. Note that, due to alignment effects, it is possible that not all <code>size</code> bytes of memory in <code>buffer</code> can be used for allocation. Also note that when constant growth is used, the size of the internal buffers will always be the same as <code>size</code>. </p>

</div>
</div>
<a class="anchor" id="a09dc89905dd6e3c7396410cedda86b8f"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::~BufferedSequentialPool" ref="a09dc89905dd6e3c7396410cedda86b8f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialPool::~BufferedSequentialPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this buffered sequential pool. All memory allocated from this pool is released. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a307704615a90c04c6bc1dc411e3bdec2"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::allocate" ref="a307704615a90c04c6bc1dc411e3bdec2" args="(bsls::Types::size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::BufferedSequentialPool::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of memory of the specified <code>size</code> (in bytes) according to the alignment strategy specified at construction. If the allocation request exceeds the remaining free memory space in the external buffer supplied at construction, use memory obtained from the allocator supplied at construction. The behavior is undefined unless <code>0 &lt; size</code>. </p>

</div>
</div>
<a class="anchor" id="ad7ae567a6d557df026ad510931f96551"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::deleteObjectRaw" ref="ad7ae567a6d557df026ad510931f96551" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::BufferedSequentialPool::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code>. Note that memory associated with <code>object</code> is not deallocated because there is no <code>deallocate</code> method in <code><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">BufferedSequentialPool</a></code>. </p>

</div>
</div>
<a class="anchor" id="a6cadddce13b6211b1c82f60b6488579b"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::deleteObject" ref="a6cadddce13b6211b1c82f60b6488579b" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::BufferedSequentialPool::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code>. Note that this method has the same effect as the <code>deleteObjectRaw</code> method (since no deallocation is involved), and exists for consistency across memory pools. </p>

</div>
</div>
<a class="anchor" id="a8fa58ba6532daa3a687b55a537a120ef"></a><!-- doxytag: member="bdlma::BufferedSequentialPool::release" ref="a8fa58ba6532daa3a687b55a537a120ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::BufferedSequentialPool::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release all memory currently allocated through this pool. This method deallocates all memory (if any) allocated with the allocator provided at construction, and makes the memory from the entire external buffer supplied at construction available for subsequent allocations, but has no effect on the contents of the buffer. Note that this pool is reset to its initial state by this method. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlma__bufferedsequentialpool_8h_source.html">bdlma_bufferedsequentialpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:26 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
