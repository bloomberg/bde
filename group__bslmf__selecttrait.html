<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmf_selecttrait Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Component bslmf_selecttrait<br/>
<small>
[<a class="el" href="group__bslmf.html">Package bslmf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide clean compile-time dispatch based on multiple traits.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
</table>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Dispatch On Traits</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide clean compile-time dispatch based on multiple traits </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>bslmf::SelectTrait Template that selects the first of multiple traits bslmf::SelectTraitCase Template that identifies a selected trait </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates the intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_dispatch_on_traits"></a> <a class="anchor" id="usage.example_1~3A_dispatch_on_traits"></a> <a class="anchor" id="description.usage.example_1~3A_dispatch_on_traits"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Dispatch On Traits: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We would like to create a function template, <code>ScalarPrimitives::copyConstruct</code>, that takes an original object and an allocator constructs a copy of <code>original</code> using the most efficient valid mechanism. The function should take into account that the original type might be bitwise copyable, or have an allocator that can be different in the copy than in the original object, or that the original might be a pair type, where the correct method of copying <code>first</code> and <code>second</code> is (recursively) governed by the same concerns. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The old (legacy) <code>bsls::HasTrait</code> mechanism has a clumsy mechanism for dispatching on multiple traits at once. For example, the <code>bslalg::scalarprimitives::copyConstruct</code>, function uses four different implementations, depending on the traits of the object being copied. The existing code looks like this: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TARGET_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span>
  ScalarPrimitives::copyConstruct(TARGET_TYPE        *address,
                                  <span class="keyword">const</span> TARGET_TYPE&amp;  original,
                                  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(address);

      <span class="keyword">enum</span> {
          VALUE = HasTrait&lt;TARGET_TYPE,
                                  TypeTraitUsesBslmaAllocator
                                 &gt;::VALUE ? Imp::USES_BSLMA_ALLOCATOR_TRAITS
                : HasTrait&lt;TARGET_TYPE,
                                  TypeTraitBitwiseCopyable
                                 &gt;::VALUE ? Imp::BITWISE_COPYABLE_TRAITS
                : HasTrait&lt;TARGET_TYPE,
                                  TypeTraitPair
                                 &gt;::VALUE ? Imp::PAIR_TRAITS
                : Imp::NIL_TRAITS
      };
      Imp::copyConstruct(address, original, allocator,
                         (<a class="code" href="structbsl_1_1integral__constant.html">bsl::integral_constant&lt;int, VALUE&gt;</a>*)0);
  }
</pre></div><br/>
<br/>
 We would like to replace the cumbersome chain of <code>?:</code> operations with a clean mechanism for producing one of four different types based on the first matching trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create three traits metafunctions to replace the three legacy traits used above: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt; <span class="keyword">struct </span>UsesBslmaAllocator : bsl::<a class="code" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a> { };
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt; <span class="keyword">struct </span>IsBitwiseCopyable : bsl::<a class="code" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a> { };
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt; <span class="keyword">struct </span>IsPair : bsl::<a class="code" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a> { };
</pre></div><br/>
<br/>
 Note that these definitions are simplified to avoid excess dependencies; A proper traits definition would inherit from <code><a class="el" href="structbslmf_1_1DetectNestedTrait.html">bslmf::DetectNestedTrait</a></code> instead of from <code><a class="el" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">bsl::false_type</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we forward-declare <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and <code>bslalg::scalarprimitives::copyConstruct</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">namespace </span>bslma { <span class="keyword">class </span>Allocator; }

  <span class="keyword">namespace </span>bslalg {
  <span class="keyword">struct </span>ScalarPrimitives {
      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">copyConstruct</a>(TARGET_TYPE        *address,
                                <span class="keyword">const</span> TARGET_TYPE&amp;  original,
                                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator);
  };
</pre></div><br/>
<br/>
 Next, we implement three overloads of <code>Imp::copyConstruct</code>, each taking a different trait specialization. A fourth overload takes <code>false_type</code> instead of a trait specialization, for those types that don't match any traits. For testing purposes, in addition to copying the data member, each overload also increments a separate counter. These implementations are slightly simplified for readability: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Imp {

      <span class="comment">// Counters for counting overload calls</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> s_noTraitsCounter;
      <span class="keyword">static</span> <span class="keywordtype">int</span> s_usesBslmaAllocatorCounter;
      <span class="keyword">static</span> <span class="keywordtype">int</span> s_isPairCounter;
      <span class="keyword">static</span> <span class="keywordtype">int</span> s_isBitwiseCopyableCounter;

      <span class="keyword">static</span> <span class="keywordtype">void</span> clearCounters() {
          s_noTraitsCounter = 0;
          s_usesBslmaAllocatorCounter = 0;
          s_isPairCounter = 0;
          s_isBitwiseCopyableCounter = 0;
      }

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      copyConstruct(TARGET_TYPE                                 *address,
                    <span class="keyword">const</span> TARGET_TYPE&amp;                           original,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                            *allocator,
                    bslmf::SelectTraitCase&lt;UsesBslmaAllocator&gt;)
      {
          <span class="keyword">new</span> (address) TARGET_TYPE(original, allocator);
          ++s_usesBslmaAllocatorCounter;
      }

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      copyConstruct(TARGET_TYPE                 *address,
                    <span class="keyword">const</span> TARGET_TYPE&amp;           original,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>            *allocator,
                    bslmf::SelectTraitCase&lt;IsPair&gt;)
      {
          ScalarPrimitives::copyConstruct(&amp;address-&gt;first, original.first,
                                          allocator);
          ScalarPrimitives::copyConstruct(&amp;address-&gt;second, original.second,
                                          allocator);
          ++s_isPairCounter;
      }

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      copyConstruct(TARGET_TYPE                             *address,
                    <span class="keyword">const</span> TARGET_TYPE&amp;                       original,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                        *,
                    bslmf::SelectTraitCase&lt;IsBitwiseCopyable&gt;)
      {
          memcpy(address, &amp;original, <span class="keyword">sizeof</span>(original));
          ++s_isBitwiseCopyableCounter;
      }

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TARGET_TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      copyConstruct(TARGET_TYPE                *address,
                    <span class="keyword">const</span> TARGET_TYPE&amp;          original,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>           *,
                    bslmf::SelectTraitCase&lt;&gt;)
      {
          <span class="keyword">new</span> (address) TARGET_TYPE(original);
          ++s_noTraitsCounter;
      }
  };

  <span class="keywordtype">int</span> Imp::s_noTraitsCounter = 0;
  <span class="keywordtype">int</span> Imp::s_usesBslmaAllocatorCounter = 0;
  <span class="keywordtype">int</span> Imp::s_isPairCounter = 0;
  <span class="keywordtype">int</span> Imp::s_isBitwiseCopyableCounter = 0;
</pre></div><br/>
<br/>
 Then, we implement <code>ScalarPrimitives::copyConstruct</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TARGET_TYPE&gt;
  <span class="keyword">inline</span> <span class="keywordtype">void</span>
  ScalarPrimitives::copyConstruct(TARGET_TYPE        *address,
                                  <span class="keyword">const</span> TARGET_TYPE&amp;  original,
                                  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator)
  {
</pre></div><br/>
<br/>
 We use <code>bslmf::SelectTrait</code> to declare <code>Selection</code> as a specialization of the first match of the specified traits: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">typedef</span> <span class="keyword">typename</span> bslmf::SelectTrait&lt;TARGET_TYPE,
                                          UsesBslmaAllocator,
                                          IsBitwiseCopyable,
                                          IsPair&gt;<a class="code" href="classBind__ImplSelector_1_1Type.html">::Type</a> Selection;
</pre></div><br/>
<br/>
 Now, we use <code>Selection</code> to choose (at compile time), one of the <code>Imp::copyConstruct</code> overloads defined above: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::copyConstruct(address, original, allocator, Selection());
  } <span class="comment">// end copyConstruct()</span>

  } <span class="comment">// Close namespace bslalg</span>
</pre></div><br/>
<br/>
 Finally, we define three classes, associated with each of the three traits of interest, a fourth class associated with more than one trait (to show that the selection mechanism respects preference) and a fifth class that is not associated with any trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The first class is associated with the <code>UsesBslmaAllocator</code> trait: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>TypeWithAllocator {
      <span class="keywordtype">int</span>               d_value;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_alloc;
  <span class="keyword">public</span>:
      TypeWithAllocator(<span class="keywordtype">int</span> v = 0, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *a = 0)       <span class="comment">// IMPLICIT</span>
          : d_value(v), d_alloc(a) { }
      TypeWithAllocator(<span class="keyword">const</span> TypeWithAllocator&amp; other,
                        <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *a = 0)
          : d_value(other.d_value), d_alloc(a) {  }

      <span class="keywordtype">int</span> value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_alloc; }
  };

  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>UsesBslmaAllocator&lt;TypeWithAllocator&gt;
      : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
</pre></div><br/>
<br/>
 The second class is associated with the <code>IsBitwiseCopyable</code> trait: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>BitwiseCopyableType {
      <span class="keywordtype">int</span> d_value;
  <span class="keyword">public</span>:
      BitwiseCopyableType(<span class="keywordtype">int</span> v = 0) : d_value(v) { }             <span class="comment">// IMPLICIT</span>
      <span class="keywordtype">int</span> value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
  };

  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsBitwiseCopyable&lt;BitwiseCopyableType&gt;
      : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
</pre></div><br/>
<br/>
 The third class is associated with the <code>IsPair</code> trait: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>PairType {
      TypeWithAllocator   first;
      BitwiseCopyableType second;

      PairType(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) : first(a), second(b) { }
  };

  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsPair&lt;PairType&gt; : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
</pre></div><br/>
<br/>
 The fourth class is associated with both the the <code>IsPair</code> and <code>IsBitwiseCopyable</code> traits: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>BitwiseCopyablePairType {
      BitwiseCopyableType first;
      BitwiseCopyableType second;

      BitwiseCopyablePairType(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) : first(a), second(b) { }
  };

  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsPair&lt;BitwiseCopyablePairType&gt; : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>IsBitwiseCopyable&lt;BitwiseCopyablePairType&gt;
      : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> { };
</pre></div><br/>
<br/>
 The fifth class is not associated with any explicit traits: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>TypeWithNoTraits {
      <span class="keywordtype">int</span> d_value;
  <span class="keyword">public</span>:
      TypeWithNoTraits(<span class="keywordtype">int</span> v = 0) : d_value(v) { }                <span class="comment">// IMPLICIT</span>
      <span class="keywordtype">int</span> value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
  };
</pre></div><br/>
<br/>
 We use these classes to instantiate <code>ScalarPrimitives::copyConstruct</code> and verify that the most efficient copy operation that is valid for each type is applied: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample1()
  {
      <span class="keyword">using</span> bslalg::Imp;

      <span class="comment">// This buffer is properly aligned and big enough to hold any of the</span>
      <span class="comment">// test types.</span>
      <span class="keywordtype">void</span> *buffer[4];
      <span class="keywordtype">char</span> dummy[2];  <span class="comment">// Dummy addresses</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *a1 = (<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*) &amp;dummy[0];
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *a2 = (<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*) &amp;dummy[1];
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>TypeWithAllocator</code>, we expect that the copy will have the same value but a different allocator than the original and that the <code>UsesBslmaAllocator</code> copy implementation will be called once: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      TypeWithAllocator  twa(1, a1);
      TypeWithAllocator *twaptr = (TypeWithAllocator*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(twaptr, twa, a2);
      assert(1 == Imp::s_usesBslmaAllocatorCounter);
      assert(1 == twaptr-&gt;value());
      assert(a2 == twaptr-&gt;allocator());
      twaptr-&gt;~TypeWithAllocator();
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>BitwiseCopyableType</code>, we expect that the <code>IsBitwiseCopyable</code> copy implementation will be called once: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      BitwiseCopyableType  bct(2);
      BitwiseCopyableType *bctptr = (BitwiseCopyableType*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(bctptr, bct, a2);
      assert(1 == Imp::s_isBitwiseCopyableCounter);
      assert(2 == bctptr-&gt;value());
      bctptr-&gt;~BitwiseCopyableType();
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>PairType</code>, we expect that the <code>IsPair</code> copy implementation will be called once for the pair as whole and that the <code>UsesBslmaAllocator</code> and <code>IsBitwiseCopyable</code> implementations will be called for the <code>first</code> and <code>second</code> members, respectively: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      PairType  pt(3, 4);
      PairType *ptptr = (PairType*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(ptptr, pt, a2);
      assert(1 == Imp::s_isPairCounter);
      assert(1 == Imp::s_usesBslmaAllocatorCounter);
      assert(1 == Imp::s_usesBslmaAllocatorCounter);
      assert(3 == ptptr-&gt;first.value());
      assert(a2 == ptptr-&gt;first.allocator());
      assert(4 == ptptr-&gt;second.value());
      ptptr-&gt;~PairType();
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>BitwiseCopyablePairType</code>, the <code>IsBitwiseCopyable</code> trait takes precedence over the <code>IsPair</code> trait (because it appears first in the list of traits used to instantiate <code>SelectTrait</code>). Therefore, we expect to see the <code>IsBitwiseCopyable</code> copy implementation called once for the whole pair and the <code>IsPair</code> copy implementation not called at all: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      BitwiseCopyablePairType  bcpt(5, 6);
      BitwiseCopyablePairType *bcptbcptr = (BitwiseCopyablePairType*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(bcptbcptr, bcpt, a2);
      <span class="comment">// Prefer IsBitwiseCopyable over IsPair trait</span>
      assert(1 == Imp::s_isBitwiseCopyableCounter);
      assert(0 == Imp::s_isPairCounter);
      assert(5 == bcptbcptr-&gt;first.value());
      assert(6 == bcptbcptr-&gt;second.value());
      bcptbcptr-&gt;~BitwiseCopyablePairType();
</pre></div><br/>
<br/>
 When we call <code>ScalarPrimitives::copyConstruct</code> for an object of <code>TypeWithNoTraits</code>, we expect none of the specialized copy implementations to be called, thus defaulting to the <code>false_type</code> copy implementation: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Imp::clearCounters();
      TypeWithNoTraits  twnt(7);
      TypeWithNoTraits *twntptr = (TypeWithNoTraits*) buffer;
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(twntptr, twnt, a2);
      assert(1 == Imp::s_noTraitsCounter);
      assert(7 == twntptr-&gt;value());
      twntptr-&gt;~TypeWithNoTraits();

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Note that using <code>SelectTraits</code> for dispatching using overloading imposes little or no overhead, since the compiler typically generates no code for the constructor or copy constructor of the trait argument to the overloaded functions. When inlining is in effect, the result is very efficient. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:00 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
