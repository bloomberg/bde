<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslstl_mapcomparator.h                                             -*-C++-*-
#ifndef INCLUDED_BSLSTL_MAPCOMPARATOR
#define INCLUDED_BSLSTL_MAPCOMPARATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a comparator for &#39;TreeNode&#39; objects and a lookup key.
//
//@CLASSES:
//   bslstl::MapComparator: comparator for &#39;TreeNode&#39; objects and key objects
//
//@SEE_ALSO: bslstl_map, bslstl_treenode, bslalg_rbtreeutil
//
//@DESCRIPTION: This component provides a functor adapter, &#39;MapComparator&#39;,
// that adapts a parameterized &#39;COMPARATOR&#39; comparing objects of a
// parameterized &#39;KEY&#39; type into a functor comparing a object of &#39;KEY&#39; type
// with objects of &#39;TreeNode&#39; type holding a &#39;bsl::pair&lt;KEY, VALUE&gt;&#39; object.
// Note that this functor was designed to be supplied to functions in
// &#39;bslalg::RbTreeUtil&#39;, primarily for the purpose of implementing a &#39;map&#39;
// container using the utilities defined in &#39;bslalg::RbTreeUtil&#39;.
//
///Usage
///-----
///Example 1: Create a Simple Tree of &#39;TreeNode&#39; Objects
///- - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose that we want to create a tree of &#39;TreeNode&#39; objects arranged
// according to a functor that we supply.
//
// First, we create an array of &#39;bslstl::TreeNode&#39; objects, each holding a pair
// of integers:
//..
//  typedef bsl::allocator&lt;TreeNode&lt;bsl::pair&lt;int, int&gt; &gt; &gt; Alloc;
//
//  bslma::TestAllocator oa;
//  Alloc allocator(&amp;oa);
//
//  enum { NUM_NODES = 5 };
//
//  bslstl::TreeNode&lt;bsl::pair&lt;int, int&gt; &gt;* nodes[NUM_NODES];
//
//  typedef bsl::allocator_traits&lt;Alloc&gt;  AllocTraits;
//
//  for (int i = 0; i &lt; NUM_NODES; ++i) {
//      nodes[i] = AllocTraits::allocate(allocator, 1);
//      AllocTraits::construct(allocator, &amp;nodes[i]-&gt;value(),
//                             i, 2*i);
//  }
//..
// Then, we define a &#39;MapComparator&#39; object, &#39;comparator&#39;, for comparing
// &#39;bslstl::TreeNode&lt;pair&lt;int, int&gt; &gt;&#39; objects with integers.
//..
//  MapComparator&lt;int, int, std::less&lt;int&gt; &gt; comparator;
//..
// Now, we can use the functions in &#39;bslalg::RbTreeUtil&#39; to arrange our tree:
//..
//  bslalg::RbTreeAnchor tree;
//
//  for (int i = 0; i &lt; NUM_NODES; ++i) {
//      int comparisonResult;
//      bslalg::RbTreeNode *insertLocation =
//          bslalg::RbTreeUtil::findUniqueInsertLocation(
//              &amp;comparisonResult,
//              &amp;tree,
//              comparator,
//              nodes[i]-&gt;value().first);
//
//      assert(0 != comparisonResult);
//
//      bslalg::RbTreeUtil::insertAt(&amp;tree,
//                                   insertLocation,
//                                   comparisonResult &lt; 0,
//                                   nodes[i]);
//  }
//
//  assert(5 == tree.numNodes());
//..
// Then, we use &#39;bslalg::RbTreeUtil::next()&#39; to navigate the elements of the
// tree, printing their values:
//..
//  const bslalg::RbTreeNode *nodeIterator = tree.firstNode();
//
//  while (nodeIterator != tree.sentinel()) {
//      const TreeNode&lt;bsl::pair&lt;int, int&gt; &gt; *node =
//      static_cast&lt;const TreeNode&lt;bsl::pair&lt;int, int&gt; &gt;*&gt;(nodeIterator);
//      printf(&quot;Node value: (%d, %d)\n&quot;,
//             node-&gt;value().first, node-&gt;value().second);
//      nodeIterator = bslalg::RbTreeUtil::next(nodeIterator);
//  }
//..
// Next, we destroy and deallocate each of the &#39;bslstl::TreeNode&#39; objects:
//..
//  for (int i = 0; i &lt; NUM_NODES; ++i) {
//      AllocTraits::destroy(allocator, &amp;nodes[i]-&gt;value());
//      AllocTraits::deallocate(allocator, nodes[i], 1);
//  }
//..
// Finally, we observe the console output:
//..
//  Node value: (0, 0)
//  Node value: (1, 2)
//  Node value: (2, 4)
//  Node value: (3, 6)
//  Node value: (4, 8)
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_mapcomparator.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_PAIR
#include &lt;bslstl_pair.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_TREENODE
#include &lt;bslstl_treenode.h&gt;
#endif

#ifndef INCLUDED_BSLALG_FUNCTORADAPTER
#include &lt;bslalg_functoradapter.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

namespace BloombergLP {
namespace bslstl {

                       // ===================
                       // class MapComparator
                       // ===================

template &lt;class KEY, class VALUE, class COMPARATOR&gt;
#ifdef BSLS_PLATFORM_CMP_MSVC
// Visual studio compiler fails to resolve the conversion operator in
// &#39;bslalg::FunctorAdapter_FunctionPointer&#39; when using private inheritance.
// Below is a workaround until a more suitable way the resolve this issue can
// be found.
class MapComparator : public bslalg::FunctorAdapter&lt;COMPARATOR&gt;::Type {
#else
class MapComparator : private bslalg::FunctorAdapter&lt;COMPARATOR&gt;::Type {
#endif
    // This class overloads the function-call operator to compare a referenced
    // &#39;bslalg::RbTreeNode&#39; object with a object of the parameterized &#39;KEY&#39;
    // type, assuming the reference to &#39;bslalg::RbTreeNode&#39; is a base of a
    // &#39;bslstl::TreeNode&#39; holding a &#39;pair&lt;KEY, VALUE&gt;&#39;, using a functor of the
    // parameterized &#39;COMPARATOR&#39; type.

  private:
    // This class does not support assignment.

    MapComparator&amp; operator=(const MapComparator&amp;);  // Declared but not
                                                     // defined

  public:
    // TYPES
    typedef bsl::pair&lt;const KEY, VALUE&gt;  ValueType;
        // This alias represents the type of the values held by nodes in an
        // &#39;bslalg::RbTree&#39; object.

    typedef TreeNode&lt;ValueType&gt; NodeType;
        // This alias represents the type of node holding a &#39;ValueType&#39; object.

    // CREATORS
    MapComparator();
        // Create a &#39;MapComparator&#39; object that will use a default constructed
        // &#39;COMPARATOR&#39;.

    explicit MapComparator(const COMPARATOR&amp; keyComparator);
        // Create a &#39;MapComparator&#39; object holding a copy of the specified
        // &#39;keyComparator&#39;.

    // MapComparator(const MapComparator&amp;) = default;
        // Create a &#39;MapComparator&#39; object with the &#39;COMPARATOR&#39; object of the
        // specified &#39;original&#39; object.

    // ~MapComparator() = default;
        // Destroy this object.

    // MANIPULATORS
    bool operator()(const KEY&amp;                lhs,
                    const bslalg::RbTreeNode&amp; rhs);
        // Return &#39;true&#39; if the specified &#39;lhs&#39; is less than (ordered before,
        // according to the comparator held by this object) &#39;value().first&#39; of
        // the specified &#39;rhs&#39; after being cast to &#39;NodeType&#39;, and &#39;false&#39;
        // otherwise.  The behavior is undefined unless &#39;rhs&#39; can be safely
        // cast to &#39;NodeType&#39;.

    bool operator()(const bslalg::RbTreeNode&amp; lhs,
                    const KEY&amp;                rhs);
        // Return &#39;true&#39; if &#39;value().first()&#39; of the specified &#39;lhs&#39; after
        // being cast to &#39;NodeType&#39; is less than (ordered before, according to
        // the comparator held by this object) the specified &#39;rhs&#39;, and &#39;false&#39;
        // otherwise.  The behavior is undefined unless &#39;rhs&#39; can be safely
        // cast to &#39;NodeType&#39;.

    void swap(MapComparator&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.

    // ACCESSORS
    bool operator()(const KEY&amp;                lhs,
                    const bslalg::RbTreeNode&amp; rhs) const;
        // Return &#39;true&#39; if the specified &#39;lhs&#39; is less than (ordered before,
        // according to the comparator held by this object) &#39;value().first&#39; of
        // the specified &#39;rhs&#39; after being cast to &#39;NodeType&#39;, and &#39;false&#39;
        // otherwise.  The behavior is undefined unless &#39;rhs&#39; can be safely
        // cast to &#39;NodeType&#39;.

    bool operator()(const bslalg::RbTreeNode&amp; lhs,
                    const KEY&amp;                rhs) const;
        // Return &#39;true&#39; if &#39;value().first()&#39; of the specified &#39;lhs&#39; after
        // being cast to &#39;NodeType&#39; is less than (ordered before, according to
        // the comparator held by this object) the specified &#39;rhs&#39;, and &#39;false&#39;
        // otherwise.  The behavior is undefined unless &#39;rhs&#39; can be safely
        // cast to &#39;NodeType&#39;.

    COMPARATOR&amp; keyComparator();
        // Return a reference providing modifiable access to the function
        // pointer or functor to which this comparator delegates comparison
        // operations.

    const COMPARATOR&amp; keyComparator() const;
        // Return a reference providing non-modifiable access to the function
        // pointer or functor to which this comparator delegates comparison
        // operations.
};

// FREE FUNCTIONS

template &lt;class KEY,  class VALUE,  class COMPARATOR&gt;
void swap(MapComparator&lt;KEY, VALUE, COMPARATOR&gt;&amp; a,
          MapComparator&lt;KEY, VALUE, COMPARATOR&gt;&amp; b);
    // Efficiently exchange the values of the specified &#39;a&#39; and &#39;b&#39; objects.
    // This function provides the no-throw exception-safety guarantee.

// ===========================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ===========================================================================

                    // -------------------
                    // class MapComparator
                    // -------------------

// CREATORS
template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::MapComparator()
: bslalg::FunctorAdapter&lt;COMPARATOR&gt;::Type()
{
}

template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::
MapComparator(const COMPARATOR&amp; valueComparator)
: bslalg::FunctorAdapter&lt;COMPARATOR&gt;::Type(valueComparator)
{
}

// MANIPULATORS
template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
void MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::swap(
                                  MapComparator&lt;KEY, VALUE, COMPARATOR&gt;&amp; other)
{
    bslalg::SwapUtil::swap(
      static_cast&lt;typename bslalg::FunctorAdapter&lt;COMPARATOR&gt;::Type*&gt;(this),
      static_cast&lt;typename bslalg::FunctorAdapter&lt;COMPARATOR&gt;::Type*&gt;(
                                                  BSLS_UTIL_ADDRESSOF(other)));
}

// ACCESSOR
template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
bool MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::operator()(
                                                 const KEY&amp;                lhs,
                                                 const bslalg::RbTreeNode&amp; rhs)
{
    return keyComparator()(lhs,
                           static_cast&lt;const NodeType&amp;&gt;(rhs).value().first);
}

template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
bool MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::operator()(
                                           const KEY&amp;                lhs,
                                           const bslalg::RbTreeNode&amp; rhs) const
{
    return keyComparator()(lhs,
                           static_cast&lt;const NodeType&amp;&gt;(rhs).value().first);
}

template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
bool MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::operator()(
                                                 const bslalg::RbTreeNode&amp; lhs,
                                                 const KEY&amp;                rhs)
{
    return keyComparator()(static_cast&lt;const NodeType&amp;&gt;(lhs).value().first,
                           rhs);
}

template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
bool MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::operator()(
                                           const bslalg::RbTreeNode&amp; lhs,
                                           const KEY&amp;                rhs) const
{
    return keyComparator()(static_cast&lt;const NodeType&amp;&gt;(lhs).value().first,
                           rhs);
}

template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
COMPARATOR&amp;
MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::keyComparator()
{
    return *this;
}

template &lt;class KEY, class VALUE, class COMPARATOR&gt;
inline
const COMPARATOR&amp;
MapComparator&lt;KEY, VALUE, COMPARATOR&gt;::keyComparator() const
{
    return *this;
}


// FREE FUNCTIONS
template &lt;class KEY,  class VALUE,  class COMPARATOR&gt;
void swap(MapComparator&lt;KEY, VALUE, COMPARATOR&gt;&amp; a,
          MapComparator&lt;KEY, VALUE, COMPARATOR&gt;&amp; b)
{
    a.swap(b);
}

}  // close namespace bslstl
}  // close namespace BloombergLP

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
