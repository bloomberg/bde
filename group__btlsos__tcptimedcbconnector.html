<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsos_tcptimedcbconnector Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsos_tcptimedcbconnector<br/>
<small>
[<a class="el" href="group__btlsos.html">Package btlsos</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a non-blocking connector (with timeout) to TCP servers.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsos.html">btlsos</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: An Example Echo Client</a> </li>
<li>
<a href="#3.2.2">Dual Control and Data Channels</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a non-blocking connector (with timeout) to TCP servers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsos_1_1TcpTimedCbConnector.html">btlsos::TcpTimedCbConnector</a> </td><td>non-blocking timed channel allocator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsos__tcptimedcbchannel.html" title="Provide timed stream-based communication channel over TCP sockets.">Component btlsos_tcptimedcbchannel</a> <a class="el" href="group__btlso__tcptimereventmanager.html" title="Provide a multiplexer of events on sockets and timers.">Component btlso_tcptimereventmanager</a> <a class="el" href="group__btlsos__tcptimedcbacceptor.html" title="Provide a non-blocking acceptor of TCP connections with timeout.">Component btlsos_tcptimedcbacceptor</a> <a class="el" href="group__btlsos__tcpcbchannel.html" title="Provide stream-based communication channel over TCP sockets.">Component btlsos_tcpcbchannel</a> <a class="el" href="group__btlso__socketoptutil.html" title="Provide operations to manipulate socket options.">Component btlso_socketoptutil</a> <a class="el" href="group__btlso__inetstreamsocketfactory.html" title="Implementation for TCP based stream sockets.">Component btlso_inetstreamsocketfactory</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a non-blocking single-port connector of TCP connections with timeout capability, <code><a class="el" href="classbtlsos_1_1TcpTimedCbConnector.html">btlsos::TcpTimedCbConnector</a></code>, that adheres to the <code><a class="el" href="classbtlsc_1_1TimedCbChannelAllocator.html">btlsc::TimedCbChannelAllocator</a></code> protocol. Both timed and non-timed (callback) channels can be allocated in a timed and non-timed fashion as indicated by the following table: <br/>
<br/>
<div class="fragment"><pre class="fragment">                           +=========================================+
                           |            Accept operation             |
       +=============================================================+
       |   Result channel  |        Timed         |    Non-Timed     |
       +-------------------+----------------------+------------------+
       |      Timed        | <span class="stringliteral">&#39;timedAllocateTimed&#39;</span> | <span class="stringliteral">&#39;allocateTimed&#39;</span>  |
       +-------------------+----------------------+------------------+
       |    Non-Timed      |    <span class="stringliteral">&#39;timedAllocate&#39;</span>   |    <span class="stringliteral">&#39;allocate&#39;</span>    |
       +=============================================================+
</pre></div><br/>
<br/>
 Allocations (both timed and non-timed) follow the asynchronous (callback-based) nature of the <code>btesc</code> protocol; the callbacks are invoked when an allocation succeeds or an error occurs. The connector uses a user-installed socket event manager in order to monitor (in a non-blocking fashion) the connecting socket for completion of a connection. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The connector has the flexibility of changing the address of the peer server at run-time with no effect on the state of managed channels. The enqueued (i.e., not-yet-completed) allocation requests will, however, fail (without invalidating the allocator) and the associated callbacks will be invoked when the peer address is changed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The connector is <em>thread</em> <em>safe</em>, meaning that any operation can be called on <em>distinct</em> <em>instances</em> from different threads without any side-effects (which, generally speaking, means that there is no <code>static</code> data), but not <em>thread</em> <em>enabled</em> (i.e., two threads cannot safely call methods on the <em>same</em> <em>instance</em> without external synchronization). This connector is not <em>async-safe</em>, meaning that one or more functions cannot be invoked safely from a signal handler. Note that the thread safety of the connector is subject to the thread safety of the supplied socket event manager. If distinct instances of this connector use the <em>same</em> instance of a socket event manager, both connectors are thread-safe if and only if that socket event manager is <em>THREAD</em> <em>ENABLED</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_an_example_echo_client"></a> <a class="anchor" id="usage.example_1~3A_an_example_echo_client"></a> <a class="anchor" id="description.usage.example_1~3A_an_example_echo_client"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: An Example Echo Client: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following usage example shows a possible implementation of an echo client. An echo client sends connection requests to an echo server, and for every connection, sends and receives data. Various configuration parameters such as the timeout values, the number of connections, the port number, and the number of messages to be sent should be passed into a client object. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_EchoClient {
      <span class="keyword">enum</span> {
          k_BUFFER_SIZE = 100
      };

      <a class="code" href="classbtlsos_1_1TcpTimedCbConnector.html">btlsos::TcpTimedCbConnector</a> d_allocator;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>          d_connectTimeout;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>          d_readTimeout;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>          d_writeTimeout;
      <span class="keywordtype">char</span>                        d_controlBuffer[k_BUFFER_SIZE];
      <span class="keywordtype">int</span>                         d_numConnections;
      <span class="keywordtype">int</span>                         d_maxConnections;
      <span class="keywordtype">int</span>                         d_numMessages;

      bsl::function&lt;void(btlsc::TimedCbChannel*, int)&gt;
                                  d_allocateFunctor;

      <span class="keywordtype">void</span> allocateCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel, <span class="keywordtype">int</span> status);
          <span class="comment">// Invoked by the socket event manager when a connection is</span>
          <span class="comment">// accepted.</span>

      <span class="keywordtype">void</span> bufferedReadCb(<span class="keyword">const</span> <span class="keywordtype">char</span>            *buffer,
                          <span class="keywordtype">int</span>                    status,
                          <span class="keywordtype">int</span>                    asyncStatus,
                          <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                          <span class="keywordtype">int</span>                    sequence);

      <span class="keywordtype">void</span> writeCb(<span class="keywordtype">int</span>                    status,
                   <span class="keywordtype">int</span>                    asyncStatus,
                   <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                   <span class="keywordtype">int</span>                    sequence);

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_EchoClient(<span class="keyword">const</span> my_EchoClient&amp;);
      my_EchoClient&amp; operator=(<span class="keyword">const</span> my_EchoClient&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_EchoClient(
         <a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *factory,
         <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>                       *manager,
         <span class="keywordtype">int</span>                                             maxConnections,
         <span class="keywordtype">int</span>                                             numMessages,
         <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                               *basicAllocator = 0);

      ~my_EchoClient();

      <span class="comment">//  MANIPULATORS</span>
      <span class="keywordtype">int</span> setPeer(<span class="keyword">const</span> <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&amp; address);
          <span class="comment">// Set the address of the echo server to the specified &#39;address&#39;,</span>
          <span class="comment">// and start sending messages to the server.</span>
  };

  <span class="comment">// CREATORS</span>
  my_EchoClient::my_EchoClient(
              <a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *factory,
              <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>                       *manager,
              <span class="keywordtype">int</span>                                             maxConnections,
              <span class="keywordtype">int</span>                                             numMessages,
              <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                               *basicAllocator)
  : d_allocator(factory, manager, basicAllocator)
  , d_connectTimeout(120, 0)
  , d_readTimeout(20.0)
  , d_writeTimeout(5,0)
  , d_numConnections(0)
  , d_maxConnections(maxConnections)
  , d_numMessages(numMessages)
  {
      assert(factory);
      assert(manager);
      d_allocateFunctor = <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_EchoClient::allocateCb,
                                                 <span class="keyword">this</span>);

      bsl::memset(d_controlBuffer, <span class="charliteral">&#39;A&#39;</span>, k_BUFFER_SIZE);
      ((<span class="keywordtype">int</span>*)d_controlBuffer)[0] = k_BUFFER_SIZE;
      ((<span class="keywordtype">int</span>*)d_controlBuffer)[1] = k_BUFFER_SIZE;
  }

  my_EchoClient::~my_EchoClient() {
  }
</pre></div><br/>
<br/>
 All the work of accepting connections and reading/writing the data is done in the (private) callback methods of <code>my_EchoClient</code>. When the connection is established and the <code>allocateCb</code> method is invoked, the buffered write with timeout is initiated on the channel and another allocation request is enqueued. If any error occurs while allocating, the acceptor is shut down. If any error, including timeout, occurs while reading or writing data, the channel is shut down. Note that the allocation functor is cached to improve performance: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> my_EchoClient::allocateCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                                 <span class="keywordtype">int</span>                    status) {
      <span class="keywordflow">if</span> (channel) {
          <span class="comment">// Connected to a server.  Issue a buffered write request.</span>

          bsl::function&lt;void(int, int)&gt; callback(
                                <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_EchoClient::writeCb,
                                                     <span class="keyword">this</span>,
                                                     <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                                                     _2,
                                                     channel,
                                                     0));
          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aec7af32d3d17c756292f391f8c5652eb">timedBufferedWrite</a>(d_controlBuffer,
                                          k_BUFFER_SIZE,
                                          <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                               + d_writeTimeout, callback)) {
              puts(<span class="stringliteral">&quot;Failed to enqueue write request.&quot;</span>);
              assert(channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#ac4f00d6d10f9b96decb221c455ca42f9">isInvalidWrite</a>());
              d_allocator.deallocate(channel);
          }

          <span class="keywordflow">if</span> (d_maxConnections &gt; ++d_numConnections) {
              <span class="keywordtype">int</span> s = d_allocator.timedAllocateTimed(d_allocateFunctor,
                                                     <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                         + d_connectTimeout);
              assert(0 == s);
          }
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }

      assert(0 &gt;= status);    <span class="comment">// Interrupts are not enabled.</span>
      <span class="keywordflow">if</span> (0 == status) {
          cerr &lt;&lt; <span class="stringliteral">&quot;Timed out connecting to the server.&quot;</span> &lt;&lt; endl;
      }
      <span class="keywordflow">else</span> {
          <span class="comment">// Hard-error accepting a connection, invalidate the allocator.</span>
          printf(<span class="stringliteral">&quot;Non-recoverable error connecting to the server %d &quot;</span>
                 <span class="stringliteral">&quot;(Connection %d of of %d)\n&quot;</span>,
                 status, d_numConnections, d_maxConnections);
          d_allocator.invalidate();
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      <span class="comment">// In any case, except for hard error on allocator, enqueue another</span>
      <span class="comment">// connect request</span>
      <span class="keywordflow">if</span> (d_maxConnections &gt; ++d_numConnections) {
          <span class="keywordtype">int</span> s = d_allocator.timedAllocateTimed(d_allocateFunctor,
                                                 <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                         + d_connectTimeout);
          assert(0 == s);
      }
  }

  <span class="keywordtype">void</span> my_EchoClient::bufferedReadCb(<span class="keyword">const</span> <span class="keywordtype">char</span>            *buffer,
                                     <span class="keywordtype">int</span>                    status,
                                     <span class="keywordtype">int</span>                    asyncStatus,
                                     <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                                     <span class="keywordtype">int</span>                    sequence)
  {
      assert(channel);
      <span class="keywordflow">if</span> (0 &lt; status) {
          assert(k_BUFFER_SIZE == status);
          assert(0 == bsl::memcmp(buffer, d_controlBuffer, k_BUFFER_SIZE));

          <span class="comment">// If we&#39;re not done -- enqueue another request</span>
          <span class="keywordflow">if</span> (sequence &lt; d_numMessages) {
              bsl::function&lt;void(int, int)&gt; callback(
                                <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_EchoClient::writeCb,
                                                     <span class="keyword">this</span>,
                                                     <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                                                     _2,
                                                     channel,
                                                     sequence + 1));
              <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aec7af32d3d17c756292f391f8c5652eb">timedBufferedWrite</a>(d_controlBuffer,
                                              k_BUFFER_SIZE,
                                              <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                 + d_writeTimeout, callback))
                  {
                      puts(<span class="stringliteral">&quot;Failed to enqueue write request.&quot;</span>);
                      assert(channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#ac4f00d6d10f9b96decb221c455ca42f9">isInvalidWrite</a>());
                      d_allocator.deallocate(channel);
                  }
          }
          <span class="keywordflow">else</span> {
              d_allocator.deallocate(channel);
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == status) {
          <span class="keywordflow">if</span> (0 &gt; asyncStatus) {
          }
          <span class="keywordflow">else</span> {
              printf(<span class="stringliteral">&quot;Timed out: Can&#39;t read data from server for more than&quot;</span>
                     <span class="stringliteral">&quot; %lld seconds\n&quot;</span>, d_readTimeout.seconds());
              d_allocator.deallocate(channel);
          }
      }
      <span class="keywordflow">else</span> {
          printf(<span class="stringliteral">&quot;Failed to read data: non-recoverable error: %d\n&quot;</span>,
                 status);
          d_allocator.deallocate(channel);
      }
  }

  <span class="keywordtype">void</span> my_EchoClient::writeCb(<span class="keywordtype">int</span>                    status,
                              <span class="keywordtype">int</span>                    asyncStatus,
                              <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                              <span class="keywordtype">int</span>                    sequence)
  {
      <span class="keywordflow">if</span> (0 &lt; status) {
          <span class="keywordflow">if</span> (status != k_BUFFER_SIZE) {
              d_allocator.deallocate(channel);
              assert(<span class="stringliteral">&quot;Failed to send data to the server&quot;</span> &amp;&amp; 0);
          }
          <span class="keywordflow">else</span> {
              bsl::function&lt;void(const char *, int, int)&gt; callback(
                         <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_EchoClient::bufferedReadCb,
                                              <span class="keyword">this</span>,
                                              <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                                              _2,
                                              _3,
                                              channel,
                                              sequence));
              <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#a1bcaa5992ed3d03f3f5e983942c6f547">timedBufferedRead</a>(k_BUFFER_SIZE,
                                             <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                             + d_readTimeout,
                                             callback)) {
                  assert(channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aa2ec0ed55d1935bbb08b7d02d0df6bb2">isInvalidRead</a>());
                  d_allocator.deallocate(channel);
                  assert(<span class="stringliteral">&quot;Failed to enqueue read request&quot;</span> &amp;&amp; 0);
              }
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == status) {
          <span class="keywordflow">if</span> (0 &gt; asyncStatus) {
              cout &lt;&lt; <span class="stringliteral">&quot;Request dequeued.&quot;</span> &lt;&lt; endl;
          }
          <span class="keywordflow">else</span> {
              d_allocator.deallocate(channel);
              assert(<span class="stringliteral">&quot;Timed out sending data to the server&quot;</span> &amp;&amp; 0);
          }
      }
      <span class="keywordflow">else</span> {
          d_allocator.deallocate(channel);
          assert(<span class="stringliteral">&quot;Failed to send data: non-recoverable error on the channel&quot;</span>
                 &amp;&amp; 0);
      }
  }

  <span class="keywordtype">int</span> my_EchoClient::setPeer(<span class="keyword">const</span> <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&amp; address) {
      d_allocator.setPeer(address);
      <span class="keywordflow">return</span> d_allocator.timedAllocateTimed(d_allocateFunctor,
                                            <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                         + d_connectTimeout);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="dual_control_and_data_channels"></a> <a class="anchor" id="usage.dual_control_and_data_channels"></a> <a class="anchor" id="description.usage.dual_control_and_data_channels"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Dual Control and Data Channels: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following usage example shows a possible implementation of a client-side communication layer where two communication channels are established for a server: one is for control messages and another for the data stream. The client is implemented as a separate class that owns the connector and uses a socket event manager and (corresponding) stream socket factory installed at creation. Various configuration parameters such as the timeout values, the queue size, and input buffer size are constants within this class. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_DataStream {
      <span class="keyword">enum</span> {
          k_DEFAULT_PORT_NUMBER = 1234,
          k_QUEUE_SIZE          =   16
      };

      <a class="code" href="classbtlsos_1_1TcpTimedCbConnector.html">btlsos::TcpTimedCbConnector</a>  d_allocator;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>           d_connectTimeout;
      <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a>       *d_controlChannel;
      <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a>       *d_dataChannel;

    <span class="keyword">private</span>:
      <span class="comment">// Callbacks</span>
      <span class="keywordtype">void</span> allocateCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a>  *channel,
                      <span class="keywordtype">int</span>                     status,
                      <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> **cachedChannel);
          <span class="comment">// Invoked from the socket event manager when a connection is</span>
          <span class="comment">// allocated (i.e., established) or an error occurs when</span>
          <span class="comment">// allocating.</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_DataStream(<span class="keyword">const</span> my_DataStream&amp;);
      my_DataStream&amp; operator=(<span class="keyword">const</span> my_DataStream&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_DataStream(
                <a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *factory,
                <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>                       *manager,
                <span class="keyword">const</span> <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&amp;                       peerAddress);
          <span class="comment">// Create a controlled data stream that uses the specified stream</span>
          <span class="comment">// socket &#39;factory&#39; for system sockets, uses the specified socket</span>
          <span class="comment">// event &#39;manager&#39; to multiplex events on these sockets, and</span>
          <span class="comment">// attempts to connect to the server at the specified</span>
          <span class="comment">// &#39;peerAddress&#39;.  The behavior is undefined if either &#39;factory&#39;</span>
          <span class="comment">// or &#39;manager&#39; is 0.</span>

      ~my_DataStream();
          <span class="comment">// Destroy this server.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> setUpCallbacks();
          <span class="comment">// Register callbacks as required for establishing communication</span>
          <span class="comment">// channels.  Return 0 on success, and a non-zero value otherwise,</span>
          <span class="comment">// in which case all further registration attempts will fail (and</span>
          <span class="comment">// the object can be only destroyed).</span>
  };
</pre></div><br/>
<br/>
 The implementation of the public methods of <code>my_DataStream</code> is trivial. For the constructor, the socket factory and socket event manager are passed to the connector, and the allocate callback and (three) event timeouts are initialized; the peer address is passed to the connector. The destructor verifies that the state of the connector is valid: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_DataStream::my_DataStream(
                 <a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *factory,
                 <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>                       *manager,
                 <span class="keyword">const</span> <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&amp;                       peerAddress)
  : d_allocator(factory, manager)
  , d_connectTimeout(120, 0)
  , d_controlChannel(NULL)
  , d_dataChannel(NULL)
  {
      assert(factory);
      assert(manager);
      d_allocator.setPeer(peerAddress);
  }

  my_DataStream::~my_DataStream() {
      assert(0 == d_allocator.numChannels());
  }

  <span class="keywordtype">int</span> my_DataStream::setUpCallbacks() {
      bsl::function&lt;void(btlsc::TimedCbChannel*, int)&gt; callback(
                             <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_DataStream::allocateCb,
                                                  <span class="keyword">this</span>,
                                                  <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                                                  _2,
                                                  &amp;d_controlChannel));

      <span class="keywordflow">if</span> (d_allocator.timedAllocateTimed(callback,
                                         <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                       + d_connectTimeout)) {
          <span class="keywordflow">return</span> -1;                                                <span class="comment">// RETURN</span>
      }

      callback = <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_DataStream::allocateCb,
                                      <span class="keyword">this</span>,
                                      <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                                      _2,
                                      &amp;d_dataChannel);
      <span class="keywordflow">return</span> d_allocator.timedAllocateTimed(callback,
                                            <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                         + d_connectTimeout);
  }
</pre></div><br/>
<br/>
 The allocate callback will cache the newly-allocated channel for future use: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_DataStream::allocateCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a>  *channel,
                                 <span class="keywordtype">int</span>                     status,
                                 <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> **cachedChannel) {
      assert(cachedChannel);

      <span class="keywordflow">if</span> (channel) {
          *cachedChannel = channel;
          <span class="keywordflow">if</span> (d_controlChannel &amp;&amp; d_dataChannel) {
              <span class="comment">// Ready to do data processing ...</span>
          }
      }
      <span class="keywordflow">else</span> {
          cout &lt;&lt; <span class="stringliteral">&quot;not valid channel: status: &quot;</span> &lt;&lt; status &lt;&lt; endl;
      }
  }

  <span class="keyword">static</span> <span class="keywordtype">void</span> connectCb(<a class="code" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a>            *channel,
                        <span class="keywordtype">int</span>                          status,
                        <a class="code" href="classbtlsos_1_1TcpTimedCbConnector.html">btlsos::TcpTimedCbConnector</a> *connector,
                        <span class="keywordtype">int</span>                         *numConnections,
                        <span class="keywordtype">int</span>                          validChannel,
                        <span class="keywordtype">int</span>                          expStatus,
                        <span class="keywordtype">int</span>                          cancelFlag)
      <span class="comment">// Verify the result of an &quot;ACCEPT&quot; request by comparing against the</span>
      <span class="comment">// expected values: If the specified &#39;validChannel&#39; is nonzero, a new</span>
      <span class="comment">// &#39;btlsc::CbChannel&#39; should be established; the specified return</span>
      <span class="comment">// &#39;status&#39; should be the same as the specified &#39;expStatus&#39;.  If the</span>
      <span class="comment">// specified &#39;cancelFlag&#39; is nonzero, invoke the &#39;cancelAll()&#39; on the</span>
      <span class="comment">// specified &#39;acceptor&#39; for test.</span>
  {
      <span class="keywordflow">if</span> (validChannel) {
          assert(channel);
      }
      <span class="keywordflow">else</span> {
          assert(0 == channel);
      }
      assert(status == expStatus);

      <span class="keywordflow">if</span> (0 == channel) {
      }
      <span class="keywordflow">else</span> {
          ++(*numConnections);
      }
      <span class="keywordflow">if</span> (cancelFlag) {
          connector-&gt;<a class="code" href="classbtlsos_1_1TcpTimedCbConnector.html#a89d356169bc06c72728dd69aa7d835b9">cancelAll</a>();
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
