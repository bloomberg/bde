<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: balst_stackaddressutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component balst_stackaddressutil<br/>
<small>
[<a class="el" href="group__balst.html">Package balst</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a utility for obtaining return addresses from the stack.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebalst.html">balst</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Obtaining Return Addresses and Verifying Their Validity</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a utility for obtaining return addresses from the stack. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbalst_1_1StackAddressUtil.html">balst::StackAddressUtil</a> </td><td>utilities for obtaining addresses from the stack  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__balst__stacktrace.html" title="Provide a description of a function-call stack.">Component balst_stacktrace</a>, <a class="el" href="group__balst__stacktraceframe.html" title="Provide an attribute class describing an execution stack frame.">Component balst_stacktraceframe</a>, <a class="el" href="group__balst__stacktraceutil.html" title="Provide low-level utilities for obtaining &amp; printing a stack-trace.">Component balst_stacktraceutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides namespace containing a function that populates an array with an ordered sequence of return addresses from the current thread's function call stack. Each return address points to the (text) memory location of the first instruction to be executed upon returning from a called routine. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show the intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_obtaining_return_addresses_and_verifying_their_validity"></a> <a class="anchor" id="usage.example_1~3A_obtaining_return_addresses_and_verifying_their_validity"></a> <a class="anchor" id="description.usage.example_1~3A_obtaining_return_addresses_and_verifying_their_validity"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Obtaining Return Addresses and Verifying Their Validity: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following example we demonstrate how to obtain the sequence of function return addresses from the stack using <code>getStackAddresses</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define <code>AddressEntry</code>, which will contain a pointer to the beginning of a function and an index corresponding to the function. The <code>&lt;</code> operator is defined so that a vector of address entries can be sorted in the order of the function addresses. The address entries will be populated so that the entry containing <code>&amp;funcN</code> when <code>N</code> is an integer will have an index of <code>N</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>AddressEntry {
      <span class="keywordtype">void</span> *d_funcAddress;
      <span class="keywordtype">int</span>   d_index;

      <span class="comment">// CREATORS</span>
      AddressEntry(<span class="keywordtype">void</span> *funcAddress, <span class="keywordtype">int</span> index)
      : d_funcAddress(funcAddress)
      , d_index(index)
          <span class="comment">// Create an &#39;AddressEntry&#39; object and initialize it with the</span>
          <span class="comment">// specified &#39;funcAddress&#39; and &#39;index&#39;.</span>
      {}

      <span class="keywordtype">bool</span> <a class="code" href="namespacebaltzo.html#a7103b08c49f3116c75f12856af5d1ca7">operator&lt;</a>(<span class="keyword">const</span> AddressEntry&amp; rhs) <span class="keyword">const</span>
          <span class="comment">// Return &#39;true&#39; if the address stored in the object is lower than</span>
          <span class="comment">// the address stored in &#39;rhs&#39; and &#39;false&#39; otherwise.  Note that</span>
          <span class="comment">// this is a member function for brevity, it only exists to</span>
          <span class="comment">// facilitate sorting &#39;AddressEntry&#39; objects in a vector.</span>
      {
          <span class="keywordflow">return</span> d_funcAddress &lt; rhs.d_funcAddress;
      }
  };
</pre></div><br/>
<br/>
 Then, we define <code>entries</code>, a vector of address entries. This will be populated such that a given entry will contain function address <code>&amp;funcN</code> and index <code>N</code>. The elements will be sorted according to function address. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;AddressEntry&gt;</a> entries;
</pre></div><br/>
<br/>
 Next, we define <code>findIndex</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">int</span> findIndex(<span class="keyword">const</span> <span class="keywordtype">void</span> *retAddress)
      <span class="comment">// Return the index of the address entry whose function uses an</span>
      <span class="comment">// instruction located at specified &#39;retAddress&#39;.  The behavior is</span>
      <span class="comment">// undefined unless &#39;retAddress&#39; is the address of an instruction in</span>
      <span class="comment">// use by a function referred to by an address entry in &#39;entries&#39;.</span>
  {
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0;
      <span class="keywordflow">while</span> (u &lt; entries.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>()-1 &amp;&amp;
                                  retAddress &gt;= entries[u+1].d_funcAddress) {
          ++u;
      }
      assert(u &lt; entries.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());
      assert(retAddress &gt;= entries[u].d_funcAddress);

      <span class="keywordtype">int</span> ret = entries[u].d_index;

      <span class="keywordflow">if</span> (veryVerbose) {
          P_(retAddress) P_(entries[u].d_funcAddress) <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a>(ret);
      }

      return ret;
  }
</pre></div><br/>
<br/>
 Then, we define a volatile global variable that we will use in calculation to discourage compiler optimizers from inlining: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> volatileGlobal = 1;
</pre></div><br/>
<br/>
 Next, we define a set of functions that will be called in a nested fashion -- <code>func5</code> calls <code>func4</code> who calls <code>fun3</code> and so on. In each function, we will perform some inconsequential instructions to prevent the compiler from inlining the functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that we know the <code>if</code> conditions in these 5 subroutines never evaluate to <code>true</code>, however, the optimizer cannot figure that out, and that will prevent it from inlining here. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> func1();
  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> func2()
  {
      <span class="keywordflow">if</span> (volatileGlobal &gt; 10) {
          <span class="keywordflow">return</span> (volatileGlobal -= 100) * 2 * func2();             <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> volatileGlobal * 2 * func1();                      <span class="comment">// RETURN</span>
      }
  }
  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> func3()
  {
      <span class="keywordflow">if</span> (volatileGlobal &gt; 10) {
          <span class="keywordflow">return</span> (volatileGlobal -= 100) * 2 * func3();             <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> volatileGlobal * 3 * func2();                      <span class="comment">// RETURN</span>
      }
  }
  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> func4()
  {
      <span class="keywordflow">if</span> (volatileGlobal &gt; 10) {
          <span class="keywordflow">return</span> (volatileGlobal -= 100) * 2 * func4();             <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> volatileGlobal * 4 * func3();                      <span class="comment">// RETURN</span>
      }
  }
  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> func5()
  {
      <span class="keywordflow">if</span> (volatileGlobal &gt; 10) {
          <span class="keywordflow">return</span> (volatileGlobal -= 100) * 2 * func5();             <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> volatileGlobal * 5 * func4();                      <span class="comment">// RETURN</span>
      }
  }
  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> func6()
  {
      <span class="keywordflow">if</span> (volatileGlobal &gt; 10) {
          <span class="keywordflow">return</span> (volatileGlobal -= 100) * 2 * func6();             <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> volatileGlobal * 6 * func5();                      <span class="comment">// RETURN</span>
      }
  }
</pre></div><br/>
<br/>
 Next, we define the macro FUNC_ADDRESS, which will take a parameter of <code>&amp;&lt;function name&gt;</code> and return a pointer to the actual beginning of the function's code, which is a non-trivial and platform-dependent exercise. Note: this doesn't work on Windows for global routines. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #if   defined(BSLS_PLATFORM_OS_HPUX)</span>
<span class="preprocessor"></span><span class="preprocessor">  # define FUNC_ADDRESS(p) (((void **) (void *) (p))[sizeof(void *) == 4])</span>
<span class="preprocessor"></span><span class="preprocessor">  #elif defined(BSLS_PLATFORM_OS_AIX)</span>
<span class="preprocessor"></span><span class="preprocessor">  # define FUNC_ADDRESS(p) (((void **) (void *) (p))[0])</span>
<span class="preprocessor"></span><span class="preprocessor">  #else</span>
<span class="preprocessor"></span><span class="preprocessor">  # define FUNC_ADDRESS(p) ((void *) (p))</span>
<span class="preprocessor">  #endif</span>
</pre></div><br/>
<br/>
 Then, we define <code>func1</code>, the last function to be called in the chain of nested function calls. <code>func1</code> uses <code><a class="el" href="structbalst_1_1StackAddressUtil.html#a31eb649ae00ae8153ef1439f7c5d58a0">balst::StackAddressUtil::getStackAddresses</a></code> to get an ordered sequence of return addresses from the current thread's function call stack and uses the previously defined <code>findIndex</code> function to verify those address are correct. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> func1()
      <span class="comment">// Call &#39;getAddresses&#39; and verify that the returned set of addresses</span>
      <span class="comment">// matches our expectations.</span>
  {
</pre></div><br/>
<br/>
 Next, we populate and sort the <code>entries</code> table, a sorted array of <code>AddressEntry</code> objects that will allow <code>findIndex</code> to look up within which function a given return address can be found. <br/>
<br/>
<div class="fragment"><pre class="fragment">      entries.<a class="code" href="group__bslstl__vector.html#gae9fa4fec3242df3b8c6a70118726304d">clear</a>();
      entries.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(AddressEntry(0, 0));
      entries.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(AddressEntry(FUNC_ADDRESS(&amp;func1), 1));
      entries.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(AddressEntry(FUNC_ADDRESS(&amp;func2), 2));
      entries.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(AddressEntry(FUNC_ADDRESS(&amp;func3), 3));
      entries.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(AddressEntry(FUNC_ADDRESS(&amp;func4), 4));
      entries.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(AddressEntry(FUNC_ADDRESS(&amp;func5), 5));
      entries.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(AddressEntry(FUNC_ADDRESS(&amp;func6), 6));
      bsl::sort(entries.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>(), entries.<a class="code" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a>());
</pre></div><br/>
<br/>
 Then, we obtain the stack addresses with <code>getStackAddresses</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">enum</span> { BUFFER_LENGTH = 100 };
      <span class="keywordtype">void</span> *buffer[BUFFER_LENGTH];
      bsl::memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));
      <span class="keywordtype">int</span> numAddresses = <a class="code" href="structbalst_1_1StackAddressUtil.html#a31eb649ae00ae8153ef1439f7c5d58a0">balst::StackAddressUtil::getStackAddresses</a>(
                                                              buffer,
                                                              BUFFER_LENGTH);
      assert(numAddresses &gt;= (<span class="keywordtype">int</span>) entries.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());
      assert(numAddresses &lt; BUFFER_LENGTH);
      assert(0 != buffer[numAddresses-1]);
      assert(0 == buffer[numAddresses]);
</pre></div><br/>
<br/>
 Finally, we go through several of the first addresses returned in <code>buffer</code> and verify that each address corresponds to the routine we expect it to. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that on some, but not all, platforms there is an extra <code>narcissic</code> frame describing <code>getStackAddresses</code> itself at the beginning of <code>buffer</code>. By starting our iteration through <code>buffer</code> at <code>k_IGNORE_FRAMES</code>, we guarantee that the first address we examine will be in <code>func1</code> on all platforms. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">int</span> funcIdx  = 1;
      <span class="keywordtype">int</span> stackIdx = balst::StackAddressUtil::k_IGNORE_FRAMES;
      <span class="keywordflow">for</span> (; funcIdx &lt; (int) entries.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>(); ++funcIdx, ++stackIdx) {
          assert(stackIdx &lt; numAddresses);
          assert(funcIdx == findIndex(buffer[stackIdx]));
      }

      <span class="keywordflow">if</span> (testStatus || veryVerbose) {
          Q(Entries:);
          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0; u &lt; entries.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>(); ++u) {
              P_(u); P_((<span class="keywordtype">void</span> *) entries[u].d_funcAddress);
              <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a>(entries[u].d_index);
          }

          Q(Stack:);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numAddresses; ++i) {
              P_(i); <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a>(buffer[i]);
          }
      }

      <span class="keywordflow">return</span> volatileGlobal;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:29 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
