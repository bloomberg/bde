<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslalg_autoarraymovedestructor.h                                   -*-C++-*-
#ifndef INCLUDED_BSLALG_AUTOARRAYMOVEDESTRUCTOR
#define INCLUDED_BSLALG_AUTOARRAYMOVEDESTRUCTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a proctor for destroying arrays.
//
//@CLASSES:
//  bslalg::AutoArrayMoveDestructor: exception-neutrality guard for arrays
//
//@SEE_ALSO: bslma_autodestructor, bslalg_autoarraydestructor
//
//@DESCRIPTION: This component provides a proctor object to manage a contiguous
// (in-place) sequence of otherwise-unmanaged instances of a user-defined type.
// If not explicitly released, all objects managed by the proctor object are
// automatically destroyed by the proctor&#39;s destructor or moved back to their
// original area, using the &#39;bslalg_arraydestructionprimitives&#39; and
// &#39;std::memmove&#39;.  This component is intended to be used only with bit-wise
// moveable types, and for a very special purpose as shown in the usage
// example.
//
// Overview of the operation of &#39;AutoArrayMoveDestructor&#39;:
// ------------------------------------------------------
// Supposee we want to double the length of an array by prepending copies a
// &#39;value&#39; at the start of the array.  Note that we assume there is ample
// uninitialized memory after the end of the initial array for these new
// values to be instered.
//
// Legend:
//..
//    &#39;ABCDE&#39;   -- initial array elements.
//    &#39;v&#39;       -- copy of specified &#39;value&#39; being inserted.
//    &#39;.&#39;       -- (period) uninitialized memory.
//    &#39;^(,)&#39;    -- area guarded by &#39;AutoArrayMoveDestructor&#39;, where:
//                 &#39;^&#39; -- position of &#39;guard.destination()&#39;
//                 &#39;(&#39; -- position of &#39;guard.begin()&#39;
//                 &#39;,&#39; -- (comma) position of &#39;guard.middle()&#39;
//                 &#39;)&#39; -- position of &#39;guard.end()&#39;
//..
// The copy constructor for the type being inserted may throw, so we need to
// have a guard object which allows us to make some guarantee about the state
// of the array after the guard is destroyed.  What we want to guarantee is
// that there are as many valid objects at the start of the array as before
// with no other valid objects in existence.
//
// The following steps show a succssful operation prepending copies of the
// value &#39;v&#39;:
//..
//  1: &#39;ABCDE.....&#39;      -- initial memory.
//  2: &#39;.....ABCDE&#39;      -- memory after first &#39;std::memcpy&#39;.
//  3: &#39;^.....(,ABCDE)&#39;  -- memory immediately after &#39;guard&#39; is set
//  4: &#39;vv^...(AB,CDE)&#39;  -- memory after 2 copies of &#39;value&#39; have been
//                          created, and &#39;guard.advance()&#39; has been called
//                          twice.
//  5: &#39;vvvvv^(ABCDE,)&#39;  -- memory after insertion is completed
//  6: &#39;vvvvvABCDE&#39;      -- memory after guard was destroyed (at which point
//                          &#39;guard.middle() == guard.end()&#39; so destructor did
//                          nothing.
//..
// Now suppose we threw after step 4, destroying &#39;guard&#39;.
//..
//  4:  &#39;vv^...(AB,CDE)&#39; -- same as step &#39;4&#39; above, before destructor starts
//  5b: &#39;vv^CDE(AB,...)&#39; -- memory after &#39;guard&#39;s destructor moves &#39;CDE&#39; back
//                          to their position before we began
//  6b: &#39;vv^CDE(..,...)&#39; -- memory after &#39;guard&#39;s destructor destroys &#39;A&#39; and
//                          &#39;B&#39;
//  7b: &#39;vvCDE.....&#39;     -- memory after &#39;guard&#39;s destructor completes
//..
// We now have 5 valid elements in the beginning of the range, as it was when
// we started, making the situation predictable for our next destructor.
//
// This was a very simple case, but using this guard in conjunction with
// &#39;bslalg::AutoArrayDestructor&#39;, we can implment the more general case of
// inserting arbitrary numbers of elements at the beginning of an array.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Doubling the Length of an Array
/// - - - - - - - - - - - - - - - - - - - - -
// First, we create the class &#39;TestType&#39;, which is bitwise-movable and
// allocates memory upon construction:
//..
//                             // ==============
//                             // class TestType
//                             // ==============
//
//  class TestType {
//      // This test type contains a &#39;char&#39; in some allocated storage.  It
//      // counts the number of default and copy constructions, assignments,
//      // and destructions.  It has no traits other than using a &#39;bslma&#39;
//      // allocator.  It could have the bit-wise moveable traits but we defer
//      // that trait to the &#39;MoveableTestType&#39;.
//
//      char             *d_data_p;
//      bslma::Allocator *d_allocator_p;
//
//    public:
//      // CREATORS
//      explicit TestType(bslma::Allocator *basicAllocator = 0)
//      : d_data_p(0)
//      , d_allocator_p(bslma::Default::allocator(basicAllocator))
//      {
//          d_data_p  = (char *)d_allocator_p-&gt;allocate(sizeof(char));
//          *d_data_p = &#39;?&#39;;
//      }
//
//      explicit TestType(char c, bslma::Allocator *basicAllocator = 0)
//      : d_data_p(0)
//      , d_allocator_p(bslma::Default::allocator(basicAllocator))
//      {
//          d_data_p  = (char *)d_allocator_p-&gt;allocate(sizeof(char));
//          *d_data_p = c;
//      }
//
//      TestType(const TestType&amp;   original,
//               bslma::Allocator *basicAllocator = 0)
//      : d_data_p(0)
//      , d_allocator_p(bslma::Default::allocator(basicAllocator))
//      {
//          if (&amp;original != this) {
//              d_data_p  = (char *)d_allocator_p-&gt;allocate(sizeof(char));
//              *d_data_p = *original.d_data_p;
//          }
//      }
//
//      ~TestType()
//      {
//          *d_data_p = &#39;_&#39;;
//          d_allocator_p-&gt;deallocate(d_data_p);
//          d_data_p = 0;
//      }
//
//      // MANIPULATORS
//      TestType&amp; operator=(const TestType&amp; rhs)
//      {
//          if (&amp;rhs != this) {
//              char *newData = (char *)d_allocator_p-&gt;allocate(sizeof(char));
//              *d_data_p = &#39;_&#39;;
//              d_allocator_p-&gt;deallocate(d_data_p);
//              d_data_p  = newData;
//              *d_data_p = *rhs.d_data_p;
//          }
//          return *this;
//      }
//
//      void setDatum(char c) { *d_data_p = c; }
//
//      // ACCESSORS
//      char datum() const { return *d_data_p; }
//  };
//
//  // FREE OPERATORS
//  bool operator==(const TestType&amp; lhs, const TestType&amp; rhs)
//  {
//      return lhs.datum() == rhs.datum();
//  }
//
//  // TRAITS
//  namespace BloombergLP {
//
//  namespace bslma {
//  template &lt;&gt; struct UsesBslmaAllocator&lt;TestType&gt; : bsl::true_type {};
//  }  // close package namespace
//
//  namespace bslma {
//  template &lt;&gt; struct IsBitwiseMoveable&lt;TestType&gt; : bsl::true_type {};
//  }  // close package namespace
//
//  }  // close enterprise namespace
//..
// Then, we define the function &#39;insertItems&#39; which uses
// &#39;AutoArrayMoveDestructor&#39; to ensure that if an exception is thrown (e.g.,
// when allocating memory), the array will be left in a state where it has the
// same number of elements, in the same location, as when the function begin
// (though not necessarily the same value).
//..
//  void insertItems(TestType         *start,
//                   TestType         *divider,
//                   const TestType    value,
//                   bslma::Allocator *allocator)
//      // The memory in the specified range &#39;[ start, divider )&#39; contains
//      // valid elements, and the range of valid elements is to be doubled by
//      // inserting &#39;divider - start&#39; copies of the specified &#39;value&#39; at
//      // &#39;start&#39;, shifting the existing valid values back in memory.  Assume
//      // that following the pointer &#39;divider&#39; is sufficient uninitialized
//      // memory, and that the type &#39;TestType&#39; is bitwise-movable
//      // (&#39;AutoArrayMoveDestructor&#39; will only work bitwise-movable types).
//  {
//      TestType *finish = divider + (divider - start);
//
//      BSLMF_ASSERT(bslmf::IsBitwiseMoveable&lt; TestType&gt;::value);
//      BSLMF_ASSERT(bslma::UsesBslmaAllocator&lt;TestType&gt;::value);
//
//      // The range &#39;[ start, divider )&#39; contains valid elements.  The range
//      // &#39;[ divider, finish )&#39; is of equal length and contains uninitialized
//      // memory.  We want to insert &#39;divider - start&#39; copies of the specified
//      // &#39;value&#39; at the front half of the range &#39;[ start, finish )&#39;, moving
//      // the exising elements back to make room for them.  Note that the copy
//      // c&#39;tor of &#39;TestType&#39; allocates memory and may throw, so we have to
//      // leave the array in a somewhat predicatable state if we do throw.
//      // What the bslalg::AutoArrayMoveDestructor will do is guarantee that,
//      // if it is destroyed before the insertion is complete, the range
//      // &#39;[ start, divider )&#39; will contain valid elements, and that no other
//      // valid elements will exist.
//      //
//      // Note that the existing elements, which are bitwise-moveable, may be
//      // *moved* about the container without the possibility of throwing an
//      // exception, but the newly inserted elements must be copy-constructed
//      // (requiring memory allocation).
//      //
//      // First, move the valid elements from &#39;[ start, divider )&#39; to
//      // &#39;[ divider, finish )&#39;.  This can be done without risk of a throw
//      // occurring.
//
//      std::memcpy(divider, start, (divider - start) * sizeof(TestType));
//
//      bslalg::AutoArrayMoveDestructor&lt;TestType&gt; guard(start,
//                                                      divider,
//                                                      divider,
//                                                      finish);
//
//      while (guard.middle() &lt; guard.end()) {
//          // Call the copy c&#39;tor, which may throw.
//
//          new (guard.destination()) TestType(value, allocator);
//
//          // &#39;guard.advance()&#39; increments &#39;guard.destination()&#39; and
//          // &#39;guard.middle()&#39; by one.
//
//          guard.advance();
//      }
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_ARRAYDESTRUCTIONPRIMITIVES
#include &lt;bslalg_arraydestructionprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;        // std::size_t
#define INCLUDED_CSTDDEF
#endif

#ifndef INCLUDED_CSTRING
#include &lt;cstring&gt;        // memset, memcpy, memmove
#define INCLUDED_CSTRING
#endif

namespace BloombergLP {

namespace bslalg {

                    // =============================
                    // class AutoArrayMoveDestructor
                    // =============================

template &lt;class OBJECT_TYPE&gt;
class AutoArrayMoveDestructor {
    // This &#39;class&#39; provides a specialized proctor object that, upon
    // destruction and unless the &#39;release&#39; method has been called, bit-wise
    // moves the elements in a segment of an array of parameterized
    // &#39;OBJECT_TYPE&#39; back to some destination, and destroys some other elements
    // in an adjacent segment of the same array.  The elements destroyed are
    // delimited by the range &#39;[ begin(), middle() )&#39; and those moved to
    // &#39;destination()&#39; and in the range &#39;[ middle(), end() )&#39;.  Note that, once
    // constructed, &#39;begin()&#39; and &#39;end()&#39; remain fixed.  As the guard advances,
    // &#39;middle()&#39; and &#39;destination()&#39; move, reflecting the successful transfer
    // of data between the moving range and the destination.

    // DATA
    OBJECT_TYPE *d_dst_p;    // destination of the bit-wise move

    OBJECT_TYPE *d_begin_p;  // address of first element in guarded range

    OBJECT_TYPE *d_middle_p; // address of first moved element in guarded range
                             // which is also first address beyond last element
                             // destroyed in same guarded range

    OBJECT_TYPE *d_end_p;    // first address beyond last (moved) element in
                             // guarded range

    // CLASS INVARIANT
    BSLMF_ASSERT(bslmf::IsBitwiseMoveable&lt;OBJECT_TYPE&gt;::value);

  private:
    // NOT IMPLEMENTED
    AutoArrayMoveDestructor(const AutoArrayMoveDestructor&amp;);
    AutoArrayMoveDestructor&amp; operator=(const AutoArrayMoveDestructor&amp;);

  public:
    // CREATORS
    AutoArrayMoveDestructor(OBJECT_TYPE *destination,
                            OBJECT_TYPE *begin,
                            OBJECT_TYPE *middle,
                            OBJECT_TYPE *end);
        // Create a proctor for the sequence of elements of the parameterized
        // &#39;OBJECT_TYPE&#39; in the specified range &#39;[ begin, end )&#39; which, upon
        // destruction, moves the range &#39;[ begin, middle )&#39; to the specified
        // &#39;destination&#39; and destroys the &#39;[ middle, end )&#39; range.  The
        // behavior is undefined unless &#39;begin&#39;, &#39;middle&#39;, and &#39;end&#39; refer to
        // a contiguous sequence of initialized &#39;OBJECT_TYPE&#39; objects, where
        // &#39;begin &lt;= middle &lt;= end&#39;, and &#39;destination&#39; refers to a contiguous
        // sequence of (uninitialized) memory of sufficient size to hold
        // &#39;end - begin&#39; &#39;OBJECT_TYPE&#39; objects (which must not overlap
        // &#39;[begin, end)&#39;).

    ~AutoArrayMoveDestructor();
        // Bit-wise move the range &#39;[ middle(), end() )&#39; to the &#39;destination()&#39;
        // address and destroy &#39;[ begin(), middle() )&#39;.

    // MANIPULATORS
    void advance();
        // Increment both middle and destination pointers by one position.  The
        // behavior is undefined if this operation result in &#39;destination()&#39;
        // entering the &#39;[ begin(), end() )&#39; range.

    // ACCESSORS
    OBJECT_TYPE *begin() const;
        // Return the address at the beginning of the guarded range.

    OBJECT_TYPE *destination() const;
        // Return the destination address, to which the second portion of the
        // guarded range, delimited by &#39;[ middle(), end() )&#39;, will be moved
        // upon destruction, or 0 if this guard has been released.

    OBJECT_TYPE *end() const;
        // Return the address at the end of the guarded range.

    OBJECT_TYPE *middle() const;
        // Return the address at the middle of the guarded range.
};

// ===========================================================================
//                         INLINE FUNCTION DEFINITIONS
// ===========================================================================

                    // -----------------------------
                    // class AutoArrayMoveDestructor
                    // -----------------------------

// CREATORS
template &lt;class OBJECT_TYPE&gt;
inline
AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::AutoArrayMoveDestructor(
                                                      OBJECT_TYPE *destination,
                                                      OBJECT_TYPE *begin,
                                                      OBJECT_TYPE *middle,
                                                      OBJECT_TYPE *end)
: d_dst_p(destination)
, d_begin_p(begin)
, d_middle_p(middle)
, d_end_p(end)
{
    BSLS_ASSERT_SAFE(!begin  == !middle);  // neither or both are null
    BSLS_ASSERT_SAFE(!middle == !end);     // neither or both are null
    BSLS_ASSERT_SAFE(destination || begin == middle);
    BSLS_ASSERT_SAFE(begin  &lt;= middle);
    BSLS_ASSERT_SAFE(middle &lt;= end);

}

template &lt;class OBJECT_TYPE&gt;
AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::~AutoArrayMoveDestructor()
{
    BSLS_ASSERT_SAFE(!d_begin_p  == !d_middle_p);  // neither or both are null
    BSLS_ASSERT_SAFE(!d_middle_p == !d_end_p);     // neither or both are null
    BSLS_ASSERT_SAFE(d_dst_p || d_begin_p == d_middle_p);
    BSLS_ASSERT_SAFE(d_begin_p  &lt;= d_middle_p);
    BSLS_ASSERT_SAFE(d_middle_p &lt;= d_end_p);
    BSLS_ASSERT_SAFE(d_dst_p    &lt;  d_begin_p
                  || d_end_p    &lt;= d_dst_p
                  || d_middle_p == d_end_p);

    if (d_middle_p != d_end_p) {
        std::size_t numBytes = (char *)d_end_p - (char *)d_middle_p;
        std::memcpy(d_dst_p, d_middle_p, numBytes);
        ArrayDestructionPrimitives::destroy(d_begin_p, d_middle_p);
    }
}

// MANIPULATORS
template &lt;class OBJECT_TYPE&gt;
inline
void AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::advance()
{
    BSLS_ASSERT_SAFE(d_middle_p &lt; d_end_p);

    ++d_middle_p;
    ++d_dst_p;

    BSLS_ASSERT_SAFE(d_dst_p != d_begin_p || d_middle_p == d_end_p);
}

// ACCESSORS
template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::begin() const
{
    return d_begin_p;
}

template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::middle() const
{
    return d_middle_p;
}

template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::end() const
{
    return d_end_p;
}

template &lt;class OBJECT_TYPE&gt;
inline
OBJECT_TYPE *AutoArrayMoveDestructor&lt;OBJECT_TYPE&gt;::destination() const
{
    return d_dst_p;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
