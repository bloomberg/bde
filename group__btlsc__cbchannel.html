<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsc_cbchannel Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsc_cbchannel<br/>
<small>
[<a class="el" href="group__btlsc.html">Package btlsc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for stream-based data communication.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsc.html">btlsc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Protocol Hierarchy</a> </li>
<li>
<a href="#3.2">Non-Blocking Stream-Based Transport</a> <ul>
<li>
<a href="#3.2.1">Callback Functor Registration</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Buffered Transport</a> </li>
<li>
<a href="#3.4">Incomplete Transmissions: "Partial" and "Canceled"</a> <ul>
<li>
<a href="#3.4.1">Asynchronous Events</a> </li>
<li>
<a href="#3.4.2">Raw Transmissions</a> </li>
<li>
<a href="#3.4.3"><code>augStatus</code></a> </li>
</ul>
</li>
<li>
<a href="#3.5">Scatter/Gather (<code>readv</code>/<code>writev</code>)</a> </li>
<li>
<a href="#3.6">Synopsis</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for stream-based data communication. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a> </td><td>non-blocking stream-based channel protocol  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsc__timedcbchannel.html" title="Provide protocol for stream-based data communication with timeout.">Component btlsc_timedcbchannel</a>, <a class="el" href="group__btlsc__channel.html" title="Provide a protocol for synchronous stream-based communication.">Component btlsc_channel</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a></code>, that defines an abstract interface for an end-point of a bi-directional (full-duplex) non-blocking stream-based communication channel. The protocol supports efficient "buffered" transport and the syntax to enable efficient vector I/O operations (i.e., Unix-style scatter/gather "readv" and "writev"). Various forms of "partial transmission" authorizations (i.e., "raw" OS-level atomic operations and interruptions due to "asynchronous
 events") are also supported for each method as appropriate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Read and write operations are enqueued separately (facilitating full-duplex operation) and executed in order within each queue. In contrast, the relative sequence in which the "read" and "write" queues are serviced is implementation dependent. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Users can cancel enqueued operations via the <code>cancelRead</code>, 'cancelWrite, and <code>cancelAll</code> methods. Also, if a read (write) operation returns with a partial result (see below), all pending read (write) operations will be dequeued; the callback status will reflect the reason for the incomplete result. Such dequeued operations may be re-submitted (presumably after inspection of the callback status) at the user's discretion. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, users can invalidate the read and write portions of a channel separately, or the entire channel at once. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="protocol_hierarchy"></a> <a class="anchor" id="description.protocol_hierarchy"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Protocol Hierarchy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a></code> forms the base of an interface hierarchy; other interfaces may be defined by direct public inheritance: <br/>
<br/>
<div class="fragment"><pre class="fragment">                           ,----------------.
                          ( <a class="code" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a> )
                           `----------------<span class="stringliteral">&#39;</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="non-blocking_stream-based_transport"></a> <a class="anchor" id="description.non-blocking_stream-based_transport"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Non-Blocking Stream-Based Transport: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface establishes methods for non-blocking stream-based transport. A method call registers the I/O request and a user-supplied callback function object (functor), and returns immediately with a status indicating the success or failure of the registration. After successful registration, the channel eventually services the enqueued I/O operation and invokes the callback function, which in turn conveys the status of the transmission. Note that if the initial registration is not successful, the callback function will <em>not</em> be invoked. Also note that whether the callback is invoked before or after the registering method returns is not specified; in either case, if the registration was successful, then the return value will reflect success. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Enqueued read and write operations proceed asynchronously to one of four possible results: (1) "success" -- the specified number of bytes was transmitted, (2) "partial transmission" -- the operation was interrupted (e.g., via an asynchronous event), (3) "canceled transmission" -- the request was dequeued (either by the user or by the channel), or (4) "error" -- an implementation-dependent error occurred. In all cases, status information and any appropriately available data are communicated to the user via the registered callback function, including status information to distinguish among various reasons for incomplete transmissions (see below). The user may retry incomplete operations (with method arguments suitably adjusted), with a reasonable expectation of success. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, concrete non-blocking stream-based channels do a "best effort" in sending and receiving the specified data, but need not guarantee successful transmission. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="callback_functor_registration"></a> <a class="anchor" id="non-blocking_stream-based_transport.callback_functor_registration"></a> <a class="anchor" id="description.non-blocking_stream-based_transport.callback_functor_registration"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Callback Functor Registration: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once an operation is successfully initiated, a (reference-counted) copy of the (<code>bdlf</code>) callback functor is retained by the concrete channel until the callback is executed. Therefore, the user need not be concerned with preserving the resources explicitly used by the <code>bdlf</code> functor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="buffered_transport"></a> <a class="anchor" id="description.buffered_transport"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Buffered Transport: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Most (but not all) I/O operations support a "buffered" variant that may be more efficient in some situations. For such operations, the prefix "buffered" (or infix "Buffered") appears before the basic operation name in the full method name (e.g., <code>bufferedRead</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "buffered" read operations optimize throughput (as opposed to latency) for relatively small transmissions under high-volume conditions. The specific buffered-read method signatures enable the concrete transport to read as much as it efficiently can (i.e., without blocking) and buffer that information for current and future use. In the buffered variant, the caller does not provide a buffer, but rather receives direct (non-modifiable) access to the implementation's buffered data. In the event of a partial read (see below), the data remains buffered and subsequent reads will behave as if the buffered operation had never occurred. Once a buffered read operation succeeds (i.e., receives the requested number of bytes) the buffered contents will become invalid after the callback function returns. Note that "buffered" and "vector" (<code>readv</code>, see below) are incompatible read options. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "buffered" write operations relieve the caller from having to preserve an input buffer during processing. A "buffered write" operation transmits as much data as possible without blocking, and then copies any remaining data to a buffer owned by the channel for eventual transmission. Note that the callback function is not invoked until the I/O operation terminates (successfully or otherwise, see above). Also note that "buffered" and "raw" (see below) are incompatible write options. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="incomplete_transmissions~3A_~22partial~22_and_~22canceled~22"></a> <a class="anchor" id="description.incomplete_transmissions~3A_~22partial~22_and_~22canceled~22"></a> <a class="anchor" id="incomplete_transmissions"></a> <a class="anchor" id="description.incomplete_transmissions"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Incomplete Transmissions: "Partial" and "Canceled": </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "simple" results of read and write operations are "success" (with a status equal to the requested number of bytes) and "error" (with a negative status). More complex behavior is also supported, some of which is at the option of the user. Specifically, the caller may authorize the possibility of another outcome via combinations of the following two mechanisms: (1) an interruption due to an asynchronous event and (2) a "raw" operation, i.e., accepting the results of a single low-level (implementation dependent) atomic read/write operation. These three mechanisms (discussed in more detail below) may each result in a "partial transmission", characterized by a non-negative status that is less than the requested number of bytes. Note that asynchronous events, but <em>not</em> raw operations, may result in a return status of zero bytes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A return status of exactly zero bytes may also occur via a fourth mechanism. As discussed above, an enqueued operation may be dequeued due to the partial-transmission status of a prior operation. Also, the <code>cancelRead</code>, <code>cancelWrite</code>, and <code>cancelAll</code> methods may be used to dequeue all enqueued requests from the read queue, the write queue, and both queues, respectively. All such dequeued operations result in "canceled
 transmissions". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>"Partial" and "canceled" transmissions share some common characteristics, and so are collectively referred to as "incomplete transmissions". The specific cause of an incomplete transmission (as deduced from "status") can in turn be determined by examining a second status value, called the "augStatus", described in detail below. All incomplete transmissions may be re-submitted with a reasonable expectation of success. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="asynchronous_events"></a> <a class="anchor" id="incomplete_transmissions.asynchronous_events"></a> <a class="anchor" id="description.incomplete_transmissions.asynchronous_events"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Asynchronous Events: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Methods in this protocol anticipate the possible occurrence of an "asynchronous event" (AE) during execution. This interface cannot specify what an AE is, but a common example of an AE is a Unix signal. Note, however, that a Unix signal need not be an AE, and an AE certainly need not be a signal. It is up to the concrete implementation to define what is and is not an AE. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since the specific nature of an AE is not defined here, method behavior resulting from an AE likewise cannot be fully specified. Rather, certain restrictions are imposed. By default, AEs are either ignored or, if that is not possible, cause an error. The user may, however, choose to authorize (when a method is invoked) that an AE causes a concrete implementation to return, if possible, a "partial transmission" (which may be resumed -- see above). This authorization is made by incorporating (i.e., bitwise OR-ing) the <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code> value into an optional (trailing) integer <code>flags</code> argument to the method call. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="raw_transmissions"></a> <a class="anchor" id="incomplete_transmissions.raw_transmissions"></a> <a class="anchor" id="description.incomplete_transmissions.raw_transmissions"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Raw Transmissions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>All read and unbuffered write operations support a "raw" variant in which the function is allowed to return with a "partial transmission" if (1) <em>at</em> <em>least</em> <em>one</em> <em>byte</em> has been transmitted and (2) no additional bytes are <em>immediately</em> transmittable. The "raw" mode is particularly useful to callers waiting for some read activity, who will then follow up with additional read requests after observing the initial transmission. Raw transmissions are authorized by methods whose names end in the suffix <code>Raw</code>. Note that the "raw" mode is not supported (and nonsensical) for buffered-write operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="augstatus"></a> <a class="anchor" id="incomplete_transmissions.augstatus"></a> <a class="anchor" id="description.incomplete_transmissions.augstatus"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>augStatus: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since any enqueued I/O request can be dequeued (canceled) by the channel or the user, and the user can authorize various modes supporting "partial
 transmission", the caller may wish to know the cause of an incomplete transmission. Callback functions therefore take a second <code>int</code> status value, <code>augStatus</code> ("augmented status"). This value will be positive if the interruption was due to an "asynchronous event" and negative if the request was dequeued by the channel or the user. Note that an <code>augStatus</code> of zero is not possible for this protocol; the zero value is reserved for protocols supporting timeouts. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="scatter~2Fgather_(readv~2Fwritev)"></a> <a class="anchor" id="description.scatter~2Fgather_(readv~2Fwritev)"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Scatter/Gather (readv/writev): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface supports "vector I/O" -- the simultaneous reading from or writing to multiple buffers -- via Unix-style <code>readv</code> and <code>writev</code> variants of the normal single-buffer methods. These vector methods rely on two auxiliary data structures defined in the <code>btls_iovec</code> component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> structure will be familiar to most Unix systems programmers. The <code>Ovec</code> variant enables read operations to avoid having to cast away <code>const</code> in order to hold the address of non-modifiable data to be written. In either structure, the total number of bytes to be read or written is determined by the sum of the non-negative <code>length</code> method values in the contiguous sequence of structures supplied to the method along with a <em>positive</em> sequence length (note that at least one of the <code>length</code> values must be positive). The following simple example shows how to create and populate an <code>Ovec</code> structure array in preparation for a <code>bufferedWritev</code> operation: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">static</span> <span class="keywordtype">void</span> myPrintWriteStatus(<span class="keywordtype">int</span> status,
                                     <span class="keywordtype">int</span> augStatus,
                                     <span class="keywordtype">int</span> numBytes)
          <span class="comment">// Print to the user console the result of attempting to write the</span>
          <span class="comment">// specified &#39;numBytes&#39; based on the specified write &#39;status&#39; and</span>
          <span class="comment">// the auxiliary &#39;augStatus&#39; (discussed below).  The behavior is</span>
          <span class="comment">// undefined unless &#39;0 &lt; numBytes&#39; and &#39;status &lt;= numBytes&#39;.  Note</span>
          <span class="comment">// that &#39;augStatus&#39; is ignored unless &#39;0 &lt;= status &lt; numBytes&#39;.</span>
     {
         assert(0 &lt; numBytes);
         assert(status &lt;= numBytes);

         <span class="keywordflow">if</span> (status == numBytes) {
             bsl::cout &lt;&lt; <span class="stringliteral">&quot;All requested bytes written successfully.&quot;</span>
                       &lt;&lt; bsl::endl;
         }
         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 &lt;= status) { <span class="comment">// PARTIAL RESULTS ARE NOT AUTHORIZED BELOW</span>

             <span class="keywordflow">if</span> (0 &lt; augStatus) {
                 bsl::cout &lt;&lt; <span class="stringliteral">&quot;Write interrupted after writing &quot;</span>
                           &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; numBytes &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span>
                           &lt;&lt; bsl::endl;
             }
             <span class="keywordflow">else</span> {
                 assert(augStatus &lt; 0);
                 <span class="keywordflow">if</span> (0 == status) {
                     bsl::cout
                             &lt;&lt; <span class="stringliteral">&quot;Write operation dequeued due to partial &quot;</span>
                             &lt;&lt; <span class="stringliteral">&quot;write in some preceding enqueued operation.&quot;</span>
                             &lt;&lt; bsl::endl;
                 }
                 <span class="keywordflow">else</span> {
                     assert(status &gt; 0);
                     bsl::cout &lt;&lt; <span class="stringliteral">&quot;Write (efficiently) transmitted &quot;</span>
                               &lt;&lt; status
                               &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; numBytes &lt;&lt; bytes.<span class="stringliteral">&quot; &lt;&lt; bsl::endl;</span>
<span class="stringliteral">                 }</span>
<span class="stringliteral">             }</span>
<span class="stringliteral">         }</span>
<span class="stringliteral">         else if (-1 == status) {</span>
<span class="stringliteral">             bsl::cout &lt;&lt; &quot;</span>Write failed: connection was closed by peer.<span class="stringliteral">&quot;</span>
<span class="stringliteral">                       &lt;&lt; bsl::endl;</span>
<span class="stringliteral">         }</span>
<span class="stringliteral">         else {</span>
<span class="stringliteral">             assert(status &lt; -1);</span>
<span class="stringliteral">             bsl::cout &lt;&lt; &quot;</span>Write failed: the reason is unknown.<span class="stringliteral">&quot;</span>
<span class="stringliteral">                       &lt;&lt; bsl::endl;</span>
<span class="stringliteral">         }</span>
<span class="stringliteral">     }</span>
<span class="stringliteral"></span>
<span class="stringliteral">     void myWritevAndPrintStatusWhenAvailable(btlsc::CbChannel *channel)</span>
<span class="stringliteral">         // Write the integer representation of the length of a character</span>
<span class="stringliteral">         // string followed by the (non-terminated) string data itself to</span>
<span class="stringliteral">         // the specified &#39;channel&#39;; upon completion, report the status</span>
<span class="stringliteral">         // of the &quot;</span>write<span class="stringliteral">&quot; operation to &#39;cout&#39;.</span>
<span class="stringliteral">     {</span>
<span class="stringliteral">         const char *const MESSAGE     = &quot;</span>Hello World!<span class="stringliteral">&quot;;</span>
<span class="stringliteral">         const int         HEADER      = strlen(MESSAGE);</span>
<span class="stringliteral">         const int         NUM_BUFFERS = 2;</span>
<span class="stringliteral"></span>
<span class="stringliteral">         btls::Ovec buffers[NUM_BUFFERS];</span>
<span class="stringliteral"></span>
<span class="stringliteral">         buffers[0].setBuffer(&amp;HEADER, sizeof HEADER);</span>
<span class="stringliteral">         buffers[1].setBuffer(MESSAGE, HEADER);</span>
<span class="stringliteral"></span>
<span class="stringliteral">         const int TOTAL_NUM_BYTES = buffers[0].length()</span>
<span class="stringliteral">                                   + buffers[1].length());</span>
<span class="stringliteral"></span>
<span class="stringliteral">         // Create a functor.</span>
<span class="stringliteral"></span>
<span class="stringliteral">         using namespace bdlf::PlaceHolders;</span>
<span class="stringliteral">         btlsc::CbChannel::WriteCallback functor(</span>
<span class="stringliteral">         bdlf::BindUtil::bind(&amp;myPrintWriteStatus, _1, _2, TOTAL_NUM_BYTES));</span>
<span class="stringliteral"></span>
<span class="stringliteral">         if (0 != channel-&gt;bufferedWritev(buffers, NUM_BUFFERS)) {</span>
<span class="stringliteral">             bsl::cout &lt;&lt; &quot;</span>Buffered write operation failed immediately!<span class="stringliteral">&quot;</span>
<span class="stringliteral">                       &lt;&lt; bsl::endl;</span>
<span class="stringliteral">         }</span>
<span class="stringliteral"></span>
<span class="stringliteral">         // Notice that the &#39;bufferedWritev&#39; operation above does not</span>
<span class="stringliteral">         // authorize any partial write operations whatsoever.  When</span>
<span class="stringliteral">         // invoked, the &quot;</span>status<span class="stringliteral">&quot; passed to the callback will be either</span>
<span class="stringliteral">         // &#39;TOTAL_NUM_BYTES&#39; for *success* or negative for *error*</span>
<span class="stringliteral">         // (baring some other pending &quot;</span>write<span class="stringliteral">&quot; operation on this channel</span>
<span class="stringliteral">         // that explicitly enabled a partial result).</span>
<span class="stringliteral">    }</span>
</pre></div><br/>
<br/>
 Note that once the <code>bufferedWritev</code> operation returns, there is no need to preserve either the output buffers or the array of <code>Ovec</code> (or <code>Iovec</code>) structures used to identify them (they would potentially be needed only to continue after a partial write, say, due to an interruption if such were authorized). By contrast, both the output buffers and the array of <code>Ovec</code> (or <code>Iovec</code>) structures must remain valid until an <em>unbuffered</em> <code>writev</code> operation completes and its corresponding <code>WriteCallback</code> is invoked. Since all <code>readv</code> operations are necessarily unbuffered, both the array of <code>Iovec</code> structures and each input buffer must remain valid until the <code>readv</code> operation completes and its <code>ReadCallback</code> is invoked. Note that "vectored" and "buffered" reads are inherently incompatible. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synopsis"></a> <a class="anchor" id="description.synopsis"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following chart summarizes the set of 20 transmission methods that are available to read and write data from and to a <code><a class="el" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a></code>; note that, for efficiency reasons, only three vector operations, <code>readvRaw</code>, <code>writevRaw</code>, and <code>bufferedWritev</code> are provided. Also, the "buffered write
 raw" operations are not supported by this protocol: <br/>
<br/>
<div class="fragment"><pre class="fragment">    Buffered    Re/Wr    Vec    Raw    Method Name
    --------    -----    ---    ---    ---------------
                READ                   read
                READ            RAW    readRaw

                READ     VEC    RAW    readvRaw

    BUFFERED    READ                   bufferedRead
    BUFFERED    READ            RAW    bufferedReadRaw

                WRITE                  write
                WRITE           RAW    writeRaw

                WRITE    VEC    RAW    writevRaw

    BUFFERED    WRITE                  bufferedWrite
    BUFFERED    WRITE    VEC           bufferedWritev
</pre></div><br/>
<br/>
 Each of these methods supports the specification of a flag value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a>
</pre></div><br/>
<br/>
 supplied in an optional trailing integer to enable interruptions due to "asynchronous events" to result in partial transmissions; by default, asynchronous events are ignored. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following summarizes the return status values for a request to transmit <code>N</code> bytes. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="stringliteral">&#39;status&#39;</span>     <span class="stringliteral">&#39;augStatus&#39;</span>    meaning
  ----------    ----------    --------------------------------------------
      N             x         Success
  [0..(N-1)]     positive     Interruption by an <span class="stringliteral">&quot;asynchronous event&quot;</span>
  [1..(N-1)]        x         Raw operation could not complete w/o blocking
      0          negative     Pending operation dequeued before execution
  negative          x         Error
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
