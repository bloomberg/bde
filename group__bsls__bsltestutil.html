<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bsls_bsltestutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_bsltestutil<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide test utilities for <code>bsl</code> that do not use &lt;iostream&gt;.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Usage</a> <ul>
<li>
<a href="#4.1.1">Example 1: Writing a Test Driver</a> </li>
<li>
<a href="#4.1.2">Example 2: Adding Support For A New User-Defined Type</a> </li>
<li>
<a href="#4.1.3">Example 3: Printing Unusual Types with <code>printf</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide test utilities for <code>bsl</code> that do not use &lt;iostream&gt;. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsls_1_1BslTestUtil.html">bsls::BslTestUtil</a> </td><td>utilities to aid writing <code>bsl</code> test drivers  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="bsls__bsltestutil_8h.html#a33ccbde339f78db66d2b902188146160">BSLS_BSLTESTUTIL_LOOP_ASSERT( I, X)</a>  </td><td>print args if <code>!X</code>  </td></tr>
<tr>
<td><a class="el" href="bsls__bsltestutil_8h.html#a30282f699747101080f1961272ef1deb">BSLS_BSLTESTUTIL_LOOP2_ASSERT(I, J, X)</a>  </td><td>print args if <code>!X</code>  </td></tr>
<tr>
<td><a class="el" href="bsls__bsltestutil_8h.html#ab052d940009f3bc6a6bc353cac0f280e">BSLS_BSLTESTUTIL_LOOP3_ASSERT(I, J, K, X)</a>  </td><td>print args if <code>!X</code>  </td></tr>
<tr>
<td><a class="el" href="bsls__bsltestutil_8h.html#afd71602f0a1bda2921accdc478d7e91b">BSLS_BSLTESTUTIL_LOOP4_ASSERT(I, J, K, L, X)</a>  </td><td>print args if <code>!X</code>  </td></tr>
<tr>
<td><a class="el" href="bsls__bsltestutil_8h.html#a0a9aa70669830bad6ddead3912e66bdf">BSLS_BSLTESTUTIL_LOOP5_ASSERT(I, J, K, L, M, X)</a>  </td><td>print args if <code>!X</code>  </td></tr>
<tr>
<td><a class="el" href="bsls__bsltestutil_8h.html#ac1373ac87e57a0112d80630efcd8ab92">BSLS_BSLTESTUTIL_LOOP6_ASSERT(I, J, K, L, M, N, X)</a> </td><td>print args if <code>!X</code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="el" href="bsls__bsltestutil_8h.html#a03d4c472006a6b9571611d95896759dd">BSLS_BSLTESTUTIL_Q(X)</a> : quote identifier literally <a class="el" href="bsls__bsltestutil_8h.html#aaf057216ba98f4a8ccee31220862aed7">BSLS_BSLTESTUTIL_P(X)</a> : print identifier and value <a class="el" href="bsls__bsltestutil_8h.html#a150ba17c509fd88418789854d60d0c29">BSLS_BSLTESTUTIL_P_(X)</a>: print identifier and value without <code>\n</code> BSLS_BSLTESTUTIL_L_ : current line number BSLS_BSLTESTUTIL_T_ : print tab without <code>\n</code> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>BSLS_BSLTESTUTIL_FORMAT_ZU : <code>printf</code> format for <code>size_t</code> BSLS_BSLTESTUTIL_FORMAT_TD : <code>printf</code> format for <code>ptrdiff_t</code> BSLS_BSLTESTUTIL_FORMAT_I64: <code>printf</code> format for unsigned 64-bit integers BSLS_BSLTESTUTIL_FORMAT_U64: <code>printf</code> format for signed 64-bit integers </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides standard facilities for for components in the <code>bsl</code> package group to produce test driver output, including the standard printing macros used in BDE-style test drivers (<code>ASSERT</code>, <code>LOOP_ASSERT</code>, <code>ASSERTV</code>, <code>P</code>, <code>Q</code>, <code>L</code>, and <code>T</code>), and a suite of cross-platform format strings for printing C++ or BDE-specific types with <code>printf</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Many components in the <code>bsl</code> package group reside below the standard library; therefore, hierarchical design dictates that the test driver for these components shall not use <code>iostream</code> (which is part of the standard library), and instead they shall only rely on the <code>printf</code> function to print objects' values. Using <code>printf</code> over <code>iostream</code> has the following disadvantages: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
The <code>printf</code> function requires a format string to specify the way to print an object; so, unlike <code>iostream</code>, printing different types of objects using <code>printf</code> requires different syntaxes due to the need for different format strings.  </li>
<li>
While the format strings for built-in types can be included as part of the standard boiler plate code of the test driver, printing a user-defined type often requires additional code that is not part of the standard boilerplate.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides solutions to the these issues by (1) encapsulating all the standard printing macros in a single place, (2) providing a way to extend the supplied macros to support user-defined types, and (3) providing macros that resolve the correct <code>printf</code> format strings for types that do not have standard, cross-platform format strings of their own. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The macros in this component use a class method template, <code>BslTestUtil::callDebugprint</code>, to print the value of an object of the parameterized type, along with an optional leading string and an optional trailing string, to the console. The value of the object of the parameterized type will be printed using a free function named <code>debugprint</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The macros defined in this component natively support built-in type through the <code>debugprint</code> function overloads for these types defined in this component. The macros can be extended support additional user-defined types by defining function overloads for <code>debugprint</code> that takes a single parameter of each user-defined type, in the same namespace in which the user-defined type is defined. See the second usage example for more details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_writing_a_test_driver"></a> <a class="anchor" id="usage.example_1~3A_writing_a_test_driver"></a> <a class="anchor" id="description.usage.example_1~3A_writing_a_test_driver"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="4.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Writing a Test Driver: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we write a component to test, which provides a utility class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">namespace </span>bslabc {

  <span class="keyword">struct </span>BslExampleUtil {
      <span class="comment">// This utility class provides sample functionality to demonstrate how</span>
      <span class="comment">// a test driver might be written validating its only method.</span>

      <span class="keyword">static</span> <span class="keywordtype">int</span> fortyTwo();
          <span class="comment">// Return the integer value &#39;42&#39;.</span>
  };

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> BslExampleUtil::fortyTwo()
  {
      <span class="keywordflow">return</span> 42;
  }

  }  <span class="comment">// close package namespace</span>
</pre></div><br/>
<br/>
 Then, we can write a test driver for this component. We start by providing the standard BDE assert test macro: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ========================================================================</span>
  <span class="comment">//                       STANDARD BDE ASSERT TEST MACRO</span>
  <span class="comment">// ------------------------------------------------------------------------</span>
  <span class="keyword">static</span> <span class="keywordtype">int</span> testStatus = 0;

  <span class="keyword">static</span> <span class="keywordtype">void</span> aSsErT(<span class="keywordtype">bool</span> b, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> i)
  {
      <span class="keywordflow">if</span> (b) {
          printf(<span class="stringliteral">&quot;Error &quot;</span> __FILE__ <span class="stringliteral">&quot;(%d): %s    (failed)\n&quot;</span>, i, s);
          <span class="keywordflow">if</span> (testStatus &gt;= 0 &amp;&amp; testStatus &lt;= 100) ++testStatus;
      }
  }

<span class="preprocessor">  # define ASSERT(X) { aSsErT(!(X), #X, __LINE__); }</span>
</pre></div><br/>
<br/>
 Next, we define the standard print and <code>LOOP_ASSERT</code> macros, as aliases to the macros defined by this component: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ========================================================================</span>
  <span class="comment">//                       STANDARD BDE TEST DRIVER MACROS</span>
  <span class="comment">// ------------------------------------------------------------------------</span>
<span class="preprocessor">  #define LOOP_ASSERT  BSLS_BSLTESTUTIL_LOOP_ASSERT</span>
<span class="preprocessor"></span><span class="preprocessor">  #define LOOP2_ASSERT BSLS_BSLTESTUTIL_LOOP2_ASSERT</span>
<span class="preprocessor"></span><span class="preprocessor">  #define LOOP3_ASSERT BSLS_BSLTESTUTIL_LOOP3_ASSERT</span>
<span class="preprocessor"></span><span class="preprocessor">  #define LOOP4_ASSERT BSLS_BSLTESTUTIL_LOOP4_ASSERT</span>
<span class="preprocessor"></span><span class="preprocessor">  #define LOOP5_ASSERT BSLS_BSLTESTUTIL_LOOP5_ASSERT</span>
<span class="preprocessor"></span><span class="preprocessor">  #define LOOP6_ASSERT BSLS_BSLTESTUTIL_LOOP6_ASSERT</span>
<span class="preprocessor"></span>
<span class="preprocessor">  #define Q   BSLS_BSLTESTUTIL_Q   // Quote identifier literally.</span>
<span class="preprocessor"></span><span class="preprocessor">  #define P   BSLS_BSLTESTUTIL_P   // Print identifier and value.</span>
<span class="preprocessor"></span><span class="preprocessor">  #define P_  BSLS_BSLTESTUTIL_P_  // &#39;P(X)&#39; without &#39;\n&#39;.</span>
<span class="preprocessor"></span><span class="preprocessor">  #define T_  BSLS_BSLTESTUTIL_T_  // Print a tab (w/o newline).</span>
<span class="preprocessor">  #define L_  BSLS_BSLTESTUTIL_L_  // current Line number</span>
</pre></div><br/>
<br/>
 Now, using the (standard) abbreviated macro names we have just defined, we write a test function for the <code>static</code> <code>fortyTwo</code> method, to be called from a test case in a test driver. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testFortyTwo(<span class="keywordtype">bool</span> verbose)
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> value = bslabc::BslExampleUtil::fortyTwo();
      <span class="keywordflow">if</span> (verbose) <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a>(value);
      LOOP_ASSERT(value, 42 == value);
  }
</pre></div><br/>
<br/>
 Finally, when <code>testFortyTwo</code> is called from a test case in verbose mode we observe the console output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  value = 42
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_adding_support_for_a_new_user-defined_type"></a> <a class="anchor" id="usage.example_2~3A_adding_support_for_a_new_user-defined_type"></a> <a class="anchor" id="description.usage.example_2~3A_adding_support_for_a_new_user-defined_type"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="4.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Adding Support For A New User-Defined Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a new user-defined type, <code>MyType</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">namespace </span>xyza {

  <span class="keyword">class </span>MyType {
      <span class="comment">// This elided class provides a type intended to show how the macros in</span>
      <span class="comment">// &#39;bsls_bsltestutil&#39; can be extended to support a new user-defined</span>
      <span class="comment">// type.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_value;  <span class="comment">// the value of MyType</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>

      <span class="comment">// ...</span>

      <span class="keyword">explicit</span> MyType(<span class="keywordtype">int</span> value);
          <span class="comment">// Create a &#39;MyType&#39; object with &#39;d_value&#39; set to the specified</span>
          <span class="comment">// &#39;value&#39;.</span>

      <span class="comment">// ACCESSORS</span>

      <span class="comment">// ...</span>

      <span class="keywordtype">int</span> value() <span class="keyword">const</span>;
          <span class="comment">// Return the value of &#39;d_value&#39;.</span>

      <span class="comment">// ...</span>
  };

  <span class="comment">// ...</span>

  <span class="keyword">inline</span>
  MyType::MyType(<span class="keywordtype">int</span> value)
  : d_value(value)
  {
  }

  <span class="comment">// ...</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyType::value()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_value;
  }
</pre></div><br/>
<br/>
 Then, in the same namespace in which <code>MyType</code> is defined, we define a function <code>debugprint</code> that prints the value of a <code>MyType</code> object to the console. (In this case, we will simply print a string literal for simplicity): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> <a class="code" href="namespacebsls.html#adaddaf11e612254a0f2f50ef0ddf76fb">debugprint</a>(<span class="keyword">const</span> MyType&amp; obj)
  {
      printf(<span class="stringliteral">&quot;MyType&lt;%d&gt;&quot;</span>, obj.value());
  }

  }  <span class="comment">// close namespace xyza</span>
</pre></div><br/>
<br/>
 Now, using the (standard) abbreviated macro names previously defined, we write a test function for the <code>MyType</code> constructor, to be called from a test case in a test driver. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testMyTypeSetValue(<span class="keywordtype">bool</span> verbose) {
      xyza::MyType obj(9);
      <span class="keywordflow">if</span> (verbose) <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a>(obj);
      LOOP_ASSERT(obj.value(), obj.value() == 9);
  }
</pre></div><br/>
<br/>
 Finally, when <code>testMyTypeSetValue</code> is called from a test case in verbose mode we observe the console output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  obj = MyType&lt;9&gt;
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_printing_unusual_types_with_printf"></a> <a class="anchor" id="usage.example_3~3A_printing_unusual_types_with_printf"></a> <a class="anchor" id="description.usage.example_3~3A_printing_unusual_types_with_printf"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="4.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Printing Unusual Types with printf: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we are writing a test driver that needs to print out the contents of a complex data structure in <code>veryVeryVerbose</code> mode. The complex data structure contains, among other values, an array of block sizes, expressed as <code>size_t</code>. It would be very cumbersome, and visually confusing, to print each member of the array with either the <code>P_</code> or <code>Q_</code> standard output macros, so we elect to print out the array as a single string, following the pattern of <code>[ A, B, C, D, E, ... ]</code>. This could be easily accomplished with multiple calls to <code>printf</code>, except that <code>printf</code> has no cross-platform standard formatting string for <code>size_t</code>. We can use the <code>BSLS_BSLTESTUTIL_FORMAT_ZU</code> macro to resolve the appropriate format string for us on each platform. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we write a component to test, which provides an a utility that operates on a list of memory blocks. Each block is a structure containing a base address, a block size, and a pointer to the next block in the list. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">namespace </span>xyza {
  <span class="keyword">struct </span>Block {
      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span>   *d_address;
      <span class="keywordtype">size_t</span>  d_size;
      Block  *d_next;

      <span class="comment">// ...</span>
  };

  <span class="keyword">class </span>BlockList {
      <span class="comment">// ...</span>

      <span class="comment">// DATA</span>
      Block *d_head;

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      BlockList();
      ~BlockList();

      <span class="comment">// MANIPULATORS</span>

      Block *begin();
      Block *end();

      <span class="keywordtype">void</span> addBlock(<span class="keywordtype">size_t</span> size);

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> length();

      <span class="comment">// ...</span>
  };

  }  <span class="comment">// close namespace xyza</span>
</pre></div><br/>
<br/>
 Then, we write a test driver for this component. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ...</span>

  <span class="comment">// ========================================================================</span>
  <span class="comment">//                       STANDARD BDE TEST DRIVER MACROS</span>
  <span class="comment">// ------------------------------------------------------------------------</span>

  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Here, after defining the standard BDE test macros, we define a macro, <code>ZU</code> for the platform-specific <code>printf</code> format string for <code>size_t</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ========================================================================</span>
  <span class="comment">//                          PRINTF FORMAT MACROS</span>
  <span class="comment">// ------------------------------------------------------------------------</span>
<span class="preprocessor">  #define ZU BSLS_BSLTESTUTIL_FORMAT_ZU</span>
</pre></div><br/>
<br/>
 Note that, we could use <code>BSLS_BSLTESTUTIL_FORMAT_ZU</code> as is, but it is more convenient to define <code>ZU</code> locally as an abbreviation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we write the test apparatus for the test driver, which includes a support function that prints the list of blocks in a <code>BlockList</code> in a visually succinct form: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> printBlockList(xyza::BlockList &amp;list)
  {
      xyza::Block *blockPtr = list.begin();

      printf(<span class="stringliteral">&quot;{\n&quot;</span>);
      <span class="keywordflow">while</span> (blockPtr != list.end()) {
</pre></div><br/>
<br/>
 Here, we use <code>ZU</code> as the format specifier for the <code>size_t</code> in the <code>printf</code> invocation. <code>ZU</code> is the appropriate format specifier for <code>size_t</code> on each supported platform. <br/>
<br/>
<div class="fragment"><pre class="fragment">          printf(<span class="stringliteral">&quot;\t{ address: %p,\tsize: &quot;</span> ZU <span class="stringliteral">&quot; }&quot;</span>,
                 blockPtr-&gt;d_address,
                 blockPtr-&gt;d_size);
          blockPtr = blockPtr-&gt;d_next;

          <span class="keywordflow">if</span> (blockPtr) {
              printf(<span class="stringliteral">&quot;,\n&quot;</span>);
          } <span class="keywordflow">else</span> {
              printf(<span class="stringliteral">&quot;\n&quot;</span>);
          }
      }
      printf(<span class="stringliteral">&quot;}\n&quot;</span>);
  }
</pre></div><br/>
<br/>
 Note that because we are looping through a number of blocks, formatting the output directly with <code>printf</code> produces more readable output than we would get from callling the standard output macros. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Calling <code>printf</code> directly will yield output similar to: <br/>
<br/>
<div class="fragment"><pre class="fragment"> {
     { address: 0x012345600,    size: 32 },
     ...
 }
</pre></div><br/>
<br/>
 while the standard output macros would have produced: <br/>
<br/>
<div class="fragment"><pre class="fragment"> {
     { blockPtr-&gt;d_address = 0x012345600,    blockPtr-&gt;d_size: 32 },
     ...
 }
</pre></div><br/>
<br/>
 Now, we write a test function for one of our test cases, which provides a detailed trace of <code>BlockList</code> contents: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testBlockListConstruction(<span class="keywordtype">bool</span> veryVeryVerbose)
  {
      <span class="comment">// ...</span>

      {
          xyza::BlockList bl;

          bl.addBlock(42);
          bl.addBlock(19);
          bl.addBlock(1024);

          <span class="keywordflow">if</span> (veryVeryVerbose) {
              printBlockList(bl);
          }

          ASSERT(3 == bl.length());

          <span class="comment">// ...</span>
      }

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 Finally, when <code>testBlockListConstruction</code> is called from a test case in <code>veryVeryVerbose</code> mode, we observe console output similar to: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      { address: 0x012345600,    size: 42 },
      { address: 0x012345610,    size: 19 },
      { address: 0x012345620,    size: 1024 }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:54 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
