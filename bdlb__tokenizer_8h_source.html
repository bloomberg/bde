<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlb_tokenizer.h                                                   -*-C++-*-
#ifndef INCLUDED_BDLB_TOKENIZER
#define INCLUDED_BDLB_TOKENIZER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide access to user-described tokens via string references.
//
//@CLASSES:
//  bdlb::Tokenizer: lexer for tokens defined via hard and/or soft delimiters
//  bdlb::TokenizerIterator: input iterator for delimited tokens in a string
//
//@SEE_ALSO: bslstl_stringref
//
//@DESCRIPTION: This component defines a mechanism, &#39;bdlb::Tokenizer&#39;, that
// provides non-destructive sequential (read-only) access to tokens in a given
// input string as characterized by two disjoint sets of user-specified
// delimiter characters, each of which is supplied at construction via either a
// &#39;const bslstl::StringRef&amp;&#39; or (for efficiency, when only the leading
// characters of the input string may need to be parsed) a &#39;const char *&#39;.
// Note that each character (including &#39;\0&#39;) that is not explicitly designated
// as a delimiter character is assumed to be *token* character.
//
///Soft versus Hard Delimiters
///---------------------------
// The tokenizer recognizes two distinct kinds of delimiter characters, *soft*
// and *hard*.
//
// A *soft* *delimiter* is a maximal (non-empty) sequence of soft-delimiter
// characters.  Soft delimiters, typically whitespace characters, are used to
// separate (rather than terminate) tokens, and thus never result in an empty
// token.
//
// A *hard* *delimiter* is a maximal (non-empty) sequence of delimiter
// characters consisting of exactly one hard-delimiter character.  Hard
// delimiters, typically printable punctuation characters such (&#39;/&#39;) or colon
// (&#39;:&#39; ), are used to terminate (rather than just separate) tokens, and thus a
// hard delimiter that is not preceded by a token character results in an empty
// token.
//
// Soft delimiters are used in applications where multiple consecutive
// delimiter characters are to be treated as just a single delimiter.  For
// example, if we want the input string &quot;Sticks  and stones&quot; to parse into a
// sequence of three non-empty tokens [&quot;Sticks&quot;, &quot;and&quot;, &quot;stones&quot;], rather than
// the five-token sequence [&quot;Sticks&quot;, &quot;&quot;, &quot;&quot;, &quot;and&quot;, &quot;stones&quot;], we would make
// the space (&#39; &#39;) a soft-delimiter character.
//
// Hard delimiters are used in applications where consecutive delimiter
// characters are to be treated as separate delimiters, giving rise to the
// possibility of empty tokens.  Making the slash (&#39;/&#39;) in the standard date
// format a hard delimiter for the input string &quot;15//9&quot; yields the three-token
// sequence [&quot;15&quot;, &quot;&quot;, &quot;9&quot;], rather than the two-token one [&quot;15&quot;, &quot;9&quot;] had it
// been made soft.
//
// All members within each respective character set are considered equivalent
// with respect to tokenization.  For example, making &#39;/&#39; and &#39;:&#39; *soft*
// *delimiter* characters on the questionably formatted date &quot;2015/:10:/31&quot;
// would yield the token sequence [&quot;2015&quot;, &quot;10&quot;, &quot;31&quot;], whereas making &#39;/&#39; and
// &#39;:&#39; *hard* *delimiter* characters would result in the token sequence
// [&quot;2015&quot;, &quot;&quot;, &quot;10&quot;, &quot;&quot;, &quot;31&quot;].  Making either of these two delimiter
// characters hard and the other soft would, in this example, yield the former
// (shorter) sequence of tokens.  The details of how soft and hard delimiters
// interact is illustrated in more detail in the following section (but also
// see, later on, the section on &quot;Comprehensive Detailed Parsing
// Specification&quot;).
//
///The Input String to be Tokenized
///--------------------------------
// Each input string consists of an optional leading sequence of soft-delimiter
// characters called the *leader*, followed by an alternating sequence of
// tokens and delimiters (the final delimiter being optional):
//..
//  Input String:
//  +--------+---------+-------------+---...---+---------+-------------+
//  | leader | token_1 | delimiter_1 |         | token_N | delimiter_N |
//  +--------+---------+-------------+---...---+---------+-------------+
//  (optional)                                              (optional)
//..
// The tokenization of a string can also be expressed as pseudo-Posix regular
// expression notation:
//..
//   delimiter = [[:soft:]]+ | [[:soft:]]* [[:hard:]] [[:soft:]]*
//   token     = [^[:soft:][:hard:]]*
//   string    = [[:soft:]]* (token delimiter)* token?
//..
// Parsing is from left to right and is *greedy* -- i.e., the longest sequence
// satisfying the regular expression is the one that matches.  For example, let
// &#39;s&#39; represent the start of a soft delimiter, &#39;d&#39; the start of a hard
// delimiter, &#39;^&quot; the start of a token, and &#39;~&#39; the continuation of that same
// delimiter or token.  Using &#39;.&#39; as a soft delimiter and &quot;/&quot; as a hard one,
// the string
//..
//         s~   h~  h~~  h~     s~   hh  s  h~h    h~~~        Delimiters
//
//        &quot;..One/.if./.by./land,..two//if.by/./sea!./..&quot;
//
//           ^~~  ^~   ^~  ^~~~   ^~~ ^^~ ^~  ^^~~             Tokens
//                                    |       |
//                                 (empty)  (empty)
//..
// yields the tokenization
//..
//     [One]  [if]   [by]  [land,]  [two] [] [if] [by]  [] [sea]       Tokens
//
//  (..)   (/.)  (./.)  (./)     (..)   (/)(/)  (.)  (/.)(/)   (./..)  Delims
//..
// Notice that in pair of hard delimiters &quot;/./&quot; before the token &quot;sea&quot;, the
// soft token character between the two hard ones binds to the earlier
// delimiter.
//
///Iterating using a &#39;TokenizerIterator&#39; object (ACCESS TO TOKENS ONLY)
///--------------------------------------------------------------------
// This component provides two separate mechanisms by which a user may iterate
// over a sequence of tokens.  The first mechanism is as a *token* *range*,
// exposed by the &#39;TokenizerIterator&#39; objects returned by the &#39;begin&#39; and &#39;end&#39;
// methods on a &#39;Tokenizer&#39; object.  A &#39;TokenizerIterator&#39; supports the concept
// of a standard *input* *iterator*, returning each successive token as a
// &#39;bslstl::StringRef&#39;, making it suitable for generic use -- e.g., in a
// range-based &#39;for&#39; loop:
//..
//  void parse_1(bsl::ostream&amp; output, const char *input)
//      // Print, to the specified &#39;output&#39; stream, each whitespace-delimited
//      // token in the specified &#39;input; string on a separate line following
//      // a vertical bar (&#39;|&#39;) and a hard space (&#39; &#39;).
//  {
//      const char softDelimiters[] = &quot; \t\n&quot;;  // whitespace
//
//      for (bslstl::StringRef token : bdlb_Tokenizer(input, softDelimiters) {
//          bsl::cout &lt;&lt; &quot;| &quot; &lt;&lt; token &lt;&lt; bsl::endl;
//      }
//  }
//..
// The &#39;parse_1&#39; function above produces each (non-whitespace) token in the
// supplied input string on a separate line.  So, were &#39;parse_1&#39; to be given a
// reference to &#39;bsl::cout&#39; and the input string
//..
//  &quot; Times  like \tthese\n  try \n \t men&#39;s\t \tsouls.\n&quot;
//..
// we would expect
//..
//  | Times
//  | like
//  | these
//  | try
//  | men&#39;s
//  | souls.
//..
// to be displayed on &#39;bsl::cout&#39;.  Note that there is no way to access the
// delimiters from a &#39;TokenizerIterator&#39; directly, for that we will need to
// use the &#39;tokenizer&#39; as a non-standard &quot;iterator&quot; directly.
//
///Iterating using a &#39;Tokenizer&#39; object (ACCESS TO TOKENS AND DELIMITERS)
///----------------------------------------------------------------------
// The second mechanism, not intended for generic use, provides direct access
// to the previous and current (trailing) delimiters as well as the current
// token:
//..
//  void parse_2(bsl::outstream, const char *input)
//      // Print, to the specified &#39;output&#39; stream the leader of the specified
//      // &#39;input&#39;, on a singly line, followed by subsequent current token and
//      // (trailing) delimiter pairs on successive lines, each line beginning
//      // with a vertical bar (&#39;|&#39;) followed by a tab (&#39;\t&#39;) character.
//  {
//      const char softDelimiters[] = &quot; &quot;;
//      const char hardDelimiters[] = &quot;:/&quot;
//
//      bdlb_Tokenizer it(input, softDelimiters, hardDelimiters);
//      bsl::cout &lt;&lt; &quot;| &quot; &lt;&lt; &#39;&quot;&#39; &lt;&lt; it.previousDelimiter() &lt;&lt; &#39;&quot;&#39; &lt;&lt; bsl::endl;
//
//      for (; it; ++it) {
//          bsl::cout &lt;&lt; &quot;|\t&quot;
//                    &lt;&lt; &#39;&quot;&#39; &lt;&lt; it.token() &lt;&lt; &#39;&quot;&#39;
//                    &lt;&lt; &quot;\t&quot;
//                    &lt;&lt; &#39;&quot;&#39; &lt;&lt; it.delimiter() &#39;&quot;&#39;
//                    &lt;&lt; bsl::endl;
//      }
//..
// The parse_2 function above produces the *leader* on the first line,
// followed by each *token* along with its current (trailing) delimiter on
// successive lines.  So, were &#39;parse_2&#39; to be given a reference to
// &#39;bsl::cout&#39; and the input string
//..
//  &quot; I&#39;ve :been: a : :bad:/ boy! / &quot;
//..
// we would expect
//..
//  |       &quot; &quot;
//  |       &quot;I&#39;ve&quot;  &quot; :&quot;
//  |       &quot;been&quot;  &quot;: &quot;
//  |       &quot;a :&quot;   &quot; : &quot;
//  |       &quot;&quot;      &quot;:&quot;
//  |       &quot;bad&quot;   &quot;:&quot;
//  |       &quot;&quot;      &quot;/ &quot;
//  |       &quot;boy!&quot;  &quot; / &quot;
//..
// to be displayed on &#39;bsl::cout&#39;.
//
///Token and Delimiter Lifetimes
///-----------------------------
// All tokens and delimiters are returned efficiently by value as
// &#39;bslstl::StringRef&#39; objects, which naturally remain valid so long as the
// underlying input string remains unchanged -- irrespective of the validity
// of the &#39;tokenizer&#39; or any of its dispensed token iterators.  Note, however,
// that all such token iterators are invalidated if the parent tokenizer object
// is destroyed or reset.  Note also the previous delimiter field remains
// accessible from a &#39;tokenizer&#39; object even after it has reached the end of
// its input.  Also note that the *leader* is accessible, using the
// &#39;previousDelimiter&#39;, method prior to advancing the interation state of
// state of the &#39;Tokenizer&#39;.
//
///Comprehensive Detailed Parsing Specification
///--------------------------------------------
// This section provides a comprehensive (length-ordered) enumeration of how
// the &#39;bdlb::Tokenizer&#39; performs, according to its three (non-null) character
// types:
//..
//  &#39;.&#39; = any *soft* delimiter character
//  &#39;#&#39; = any *hard* delimiter character
//  &#39;T&#39; = any token character
//..
// Here&#39;s how iteration progresses for various input strings.  Note that input
// strings having consecutive characters of the same category that naturally
// coalesce (i.e., behave as if they were a single character of that category)
// -- namely soft-delimiter or token characters -- are labeled with &#39;(%)&#39;.
// For example, consider the input &quot;..&quot; at the top of the [length 2] section
// below.  The table indicates, with a (%) in the first column, that the input
// acts the same as if it were a single (soft-delimiter) character (i.e., &quot;.&quot;).
// There is only one line in this row of the table because, upon construction,
// the iterator is immediately invalid (as indicated by the right-most column).
// Now consider the &quot;##&quot; entry near the bottom of [length 2].  These
// (hard-delimiter) tokens do not coalesce.  What&#39;s more, the iterator on
// construction is valid and produces a empty leader and empty first token.
// after advancing the tokenizer, the second line of that row shows the
// current state of iteration with the previous delimiter being a &#39;#&#39; as well
// as the current one.  The current token is again shown as empty.  After
// advancing the tokenizer again, we now see that the iterater is invalid, yet
// the previous delimiter (still accessible) is a &#39;#&#39;).
//..
//  (%) = repeat   Previous   Current   Current   Iterator
//  Input String   Delimiter   Token   Delimiter   Status
//  ============   =========  =======  =========  ========  [length 0]
//  &quot;&quot;             &quot;&quot;         na       na         invalid
//
//  ============   =========  =======  =========  ========  [length 1]
//  &quot;.&quot;            &quot;.&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;#&quot;            &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;T&quot;            &quot;&quot;         &quot;T&quot;      &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//
//  ============   =========  =======  =========  ========  [length 2]
//  &quot;..&quot;     (%)   &quot;..&quot;       na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;.#&quot;           &quot;.&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;.T&quot;           &quot;.&quot;        &quot;T&quot;      &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//
//  ------------   ---------  -------  ---------  --------
//  &quot;#.&quot;           &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;##&quot;           &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;#T&quot;           &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;T&quot;      &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//
//  ------------   ---------  -------  ---------  --------
//  &quot;T.&quot;           &quot;&quot;         &quot;T&quot;      &quot;.&quot;        valid
//                 &quot;.&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;T#&quot;           &quot;&quot;         &quot;T&quot;      &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;TT&quot;     (%)   &quot;&quot;         &quot;TT&quot;     &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//
//  ============   =========  =======  =========  ========  [length 3]
//  &quot;...&quot;    (%)   &quot;...&quot;      na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;..#&quot;    (%)   &quot;..&quot;       &quot;&quot;       &quot;#&quot;        valid
//                   &quot;#&quot;      na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;..T&quot;    (%)   &quot;..&quot;       &quot;T&quot;      &quot;&quot;         valid
//                 &quot;..&quot;       na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;.#.&quot;          &quot;.&quot;        &quot;&quot;       &quot;#.&quot;       valid
//                 &quot;#.&quot;       na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;.##&quot;          &quot;.&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;.#T&quot;          &quot;.&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;T&quot;      &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;.T.&quot;          &quot;.&quot;        &quot;T&quot;      &quot;.&quot;        valid
//                 &quot;.&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;.T#&quot;          &quot;.&quot;        &quot;T&quot;      &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;.TT&quot;    (%)   &quot;.&quot;        &quot;TT&quot;     &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//
//  ------------   ---------  -------  ---------  --------
//  &quot;#..&quot;    (%)   &quot;&quot;         &quot;&quot;       &quot;#..&quot;      invalid
//                 &quot;#..&quot;      na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;#.#&quot;          &quot;&quot;         &quot;&quot;       &quot;#.&quot;       valid
//                 &quot;#.&quot;       &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;#.T&quot;          &quot;&quot;         &quot;&quot;       &quot;#.&quot;       valid
//                 &quot;#.&quot;       &quot;T&quot;      &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;##.&quot;          &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;&quot;       &quot;#.&quot;       valid
//                 &quot;#.&quot;       na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;###&quot;          &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;##T&quot;          &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;T&quot;      &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;#T.&quot;          &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;T&quot;      &quot;.&quot;        valid
//                 &quot;.&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;#T#&quot;          &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;T&quot;      &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;#TT&quot;    (%)   &quot;&quot;         &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;TT&quot;     &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//
//  ------------   ---------  -------  ---------  --------
//  &quot;T..&quot;    (%)   &quot;&quot;         &quot;T&quot;      &quot;..&quot;       valid
//                 &quot;..&quot;       na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;T.#&quot;          &quot;&quot;         &quot;T&quot;      &quot;.#&quot;       valid
//                 &quot;.#&quot;       na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;T.T&quot;          &quot;&quot;         &quot;T&quot;      &quot;.&quot;        valid
//                 &quot;.&quot;        &quot;T&quot;      &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;T#.&quot;          &quot;&quot;         &quot;T&quot;      &quot;#.&quot;       valid
//                 &quot;#.&quot;       na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;T##&quot;          &quot;&quot;         &quot;T&quot;      &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;&quot;       &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;T#T&quot;          &quot;&quot;         &quot;T&quot;      &quot;#&quot;        valid
//                 &quot;#&quot;        &quot;T&quot;      &quot;#&quot;        valid
//                 &quot;&quot;         na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;TT.&quot;    (%)   &quot;&quot;         &quot;TT&quot;     &quot;.&quot;        valid
//                 &quot;.&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;TT#&quot;    (%)   &quot;&quot;         &quot;TT&quot;     &quot;#&quot;        valid
//                 &quot;#&quot;        na       na         invalid
//  ------------   ---------  -------  ---------  --------
//  &quot;TTT&quot;    (%)   &quot;#&quot;        &quot;TTT&quot;    &quot;&quot;         valid
//                 &quot;&quot;         na       na         invalid
//  ------------   ---------  -------  ---------  --------
//..
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Iterating Over Tokens Using Just *Soft* Delimiters
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
///Example 2: Iterating Over Tokens Using Just *Hard* Delimiters
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
///Example 3: Iterating Over Tokens Using Both *Hard* and *Soft* Delimiters
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
///Example 4: Using the &#39;Tokenizer&#39; to Access Delimiters As Well As Tokens
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
///Example 5: Parsing Layers of Different Tokens Using Nested &#39;for&#39; Loops
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {

namespace bdlb {
                        // ============================
                        // private class Tokenizer_Data
                        // ============================

class Tokenizer_Data {
    // This component-private class is used to hold delimiter information.
    // Each &#39;Tokenizer&#39; object will have, as a private data member, an object
    // of this class,  and will pass the address of that member to the
    // (private) constructor of each &#39;TockenizerIterator&#39; object it issues:
    //..
    //  +--------------------------------------+
    //  |   ,--------------.                   |
    //  |  ( Tokenizer_Data )                  |
    //  |   `--------------&#39;\                  |
    //  |          |         \                 |
    //  |          |     ,----*------------.   |
    //  |          |    ( TokenizerIterator )  |
    //  |          |    /`-----------------&#39;   |
    //  |          |   /                       |
    //  |     ,----*--o-.                      |
    //  |    ( Tokenizer )                     |
    //  |     `---------&#39;                      |
    //  +--------------------------------------+
    //  bdlb_tokenizer
    //..

    enum {
        k_MAX_CHARS = 256  // maximum # of unique values for an 8-bit &#39;char&#39;
    };

    char d_charTypes[k_MAX_CHARS];  // table of SOFT / HARD / TOKEN characters

  private:
    // NOT IMPLEMENTED
    Tokenizer_Data(const Tokenizer_Data&amp;);
    Tokenizer_Data&amp; operator=(const Tokenizer_Data&amp;);

  public:
    // CREATORS
    explicit Tokenizer_Data(const bslstl::StringRef&amp; softDelimiters);
    Tokenizer_Data(const bslstl::StringRef&amp; softDelimiters,
                   const bslstl::StringRef&amp; hardDelimiters);
        // Create a &#39;Tokenizer_Data&#39; object and load the &#39;d_charTypes&#39; data
        // member such that it has the same value *as* *if* this (overly
        // prescriptive) algorithm were used: (I) initialize each entry in
        // &#39;d_charTypes&#39; array to a value indicating that the character having
        // that &#39;index&#39; as its (e.g., ASCII) representation is a *token*
        // character; (II) then, for each character in the specified
        // &#39;softDelimiters&#39; sequence, overwrite the element at the
        // corresponding index in &#39;d_charTypes&#39; with a value that indicates
        // that the character is a *soft* delimiter character; (III) finally,
        // for each character in the specified &#39;hardDelimiters&#39; sequence,
        // overwrite the element at the corresponding index with a distinct
        // value that indicates the character is a *hard* delimiter* character.
        // Note that duplicate delimiter characters in the respective inputs
        // are naturally ignored, and that a character that appears in both
        // sets would naturally be considered *hard*.  Also note that it is
        // entirely reasonable to state, in any public interface, that the
        // behavior is undefined unless the characters in the union of the two
        // delimiter sequences are unique.

    // ACCESSORS
    int inputType(char character) const;
        // Return the input type of the specified &#39;character&#39;: 0 for token,
        // 1 for soft delimiter, 2 for hard delimiter.
};

                        // =======================
                        // class TokenizerIterator
                        // =======================

class TokenizerIterator {
    // This class provides a C++-standards-conforming input iterator over the
    // tokens in the input string suppled at construction (along with the
    // designation of *soft* and *hard* delimiter characters) to a &#39;Tokenizer&#39;
    // object.  Tokens are returned, using a &#39;bslstl::StringRef&#39; -- by value --
    // that means the iterated references remain valid until the underlying
    // input string itself is modified or destroyed.  Note that all iterators
    // are invalidated whenever the input string in the parent &#39;Tokenizer&#39;
    // change.


    // DATA
    const Tokenizer_Data *d_sharedData_p;  // (address of) character categories
    const char           *d_cursor_p;      // tail of parsed input
    const char           *d_token_p;       // current token
    const char           *d_postDelim_p;   // current (trailing) delimiter
    const char           *d_end_p;         // one past input; 0 for &#39;(char *)&#39;
    bool                  d_endFlag;       // set &#39;true&#39; when at end of input

    // FRIENDS
    friend class Tokenizer;
    friend bool operator==(const TokenizerIterator&amp;, const TokenizerIterator&amp;);
    friend bool operator!=(const TokenizerIterator&amp;, const TokenizerIterator&amp;);

    // PRIVATE CREATORS
    TokenizerIterator(const char           *input,
                      const char           *end,
                      const Tokenizer_Data *sharedData);
        // Create a &#39;TokenizerIterator&#39; object bound to the specified sequence
        // of &#39;input&#39; characters ending at the specified &#39;end&#39; and the
        // specified delimiter and token mapper &#39;sharedData&#39;.

  public:
    // CREATORS
    TokenizerIterator();
    TokenizerIterator(const TokenizerIterator&amp; origin);
        // Create a &#39;TokenizerIterator&#39; object having the value of the
        // specified &#39;origin&#39; iterator.

    // MANIPULATORS
    TokenizerIterator&amp; operator=(const TokenizerIterator&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; iterator, and
        // return a reference providing modifiable access to this object.

    TokenizerIterator&amp; operator++();
        // Advance the iteration state of this object to refer to the next
        // token in the underlying input sequence, and return a reference
        // providing modifiable access to this object.  The behavior is
        // undefined unless the iteration state of this object is initially
        // valid, or if the underlying input has been modified or destroyed
        // since this object was created.

    // ACCESSORS
    bslstl::StringRef operator*() const;
        // Return a reference to the non-modifiable current token (i.e.,
        // maximal sequence of non-delimiter characters) in the input string.
        // The returned reference remains valid so long as the underlying input
        // is not modified or destroyed -- irrespective of the state (or
        // existence) of this object.  The behavior is undefined unless the
        // iteration state of this object is initially valid, or if the
        // underlying input has been modified or destroyed since this object
        // was created.
};

// FREE OPERATORS
bool operator==(const TokenizerIterator&amp; lhs, const TokenizerIterator&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;TokenizerIterator&#39; objects have the
    // same value if both of them are pointing to the same token within the
    // same tokenized string or if they both point past the tokenized string.
    // The behaviour is undefined unless the iterators returned by the same
    // &#39;Tokenizer&#39; object, or if the underlying input has been modified or
    // destroyed since any of those objects were created.

bool operator!=(const TokenizerIterator&amp; lhs, const TokenizerIterator&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  The behaviour is undefined unless
    // the iterators returned by the same &#39;Tokenizer&#39; object, or if the
    // underlying input has been modified or destroyed since any of those
    // objects were created.

const TokenizerIterator operator++(TokenizerIterator&amp; object, int);
    // Advance the iteration state of the specified &#39;object&#39; to refer to the
    // next token in the underlying input sequence, and return a copy of this
    // object prior advancing the iteration state.  The behavior is undefined
    // unless the iteration state of this object is initially valid, or if the
    // underlying input has been modified or destroyed since this object was
    // created.


                            // ===============
                            // class Tokenizer
                            // ===============

class Tokenizer {
    // This class provides (read-only) sequential access to tokens delimited by
    // two user-supplied character sets consisting, respectively, of *soft* and
    // *hard* delimiters characters.  Access to the previous and current
    // (trailing) delimiter, as well as to the current token itself, is
    // provided efficiently via &#39;bslstl::StringRef&#39;.

    // DATA
    Tokenizer_Data  d_sharedData;  // delimiter/token character categories
    const char     *d_input_p;     // original input
    const char     *d_cursor_p;    // tail of parsed input
    const char     *d_prevDelim_p; // previous delimiter
    const char     *d_token_p;     // current token
    const char     *d_postDelim_p; // current (trailing) delimiter
    const char     *d_end_p;       // one past end of input; 0 for &#39;(char *)&#39;
    bool            d_endFlag;     // set &#39;true&#39; when cursor at end of input

  private:
    // PRIVATE MANIPULATORS
    void resetImpl(const char *input, const char *endOfInput);
        // Rebind this object to refer to the specified sequence of &#39;input&#39;
        // characters ending at the specified &#39;endOfInput&#39; pointer.  The state
        // of the tokenizer following this call is *as* *if* it had been
        // constructed with &#39;input&#39; and its current sets of *soft* and *hard*
        // delimiter characters.  Note that the behavior is undefined if this
        // object is used in any way (other than to reset or destroy it) after
        // its underlying &#39;input&#39; string is modified.

  private:
    // NOT IMPLEMENTED
    Tokenizer(const Tokenizer&amp;);
    Tokenizer&amp; operator=(const Tokenizer&amp;);
    Tokenizer&amp; operator++(int);

  public:
    // TYPES
    typedef TokenizerIterator iterator;

    // CREATORS
    Tokenizer(const char               *input, const bslstl::StringRef&amp; soft);
    Tokenizer(const bslstl::StringRef&amp;  input, const bslstl::StringRef&amp; soft);
    Tokenizer(const char               *input,
              const bslstl::StringRef&amp;  soft,
              const bslstl::StringRef&amp;  hard);
    Tokenizer(const bslstl::StringRef&amp;  input,
              const bslstl::StringRef&amp;  soft,
              const bslstl::StringRef&amp;  hard);
        // Create a &#39;Tokenizer&#39; object bound to the specified sequence of
        // &#39;input&#39; characters having the specified set of (unique) &#39;soft&#39;
        // delimiter characters to be used to separate *tokens* (i.e., maximal
        // sequence of non-delimiter characters) in &#39;input&#39;.  Optionally
        // specify a disjoint set of (unique) &#39;hard&#39; delimiter characters to be
        // used to explicitly terminate tokens.  Delimiters within &#39;input&#39;
        // consist of a maximal sequence of one or more delimiter characters,
        // at most one of which may be *hard*; when there is a contiguous
        // sequence of delimiter characters containing two or more *hard*
        // delimiter characters in &#39;input&#39;, any intervening *soft* delimiter
        // characters are associated with the previous (*hard*) delimiter.  Any
        // leading soft delimiter characters -- i.e., those preceding the first
        // *token* or *hard* delimiter character (referred to as the *leader*)
        // -- are available immediately after construction via the
        // &#39;previousDelimiter&#39; method.  The behavior is undefined unless all
        // supplied delimiter characters are unique.  Note that the behavior is
        // also undefined if this object is used in any way (other than to
        // reset or destroy it) after its underlying &#39;input&#39; string is
        // modified.  Also note that the current token and (trailing) delimiter
        // may be accessed only while this object is in the valid state;
        // however, the previous delimiter (or *leader*) is always accessible.
        // Finally note that all token and delimiter strings are returned as
        // references into the underlying &#39;input&#39; string, and hence remain
        // valid so long as that string is not modified or destroyed --
        // irrespective of the state (or even the existence) of this object.

    ~Tokenizer();
        // Destroy this object.

    // MANIPULATORS
    Tokenizer&amp; operator++();
        // Advance the iteration state of this object to refer to the next
        // sequence of previous delimiter, current token, and current
        // (trailing) delimiter in the underlying input sequence, and return a
        // reference providing modifiable access to this object.  The current
        // delimiter reference becomes the previous one.  If there is another
        // token remaining in the input, the current token and delimiter are
        // updated to refer to the respective new token and (trailing)
        // delimiter values -- either of which (but not both) might be empty.
        // The behavior is undefined unless the iteration state of this object
        // is initially valid, or if the underlying input has been modified or
        // destroyed since this object was most recently reset (or created).

    void reset(const char *input);
    void reset(const bslstl::StringRef&amp; input);
        // Rebind this object to refer to the specified sequence of &#39;input&#39;
        // characters.  The state of the tokenizer following this call is *as*
        // *if* it had been constructed with &#39;input&#39; and its current sets of
        // *soft* and *hard* delimiter characters.  Note that the behavior is
        // undefined if this object is used in any way (other than to reset or
        // destroy it) after its underlying &#39;input&#39; string is modified.

    // ACCESSORS
    bool hasPreviousSoft() const;
        // Return &#39;true&#39; if the previous delimiter (or *leader*) contains a
        // *soft* delimiter character, and &#39;false&#39; otherwise.  The behavior is
        // undefined if the underlying input itself has been modified or
        // destroyed since this object was most recently reset (or created).

    bool hasTrailingSoft() const;
        // Return &#39;true&#39; if the current (trailing) delimiter contains a *soft*
        // delimiter character, and &#39;false&#39; otherwise.  The behavior is
        // undefined if the iteration state of this object is initially
        // invalid, or if the underlying input itself has been modified or
        // destroyed since this object was most recently reset (or created).

    bool isPreviousHard() const;
        // Return &#39;true&#39; if the previous delimiter contains a *hard-delimiter*
        // character, and &#39;false&#39; otherwise.  The behavior is undefined if the
        // underlying input itself has been modified or destroyed since this
        // object was most recently reset (or created).

    bool isTrailingHard() const;
        // Return &#39;true&#39; if the current (trailing) delimiter contains a *hard*
        // delimiter character, and &#39;false&#39; otherwise.  The behavior is
        // undefined if the iteration state of this object is initially
        // invalid, or if the underlying input itself has been modified or
        // destroyed since this object was most recently reset (or created).

    bool isValid() const;
        // Return &#39;true&#39; if the iteration state of this object is valid, and
        // &#39;false&#39; otherwise.  Note that the behavior of advancing the
        // iteration state as well as accessing the current token or (trailing)
        // delimiter is undefined unless the current iteration state of this
        // object is valid.

    bslstl::StringRef previousDelimiter() const;
        // Return a reference to the non-modifiable previous delimiter (or
        // *leader*) in the input string.  The behavior is undefined unless the
        // underlying input has been modified or destroyed since this object
        // was most recently reset (or created).

    bslstl::StringRef token() const;
        // Return a reference to the non-modifiable current token (i.e.,
        // maximal sequence of non-delimiter characters) in the input string.
        // The returned reference remains valid so long as the underlying input
        // is not modified or destroyed -- irrespective of the state (or
        // existence) of this object.  The behavior is undefined unless the
        // iteration state of this object is initially valid, or if the
        // underlying input has been modified or destroyed since this object
        // was most recently reset (or created).


    bslstl::StringRef trailingDelimiter() const;
        // Return a reference to the non-modifiable current (trailing)
        // delimiter (maximal sequence of one or more delimiter characters
        // containing at most one *hard* delimiter character) in the input
        // string.  The returned reference remains valid so long as the
        // underlying input is not modified or destroyed -- irrespective of the
        // state (or existence) of this object.  The behavior is undefined
        // unless the iteration state of this object is initially valid, or if
        // the underlying input has been modified or destroyed since this
        // object was most recently reset (or created).


                         // iterators
    iterator begin() const;
        // Return an iterator referring to the first token in this object&#39;s
        // input string (the past-the-end iterator if this object iteration
        // state is initially invalid).  This reference remains valid as long
        // as the underlying input has not been modified or destroyed since
        // this object was most recently reset (or created).

    iterator end() const;
        // Return an iterator referring to position beyond the last token in
        // this object&#39;s input string.  This reference remains valid as long as
        // the underlying input has not been modified or destroyed since this
        // object was most recently reset (or created).
};

// FREE OPERATORS
const Tokenizer operator++(Tokenizer&amp; object, int);

// ============================================================================
//                               INLINE DEFINITIONS
// ============================================================================

                        // --------------------------
                        // class bdlb::Tokenizer_Data
                        // --------------------------
// ACCESSORS
inline
int Tokenizer_Data::inputType(char character) const
{
    return d_charTypes[static_cast&lt;unsigned char&gt;(character)];
}

                        // -----------------------------
                        // class bdlb::TokenizerIterator
                        // -----------------------------
// ACCESSORS
inline
bslstl::StringRef TokenizerIterator::operator*() const
{
    // Called on invalid iterator
    BSLS_ASSERT_SAFE(!d_endFlag);
    return bslstl::StringRef(d_token_p, d_postDelim_p);
}

                        // ---------------------
                        // class bdlb::Tokenizer
                        // ---------------------
// ACCESSORS
inline
bool Tokenizer::isValid() const
{
    return !d_endFlag;
}

inline
bslstl::StringRef Tokenizer::previousDelimiter() const
{
    return bslstl::StringRef(d_prevDelim_p, d_token_p);
}

inline
bslstl::StringRef Tokenizer::token() const
{
    // Called on invalid tokenizer
    BSLS_ASSERT_SAFE(!d_endFlag);
    return bslstl::StringRef(d_token_p, d_postDelim_p);
}

inline
bslstl::StringRef Tokenizer::trailingDelimiter() const
{
    // Called on invalid tokenizer
    BSLS_ASSERT_SAFE(!d_endFlag);
    return bslstl::StringRef(d_postDelim_p, d_cursor_p);
}

}  // close package namespace

// FREE OPERATORS
inline
bool bdlb::operator==(const bdlb::TokenizerIterator&amp; lhs,
                      const bdlb::TokenizerIterator&amp; rhs)
{
    // Fast path decision
    if (lhs.d_endFlag != rhs.d_endFlag) {
        return false;                                                 // RETURN
    }

    // Comparing end iterators
    if (lhs.d_endFlag &amp;&amp; rhs.d_endFlag) {
        return true;                                                  // RETURN
    }

    return  lhs.d_token_p == rhs.d_token_p;
}

inline
bool bdlb::operator!=(const bdlb::TokenizerIterator&amp; lhs,
                      const bdlb::TokenizerIterator&amp; rhs)
{
    return !(lhs == rhs);
}

inline
const bdlb::TokenizerIterator bdlb::operator++(bdlb::TokenizerIterator&amp; object,
                                               int)
{
    bdlb::TokenizerIterator tmp(object);
    ++object;
    return tmp;
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
