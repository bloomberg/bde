<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlso::DefaultEventManager_3_01Platform::SELECT_01_4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlso.html">btlso</a>      </li>
      <li><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlso::DefaultEventManager&lt; Platform::SELECT &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlso::DefaultEventManager&lt; Platform::SELECT &gt;" --><!-- doxytag: inherits="btlso::EventManager" -->
<p><code>#include &lt;<a class="el" href="btlso__defaulteventmanager__select_8h_source.html">btlso_defaulteventmanager_select.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlso::DefaultEventManager&lt; Platform::SELECT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.png" usemap="#btlso::DefaultEventManager&lt; Platform::SELECT &gt;_map" alt=""/>
  <map id="btlso::DefaultEventManager&lt; Platform::SELECT &gt;_map" name="btlso::DefaultEventManager&lt; Platform::SELECT &gt;_map">
<area href="classbtlso_1_1EventManager.html" alt="btlso::EventManager" shape="rect" coords="0,0,290,24"/>
</map>
</div>

<p><a href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#adb7312cd5b0a90aaa1d2d6d5f34f7b24ad30a955b31dbc0623a98081e9d994e0d">k_MAX_NUM_HANDLES</a> =  FD_SETSIZE
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">Callback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ac9ebb46d9fdb2797fb2f631ddc6a1c6f">DefaultEventManager</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ae77cfb40fc9343a0752a16708368f167">DefaultEventManager</a> (<a class="el" href="classbtlso_1_1TimeMetrics.html">TimeMetrics</a> *timeMetric, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a45446eaab19356cccba7e665d0ecd6fc">~DefaultEventManager</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ab57eb248ac7b209561502bc3016a79e9">dispatch</a> (int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ad4f693a68f743931fd7c80969d978467">dispatch</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a62e8abc11e37159951f8d8dae7be0915">registerSocketEvent</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, const <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> event, const <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">EventManager::Callback</a> &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#aa29d73a4ef58ec6d05a920bd830382f5">deregisterSocketEvent</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a2255042ed53b2faf614fa69f5b354943">deregisterSocket</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a3168310d44d3a68dd33afbad29b8dc94">deregisterAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a7a1265024a3960bff7e7e0b0c41f49bb">canRegisterSockets</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#aa4f0317da57b1a6888864f0454237960">hasLimitedSocketCapacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#aa44d64bb976401956d85adbaa5c91c4f">isRegistered</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, const <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> event) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ac9d858cbc760218a8943a076a0d2d14a">numEvents</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ae09329182ac390c08d109e657a66830f">numSocketEvents</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;&gt;<br/>
 class btlso::DefaultEventManager&lt; Platform::SELECT &gt;</h3>

<p>This class implements the <code><a class="el" href="classbtlso_1_1EventManager.html">EventManager</a></code> protocol to provide an event manager that uses the <code>select</code> system call. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9223eeeac7abf312a41bd5ea42bccbe7"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::Callback" ref="a9223eeeac7abf312a41bd5ea42bccbe7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void()&gt; <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alias for the type used as the registered callback for this event manager. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="adb7312cd5b0a90aaa1d2d6d5f34f7b24"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::@405" ref="adb7312cd5b0a90aaa1d2d6d5f34f7b24" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adb7312cd5b0a90aaa1d2d6d5f34f7b24ad30a955b31dbc0623a98081e9d994e0d"></a><!-- doxytag: member="k_MAX_NUM_HANDLES" ref="adb7312cd5b0a90aaa1d2d6d5f34f7b24ad30a955b31dbc0623a98081e9d994e0d" args="" -->k_MAX_NUM_HANDLES</em>&nbsp;</td><td>
<p>maximum number of socket handles that can be registered with an event manager (of this type) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac9ebb46d9fdb2797fb2f631ddc6a1c6f"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::DefaultEventManager" ref="ac9ebb46d9fdb2797fb2f631ddc6a1c6f" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::<a class="el" href="classbtlso_1_1DefaultEventManager.html">DefaultEventManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae77cfb40fc9343a0752a16708368f167"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::DefaultEventManager" ref="ae77cfb40fc9343a0752a16708368f167" args="(TimeMetrics *timeMetric, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::<a class="el" href="classbtlso_1_1DefaultEventManager.html">DefaultEventManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TimeMetrics.html">TimeMetrics</a> *&nbsp;</td>
          <td class="paramname"> <em>timeMetric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>select</code>-based event manager. Optionally specify a <code>timeMetric</code> to report time spent in CPU-bound and IO-bound operations. If <code>timeMetric</code> is not specified or is 0, these metrics are not reported. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a45446eaab19356cccba7e665d0ecd6fc"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::~DefaultEventManager" ref="a45446eaab19356cccba7e665d0ecd6fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::~<a class="el" href="classbtlso_1_1DefaultEventManager.html">DefaultEventManager</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. Note that the registered callbacks are NOT invoked. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab57eb248ac7b209561502bc3016a79e9"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::dispatch" ref="ab57eb248ac7b209561502bc3016a79e9" args="(int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each pending socket event, invoke the corresponding callback registered with this event manager. If no event is pending, wait until either (1) at least one event occurs (in which case the corresponding callback(s) is invoked) or (2) provided that the specified <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code>, an underlying system call is interrupted by a signal. Return the number of dispatched callbacks on success, and a negative value otherwise; -1 is reserved to indicate that an underlying system call was interrupted. When such an interruption occurs this method will return (-1) if <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code> and otherwise will automatically restart (i.e., reissue the identical system call). Note that all callbacks are invoked in the same thread that invokes <code>dispatch</code>, and the order of invocation, relative to the order of registration, is unspecified. Also note that -1 is never returned if <code>option</code> is not set to <code>bteso_Flag::k_ASYNC_INTERRUPT</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#a344d0ca3d7091da8a9b7ef87bc9fcad5">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="ad4f693a68f743931fd7c80969d978467"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::dispatch" ref="ad4f693a68f743931fd7c80969d978467" args="(const bsls::TimeInterval &amp;timeout, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each pending socket event, invoke the corresponding callback registered with this event manager. If no event is pending, wait until either (1) at least one event occurs (in which case the corresponding callback(s) is invoked), (2) the specified absolute <code>timeout</code> is reached, or (3) provided that the specified <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code>, an underlying system call is interrupted by a signal. Return the number of dispatched callbacks on success, 0 if <code>timeout</code> is reached, and a negative value otherwise; -1 is reserved to indicate that an underlying system call was interrupted. When such an interruption occurs this method will return -1 if <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code>, and otherwise will automatically restart (i.e., reissue the identical system call). Note that all callbacks are invoked in the same thread that invokes <code>dispatch</code>, and the order of invocation, relative to the order of registration, is unspecified. Also note that -1 is never returned unless <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#aba9cfe3a5491533928d4027e34adfea0">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a62e8abc11e37159951f8d8dae7be0915"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::registerSocketEvent" ref="a62e8abc11e37159951f8d8dae7be0915" args="(const SocketHandle::Handle &amp;handle, const EventType::Type event, const EventManager::Callback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::registerSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">EventManager::Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register with this event manager the specified <code>callback</code> to be invoked when the specified <code>event</code> occurs on the specified socket <code>handle</code>. Each socket event registration stays in effect until it is subsequently deregistered; the callback is invoked each time the corresponding event is detected. <code><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">EventType::e_READ</a></code> and <code><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">EventType::e_WRITE</a></code> are the only events that can be registered simultaneously for a socket. If a registration attempt is made for an event that is already registered, the callback associated with this event will be overwritten with the new one. Simultaneous registration of incompatible events for the same socket <code>handle</code> will result in undefined behavior. Return 0 on success and a non-zero value otherwise. The behavior is undefined unless <code><a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a7a1265024a3960bff7e7e0b0c41f49bb">canRegisterSockets()</a></code> is <code>true</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#a2f9f42a2cc3013cf6ac43553c30f8a46">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="aa29d73a4ef58ec6d05a920bd830382f5"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::deregisterSocketEvent" ref="aa29d73a4ef58ec6d05a920bd830382f5" args="(const SocketHandle::Handle &amp;handle, EventType::Type event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::deregisterSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager the callback associated with the specified <code>event</code> on the specified <code>handle</code> so that said callback will not be invoked should <code>event</code> occur. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#a0cd6f85fb3b4dc4e3066446d5da5c91c">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a2255042ed53b2faf614fa69f5b354943"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::deregisterSocket" ref="a2255042ed53b2faf614fa69f5b354943" args="(const SocketHandle::Handle &amp;handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::deregisterSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager all events associated with the specified socket <code>handle</code>. Return the number of deregistered callbacks. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#a6f59c75d70601525f59c517c9d904bbd">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a3168310d44d3a68dd33afbad29b8dc94"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::deregisterAll" ref="a3168310d44d3a68dd33afbad29b8dc94" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::deregisterAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager all events on every socket handle. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#a2bf336c8772631b783f26aead6be54d0">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a7a1265024a3960bff7e7e0b0c41f49bb"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::canRegisterSockets" ref="a7a1265024a3960bff7e7e0b0c41f49bb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::canRegisterSockets </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this event manager can register additional sockets, and <code>false</code> otherwise. Note that if <code>canRegisterSockets</code> is <code>false</code> then a subsequent call to register an event (without an intervening call to deregister an event) will result in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="aa4f0317da57b1a6888864f0454237960"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::hasLimitedSocketCapacity" ref="aa4f0317da57b1a6888864f0454237960" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::hasLimitedSocketCapacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this event manager has a limited socket capacity, and <code>false</code> otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#a9068ee5a3ca8e2e7ae82c59d36ce2430">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="aa44d64bb976401956d85adbaa5c91c4f"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::isRegistered" ref="aa44d64bb976401956d85adbaa5c91c4f" args="(const SocketHandle::Handle &amp;handle, const EventType::Type event) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::isRegistered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if the specified <code>event</code> is registered with this event manager for the specified socket <code>handle</code> and 0 otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="ac9d858cbc760218a8943a076a0d2d14a"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::numEvents" ref="ac9d858cbc760218a8943a076a0d2d14a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::numEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of all socket events currently registered with this event manager. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#a6baa2ad4ccdcf4e56d29c9f331d834d3">btlso::EventManager</a>.</p>

</div>
</div>
<a class="anchor" id="ae09329182ac390c08d109e657a66830f"></a><!-- doxytag: member="btlso::DefaultEventManager&lt; Platform::SELECT &gt;::numSocketEvents" ref="ae09329182ac390c08d109e657a66830f" args="(const SocketHandle::Handle &amp;handle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1DefaultEventManager.html">btlso::DefaultEventManager</a>&lt; <a class="el" href="structbtlso_1_1Platform_1_1SELECT.html">Platform::SELECT</a> &gt;::numSocketEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of socket events currently registered with this event manager for the specified <code>handle</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">btlso::EventManager</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlso__defaulteventmanager__select_8h_source.html">btlso_defaulteventmanager_select.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:15 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
