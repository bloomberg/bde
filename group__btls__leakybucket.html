<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btls_leakybucket Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btls_leakybucket<br/>
<small>
[<a class="el" href="group__btls.html">Package btls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mechanism to monitor the consumption rate of a resource.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtls.html">btls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Adding Units</a> <ul>
<li>
<a href="#3.1.1">Submitting Units</a> </li>
<li>
<a href="#3.1.2">Reserving Units</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Monitoring Resource Usage</a> <ul>
<li>
<a href="#3.2.1">Checking for Overflow</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Modeling a Network Connection</a> </li>
<li>
<a href="#3.4">Approximations</a> </li>
<li>
<a href="#3.5">Sliding Time-Window</a> </li>
<li>
<a href="#3.6">Time Synchronization</a> </li>
<li>
<a href="#3.7">Usage</a> </li>
<li>
<a href="#3.8">Example 1: Controlling Network Traffic Generation</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mechanism to monitor the consumption rate of a resource. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a> </td><td>a leaky bucket rate monitor  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btls__ratelimiter.html" title="Provide a mechanism to limit peak and sustained consumption rates.">Component btls_ratelimiter</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism, <code><a class="el" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a></code>, that implements a leaky bucket algorithm that allows clients to monitor whether a resource is being consumed at a particular rate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The name of this mechanism, leaky bucket, derives from an analogy of pouring water into a bucket with a hole at the bottom. The maximum rate at which water will drain out the bucket depends on the size of the hole, and not on the rate at which water is poured into the bucket. If more water is being poured into the bucket than being drained, the bucket will eventually overflow. If the person pouring water into a leaky bucket ensures the bucket doesn't overflow, then the average rate they pour water will, over time, be limited by the rate at which water flows out of the bucket. By analogy, a leaky bucket provides a means to limit the rate of consumption of some resource (water poured into the bucket) to a configured rate (the size of the hole in the bucket). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The behavior of a leaky bucket is determined by two properties: the capacity and the drain rate. The drain rate, measured in <code>units/s</code>, is the rate at which the resource is drained. The capacity, measured in <code>units</code>, is the maximum amount of the resource that the leaky bucket can hold before it overflows. <code>unit</code> is a generic unit of measurement (e.g., bytes, number of messages, packets, liters, clock cycles). Note that the drain rate determines average rate of resource consumption, while the capacity restricts the time period over which the average actual rate of resource consumption approaches the drain rate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="adding_units"></a> <a class="anchor" id="description.adding_units"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Adding Units: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Units can be added to a leaky bucket by either submitting them or reserving them. Submitted units are removed from a leaky bucket at the drain rate, while reserved units remain unchanged until they are later either cancelled (removed from the leaky bucket) or submitted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="submitting_units"></a> <a class="anchor" id="adding_units.submitting_units"></a> <a class="anchor" id="description.adding_units.submitting_units"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Submitting Units: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Units can be submitted to a leaky bucket by invoking the <code>submit</code> method, and should be added only after the resource had been consumed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Figure 1 illustrates a typical workflow for submitting units to a leaky bucket. <br/>
<br/>
<div class="fragment"><pre class="fragment"> Fig. 1:  Capacity = 5 units, Rate = 1 unit / second

    Submit 5                     Submit 2

    7|     |      7|     |       7|     |      7|     |
    6|     |      6|     |       6|     |      6|     |
 c--5|~~~~~|   c--5|-----|    c--5|-----|   c--5|-----|
    4|~~~~~|      4|     |       4|     |      4|     |
    3|~~~~~|      3|     |       3|~~~~~|      3|     |
    2|~~~~~|      2|     |       2|~~~~~|      2|     |
    1|~~~~~|      1|~~~~~|       1|~~~~~|      1|     |
     +-- --+       +-- --+        +-- --+       +-- --+

 <a class="code" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time</a>: t0          t0 + 4s        t0 + 4s       t0 + 10s
</pre></div><br/>
<br/>
 Suppose that we have an empty leaky bucket with a capacity of <code>c = 5 units</code> and a drain rate of <code>d = 1 units/s</code>. At <code>t0</code>, we submit 5 units to the leaky bucket, bringing the total number of units held up to 5. At <code>t0 + 4s</code>, 4 units have been drained from the leaky bucket, bringing the number of units held down to 1. Finally, at <code>t0 + 10s</code>, all units have been drained from the leaky bucket, making it empty. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unlike a real-life water bucket, units submitted to a leaky bucket don't spillover after its capacity has been exceeded, instead the leaky bucket may hold a number of units beyond its capacity, as examined in Figure 2 below., these units are still contained in the leaky bucket. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Figure 2 illustrates what happens if a leaky bucket exceeds its capacity. This scenario is the same as that in Figure 1, but at time <code>t0 + 4s</code>, we submit 6 units instead of 2. <br/>
<br/>
<div class="fragment"><pre class="fragment"> Fig. 2: Capacity = 5 units, Rate = 1 unit / second

    Submit 5                     Submit 6

    7|     |      7|     |       7|~~~~~|      7|     |
    6|     |      6|     |       6|~~~~~|      6|     |
 c--5|~~~~~|   c--5|-----|    c--5|~~~~~|   c--5|-----|
    4|~~~~~|      4|     |       4|~~~~~|      4|     |
    3|~~~~~|      3|     |       3|~~~~~|      3|     |
    2|~~~~~|      2|     |       2|~~~~~|      2|     |
    1|~~~~~|      1|~~~~~|       1|~~~~~|      1|~~~~~|
     +-- --+       +-- --+        +-- --+       +-- --+

 <a class="code" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time</a>: t0          t0 + 4s        t0 + 4s       t0 + 10s
</pre></div><br/>
<br/>
 At <code>t0 + 4s</code>, when the number of units held by the leaky bucket is 1, we submit 6 more units. This brings the number of units held to 7, which exceeds the capacity of the leaky bucket. At <code>t0 + 10s</code>, 6 units had been drained from the leaky bucket bring the number of units held down to 1. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="reserving_units"></a> <a class="anchor" id="adding_units.reserving_units"></a> <a class="anchor" id="description.adding_units.reserving_units"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Reserving Units: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Units can be reserved for a leaky bucket using the <code>reserve</code> method, and they may be later canceled using the <code>cancelReserved</code> method or submitted using the <code>submitReserved</code> method. Unlike submitted units, reserved units do <em>not</em> drain from the leaky bucket; like submitted units, reserved units count toward the total number of units for the purposes of determining whether a leaky bucket has exceeded its capacity. Reserving units effectively decreases the capacity of a leaky bucket. Therefore, the time interval between reserving units and submitting or canceling the reservation should be kept as short as possible. For a practical example of using reserved units, please see <code>btls_reservationguard</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Figure 3 illustrate an example of how reserving units works in a leaky bucket. <br/>
<br/>
<div class="fragment"><pre class="fragment"> Fig. 3: Capacity = 5 units, Rate = 1 unit / second

    Reserve 4                 Submit 3                  Cancel 1
                            from reserve              from reserve

    7|     |     7|     |     7|     |     7|     |     7|     |
    6|     |     6|     |     6|     |     6|     |     6|     |
 c--5|-----|  c--5|-----|  c--5|-----|  c--5|-----|  c--5|-----|
    4|#####|     4|#####|     4|~~~~~|     4|     |     4|     |
    3|#####|     3|#####|     3|~~~~~|     3|     |     3|     |
    2|#####|     2|#####|     2|~~~~~|     2|     |     2|     |
    1|#####|     1|#####|     1|#####|     1|#####|     1|     |
     +-- --+      +-- --+      +-- --+      +-- --+      +-- --+

 <a class="code" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time</a>: t0         t0 + 5s      t0 + 6s      t0 + 9s      t0 + 10s
</pre></div><br/>
<br/>
 Suppose that we have an empty leaky bucket with a capacity of <code>c = 5 units</code> and a drain rate of <code>d = 1 units/s</code>. At <code>t0</code> we reserve 4 units. At <code>t0 + 5s</code>, we observe that none of the reserved units are drained from the leaky bucket. At <code>t0 + 6s</code>, we submit 3 of the previously reserved units, which brings the number of reserved units down to 1 and the number of units held up to 3. At <code>t0 + 9s</code>, we observe that all but the remaining reserved unit have been drained from the bucket. Finally, at <code>t0 + 10s</code>, we cancel the remaining reserved unit. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="monitoring_resource_usage"></a> <a class="anchor" id="description.monitoring_resource_usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Monitoring Resource Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The recommended usage of a leaky bucket is to first check whether 1 unit can be added without causing the leaky bucket to overflow, and if so, consume the desired amount of the resource. Afterwards, submit the amount of consumed resource to the leaky bucket. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="checking_for_overflow"></a> <a class="anchor" id="monitoring_resource_usage.checking_for_overflow"></a> <a class="anchor" id="description.monitoring_resource_usage.checking_for_overflow"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Checking for Overflow: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A leaky bucket can be queried whether submitting a 1 more unit would cause it to overflow via the <code>wouldOverflow</code> method. This method facilitates the recommended usage of a leak bucket: check whether 1 more unit can be added without causing the leaky bucket to overflow, and if so, consume the desired amount of the resource (which may be more than 1). Compared to the alternative -- checking whether the desired amount can be submitted without overflow -- this recommended usage may allow a limited spike in the rate of actual consumption when the leaky bucket is empty (which is often acceptable) but is able to sustain a long term average that is actually closer to the drain rate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="modeling_a_network_connection"></a> <a class="anchor" id="description.modeling_a_network_connection"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Modeling a Network Connection: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The primary use case of leaky bucket is limiting the rate at which data is written on a network. In this use case, the drain rate of the bucket corresponds to the <em>ideal</em> maximum transmission rate that the client wishes to enforce on their outgoing connection. Clients may choose to provide a value related to the physical limitations of their network or any other arbitrary limit. The function of a leaky bucket's capacity is to limit the time period over which the average actual transimission rate may exceed the configured drain rate of the leaky bucket (see <code>Approximations</code> section and <code>Sliding Time-Window</code> section). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="approximations"></a> <a class="anchor" id="description.approximations"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Approximations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Leaky bucket is modeled on a water bucket with a hole, but as a leaky bucket does not manage any resources, there are several approximations to this model: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Units are submitted instantaneously to the leaky bucket, whereas the consumption of a resource occurs over time at a rate that depends on the nature and speed of the resource.  </li>
<li>
Leaky bucket simulates the consumption of a resource with a specified fixed drain rate, but the resource is actually consumed at different rates over time. This approximation still guarantees that the actual consumption rate does not exceed the specified drain rate when amortized over some configured period of time (determined by the capacity and the drain rate of the bucket), but does not prevent the consumption rate from spiking above the drain rate for shorter periods of time (see 'Sliding Time-Window' section).  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="sliding_time-window"></a> <a class="anchor" id="description.sliding_time-window"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Sliding Time-Window: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>One of the properties of the resource pattern created by using a lleaky bucket is an approximation of a sliding time window over which the average consumption rate is guaranteed to be less than the drain rate. This time period can be calculated using the leaky bucket's capacity and drain rate, which can be conveniently performed using the <code>calculateTimeWindow</code> class method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="time_synchronization"></a> <a class="anchor" id="description.time_synchronization"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Time Synchronization: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Leaky bucket does not utilize an internal timer, so timing must be handled manually. Clients can specify an initial time interval for the leaky bucket at construction or using the <code>reset</code> method. Whenever the number of units in a leaky bucket needs to be updated, clients must invoke the <code>updateState</code> method specifying the current time interval. Since leaky bucket cares only about the elapsed time (not absolute time), the specified time intervals may be relative to any arbitrary time origin, though all of them must refer to the same origin. For the sake of consistency, clients are encouraged to use the unix epoch time (such as the values returned by <code><a class="el" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a></code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates the intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_controlling_network_traffic_generation"></a> <a class="anchor" id="description.example_1~3A_controlling_network_traffic_generation"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="description.example_1"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Controlling Network Traffic Generation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In some systems, data is processed faster than they are consumed by I/O interfaces. This could lead to data loss due to the overflowing of the buffers where data is queued before being processed. In other systems, generic resources are shared, and their consumption might need to be managed in order to guarantee quality-of-service (QOS). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have a network interface capable of transferring at a rate of 1024 byte/s and an application wants to transmit 5 KB (5120 bytes) of data over that network in 20 different 256-bytes data chunks. We want to send data over this interface and want to ensure the transmission uses on average less than 50% of the available bandwidth, or 512 byte/s. In this way, other clients can still reasonably send and receive data using the same network interface. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Further suppose that we have a function, <code>sendData</code>, that transmits a specified data buffer over that network interface: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> sendData(<span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> dataSize)
      <span class="comment">// Send the specified &#39;buffer&#39; of the specified size &#39;dataSize&#39; through</span>
      <span class="comment">// the network interface.  Return &#39;true&#39; if data was sent successfully,</span>
      <span class="comment">// and &#39;false&#39; otherwise.</span>
  {
      (void) buffer;
      (void) dataSize;

      <span class="comment">// In our example we don`t deal with actual data sending, so we assume</span>
      <span class="comment">// that the function sends data successfully and return true.</span>
      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }
</pre></div><br/>
<br/>
 First, we create a leaky bucket having a drain rate of 512 bytes/s, a capacity of 2560 bytes, and a time origin set to the current time (as an interval from unix epoch). Note that <code>unit</code>, the unit of measurement for leaky bucket, corresponds to <code>byte</code> in this example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> rate     = 512;  <span class="comment">// bytes/second</span>
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> capacity = 2560; <span class="comment">// bytes</span>
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>  now      = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();
  <a class="code" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a>   bucket(rate, capacity, now);
</pre></div><br/>
<br/>
 Then, we define a data buffer to be sent, the size of each data chunk, and the total size of the data to transmit: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span>                buffer[5120];
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        chunkSize  = 256;             <span class="comment">// in bytes</span>
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> totalSize  = 20 * chunkSize;  <span class="comment">// in bytes</span>
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> dataSent   = 0;               <span class="comment">// in bytes</span>

  <span class="comment">// Load &#39;buffer&#39;...</span>
</pre></div><br/>
<br/>
 Notice that, for the sake of brevity, we elide the loading of <code>buffer</code> with the data to be sent. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we send the chunks of data using a loop. For each iteration, we check whether submitting another byte would cause the leaky bucket to overflow. If not, we send an additional chunk of data and submit the number of bytes sent to the leaky bucket. Note that <code>submit</code> is invoked only after the data has been sent. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> *data = buffer;
  <span class="keywordflow">while</span> (dataSent &lt; totalSize) {
      now = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();
      <span class="keywordflow">if</span> (!bucket.wouldOverflow(now)) {
          <span class="keywordflow">if</span> (<span class="keyword">true</span> == sendData(data, chunkSize)) {
              data += chunkSize;
              bucket.submit(chunkSize);
              dataSent += chunkSize;
          }
      }
</pre></div><br/>
<br/>
 Finally, if submitting another byte will cause the leaky bucket to overflow, then we wait until the submission will be allowed by waiting for an amount time returned by the <code>calculateTimeToSubmit</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">else</span> {
          <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> timeToSubmit =
                                           bucket.calculateTimeToSubmit(now);

          <span class="comment">// Round up the number of microseconds.</span>
          <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> uS = timeToSubmit.<a class="code" href="classbsls_1_1TimeInterval.html#ac444ef74eebd36b28c6eabd8ee1d75cb">totalMicroseconds</a>() +
                               ((timeToSubmit.<a class="code" href="classbsls_1_1TimeInterval.html#a6a37e5f3c58f4e02724d5fc6321d4d08">nanoseconds</a>() % 1000) ? 1 : 0);
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(static_cast&lt;int&gt;(uS));
      }
  }
</pre></div><br/>
<br/>
 Notice that we wait by putting the thread into a sleep state instead of using busy-waiting to better optimize for multi-threaded applications. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:01 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
