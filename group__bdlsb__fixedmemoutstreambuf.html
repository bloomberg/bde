<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlsb_fixedmemoutstreambuf Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlsb_fixedmemoutstreambuf<br/>
<small>
[<a class="el" href="group__bdlsb.html">Package bdlsb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an output <code>basic_streambuf</code> using a client buffer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlsb.html">bdlsb</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Streaming Architecture</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Directly Observing Stream Buffer Contents</a> </li>
<li>
<a href="#3.2.2">Example 2: Fixed Buffer Size</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an output <code>basic_streambuf</code> using a client buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a> </td><td>output stream buffer using client memory  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlsb__memoutstreambuf.html" title="Provide an output basic_streambuf using managed memory.">Component bdlsb_memoutstreambuf</a>, <a class="el" href="group__bdlsb__fixedmeminstreambuf.html" title="Provide an input basic_streambuf using a client buffer.">Component bdlsb_fixedmeminstreambuf</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a class <code><a class="el" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a></code> that implements the output portion of the <code>bsl::basic_streambuf</code> protocol using a client-supplied memory buffer. Method names necessarily correspond to the protocol-specified method names. Clients supply the character buffer at stream buffer construction, and can later reinitialize the stream buffer with a different character buffer by calling the <code>pubsetbuf</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides none of the input-related functionality of <code>basic_streambuf</code> (see Streaming Architecture, below), nor does it use locales in any way. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="streaming_architecture"></a> <a class="anchor" id="description.streaming_architecture"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Streaming Architecture: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Stream buffers are designed to decouple device handling from content formatting, providing the requisite device handling and possible buffering services, and leaving the formatting to the client stream. The standard C++ IOStreams library further partitions streaming into input streaming and output streaming, separating responsibilities for each at both the stream layer and the stream buffer layer. The BDE streaming library for <code>bdex</code>, including all of <code>bdesb</code>, follows this model. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_directly_observing_stream_buffer_contents"></a> <a class="anchor" id="usage.example_1~3A_directly_observing_stream_buffer_contents"></a> <a class="anchor" id="description.usage.example_1~3A_directly_observing_stream_buffer_contents"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Directly Observing Stream Buffer Contents: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unlike most implementations of the <code>bsl::basic_streambuf</code> concept, <code><a class="el" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a></code> gives the user direct access to the stream's storage, both through the <code>data</code> accessor and through the buffer originally supplied to the constructor. Note that this can be useful in many contexts, such as when we need to perform extra security validation on buffer during the streaming process. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create an array to provide storage for the stream buffer, and construct a <code><a class="el" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a></code> on that array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          STORAGE_SIZE = 64;
  <span class="keywordtype">char</span>                        storage[STORAGE_SIZE];
  <a class="code" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a> buffer(storage, STORAGE_SIZE);
</pre></div><br/>
<br/>
 Notice that <code>storage</code> is on the stack. <code><a class="el" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a></code> can be easily used without resorting to dynamic memory allocation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we observe that <code>buffer</code> already has a capacity of 64. Note that this capacity is fixed at construction: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(STORAGE_SIZE == buffer.capacity());
  assert( 0 == buffer.length());
  assert(buffer.data() == storage);
</pre></div><br/>
<br/>
 Next, we use <code>buffer</code> to construct a <code>bsl::ostream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::ostream stream(&amp;buffer);
</pre></div><br/>
<br/>
 Now, we output some data to the <code>stream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  stream &lt;&lt; <span class="stringliteral">&quot;The answer is &quot;</span> &lt;&lt; 42 &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;
</pre></div><br/>
<br/>
 Finally, we observe that the data is present in the storage array that we supplied to <code>buffer</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(17 == buffer.length());
  assert(buffer.length() &lt; STORAGE_SIZE);
  assert(0 == strncmp(<span class="stringliteral">&quot;The answer is 42.&quot;</span>, storage, 17));
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_fixed_buffer_size"></a> <a class="anchor" id="usage.example_2~3A_fixed_buffer_size"></a> <a class="anchor" id="description.usage.example_2~3A_fixed_buffer_size"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Fixed Buffer Size: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unlike most implementations of the <code>bsl::basic_streambuf</code> concept, <code><a class="el" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a></code> uses a buffer of limited size, provided to the constructor together with the address of the storage buffer. That limit will not be exceeded even in case of superfluous data. Symbols beyond this limit will be ignored. Note that this can be useful if memory allocation should be strictly controlled. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create an array to provide storage for the stream buffer, fill it with some data and construct a <code><a class="el" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a></code> on the part of that array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> SMALL_STORAGE_SIZE = 16;
  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> SMALL_BUFFER_CAPACITY = SMALL_STORAGE_SIZE/2;
  <span class="keywordtype">char</span>               smallStorage[SMALL_STORAGE_SIZE];
  memset(smallStorage, <span class="charliteral">&#39;Z&#39;</span>, SMALL_STORAGE_SIZE);

  <a class="code" href="classbdlsb_1_1FixedMemOutStreamBuf.html">bdlsb::FixedMemOutStreamBuf</a> smallBuffer(smallStorage,
                                          SMALL_BUFFER_CAPACITY);
</pre></div><br/>
<br/>
 Next, we write some characters to the buffer and check that it handles them correctly and superfluous data is ignored: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::streamsize returnedSize = smallBuffer.sputn(<span class="stringliteral">&quot;The answer is 42.&quot;</span>, 17);
  assert(SMALL_BUFFER_CAPACITY == returnedSize);
  assert(SMALL_BUFFER_CAPACITY == smallBuffer.length());
  assert(<span class="charliteral">&#39;Z&#39;</span> == smallStorage[smallBuffer.length()]);
</pre></div><br/>
<br/>
 Then, we reset position indicator to the beginning of storage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  smallBuffer.pubseekpos(0,bsl::ios_base::out);
  assert(0 == smallBuffer.length());
</pre></div><br/>
<br/>
 Now, we write another string, containing fewer characters than the storage capacity: <br/>
<br/>
<div class="fragment"><pre class="fragment">  returnedSize = smallBuffer.sputn(<span class="stringliteral">&quot;Truth.&quot;</span>, 6);
</pre></div><br/>
<br/>
 Finally, we observe that given string has been successfully placed to buffer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(6 == returnedSize);
  assert(6 == smallBuffer.length());
  assert(0 == strncmp(<span class="stringliteral">&quot;Truth.&quot;</span>, smallStorage, 6));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:48 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
