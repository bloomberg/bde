<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslstl_hashtable Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_hashtable<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a hash-container with support for duplicate values.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html">bslstl</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on <code>KEY_CONFIG</code></a> </li>
<li>
<a href="#3.2">Memory Allocation</a> <ul>
<li>
<a href="#3.2.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Exception Safety</a> </li>
<li>
<a href="#3.4">Internal Data Structure</a> </li>
<li>
<a href="#3.5">Usage</a> </li>
<li>
<a href="#3.6">Example 1: Implementing a Hashed Set Container</a> </li>
<li>
<a href="#3.7">Example 2: Implementing a Hashed Map Container</a> </li>
<li>
<a href="#3.8">Example 3: Implementing a Hashed Multi-Map Container</a> </li>
<li>
<a href="#3.9">Example 4: Implementing a Custom Container</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a hash-container with support for duplicate values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a>  </td><td>hashed-table container for user-supplied object types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bsl+stdhdrs </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template, <code>HashTable</code>, implementing a value-semantic container that can be used to easily implement the four <code>unordered</code> containers specified by the C++11 standard. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>HashTable</code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of keys) and the ordered sequence of keys the <code>HashTable</code> contains. If <code>HashTable</code> is instantiated with a key type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if the key type cannot be tested for equality, then a HashTable containing that type cannot be tested for equality. It is even possible to instantiate <code>HashTable</code> with a key type that does not have a copy-constructor, in which case the <code>HashTable</code> will not be copyable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_key_config"></a> <a class="anchor" id="description.requirements_on_key_config"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on KEY_CONFIG: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The elements stored in a <code>HashTable</code> and the key by which they are indexed are defined by a <code>KEY_CONFIG</code> template type parameter. The user-supplied <code>KEY_CONFIG</code> type must provide two type aliases named <code>ValueType</code> and <code>KeyType</code> that name the type of element stored and its associated key type respectively. In addition, a <code>KEY_CONFIG</code> class shall provide a static member function which may be called as if it had the following signature: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keyword">const</span> KeyType&amp; extractKey(<span class="keyword">const</span> ValueType&amp; value);
      <span class="comment">// Return a reference offering non-modifiable access to the key for the</span>
      <span class="comment">// specified &#39;value&#39;.</span>
</pre></div><br/>
<br/>
 Optionally, the <code>KEY_CONFIG</code> class might provide an <code>extractKey</code> function with the alternative signature: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> KeyType&amp; extractKey(ValueType&amp; value);
      <span class="comment">// Return a reference to the key for the specified &#39;value&#39;.</span>
</pre></div><br/>
<br/>
 This alternative signature is necessary to support the rare case that a hash function or comparator used to configure the <code>HashTable</code> template below take their arguments by non-const reference. This is subject to additional constraints that these functions may not modify the passed arguments, and is inherently a fragile interface and not recommended. It is supported only for C++ Standard conformance. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>HashTable</code> is a <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the configured <code>ValueType</code> is value-semantic. It is possible to instantiate a <code>HashTable</code> configured with a <code>ValueType</code> that does not provide a full <code>HashTable</code> of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code>HashTable</code> to describe a function's requirements for the <code>KEY</code> template parameter. These terms are also defined in [utility.arg.requirements] (section 17.6.3.1 of the C++11 standard). Note that, in the context of a <code>HashTable</code> instantiation, the requirements apply specifically to the <code>HashTable</code>s element type, <code>ValueType</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_key_config.default-constructible"></a> <a class="anchor" id="description.requirements_on_key_config.default-constructible"></a> <em>default-constructible</em>: The type provides a default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_key_config.copy-constructible"></a> <a class="anchor" id="description.requirements_on_key_config.copy-constructible"></a> <em>copy-constructible</em>: The type provides a copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_key_config.equality-comparable"></a> <a class="anchor" id="description.requirements_on_key_config.equality-comparable"></a> <em>equality-comparable</em>: The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a HashTable's <code>ALLOCATOR</code> template parameter determines how that HashTable will allocate memory. The <code>HashTable</code> template supports allocators meeting the requirements of the C++ standard allocator requirements ([allocator.requirements], C++11 17.6.3.5); in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the parameterized <code>ALLOCATOR</code> type of an <code>HashTable</code> instantiation is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that HashTable type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a HashTable accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it will be used to supply memory for the HashTable throughout its lifetime; otherwise, the HashTable will use the default allocator installed at the time of the HashTable's construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, a HashTable supplies that allocator's address to the constructors of contained objects of the configured <code>ValueType</code> with the <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception_safety"></a> <a class="anchor" id="description.exception_safety"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Exception Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The operations of a <code>HashTable</code> provide the strong exception guarantee (see {'bsldoc_glossary')) except in the presence of a hash-functor or equality-comparator that throws exceptions. If either the hash-function or equality-comparator throws an exception from a non-const method, <code>HashTable</code> provides only the basic exception guarantee, and the operation will leave the container in a valid but unspecified (potentially empty) state. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="internal_data_structure"></a> <a class="anchor" id="description.internal_data_structure"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Internal Data Structure: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This implementation of a hash-table uses a single bidirectional list, to hold all the elements stored in the container, and the elements in this list are indexed by a dynamic array of buckets, each of which holds a pointer to the first and last element in the linked-list whose adjusted hash-values are equal to that bucket's index. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As we do not cache the hashed value, if any hash function throws we will either do nothing and allow the exception to propagate, or, if some change of state has already been made, clear the whole container to provide the basic exception guarantee. There are similar concerns for the <code>COMPARATOR</code> predicate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. The <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> class template provides a common foundation for implementing the four standard unordered containers: <ul>
<li>
<code><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a></code>  </li>
<li>
<code><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a></code>  </li>
<li>
<code><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a></code>  </li>
<li>
<code><a class="el" href="classbsl_1_1unordered__set.html">bsl::unordered_set</a></code>  </li>
</ul>
This and the subsequent examples in this component use the <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> class to implement several model container classes, each providing a small but representative sub-set of the functionality of one of the standard unordered containers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_hashed_set_container"></a> <a class="anchor" id="description.example_1~3A_implementing_a_hashed_set_container"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="description.example_1"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Hashed Set Container: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to implement, <code>MyHashedSet</code>, a greatly abbreviated version of <code><a class="el" href="classbsl_1_1unordered__set.html">bsl::unordered_set</a></code>. The <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> class template can be used as the basis of that implementation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define <code>UseEntireValueAsKey</code>, a class template we can use to configure <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> to use its entire elements as keys for its hasher, a policy suitable for a set container. (Later, in <a href="group__bslstl__hashtable.html#example_2" class="el">Example 2</a>, we will define <code>UseFirstValueOfPairAsKey</code> for use in a map container. Note that, in practice, developers can use the existing classes in <a href="group__bslstl__unorderedmapkeyconfiguration.html" class="el"><code>bslstl_unorderedmapkeyconfiguration</code></a> and <a href="group__bslstl__unorderedsetkeyconfiguration.html" class="el"><code>bslstl_unorderedsetkeyconfiguration</code></a>.) <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ==========================</span>
                          <span class="comment">// struct UseEntireValueAsKey</span>
                          <span class="comment">// ==========================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keyword">struct </span>UseEntireValueAsKey {
      <span class="comment">// This &#39;struct&#39; provides a namespace for types and methods that define</span>
      <span class="comment">// the policy by which the key value of a hashed container (i.e., the</span>
      <span class="comment">// value passed to the hasher) is extracted from the objects stored in</span>
      <span class="comment">// the hashed container (the &#39;value&#39; type).</span>

      <span class="keyword">typedef</span> VALUE_TYPE ValueType;
          <span class="comment">// Alias for &#39;VALUE_TYPE&#39;, the type stored in the hashed container.</span>

      <span class="keyword">typedef</span> ValueType KeyType;
          <span class="comment">// Alias for the type passed to the hasher by the hashed container.</span>
          <span class="comment">// In this policy, that type is &#39;ValueType&#39;.</span>

      <span class="keyword">static</span> <span class="keyword">const</span> KeyType&amp; extractKey(<span class="keyword">const</span> ValueType&amp; value);
          <span class="comment">// Return the key value for the specified &#39;value&#39;.  In this policy,</span>
          <span class="comment">// that is &#39;value&#39; itself.</span>
  };

                          <span class="comment">// --------------------------</span>
                          <span class="comment">// struct UseEntireValueAsKey</span>
                          <span class="comment">// --------------------------</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <span class="keyword">typename</span> UseEntireValueAsKey&lt;VALUE_TYPE&gt;::KeyType&amp;
                 UseEntireValueAsKey&lt;VALUE_TYPE&gt;::extractKey(
                                                      <span class="keyword">const</span> ValueType&amp; value)
  {
      <span class="keywordflow">return</span> value;
  }
</pre></div><br/>
<br/>
 Next, we define <code>MyPair</code>, a class template that can hold a pair of values of arbitrary types. This will be used to in <code>MyHashedSet</code> to return the status of the <code>insert</code> method, which must provide an iterator to the inserted value and a boolean value indicating if the value is newly inserted if it previously exiting in the set. The <code>MyPair</code> class template will also appear in <a href="group__bslstl__hashtable.html#example_2" class="el">Example 2</a> and <a href="group__bslstl__hashtable.html#example_3" class="el">Example 3</a>. Note that in practice, users can use the standard <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> in this role; the 'MyPair class template is used in these examples to avoid creating a dependency of <code>bslstl_hashtable</code> on <code>bslstl_pair</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">                      <span class="comment">// =============</span>
                      <span class="comment">// struct MyPair</span>
                      <span class="comment">// =============</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> FIRST_TYPE, <span class="keyword">class</span> SECOND_TYPE&gt;
  <span class="keyword">struct </span>MyPair {
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span>  FIRST_TYPE  first_type;
      <span class="keyword">typedef</span> SECOND_TYPE second_type;

      <span class="comment">// DATA</span>
      first_type  first;
      second_type second;

      <span class="comment">// CREATORS</span>
      MyPair();
          <span class="comment">// Create a &#39;MyPair&#39; object with a default constructed &#39;first&#39;</span>
          <span class="comment">// member and a default constructed &#39;second&#39; member.</span>

      MyPair(first_type firstValue, second_type secondValue);
          <span class="comment">// Create a &#39;MyPair&#39; object with a &#39;first&#39; member equal to the</span>
          <span class="comment">// specified &#39;firstValue&#39; and the &#39;second&#39; member equal to the</span>
          <span class="comment">// specified &#39;secondValue&#39;.</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> FIRST_TYPE, <span class="keyword">class</span> SECOND_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> MyPair&lt;FIRST_TYPE, SECOND_TYPE&gt;&amp; lhs,
                  <span class="keyword">const</span> MyPair&lt;FIRST_TYPE, SECOND_TYPE&gt;&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; MyPair objects have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  &#39;lhs&#39; has the same value as</span>
      <span class="comment">// &#39;rhs&#39; if &#39;lhs.first == rhs.first&#39; and &#39;lhs.second == rhs.second&#39;.</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> FIRST_TYPE, <span class="keyword">class</span> SECOND_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aceb1a703f6f64327cd3cdcd03a557f4a">operator!=</a>(<span class="keyword">const</span> MyPair&lt;FIRST_TYPE, SECOND_TYPE&gt;&amp; lhs,
                  <span class="keyword">const</span> MyPair&lt;FIRST_TYPE, SECOND_TYPE&gt;&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; MyPair objects do not</span>
      <span class="comment">// have the same value, and &#39;false&#39; otherwise.  &#39;lhs&#39; does not have the</span>
      <span class="comment">// same value as &#39;rhs&#39; if &#39;lhs.first != rhs.first&#39; or</span>
      <span class="comment">// &#39;lhs.second != rhs.second&#39;.</span>

                      <span class="comment">// -------------</span>
                      <span class="comment">// struct MyPair</span>
                      <span class="comment">// -------------</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> FIRST_TYPE, <span class="keyword">class</span> SECOND_TYPE&gt;
  <span class="keyword">inline</span>
  MyPair&lt;FIRST_TYPE,SECOND_TYPE&gt;::MyPair()
  : first()
  , second()
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> FIRST_TYPE, <span class="keyword">class</span> SECOND_TYPE&gt;
  <span class="keyword">inline</span>
  MyPair&lt;FIRST_TYPE,SECOND_TYPE&gt;::MyPair( first_type firstValue,
                                         second_type secondValue)
  : first(firstValue)
  , second(secondValue)
  {
  }

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> FIRST_TYPE, <span class="keyword">class</span> SECOND_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> MyPair&lt;FIRST_TYPE, SECOND_TYPE&gt;&amp; lhs,
                  <span class="keyword">const</span> MyPair&lt;FIRST_TYPE, SECOND_TYPE&gt;&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.first == rhs.first &amp;&amp; lhs.second == rhs.second;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> FIRST_TYPE, <span class="keyword">class</span> SECOND_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aceb1a703f6f64327cd3cdcd03a557f4a">operator!=</a>(<span class="keyword">const</span> MyPair&lt;FIRST_TYPE, SECOND_TYPE&gt;&amp; lhs,
                  <span class="keyword">const</span> MyPair&lt;FIRST_TYPE, SECOND_TYPE&gt;&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.first != rhs.first || lhs.second != rhs.second;
  }
</pre></div><br/>
<br/>
 Then, we define our <code>MyHashedSet</code> class template with an instance of <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> (configured using <code>UseEntireValueAsKey</code>) as its sole data member. We provide <code>insert</code> method, to allow us to populate these sets, and the <code>find</code> method to allow us to examine those elements. We also provide <code>size</code> and <code>bucket_count</code> accessor methods to let us check the inner workings of our class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the standard classes define aliases for the templated parameters and other types. In the interest of brevity, this model class (and the classes in the subsequent examples) do not define such aliases except where strictly needed for the example. <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// =================</span>
                          <span class="comment">// class MyHashedSet</span>
                          <span class="comment">// =================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class </span>KEY,
            <span class="keyword">class </span>HASH      = <a class="code" href="structbsl_1_1hash.html">bsl::hash&lt;KEY&gt;</a>,
            <span class="keyword">class </span>EQUAL     = <a class="code" href="structbsl_1_1equal__to.html" title="C++11-compliant binary functor applying operator==">bsl::equal_to&lt;KEY&gt;</a>,
            <span class="keyword">class </span>ALLOCATOR = <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;KEY&gt;</a> &gt;
  <span class="keyword">class </span>MyHashedSet
  {
    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits&lt;ALLOCATOR&gt;</a>          AllocatorTraits;
      <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocatorTraits::difference_type difference_type;
      <span class="keyword">typedef</span> <a class="code" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt;<span class="keyword">const</span> KEY,
                                                     difference_type&gt;
                                                        iterator;

      <span class="comment">// DATA</span>
      BloombergLP::bslstl::HashTable&lt;UseEntireValueAsKey&lt;KEY&gt;,
                                     HASH,
                                     EQUAL,
                                     ALLOCATOR&gt; d_impl;
    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocatorTraits::size_type size_type;
      <span class="keyword">typedef</span> iterator                            const_iterator;

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyHashedSet(size_type        initialNumBuckets = 0,
                           <span class="keyword">const</span> HASH&amp;      hash              = HASH(),
                           <span class="keyword">const</span> EQUAL&amp;     keyEqual          = EQUAL(),
                           <span class="keyword">const</span> ALLOCATOR&amp; allocator         = ALLOCATOR());
          <span class="comment">// Create an empty &#39;MyHashedSet&#39; object having a maximum load</span>
          <span class="comment">// factor of 1.  Optionally specify at least &#39;initialNumBuckets&#39; in</span>
          <span class="comment">// this container&#39;s initial array of buckets.  If</span>
          <span class="comment">// &#39;initialNumBuckets&#39; is not supplied, an implementation defined</span>
          <span class="comment">// value is used.  Optionally specify a &#39;hash&#39; used to generate the</span>
          <span class="comment">// hash values associated to the keys extracted from the values</span>
          <span class="comment">// contained in this object.  If &#39;hash&#39; is not supplied, a</span>
          <span class="comment">// default-constructed object of type &#39;HASH&#39; is used.  Optionally</span>
          <span class="comment">// specify a key-equality functor &#39;keyEqual&#39; used to verify that</span>
          <span class="comment">// two key values are the same.  If &#39;keyEqual&#39; is not supplied, a</span>
          <span class="comment">// default-constructed object of type &#39;EQUAL&#39; is used.  Optionally</span>
          <span class="comment">// specify an &#39;allocator&#39; used to supply memory.  If &#39;allocator&#39; is</span>
          <span class="comment">// not supplied, a default-constructed object of the (template</span>
          <span class="comment">// parameter) type &#39;ALLOCATOR&#39; is used.  If the &#39;ALLOCATOR&#39; is</span>
          <span class="comment">// &#39;bsl::allocator&#39; (the default), then &#39;allocator&#39; shall be</span>
          <span class="comment">// convertible to &#39;bslma::Allocator *&#39;.  If the &#39;ALLOCATOR&#39; is</span>
          <span class="comment">// &#39;bsl::allocator&#39; and &#39;allocator&#39; is not supplied, the currently</span>
          <span class="comment">// installed default allocator will be used to supply memory.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      MyPair&lt;const_iterator, bool&gt; insert(<span class="keyword">const</span> KEY&amp; value);
          <span class="comment">// Insert the specified &#39;value&#39; into this set if the &#39;value&#39; does</span>
          <span class="comment">// not already exist in this set; otherwise, this method has no</span>
          <span class="comment">// effect.  Return a pair whose &#39;first&#39; member is an iterator</span>
          <span class="comment">// providing non-modifiable access to the (possibly newly inserted)</span>
          <span class="comment">// &#39;KEY&#39; object having &#39;value&#39; (according to &#39;EQUAL&#39;) and whose</span>
          <span class="comment">// &#39;second&#39; member is &#39;true&#39; if a new element was inserted, and</span>
          <span class="comment">// &#39;false&#39; if &#39;value&#39; was already present.</span>

      <span class="comment">// ACCESSORS</span>
      size_type bucket_count() <span class="keyword">const</span>;
          <span class="comment">// Return the number of buckets in this set.</span>

      const_iterator cend() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// past-the-end element (in the sequence of &#39;KEY&#39; objects)</span>
          <span class="comment">// maintained by this set.</span>

      const_iterator find(<span class="keyword">const</span> KEY&amp; value) <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the &#39;KEY&#39;</span>
          <span class="comment">// object in this set having the specified &#39;value&#39;, if such an</span>
          <span class="comment">// entry exists, and the iterator returned by the &#39;cend&#39; method</span>
          <span class="comment">// otherwise.</span>

      size_type size() <span class="keyword">const</span>;
          <span class="comment">// Return the number of elements in this set.</span>
  };
</pre></div><br/>
<br/>
 Next, we implement the methods of <code>MyHashedSet</code>. In many cases, the implementations consist mainly in forwarding arguments to and returning values from the underlying <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// =================</span>
                          <span class="comment">// class MyHashedSet</span>
                          <span class="comment">// =================</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::MyHashedSet(
                                          size_type        initialNumBuckets,
                                          <span class="keyword">const</span> HASH&amp;      hash,
                                          <span class="keyword">const</span> EQUAL&amp;     keyEqual,
                                          <span class="keyword">const</span> ALLOCATOR&amp; allocator)
  : d_impl(hash, keyEqual, initialNumBuckets, allocator)
  {
  }
</pre></div><br/>
<br/>
 Note that the <code>insertIfMissing</code> method of <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> provides the semantics needed for adding values (unique values only) to sets. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  MyPair&lt;typename MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::iterator,
         <span class="keywordtype">bool</span>&gt;    MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::insert(
                                                            <span class="keyword">const</span> KEY&amp; value)
  {
      <span class="keyword">typedef</span> MyPair&lt;iterator, bool&gt; ResultType;

      <span class="keywordtype">bool</span>                       isInsertedFlag = <span class="keyword">false</span>;
      <a class="code" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *result         = d_impl.insertIfMissing(
                                                             &amp;isInsertedFlag,
                                                             value);
      <span class="keywordflow">return</span> ResultType(iterator(result), isInsertedFlag);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  <span class="keyword">typename</span> MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::size_type
           MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::bucket_count()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_impl.numBuckets();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  <span class="keyword">typename</span> MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
           MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::cend()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> const_iterator();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  <span class="keyword">typename</span> MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
           MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::find(<span class="keyword">const</span> KEY&amp; key)<span class="keyword"></span>
<span class="keyword">                                                                        const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> const_iterator(d_impl.find(key));
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  <span class="keyword">typename</span> MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::size_type
           MyHashedSet&lt;KEY, HASH, EQUAL, ALLOCATOR&gt;::size()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_impl.size();
  }
</pre></div><br/>
<br/>
 Finally, we create <code>mhs</code>, an instance of <code>MyHashedSet</code>, exercise it, and confirm that it behaves as expected. <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyHashedSet&lt;int&gt; mhs;
  assert( 0    == mhs.size());
  assert( 1    == mhs.bucket_count());
</pre></div><br/>
<br/>
 Notice that the newly created set is empty and has a single bucket. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Inserting a value (10) succeeds the first time but correctly fails on the second attempt. <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPair&lt;MyHashedSet&lt;int&gt;::const_iterator, <span class="keywordtype">bool</span>&gt; status;

  status = mhs.insert(10);
  assert( 1    ==  mhs.size());
  assert(10    == *status.first)
  assert(true  ==  status.second);

  status = mhs.insert(10);
  assert( 1    ==  mhs.size());
  assert(10    == *status.first)
  assert(false ==  status.second);
</pre></div><br/>
<br/>
 We can insert a different value (20) and thereby increase the set size to 2. <br/>
<br/>
<div class="fragment"><pre class="fragment">  status = mhs.insert(20);
  assert( 2    ==  mhs.size());
  assert(20    == *status.first)
  assert(true  ==  status.second);
</pre></div><br/>
<br/>
 Each of the inserted values (10, 20) can be found in the set. <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyHashedSet&lt;int&gt;::const_iterator itr, end = mhs.cend();

  itr = mhs.find(10);
  assert(end !=  itr);
  assert(10  == *itr);

  itr = mhs.find(20);
  assert(end !=  itr);
  assert(20  == *itr);
</pre></div><br/>
<br/>
 However, a value known to absent from the set (0), is correctly reported as not there. <br/>
<br/>
<div class="fragment"><pre class="fragment">  itr = mhs.find(0);
  assert(end ==  itr);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_implementing_a_hashed_map_container"></a> <a class="anchor" id="description.example_2~3A_implementing_a_hashed_map_container"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="description.example_2"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Implementing a Hashed Map Container: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to implement, <code>MyHashedMap</code>, a greatly abbreviated version of <code><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a></code>. As with <code>MyHashedSet</code> (see <a href="group__bslstl__hashtable.html#example_1" class="el">Example 1</a>), the <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> class template can be used as the basis of our implementation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define <code>UseFirstValueOfPairAsKey</code>, a class template we can use to configure <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> to use the <code>first</code> member of each element, each a <code>MyPair</code>, as the key-value for hashing. Note that, in practice, developers can use class defined in <a href="group__bslstl__unorderedmapkeyconfiguration.html" class="el"><code>bslstl_unorderedmapkeyconfiguration</code></a>. <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ===============================</span>
                          <span class="comment">// struct UseFirstValueOfPairAsKey</span>
                          <span class="comment">// ===============================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keyword">struct </span>UseFirstValueOfPairAsKey {
      <span class="comment">// This &#39;struct&#39; provides a namespace for types and methods that define</span>
      <span class="comment">// the policy by which the key value of a hashed container (i.e., the</span>
      <span class="comment">// value passed to the hasher) is extracted from the objects stored in</span>
      <span class="comment">// the hashed container (the &#39;value&#39; type).</span>

      <span class="keyword">typedef</span> VALUE_TYPE ValueType;
          <span class="comment">// Alias for &#39;VALUE_TYPE&#39;, the type stored in the hashed container.</span>
          <span class="comment">// For this policy &#39;ValueType&#39; must define a public member named</span>
          <span class="comment">// &#39;first&#39; of type &#39;first_type&#39;.</span>

      <span class="keyword">typedef</span> <span class="keyword">typename</span> ValueType::first_type KeyType;
          <span class="comment">// Alias for the type passed to the hasher by the hashed container.</span>
          <span class="comment">// In this policy, that type is the type of the &#39;first&#39; element of</span>
          <span class="comment">// &#39;ValueType&#39;.</span>

      <span class="keyword">static</span> <span class="keyword">const</span> KeyType&amp; extractKey(<span class="keyword">const</span> ValueType&amp; value);
          <span class="comment">// Return the key value for the specified &#39;value&#39;.  In this policy,</span>
          <span class="comment">// that is the value of the &#39;first&#39; member of &#39;value&#39;.</span>
  };

                          <span class="comment">// -------------------------------</span>
                          <span class="comment">// struct UseFirstValueOfPairAsKey</span>
                          <span class="comment">// -------------------------------</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <span class="keyword">typename</span> UseFirstValueOfPairAsKey&lt;VALUE_TYPE&gt;::KeyType&amp;
                 UseFirstValueOfPairAsKey&lt;VALUE_TYPE&gt;::extractKey(
                                                      <span class="keyword">const</span> ValueType&amp; value)
  {
      <span class="keywordflow">return</span> value.first;
  }
</pre></div><br/>
<br/>
 Next, we define our <code>MyHashedMap</code> class template with an instance of <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> (configured using <code>UseFirstValueOfPairAsKey</code>) as its sole data member. In this example, we choose to implement <code>operator[]</code> (corresponding to the signature method of <code><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a></code>) to allow us to populate our maps and to examine their elements. <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// =================</span>
                          <span class="comment">// class MyHashedMap</span>
                          <span class="comment">// =================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class </span>KEY,
            <span class="keyword">class </span>VALUE,
            <span class="keyword">class </span>HASH      = <a class="code" href="structbsl_1_1hash.html">bsl::hash&lt;KEY&gt;</a>,
            <span class="keyword">class </span>EQUAL     = <a class="code" href="structbsl_1_1equal__to.html" title="C++11-compliant binary functor applying operator==">bsl::equal_to&lt;KEY&gt;</a>,
            <span class="keyword">class </span>ALLOCATOR = <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;KEY&gt;</a> &gt;
  <span class="keyword">class </span>MyHashedMap
  {
    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits&lt;ALLOCATOR&gt;</a>          AllocatorTraits;

      <span class="keyword">typedef</span> BloombergLP::bslstl::HashTable&lt;
                      UseFirstValueOfPairAsKey&lt;MyPair&lt;const KEY, VALUE&gt; &gt;,
                      HASH,
                      EQUAL,
                      ALLOCATOR&gt;                     HashTable;

      <span class="comment">// DATA</span>
      HashTable d_impl;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocatorTraits::size_type size_type;

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyHashedMap(size_type        initialNumBuckets = 0,
                           <span class="keyword">const</span> HASH&amp;      hash              = HASH(),
                           <span class="keyword">const</span> EQUAL&amp;     keyEqual          = EQUAL(),
                           <span class="keyword">const</span> ALLOCATOR&amp; allocator         = ALLOCATOR());
      <span class="comment">// Create an empty &#39;MyHashedMap&#39; object having a maximum load factor</span>
      <span class="comment">// of 1.  Optionally specify at least &#39;initialNumBuckets&#39; in this</span>
      <span class="comment">// container&#39;s initial array of buckets.  If &#39;initialNumBuckets&#39; is not</span>
      <span class="comment">// supplied, one empty bucket shall be used and no memory allocated.</span>
      <span class="comment">// Optionally specify &#39;hash&#39; to generate the hash values associated</span>
      <span class="comment">// with the key-value pairs contained in this unordered map.  If &#39;hash&#39;</span>
      <span class="comment">// is not supplied, a default-constructed object of (template</span>
      <span class="comment">// parameter) &#39;HASH&#39; is used.  Optionally specify a key-equality</span>
      <span class="comment">// functor &#39;keyEqual&#39; used to determine whether two keys have the same</span>
      <span class="comment">// value.  If &#39;keyEqual&#39; is not supplied, a default-constructed object</span>
      <span class="comment">// of (template parameter) &#39;EQUAL&#39; is used.  Optionally specify an</span>
      <span class="comment">// &#39;allocator&#39; used to supply memory.  If &#39;allocator&#39; is not supplied,</span>
      <span class="comment">// a default-constructed object of the (template parameter) type</span>
      <span class="comment">// &#39;ALLOCATOR&#39; is used.  If &#39;ALLOCATOR&#39; is &#39;bsl::allocator&#39; (the</span>
      <span class="comment">// default), then &#39;allocator&#39; shall be convertible to</span>
      <span class="comment">// &#39;bslma::Allocator *&#39;.  If &#39;ALLOCATOR&#39; is &#39;bsl::allocator&#39; and</span>
      <span class="comment">// &#39;allocator&#39; is not supplied, the currently installed default</span>
      <span class="comment">// allocator will be used to supply memory.  Note that more than</span>
      <span class="comment">// &#39;initialNumBuckets&#39; buckets may be created in order to preserve the</span>
      <span class="comment">// bucket allocation strategy of the hash-table (but never fewer).</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      VALUE&amp; operator[](<span class="keyword">const</span> KEY&amp; key);
          <span class="comment">// Return a reference providing modifiable access to the</span>
          <span class="comment">// mapped-value associated with the specified &#39;key&#39; in this</span>
          <span class="comment">// unordered map; if this unordered map does not already contain a</span>
          <span class="comment">// &#39;value_type&#39; object with &#39;key&#39;, first insert a new &#39;value_type&#39;</span>
          <span class="comment">// object having &#39;key&#39; and a default-constructed &#39;VALUE&#39; object.</span>
          <span class="comment">// This method requires that the (template parameter) type &#39;KEY&#39; is</span>
          <span class="comment">// &quot;copy-constructible&quot; and the (template parameter) &#39;VALUE&#39; is</span>
          <span class="comment">// &quot;default-constructible&quot;.</span>
  };
</pre></div><br/>
<br/>
 Then, we implement the methods <code>MyHashedMap</code>. The construct need merely forward its arguments to the constructor of <code>d_impl</code>, <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// =================</span>
                          <span class="comment">// class MyHashedMap</span>
                          <span class="comment">// =================</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> VALUE, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  MyHashedMap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::MyHashedMap(
                                          size_type        initialNumBuckets,
                                          <span class="keyword">const</span> HASH&amp;      hash,
                                          <span class="keyword">const</span> EQUAL&amp;     keyEqual,
                                          <span class="keyword">const</span> ALLOCATOR&amp; allocator)
  : d_impl(hash, keyEqual, initialNumBuckets, allocator)
  {
  }
</pre></div><br/>
<br/>
 As with <code>MyHashedSet</code>, the <code>insertIfMissing</code> method of <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> provides the semantics we need: an element is inserted only if no such element (no element with the same key) in the container, and a reference to that element (<code>node</code>) is returned. Here, we use <code>node</code> to obtain and return a reference offering modifiable access to the <code>second</code> member of the (possibly newly added) element. Note that the <code>static_cast</code> from <code>HashTableLink *</code> to <code>HashTableNode *</code> is valid because the nodes derive from the link type (see <code>bslalg_bidirectionallink</code> and <code>bslalg_hashtableimputil</code>). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> VALUE, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  VALUE&amp; MyHashedMap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::operator[](
                                                              <span class="keyword">const</span> KEY&amp; key)
  {
      <span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable::NodeType           HashTableNode;
      <span class="keyword">typedef</span> BloombergLP::bslalg::BidirectionalLink HashTableLink;

      HashTableLink *node = d_impl.insertIfMissing(key);
      <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>HashTableNode *<span class="keyword">&gt;</span>(node)-&gt;value().second;
  }
</pre></div><br/>
<br/>
 Finally, we create <code>mhm</code>, an instance of <code>MyHashedMap</code>, exercise it, and confirm that it behaves as expected. We can add an element (with key value of 0). <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyHashedMap&lt;int, double&gt; mhm;

  mhm[0] = 1.234;
  assert(1.234 == mhm[0]);
</pre></div><br/>
<br/>
 We can change the value of the element with key value 0. <br/>
<br/>
<div class="fragment"><pre class="fragment">  mhm[0] = 4.321;
  assert(4.321 == mhm[0]);
</pre></div><br/>
<br/>
 We can add a new element (key value 1), without changing the previously existing element (key value 0). <br/>
<br/>
<div class="fragment"><pre class="fragment">  mhm[1] = 5.768;
  assert(5.768 == mhm[1]);
  assert(4.321 == mhm[0]);
</pre></div><br/>
<br/>
 Accessing a non-existing element (key value 2) creates that element and populates it with the default value of the mapped value (0.0). <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0.000 == mhm[2]);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_implementing_a_hashed_multi-map_container"></a> <a class="anchor" id="description.example_3~3A_implementing_a_hashed_multi-map_container"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="description.example_3"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Implementing a Hashed Multi-Map Container: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to implement, <code>MyHashedMultiMap</code>, a greatly abbreviated version of <code><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a></code>. As with <code>MyHashedSet</code> and <code>MyHashedMap</code> (see <a href="group__bslstl__hashtable.html#example_1" class="el">Example 1</a>, and <a href="group__bslstl__hashtable.html#example_2" class="el">Example 2</a>, respectively), the <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> class template can be used as the basis of our implementation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we need a class template to configure <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> to extract key values in manner appropriate for maps. The previously defined <code>UseFirstValueOfPairAsKey</code> class template (see <a href="group__bslstl__hashtable.html#example_2" class="el">Example 2</a>) suits perfectly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we define our <code>MyHashedMultiMap</code> class template with an instance of <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> (configured using <code>UseFirstValueOfPairAsKey</code>) as its sole data member. In this example, we choose to implement an <code>insert</code> method to populate our container, and an <code>equal_range</code> method (a signature method of the multi containers) to provide access to those elements. <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ======================</span>
                          <span class="comment">// class MyHashedMultiMap</span>
                          <span class="comment">// ======================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class </span>KEY,
            <span class="keyword">class </span>VALUE,
            <span class="keyword">class </span>HASH      = <a class="code" href="structbsl_1_1hash.html">bsl::hash&lt;KEY&gt;</a>,
            <span class="keyword">class </span>EQUAL     = <a class="code" href="structbsl_1_1equal__to.html" title="C++11-compliant binary functor applying operator==">bsl::equal_to&lt;KEY&gt;</a>,
            <span class="keyword">class </span>ALLOCATOR = <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;KEY&gt;</a> &gt;
  <span class="keyword">class </span>MyHashedMultiMap
  {
    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> MyPair&lt;const KEY, VALUE&gt;                  value_type;
      <span class="keyword">typedef</span> <a class="code" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits&lt;ALLOCATOR&gt;</a>          AllocatorTraits;
      <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocatorTraits::difference_type difference_type;

      <span class="keyword">typedef</span> BloombergLP::bslstl::HashTable&lt;
                         UseFirstValueOfPairAsKey&lt;MyPair&lt;const KEY, VALUE&gt; &gt;,
                         HASH,
                         EQUAL,
                         ALLOCATOR&gt;                     HashTable;

      <span class="comment">// DATA</span>
      HashTable d_impl;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocatorTraits::size_type  size_type;

      <span class="keyword">typedef</span> <a class="code" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt;value_type,
                                                     difference_type&gt;
                                                                    iterator;
      <span class="keyword">typedef</span> <a class="code" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt;<span class="keyword">const</span> value_type,
                                                     difference_type&gt;
                                                              const_iterator;

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyHashedMultiMap(
                           size_type        initialNumBuckets = 0,
                           <span class="keyword">const</span> HASH&amp;      hash              = HASH(),
                           <span class="keyword">const</span> EQUAL&amp;     keyEqual          = EQUAL(),
                           <span class="keyword">const</span> ALLOCATOR&amp; allocator         = ALLOCATOR());
      <span class="comment">// Create an empty &#39;MyHashedMultiMap&#39; object having a maximum load</span>
      <span class="comment">// factor of 1.  Optionally specify at least &#39;initialNumBuckets&#39; in</span>
      <span class="comment">// this container&#39;s initial array of buckets.  If &#39;initialNumBuckets&#39;</span>
      <span class="comment">// is not supplied, an implementation defined value is used.</span>
      <span class="comment">// Optionally specify a &#39;hash&#39;, a hash-functor used to generate the</span>
      <span class="comment">// hash values associated to the key-value pairs contained in this</span>
      <span class="comment">// object.  If &#39;hash&#39; is not supplied, a default-constructed object of</span>
      <span class="comment">// (template parameter) &#39;HASH&#39; type is used.  Optionally specify a</span>
      <span class="comment">// key-equality functor &#39;keyEqual&#39; used to verify that two key values</span>
      <span class="comment">// are the same.  If &#39;keyEqual&#39; is not supplied, a default-constructed</span>
      <span class="comment">// object of (template parameter) &#39;EQUAL&#39; type is used.  Optionally</span>
      <span class="comment">// specify an &#39;allocator&#39; used to supply memory.  If &#39;allocator&#39; is not</span>
      <span class="comment">// supplied, a default-constructed object of the (template parameter)</span>
      <span class="comment">// &#39;ALLOCATOR&#39; type is used.  If &#39;ALLOCATOR&#39; is &#39;bsl::allocator&#39; (the</span>
      <span class="comment">// default), then &#39;allocator&#39; shall be convertible to</span>
      <span class="comment">// &#39;bslma::Allocator *&#39;.  If the &#39;ALLOCATOR&#39; is &#39;bsl::allocator&#39; and</span>
      <span class="comment">// &#39;allocator&#39; is not supplied, the currently installed default</span>
      <span class="comment">// allocator will be used to supply memory.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">template</span> &lt;<span class="keyword">class</span> SOURCE_TYPE&gt;
      iterator insert(<span class="keyword">const</span> SOURCE_TYPE&amp; value);
          <span class="comment">// Insert the specified &#39;value&#39; into this multi-map, and return an</span>
          <span class="comment">// iterator to the newly inserted element.  This method requires</span>
          <span class="comment">// that the (class template parameter) types &#39;KEY&#39; and &#39;VALUE&#39;</span>
          <span class="comment">// types both be &quot;copy-constructible&quot;, and that the (function</span>
          <span class="comment">// template parameter) &#39;SOURCE_TYPE&#39; be convertible to the</span>
          <span class="comment">// (class template parameter) &#39;VALUE&#39; type.</span>

      <span class="comment">// ACCESSORS</span>
      MyPair&lt;const_iterator, const_iterator&gt; equal_range(<span class="keyword">const</span> KEY&amp; key)
                                                                       <span class="keyword">const</span>;
          <span class="comment">// Return a pair of iterators providing non-modifiable access to</span>
          <span class="comment">// the sequence of &#39;value_type&#39; objects in this container matching</span>
          <span class="comment">// the specified &#39;key&#39;, where the the first iterator is positioned</span>
          <span class="comment">// at the start of the sequence and the second iterator is</span>
          <span class="comment">// positioned one past the end of the sequence.  If this container</span>
          <span class="comment">// contains no &#39;value_type&#39; objects matching &#39;key&#39; then the two</span>
          <span class="comment">// returned iterators will have the same value.</span>
  };
</pre></div><br/>
<br/>
 Then, we implement the methods <code>MyHashedMultiMap</code>. The construct need merely forward its arguments to the constructor of <code>d_impl</code>, <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ======================</span>
                          <span class="comment">// class MyHashedMultiMap</span>
                          <span class="comment">// ======================</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> VALUE, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">inline</span>
  MyHashedMultiMap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::MyHashedMultiMap(
                                         size_type        initialNumBuckets,
                                         <span class="keyword">const</span> HASH&amp;      hash,
                                         <span class="keyword">const</span> EQUAL&amp;     keyEqual,
                                         <span class="keyword">const</span> ALLOCATOR&amp; allocator)
  : d_impl(hash, keyEqual, initialNumBuckets, allocator)
  {
  }
</pre></div><br/>
<br/>
 Note that here we forgo use of the <code>insertIfMissing</code> method and use the <code>insert</code> method of <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code>. This method supports the semantics of the multi containers: there can be more than one element with the same key value. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> VALUE, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> SOURCE_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keyword">typename</span> MyHashedMultiMap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
           MyHashedMultiMap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::insert(
                                                    <span class="keyword">const</span> SOURCE_TYPE&amp; value)
  {
      <span class="keywordflow">return</span> iterator(d_impl.insert(value));
  }
</pre></div><br/>
<br/>
 The <code>equal_range</code> method need only convert the values returned by the <code>findRange</code> method to the types expected by the caller. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> VALUE, <span class="keyword">class</span> HASH, <span class="keyword">class</span> EQUAL, <span class="keyword">class</span> ALLOCATOR&gt;
  MyPair&lt;<span class="keyword">typename</span> MyHashedMultiMap&lt;KEY,
                                   VALUE,
                                   HASH,
                                   EQUAL,
                                   ALLOCATOR&gt;::const_iterator,
         <span class="keyword">typename</span> MyHashedMultiMap&lt;KEY,
                                   VALUE,
                                   HASH,
                                   EQUAL, ALLOCATOR&gt;::const_iterator&gt;
  MyHashedMultiMap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::equal_range(
                                                        <span class="keyword">const</span> KEY&amp; key)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keyword">typedef</span> MyPair&lt;const_iterator, const_iterator&gt; ResultType;
      <span class="keyword">typedef</span> BloombergLP::bslalg::BidirectionalLink HashTableLink;

      HashTableLink *first;
      HashTableLink *last;
      d_impl.findRange(&amp;first, &amp;last, key);
      <span class="keywordflow">return</span> ResultType(const_iterator(first), const_iterator(last));
  }
</pre></div><br/>
<br/>
 Finally, we create <code>mhmm</code>, an instance of <code>MyHashedMultiMap</code>, exercise it, and confirm that it behaves as expected. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We define several aliases to make our code more concise. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> MyHashedMultiMap&lt;int, double&gt;::iterator       Iterator;
  <span class="keyword">typedef</span> MyHashedMultiMap&lt;int, double&gt;::const_iterator ConstIterator;
  <span class="keyword">typedef</span> MyPair&lt;ConstIterator, ConstIterator&gt;          ConstRange;
</pre></div><br/>
<br/>
 Searching for an element (key value 10) in a newly created, empty container correctly shows the absence of any such element. <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyHashedMultiMap&lt;int, double&gt; mhmm;

  ConstRange range;
  range = mhmm.equal_range(10);
  assert(range.first == range.second);
</pre></div><br/>
<br/>
 We can insert a value (the pair 10, 100.00) into the container... <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPair&lt;const int, double&gt; value(10, 100.00);

  Iterator itr;

  itr = mhmm.insert(value);
  assert(value == *itr);
</pre></div><br/>
<br/>
 ... and we can do so again. <br/>
<br/>
<div class="fragment"><pre class="fragment">  itr = mhmm.insert(value);
  assert(value == *itr);
</pre></div><br/>
<br/>
 We can now find elements with the key value of 10. <br/>
<br/>
<div class="fragment"><pre class="fragment">  range = mhmm.equal_range(10);
  assert(range.first != range.second);
</pre></div><br/>
<br/>
 As expected, there are two such elements, and both are identical in key value (10) and mapped value (100.00). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> count = 0;
  <span class="keywordflow">for</span> (ConstIterator cur  = range.first,
                     end  = range.second;
                     end != cur; ++cur, ++count) {
      assert(value == *cur);
  }
  assert(2 == count);
</pre></div><br/>
<br/>
 } </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_4~3A_implementing_a_custom_container"></a> <a class="anchor" id="description.example_4~3A_implementing_a_custom_container"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="description.example_4"></a> <a class="anchor" id="3.9"></a> </dd></dl>
<dl class="user"><dt><b>Example 4: Implementing a Custom Container: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although the <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> class was created to be a common implementation for the standard unordered classes, this class can also be used in its own right to address other user problems. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we wish to retain a record of sales orders, that each record is characterized by several integer attributes, and that we must be able to find records based on <em>any</em> of those attributes. We can use <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> to implement a custom container supporting multiple key-values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define <code>MySalesRecord</code>, our record class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { MAX_DESCRIPTION_SIZE = 16 };

  <span class="keyword">typedef</span> <span class="keyword">struct </span>MySalesRecord {
      <span class="keywordtype">int</span>  orderNumber;                        <span class="comment">// unique</span>
      <span class="keywordtype">int</span>  customerId;                         <span class="comment">// no constraint</span>
      <span class="keywordtype">int</span>  vendorId;                           <span class="comment">// no constraint</span>
      <span class="keywordtype">char</span> description[MAX_DESCRIPTION_SIZE];  <span class="comment">// ascii string</span>
  } MySalesRecord;
</pre></div><br/>
<br/>
 Notice that only each <code>orderNumber</code> is unique. We expect multiple sales to any given customer (<code>customerId</code>) and multiple sales by any given vendor (<code>vendorId</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We will use a <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> object (a hashtable) to save record values based on the unique <code>orderNumber</code>, and two auxiliary hashtables to provide map <code>customerId</code> and <code>vendorId</code> values to the addresses of the records in the first <code><a class="el" href="classbslstl_1_1HashTable.html">bslstl::HashTable</a></code> object. Note that this implementation relies on the fact that nodes in our hashtables remain stable until they are removed and that in this application we do <em>not</em> allow the removal (or modification) of records once they are inserted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To configure these hashtables, we will need several policy objects to extract relevant portions the <code>MySalesRecord</code> objects for hashing. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, define <code>UseOrderNumberAsKey</code>, a policy class for the hashtable holding the sales record objects. Note that the <code>ValueType</code> is <code>MySalesRecord</code> and that the <code>extractKey</code> method selects the <code>orderNumber</code> attribute: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ==========================</span>
                          <span class="comment">// struct UseOrderNumberAsKey</span>
                          <span class="comment">// ==========================</span>

  <span class="keyword">struct </span>UseOrderNumberAsKey {
      <span class="comment">// This &#39;struct&#39; provides a namespace for types and methods that define</span>
      <span class="comment">// the policy by which the key value of a hashed container (i.e., the</span>
      <span class="comment">// value passed to the hasher) is extracted from the objects stored in</span>
      <span class="comment">// the hashed container (the &#39;value&#39; type).</span>

      <span class="keyword">typedef</span> MySalesRecord ValueType;
          <span class="comment">// Alias for &#39;MySalesRecord&#39;, the type stored in the first</span>
          <span class="comment">// hashtable.</span>

      <span class="keyword">typedef</span> <span class="keywordtype">int</span> KeyType;
          <span class="comment">// Alias for the type passed to the hasher by the hashed container.</span>
          <span class="comment">// In this policy, the value passed to the hasher is the</span>
          <span class="comment">// &#39;orderNumber&#39; attribute, an &#39;int&#39; type.</span>

      <span class="keyword">static</span> <span class="keyword">const</span> KeyType&amp; extractKey(<span class="keyword">const</span> ValueType&amp; value);
          <span class="comment">// Return the key value for the specified &#39;value&#39;.  In this policy,</span>
          <span class="comment">// that is the &#39;orderNumber&#39; attribute of &#39;value&#39;.</span>
  };

                          <span class="comment">// --------------------------</span>
                          <span class="comment">// struct UseOrderNumberAsKey</span>
                          <span class="comment">// --------------------------</span>

  <span class="keyword">inline</span>
  <span class="keyword">const</span> UseOrderNumberAsKey::KeyType&amp;
        UseOrderNumberAsKey::extractKey(<span class="keyword">const</span> ValueType&amp; value)
  {
      <span class="keywordflow">return</span> value.orderNumber;
  }
</pre></div><br/>
<br/>
 Then, we define <code>UseCustomerIdAsKey</code>, the policy class for the hashtable that will multiply map <code>customerId</code> to the addresses of records in the first hashtable. Note that in this policy class the <code>ValueType</code> is <code>const MySalesRecord *</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// =========================</span>
                          <span class="comment">// struct UseCustomerIdAsKey</span>
                          <span class="comment">// =========================</span>

  <span class="keyword">struct </span>UseCustomerIdAsKey {
      <span class="comment">// This &#39;struct&#39; provides a namespace for types and methods that define</span>
      <span class="comment">// the policy by which the key value of a hashed container (i.e., the</span>
      <span class="comment">// value passed to the hasher) is extracted from the objects stored in</span>
      <span class="comment">// the hashed container (the &#39;value&#39; type).</span>

      <span class="keyword">typedef</span> <span class="keyword">const</span> MySalesRecord *ValueType;
          <span class="comment">// Alias for &#39;const MySalesRecord *&#39;, the type stored in second</span>
          <span class="comment">// hashtable, a pointer to the record stored in the first</span>
          <span class="comment">// hashtable.</span>

      <span class="keyword">typedef</span> <span class="keywordtype">int</span> KeyType;
          <span class="comment">// Alias for the type passed to the hasher by the hashed container.</span>
          <span class="comment">// In this policy, the value passed to the hasher is the</span>
          <span class="comment">// &#39;orderNumber&#39; attribute, an &#39;int&#39; type.</span>

      <span class="keyword">static</span> <span class="keyword">const</span> KeyType&amp; extractKey(<span class="keyword">const</span> ValueType&amp; value);
          <span class="comment">// Return the key value for the specified &#39;value&#39;.  In this policy,</span>
          <span class="comment">// that is the &#39;customerId&#39; attribute of &#39;value&#39;.</span>
  };

                          <span class="comment">// -------------------------</span>
                          <span class="comment">// struct UseCustomerIdAsKey</span>
                          <span class="comment">// -------------------------</span>

  <span class="keyword">inline</span>
  <span class="keyword">const</span> UseCustomerIdAsKey::KeyType&amp;
        UseCustomerIdAsKey::extractKey(<span class="keyword">const</span> ValueType&amp; value)
  {
      <span class="keywordflow">return</span> value-&gt;customerId;
  }
</pre></div><br/>
<br/>
 Notice that, since the values in the second hashtable are addresses, the key-value is extracted by reference. This second hashtable allows what map-like semantics, <em>without</em> having to store key-values; those reside in the records in the first hashtable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>UseVendorIdAsKey</code> class, the policy class for the hashtable providing an index by <code>vendorId</code>, is almost a near clone of <code>UseCustomerIdAsKey</code>. It is shown for completeness: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// =======================</span>
                          <span class="comment">// struct UseVendorIdAsKey</span>
                          <span class="comment">// ========================</span>

  <span class="keyword">struct </span>UseVendorIdAsKey {
      <span class="comment">// This &#39;struct&#39; provides a namespace for types and methods that define</span>
      <span class="comment">// the policy by which the key value of a hashed container (i.e., the</span>
      <span class="comment">// value passed to the hasher) is extracted from the objects stored in</span>
      <span class="comment">// the hashed container (the &#39;value&#39; type).</span>

      <span class="keyword">typedef</span> <span class="keyword">const</span> MySalesRecord *ValueType;
          <span class="comment">// Alias for &#39;const MySalesRecord *&#39;, the type stored in second</span>
          <span class="comment">// hashtable, a pointer to the record stored in the first</span>
          <span class="comment">// hashtable.</span>

      <span class="keyword">typedef</span> <span class="keywordtype">int</span> KeyType;
          <span class="comment">// Alias for the type passed to the hasher by the hashed container.</span>
          <span class="comment">// In this policy, the value passed to the hasher is the</span>
          <span class="comment">// &#39;vendorId&#39; attribute, an &#39;int&#39; type.</span>

      <span class="keyword">static</span> <span class="keyword">const</span> KeyType&amp; extractKey(<span class="keyword">const</span> ValueType&amp; value);
          <span class="comment">// Return the key value for the specified &#39;value&#39;.  In this policy,</span>
          <span class="comment">// that is the &#39;vendorId&#39; attribute of &#39;value&#39;.</span>
  };

                          <span class="comment">// -----------------------</span>
                          <span class="comment">// struct UseVendorIdAsKey</span>
                          <span class="comment">// -----------------------</span>

  <span class="keyword">inline</span>
  <span class="keyword">const</span> UseVendorIdAsKey::KeyType&amp;
        UseVendorIdAsKey::extractKey(<span class="keyword">const</span> ValueType&amp; value)
  {
      <span class="keywordflow">return</span> value-&gt;vendorId;
  }
</pre></div><br/>
<br/>
 Next, we define <code>MySalesRecordContainer</code>, our customized container: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ----------------------------</span>
                          <span class="comment">// class MySalesRecordContainer</span>
                          <span class="comment">// ----------------------------</span>

  <span class="keyword">class </span>MySalesRecordContainer
  {
    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> BloombergLP::bslstl::HashTable&lt;
                    UseOrderNumberAsKey,
                    <a class="code" href="structbsl_1_1hash.html">bsl::hash&lt;    UseOrderNumberAsKey::KeyType&gt;</a>,
                    <a class="code" href="structbsl_1_1equal__to.html" title="C++11-compliant binary functor applying operator==">bsl::equal_to&lt;UseOrderNumberAsKey::KeyType&gt;</a> &gt;
                                                        RecordsByOrderNumber;
      <span class="keyword">typedef</span> <a class="code" href="structbsl_1_1allocator__traits.html">bsl::allocator_traits</a>&lt;
            <a class="code" href="classbsl_1_1allocator.html">bsl::allocator&lt;UseOrderNumberAsKey::ValueType&gt;</a> &gt; AllocatorTraits;
      <span class="keyword">typedef</span> AllocatorTraits::difference_type               difference_type;
</pre></div><br/>
<br/>
 The <code>ItrByOrderNumber</code> type is used to provide access to the elements of the first hash table, the one that stores the records. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">typedef</span> <a class="code" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt;<span class="keyword">const</span> MySalesRecord,
                                                     difference_type&gt;
                                                            ItrByOrderNumber;
</pre></div><br/>
<br/>
 The <code>ItrPtrById</code> type is used to provide access to the elements of the other hashtables, the ones that store pointers into the first hashtable. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">typedef</span> <a class="code" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt;<span class="keyword">const</span> MySalesRecord *,
                                                     difference_type&gt;
                                                                  ItrPtrById;
</pre></div><br/>
<br/>
 If we were to provide iterators of type <code>ItrPtrById</code> to our users, dereferencing the iterator would provide a <code>MySalesRecord</code> pointer, which would then have to be dereferences. Instead, we use <code>ItrPtrById</code> to define <code>ItrById</code> in which accessors have been overriden to provide that extra dereference implicitly. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">class </span>ItrById : <span class="keyword">public</span> ItrPtrById
      {
        <span class="keyword">public</span>:
          <span class="comment">// CREATORS</span>
          <span class="keyword">explicit</span> ItrById(<a class="code" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *node)
          : ItrPtrById(node)
          {
          }

          <span class="comment">// ACCESSORS</span>
          <span class="keyword">const</span> MySalesRecord&amp; <a class="code" href="namespacebdldfp.html#a8158394e9cee4367a9de15cf73e3646a">operator*</a>()<span class="keyword"> const</span>
<span class="keyword">          </span>{
              <span class="keywordflow">return</span> *<a class="code" href="namespacebdldfp.html#a8158394e9cee4367a9de15cf73e3646a">ItrPtrById::operator*</a>();
          }

          <span class="keyword">const</span> MySalesRecord *operator-&gt;()<span class="keyword"> const</span>
<span class="keyword">          </span>{
              <span class="keywordflow">return</span> &amp;(*<a class="code" href="namespacebdldfp.html#a8158394e9cee4367a9de15cf73e3646a">ItrPtrById::operator*</a>());
          }
      };

      <span class="keyword">typedef</span> BloombergLP::bslstl::HashTable&lt;
                    UseCustomerIdAsKey,
                    <a class="code" href="structbsl_1_1hash.html">bsl::hash&lt;    UseCustomerIdAsKey::KeyType&gt;</a>,
                    <a class="code" href="structbsl_1_1equal__to.html" title="C++11-compliant binary functor applying operator==">bsl::equal_to&lt;UseCustomerIdAsKey::KeyType&gt;</a> &gt;
                                                     RecordsPtrsByCustomerId;
      <span class="keyword">typedef</span> BloombergLP::bslstl::HashTable&lt;
                    UseVendorIdAsKey,
                    <a class="code" href="structbsl_1_1hash.html">bsl::hash&lt;    UseVendorIdAsKey::KeyType&gt;</a>,
                    <a class="code" href="structbsl_1_1equal__to.html" title="C++11-compliant binary functor applying operator==">bsl::equal_to&lt;UseVendorIdAsKey::KeyType&gt;</a> &gt;
                                                       RecordsPtrsByVendorId;
      <span class="comment">// DATA</span>
      RecordsByOrderNumber    d_recordsByOrderNumber;
      RecordsPtrsByCustomerId d_recordptrsByCustomerId;
      RecordsPtrsByVendorId   d_recordptrsByVendorId;

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> ItrByOrderNumber  ConstItrByOrderNumber;
      <span class="keyword">typedef</span> ItrById           ConstItrById;

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MySalesRecordContainer(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;MySalesRecordContainer&#39; object.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      MyPair&lt;ConstItrByOrderNumber, bool&gt; insert(<span class="keyword">const</span> MySalesRecord&amp; value);
          <span class="comment">// Insert the specified &#39;value&#39; into this set if the &#39;value&#39; does</span>
          <span class="comment">// not already exist in this set; otherwise, this method has no</span>
          <span class="comment">// effect.  Return a pair whose &#39;first&#39; member is an iterator</span>
          <span class="comment">// providing non-modifiable access to the (possibly newly inserted)</span>
          <span class="comment">// &#39;MySalesRecord&#39; object having &#39;value&#39; and whose &#39;second&#39; member</span>
          <span class="comment">// is &#39;true&#39; if a new element was inserted, and &#39;false&#39; if &#39;value&#39;</span>
          <span class="comment">// was already present.</span>

      <span class="comment">// ACCESSORS</span>
      ConstItrByOrderNumber cend() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// past-the-end element (in the sequence of &#39;MySalesRecord&#39;</span>
          <span class="comment">// objects) maintained by this set.</span>

      ConstItrByOrderNumber findByOrderNumber(<span class="keywordtype">int</span> value) <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// &#39;MySalesRecord&#39; object in this set having the specified &#39;value&#39;,</span>
          <span class="comment">// if such an entry exists, and the iterator returned by the &#39;cend&#39;</span>
          <span class="comment">// method otherwise.</span>
</pre></div><br/>
<br/>
 Notice that this interface provides map-like semantics for finding records. We need only specify the <code>orderNumber</code> attribute of the record of interest; however, the return value is set-like: we get access to the record, not the more complicated key-value/record pair that a map would have provided. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Internally, the hash table need only store the records themselves. A map would have had to manage key-value/record pairs, where the key-value would be a copy of part of the record. <br/>
<br/>
<div class="fragment"><pre class="fragment">      MyPair&lt;ConstItrById, ConstItrById&gt; findByCustomerId(<span class="keywordtype">int</span> value) <span class="keyword">const</span>;
          <span class="comment">// Return a pair of iterators providing non-modifiable access to</span>
          <span class="comment">// the sequence of &#39;MySalesRecord&#39; objects in this container having</span>
          <span class="comment">// a &#39;customerId&#39; attribute equal to the specified &#39;value&#39; where</span>
          <span class="comment">// the first iterator is positioned at the start of the sequence</span>
          <span class="comment">// and the second iterator is positioned one past the end of the</span>
          <span class="comment">// sequence.  If this container has no such objects, then the two</span>
          <span class="comment">// iterators will be equal.</span>

      MyPair&lt;ConstItrById, ConstItrById&gt; findByVendorId(<span class="keywordtype">int</span> value) <span class="keyword">const</span>;
          <span class="comment">// Return a pair of iterators providing non-modifiable access to</span>
          <span class="comment">// the sequence of &#39;MySalesRecord&#39; objects in this container having</span>
          <span class="comment">// a &#39;vendorId&#39; attribute equal to the specified &#39;value&#39; where the</span>
          <span class="comment">// first iterator is positioned at the start of the sequence and</span>
          <span class="comment">// the second iterator is positioned one past the end of the</span>
          <span class="comment">// sequence.  If this container has no such objects, then the two</span>
          <span class="comment">// iterators will be equal.</span>
  };
</pre></div><br/>
<br/>
 Then, we implement the methods of <code>MySalesRecordContainer</code>, our customized container: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ----------------------------</span>
                          <span class="comment">// class MySalesRecordContainer</span>
                          <span class="comment">// ----------------------------</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MySalesRecordContainer::MySalesRecordContainer(
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_recordsByOrderNumber(basicAllocator)
  , d_recordptrsByCustomerId(basicAllocator)
  , d_recordptrsByVendorId(basicAllocator)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  MyPair&lt;MySalesRecordContainer::ConstItrByOrderNumber, bool&gt;
  MySalesRecordContainer::insert(<span class="keyword">const</span> MySalesRecord&amp; value)
  {
      <span class="comment">// Insert into internal container that will own the record.</span>

      <span class="keywordtype">bool</span>                                    isInsertedFlag = <span class="keyword">false</span>;
      BloombergLP::bslalg::BidirectionalLink *result         =
              d_recordsByOrderNumber.insertIfMissing(&amp;isInsertedFlag, value);

      <span class="comment">// Index by other record attributes</span>

      RecordsByOrderNumber::NodeType *nodePtr =
                       <span class="keyword">static_cast&lt;</span>RecordsByOrderNumber::NodeType *<span class="keyword">&gt;</span>(result);

      d_recordptrsByCustomerId.insert(&amp;nodePtr-&gt;value());
        d_recordptrsByVendorId.insert(&amp;nodePtr-&gt;value());

      <span class="comment">// Return of insertion.</span>

      <span class="keywordflow">return</span> MyPair&lt;ConstItrByOrderNumber, bool&gt;(
                                               ConstItrByOrderNumber(result),
                                               isInsertedFlag);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  MySalesRecordContainer::ConstItrByOrderNumber
  MySalesRecordContainer::cend()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> ConstItrByOrderNumber();
  }

  <span class="keyword">inline</span>
  MySalesRecordContainer::ConstItrByOrderNumber
  MySalesRecordContainer::findByOrderNumber(<span class="keywordtype">int</span> value)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> ConstItrByOrderNumber(d_recordsByOrderNumber.find(value));
  }

  <span class="keyword">inline</span>
  MyPair&lt;MySalesRecordContainer::ConstItrById,
         MySalesRecordContainer::ConstItrById&gt;
  MySalesRecordContainer::findByCustomerId(<span class="keywordtype">int</span> value)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keyword">typedef</span> BloombergLP::bslalg::BidirectionalLink HashTableLink;

      HashTableLink *first;
      HashTableLink *last;
      d_recordptrsByCustomerId.findRange(&amp;first, &amp;last, value);

      <span class="keywordflow">return</span> MyPair&lt;ConstItrById, ConstItrById&gt;(ConstItrById(first),
                                                ConstItrById(last));
  }

  <span class="keyword">inline</span>
  MyPair&lt;MySalesRecordContainer::ConstItrById,
         MySalesRecordContainer::ConstItrById&gt;
  MySalesRecordContainer::findByVendorId(<span class="keywordtype">int</span> value)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keyword">typedef</span> BloombergLP::bslalg::BidirectionalLink HashTableLink;

      HashTableLink *first;
      HashTableLink *last;
      d_recordptrsByVendorId.findRange(&amp;first, &amp;last, value);

      <span class="keywordflow">return</span> MyPair&lt;ConstItrById, ConstItrById&gt;(ConstItrById(first),
                                                ConstItrById(last));
  }
</pre></div><br/>
<br/>
 Now, create an empty container and load it with some sample data. <br/>
<br/>
<div class="fragment"><pre class="fragment">      MySalesRecordContainer msrc;

      <span class="keyword">const</span> MySalesRecord DATA[] = {
          { 1000, 100, 10, <span class="stringliteral">&quot;hello&quot;</span> },
          { 1001, 100, 20, <span class="stringliteral">&quot;world&quot;</span> },
          { 1002, 200, 10, <span class="stringliteral">&quot;how&quot;</span> },
          { 1003, 200, 20, <span class="stringliteral">&quot;are&quot;</span> },
          { 1004, 100, 10, <span class="stringliteral">&quot;you&quot;</span> },
          { 1005, 100, 20, <span class="stringliteral">&quot;today&quot;</span> }
      };
      <span class="keyword">const</span> <span class="keywordtype">int</span> numDATA = <span class="keyword">sizeof</span> DATA / <span class="keyword">sizeof</span> *DATA;

      printf(<span class="stringliteral">&quot;Insert sales records into container.\n&quot;</span>);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numDATA; ++i) {
          <span class="keyword">const</span> <span class="keywordtype">int</span> orderNumber   = DATA[i].orderNumber;
          <span class="keyword">const</span> <span class="keywordtype">int</span> customerId    = DATA[i].customerId;
          <span class="keyword">const</span> <span class="keywordtype">int</span> vendorId      = DATA[i].vendorId;
          <span class="keyword">const</span> <span class="keywordtype">char</span> *description = DATA[i].description;

          printf(<span class="stringliteral">&quot;%d: %d %d %s\n&quot;</span>,
                 orderNumber,
                 customerId,
                 vendorId,
                 description);
          MyPair&lt;MySalesRecordContainer::ConstItrByOrderNumber,
                 <span class="keywordtype">bool</span>&gt; status = msrc.insert(DATA[i]);
          assert(msrc.cend() != status.first);
          assert(<span class="keyword">true</span>        == status.second);
      }
</pre></div><br/>
<br/>
 We find on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Insert sales records into container.
  1000: 100 10 hello
  1001: 100 20 world
  1002: 200 10 how
  1003: 200 20 are
  1004: 100 10 you
  1005: 100 20 today
</pre></div><br/>
<br/>
 We can search our container by order number and find the expected records. <br/>
<br/>
<div class="fragment"><pre class="fragment">      printf(<span class="stringliteral">&quot;Find sales records by order number.\n&quot;</span>);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numDATA; ++i) {
          <span class="keyword">const</span> <span class="keywordtype">int</span> orderNumber   = DATA[i].orderNumber;
          <span class="keyword">const</span> <span class="keywordtype">int</span> customerId    = DATA[i].customerId;
          <span class="keyword">const</span> <span class="keywordtype">int</span> vendorId      = DATA[i].vendorId;
          <span class="keyword">const</span> <span class="keywordtype">char</span> *description = DATA[i].description;

          printf(<span class="stringliteral">&quot;%d: %d %d %s\n&quot;</span>,
                 orderNumber,
                 customerId,
                 vendorId,
                 description);
          MySalesRecordContainer::ConstItrByOrderNumber itr =
                                         msrc.findByOrderNumber(orderNumber);
          assert(msrc.cend() != itr);
          assert(orderNumber == itr-&gt;orderNumber);
          assert(customerId  == itr-&gt;customerId);
          assert(vendorId    == itr-&gt;vendorId);
          assert(0 == strcmp(description, itr-&gt;description));
      }
</pre></div><br/>
<br/>
 We find on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Find sales records by order number.
  1000: 100 10 hello
  1001: 100 20 world
  1002: 200 10 how
  1003: 200 20 are
  1004: 100 10 you
  1005: 100 20 today
</pre></div><br/>
<br/>
 We can search our container by customer identifier and find the expected records. <br/>
<br/>
<div class="fragment"><pre class="fragment">      printf(<span class="stringliteral">&quot;Find sales records by customer identifier.\n&quot;</span>);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> customerId = 100; customerId &lt;= 200; customerId += 100) {
          MyPair&lt;MySalesRecordContainer::ConstItrById,
                 MySalesRecordContainer::ConstItrById&gt; result =
                                           msrc.findByCustomerId(customerId);
          <span class="keywordtype">int</span> count = std::distance(result.first, result.second);
          printf(<span class="stringliteral">&quot;customerId %d, count %d\n&quot;</span>, customerId, count);

          <span class="keywordflow">for</span> (MySalesRecordContainer::ConstItrById itr  = result.first,
                                                    end  = result.second;
                                                    end != itr; ++itr) {
              printf(<span class="stringliteral">&quot;\t\t%d %d %d %s\n&quot;</span>,
                     itr-&gt;orderNumber,
                     itr-&gt;customerId,
                     itr-&gt;vendorId,
                     itr-&gt;description);
          }
      }
</pre></div><br/>
<br/>
 We find on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Find sales records by customer identifier.
  customerId 100, count 4
              1005 100 20 today
              1004 100 10 you
              1001 100 20 world
              1000 100 10 hello
  customerId 200, count 2
              1003 200 20 are
              1002 200 10 how
</pre></div><br/>
<br/>
 Lastly, we can search our container by vendor identifier and find the expected records. <br/>
<br/>
<div class="fragment"><pre class="fragment">      printf(<span class="stringliteral">&quot;Find sales records by vendor identifier.\n&quot;</span>);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> vendorId = 10; vendorId &lt;= 20; vendorId += 10) {
          MyPair&lt;MySalesRecordContainer::ConstItrById,
                 MySalesRecordContainer::ConstItrById&gt; result =
                                               msrc.findByVendorId(vendorId);
          <span class="keywordtype">int</span> count = std::distance(result.first, result.second);
          printf(<span class="stringliteral">&quot;vendorId %d, count %d\n&quot;</span>, vendorId, count);

          <span class="keywordflow">for</span> (MySalesRecordContainer::ConstItrById itr  = result.first,
                                                    end  = result.second;
                                                    end != itr; ++itr) {
              printf(<span class="stringliteral">&quot;\t\t%d %d %d %s\n&quot;</span>,
                     (*itr).orderNumber,
                     (*itr).customerId,
                     (*itr).vendorId,
                     (*itr).description);
          }
      }
</pre></div><br/>
<br/>
 We find on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Find sales records by vendor identifier.
  vendorId 10, count 3
              1004 100 10 you
              1002 200 10 how
              1000 100 10 hello
  vendorId 20, count 3
              1005 100 20 today
              1003 200 20 are
              1001 100 20 world
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:22 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
