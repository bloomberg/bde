<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_alignedallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_alignedallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for memory allocators that support alignment.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Implementing <code>bdlma::AlignedAllocator</code></a> </li>
<li>
<a href="#3.1.2">Example 2: Using the <code>bdlma::AlignedAllocator</code> Protocol</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for memory allocators that support alignment. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1AlignedAllocator.html">bdlma::AlignedAllocator</a> </td><td>protocol for aligned memory allocators  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides an implementation, <code><a class="el" href="classbdlma_1_1AlignedAllocator.html">bdlma::AlignedAllocator</a></code>, of the base-level protocol (pure abstract interface) class, <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, providing the ability to allocate raw memory with a specified alignment. The following inheritance diagram shows the classes involved and their methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,----------------------.
  ( <a class="code" href="classbdlma_1_1AlignedAllocator.html">bdlma::AlignedAllocator</a> )
   `----------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">               |       allocateAligned</span>
<span class="stringliteral">               V</span>
<span class="stringliteral">       ,----------------.</span>
<span class="stringliteral">      ( bslma::Allocator )</span>
<span class="stringliteral">       `----------------&#39;</span>
                       allocate
                       deallocate
</pre></div><br/>
<br/>
 The <code>allocateAligned</code> method supplies the address of a contiguous block of allocated memory of at least the indicated size, that is aligned to a given boundary. Note that this behavior is similar to the behavior of the POSIX function <code>posix_memalign</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_bdlma~3A~3Aalignedallocator"></a> <a class="anchor" id="usage.example_1~3A_implementing_bdlma~3A~3Aalignedallocator"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_bdlma~3A~3Aalignedallocator"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing bdlma::AlignedAllocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlma_1_1AlignedAllocator.html">bdlma::AlignedAllocator</a></code> protocol provided in this component defines a bilateral contract between suppliers and consumers of raw aligned memory. In order for the <code><a class="el" href="classbdlma_1_1AlignedAllocator.html">bdlma::AlignedAllocator</a></code> interface to be useful, we must supply a concrete allocator that implements it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we demonstrate how to adapt <code>posix_memalign</code> on Linux and AIX, <code>memalign</code> on SunOS and <code>_aligned_malloc</code> on Windows, to this protocol base class: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we specify the interface of the concrete implementation of 'MyAlignedAllocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// myposixmemalignallocator.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">class </span>MyAlignedAllocator: <span class="keyword">public</span> bdlma::AlignedAllocator {
      <span class="comment">// This class is a sample concrete implementation of the</span>
      <span class="comment">// &#39;bdlma::AlignedAllocator&#39; protocol that provides direct access to</span>
      <span class="comment">// the system-supplied &#39;posix_memalign&#39; and &#39;free&#39; on Linux and AIX</span>
      <span class="comment">// platforms, &#39;memalign&#39; and &#39;free&#39; on SunOS, or &#39;_aligned_malloc&#39; and</span>
      <span class="comment">// &#39;_aligned_free&#39; on Windows.</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      MyAlignedAllocator(<span class="keyword">const</span> MyAlignedAllocator&amp;);
      MyAlignedAllocator&amp; operator=(<span class="keyword">const</span> MyAlignedAllocator&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MyAlignedAllocator();
          <span class="comment">// Create a &#39;MyAlignedAllocator&#39; object.  Note that all objects of</span>
          <span class="comment">// this class share the same underlying resource.</span>

      <span class="keyword">virtual</span> ~MyAlignedAllocator();
          <span class="comment">// Destroy this object.  Note that destroying this object has no</span>
          <span class="comment">// effect on any outstanding allocated memory.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(size_type <a class="code" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size</a>);
          <span class="comment">// Return a newly allocated block of memory of (at least) the</span>
          <span class="comment">// specified positive &#39;size&#39; (in bytes).  If &#39;size&#39; is 0, a null</span>
          <span class="comment">// pointer is returned with no other effect.  If this allocator</span>
          <span class="comment">// cannot return the requested number of bytes, then it will throw</span>
          <span class="comment">// an &#39;std::bad_alloc&#39; exception in an exception-enabled build, or</span>
          <span class="comment">// else it will abort the program in a non-exception build.  The</span>
          <span class="comment">// behavior is undefined unless &#39;0 &lt;= size&#39;.   Note that the</span>
          <span class="comment">// alignment of the address returned conforms to the platform</span>
          <span class="comment">// requirement for any object of the &#39;size&#39;.  Also note that global</span>
          <span class="comment">// &#39;operator new&#39; is *not* called when &#39;size&#39; is 0 (in order to</span>
          <span class="comment">// avoid having to acquire a lock, and potential contention in</span>
          <span class="comment">// multi-threaded programs).</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocateAligned(bsl::size_t <a class="code" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size</a>, size_type alignment);
          <span class="comment">// Return the address of a newly allocated block of memory of at</span>
          <span class="comment">// least the specified positive &#39;size&#39; (in bytes), sufficiently</span>
          <span class="comment">// aligned such that the returned &#39;address&#39; satisfies, for the</span>
          <span class="comment">// specified &#39;alignment&#39;, &#39;0 == (address &amp; (alignment - 1))&#39;.  If</span>
          <span class="comment">// &#39;size&#39; is 0, a null pointer is returned with no other effect.</span>
          <span class="comment">// If the requested number of appropriately aligned bytes cannot be</span>
          <span class="comment">// returned, then a &#39;bsl::bad_alloc&#39; exception is thrown, or in a</span>
          <span class="comment">// non-exception build the program is terminated.  The behavior is</span>
          <span class="comment">// undefined unless &#39;alignment&#39; is both a multiple of</span>
          <span class="comment">// &#39;sizeof(void *)&#39; and an integral non-negative power of two.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
          <span class="comment">// Return the memory block at the specified &#39;address&#39; back to this</span>
          <span class="comment">// allocator.  If &#39;address&#39; is 0, this function has no effect.  The</span>
          <span class="comment">// behavior is undefined unless &#39;address&#39; was allocated using this</span>
          <span class="comment">// allocator object and has not already been deallocated.</span>
  };
  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Then, we implement the creators, trivially, as this class contains no instance data members. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  MyAlignedAllocator::MyAlignedAllocator()
  {
  }

  MyAlignedAllocator::~MyAlignedAllocator()
  {
  }
</pre></div><br/>
<br/>
 Now, we define the virtual methods of <code>MyAlignedAllocator</code>. Note that these definitions are not <code>inline</code>, as they would not be inlined when invoked from the base class (the typical usage in this case): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> *MyAlignedAllocator::allocate(size_type <a class="code" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size</a>)
  {
      <span class="keywordflow">if</span> (0 == size) {
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }

      <span class="keywordtype">int</span> alignment = <a class="code" href="structbsls_1_1AlignmentUtil.html#a22499d10c8827af367d52693472ca491">bsls::AlignmentUtil::calculateAlignmentFromSize</a>(size);
      <span class="keywordflow">return</span> allocateAligned(size, alignment);
  }

  <span class="keywordtype">void</span> *MyAlignedAllocator::allocateAligned(bsl::size_t size,
                                            size_type   alignment)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(0 == (alignment &amp; (alignment - 1)));
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(0 == (alignment % <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *)));

      <span class="keywordflow">if</span> (0 == size) {
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }

      <span class="keywordtype">void</span> *ret = 0;

<span class="preprocessor">  #ifdef BSLS_PLATFORM_OS_WINDOWS</span>
<span class="preprocessor"></span>      errno = 0;
      ret = _aligned_malloc(size, alignment);
      <span class="keywordflow">if</span> (0 != errno) {
          <a class="code" href="structbsls_1_1BslExceptionUtil.html#a465dfe918544c50b66067aee9c520a8c">bsls::BslExceptionUtil::throwBadAlloc</a>();
      }
<span class="preprocessor">  #elif defined(BSLS_PLATFORM_OS_SOLARIS) || defined(BSLS_PLATFORM_OS_HPUX)</span>
<span class="preprocessor"></span>      ret = memalign(alignment, size);
      <span class="keywordflow">if</span> (0 == ret) {
          <a class="code" href="structbsls_1_1BslExceptionUtil.html#a465dfe918544c50b66067aee9c520a8c">bsls::BslExceptionUtil::throwBadAlloc</a>();
      }
<span class="preprocessor">  #else</span>
<span class="preprocessor"></span>      <span class="keywordtype">int</span> rc = ::posix_memalign(&amp;ret, alignment, size);
      <span class="keywordflow">if</span> (0 != rc) {
          <a class="code" href="structbsls_1_1BslExceptionUtil.html#a465dfe918544c50b66067aee9c520a8c">bsls::BslExceptionUtil::throwBadAlloc</a>();
      }
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
      <span class="keywordflow">return</span> ret;
  }

  <span class="keywordtype">void</span> MyAlignedAllocator::deallocate(<span class="keywordtype">void</span> *address)
  {
      <span class="keywordflow">if</span> (0 == address) {
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
<span class="preprocessor">  #ifdef BSLS_PLATFORM_WINDOWS</span>
<span class="preprocessor"></span>      _aligned_free(address);
<span class="preprocessor">  #else</span>
<span class="preprocessor"></span>      ::free(address);
<span class="preprocessor">  #endif</span>
<span class="preprocessor">  }</span>
</pre></div><br/>
<br/>
 Finally, we define a function <code>f</code> that instantiates an object of type <code>MyAlignedAllocator</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> f() {
      MyAlignedAllocator a;
  }
</pre></div><br/>
<br/>
 Note that the memory is not released when the allocator goes out of scope. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_the_bdlma~3A~3Aalignedallocator_protocol"></a> <a class="anchor" id="usage.example_2~3A_using_the_bdlma~3A~3Aalignedallocator_protocol"></a> <a class="anchor" id="description.usage.example_2~3A_using_the_bdlma~3A~3Aalignedallocator_protocol"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using the bdlma::AlignedAllocator Protocol: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we illustrate how to use the <code><a class="el" href="classbdlma_1_1AlignedAllocator.html">bdlma::AlignedAllocator</a></code> protocol to allocate memory that is aligned to the beginning of a memory page. Third party libraries, for example device drivers that perform DMA access of device drivers, or some extreme optimizations to reduce the number of page faults, might require page aligned allocations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create an aligned allocator <code>myAlignedAllocator</code> using the class <code>MyAlignedAllocator</code> defined in the previous example, and obtain a <code><a class="el" href="classbdlma_1_1AlignedAllocator.html">bdlma::AlignedAllocator</a></code> pointer to it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyAlignedAllocator myAlignedAllocator;
  <a class="code" href="classbdlma_1_1AlignedAllocator.html">bdlma::AlignedAllocator</a> *alignedAllocator = &amp;myAlignedAllocator;
</pre></div><br/>
<br/>
 Now, assuming a page size of 4K, we allocate a buffer of 1024 bytes of memory and indicate that it should be aligned on a 4096 boundary: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> *address = (<span class="keywordtype">char</span> *) alignedAllocator-&gt;<a class="code" href="classbdlma_1_1AlignedAllocator.html#a2db888fceede4dc0079995937c73cf0f">allocateAligned</a>(1024, 4096);
</pre></div><br/>
<br/>
 Finally, we verify that the obtained address actually is aligned as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == ((bsl::size_t)address &amp; (4096 - 1)));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:44 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
