<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_queue Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_queue<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide container adapter class template <code>queue</code>.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html">bslstl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html">bsl</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Memory Allocation</a> </li>
<li>
<a href="#3.2">Operations</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Messages Queue</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide container adapter class template <code>queue</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslstl::queue </td><td>class template of a first-in-first-out data structure  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__priorityqueue.html" title="Provide container adapter class template priority_queue.">Component bslstl_priorityqueue</a>, <a class="el" href="group__bslstl__stack.html" title="Provide an STL-compliant stack class.">Component bslstl_stack</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a class template, <code><a class="el" href="classbsl_1_1queue.html">bsl::queue</a></code>, holding a container (of a parameterized type <code>CONTAINER</code> containing elements of another parameterized type <code>VALUE</code>), and adapting it to provide a first-in-first-out queue data structure. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>queue</code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of elements held) and the sequence of values (of held elements) in the order that they were pushed into the <code>queue</code>. If <code>queue</code> is instantiated with a parameterized type <code>VALUE</code> that is not itself value-semantic, then it will not retain all of its value-semantic qualities. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>queue</code> meets the requirements of a container adapter in the C++ standard [23.6]. The <code>queue</code> implemented here adheres to the C++11 standard, except that it does not have methods that take rvalue references and <code>initializer_lists</code>. Note that excluded C++11 features are those that require C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as <code>ALLOCATOR</code> template parameter in some of <code>queue</code> constructors determines how the held container (of parameterized <code>CONTAINER</code>) will allocate memory. A <code>queue</code> supports allocators meeting the requirements of the C++11 standard [17.6.3.5] as long as the held container does. In addition it supports scoped-allocators derived from the <code>bslma_Allocator</code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> as the <code>ALLOCATOR</code> template parameter, providing a C++11 standard-compatible adapter for a <code>bslma_Allocator</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The C++11 standard [23.6.3.1] declares any container type supporting operations <code>front</code>, <code>back</code>, <code>push_back</code> and <code>pop_front</code> can be used to instantiate the parameterized type <code>CONTAINER</code>. Below is a list of public methods of <code>queue</code> class that effectively forward their implementations to corresponding operations in the held container (referenced as <code>c</code>). +--------------------------------------+---------------------------+ | Public methods in <code>queue</code> | Operation in <code>CONTAINER</code> | +======================================+===========================+ | void push(const value_type&amp; value); | c.push_back(value); | | void pop(); | c.pop_front(); | | reference front(); | c.front(); | | reference back(); | c.back(); | +--------------------------------------+---------------------------+ | bool empty() const; | c.empty(); | | size_type size() const; | c.size(); | | const_reference front() const; | c.front(); | | const_reference back()  const; | c.back(); | +--------------------------------------+---------------------------+ </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_messages_queue"></a> <a class="anchor" id="usage.example_1~3A_messages_queue"></a> <a class="anchor" id="description.usage.example_1~3A_messages_queue"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Messages Queue: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will use the <code><a class="el" href="classbsl_1_1queue.html">bsl::queue</a></code> container adapter to implement a message processor in a server program that receives and displays messages from clients. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to write a server program that has two threads: one thread (receiving thread) receives messages from clients, passing them to a message processor; the other thread (processing thread) runs the message processor, printing the messages to the console in the same order as they were received. To accomplish this task, we can use <code><a class="el" href="classbsl_1_1queue.html">bsl::queue</a></code> in the message processor to buffer received, but as yet unprinted, messages. The message processor pushes newly received messages onto the queue in the receiving thread, and pops them off the queue in the processing thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a <code>Message</code> type: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Message {
      <span class="keywordtype">int</span>         d_msgId;  <span class="comment">// message identifier given by client</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *d_msg_p;  <span class="comment">// message content (C-style string, not owned)</span>
  };
</pre></div><br/>
<br/>
 Then, we define the class <code>MessageProcessor</code>, which provides methods to receive and process messages: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MessageProcessor {
      <span class="comment">// This class receives and processes messages from clients.</span>
</pre></div><br/>
<br/>
 Here, we define a private data member of <code><a class="el" href="classbsl_1_1queue.html">bsl::queue</a>&lt;Message&gt;</code> type, which is an instantiation of <code><a class="el" href="classbsl_1_1queue.html">bsl::queue</a></code> that uses <code>Message</code> for its <code>VALUE</code> (template parameter) type and (by default) <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt;Message&gt;</code> for its <code>CONTAINER</code> (template parameter) type: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1queue.html">bsl::queue&lt;Message&gt;</a> d_msgQueue;  <span class="comment">// queue holding received but</span>
                                       <span class="comment">// unprocessed messages</span>
      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MessageProcessor(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a message processor object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> receiveMessage(<span class="keyword">const</span> Message &amp;message);
          <span class="comment">// Enqueue the specified &#39;message&#39; onto this message processor.</span>

      <span class="keywordtype">void</span> processMessages(<span class="keywordtype">int</span> verbose);
          <span class="comment">// Dequeue all messages currently contained by this processor,</span>
          <span class="comment">// and print them to the console if the specified &#39;verbose&#39; flag</span>
          <span class="comment">// is not 0.</span>
  };
</pre></div><br/>
<br/>
 Next, we implement the <code>MessageProcessor</code> constructor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MessageProcessor::MessageProcessor(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_msgQueue(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Notice that we pass to the contained <code>d_msgQueue</code> object the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*</code> supplied to the <code>MessageProcessor</code> at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we implement the <code>receiveMessage</code> method, which pushes the given message onto the queue object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> MessageProcessor::receiveMessage(<span class="keyword">const</span> Message &amp;message)
  {
      <span class="comment">// ... (some synchronization)</span>

      d_msgQueue.push(message);

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 Finally, we implement the <code>processMessages</code> method, which pops all messages off the queue object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> MessageProcessor::processMessages(<span class="keywordtype">int</span> verbose)
  {
      <span class="comment">// ... (some synchronization)</span>

      <span class="keywordflow">while</span> (!d_msgQueue.empty()) {
          <span class="keyword">const</span> Message&amp; message = d_msgQueue.front();
          <span class="keywordflow">if</span> (verbose) {
              printf(<span class="stringliteral">&quot;Msg %d: %s\n&quot;</span>, message.d_msgId, message.d_msg_p);
          }
          d_msgQueue.pop();
      }

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 Note that the sequence of messages popped from the queue will be in exactly the same order in which they were pushed, due to the first-in-first-out property of the queue. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:05 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
