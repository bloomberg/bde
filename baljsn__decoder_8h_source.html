<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// baljsn_decoder.h                                                   -*-C++-*-
#ifndef INCLUDED_BALJSN_DECODER
#define INCLUDED_BALJSN_DECODER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a JSON decoder for &#39;bdeat&#39; compatible types.
//
//@CLASSES:
//  baljsn::Decoder: JSON decoder for &#39;bdeat&#39;-compliant types
//
//@SEE_ALSO: baljsn_encoder, baljsn_parserutil, baljsn_parser
//
//@DESCRIPTION: This component provides a class, &#39;baljsn::Decoder&#39;, for
// decoding value-semantic objects in the JSON format.  In particular, the
// &#39;class&#39; contains a parameterized &#39;decode&#39; function that decodes an object
// from a specified stream.  There are two overloaded versions of this
// function:
//
//: o one that reads from a &#39;bsl::streambuf&#39;
//: o one that reads from a &#39;bsl::istream&#39;
//
// This component can be used with types that support the &#39;bdeat&#39; framework
// (see the &#39;bdeat&#39; package for details), which is a compile-time interface for
// manipulating struct-like and union-like objects.  In particular, types
// generated by the &#39;bas_codegen.pl&#39; tool, and other dynamic types, can be
// decoded using this &#39;class&#39;.  The &#39;decode&#39; function can be invoked on any
// object that satisfies the requirements of a sequence, choice, or array
// object as defined in the &#39;bdlat_sequencefunctions&#39;, &#39;bdlat_choicefunctions&#39;,
// and &#39;bdlat_arrayfunctions&#39; components.
//
// Although the JSON format is easy to read and write and is very useful for
// debugging, it is relatively expensive to encode and decode and relatively
// bulky to transmit.  It is more efficient to use a binary encoding (such as
// BER) if the encoding format is under your control (see &#39;balber_berdecoder&#39;).
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Decoding into a &#39;bas_codegen.pl&#39;-generated from data in JSON
///-----------------------------------------------------------------------
// Consider that we want to exchange an employee&#39;s information between two
// processes.  To allow this information exchange we will define the XML schema
// representation for that class, use &#39;bas_codegen.pl&#39; to create the &#39;Employee&#39;
// &#39;class&#39; for storing that information, and decode into that object using the
// baljsn decoder.
//
// First, we will define the XML schema inside a file called &#39;employee.xsd&#39;:
//..
//  &lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;
//  &lt;xs:schema xmlns:xs=&#39;http://www.w3.org/2001/XMLSchema&#39;
//             xmlns:test=&#39;http://bloomberg.com/schemas/test&#39;
//             targetNamespace=&#39;http://bloomberg.com/schemas/test&#39;
//             elementFormDefault=&#39;unqualified&#39;&gt;
//
//      &lt;xs:complexType name=&#39;Address&#39;&gt;
//          &lt;xs:sequence&gt;
//              &lt;xs:element name=&#39;street&#39; type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;city&#39;   type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;state&#39;  type=&#39;xs:string&#39;/&gt;
//          &lt;/xs:sequence&gt;
//      &lt;/xs:complexType&gt;
//
//      &lt;xs:complexType name=&#39;Employee&#39;&gt;
//          &lt;xs:sequence&gt;
//              &lt;xs:element name=&#39;name&#39;        type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;homeAddress&#39; type=&#39;test:Address&#39;/&gt;
//              &lt;xs:element name=&#39;age&#39;         type=&#39;xs:int&#39;/&gt;
//          &lt;/xs:sequence&gt;
//      &lt;/xs:complexType&gt;
//
//      &lt;xs:element name=&#39;Employee&#39; type=&#39;test:Employee&#39;/&gt;
//
//  &lt;/xs:schema&gt;
//..
// Then, we will use the &#39;bas_codegen.pl&#39; tool, to generate the C++ classes for
// this schema.  The following command will generate the header and
// implementation files for the all the classes in the &#39;test_messages&#39;
// components in the current directory:
//..
//  $ bas_codegen.pl -m msg -p test xsdfile.xsd
//..
// Next, we will create a &#39;test::Employee&#39; object:
//..
//  test::Employee employee;
//..
// Then, we will create a &#39;baljsn::Decoder&#39; object:
//..
//  baljsn::Decoder decoder;
//..
// Next, we will specify the input data provided to the decoder:
//..
//  const char INPUT[] = &quot;{\&quot;name\&quot;:\&quot;Bob\&quot;,\&quot;homeAddress\&quot;:{\&quot;street\&quot;:&quot;
//                       &quot;\&quot;Lexington Ave\&quot;,\&quot;city\&quot;:\&quot;New York City\&quot;,&quot;
//                       &quot;\&quot;state\&quot;:\&quot;New York\&quot;},\&quot;age\&quot;:21}&quot;;
//
//  bsl::istringstream is(INPUT);
//..
// Now, we will decode this object using the &#39;decode&#39; function of the baljsn
// decoder by providing it a &#39;baljsn::DecoderOptions&#39; object.  The decoder
// options allow us to specify that unknown elements should *not* be skipped.
// Setting this option to &#39;false&#39; will result in the decoder returning an error
// on encountering an unknown element:
//..
//  baljsn::DecoderOptions options;
//  options.setSkipUnknownElements(false);
//
//  const int rc = decoder.decode(is, &amp;employee, options);
//  assert(!rc);
//  assert(is);
//..
// Finally, we will verify that the decoded object is as expected:
//..
//  assert(&quot;Bob&quot;           == employee.name());
//  assert(&quot;Lexington Ave&quot; == employee.homeAddress().street());
//  assert(&quot;New York City&quot; == employee.homeAddress().city());
//  assert(&quot;New York&quot;      == employee.homeAddress().state());
//  assert(21              == employee.age());
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALJSN_DECODEROPTIONS
#include &lt;baljsn_decoderoptions.h&gt;
#endif

#ifndef INCLUDED_BALJSN_PARSERUTIL
#include &lt;baljsn_parserutil.h&gt;
#endif

#ifndef INCLUDED_BALJSN_TOKENIZER
#include &lt;baljsn_tokenizer.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ATTRIBUTEINFO
#include &lt;bdlat_attributeinfo.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CHOICEFUNCTIONS
#include &lt;bdlat_choicefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CUSTOMIZEDTYPEFUNCTIONS
#include &lt;bdlat_customizedtypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ENUMFUNCTIONS
#include &lt;bdlat_enumfunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_FORMATTINGMODE
#include &lt;bdlat_formattingmode.h&gt;
#endif

#ifndef INCLUDED_BDLAT_SELECTIONINFO
#include &lt;bdlat_selectioninfo.h&gt;
#endif

#ifndef INCLUDED_BDLAT_SEQUENCEFUNCTIONS
#include &lt;bdlat_sequencefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPECATEGORY
#include &lt;bdlat_typecategory.h&gt;
#endif

#ifndef INCLUDED_BDLAT_VALUETYPEFUNCTIONS
#include &lt;bdlat_valuetypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLB_PRINTMETHODS
#include &lt;bdlb_printmethods.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSTREAM
#include &lt;bsl_iostream.h&gt;
#endif

#ifndef INCLUDED_BSL_SSTREAM
#include &lt;bsl_sstream.h&gt;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

namespace BloombergLP {
namespace baljsn {

                               // =============
                               // class Decoder
                               // =============

class Decoder {
    // This class provides a mechanism for decoding JSON data into
    // value-semantic objects.  The &#39;decode&#39; methods are function templates
    // that will decode any object that meets the requirements of a sequence,
    // choice, or array object as defined in the &#39;bdlat_sequencefunctions&#39;,
    // &#39;bdlat_choicefunctions&#39;, and &#39;bdlat_choicefunctions&#39; components
    // respectively.  These generic frameworks provide a common compile-time
    // interface for manipulating struct-like and union-like objects.  In
    // particular, the types generated by &#39;bas_codegen.pl&#39; provide the
    // necessary interface and can be decoded using this component.

    // DATA
    bsl::ostringstream  d_logStream;            // stream to record errors
    Tokenizer    d_tokenizer;            // JSON tokenizer
    bsl::string         d_elementName;          // current element name
    int                 d_currentDepth;         // current decoding depth
    int                 d_maxDepth;             // max decoding depth
    bool                d_skipUnknownElements;  // skip unknown elements flag

    // FRIENDS
    friend struct Decoder_DecodeImpProxy;
    friend struct Decoder_ElementVisitor;

    // PRIVATE MANIPULATORS
    template &lt;class TYPE&gt;
    int decodeImp(TYPE *value, int mode, bdlat_TypeCategory::DynamicType);
    template &lt;class TYPE&gt;
    int decodeImp(TYPE *value, int mode, bdlat_TypeCategory::Sequence);
    template &lt;class TYPE&gt;
    int decodeImp(TYPE *value, int mode, bdlat_TypeCategory::Choice);
    template &lt;class TYPE&gt;
    int decodeImp(TYPE *value, int mode, bdlat_TypeCategory::Enumeration);
    template &lt;class TYPE&gt;
    int decodeImp(TYPE *value, int mode, bdlat_TypeCategory::CustomizedType);
    template &lt;class TYPE&gt;
    int decodeImp(TYPE *value, int mode, bdlat_TypeCategory::Simple);
    template &lt;class TYPE&gt;
    int decodeImp(TYPE *value, int mode, bdlat_TypeCategory::Array);
    template &lt;class TYPE&gt;
    int decodeImp(TYPE *value, int mode, bdlat_TypeCategory::NullableValue);
    int decodeImp(bsl::vector&lt;char&gt;         *value,
                  int                        mode,
                  bdlat_TypeCategory::Array);
    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int decodeImp(TYPE *value, ANY_CATEGORY category);
        // Decode into the specified &#39;value&#39;, of a (template parameter) &#39;TYPE&#39;
        // corresponding to the specified &#39;bdeat&#39; &#39;category&#39;, the JSON data
        // currently referred to by the tokenizer owned by this object, using
        // the specified formatting &#39;mode&#39;.  Return 0 on success and a non-zero
        // value otherwise.  The behavior is undefined unless &#39;value&#39;
        // corresponds to the specified &#39;bdeat&#39; category and &#39;mode&#39; is a valid
        // formatting mode as specified in &#39;bdlat_FormattingMode&#39;.  Note that
        // &#39;ANY_CATEGORY&#39; shall be a tag-type defined in &#39;bdlat_TypeCategory&#39;.

    int skipUnknownElement(const bslstl::StringRef&amp; elementName);
        // Skip the unknown element specified by &#39;elementName&#39; by discarding
        // all the data associated with it and advancing the parser to the next
        // element.  Return 0 on success and a non-zero value otherwise.

  private:
    // Not implemented:
    Decoder(const Decoder&amp;);

  public:
    // CREATORS
    explicit Decoder(bslma::Allocator *basicAllocator = 0);
        // Construct a decoder object using the optionally specified
        // &#39;basicAllocator&#39;.  If &#39;basicAllocator&#39; is 0, the default allocator
        // is used.

    // MANIPULATORS
    template &lt;class TYPE&gt;
    int decode(bsl::streambuf        *streamBuf,
               TYPE                  *value,
               const DecoderOptions&amp;  options);
        // Decode into the specified &#39;value&#39;, of a (template parameter) &#39;TYPE&#39;,
        // the JSON data read from the specified &#39;streamBuf&#39; and using the
        // specified &#39;options&#39;.  &#39;TYPE&#39; shall be a &#39;bdeat&#39;-compatible sequence,
        // choice, or array type, or a &#39;bdeat&#39;-compatible dynamic type
        // referring to one of those types.  Return 0 on success, and a
        // non-zero value otherwise.  Note that this operation internally
        // buffers input from &#39;streambuf&#39;, and if decoding is successful, will
        // attempt to update the input position of &#39;streambuf&#39; to the last
        // unprocessed byte.

    template &lt;class TYPE&gt;
    int decode(bsl::istream&amp;          stream,
               TYPE                  *value,
               const DecoderOptions&amp;  options);
        // Decode into the specified &#39;value&#39;, of a (template parameter) &#39;TYPE&#39;,
        // the JSON data read from the specified &#39;stream&#39; and using the
        // specified &#39;options&#39;.  &#39;TYPE&#39; shall be a &#39;bdeat&#39;-compatible sequence,
        // choice, or array type, or a &#39;bdeat&#39;-compatible dynamic type
        // referring to one of those types.  Return 0 on success, and a
        // non-zero value otherwise.  Note that this operation internally
        // buffers input from &#39;stream&#39;, and if decoding is successful, will
        // attempt to update the input position of &#39;stream&#39; to the last
        // unprocessed byte.

    template &lt;class TYPE&gt;
    int decode(bsl::streambuf *streamBuf, TYPE *value);
        // Decode an object of (template parameter) &#39;TYPE&#39; from the specified
        // &#39;streamBuf&#39; and load the result into the specified modifiable
        // &#39;value&#39;.  Return 0 on success, and a non-zero value otherwise.
        //
        // DEPRECATED: Use the &#39;decode&#39; function passed a reference to a
        // non-modifiable &#39;DecoderOptions&#39; object instead.

    template &lt;class TYPE&gt;
    int decode(bsl::istream&amp; stream, TYPE *value);
        // Decode an object of (template parameter) &#39;TYPE&#39; from the specified
        // &#39;stream&#39; and load the result into the specified modifiable &#39;value&#39;.
        // Return 0 on success, and a non-zero value otherwise.  Note that
        // &#39;stream&#39; will be invalidated if the decoding fails.
        //
        // DEPRECATED: Use the &#39;decode&#39; function passed a reference to a
        // non-modifiable &#39;DecoderOptions&#39; object instead.

    // ACCESSORS
    bsl::string loggedMessages() const;
        // Return a string containing any error, warning, or trace messages
        // that were logged during the last call to the &#39;decode&#39; method.  The
        // log is reset each time &#39;decode&#39; is called.
};

                       // =============================
                       // struct Decoder_ElementVisitor
                       // =============================

struct Decoder_ElementVisitor {
    // This &#39;class&#39; implements a visitor for decoding elements within a
    // sequence, choice, or array type.  This is a component-private class and
    // should not be used outside of this component.  Note that the operators
    // provided in this &#39;class&#39; match the function signatures required of
    // visitors decoding into elements of compatible types.

    // DATA
    Decoder *d_decoder_p;  // decoder (held, not owned)
    int             d_mode;       // formatting mode

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // MANIPULATORS
    template &lt;class TYPE&gt;
    int operator()(TYPE *value);
        // Decode into the specified &#39;value&#39; the data in the JSON format.
        // Return 0 on success and a non-zero value otherwise.

    template &lt;class TYPE, class INFO&gt;
    int operator()(TYPE *value, const INFO&amp; info);
        // Decode into the specified &#39;value&#39; using the specified &#39;info&#39; the
        // data in the JSON format.  Return 0 on success and a non-zero value
        // otherwise.
};

                       // =============================
                       // struct Decoder_DecodeImpProxy
                       // =============================

struct Decoder_DecodeImpProxy {
    // This class provides a functor that dispatches the appropriate
    // &#39;decodeImp&#39; method for a &#39;bdeat&#39; Dynamic type.  Note that the operators
    // provided in this &#39;class&#39; match the function signatures required of
    // visitors decoding into compatible types.

    // DATA
    Decoder *d_decoder_p;  // decoder (held, not owned)
    int             d_mode;       // formatting mode

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // MANIPULATORS
    template &lt;class TYPE&gt;
    int operator()(TYPE *, bslmf::Nil);

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int operator()(TYPE *object, ANY_CATEGORY category);
        // Dencode into the specified &#39;value&#39; of the specified &#39;bdeat&#39;
        // &#39;category&#39; from the data in the JSON format.  Return 0 on success
        // and a non-zero value otherwise.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                               // -------------
                               // class Decoder
                               // -------------

// PRIVATE MANIPULATORS
template &lt;class TYPE&gt;
inline
int Decoder::decodeImp(TYPE *value, int mode, bdlat_TypeCategory::DynamicType)
{
    Decoder_DecodeImpProxy proxy = { this, mode };
    return bdlat_TypeCategoryUtil::manipulateByCategory(value, proxy);
}

template &lt;class TYPE&gt;
int Decoder::decodeImp(TYPE *value, int mode, bdlat_TypeCategory::Sequence)
{
    if (bdlat_FormattingMode::e_UNTAGGED &amp; mode) {
        // This is an anonymous element.  Do not read anything and instead
        // decode into the corresponding sub-element.

        if (bdlat_SequenceFunctions::hasAttribute(
                                   *value,
                                   d_elementName.data(),
                                   static_cast&lt;int&gt;(d_elementName.length()))) {
            Decoder_ElementVisitor visitor = { this, mode };

            if (0 != bdlat_SequenceFunctions::manipulateAttribute(
                                   value,
                                   visitor,
                                   d_elementName.data(),
                                   static_cast&lt;int&gt;(d_elementName.length()))) {
                d_logStream &lt;&lt; &quot;Could not decode sequence, error decoding &quot;
                            &lt;&lt; &quot;element or bad element name &#39;&quot;
                            &lt;&lt; d_elementName &lt;&lt; &quot;&#39; \n&quot;;
                return -1;                                            // RETURN
            }
        }
        else {
            if (d_skipUnknownElements) {
                const int rc = skipUnknownElement(d_elementName);
                if (rc) {
                    d_logStream &lt;&lt; &quot;Error reading unknown element &#39;&quot;
                                &lt;&lt; d_elementName &lt;&lt; &quot;&#39; or after it\n&quot;;
                    return -1;                                        // RETURN
                }
            }
            else {
                d_logStream &lt;&lt; &quot;Unknown element &#39;&quot; &lt;&lt; d_elementName
                            &lt;&lt; &quot;&#39; found\n&quot;;
                return -1;                                            // RETURN
            }
        }
    }
    else {
        if (++d_currentDepth &gt; d_maxDepth) {
            d_logStream &lt;&lt; &quot;Maximum allowed decoding depth reached: &quot;
                        &lt;&lt; d_currentDepth &lt;&lt; &quot;\n&quot;;
            return -1;                                                // RETURN
        }

        if (Tokenizer::e_START_OBJECT != d_tokenizer.tokenType()) {
            d_logStream &lt;&lt; &quot;Could not decode sequence, missing starting &#39;{&#39;\n&quot;;
            return -1;                                                // RETURN
        }

        int rc = d_tokenizer.advanceToNextToken();
        if (rc) {
            d_logStream &lt;&lt; &quot;Could not decode sequence, &quot;
                        &lt;&lt; &quot;error reading token after &#39;{&#39;\n&quot;;
            return -1;                                                // RETURN
        }

        while (Tokenizer::e_ELEMENT_NAME ==
                                                     d_tokenizer.tokenType()) {
            bslstl::StringRef elementName;
            rc = d_tokenizer.value(&amp;elementName);
            if (rc) {
                d_logStream &lt;&lt; &quot;Error reading attribute name after &#39;{&#39;\n&quot;;
                return -1;                                            // RETURN
            }

            if (bdlat_SequenceFunctions::hasAttribute(
                                     *value,
                                     elementName.data(),
                                     static_cast&lt;int&gt;(elementName.length()))) {
                d_elementName = elementName;

                rc = d_tokenizer.advanceToNextToken();
                if (rc) {
                    d_logStream &lt;&lt; &quot;Error reading value for attribute &#39;&quot;
                                &lt;&lt; d_elementName &lt;&lt; &quot;&#39; \n&quot;;
                    return -1;                                        // RETURN
                }

                Decoder_ElementVisitor visitor = { this, mode };

                if (0 != bdlat_SequenceFunctions::manipulateAttribute(
                                   value,
                                   visitor,
                                   d_elementName.data(),
                                   static_cast&lt;int&gt;(d_elementName.length()))) {
                    d_logStream &lt;&lt; &quot;Could not decode sequence, error decoding &quot;
                                &lt;&lt; &quot;element or bad element name &#39;&quot;
                                &lt;&lt; d_elementName &lt;&lt; &quot;&#39; \n&quot;;
                    return -1;                                        // RETURN
                }
            }
            else {
                if (d_skipUnknownElements) {
                    rc = skipUnknownElement(elementName);
                    if (rc) {
                        d_logStream &lt;&lt; &quot;Error reading unknown element &#39;&quot;
                                    &lt;&lt; elementName &lt;&lt; &quot;&#39; or after it\n&quot;;
                        return -1;                                    // RETURN
                    }
                }
                else {
                    d_logStream &lt;&lt; &quot;Unknown element &#39;&quot;
                                &lt;&lt; elementName &lt;&lt; &quot;&#39; found\n&quot;;
                    return -1;                                        // RETURN
                }
            }

            rc = d_tokenizer.advanceToNextToken();
            if (rc) {
                d_logStream &lt;&lt; &quot;Could not decode sequence, error reading token&quot;
                            &lt;&lt; &quot; after value for attribute &#39;&quot;
                            &lt;&lt; d_elementName &lt;&lt; &quot;&#39; \n&quot;;
                return -1;                                            // RETURN
            }
        }

        if (Tokenizer::e_END_OBJECT != d_tokenizer.tokenType()) {
            d_logStream &lt;&lt; &quot;Could not decode sequence, &quot;
                        &lt;&lt; &quot;missing terminator &#39;}&#39; or seperator &#39;,&#39;\n&quot;;
            return -1;                                                // RETURN
        }

        --d_currentDepth;
    }
    return 0;
}

template &lt;class TYPE&gt;
int Decoder::decodeImp(TYPE                       *value,
                       int                         mode,
                       bdlat_TypeCategory::Choice)
{
    if (bdlat_FormattingMode::e_UNTAGGED &amp; mode) {
        // This is an anonymous element.  Do not read anything and instead
        // decode into the corresponding sub-element.

        bslstl::StringRef selectionName;
        selectionName.assign(d_elementName.begin(), d_elementName.end());

        if (bdlat_ChoiceFunctions::hasSelection(
                                   *value,
                                   selectionName.data(),
                                   static_cast&lt;int&gt;(selectionName.length()))) {
            if (0 != bdlat_ChoiceFunctions::makeSelection(
                                   value,
                                   selectionName.data(),
                                   static_cast&lt;int&gt;(selectionName.length()))) {
                d_logStream &lt;&lt; &quot;Could not decode choice, bad selection name &#39;&quot;
                            &lt;&lt; selectionName &lt;&lt; &quot;&#39; \n&quot;;
                return -1;                                            // RETURN
            }

            Decoder_ElementVisitor visitor = { this, mode };

            if (0 != bdlat_ChoiceFunctions::manipulateSelection(value,
                                                                visitor)) {
                d_logStream &lt;&lt; &quot;Could not decode choice, selection &quot;
                            &lt;&lt; &quot;was not decoded\n&quot;;
                return -1;                                            // RETURN
            }
        }
        else {
            if (d_skipUnknownElements) {
                const int rc = skipUnknownElement(selectionName);
                if (rc) {
                     d_logStream &lt;&lt; &quot;Error reading unknown element &#39;&quot;
                                 &lt;&lt; selectionName &lt;&lt; &quot;&#39; or after that &quot;
                                 &lt;&lt; &quot;element\n&quot;;
                    return -1;                                        // RETURN
                }
            }
            else {
                d_logStream &lt;&lt; &quot;Unknown element &#39;&quot;
                            &lt;&lt; selectionName &lt;&lt; &quot;&#39; found\n&quot;;
                return -1;                                            // RETURN
            }
        }
    }
    else {
        if (++d_currentDepth &gt; d_maxDepth) {
            d_logStream &lt;&lt; &quot;Maximum allowed decoding depth reached: &quot;
                        &lt;&lt; d_currentDepth &lt;&lt; &quot;\n&quot;;
            return -1;                                                // RETURN
        }

        if (Tokenizer::e_START_OBJECT != d_tokenizer.tokenType()) {
            d_logStream &lt;&lt; &quot;Could not decode choice, missing starting {\n&quot;;
            return -1;                                                // RETURN
        }

        int rc = d_tokenizer.advanceToNextToken();
        if (rc) {
            d_logStream &lt;&lt; &quot;Could not decode choice, &quot;
                        &lt;&lt; &quot;error reading token after {\n&quot;;
            return -1;                                                // RETURN
        }

        if (Tokenizer::e_ELEMENT_NAME == d_tokenizer.tokenType()) {
            bslstl::StringRef selectionName;
            rc = d_tokenizer.value(&amp;selectionName);
            if (rc) {
                d_logStream &lt;&lt; &quot;Error reading selection name after &#39;{&#39;\n&quot;;
                return -1;                                            // RETURN
            }

            if (bdlat_ChoiceFunctions::hasSelection(
                                   *value,
                                   selectionName.data(),
                                   static_cast&lt;int&gt;(selectionName.length()))) {
                if (0 != bdlat_ChoiceFunctions::makeSelection(
                                   value,
                                   selectionName.data(),
                                   static_cast&lt;int&gt;(selectionName.length()))) {
                    d_logStream &lt;&lt; &quot;Could not decode choice, bad selection &quot;
                                &lt;&lt; &quot;name &#39;&quot; &lt;&lt; selectionName &lt;&lt; &quot;&#39; \n&quot;;
                    return -1;                                        // RETURN
                }

                rc = d_tokenizer.advanceToNextToken();
                if (rc) {
                    d_logStream &lt;&lt; &quot;Could not decode choice, &quot;
                                &lt;&lt; &quot;error reading value \n&quot;;
                    return -1;                                        // RETURN
                }

                Decoder_ElementVisitor visitor = { this, mode };

                if (0 != bdlat_ChoiceFunctions::manipulateSelection(value,
                                                                    visitor)) {
                    d_logStream &lt;&lt; &quot;Could not decode choice, selection &quot;
                                &lt;&lt; &quot;was not decoded\n&quot;;
                    return -1;                                        // RETURN
                }
            }
            else {
                if (d_skipUnknownElements) {
                    rc = skipUnknownElement(selectionName);
                    if (rc) {
                        d_logStream &lt;&lt; &quot;Error reading unknown element &#39;&quot;
                                    &lt;&lt; selectionName &lt;&lt; &quot;&#39; or after that &quot;
                                    &lt;&lt; &quot;element\n&quot;;
                        return -1;                                    // RETURN
                    }
                }
                else {
                    d_logStream &lt;&lt; &quot;Unknown element &#39;&quot;
                                &lt;&lt; selectionName &lt;&lt; &quot;&#39; found\n&quot;;
                    return -1;                                        // RETURN
                }
            }

            rc = d_tokenizer.advanceToNextToken();
            if (rc) {
                d_logStream &lt;&lt; &quot;Could not decode choice, error reading &quot;
                            &lt;&lt; &quot;token after value for selection \n&quot;;
                return -1;                                            // RETURN
            }
        }

        if (Tokenizer::e_END_OBJECT != d_tokenizer.tokenType()) {
            d_logStream &lt;&lt; &quot;Could not decode choice, &quot;
                        &lt;&lt; &quot;missing terminator &#39;}&#39;\n&quot;;
            return -1;                                                // RETURN
        }

        --d_currentDepth;
    }
    return 0;
}

template &lt;class TYPE&gt;
int Decoder::decodeImp(TYPE *value,
                              int,
                              bdlat_TypeCategory::Enumeration)
{
    enum { k_MIN_ENUM_STRING_LENGTH = 2 };

    if (Tokenizer::e_ELEMENT_VALUE != d_tokenizer.tokenType()) {
        d_logStream &lt;&lt; &quot;Enumeration element value was not found\n&quot;;
        return -1;                                                    // RETURN
    }

    bslstl::StringRef dataValue;
    int rc = d_tokenizer.value(&amp;dataValue);
    if (rc
     || dataValue.length() &lt;= k_MIN_ENUM_STRING_LENGTH
     || &#39;&quot;&#39;                != dataValue[0]
     || &#39;&quot;&#39;                != dataValue[dataValue.length() - 1]) {
        d_logStream &lt;&lt; &quot;Error reading enumeration value\n&quot;;
        return -1;                                                    // RETURN
    }

    dataValue.assign(dataValue.begin() + 1, dataValue.end() - 1);
    rc = bdlat_EnumFunctions::fromString(value,
                                         dataValue.data(),
                                         static_cast&lt;int&gt;(dataValue.length()));

    if (rc) {
        d_logStream &lt;&lt; &quot;Could not decode Enum String, value not allowed \&quot;&quot;
                    &lt;&lt; dataValue &lt;&lt; &quot;\&quot;\n&quot;;
    }
    return rc;
}

template &lt;class TYPE&gt;
int Decoder::decodeImp(TYPE *value,
                              int,
                              bdlat_TypeCategory::CustomizedType)
{
    if (Tokenizer::e_ELEMENT_VALUE != d_tokenizer.tokenType()) {
        d_logStream &lt;&lt; &quot;Customized element value was not found\n&quot;;
        return -1;                                                    // RETURN
    }

    bslstl::StringRef dataValue;
    int rc = d_tokenizer.value(&amp;dataValue);
    if (rc) {
        d_logStream &lt;&lt; &quot;Error reading customized type value\n&quot;;
        return -1;                                                    // RETURN
    }

    typename bdlat_CustomizedTypeFunctions::BaseType&lt;TYPE&gt;::Type valueBaseType;

    rc = ParserUtil::getValue(&amp;valueBaseType, dataValue);
    if (rc) {
        d_logStream &lt;&lt; &quot;Could not decode Enum Customized, &quot;
                    &lt;&lt; &quot;value not allowed \&quot;&quot; &lt;&lt; dataValue &lt;&lt; &quot;\&quot;\n&quot;;
        return -1;                                                    // RETURN
    }

    rc = bdlat_CustomizedTypeFunctions::convertFromBaseType(value,
                                                            valueBaseType);
    if (rc) {
        d_logStream &lt;&lt; &quot;Could not convert base type to customized type, &quot;
                    &lt;&lt; &quot;base value disallowed: \&quot;&quot;;
        bdlb::PrintMethods::print(d_logStream, valueBaseType, 0, -1);
        d_logStream &lt;&lt; &quot;\&quot;\n&quot;;
    }
    return rc;
}

template &lt;class TYPE&gt;
int Decoder::decodeImp(TYPE *value,
                              int,
                              bdlat_TypeCategory::Simple)
{
    if (Tokenizer::e_ELEMENT_VALUE != d_tokenizer.tokenType()) {
        d_logStream &lt;&lt; &quot;Simple element value was not found\n&quot;;
        return -1;                                                    // RETURN
    }

    bslstl::StringRef dataValue;
    int rc = d_tokenizer.value(&amp;dataValue);
    if (rc) {
        d_logStream &lt;&lt; &quot;Error reading simple value\n&quot;;
        return -1;                                                    // RETURN
    }

    return ParserUtil::getValue(value, dataValue);
}

inline
int Decoder::decodeImp(bsl::vector&lt;char&gt; *value,
                              int,
                              bdlat_TypeCategory::Array)
{
    if (Tokenizer::e_ELEMENT_VALUE != d_tokenizer.tokenType()) {
        d_logStream &lt;&lt; &quot;Could not decode vector&lt;char&gt; &quot;
                    &lt;&lt; &quot;expected as an element value\n&quot;;
        return -1;                                                    // RETURN
    }

    bslstl::StringRef dataValue;
    int rc = d_tokenizer.value(&amp;dataValue);

    if (rc) {
        d_logStream &lt;&lt; &quot;Error reading customized type element value\n&quot;;
        return -1;                                                    // RETURN
    }

    return ParserUtil::getValue(value, dataValue);
}

template &lt;class TYPE&gt;
int Decoder::decodeImp(TYPE                      *value,
                       int                        mode,
                       bdlat_TypeCategory::Array)
{
    if (Tokenizer::e_START_ARRAY != d_tokenizer.tokenType()) {
        d_logStream &lt;&lt; &quot;Could not decode vector, missing start token: &#39;[&#39;\n&quot;;
        return -1;                                                    // RETURN
    }

    int rc = d_tokenizer.advanceToNextToken();
    if (rc) {
        return rc;                                                    // RETURN
    }

    int i = 0;
    while (Tokenizer::e_END_ARRAY != d_tokenizer.tokenType()) {
        if (Tokenizer::e_ELEMENT_VALUE == d_tokenizer.tokenType()
         || Tokenizer::e_START_OBJECT  ==
                                                     d_tokenizer.tokenType()) {
            ++i;
            bdlat_ArrayFunctions::resize(value, i);

            Decoder_ElementVisitor visitor = { this, mode };

            if (0 != bdlat_ArrayFunctions::manipulateElement(value,
                                                             visitor,
                                                             i - 1)) {
                d_logStream &lt;&lt; &quot;Error adding element &#39;&quot; &lt;&lt; i - 1 &lt;&lt; &quot;&#39;\n&quot;;
                return -1;                                            // RETURN
            }

            rc = d_tokenizer.advanceToNextToken();
            if (rc) {
                d_logStream &lt;&lt; &quot;Error reading token after value of element &#39;&quot;
                            &lt;&lt; i - 1 &lt;&lt; &quot;&#39;\n&quot;;
                return rc;                                            // RETURN
            }
        }
        else {
            d_logStream &lt;&lt; &quot;Erroneous token found instead of array element\n&quot;;
            return -1;                                                // RETURN
        }
    }

    if (Tokenizer::e_END_ARRAY != d_tokenizer.tokenType()) {
        d_logStream &lt;&lt; &quot;Could not decode vector, missing end token: &#39;]&#39;\n&quot;;
        return -1;                                                    // RETURN
    }

    return 0;
}

template &lt;class TYPE&gt;
int Decoder::decodeImp(TYPE                              *value,
                       int                                mode,
                       bdlat_TypeCategory::NullableValue)
{
    enum { k_NULL_VALUE_LENGTH = 4 };

    if (Tokenizer::e_ELEMENT_VALUE == d_tokenizer.tokenType()) {
        bslstl::StringRef dataValue;
        const int rc = d_tokenizer.value(&amp;dataValue);
        if (rc) {
            return rc;                                                // RETURN
        }

        if (k_NULL_VALUE_LENGTH == dataValue.length()
         &amp;&amp; &#39;n&#39;                      == dataValue[0]
         &amp;&amp; &#39;u&#39;                      == dataValue[1]
         &amp;&amp; &#39;l&#39;                      == dataValue[2]
         &amp;&amp; &#39;l&#39;                      == dataValue[3]) {
            return 0;                                                 // RETURN
        }
    }

    bdlat_NullableValueFunctions::makeValue(value);

    Decoder_ElementVisitor visitor = { this, mode };
    return bdlat_NullableValueFunctions::manipulateValue(value, visitor);
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
inline
int Decoder::decodeImp(TYPE *, ANY_CATEGORY)
{
    BSLS_ASSERT_OPT(!&quot;Unreachable&quot;);

    return -1;
}

// CREATORS
inline
Decoder::Decoder(bslma::Allocator *basicAllocator)
: d_logStream(basicAllocator)
, d_tokenizer(basicAllocator)
, d_elementName(basicAllocator)
, d_currentDepth(0)
, d_maxDepth(0)
, d_skipUnknownElements(false)
{
}

// MANIPULATORS
template &lt;class TYPE&gt;
int Decoder::decode(bsl::streambuf        *streamBuf,
                    TYPE                  *value,
                    const DecoderOptions&amp;  options)
{
    BSLS_ASSERT(streamBuf);
    BSLS_ASSERT(value);

    bdlat_TypeCategory::Value category =
                                bdlat_TypeCategoryFunctions::select(*value);

    if (bdlat_TypeCategory::e_SEQUENCE_CATEGORY != category
     &amp;&amp; bdlat_TypeCategory::e_CHOICE_CATEGORY   != category
     &amp;&amp; bdlat_TypeCategory::e_ARRAY_CATEGORY    != category) {
        d_logStream &lt;&lt; &quot;The object being decoded must be a Sequence, &quot;
                    &lt;&lt; &quot;Choice, or Array type\n&quot;;
        return -1;                                                    // RETURN
    }

    d_tokenizer.reset(streamBuf);
    d_tokenizer.setAllowStandAloneValues(false);

    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    int rc = d_tokenizer.advanceToNextToken();
    if (rc) {
        d_logStream &lt;&lt; &quot;Error advancing to the first token. &quot;
                    &lt;&lt; &quot;Expecting a &#39;{&#39; or &#39;[&#39; as the first character\n&quot;;
        return rc;                                                    // RETURN
    }

    bdlat_ValueTypeFunctions::reset(value);

    d_logStream.clear();
    d_logStream.str(&quot;&quot;);

    d_maxDepth            = options.maxDepth();
    d_skipUnknownElements = options.skipUnknownElements();

    rc = decodeImp(value, 0, TypeCategory());

    d_tokenizer.resetStreamBufGetPointer();

    return rc;
}

template &lt;class TYPE&gt;
int Decoder::decode(bsl::istream&amp;          stream,
                    TYPE                  *value,
                    const DecoderOptions&amp;  options)
{
    if (!stream.good()) {
        return -1;                                                    // RETURN
    }

    if (0 != decode(stream.rdbuf(), value, options)) {
        stream.setstate(bsl::ios_base::failbit);
        return -1;                                                    // RETURN
    }

    return 0;
}

template &lt;class TYPE&gt;
int Decoder::decode(bsl::streambuf *streamBuf, TYPE *value)
{
    const DecoderOptions options;
    return decode(streamBuf, value, options);
}

template &lt;class TYPE&gt;
int Decoder::decode(bsl::istream&amp; stream, TYPE *value)
{
    const DecoderOptions options;
    return decode(stream, value, options);
}

// ACCESSORS
inline
bsl::string Decoder::loggedMessages() const
{
    return d_logStream.str();
}

                       // -----------------------------
                       // struct Decoder_ElementVisitor
                       // -----------------------------

template &lt;class TYPE&gt;
inline
int Decoder_ElementVisitor::operator()(TYPE *value)
{
    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;
    return d_decoder_p-&gt;decodeImp(value, d_mode, TypeCategory());
}

template &lt;class TYPE, class INFO&gt;
inline
int Decoder_ElementVisitor::operator()(TYPE *value, const INFO&amp; info)
{
    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;
    return d_decoder_p-&gt;decodeImp(value,
                                  info.formattingMode(),
                                  TypeCategory());
}

                       // -----------------------------
                       // struct Decoder_DecodeImpProxy
                       // -----------------------------

// MANIPULATORS
template &lt;class TYPE&gt;
inline
int Decoder_DecodeImpProxy::operator()(TYPE *, bslmf::Nil)
{
    BSLS_ASSERT_OPT(!&quot;Unreachable&quot;);

    return -1;
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
inline
int Decoder_DecodeImpProxy::operator()(TYPE         *object,
                                       ANY_CATEGORY  category)
{
    return d_decoder_p-&gt;decodeImp(object, d_mode, category);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
