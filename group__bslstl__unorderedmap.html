<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_unorderedmap Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_unorderedmap<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> container.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">bsl::unordered_map::key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gada3d59d79ebed1da840d4bc073381609">bsl::unordered_map::mapped_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; const KEY, <br class="typebreak"/>
VALUE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gabc706719a0b22874e967feb3d26e33bd">bsl::unordered_map::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef HASH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga7eb1a11e3435ec8e83348a469e7586ef">bsl::unordered_map::hasher</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef EQUAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga43a3a6e7447ab33468ab2c2445ea531a">bsl::unordered_map::key_equal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga5f65158aa509fdfb71e2b0706837c8c0">bsl::unordered_map::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef allocator_type::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gab82f42c50a8ae07add49c554b900094a">bsl::unordered_map::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
allocator_type::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga4ce6b350c2f6ef7249fa9432926216a0">bsl::unordered_map::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">bsl::unordered_map::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gabc0dd2d5cb53e0fede397117d470fb24">bsl::unordered_map::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga2c7a7b4b41d5eb42e33488ca4528a4ba">bsl::unordered_map::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga489e4df0f652e594c4de7d228f5b06e7">bsl::unordered_map::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a><br class="typebreak"/>
&lt; value_type, difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gab7f84c5ccadac45c3d7ae9dfc2eb7fa6">bsl::unordered_map::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a><br class="typebreak"/>
&lt; const value_type, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaf99fdff6c051caf748820608a2927eaa">bsl::unordered_map::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::HashTableBucketIterator<br class="typebreak"/>
&lt; value_type, difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga82801babe6317665185a546a885748f2">bsl::unordered_map::local_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::HashTableBucketIterator<br class="typebreak"/>
&lt; const value_type, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaacf3888883fdae79e5503c655f872939">bsl::unordered_map::const_local_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gadcbddf5695e5cf931abdd7643578e813">bsl::unordered_map::BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (unordered_map,::BloombergLP::bslmf::IsBitwiseMoveable,::BloombergLP::bslmf::IsBitwiseMoveable&lt; HashTable &gt;::value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaf27f657a125c484b93854cf690cbbb14">bsl::unordered_map::unordered_map</a> (size_type initialNumBuckets=0, const hasher &amp;hashFunction=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;basicAllocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga36efb673a10ad2675a528c20f5752889">bsl::unordered_map::unordered_map</a> (const allocator_type &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gab168e1533fc4fe84467005fce9cfbfae">bsl::unordered_map::unordered_map</a> (const unordered_map &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga4729034576bdd8365aed6aadc3b19155">bsl::unordered_map::unordered_map</a> (const unordered_map &amp;original, const allocator_type &amp;basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga4009ed91ded563b220e32d5d09084a11">bsl::unordered_map::unordered_map</a> (INPUT_ITERATOR first, INPUT_ITERATOR last, size_type initialNumBuckets=0, const hasher &amp;hashFunction=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;basicAllocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga120f9570ad70b4b0a5582de1a329814b">bsl::unordered_map::~unordered_map</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unordered_map &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga010b0fbb7737d2e3a902daacda105193">bsl::unordered_map::operator=</a> (const unordered_map &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">mapped_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaccd7c401c9b8e8a23ae73b1702641181">bsl::unordered_map::operator[]</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">mapped_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaab4872ccedf3d7fcd15064d9858ee0c3">bsl::unordered_map::at</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga155bac80f132c04d956f4ccb5143a7cb">bsl::unordered_map::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga8ca8efee2ae369c4972442105213c5cf">bsl::unordered_map::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gad125de130d7ec49f9af4eecf3d40d503">bsl::unordered_map::begin</a> (size_type index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga3040ab1ffec86576f552c7c652fec2df">bsl::unordered_map::end</a> (size_type index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaf03bb87d2c6946aaa057cae588eecc23">bsl::unordered_map::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gad08067070f04b73fb044a38a9ef32606">bsl::unordered_map::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gae0c463ce68ccc8acbdec5952c9df4337">bsl::unordered_map::erase</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga7bf4fe159278cb729be06c68ee4c5b74">bsl::unordered_map::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga3718f60f68a27eea701607154f59ecda">bsl::unordered_map::find</a> (const key_type &amp;key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">pair&lt; iterator, bool &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga8b05e4716e90a9341d20bf1e755d84d5">bsl::unordered_map::insert</a> (const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gac1e89f8b96b1242de7320a3ab83d7ff1">bsl::unordered_map::insert</a> (const_iterator hint, const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga5d690ff198892fca1fd6b6d6a2d87aa2">bsl::unordered_map::insert</a> (INPUT_ITERATOR first, INPUT_ITERATOR last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga462413dd9ce4314005bc81ef2abbfcb4">bsl::unordered_map::equal_range</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga4ffa659ba3bcf9e0e670d24b4edfa855">bsl::unordered_map::max_load_factor</a> (float newMaxLoadFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga71fcbb1773d9c3bcb550f269c6dfc73e">bsl::unordered_map::rehash</a> (size_type numBuckets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga868c8da7b11922a9575ff3ef3bedddc4">bsl::unordered_map::reserve</a> (size_type numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gafb1f028665d51b997b1b9afb5255193d">bsl::unordered_map::swap</a> (unordered_map &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const mapped_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gafa30c525e6105241458628f9005c5c5b">bsl::unordered_map::at</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga9036b6a7ae8e85eac7322086d62a4577">bsl::unordered_map::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaf0f51a20ee138b2b86b59a239c8c3e7a">bsl::unordered_map::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga7d33dc1ff7cf4398a21eff735d75f600">bsl::unordered_map::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gae19ec5a71a5c5af0a07252e1ad7c6822">bsl::unordered_map::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga3d8032da1052300c73bf1c0b03c496d5">bsl::unordered_map::begin</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga9b590484edcfb5f70b3da604b3e55b64">bsl::unordered_map::cbegin</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga6677150da9d57ca1d7f6d9fefbaa2de7">bsl::unordered_map::end</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga0a2155283876261fb11074ad92ec9b02">bsl::unordered_map::cend</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaf8fdbb44c934a90020542bdcc121701b">bsl::unordered_map::bucket</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga68bcc778cab7a6716388c63d5abc96a8">bsl::unordered_map::bucket_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gab0fcfc7ff734b03bc67433c4d1c0dac1">bsl::unordered_map::max_bucket_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gad2e54ac291fa8c25374e2289b60d1574">bsl::unordered_map::bucket_size</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga6d72213f6bf2c16da92876c175f7af9d">bsl::unordered_map::count</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gad6eba26d1fc10e33804255f0a5a466b4">bsl::unordered_map::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gadc28b39e9462374c7bed039bf2eb2b67">bsl::unordered_map::equal_range</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gafa1ae679704e0ffe457a6ee2e5a271a3">bsl::unordered_map::find</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga0cd74075299dfe15846063ce244fe275">bsl::unordered_map::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hasher&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga5721e3e1778a542f6889d93586f47390">bsl::unordered_map::hash_function</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">key_equal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga838d2f6f8ff91da9673be908aff00e28">bsl::unordered_map::key_eq</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga61dc1258354e771ea9a5b58476489fe1">bsl::unordered_map::load_factor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga06d036aafd8fae2d48627075bd77ef05">bsl::unordered_map::max_load_factor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga5e74c56229155ada463d2ddbf4b6e86e">bsl::unordered_map::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gaa33c259b435a3be3bbe2e46289b1c575">bsl::unordered_map::max_size</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga0c4f54461a359b055782b5a6a3bcb14c">bsl::operator==</a> (const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga631ea915746fe2b1f2664f2b2306d4d2">bsl::operator!=</a> (const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#ga2c1a5c101ec75196e300c49d54a40833">bsl::swap</a> (unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;a, unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY2 , class VALUE2 , class HASH2 , class EQUAL2 , class ALLOCATOR2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmap.html#gab59720c8d1e7fadca1e1cfad48327513">bsl::unordered_map::operator==</a> (const unordered_map&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_map&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on <code>KEY</code> and <code>VALUE</code></a> </li>
<li>
<a href="#3.2">Requirements on <code>HASH</code> and <code>EQUAL</code></a> </li>
<li>
<a href="#3.3">Memory Allocation</a> <ul>
<li>
<a href="#3.3.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.4">Operations</a> </li>
<li>
<a href="#3.5">Iterator, Pointer, and Reference Invalidation</a> </li>
<li>
<a href="#3.6">Unordered Map Configuration</a> </li>
<li>
<a href="#3.7">Practical Requirements on <code>HASH</code></a> </li>
<li>
<a href="#3.8">Usage</a> <ul>
<li>
<a href="#3.8.1">Example 1: Gathering Document Statistics</a> </li>
<li>
<a href="#3.8.2">Example 2: Examining and Setting Unordered Map Configuration</a> </li>
<li>
<a href="#3.8.3">Example 3: Inverse Concordance</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> container. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>  </td><td>STL-compliant <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> container  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bsl+stdhdrs </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template, <code><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a></code>, implementing the standard container holding a collection of unique keys, each mapped to an associated value with no guarantees on ordering. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of keys) and the set of key-value pairs the <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> contains, without regard to their order. If <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> is instantiated with a key type or mapped value-type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if the key or value type cannot be tested for equality, then an <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> containing that type cannot be tested for equality. It is even possible to instantiate <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> with types that do not have an accessible copy-constructor, in which case the <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> will not be copyable. Note that the equality-comparison operator for each key-value pair is used to determine when two <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> objects have the same value, and not the instance of the <code>EQUAL</code> template parameter supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> meets the requirements of an unordered associative container with forward iterators in the C++11 standard [unord]. The <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> implemented here adheres to the C++11 standard, except that it may rehash when setting the <code>max_load_factor</code> in order to preserve the property that the value is always respected (which is a potentially throwing operation) and it does not have interfaces that take rvalue references, <code>initializer_list</code>, <code>emplace</code>, or operations taking a variadic number of template parameters. Note that excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_key_and_value"></a> <a class="anchor" id="description.requirements_on_key_and_value"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on KEY and VALUE: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> instantiation is a fully <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the supplied <code>KEY</code> and <code>VALUE</code> template parameters are fully value-semantic. It is possible to instantiate an <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> with <code>KEY</code> and <code>VALUE</code> parameter arguments that do not provide a full set of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> to describe a function's requirements for the <code>KEY</code> and <code>VALUE</code> template parameters. These terms are also defined in section [utility.arg.requirements] of the C++11 standard. Note that, in the context of an <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> instantiation, the requirements apply specifically to the <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code>s element type, <code>value_type</code>, which is an alias for <code>std::pair&lt;const KEY, VALUE&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_key_and_value.default-constructible"></a> <a class="anchor" id="description.requirements_on_key_and_value.default-constructible"></a> <em>default-constructible</em>: <br/>
 The type provides an accessible default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_key_and_value.copy-constructible"></a> <a class="anchor" id="description.requirements_on_key_and_value.copy-constructible"></a> <em>copy-constructible</em>: <br/>
 The type provides an accessible copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_key_and_value.equality-comparable"></a> <a class="anchor" id="description.requirements_on_key_and_value.equality-comparable"></a> <em>equality-comparable</em>: <br/>
 The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_hash_and_equal"></a> <a class="anchor" id="description.requirements_on_hash_and_equal"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on HASH and EQUAL: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The (template parameter) types <code>HASH</code> and <code>EQUAL</code> must be copy-constructible function-objects. Note that this requirement is somewhat stronger than the requirement currently in the standard; see the discussion for Issue 2215 (<a href="http://cplusplus.github.com/LWG/lwg-active.html">http://cplusplus.github.com/LWG/lwg-active.html</a>#2215); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Naturally, if either <code>HASH</code> or <code>EQUAL</code> is to be the default for its type, it must be default-constructible as well. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>HASH</code> shall support a function call operator compatible with the following statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  HASH        hash;
  KEY         key;
  std::size_t result = hash(key);
</pre></div><br/>
<br/>
 where the definition of the called function meets the requirements of a hash function as specified in <a href="group__bslstl__hash.html#standard_hash_function" class="el"><code>bslstl_hash</code>|Standard Hash Function</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>EQUAL</code> shall support the a function call operator compatible with the following statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  EQUAL equal;
  KEY   key1, key2;
  <span class="keywordtype">bool</span>  result = equal(key1, key2);
</pre></div><br/>
<br/>
 where the definition of the called function defines an equivalence relationship on keys that is both reflexive and transitive. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>HASH</code> and <code>EQUAL</code> function-objects are further constrained, such for any two objects whose keys compare equal by the comparator, shall produce the same value from the hasher. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as the <code>ALLOCATOR</code> template parameter determines how memory will be allocated. The <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> template supports allocators meeting the requirements of the C++11 standard [allocator.requirements], and, in addition, it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the (template parameter) type <code>ALLOCATOR</code> of an <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> instantiation is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that unordered map type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such an unordered map accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it is used to supply memory for the <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> throughout its lifetime; otherwise, the <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> will use the default allocator installed at the time of the <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code>s construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, an <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> supplies that allocator's address to the constructors of contained objects of the (template parameter) types <code>KEY</code> and <code>VALUE</code> having the <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;K&#39;</span>               - <span class="keyword">template</span> parameter type <span class="stringliteral">&#39;KEY&#39;</span> of the unordered map
  <span class="charliteral">&#39;V&#39;</span>               - <span class="keyword">template</span> parameter type <span class="stringliteral">&#39;VALUE&#39;</span> of the unordered map
  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>          - two distinct objects of type <span class="stringliteral">&#39;unordered_map&lt;K, V&gt;&#39;</span>
  <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;m&#39;</span>          - number of elements in <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span>, respectively
  <span class="charliteral">&#39;w&#39;</span>               - number of buckets of <span class="charliteral">&#39;a&#39;</span>
  <span class="stringliteral">&#39;value_type&#39;</span>      - <span class="stringliteral">&#39;unordered_map&lt;K, V&gt;::value_type&#39;</span>
  <span class="stringliteral">&#39;hf&#39;</span>              - hash functor hashing objects of type <span class="charliteral">&#39;K&#39;</span>
  <span class="stringliteral">&#39;eq&#39;</span>              - equality functor comparing objects of type <span class="charliteral">&#39;K&#39;</span>
  <span class="stringliteral">&#39;al               - an STL-style memory allocator</span>
<span class="stringliteral">  &#39;</span>i1<span class="stringliteral">&#39;, &#39;</span>i2<span class="stringliteral">&#39;        - two iterators defining a sequence of &#39;</span>value_type<span class="stringliteral">&#39;</span>
<span class="stringliteral">                      objects</span>
<span class="stringliteral">  &#39;</span>k<span class="stringliteral">&#39;               - an object of type &#39;</span>K<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>v<span class="stringliteral">&#39;               - an object of type &#39;</span>value_type<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>p1<span class="stringliteral">&#39;, &#39;</span>p2<span class="stringliteral">&#39;        - two iterators belonging to &#39;</span>a<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>distance(i1,i2)<span class="stringliteral">&#39; - the number of elements in the range [i1, i2)</span>
<span class="stringliteral">  &#39;</span>distance(p1,p2)<span class="stringliteral">&#39; - the number of elements in the range [p1, p2)</span>
<span class="stringliteral">  &#39;</span>z<span class="stringliteral">&#39;               - a floating point value representing a load factor</span>
<span class="stringliteral"></span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | Operation                                          | Complexity         |</span>
<span class="stringliteral">  +====================================================+====================+</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a;    (default construction)   | O[1]               |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(al);                         |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(b); (copy construction)      | Average: O[m]      |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(b, al);                      | Worst:   O[m^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(w);                          | O[n]               |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(w, hf);                      |                    |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(w, hf, eq);                  |                    |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(w, hf, eq, al);              |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(i1, i2);                     | Average: O[N]      |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(i1, i2, w)                   | Worst:   O[N^2]    |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(i1, i2, w, hf);              | where N =          |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(i1, i2, w, hf, eq);          |  distance(i1, i2)] |</span>
<span class="stringliteral">  | unordered_map&lt;K, V&gt; a(i1, i2, w, hf, eq, al);      |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.~unordered_map&lt;K, V&gt;(); (destruction)            | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a = b;          (assignment)                       | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a == b, a != b                                     | Best:  O[n]        |</span>
<span class="stringliteral">  |                                                    | Worst: O[n^2]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.swap(b), swap(a, b)                              | O[1] if &#39;</span>a<span class="stringliteral">&#39; and    |</span>
<span class="stringliteral">  |                                                    | &#39;</span>b<span class="stringliteral">&#39; use the same   |</span>
<span class="stringliteral">  |                                                    | allocator,         |</span>
<span class="stringliteral">  |                                                    | O[n + m] otherwise |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.key_eq()                                         | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.hash_function()                                  | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.size()                                           | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_size()                                       | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.empty()                                          | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.get_allocator()                                  | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a[k]                                               | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.at(k)                                            | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(v)                                        | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(p1, v)                                    | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(i1, i2)                                   | Average: O[        |</span>
<span class="stringliteral">  |                                                    |   distance(i1, i2)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n *     |</span>
<span class="stringliteral">  |                                                    |   distance(i1, i2)]|</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1)                                        | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(k)                                         | Average:           |</span>
<span class="stringliteral">  |                                                    |       O[a.count(k)]|</span>
<span class="stringliteral">  |                                                    | Worst:             |</span>
<span class="stringliteral">  |                                                    |       O[n]         |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1, p2)                                    | Average: O[        |</span>
<span class="stringliteral">  |                                                    |   distance(p1, p2)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.clear()                                          | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.find(k)                                          | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.count(k)                                         | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.equal_range(k)                                   | Average: O[        |</span>
<span class="stringliteral">  |                                                    |         a.count(k)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket_count()                                   | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_bucket_count()                               | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket(k)                                        | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket_size(k)                                   | O[a.bucket_size(k)]|</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.load_factor()                                    | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_load_factor()                                | O[1]               |</span>
<span class="stringliteral">  | a.max_load_factor(z)                               | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.rehash(k)                                        | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.reserve(k)                                       | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="iterator,_pointer,_and_reference_invalidation"></a> <a class="anchor" id="description.iterator,_pointer,_and_reference_invalidation"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Iterator, Pointer, and Reference Invalidation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>No method of <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> invalidates a pointer or reference to an element in the set, unless it also erases that element, such as any <code>erase</code> overload, <code>clear</code>, or the destructor (that erases all elements). Pointers and references are stable through a rehash. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Iterators to elements in the container are invalidated by any rehash, so iterators may be invalidated by an <code>insert</code> or <code>emplace</code> call if it triggers a rehash (but not otherwise). Iterators to specific elements are also invalidated when that element is erased. Note that the <code>end</code> iterator is not an iterator referring to any element in the container, so may be invalidated by any non-'const' method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="unordered_map_configuration"></a> <a class="anchor" id="description.unordered_map_configuration"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Unordered Map Configuration: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The unordered map has interfaces that can provide insight into and control of its inner workings. The unordered map is implemented using a hash table (see <a href="group__bslstl__hashtable.html" class="el"><code>bslstl_hashtable</code></a>), a dynamically sized array of "buckets". If two elements hash to the same bucket (termed a "collision"), then that bucket will house multiple elements. As elements are added to the unordered map, the number of buckets is increased (and the existing elements redistributed) to keep the average number of elements per bucket (the "loading factor") below the specified maximum (the "maximum load factor", 1 by default). <a href="group__bslstl__unorderedmap.html#example_2~3A_examining_and_setting_unordered_map_configuration" class="el">Example 2: Examining and Setting Unordered Map Configuration</a> illustrates the use of these interfaces. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="practical_requirements_on_hash"></a> <a class="anchor" id="description.practical_requirements_on_hash"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Practical Requirements on HASH: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An important factor in the performance an unordered map (and any of the other unordered containers) is the choice of hash function. In general, one wants the hash function to return uniformly distributed values that can be assigned to buckets (see <a href="group__bslstl__unorderedmap.html#unordered_map_configuration" class="el">Unordered Map Configuration</a>) with few collisions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bsl</code> package provides general purpose, default hash functions for <code>bsl::string</code>, <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, and the arithmetic types (e.g., <code>int</code>); however, custom defined hash functions may do better, especially if one has information about the distribution of keys; there is considerable literature on designing hash functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When a user-defined class is used as a key, hasher must be provided (and equality functor, if equality is not otherwise defined). Two examples, <a href="group__bslstl__unorderedmap.html#example_3" class="el">Example 3</a> and <a href="group__bslstl__unorderedset.html#example_1" class="el"><code>bslstl_unorderedset</code>|Example 1</a>, address this issue by adapting the existing default hash functions for primitive types, an approach that may not always prove adequate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_gathering_document_statistics"></a> <a class="anchor" id="usage.example_1~3A_gathering_document_statistics"></a> <a class="anchor" id="description.usage.example_1~3A_gathering_document_statistics"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.8.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Gathering Document Statistics: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unordered maps are useful in situations when there is no meaningful way to order the key values, when the order of the keys is irrelevant to the problem domain (see <a href="group__bslstl__unorderedmap.html#example_3" class="el">Example 3</a>), and (even if there is a meaningful ordering) the value of ordering the results is outweighed by the higher performance provided by unordered maps (compared to ordered maps). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose one wished to gather statistics on the words appearing in a large set of documents on disk or in a data base. Gathering those statistics is intrusive (as one is competing for access to the documents with the regular users) and must be done as quickly as possible. Moreover, the set of unique words appearing in those documents may be high. The English language has in excess of a million words (albeit many appear infrequently), and, if the documents contain serial numbers, or Social Security numbers, or chemical formulas, etc., then the <code>O[log(n)]</code> insertion time of ordered maps may well be inadequate. The unordered map, having an <code>O[1]</code> typical insertion cost, is a viable alternative. In many problem domains, sorting, if needed, can be done after the data is gathered. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example illustrates the use of <code><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a></code> to gather one simple statistic (counts of unique words) on a single document. To avoid irrelevant details of acquiring the data, several modestly sized documents are stored in static arrays: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">char</span> document0[] =
  <span class="stringliteral">&quot; IN CONGRESS, July 4, 1776.\n&quot;</span>
  <span class="stringliteral">&quot;\n&quot;</span>
  <span class="stringliteral">&quot; The unanimous Declaration of the thirteen united States of America,\n&quot;</span>
  <span class="stringliteral">&quot;\n&quot;</span>
  <span class="stringliteral">&quot; When in the Course of human events, it becomes necessary for one\n&quot;</span>
  <span class="stringliteral">&quot; people to dissolve the political bands which have connected them with\n&quot;</span>
  <span class="stringliteral">&quot; another, and to assume among the powers of the earth, the separate\n&quot;</span>
  <span class="stringliteral">&quot; and equal station to which the Laws of Nature and of Nature&#39;s God\n&quot;</span>
  <span class="stringliteral">&quot; entitle them, a decent respect to the opinions of mankind requires\n&quot;</span>
  <span class="stringliteral">&quot; that they should declare the causes which impel them to the\n&quot;</span>
  <span class="stringliteral">&quot; separation.  We hold these truths to be self-evident, that all men\n&quot;</span>
  <span class="stringliteral">&quot; are created equal, that they are endowed by their Creator with\n&quot;</span>
  <span class="stringliteral">&quot; certain unalienable Rights, that among these are Life, Liberty and\n&quot;</span>
  <span class="stringliteral">&quot; the pursuit of Happiness.--That to secure these rights, Governments\n&quot;</span>
  <span class="stringliteral">&quot; are instituted among Men, deriving their just powers from the consent\n&quot;</span>
  <span class="stringliteral">&quot; of the governed, --That whenever any Form of Government becomes\n&quot;</span>
  ...
  <span class="stringliteral">&quot; States may of right do.  And for the support of this Declaration,\n&quot;</span>
  <span class="stringliteral">&quot; with a firm reliance on the protection of divine Providence, we\n&quot;</span>
  <span class="stringliteral">&quot; mutually pledge to each other our Lives, our Fortunes and our sacred\n&quot;</span>
  <span class="stringliteral">&quot; Honor.\n&quot;</span>;

  <span class="keyword">static</span> <span class="keywordtype">char</span> document1[] =
  <span class="stringliteral">&quot;/The Universal Declaration of Human Rights\n&quot;</span>
  <span class="stringliteral">&quot;/-----------------------------------------\n&quot;</span>
  <span class="stringliteral">&quot;/Preamble\n&quot;</span>
  <span class="stringliteral">&quot;/ - - - -\n&quot;</span>
  <span class="stringliteral">&quot; Whereas recognition of the inherent dignity and of the equal and\n&quot;</span>
  <span class="stringliteral">&quot; inalienable rights of all members of the human family is the\n&quot;</span>
  <span class="stringliteral">&quot; foundation of freedom, justice and peace in the world,\n&quot;</span>
  ...
  <span class="stringliteral">&quot;/Article 30\n&quot;</span>
  <span class="stringliteral">&quot;/ - - - - -\n&quot;</span>
  <span class="stringliteral">&quot; Nothing in this Declaration may be interpreted as implying for any\n&quot;</span>
  <span class="stringliteral">&quot; State, group or person any right to engage in any activity or to\n&quot;</span>
  <span class="stringliteral">&quot; perform any act aimed at the destruction of any of the rights and\n&quot;</span>
  <span class="stringliteral">&quot; freedoms set forth herein.\n&quot;</span>;

  <span class="keyword">static</span> <span class="keywordtype">char</span> document2[] =
  <span class="stringliteral">&quot;/CHARTER OF FUNDAMENTAL RIGHTS OF THE EUROPEAN UNION\n&quot;</span>
  <span class="stringliteral">&quot;/---------------------------------------------------\n&quot;</span>
  <span class="stringliteral">&quot; PREAMBLE\n&quot;</span>
  <span class="stringliteral">&quot;\n&quot;</span>
  <span class="stringliteral">&quot; The peoples of Europe, in creating an ever closer union among them,\n&quot;</span>
  <span class="stringliteral">&quot; are resolved to share a peaceful future based on common values.\n&quot;</span>
  ...
  <span class="stringliteral">&quot;/Article 54\n&quot;</span>
  <span class="stringliteral">&quot;/-  -  -  -\n&quot;</span>
  <span class="stringliteral">&quot; Prohibition of abuse of rights\n&quot;</span>
  <span class="stringliteral">&quot;\n&quot;</span>
  <span class="stringliteral">&quot; Nothing in this Charter shall be interpreted as implying any right to\n&quot;</span>
  <span class="stringliteral">&quot; engage in any activity or to perform any act aimed at the destruction\n&quot;</span>
  <span class="stringliteral">&quot; of any of the rights and freedoms recognized in this Charter or at\n&quot;</span>
  <span class="stringliteral">&quot; their limitation to a greater extent than is provided for herein.\n&quot;</span>;

  <span class="keyword">static</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> documents[] = { document0,
                                      document1,
                                      document2
                                    };
  <span class="keyword">const</span> <span class="keywordtype">int</span>           numDocuments = <span class="keyword">sizeof</span> documents / <span class="keyword">sizeof</span> *documents;
</pre></div><br/>
<br/>
 First, we define an alias to make our code more comprehensible. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1unordered__map.html">bsl::unordered_map&lt;bsl::string, int&gt;</a> WordTally;
</pre></div><br/>
<br/>
 Next, we create an (empty) unordered map to hold our word tallies. The output from the <code>printf</code> statements will be discussed in <a href="group__bslstl__unorderedmap.html#example_2" class="el">Example 2</a>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  WordTally wordTally;

  printf(<span class="stringliteral">&quot;size             %4d initial\n&quot;</span>, wordTally.size());
  printf(<span class="stringliteral">&quot;bucket_count     %4d initial\n&quot;</span>, wordTally.bucket_count());
  printf(<span class="stringliteral">&quot;load_factor      %f  initial\n&quot;</span>, wordTally.load_factor());
  printf(<span class="stringliteral">&quot;max_load_factor  %f  initial\n&quot;</span>, wordTally.max_load_factor());
</pre></div><br/>
<br/>
 Then, we define the set of characters that define word boundaries: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> *delimiters = <span class="stringliteral">&quot; \n\t,:;.()[]?!/&quot;</span>;
</pre></div><br/>
<br/>
 Next, we extract the words from our documents. Note that <code>strtok</code> modifies the document arrays (which were not made <code>const</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For each iteration of the inner loop, that method looks for a map entry matching the given key value. On the first occurrence of a word, the map has no such entry, so one is created with a default value of the mapped value (0, just what we want in this case) and inserted into the map where it is found on any subsequent occurrences of the word. The <code>operator[]</code> method returns a reference providing modifiable access to the mapped value. Here, we apply the <code>++</code> operator to that reference to maintain a tally for the word. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; numDocuments; ++idx) {
      <span class="keywordflow">for</span> (<span class="keywordtype">char</span> *cur = strtok(documents[idx], delimiters);
                 cur;
                 cur = strtok(NULL,     delimiters)) {
          ++wordTally[<a class="code" href="group__bslstl__string.html#gab67de1ebe0184939129507efe5c86bb1">bsl::string</a>(cur)];
      }
  }
</pre></div><br/>
<br/>
 Now that the data has been (quickly) gathered, we can indulge in analysis that is more time consuming. For example, we can define a comparison function, copy the data to another container (e.g., <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>), sort the entries, and determine the 20 most commonly used words in the given documents: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;bsl::string, int&gt;</a> WordTallyEntry;
      <span class="comment">// Assignable equivalent to &#39;WordTally::value_type&#39;.  Note that</span>
      <span class="comment">// &#39;bsl::vector&#39; requires assignable types.</span>

  <span class="keyword">struct </span>WordTallyEntryCompare {
      <span class="keyword">static</span> <span class="keywordtype">bool</span> lessValue(<span class="keyword">const</span> WordTallyEntry&amp; a,
                            <span class="keyword">const</span> WordTallyEntry&amp; b) {
          <span class="keywordflow">return</span> a.second &lt; b.second;
      }
      <span class="keyword">static</span> <span class="keywordtype">bool</span> moreValue(<span class="keyword">const</span> WordTallyEntry&amp; a,
                            <span class="keyword">const</span> WordTallyEntry&amp; b) {
          <span class="keywordflow">return</span> !lessValue(a, b);
      }
  };

  <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;WordTallyEntry&gt;</a> array(wordTally.cbegin(), wordTally.cend());

  assert(20 &lt;= array.size());

  std::partial_sort(array.begin(),
                    array.begin() + 20,
                    array.end(),
                    WordTallyEntryCompare::moreValue);
</pre></div><br/>
<br/>
 Notice that <code>partial_sort</code> suffices here since we seek only the 20 most used words, not a complete distribution of word counts. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, we print the sorted portion of <code>array</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<a class="code" href="group__bslstl__vector.html#ga18f44f5ce10b93d15ea3def898eab913">bsl::vector&lt;WordTallyEntry&gt;::const_iterator</a> cur  = array.begin(),
                                                   end  = cur + 20;
                                                   end != cur; ++cur) {
      printf(<span class="stringliteral">&quot;%-10s %4d\n&quot;</span>, cur-&gt;first.c_str(), cur-&gt;second);
  }
</pre></div><br/>
<br/>
 and standard output shows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  the         463
  -           398
  of          361
  and         349
  to          306
  in          141
  or          106
  right        93
  be           90
  Article      86
  has          79
  a            76
  shall        69
  <span class="keywordflow">for</span>          69
  by           62
  with         50
  Everyone     49
  rights       44
  their        44
  is           43
</pre></div><br/>
<br/>
 Notice that "-" (used as an header underscore in our markup) appears in the word count. That could be eliminated by adding <code>-</code> to the set of delimiters; however, that would partition hyphenated words into separate words. In practice, one defines a "stop list" of common words (e.g., "the", "of", "and", "is") that one does not wish to tally. We could easily and "-" to the stop list. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_examining_and_setting_unordered_map_configuration"></a> <a class="anchor" id="usage.example_2~3A_examining_and_setting_unordered_map_configuration"></a> <a class="anchor" id="description.usage.example_2~3A_examining_and_setting_unordered_map_configuration"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.8.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Examining and Setting Unordered Map Configuration: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to examine (and possibly influence) the performance of an unordered map. The unordered map provides several interfaces that allow us to do so. Several of these were used in <a href="group__bslstl__unorderedmap.html#example_1" class="el">Example 1</a> (code repeated below): <br/>
<br/>
<div class="fragment"><pre class="fragment">  WordTally wordTally;

  printf(<span class="stringliteral">&quot;size             %4d initial\n&quot;</span>, wordTally.size());
  printf(<span class="stringliteral">&quot;bucket_count     %4d initial\n&quot;</span>, wordTally.bucket_count());
  printf(<span class="stringliteral">&quot;load_factor      %f  initial\n&quot;</span>, wordTally.load_factor());
  printf(<span class="stringliteral">&quot;max_load_factor  %f  initial\n&quot;</span>, wordTally.max_load_factor());
</pre></div><br/>
<br/>
 First, we examine the metrics of of this newly created (empty) unordered map: <br/>
<br/>
<div class="fragment"><pre class="fragment">  size                0 initial
  bucket_count        1 initial
  load_factor      0.000000  initial
  max_load_factor  1.000000  initial
</pre></div><br/>
<br/>
 Notice that even when there are no elements (<code>size</code> is 0) there is one bucket. Since there are no elements, the average number of elements per bucket (the <code>load_factor</code> above) must be 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, after <code>wordTally</code> has been loaded, we examine its metrics: <br/>
<br/>
<div class="fragment"><pre class="fragment">  printf(<span class="stringliteral">&quot;size             %4d\n&quot;</span>, wordTally.size());
  printf(<span class="stringliteral">&quot;bucket_count     %4d\n&quot;</span>, wordTally.bucket_count());
  printf(<span class="stringliteral">&quot;load_factor      %f\n&quot;</span>,  wordTally.load_factor());
  printf(<span class="stringliteral">&quot;max_load_factor  %f\n&quot;</span>,  wordTally.max_load_factor());
</pre></div><br/>
<br/>
 and find at standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  size             1504
  bucket_count     2099
  load_factor      0.716532
  max_load_factor  1.000000
</pre></div><br/>
<br/>
 Notice how the number of buckets has increased. (Sampling this metric as the map was loaded would show that the increase was done in several stages.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we see that the load factor is indeed below the specified maximum; however we obtain further details of how the buckets are used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using the <code>bucket_count</code> method, the unordered map's interface for the number of elements in each bucket, we can easily determine the bucket with the greatest number of elements (i.e., the greatest number of collisions): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> bucketSizes;
  bucketSizes.<a class="code" href="group__bslstl__vector.html#gac931be06971aedc190c1191a00ee251a">reserve</a>(wordTally.bucket_count());

  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> idx = 0; idx &lt; wordTally.bucket_count(); ++idx) {
     bucketSizes.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(static_cast&lt;int&gt;(wordTally.bucket_size(idx)));
  }

  assert(0 &lt; bucketSizes.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());
  <span class="keywordtype">int</span> maxBucketSize = *std::max_element(bucketSizes.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>(),
                                        bucketSizes.<a class="code" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a>());
  printf(<span class="stringliteral">&quot;maxBucketSize    %4d\n&quot;</span>, maxBucketSize);
</pre></div><br/>
<br/>
 and find on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  maxBucketSize       5
</pre></div><br/>
<br/>
 We can also count the number of empty buckets, and the number of buckets at <code>maxBucketSize</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> numEmptyBuckets = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::count(bucketSizes.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>(),
                                                    bucketSizes.<a class="code" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a>(),
                                                    0));
  printf(<span class="stringliteral">&quot;numEmptyBuckets  %4d\n&quot;</span>, numEmptyBuckets);

  <span class="keywordtype">int</span> numMaxBuckets = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::count(bucketSizes.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>(),
                                                  bucketSizes.<a class="code" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a>(),
                                                  maxBucketSize));
  printf(<span class="stringliteral">&quot;numMaxBuckets    %4d\n&quot;</span>, numMaxBuckets);
</pre></div><br/>
<br/>
 which shows on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  numEmptyBuckets  1031
  numMaxBuckets       3
</pre></div><br/>
<br/>
 Suppose we are not satisfied with this distribution. (Perhaps the load factor is too high.) We can create a second, differently configured table. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, create a new table <code>wordTally2</code> with twice the bucket count shown by the first table (<code>wordTally</code>), and examine its initial metrics. <br/>
<br/>
<div class="fragment"><pre class="fragment">  WordTally wordTally2(wordTally.bucket_count() * 2);

  printf(<span class="stringliteral">&quot;size2            %4d initial\n&quot;</span>, wordTally2.size());
  printf(<span class="stringliteral">&quot;bucket_count2    %4d initial\n&quot;</span>, wordTally2.bucket_count());
  printf(<span class="stringliteral">&quot;load_factor2     %f  initial\n&quot;</span>, wordTally2.load_factor());
  printf(<span class="stringliteral">&quot;max_load_factor2 %f  initial\n&quot;</span>, wordTally2.max_load_factor());
</pre></div><br/>
<br/>
 Standard output shows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  size2               0 initial
  bucket_count2    4201 initial
  load_factor2     0.000000  initial
  max_load_factor2 1.000000  initial
</pre></div><br/>
<br/>
 Notice that although we requested 4198 buckets (2 * 2099), we created a table with 4201 buckets. (4201 is the smallest prime number greater than 4198). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we load our new table and examine its metrics. For simplicity, we load data from the first table rather than re-tokenize our documents. <br/>
<br/>
<div class="fragment"><pre class="fragment">  wordTally2 = wordTally;

  printf(<span class="stringliteral">&quot;size2            %4d\n&quot;</span>, wordTally2.size());
  printf(<span class="stringliteral">&quot;bucket_count2    %4d\n&quot;</span>, wordTally2.bucket_count());
  printf(<span class="stringliteral">&quot;load_factor2     %f\n&quot;</span>,  wordTally2.load_factor());
  printf(<span class="stringliteral">&quot;max_load_factor2 %f\n&quot;</span>,  wordTally2.max_load_factor());

  <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> bucketSizes2;
  bucketSizes2.reserve(wordTally2.bucket_count());

  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> idx = 0; idx &lt; wordTally2.bucket_count(); ++idx) {
     bucketSizes2.push_back(static_cast&lt;int&gt;(wordTally2.bucket_size(idx)));
  }

  assert(0 &lt; bucketSizes2.size());
  <span class="keywordtype">int</span> maxBucketSize2 = *std::max_element(bucketSizes2.begin(),
                                         bucketSizes2.end());
  printf(<span class="stringliteral">&quot;maxBucketSize2   %4d\n&quot;</span>, maxBucketSize2);

  <span class="keywordtype">int</span> numEmptyBuckets2 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::count(bucketSizes2.begin(),
                                          bucketSizes2.end(),
                                          0));
  printf(<span class="stringliteral">&quot;numEmptyBuckets2 %4d\n&quot;</span>, numEmptyBuckets2);

  <span class="keywordtype">int</span> numMaxBuckets2 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::count(bucketSizes2.begin(),
                                        bucketSizes2.end(),
                                        maxBucketSize2));
  printf(<span class="stringliteral">&quot;numMaxBuckets2   %4d\n&quot;</span>, numMaxBuckets2);
</pre></div><br/>
<br/>
 Finally, we see on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  size2            1504
  bucket_count2    4201
  load_factor2     0.358010
  max_load_factor2 1.000000
  maxBucketSize2      4
  numEmptyBuckets2 2971
  numMaxBuckets2      5
</pre></div><br/>
<br/>
 Notice that the loading factor has been (roughly) cut in half; we have achieved our goal. Also notice that the bucket count is unchanged since construction; thus, there were no rehashes during the loading this unordered map. Finally, notice that the number of empty (unused) buckets is significantly higher, and there's been a modest decrease in the largest bucket size, but more instances of them. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Thus, the unordered map provides facilities by which we can make trade-offs in performance characteristics of the containers we create. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_inverse_concordance"></a> <a class="anchor" id="usage.example_3~3A_inverse_concordance"></a> <a class="anchor" id="description.usage.example_3~3A_inverse_concordance"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.8.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Inverse Concordance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If one has a concordance for a set of documents (an index of the position of every unique word in those documents), then words of interest can be efficiently located. Suppose after locating a word of interest one also needs the surrounding words (for context). Searching in the original document requires re-tokenization (time consuming). Alternatively, one can use the concordance to create an inverse concordance to provide a fast lookup of the words at given locations in a document and then examine words near the word of interest. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the types required (and convenient aliases) to create an unordered map from a word location to the corresponding word. The "key" value will be <code>WordLocation</code>, a pair of <code>int</code> values: the first being the document code number (arbitrarily assigned), and second the word offset in that document (the first word of the document is at offset 0). The "value" of each entry is a <code>bsl::string</code> containing the word at that location. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;int, int&gt;</a> WordLocation;
      <span class="comment">// Document code number (&#39;first&#39;) and word offset (&#39;second&#39;) in that</span>
      <span class="comment">// document specify a word location.  The first word in the document</span>
      <span class="comment">// is at word offset 0.</span>
</pre></div><br/>
<br/>
 Notice that that <code>WordLocation</code>, the type of the key value, has no natural ordering. The assignment of document codes is arbitrary so there is no reason to consider the words on one document to sort below those in any another. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, since there is no default hash function for the <code>WordLocation</code> type, we define one. The document code and the word offset are individually hashed using the default hasher for the <code>int</code> type and those results bitwise exclusive OR-ed a combined result. This trivial combination formula suffices for this problem, but is <em>not</em> a general solution for combining hashes; see <a href="group__bslstl__unorderedmap.html#practical_requirements_on_hash" class="el">Practical Requirements on <code>HASH</code></a>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>WordLocationHash
  {
    <span class="keyword">private</span>:
      WordLocationHash&amp; operator=(<span class="keyword">const</span> WordLocationHash&amp; rhs);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
<span class="comment"></span>          <span class="comment">// Create a &#39;WordLocationHash&#39; object.</span>

          <span class="comment">// Create a &#39;WordLocationHash&#39; object.  Note that as</span>
          <span class="comment">// &#39;WordLocationHash&#39; is an empty (stateless) type, this operation</span>
          <span class="comment">// has no observable effect.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// ACCESSORS</span>
      std::size_t operator()(WordLocation x) <span class="keyword">const</span>
          <span class="comment">// Return a hash value computed using the specified &#39;x&#39;.</span>
      {
          <a class="code" href="structbsl_1_1hash_3_01int_01_4.html">bsl::hash&lt;int&gt;</a> hasher;
          <span class="keywordflow">return</span> hasher(x.first) ^ hasher(x.second);
      }
  };
</pre></div><br/>
<br/>
 Notice that many of the required methods of the hash type are compiler generated. (The declaration of those methods are commented out and suffixed by an <code>= default</code> comment.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to a hash functor, the unordered map requires an equality comparison functor. In this example, the unordered map uses <code>operator==</code> method of <code>std::pair</code> by default. If the mapped type has no such method, a equality-comparison functor must be provided explicitly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we define the type of the unordered map and associated convenience aliases: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1unordered__map.html">bsl::unordered_map&lt;WordLocation, bsl::string, WordLocationHash&gt;</a>
                                               InverseConcordance;

  <span class="keyword">typedef</span> InverseConcordance::const_iterator   InverseConcordanceConstItr;
</pre></div><br/>
<br/>
 Next, we obtain a concordance for the document set (see <a href="group__bslstl__unorderedmultimap.html#example_1" class="el"><code>bslstl_unorderedmultimap</code>|Example 1</a>). Here, the concordance is provided as a statically initialized array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">struct </span>{
      <span class="keyword">const</span> <span class="keywordtype">char</span> *d_word;
      <span class="keywordtype">int</span>         d_documentCode;
      <span class="keywordtype">int</span>         d_wordOffset;
  } concordance[] = {
      { <span class="stringliteral">&quot;extent&quot;</span>,             2,  3597 }, { <span class="stringliteral">&quot;to&quot;</span>,                 2,  1225 },
      ...
      { <span class="stringliteral">&quot;to&quot;</span>,                 2,  1252 }, { <span class="stringliteral">&quot;Every&quot;</span>,              2,  1049 }
  };
  <span class="keyword">const</span> <span class="keywordtype">int</span> numConcordance = <span class="keyword">sizeof</span> concordance/<span class="keyword">sizeof</span> *concordance;
</pre></div><br/>
<br/>
 Then, we create <code>inverseConcordance</code>, an unordered map, and initialize it with values obtained from <code>concordance</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  InverseConcordance inverseConcordance;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; numConcordance; ++idx) {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> word         = concordance[idx].d_word;
      <span class="keywordtype">int</span>         documentCode = concordance[idx].d_documentCode;
      <span class="keywordtype">int</span>         wordOffset   = concordance[idx].d_wordOffset;

      WordLocation                   location(documentCode, wordOffset);
      InverseConcordance::value_type value(location, word);
      <span class="keywordtype">bool</span>                           status =
                                     inverseConcordance.insert(value).second;
      assert(status);
  }
</pre></div><br/>
<br/>
 Notice that we expect every <code>insert</code> to be successful, as the concordance should not show more than one word at any location. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, suppose we knew the location of the word "unalienable" in the document set (see <a href="group__bslstl__unorderedmultimap.html#example_1" class="el"><code>bslstl_unorderedmultimap</code>|Example 1</a>) and want to know its context? <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot;unalienable&quot;</span>,  0,  109
</pre></div><br/>
<br/>
 We use the <code>find</code> method of <code>inverseConcordance</code> to determine the words within offset <code>delta</code> of "unalienable". Note that we must check the validity of the returned iterator, in case we probe beyond the boundaries of the document. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">int</span> docCode =   0;
  <span class="keyword">const</span> <span class="keywordtype">int</span> origin  = 109;
  <span class="keyword">const</span> <span class="keywordtype">int</span> delta   =  16;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> offset = origin - delta; offset &lt; origin + delta; ++offset) {
      WordLocation               location(docCode, offset);
      InverseConcordanceConstItr itr = inverseConcordance.find(location);

      <span class="keywordflow">if</span> (inverseConcordance.end() != itr) {
          printf(<span class="stringliteral">&quot;%d %4d: %s\n&quot;</span>,
                 itr-&gt;first.first,
                 itr-&gt;first.second,
                 itr-&gt;second.c_str());
          assert(origin != offset
              || <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>(<span class="stringliteral">&quot;unalienable&quot;</span>) == itr-&gt;second);
      }
  }
</pre></div><br/>
<br/>
 Notice that the assertion confirms that "unalienable" is found in our inverse location at the location we obtained from the concordance. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, we find on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  0   93: evident
  0   94: that
  0   95: all
  0   96: men
  0   97: are
  0   98: created
  0   99: equal
  0  100: that
  0  101: they
  0  102: are
  0  103: endowed
  0  104: by
  0  105: their
  0  106: Creator
  0  107: with
  0  108: certain
  0  109: unalienable
  0  110: Rights
  0  111: that
  0  112: among
  0  113: these
  0  114: are
  0  115: Life
  0  116: Liberty
  0  117: and
  0  118: the
  0  119: pursuit
  0  120: of
  0  121: Happiness
  0  122: That
  0  123: to
  0  124: secure
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gad4513161635fec170a7ef309a33d9fc9"></a><!-- doxytag: member="bsl::unordered_map::key_type" ref="gad4513161635fec170a7ef309a33d9fc9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::key_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gada3d59d79ebed1da840d4bc073381609"></a><!-- doxytag: member="bsl::unordered_map::mapped_type" ref="gada3d59d79ebed1da840d4bc073381609" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::mapped_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabc706719a0b22874e967feb3d26e33bd"></a><!-- doxytag: member="bsl::unordered_map::value_type" ref="gabc706719a0b22874e967feb3d26e33bd" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;const KEY, VALUE&gt; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7eb1a11e3435ec8e83348a469e7586ef"></a><!-- doxytag: member="bsl::unordered_map::hasher" ref="ga7eb1a11e3435ec8e83348a469e7586ef" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HASH <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::hasher<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga43a3a6e7447ab33468ab2c2445ea531a"></a><!-- doxytag: member="bsl::unordered_map::key_equal" ref="ga43a3a6e7447ab33468ab2c2445ea531a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef EQUAL <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::key_equal<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5f65158aa509fdfb71e2b0706837c8c0"></a><!-- doxytag: member="bsl::unordered_map::allocator_type" ref="ga5f65158aa509fdfb71e2b0706837c8c0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab82f42c50a8ae07add49c554b900094a"></a><!-- doxytag: member="bsl::unordered_map::reference" ref="gab82f42c50a8ae07add49c554b900094a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::reference <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4ce6b350c2f6ef7249fa9432926216a0"></a><!-- doxytag: member="bsl::unordered_map::const_reference" ref="ga4ce6b350c2f6ef7249fa9432926216a0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::const_reference <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1b9b01db4da527cf4fd2df3f9775b948"></a><!-- doxytag: member="bsl::unordered_map::size_type" ref="ga1b9b01db4da527cf4fd2df3f9775b948" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabc0dd2d5cb53e0fede397117d470fb24"></a><!-- doxytag: member="bsl::unordered_map::difference_type" ref="gabc0dd2d5cb53e0fede397117d470fb24" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::difference_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2c7a7b4b41d5eb42e33488ca4528a4ba"></a><!-- doxytag: member="bsl::unordered_map::pointer" ref="ga2c7a7b4b41d5eb42e33488ca4528a4ba" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::pointer <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga489e4df0f652e594c4de7d228f5b06e7"></a><!-- doxytag: member="bsl::unordered_map::const_pointer" ref="ga489e4df0f652e594c4de7d228f5b06e7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::const_pointer <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab7f84c5ccadac45c3d7ae9dfc2eb7fa6"></a><!-- doxytag: member="bsl::unordered_map::iterator" ref="gab7f84c5ccadac45c3d7ae9dfc2eb7fa6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf99fdff6c051caf748820608a2927eaa"></a><!-- doxytag: member="bsl::unordered_map::const_iterator" ref="gaf99fdff6c051caf748820608a2927eaa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; const value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga82801babe6317665185a546a885748f2"></a><!-- doxytag: member="bsl::unordered_map::local_iterator" ref="ga82801babe6317665185a546a885748f2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::HashTableBucketIterator&lt; value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::local_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaacf3888883fdae79e5503c655f872939"></a><!-- doxytag: member="bsl::unordered_map::const_local_iterator" ref="gaacf3888883fdae79e5503c655f872939" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::HashTableBucketIterator&lt; const value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::const_local_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadcbddf5695e5cf931abdd7643578e813"></a><!-- doxytag: member="bsl::unordered_map::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="gadcbddf5695e5cf931abdd7643578e813" args="(unordered_map,::BloombergLP::bslmf::IsBitwiseMoveable,::BloombergLP::bslmf::IsBitwiseMoveable&lt; HashTable &gt;::value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::BloombergLP::bslmf::IsBitwiseMoveable&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::BloombergLP::bslmf::IsBitwiseMoveable&lt; HashTable &gt;::value&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf27f657a125c484b93854cf690cbbb14"></a><!-- doxytag: member="bsl::unordered_map::unordered_map" ref="gaf27f657a125c484b93854cf690cbbb14" args="(size_type initialNumBuckets=0, const hasher &amp;hashFunction=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;basicAllocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>initialNumBuckets</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#ga7eb1a11e3435ec8e83348a469e7586ef">hasher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hashFunction</em> = <code><a class="el" href="group__bslstl__unorderedmap.html#ga7eb1a11e3435ec8e83348a469e7586ef">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#ga43a3a6e7447ab33468ab2c2445ea531a">key_equal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyEqual</em> = <code><a class="el" href="group__bslstl__unorderedmap.html#ga43a3a6e7447ab33468ab2c2445ea531a">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#ga5f65158aa509fdfb71e2b0706837c8c0">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code><a class="el" href="group__bslstl__unorderedmap.html#ga5f65158aa509fdfb71e2b0706837c8c0">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty unordered map having a <code>max_load_factor</code> of 1.0. Optionally specify an <code>initialNumBuckets</code> indicating the minimum initial size of the array of buckets of this unordered map. If <code>initialNumBuckets</code> is not supplied, one empty bucket shall be used and no memory allocated. Optionally specify a <code>hashFunction</code> used to generate the hash values associated with the key-value pairs contained in this unordered map. If <code>hashFunction</code> is not supplied, a default-constructed object of type <code>hasher</code> is used. Optionally specify a key-equality functor <code>keyEqual</code> used to determine whether two keys have the same value. If <code>keyEqual</code> is not supplied, a default-constructed object of type <code>key_equal</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>allocator_type</code> is used. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator is used to supply memory. Note that more than <code>initialNumBuckets</code> buckets may be created in order to preserve the bucket allocation strategy of the hash-table (but never fewer). </p>

</div>
</div>
<a class="anchor" id="ga36efb673a10ad2675a528c20f5752889"></a><!-- doxytag: member="bsl::unordered_map::unordered_map" ref="ga36efb673a10ad2675a528c20f5752889" args="(const allocator_type &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#ga5f65158aa509fdfb71e2b0706837c8c0">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty unordered map, having a <code>max_load_factor</code> of 1.0, that uses the specified <code>basicAllocator</code> to supply memory. Use a default-constructed object of type <code>hasher</code> to generate hash values for the key-value pairs contained in this unordered map, and use a default-constructed object of type <code>key_equal</code> to determine whether two keys have the same value. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="gab168e1533fc4fe84467005fce9cfbfae"></a><!-- doxytag: member="bsl::unordered_map::unordered_map" ref="gab168e1533fc4fe84467005fce9cfbfae" args="(const unordered_map &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an unordered map having the same value, hasher, key-equality comparator, and <code>max_load_factor</code> as the specified <code>original</code>. Use the allocator returned by 'bslallocator_traits&lt;allocator_type&gt;:: select_on_container_copy_construction(original.get_allocator())' to supply memory. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), the currently installed default allocator is used to supply memory. </p>

</div>
</div>
<a class="anchor" id="ga4729034576bdd8365aed6aadc3b19155"></a><!-- doxytag: member="bsl::unordered_map::unordered_map" ref="ga4729034576bdd8365aed6aadc3b19155" args="(const unordered_map &amp;original, const allocator_type &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#ga5f65158aa509fdfb71e2b0706837c8c0">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an unordered map having the same value, hasher, key-equality comparator, and <code>max_load_factor</code> as the specified <code>original</code>, and using the specified <code>basicAllocator</code> to supply memory. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="ga4009ed91ded563b220e32d5d09084a11"></a><!-- doxytag: member="bsl::unordered_map::unordered_map" ref="ga4009ed91ded563b220e32d5d09084a11" args="(INPUT_ITERATOR first, INPUT_ITERATOR last, size_type initialNumBuckets=0, const hasher &amp;hashFunction=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;basicAllocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_map </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>initialNumBuckets</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#ga7eb1a11e3435ec8e83348a469e7586ef">hasher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hashFunction</em> = <code><a class="el" href="group__bslstl__unorderedmap.html#ga7eb1a11e3435ec8e83348a469e7586ef">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#ga43a3a6e7447ab33468ab2c2445ea531a">key_equal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyEqual</em> = <code><a class="el" href="group__bslstl__unorderedmap.html#ga43a3a6e7447ab33468ab2c2445ea531a">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#ga5f65158aa509fdfb71e2b0706837c8c0">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code><a class="el" href="group__bslstl__unorderedmap.html#ga5f65158aa509fdfb71e2b0706837c8c0">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty unordered map, having a <code>max_load_factor</code> of 1.0, and then create a <code>value_type</code> object for each iterator in the range starting at the specified <code>first</code> iterator and ending immediately before the specified <code>last</code> iterator, by converting from the object referred to by each iterator. Insert into this unordered map each such object, ignoring those having a key that appears earlier in the sequence. Optionally specify a minimum <code>initialNumBuckets</code> indicating the minimum initial size of the array of buckets of this unordered map. If <code>initialNumBuckets</code> is not supplied, and <code>first</code> and <code>last</code> denote an empty range, a single empty bucket shall be supplied. Optionally specify a <code>hashFunction</code> used to generate hash values associated with the key-value pairs contained in this unordered map. If <code>hashFunction</code> is not supplied, a default-constructed object of type <code>hasher</code> is used. Optionally specify a key-equality functor <code>keyEqual</code> used to verify that two key values are the same. If <code>keyEqual</code> is not supplied, a default-constructed object of type <code>key_equal</code> is used. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>allocator_type</code> is used. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator is used to supply memory. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that more than <code>initialNumBuckets</code> buckets may be created in order to preserve the bucket allocation strategy of the hash-table (but never fewer). </p>

</div>
</div>
<a class="anchor" id="ga120f9570ad70b4b0a5582de1a329814b"></a><!-- doxytag: member="bsl::unordered_map::~unordered_map" ref="ga120f9570ad70b4b0a5582de1a329814b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::~unordered_map </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object and each of its elements. </p>

</div>
</div>
<a class="anchor" id="ga010b0fbb7737d2e3a902daacda105193"></a><!-- doxytag: member="bsl::unordered_map::operator=" ref="ga010b0fbb7737d2e3a902daacda105193" args="(const unordered_map &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&amp; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value, hasher, key-equality functor, and <code>max_load_factor</code> of the specified <code>rhs</code> object, propagate to this object the allocator of <code>rhs</code> if <code>allocator_type</code> has trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaccd7c401c9b8e8a23ae73b1702641181"></a><!-- doxytag: member="bsl::unordered_map::operator[]" ref="gaccd7c401c9b8e8a23ae73b1702641181" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mapped_type&amp; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the mapped-value associated with the specified <code>key</code> in this unordered map; if this unordered map does not already contain a <code>value_type</code> object with <code>key</code>, first insert a new <code>value_type</code> object having <code>key</code> and a default-constructed <code>VALUE</code> object. Note that this method requires that the (template parameter) type <code>KEY</code> is "copy-constructible" and the (template parameter) <code>VALUE</code> is <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value.default-constructible" class="glossary">default-constructible</a> (see <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaab4872ccedf3d7fcd15064d9858ee0c3"></a><!-- doxytag: member="bsl::unordered_map::at" ref="gaab4872ccedf3d7fcd15064d9858ee0c3" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mapped_type&amp; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the mapped-value associated with the specified <code>key</code>, if such an entry exists; otherwise throw a <code>std::out_of_range</code> exception. Note that this method is not exception-neutral. </p>

</div>
</div>
<a class="anchor" id="ga155bac80f132c04d956f4ccb5143a7cb"></a><!-- doxytag: member="bsl::unordered_map::begin" ref="ga155bac80f132c04d956f4ccb5143a7cb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object in the sequence of <code>value_type</code> objects maintained by this unordered map, or the <code>end</code> iterator if this unordered map is empty. </p>

</div>
</div>
<a class="anchor" id="ga8ca8efee2ae369c4972442105213c5cf"></a><!-- doxytag: member="bsl::unordered_map::end" ref="ga8ca8efee2ae369c4972442105213c5cf" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the past-the-end element in the sequence of <code>value_type</code> objects maintained by this unordered map. </p>

</div>
</div>
<a class="anchor" id="gad125de130d7ec49f9af4eecf3d40d503"></a><!-- doxytag: member="bsl::unordered_map::begin" ref="gad125de130d7ec49f9af4eecf3d40d503" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">local_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing modifiable access to the first <code>value_type</code> object in the sequence of <code>value_type</code> objects of the bucket having the specified <code>index</code> in the array of buckets maintained by this unordered map, or the <code>end(index)</code> iterator if the bucket is empty. The behavior is undefined unless 'index &lt; bucket_count()'. </p>

</div>
</div>
<a class="anchor" id="ga3040ab1ffec86576f552c7c652fec2df"></a><!-- doxytag: member="bsl::unordered_map::end" ref="ga3040ab1ffec86576f552c7c652fec2df" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">local_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing modifiable access to the past-the-end element in the sequence of <code>value_type</code> objects of the bucket having the specified <code>index</code> in the array of buckets maintained by this unordered map. The behavior is undefined unless <code>index &lt; bucket_count()</code>. </p>

</div>
</div>
<a class="anchor" id="gaf03bb87d2c6946aaa057cae588eecc23"></a><!-- doxytag: member="bsl::unordered_map::clear" ref="gaf03bb87d2c6946aaa057cae588eecc23" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all entries from this unordered map. Note that this unordered map will be empty after calling this method, but allocated memory may be retained for future use. </p>

</div>
</div>
<a class="anchor" id="gad08067070f04b73fb044a38a9ef32606"></a><!-- doxytag: member="bsl::unordered_map::erase" ref="gad08067070f04b73fb044a38a9ef32606" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this unordered map the <code>value_type</code> object at the specified <code>position</code>, and return an iterator referring to the element immediately following the removed element, or to the past-the-end position if the removed element was the last element in the sequence of elements maintained by this unordered map. The behavior is undefined unless <code>position</code> refers to a <code>value_type</code> object in this unordered map. </p>

</div>
</div>
<a class="anchor" id="gae0c463ce68ccc8acbdec5952c9df4337"></a><!-- doxytag: member="bsl::unordered_map::erase" ref="gae0c463ce68ccc8acbdec5952c9df4337" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this unordered map the <code>value_type</code> object having the specified <code>key</code>, if it exists, and return 1; otherwise (there is no <code>value_type</code> object having <code>key</code> in this unordered map) return 0 with no other effect. </p>

</div>
</div>
<a class="anchor" id="ga7bf4fe159278cb729be06c68ee4c5b74"></a><!-- doxytag: member="bsl::unordered_map::erase" ref="ga7bf4fe159278cb729be06c68ee4c5b74" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this unordered map the <code>value_type</code> objects starting at the specified <code>first</code> position up to, but not including, the specified <code>last</code> position, and return <code>last</code>. The behavior is undefined unless <code>first</code> and <code>last</code> either refer to elements in this unordered map or are both the <code>end</code> iterator, and the <code>first</code> position is at or before the <code>last</code> position in the iteration sequence provided by this container. </p>

</div>
</div>
<a class="anchor" id="ga3718f60f68a27eea701607154f59ecda"></a><!-- doxytag: member="bsl::unordered_map::find" ref="ga3718f60f68a27eea701607154f59ecda" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the <code>value_type</code> object in this unordered map having the specified <code>key</code>, if such an entry exists, and the past-the-end iterator (<code>end</code>) otherwise. </p>

</div>
</div>
<a class="anchor" id="ga8b05e4716e90a9341d20bf1e755d84d5"></a><!-- doxytag: member="bsl::unordered_map::insert" ref="ga8b05e4716e90a9341d20bf1e755d84d5" args="(const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;iterator, bool&gt; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this unordered map if the key (the <code>first</code> element) of a <code>value_type</code> object constructed from <code>value</code> does not already exist in this unordered map; otherwise, this method has no effect (a <code>value_type</code> object having the same key as the converted <code>value</code> already exists in this unordered map) . Return a <code>pair</code> whose <code>first</code> member is an iterator referring to the (possibly newly inserted) <code>value_type</code> object in this unordered map whose key is the same as that of <code>value</code>, and whose <code>second</code> member is <code>true</code> if a new value was inserted, and <code>false</code> if the value was already present. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). Also note that this one template stands in for two <code>insert</code> functions in the C++11 standard. </p>

</div>
</div>
<a class="anchor" id="gac1e89f8b96b1242de7320a3ab83d7ff1"></a><!-- doxytag: member="bsl::unordered_map::insert" ref="gac1e89f8b96b1242de7320a3ab83d7ff1" args="(const_iterator hint, const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this unordered map if the key (the <code>first</code> element) of a <code>value_type</code> object constructed from <code>value</code> does not already exist in this unordered map. Return an iterator referring to the (possibly newly inserted) <code>value_type</code> object in this unordered map whose key is the same as that of the converted <code>value</code>. The behavior is undefined unless the specified <code>hint</code> is a valid iterator into this unordered map. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). Also note that <code>hint</code> is not used by this method template, and this one template stands in for two <code>insert</code> functions in the C++11 standard. </p>

</div>
</div>
<a class="anchor" id="ga5d690ff198892fca1fd6b6d6a2d87aa2"></a><!-- doxytag: member="bsl::unordered_map::insert" ref="ga5d690ff198892fca1fd6b6d6a2d87aa2" args="(INPUT_ITERATOR first, INPUT_ITERATOR last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>value_type</code> object for each iterator in the range starting at the specified <code>first</code> iterator and ending immediately before the specified <code>last</code> iterator, by converting from the object referred to by each iterator. Insert into this unordered map each such object whose key is not already contained. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga462413dd9ce4314005bc81ef2abbfcb4"></a><!-- doxytag: member="bsl::unordered_map::equal_range" ref="ga462413dd9ce4314005bc81ef2abbfcb4" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;iterator, iterator&gt; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing modifiable access to the sequence of <code>value_type</code> objects in this unordered map having the specified <code>key</code>, where the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. If this unordered map contains no <code>value_type</code> object having <code>key</code>, then the two returned iterators will have the same value, <code>end()</code>. Note that since an unordered map maintains unique keys, the range will contain at most one element. </p>

</div>
</div>
<a class="anchor" id="ga4ffa659ba3bcf9e0e670d24b4edfa855"></a><!-- doxytag: member="bsl::unordered_map::max_load_factor" ref="ga4ffa659ba3bcf9e0e670d24b4edfa855" args="(float newMaxLoadFactor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newMaxLoadFactor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the maximum load factor of this unordered map to the specified <code>newMaxLoadFactor</code>. If <code>newMaxLoadFactor &lt; loadFactor()</code>, this operator require an immediate rehash; otherwise, it has a constant-time cost. The behavior is undefined unless '0 &lt; newMaxLoadFactor'. Note that the C++11 standard does not allow this operation to rehash, as it requires a constant cost for all (positive) values of <code>newMaxLoadFactor</code>. </p>

</div>
</div>
<a class="anchor" id="ga71fcbb1773d9c3bcb550f269c6dfc73e"></a><!-- doxytag: member="bsl::unordered_map::rehash" ref="ga71fcbb1773d9c3bcb550f269c6dfc73e" args="(size_type numBuckets)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numBuckets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the size of the array of buckets maintained by this unordered map to at least the specified <code>numBuckets</code>, and redistribute all the contained elements into the new sequence of buckets, according to their hash values. After this call, <code>load_factor</code> will be less than or equal to <code>max_load_factor</code>. This operation has no effect if rehashing the elements into <code>numBuckets</code> would cause this map to exceed its <code>max_load_factor</code>. </p>

</div>
</div>
<a class="anchor" id="ga868c8da7b11922a9575ff3ef3bedddc4"></a><!-- doxytag: member="bsl::unordered_map::reserve" ref="ga868c8da7b11922a9575ff3ef3bedddc4" args="(size_type numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increase the number of buckets of this set to a quantity such that the ratio between the specified <code>numElements</code> and this quantity does not exceed <code>max_load_factor</code>. Note that this guarantees that, after the reserve, elements can be inserted to grow the container to <code><a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a> == numElements</code> without rehashing. Also note that memory allocations may still occur when growing the container to 'size() == numElements'. Also note that this operation has no effect if <code>numElements &lt;= <a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gafb1f028665d51b997b1b9afb5255193d"></a><!-- doxytag: member="bsl::unordered_map::swap" ref="gafb1f028665d51b997b1b9afb5255193d" args="(unordered_map &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object as well as its hasher, key-equality functor, and <code>max_load_factor</code> with those of the specified <code>other</code> object. If <code>allocator_type</code> has the trait <code>propagate_on_container_swap</code>, exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees <code>O[1]</code> complexity, as long as the (template parameter) <code>HASH</code> and (template parameter) <code>EQUAL</code> do not throw when swapped. The behavior is undefined unless either this object was created with the same allocator as <code>other</code> or <code>allocator_type</code> has the <code>propagate_on_container_swap</code> trait. </p>

</div>
</div>
<a class="anchor" id="gafa30c525e6105241458628f9005c5c5b"></a><!-- doxytag: member="bsl::unordered_map::at" ref="gafa30c525e6105241458628f9005c5c5b" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const mapped_type&amp; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the mapped-value associated with the specified <code>key</code>, if such an entry exists; otherwise throw a <code>std::out_of_range</code> exception. Note that this method is not exception-neutral. </p>

</div>
</div>
<a class="anchor" id="ga9036b6a7ae8e85eac7322086d62a4577"></a><!-- doxytag: member="bsl::unordered_map::begin" ref="ga9036b6a7ae8e85eac7322086d62a4577" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf0f51a20ee138b2b86b59a239c8c3e7a"></a><!-- doxytag: member="bsl::unordered_map::cbegin" ref="gaf0f51a20ee138b2b86b59a239c8c3e7a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the sequence of <code>value_type</code> objects maintained by this unordered map, or the <code>end</code> iterator if this unordered map is empty. </p>

</div>
</div>
<a class="anchor" id="ga7d33dc1ff7cf4398a21eff735d75f600"></a><!-- doxytag: member="bsl::unordered_map::end" ref="ga7d33dc1ff7cf4398a21eff735d75f600" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae19ec5a71a5c5af0a07252e1ad7c6822"></a><!-- doxytag: member="bsl::unordered_map::cend" ref="gae19ec5a71a5c5af0a07252e1ad7c6822" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the sequence of <code>value_type</code> objects maintained by this unordered map. </p>

</div>
</div>
<a class="anchor" id="ga3d8032da1052300c73bf1c0b03c496d5"></a><!-- doxytag: member="bsl::unordered_map::begin" ref="ga3d8032da1052300c73bf1c0b03c496d5" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9b590484edcfb5f70b3da604b3e55b64"></a><!-- doxytag: member="bsl::unordered_map::cbegin" ref="ga9b590484edcfb5f70b3da604b3e55b64" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing non-modifiable access to the first <code>value_type</code> object in the sequence of <code>value_type</code> objects of the bucket having the specified <code>index</code> in the array of buckets maintained by this unordered map, or the <code>end(index)</code> iterator if the bucket is empty. The behavior is undefined unless <code>index &lt; bucket_count()</code>. </p>

</div>
</div>
<a class="anchor" id="ga6677150da9d57ca1d7f6d9fefbaa2de7"></a><!-- doxytag: member="bsl::unordered_map::end" ref="ga6677150da9d57ca1d7f6d9fefbaa2de7" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0a2155283876261fb11074ad92ec9b02"></a><!-- doxytag: member="bsl::unordered_map::cend" ref="ga0a2155283876261fb11074ad92ec9b02" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing non-modifiable access to the past-the-end element in the sequence of <code>value_type</code> objects of the bucket having the specified <code>index</code> in the array of buckets maintained by this unordered map. The behavior is undefined unless <code>index &lt; bucket_count()</code>. </p>

</div>
</div>
<a class="anchor" id="gaf8fdbb44c934a90020542bdcc121701b"></a><!-- doxytag: member="bsl::unordered_map::bucket" ref="gaf8fdbb44c934a90020542bdcc121701b" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the bucket, in the array of buckets maintained by this unordered map, where values having the specified <code>key</code> would be inserted. </p>

</div>
</div>
<a class="anchor" id="ga68bcc778cab7a6716388c63d5abc96a8"></a><!-- doxytag: member="bsl::unordered_map::bucket_count" ref="ga68bcc778cab7a6716388c63d5abc96a8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of buckets in the array of buckets maintained by this unordered map. </p>

</div>
</div>
<a class="anchor" id="gab0fcfc7ff734b03bc67433c4d1c0dac1"></a><!-- doxytag: member="bsl::unordered_map::max_bucket_count" ref="gab0fcfc7ff734b03bc67433c4d1c0dac1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of buckets that this unordered map could possibly manage. Note that there is no guarantee that the unordered map can successfully grow to the returned size, or even close to that size, without running out of resources. </p>

</div>
</div>
<a class="anchor" id="gad2e54ac291fa8c25374e2289b60d1574"></a><!-- doxytag: member="bsl::unordered_map::bucket_size" ref="gad2e54ac291fa8c25374e2289b60d1574" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmap.html#ga1b9b01db4da527cf4fd2df3f9775b948">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements contained in the bucket at the specified <code>index</code> in the array of buckets maintained by this unordered map. The behavior is undefined unless <code>index &lt; bucket_count()</code>. </p>

</div>
</div>
<a class="anchor" id="ga6d72213f6bf2c16da92876c175f7af9d"></a><!-- doxytag: member="bsl::unordered_map::count" ref="ga6d72213f6bf2c16da92876c175f7af9d" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of <code>value_type</code> objects contained within this unordered map having the specified <code>key</code>. Note that since an unordered map maintains unique keys, the returned value will be either 0 or 1. </p>

</div>
</div>
<a class="anchor" id="gad6eba26d1fc10e33804255f0a5a466b4"></a><!-- doxytag: member="bsl::unordered_map::empty" ref="gad6eba26d1fc10e33804255f0a5a466b4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this unordered map contains no elements, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gadc28b39e9462374c7bed039bf2eb2b67"></a><!-- doxytag: member="bsl::unordered_map::equal_range" ref="gadc28b39e9462374c7bed039bf2eb2b67" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing non-modifiable access to the sequence of <code>value_type</code> objects in this unordered map having the specified <code>key</code>, where the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. If this unordered map contains no <code>value_type</code> object having <code>key</code>, then the two returned iterators will have the same value, <code>end()</code>. Note that since an unordered map maintains unique keys, the range will contain at most one element. </p>

</div>
</div>
<a class="anchor" id="gafa1ae679704e0ffe457a6ee2e5a271a3"></a><!-- doxytag: member="bsl::unordered_map::find" ref="gafa1ae679704e0ffe457a6ee2e5a271a3" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmap.html#gad4513161635fec170a7ef309a33d9fc9">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the <code>value_type</code> object in this unordered map having the specified <code>key</code>, if such an entry exists, and the past-the-end iterator (<code>end</code>) otherwise. </p>

</div>
</div>
<a class="anchor" id="ga0cd74075299dfe15846063ce244fe275"></a><!-- doxytag: member="bsl::unordered_map::get_allocator" ref="ga0cd74075299dfe15846063ce244fe275" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the allocator used for memory allocation by this unordered map. </p>

</div>
</div>
<a class="anchor" id="ga5721e3e1778a542f6889d93586f47390"></a><!-- doxytag: member="bsl::unordered_map::hash_function" ref="ga5721e3e1778a542f6889d93586f47390" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hasher <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the unary hash functor used by this unordered map to generate a hash value (of type <code>std::size_t</code>) for a <code>key_type</code> object. </p>

</div>
</div>
<a class="anchor" id="ga838d2f6f8ff91da9673be908aff00e28"></a><!-- doxytag: member="bsl::unordered_map::key_eq" ref="ga838d2f6f8ff91da9673be908aff00e28" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">key_equal <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) binary the key-equality functor used by this unordered map that returns <code>true</code> if two <code>key_type</code> objects have the same value, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga61dc1258354e771ea9a5b58476489fe1"></a><!-- doxytag: member="bsl::unordered_map::load_factor" ref="ga61dc1258354e771ea9a5b58476489fe1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current ratio between the <code>size</code> of this unordered map and the number of buckets. The load factor is a measure of how full the container is, and a higher load factor typically leads to an increased number of collisions, thus resulting in a loss of performance. </p>

</div>
</div>
<a class="anchor" id="ga06d036aafd8fae2d48627075bd77ef05"></a><!-- doxytag: member="bsl::unordered_map::max_load_factor" ref="ga06d036aafd8fae2d48627075bd77ef05" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum load factor allowed for this unordered map. Note that if an insert operation would cause the load factor to exceed the <code>max_load_factor</code>, that same insert operation will increase the number of buckets and rehash the elements of the container into those buckets (see <code>rehash</code>). </p>

</div>
</div>
<a class="anchor" id="ga5e74c56229155ada463d2ddbf4b6e86e"></a><!-- doxytag: member="bsl::unordered_map::size" ref="ga5e74c56229155ada463d2ddbf4b6e86e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this unordered map. </p>

</div>
</div>
<a class="anchor" id="gaa33c259b435a3be3bbe2e46289b1c575"></a><!-- doxytag: member="bsl::unordered_map::max_size" ref="gaa33c259b435a3be3bbe2e46289b1c575" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that this unordered map could possibly hold. Note that there is no guarantee that the unordered map can successfully grow to the returned size, or even close to that size, without running out of resources. </p>

</div>
</div>
<a class="anchor" id="ga0c4f54461a359b055782b5a6a3bcb14c"></a><!-- doxytag: member="bsl::operator==" ref="ga0c4f54461a359b055782b5a6a3bcb14c" args="(const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> objects have the same value if they have the same number of key-value pairs, and for each key-value pair that is contained in <code>lhs</code> there is a key-value pair contained in <code>rhs</code> having the same value, and vice versa. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga631ea915746fe2b1f2664f2b2306d4d2"></a><!-- doxytag: member="bsl::operator!=" ref="ga631ea915746fe2b1f2664f2b2306d4d2" args="(const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a></code> objects do not have the same value if they do not have the same number of key-value pairs, or for some key-value pair that is contained in <code>lhs</code> there is not a key-value pair in <code>rhs</code> having the same value or vice-versa. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__unorderedmap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga2c1a5c101ec75196e300c49d54a40833"></a><!-- doxytag: member="bsl::swap" ref="ga2c1a5c101ec75196e300c49d54a40833" args="(unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;a, unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value, the hasher, the key-equality functor, and the <code>max_load_factor</code> of the specified <code>a</code> object with those of the specified <code>b</code> object. If the (template parameter) type <code>ALLOCATOR</code> has the trait <code>propagate_on_container_swap</code>, exchange the allocator of <code>a</code> with that of <code>b</code>, and do not modify either allocator otherwise. This function provides the no-throw exception-safety guarantee and guarantees <code>O[1]</code> complexity, as long as the (template parameter) type <code>HASH</code> and the (template parameter) type <code>EQUAL</code> do not throw when swapped. The behavior is undefined unless <code>a</code> and <code>b</code> were created with the same allocator, or <code>ALLOCATOR</code> has the <code>propagate_on_container_swap</code> trait. </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="gab59720c8d1e7fadca1e1cfad48327513"></a><!-- doxytag: member="bsl::unordered_map::operator==" ref="gab59720c8d1e7fadca1e1cfad48327513" args="(const unordered_map&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_map&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class KEY2 , class VALUE2 , class HASH2 , class EQUAL2 , class ALLOCATOR2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__map.html">unordered_map</a>&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:59 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
