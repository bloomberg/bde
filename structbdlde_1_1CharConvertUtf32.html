<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct bdlde::CharConvertUtf32</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlde.html">bdlde</a>      </li>
      <li><a class="el" href="structbdlde_1_1CharConvertUtf32.html">bdlde::CharConvertUtf32</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlde::CharConvertUtf32 Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlde::CharConvertUtf32" -->
<p><code>#include &lt;<a class="el" href="bdlde__charconvertutf32_8h_source.html">bdlde_charconvertutf32.h</a>&gt;</code></p>

<p><a href="structbdlde_1_1CharConvertUtf32-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf32.html#adc778190d3b66cb84d345256e6773423">utf8ToUtf32</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned int &gt; *dstVector, const char *srcString, unsigned int errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf32.html#a7319ca6524a425e684dc025c132aa7aa">utf8ToUtf32</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned int &gt; *dstVector, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, unsigned int errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf32.html#ad65cda8e52d916b8ffe7a2ed01c1e3f9">utf8ToUtf32</a> (unsigned int *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCodePointsWritten=0, unsigned int errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf32.html#a6538e63213b1283869d3c9f4dd2ad03f">utf8ToUtf32</a> (unsigned int *dstBuffer, bsl::size_t dstCapacity, const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcString, bsl::size_t *numCodePointsWritten=0, unsigned int errorWord= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf32.html#a394463251cee436eb5d2dee89f1175ce">utf32ToUtf8</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *dstString, const unsigned int *srcString, bsl::size_t *numCodePointsWritten=0, unsigned char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf32.html#a3a3e4991a7521cc481c7acbd9c8d09f4">utf32ToUtf8</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *dstVector, const unsigned int *srcString, bsl::size_t *numCodePointsWritten=0, unsigned char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlde_1_1CharConvertUtf32.html#a934abebc02a72ede0668b30b373ccc3a">utf32ToUtf8</a> (char *dstBuffer, bsl::size_t dstCapacity, const unsigned int *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numBytesWritten=0, unsigned char errorByte= '?', <a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a> byteOrder=ByteOrder::e_HOST)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of static functions to convert buffers between UTF-8 and UTF-32. Byte Order Mark (BOM) code points are neither generated nor recognized as special, and thus may be incorrect for the actual byte order of output. If a BOM is present in the input, it will be translated, whether correct (<code>0xfeff</code>) or incorrect (<code>0xfffe</code>), into the output without any special handling. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adc778190d3b66cb84d345256e6773423"></a><!-- doxytag: member="bdlde::CharConvertUtf32::utf8ToUtf32" ref="adc778190d3b66cb84d345256e6773423" args="(bsl::vector&lt; unsigned int &gt; *dstVector, const char *srcString, unsigned int errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf32::utf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned int &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7319ca6524a425e684dc025c132aa7aa"></a><!-- doxytag: member="bdlde::CharConvertUtf32::utf8ToUtf32" ref="a7319ca6524a425e684dc025c132aa7aa" args="(bsl::vector&lt; unsigned int &gt; *dstVector, const bslstl::StringRef &amp;srcString, unsigned int errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf32::utf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; unsigned int &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstVector</code> the result of converting the specified UTF-8 <code>srcString</code> to its UTF-32 equivalent. Optionally specify <code>errorWord</code> to be substituted, if not 0, for invalid encodings in the input string. Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-32 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> otherwise. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings, UTF-8 encodings more than four bytes in length, or code points outside the ranges that UTF-32 can validly encode (i.e., <code>[ 1 .. 0xd7ff ]</code> and <code>[ 0xe000 .. 0x10ffff ]</code>). If <code>errorWord</code> is 0, invalid input sequences are ignored (i.e., produce no corresponding output). Any previous contents of the destination are discarded. The behavior is undefined unless <code>srcString</code> is null-terminated when specified as a <code>const char *</code>, and unless <code>errorWord</code> is either 0 or a valid Unicode code point. Note that one code point always occupies one 32-bit *ord of output; there is no <code>numCodePointsWritten</code> argument since, after the call, <code>dstVector-&gt;<a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a></code> will equal the number of code points written. Also note that when the input is a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, it may contain embedded nulls, which are translated to zeroes in the output. Also note that <code>errorWord</code> is assumed to be in host byte order. </p>

</div>
</div>
<a class="anchor" id="ad65cda8e52d916b8ffe7a2ed01c1e3f9"></a><!-- doxytag: member="bdlde::CharConvertUtf32::utf8ToUtf32" ref="ad65cda8e52d916b8ffe7a2ed01c1e3f9" args="(unsigned int *dstBuffer, bsl::size_t dstCapacity, const char *srcString, bsl::size_t *numCodePointsWritten=0, unsigned int errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf32::utf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6538e63213b1283869d3c9f4dd2ad03f"></a><!-- doxytag: member="bdlde::CharConvertUtf32::utf8ToUtf32" ref="a6538e63213b1283869d3c9f4dd2ad03f" args="(unsigned int *dstBuffer, bsl::size_t dstCapacity, const bslstl::StringRef &amp;srcString, bsl::size_t *numCodePointsWritten=0, unsigned int errorWord= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf32::utf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>errorWord</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified UTF-8 <code>srcString</code> to its UTF-32 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the variable into which the number of Unicode code points (including the null terminator) written is to be loaded. Optionally specify <code>errorWord</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are multi-byte encoding parts out of sequence, non-minimal UTF-8 encodings, UTF-8 encodings more than four bytes in length, or code points outside the ranges that UTF-32 can validly encode (i.e., <code>[ 1 .. 0xd7ff ]</code> and <code>[ 0xe000 .. 0x10ffff ]</code>). If <code>errorWord</code> is 0, invalid input code points are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-32 output; if <code>byteOrder</code> is not specified, the output is assumed to be in host byte order. Return 0 on success and a bit-wise OR of the masks defined by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise, where <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> will be set if one or more invalid sequences were encountered in the input, and <code>CharConvertStatus::BDEDE_OUT_OF_SPACE_BIT</code> will be set if the output space was exhausted before conversion was complete. If <code>dstCapacity &gt; 0</code> yet <code>dstCapacity</code> specifies a buffer too small to hold the output, the maximal null-terminated prefix of the properly converted result string is loaded into <code>dstBuffer</code>. The behavior is undefined unless <code>dstBuffer</code> refers to an array of at least <code>dstCapacity</code> elements, <code>srcString</code>, if specified as a <code>const char *</code>, is null-terminated, and <code>errorWord</code> is either 0 or a valid UTF-32 code point (in the range <code>[ 1 .. 0xd7ff ]</code> or <code>[ 0xe000 .. 0x10ffff ]</code>). Note that if <code>dstCapacity</code> is 0, <code>*dstBuffer</code> is not modified and this function returns a value with <code>CharConvertStatus::BDEDE_OUT_OF_SPACE_BIT</code> set and 0 is written into <code>*numCodePointsWritten</code> (if that pointer is not 0), since there is insufficient space for even a null terminator alone. Also note that one Unicode code point always occupies one 32-bit <em>word</em> in UTF-32, but may occupy more than one <em>byte</em> of UTF-8, so that <code>*numCodePointsWritten</code> equals the number of <em>words</em> written. Also note that <code>errorWord</code> is assumed to be in host byte order. </p>

</div>
</div>
<a class="anchor" id="a394463251cee436eb5d2dee89f1175ce"></a><!-- doxytag: member="bdlde::CharConvertUtf32::utf32ToUtf8" ref="a394463251cee436eb5d2dee89f1175ce" args="(bsl::string *dstString, const unsigned int *srcString, bsl::size_t *numCodePointsWritten=0, unsigned char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf32::utf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstString</code> the result of converting the specified null-terminated UTF-32 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points written, including the null terminator, is to be loaded. Optionally specify <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are illegal Unicode values (in the range <code>[ 0xd800 .. 0xdfff ]</code> or above <code>0x10ffff</code>). If <code>errorByte</code> is 0, invalid input words are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-32 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> if one or more invalid words were encountered in the input. The behavior is undefined unless <code>srcString</code> is null-terminated and <code>errorByte</code> is either 0 or a valid single-byte encoded UTF-8 code point (<code>0 &lt; errorByte &lt; 0x80</code>). Note that one Unicode code point can occupy multiple <em>bytes</em> of UTF-8. Also note that the string length will be sized to the length of the output such that <code>strlen(dstString-&gt;c_str()) == dstString-&gt;length()</code>. </p>

</div>
</div>
<a class="anchor" id="a3a3e4991a7521cc481c7acbd9c8d09f4"></a><!-- doxytag: member="bdlde::CharConvertUtf32::utf32ToUtf8" ref="a3a3e4991a7521cc481c7acbd9c8d09f4" args="(bsl::vector&lt; char &gt; *dstVector, const unsigned int *srcString, bsl::size_t *numCodePointsWritten=0, unsigned char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf32::utf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; char &gt; *&nbsp;</td>
          <td class="paramname"> <em>dstVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>dstVector</code> the result of converting the specified null-terminated UTF-32 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points written, including the null terminator, is to be loaded. Optionally specify <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are illegal Unicode values (in the range <code>[ 0xd800 .. 0xdfff ]</code> or above <code>0x10ffff</code>). If <code>errorByte</code> is 0, invalid input words are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-32 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Any previous contents of the destination are discarded. Return 0 on success and <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> if one or more invalid words were encountered in the input. The behavior is undefined unless <code>srcString</code> is null-terminated and <code>errorByte</code> is either 0 or a valid single-byte encoded UTF-8 code point (<code>0 &lt; errorByte &lt; 0x80</code>). Note that one code point can occupy multiple bytes of UTF-8. Also note that <code>dstVector</code> is sized to exactly fit the output so that <code>strlen(dstVector-&gt;begin()) == dstVector-&gt;<a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a> - 1</code>. </p>

</div>
</div>
<a class="anchor" id="a934abebc02a72ede0668b30b373ccc3a"></a><!-- doxytag: member="bdlde::CharConvertUtf32::utf32ToUtf8" ref="a934abebc02a72ede0668b30b373ccc3a" args="(char *dstBuffer, bsl::size_t dstCapacity, const unsigned int *srcString, bsl::size_t *numCodePointsWritten=0, bsl::size_t *numBytesWritten=0, unsigned char errorByte= '?', ByteOrder::Enum byteOrder=ByteOrder::e_HOST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlde::CharConvertUtf32::utf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numCodePointsWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t *&nbsp;</td>
          <td class="paramname"> <em>numBytesWritten</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>errorByte</em> = <code>'?'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlde_1_1ByteOrder.html#a74d92e1282a8614a919cf60cd30e2b7f">ByteOrder::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>byteOrder</em> = <code>ByteOrder::e_HOST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>dstBuffer</code> of the specified <code>dstCapacity</code>, the result of converting the specified null-terminated UTF-32 <code>srcString</code> to its UTF-8 equivalent. Optionally specify <code>numCodePointsWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of Unicode code points (including the terminating 0, if any) written is to be loaded. Optionally specify <code>numBytesWritten</code>, which (if not 0) indicates the location of the modifiable variable into which the number of bytes written (including the null terminator, if any) is to be loaded. Optionally specify <code>errorByte</code> to be substituted (if not 0) for invalid encodings in the input string. Invalid encodings are illegal Unicode values (in the range <code>[ 0xd800 .. 0xdfff ]</code> or above <code>0x10ffff</code>). If <code>errorByte</code> is 0, invalid input words are ignored (i.e., produce no corresponding output). Optionally specify <code>byteOrder</code> to indicate the byte order of the UTF-32 input; if <code>byteOrder</code> is not specified, the input is assumed to be in host byte order. Return 0 on success and a bit-wise OR of the masks defined by <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2d">CharConvertStatus::Enum</a></code> otherwise, where <code><a class="el" href="structbdlde_1_1CharConvertStatus.html#a23816819b840656834c5e2423b125b2dacdc819a693b5cb268fe3e58fd8ec3942">CharConvertStatus::k_INVALID_INPUT_BIT</a></code> will be set if one or more invalid words were encountered in the input, and <code>CharConvertStatus::BDEDE_OUT_OF_SPACE_BIT</code> will be set if the output space was exhausted before conversion was complete. The behavior is undefined unless <code>dstBuffer</code> refers to an array of at least <code>dstCapacity</code> elements, <code>srcString</code> is null-terminated, and <code>errorByte</code> is either 0 or a valid single-byte encoded UTF-8 code point (<code>0 &lt; errorByte &lt; 0x80</code>). Note that one Unicode code point can occupy multiple UTF-8 <em>bytes</em>, but will be a single UTF-32 <em>word</em>. Also note that if <code>dstCapacity</code> is 0, this function returns <code>CharConvertStatus::BDEDE_OUT_OF_SPACE_BIT</code> set and 0 is written into <code>*numCodePointsWritten</code> and <code>*numBytesWritten</code> (if those pointers are not zero), since there is insufficient space for even a null terminator alone. Also note that since UTF-8 is a variable-length encoding, <code>numBytesWritten</code> may be up to four times <code>numCodePointsWritten</code>, and, therefore, an input <code>srcString</code> of <code>dstCapacity</code> words (including terminating 0) may not fit into <code>dstBuffer</code>. Also note that the amount of room needed will vary with the contents of the data and the language being translated, but never will the number of bytes output exceed four times the number of 32-bit words input. Also note that, if <code>dstCapacity &gt; 0</code>, then, after completion, <code>strlen(dstBuffer) + 1 == *numBytesWritten</code>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bdlde__charconvertutf32_8h_source.html">bdlde_charconvertutf32.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:22 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
