<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlat_typename.h                                                   -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLAT_TYPENAME
#define INCLUDED_BDLAT_TYPENAME

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide string representations for data type names.
//
//@CLASSES:
//  bdlat_TypeName: namespace for type-name functions
//
//@SEE_ALSO: http://www.w3.org/TR/xmlschema-2/#built-in-datatypes
//
//@DESCRIPTION: This component defines a structure &#39;bdlat_TypeName&#39; which
// provides a namespace for functions returning information about the object
// types.  Functions in this namespace allow users to get access to three
// categories of information:
//
//: o class name from the metadata associated with the object type
//: o generic type name
//: o XML/XSD type name, based on object type and formatting mode.
//
///Class Name Information
///----------------------
// The template function &#39;className&#39; returns the object class name from the
// metadata associated with given object type.  Metadata is available for the
// C++ types that have one the following traits:
//..
//  &#39;bdlat_TypeTraitBasicChoice&#39;
//  &#39;bdlat_TypeTraitBasicSequence&#39;
//  &#39;bdlat_TypeTraitBasicCustomizedType&#39;
//  &#39;bdlat_TypeTraitBasicEnumeration&#39;
//..
// If metadata is not available for the object type, the function &#39;className&#39;
// returns 0 unless the function &#39;bdlat_TypeName_className&#39; is overloaded by
// developer.
//
///Overloable Class Name Functions For User Defined Classes
///--------------------------------------------------------
// To provide the custom name for the given user-defined C++ class, the
// developer should overload the template function &#39;bdlat_TypeName_className&#39;
// for this type in the namespace where the type is defined.
//
//WARNING! Do not extend &#39;bdlat_TypeName_Overloadable&#39; namespace.
//
///Generic Type Name Information
///-----------------------------
// The template functions &#39;name&#39; returns the generic type name for the given
// object.  The generic type name is one of the following:
//..
//  o predefined name for fundamental types
//  o class name from &#39;bdlat_TypeName_className&#39;, if such function returns a
//    non-null value
//  o name obtained from &#39;type_info&#39; object provided by C++ runtime, if no
//    class name is available
//..
//
///XSD Type Name Information
///-------------------------
// The template functions &#39;xsdName&#39; returns the XML/XSD type name, based on
// the object type and formatting mode.  The returned value is one of the
// following:
//..
//   o predefined name for built-in XSD types
//   o class name from &#39;bdlat_TypeName_className&#39;, if such function returns
//     a non-null value
//   o the &quot;anyType&quot; string, if no class name is available
//..
// This component also defines the XSD names for the following C++ types and
// formatting modes:
//..
//  C++ Type                      Formatting Mode             XML Name
//  --------                      ---------------             --------
//  bool                          DEFAULT/DEC/TEXT            boolean
//  char                          DEFAULT/DEC                 byte
//  char                          TEXT                        string
//  unsigned char                 DEFAULT/DEC                 unsignedByte
//  short                         DEFAULT/DEC                 short
//  short                         TEXT                        string
//  unsigned short                DEFAULT/DEC                 unsignedShort
//  int                           DEFAULT/DEC                 int
//  unsigned int                  DEFAULT/DEC                 unsignedInt
//  bsls::Types::Int64            DEFAULT/DEC                 long
//  bsls::Types::Uint64           DEFAULT/DEC                 unsignedLong
//  float                         DEFAULT                     float
//  float                         DEC                         decimal
//  double                        DEFAULT                     double
//  double                        DEC                         decimal
//  bdldflp::Decimal64            DEFAULT                     Decimal64
//  bsl::string                   DEFAULT/TEXT                string
//  bsl::string                   BASE64                      base64Binary
//  bsl::string                   HEX                         hexBinary
//  bdlt::Date                     DEFAULT                     date
//  bdlt::DateTz                   DEFAULT                     date
//  bdlt::Datetime                 DEFAULT                     dateTime
//  bdlt::DatetimeTz               DEFAULT                     dateTime
//  bdlt::Time                     DEFAULT                     time
//  bdlt::TimeTz                   DEFAULT                     time
//  bsl::vector&lt;char&gt;             DEFAULT/BASE64              base64Binary
//  bsl::vector&lt;char&gt;             HEX                         hexBinary
//  bsl::vector&lt;char&gt;             TEXT                        string
//  bsl::vector&lt;short&gt;            TEXT                        string
//..
//
///Usage
///-----
// We begin by creating abbreviations for formatting modes and by declaring
// objects of a number of types:
//..
//  int main() {
//
//      static const int DEFAULT = bdlat_FormattingMode::DEFAULT;
//      static const int DEC     = bdlat_FormattingMode::DEC;
//      static const int HEX     = bdlat_FormattingMode::HEX;
//      static const int BASE64  = bdlat_FormattingMode::BASE64;
//      static const int TEXT    = bdlat_FormattingMode::TEXT;
//
//      short                    theShort;
//      unsigned                 theUint;
//      float                    theFloat;
//      const char              *theCharPtr;
//      bsl::string              theString;
//
//      bdlt::Date                theDate;
//      bdlt::DatetimeTz          theDatetime;
//      bsl::vector&lt;char&gt;        theCharVector;
//      bsl::vector&lt;bsl::string&gt; theStrVector;
//..
// None of these types are generated types with metadata, so &#39;className&#39; will
// return a null pointer for each of them:
//..
//      assert(0 == bdlat_TypeName::className(theShort));
//      assert(0 == bdlat_TypeName::className(theUint));
//      assert(0 == bdlat_TypeName::className(theFloat));
//      assert(0 == bdlat_TypeName::className(theCharPtr));
//      assert(0 == bdlat_TypeName::className(theString));
//
//      assert(0 == bdlat_TypeName::className(theDate));
//      assert(0 == bdlat_TypeName::className(theDatetime));
//      assert(0 == bdlat_TypeName::className(theCharVector));
//      assert(0 == bdlat_TypeName::className(theStrVector));
//..
// The &#39;name&#39; function will never return a null pointer.  For each of the
// fundamental and vocabulary types, it returns the known type name.  For
// vector types, it returns the appropriate &quot;vector&lt;X&gt;&quot; string:
//..
//      assert(0 == bsl::strcmp(&quot;short&quot;, bdlat_TypeName::name(theShort)));
//      assert(0 == bsl::strcmp(&quot;unsigned int&quot;,
//                              bdlat_TypeName::name(theUint)));
//      assert(0 == bsl::strcmp(&quot;float&quot;, bdlat_TypeName::name(theFloat)));
//      assert(0 == bsl::strcmp(&quot;const char*&quot;,
//                              bdlat_TypeName::name(theCharPtr)));
//
//      assert(0 == bsl::strcmp(&quot;string&quot;, bdlat_TypeName::name(theString)));
//      assert(0 == bsl::strcmp(&quot;bdlt::Date&quot;, bdlat_TypeName::name(theDate)));
//      assert(0 == bsl::strcmp(&quot;bdlt::DatetimeTz&quot;,
//                              bdlat_TypeName::name(theDatetime)));
//      assert(0 == bsl::strcmp(&quot;vector&lt;char&gt;&quot;,
//                              bdlat_TypeName::name(theCharVector)));
//      assert(0 == bsl::strcmp(&quot;vector&lt;string&gt;&quot;,
//                              bdlat_TypeName::name(theStrVector)));
//..
// Each of the above types except &#39;vector&lt;string&gt;&#39; has one or more
// corresponding XSD types.  The XSD type is affected by a formatting mode so
// that, for example, a &#39;vector&lt;char&gt;&#39; can be represented as a text string
// (formatting mode &#39;TEXT&#39;) or as a sequence of binary bytes (formatting mode
// &#39;HEX&#39; or &#39;BASE64&#39;).
//..
//      assert(0 == bsl::strcmp(&quot;short&quot;,
//                              bdlat_TypeName::xsdName(theShort, DEFAULT)));
//      assert(0 == bsl::strcmp(&quot;unsignedInt&quot;,
//                              bdlat_TypeName::xsdName(theUint, DEFAULT)));
//      assert(0 == bsl::strcmp(&quot;float&quot;,
//                              bdlat_TypeName::xsdName(theFloat, DEFAULT)));
//      assert(0 == bsl::strcmp(&quot;decimal&quot;,
//                              bdlat_TypeName::xsdName(theFloat, DEC)));
//      assert(0 == bsl::strcmp(&quot;base64Binary&quot;,
//                           bdlat_TypeName::xsdName(theCharVector, DEFAULT)));
//      assert(0 == bsl::strcmp(&quot;string&quot;,
//                              bdlat_TypeName::xsdName(theCharVector, TEXT)));
//..
// For types that have not corresponding XSD type, &#39;xsdName&#39; returns
// &quot;anyType&quot;, regardless of formatting mode:
//..
//      assert(0 == bsl::strcmp(&quot;anyType&quot;,
//                            bdlat_TypeName::xsdName(theStrVector, DEFAULT)));
//
//      return 0;
//  }
//..
// If we create our own class:
//..
//  namespace MyNamespace {
//
//      class MyClass {
//          //...
//      };
//..
// Then we can assign it a printable name by overloading the
// &#39;bdlat_TypeName_className&#39; function in the class&#39;s namespace:
//..
//      const char *bdlat_TypeName_className(const MyClass&amp;) {
//          return &quot;MyClass&quot;;
//      }
//
//  } // Close MyNamespace
//..
// Note that &#39;bdlat_TypeName_className&#39; must return a string that is
// valid and does not change for remaining duration the program.  The
// overloaded &#39;bdlat_TypeName_className&#39; function is automatically used for
// &#39;name&#39; and &#39;xsdName&#39;, as well as for &#39;className&#39;:
//..
//  int main()
//  {
//      static const int DEFAULT = bdlat_FormattingMode::DEFAULT;
//
//      MyNamespace::MyClass myClassObj;
//
//      assert(0 == bsl::strcmp(&quot;MyClass&quot;,
//                              bdlat_TypeName::className(myClassObj)));
//      assert(0 == bsl::strcmp(&quot;MyClass&quot;, bdlat_TypeName::name(myClassObj)));
//      assert(0 == bsl::strcmp(&quot;MyClass&quot;,
//                              bdlat_TypeName::xsdName(myClassObj, DEFAULT)));
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLAT_BDEATOVERRIDES
#include &lt;bdlat_bdeatoverrides.h&gt;
#endif

#ifndef INCLUDED_BDLAT_FORMATTINGMODE
#include &lt;bdlat_formattingmode.h&gt;
#endif

#ifndef INCLUDED_BDLDFP_DECIMAL
#include &lt;bdldfp_decimal.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPETRAITS
#include &lt;bdlat_typetraits.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATE
#include &lt;bdlt_date.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIME
#include &lt;bdlt_datetime.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIMETZ
#include &lt;bdlt_datetimetz.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETZ
#include &lt;bdlt_datetz.h&gt;
#endif

#ifndef INCLUDED_BDLT_TIME
#include &lt;bdlt_time.h&gt;
#endif

#ifndef INCLUDED_BDLT_TIMETZ
#include &lt;bdlt_timetz.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLALG_HASTRAIT
#include &lt;bslalg_hastrait.h&gt;
#endif

#ifndef INCLUDED_BSLMF_SWITCH
#include &lt;bslmf_switch.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

#ifndef INCLUDED_BSL_TYPEINFO
#include &lt;bsl_typeinfo.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif




namespace BloombergLP {

                           // =====================
                           // struct bdlat_TypeName
                           // =====================

struct bdlat_TypeName {
    // Static template functions for returning a string representation for the
    // name of a type.

    template &lt;class TYPE&gt;
    static const char *className(const TYPE&amp; object);
        // Return a null-terminated string containing the exported name for
        // the specified &#39;TYPE&#39;, or a 0 pointer if &#39;TYPE&#39; does not export a
        // name.  A type exports a name by overloading the function
        // &#39;bdlat_TypeName_className(const TYPE&amp;)&#39; in TYPE&#39;s namespace.  The
        // default implementation of &#39;bdlat_TypeName_className&#39; will
        // automatically return the &#39;CLASS_NAME&#39; value for types that have the
        // &#39;bdlat_TypeTraitBasicChoice&#39;, &#39;bdlat_TypeTraitBasicSequence&#39;,
        // &#39;bdlat_TypeTraitBasicCustomizedType&#39;, or
        // &#39;bdlat_TypeTraitBasicEnumeration&#39; trait (i.e., types generated
        // using &#39;bas_codegen.pl&#39;).

    template &lt;class TYPE&gt;
    static const char *name(const TYPE&amp; object);
        // Return a null-terminated string containing the name of the specified
        // &#39;TYPE&#39;.  If &#39;TYPE&#39; is a fundamental type, string, date, time, or
        // datetime, then return a canonical representation of the type&#39;s name.
        // Otherwise, if &#39;className&#39; applied to the specified &#39;object&#39; returns
        // a non-null value, then return that value.  Otherwise, return
        // &#39;typeid(TYPE).name()&#39;.  Note that the returned name refers to the
        // *static* &#39;TYPE&#39;, not to the dynamic type of &#39;object&#39;.

    template &lt;class TYPE&gt;
    static const char *xsdName(const TYPE&amp; object, int format);
        // Return a null-terminated text string containing the name of the the
        // specified &#39;TYPE&#39; with the specified &#39;format&#39; as it would appear in
        // an XML Schema (XSD) element declaration.  The &#39;format&#39; is
        // interpreted as the bit-wise OR of one or more of the values defined
        // in the &#39;bdlat_formattingmode&#39; component.  Formatting mode bits
        // outside of &#39;bdlat_FormattingMode::TYPE_MASK&#39; are ignored.  If the
        // specified &#39;object&#39; corresponds to one of the XSD built-in types,
        // then return the XSD type&#39;s name.  Otherwise, if &#39;className(object)&#39;
        // returns a non-null value, then return that value.  Otherwise, return
        // &quot;anyType&quot;.  The behavior is undefined unless the &#39;format&#39; is valid
        // for the specified &#39;TYPE&#39;.
};

namespace bdlat_TypeName_Overloadable {
    // Namespace that provides default implementations.

    template &lt;class TYPE&gt;
    const char *bdlat_TypeName_className(const TYPE&amp; object);
        // Default implementation of &#39;className&#39; for the specified &#39;object&#39;.

    template &lt;class TYPE&gt;
    const char *bdlat_TypeName_name(const TYPE&amp; object);
        // Default implementation of &#39;name&#39; for the specified &#39;object&#39;.

    template &lt;class TYPE&gt;
    const char *bdlat_TypeName_xsdName(const TYPE&amp; object, int format);
        // Default implementation of &#39;xsdName&#39; for the specified &#39;object&#39; and
        // &#39;format&#39;.
}  // close namespace bdlat_TypeName_Overloadable

// ---  Anything below this line is implementation specific.  Do not use.  ----

                         // =========================
                         // struct bdlat_TypeName_Imp
                         // =========================

struct bdlat_TypeName_Imp {
    // Private class providing implementation of &#39;bdlat_TypeName&#39;.

  private:
    // PRIVATE TYPES
    typedef bdlat_FormattingMode FMode;

    struct HasClassName       { };
    struct IsBasicEnumeration { };
    struct Other              { };

    // PRIVATE CLASS METHODS
    template &lt;class TYPE&gt;
    static const char *classNameImp(const TYPE *object, HasClassName);

    template &lt;class TYPE&gt;
    static const char *classNameImp(const TYPE *object, IsBasicEnumeration);

    template &lt;class TYPE&gt;
    static const char *classNameImp(const TYPE *object, Other);

    // PRIVATE CLASS DATA
    static const char BDLAT_NAME_BOOL[];
    static const char BDLAT_NAME_CHAR[];
    static const char BDLAT_NAME_SIGNED_CHAR[];
    static const char BDLAT_NAME_UNSIGNED_CHAR[];
    static const char BDLAT_NAME_SHORT[];
    static const char BDLAT_NAME_UNSIGNED_SHORT[];
    static const char BDLAT_NAME_INT[];
    static const char BDLAT_NAME_UNSIGNED_INT[];
    static const char BDLAT_NAME_LONG[];
    static const char BDLAT_NAME_UNSIGNED_LONG[];
    static const char BDLAT_NAME_INT64[];
    static const char BDLAT_NAME_UINT64[];
    static const char BDLAT_NAME_FLOAT[];
    static const char BDLAT_NAME_DOUBLE[];
    static const char BDLAT_NAME_DECIMAL64[];
    static const char BDLAT_NAME_CONST_CHAR_PTR[];
    static const char BDLAT_NAME_CONST_SIGNED_CHAR_PTR[];
    static const char BDLAT_NAME_CONST_UNSIGNED_CHAR_PTR[];
    static const char BDLAT_NAME_STRING[];
    static const char BDLAT_NAME_DATE[];
    static const char BDLAT_NAME_DATE_TZ[];
    static const char BDLAT_NAME_DATETIME[];
    static const char BDLAT_NAME_DATETIME_TZ[];
    static const char BDLAT_NAME_TIME[];
    static const char BDLAT_NAME_TIME_TZ[];
    static const char BDLAT_NAME_VECTOR_BEGIN[];
    static const char BDLAT_NAME_VECTOR_END[];

    static const char BDLAT_XSDNAME_BOOLEAN[];
    static const char BDLAT_XSDNAME_BYTE[];
    static const char BDLAT_XSDNAME_UNSIGNED_BYTE[];
    static const char BDLAT_XSDNAME_SHORT[];
    static const char BDLAT_XSDNAME_UNSIGNED_SHORT[];
    static const char BDLAT_XSDNAME_INT[];
    static const char BDLAT_XSDNAME_UNSIGNED_INT[];
    static const char BDLAT_XSDNAME_LONG[];
    static const char BDLAT_XSDNAME_UNSIGNED_LONG[];
    static const char BDLAT_XSDNAME_FLOAT[];
    static const char BDLAT_XSDNAME_DOUBLE[];
    static const char BDLAT_XSDNAME_DECIMAL64[];
    static const char BDLAT_XSDNAME_DECIMAL[];
    static const char BDLAT_XSDNAME_STRING[];
    static const char BDLAT_XSDNAME_BASE64_BINARY[];
    static const char BDLAT_XSDNAME_HEX_BINARY[];
    static const char BDLAT_XSDNAME_DATE[];
    static const char BDLAT_XSDNAME_DATETIME[];
    static const char BDLAT_XSDNAME_TIME[];
    static const char BDLAT_XSDNAME_ANY_TYPE[];

  public:
    // CLASS METHODS
    template &lt;class TYPE&gt;
    static const char *className(const TYPE                 *);
        // Overloads for basic class types.

    template &lt;class TYPE&gt;
    static const char *name(const TYPE                      *);
        // Generic implementation for non-fundamental types.

    static const char *name(const bool                      *);
    static const char *name(const char                      *);
    static const char *name(const signed char               *);
    static const char *name(const unsigned char             *);
    static const char *name(const short                     *);
    static const char *name(const unsigned short            *);
    static const char *name(const int                       *);
    static const char *name(const unsigned int              *);
    static const char *name(const long                      *);
    static const char *name(const unsigned long             *);
    static const char *name(const bsls::Types::Int64        *);
    static const char *name(const bsls::Types::Uint64       *);
    static const char *name(const float                     *);
    static const char *name(const double                    *);
    static const char *name(const bdldfp::Decimal64         *);
    static const char *name(const char               *const *);
    static const char *name(const signed char        *const *);
    static const char *name(const unsigned char      *const *);
    static const char *name(const bsl::string               *);
    static const char *name(const bdlt::Date                *);
    static const char *name(const bdlt::DateTz              *);
    static const char *name(const bdlt::Datetime            *);
    static const char *name(const bdlt::DatetimeTz          *);
    static const char *name(const bdlt::Time                *);
    static const char *name(const bdlt::TimeTz              *);
        // Overloads for fundamental types and char pointers.

    template &lt;class TYPE&gt;
    static const char *name(const bsl::vector&lt;TYPE&gt;         *);
        // Specialization for vectors.  Return the null-terminated string
        // constructed by replacing the &quot;X&quot; in the string &quot;vector&lt;X&gt;&quot; with the
        // result of calling &#39;name&#39; on an object of the specified &#39;TYPE&#39;.  If
        // the constructed string exceeds 100 characters, then truncate to 100
        // characters.  Note that &#39;TYPE&#39; may itself be a vector, leading to a
        // recursive call to this function.

    template &lt;class TYPE&gt;
    static const char *xsdName(const TYPE           *object, int format);
        // Generic implementation for non-fundamental and not predefined types
        // using the specified &#39;object&#39; and &#39;format&#39;.

    static const char *xsdName(const bool                 *, int format);
    static const char *xsdName(const char                 *, int format);
    static const char *xsdName(const signed char          *, int format);
    static const char *xsdName(const unsigned char        *, int format);
    static const char *xsdName(const short                *, int format);
    static const char *xsdName(const unsigned short       *, int format);
    static const char *xsdName(const int                  *, int format);
    static const char *xsdName(const unsigned int         *, int format);
    static const char *xsdName(const long                 *, int format);
    static const char *xsdName(const unsigned long        *, int format);
    static const char *xsdName(const bsls::Types::Int64   *, int format);
    static const char *xsdName(const bsls::Types::Uint64  *, int format);
    static const char *xsdName(const float                *, int format);
    static const char *xsdName(const double               *, int format);
    static const char *xsdName(const bdldfp::Decimal64    *, int format);
    static const char *xsdName(const bsl::string          *, int format);
    static const char *xsdName(const char          *const *, int format);
    static const char *xsdName(const signed char   *const *, int format);
    static const char *xsdName(const unsigned char *const *, int format);
    static const char *xsdName(const bdlt::Date           *, int format);
    static const char *xsdName(const bdlt::DateTz         *, int format);
    static const char *xsdName(const bdlt::Datetime       *, int format);
    static const char *xsdName(const bdlt::DatetimeTz     *, int format);
    static const char *xsdName(const bdlt::Time           *, int format);
    static const char *xsdName(const bdlt::TimeTz         *, int format);
    static const char *xsdName(const bsl::vector&lt;char&gt;    *, int format);
    static const char *xsdName(const bsl::vector&lt;short&gt;   *, int format);
        // Overloads for fundamental types and some predefined types using the
        // specified &#39;format&#39;.

    static bool idempotentConcat(char       *dest,
                                 int         destSize,
                                 const char *segments[],
                                 int         numSegments);
        // Concatenate the specified &#39;numSegments&#39; zero-terminated strings
        // specified by &#39;segments&#39; array and load the result into the specified
        // &#39;dest&#39; buffer with the specified size &#39;destSize&#39;.  Return always
        // true.  Note that this method is idempotent and safe for
        // multi-threaded environment.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                         // -------------------------
                         // struct bdlat_TypeName_Imp
                         // -------------------------

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName_Imp::classNameImp(const TYPE *, HasClassName)
{
    return TYPE::CLASS_NAME;
}

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName_Imp::classNameImp(const TYPE *, IsBasicEnumeration)
{
    typedef typename bdlat_BasicEnumerationWrapper&lt;TYPE&gt;::Wrapper Wrapper;
    return Wrapper::CLASS_NAME;
}

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName_Imp::classNameImp(const TYPE *, Other)
{
    return 0;
}

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName_Imp::className(const TYPE *object)
{
    enum {
        HAS_CLASS_NAME =
             bslalg::HasTrait&lt;TYPE, bdlat_TypeTraitBasicChoice&gt;::VALUE
           | bslalg::HasTrait&lt;TYPE, bdlat_TypeTraitBasicSequence&gt;::VALUE
           | bslalg::HasTrait&lt;TYPE, bdlat_TypeTraitBasicCustomizedType&gt;::VALUE,

        IS_BASIC_ENUMERATION =
                bslalg::HasTrait&lt;TYPE, bdlat_TypeTraitBasicEnumeration&gt;::VALUE,

        SELECTOR = (HAS_CLASS_NAME ? 0 : (IS_BASIC_ENUMERATION ? 1 : 2))
    };

    typedef typename
    bslmf::Switch&lt;SELECTOR,
                  HasClassName,
                  IsBasicEnumeration,
                  Other&gt;::Type        Switch;

    return classNameImp(object, Switch());
}

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName_Imp::name(const TYPE *object)
{
    const char *cname = bdlat_TypeName::className(*object);
    return cname ? cname : typeid(TYPE).name();
}

inline
const char *bdlat_TypeName_Imp::name(const bool *)
{
    return BDLAT_NAME_BOOL;
}

inline
const char *bdlat_TypeName_Imp::name(const char *)
{
    return BDLAT_NAME_CHAR;
}

inline
const char *bdlat_TypeName_Imp::name(const unsigned char *)
{
    return BDLAT_NAME_UNSIGNED_CHAR;
}

inline
const char *bdlat_TypeName_Imp::name(const signed char *)
{
    return BDLAT_NAME_SIGNED_CHAR;
}

inline
const char *bdlat_TypeName_Imp::name(const short *)
{
    return BDLAT_NAME_SHORT;
}

inline
const char *bdlat_TypeName_Imp::name(const unsigned short *)
{
    return BDLAT_NAME_UNSIGNED_SHORT;
}

inline
const char *bdlat_TypeName_Imp::name(const int *)
{
    return BDLAT_NAME_INT;
}

inline
const char *bdlat_TypeName_Imp::name(const unsigned int *)
{
    return BDLAT_NAME_UNSIGNED_INT;
}

inline
const char *bdlat_TypeName_Imp::name(const long *)
{
    return BDLAT_NAME_LONG;
}

inline
const char *bdlat_TypeName_Imp::name(const unsigned long *)
{
    return BDLAT_NAME_UNSIGNED_LONG;
}

inline
const char *bdlat_TypeName_Imp::name(const bsls::Types::Int64 *)
{
    return BDLAT_NAME_INT64;
}

inline
const char *bdlat_TypeName_Imp::name(const bsls::Types::Uint64 *)
{
    return BDLAT_NAME_UINT64;
}

inline
const char *bdlat_TypeName_Imp::name(const float *)
{
    return BDLAT_NAME_FLOAT;
}

inline
const char *bdlat_TypeName_Imp::name(const double *)
{
    return BDLAT_NAME_DOUBLE;
}

inline
const char *bdlat_TypeName_Imp::name(const bdldfp::Decimal64 *)
{
    return BDLAT_NAME_DECIMAL64;
}

inline
const char *bdlat_TypeName_Imp::name(const char *const *)
{
    return BDLAT_NAME_CONST_CHAR_PTR;
}

inline
const char *bdlat_TypeName_Imp::name(const signed char *const *)
{
    return BDLAT_NAME_CONST_SIGNED_CHAR_PTR;
}

inline
const char *bdlat_TypeName_Imp::name(const unsigned char *const *)
{
    return BDLAT_NAME_CONST_UNSIGNED_CHAR_PTR;
}

inline
const char *bdlat_TypeName_Imp::name(const bsl::string *)
{
    return BDLAT_NAME_STRING;
}

inline
const char *bdlat_TypeName_Imp::name(const bdlt::Date *)
{
    return BDLAT_NAME_DATE;
}

inline
const char *bdlat_TypeName_Imp::name(const bdlt::DateTz *)
{
    return BDLAT_NAME_DATE_TZ;
}

inline
const char *bdlat_TypeName_Imp::name(const bdlt::Datetime *)
{
    return BDLAT_NAME_DATETIME;
}

inline
const char *bdlat_TypeName_Imp::name(const bdlt::DatetimeTz *)
{
    return BDLAT_NAME_DATETIME_TZ;
}

inline
const char *bdlat_TypeName_Imp::name(const bdlt::Time *)
{
    return BDLAT_NAME_TIME;
}

inline
const char *bdlat_TypeName_Imp::name(const bdlt::TimeTz *)
{
    return BDLAT_NAME_TIME_TZ;
}

template &lt;class TYPE&gt;
const char *bdlat_TypeName_Imp::name(const bsl::vector&lt;TYPE&gt; *)
{
    static const int MAX_LEN = 100;
    static char name[MAX_LEN + 1];
    static bool initialized = false;

    if (! initialized) {
        // This is thread-safe because even if two threads execute this code
        // simultaneously, the same values will be written on top of each
        // other (i.e., the operations are idempotent).

        const char *segments[3] = {
            (const char*)BDLAT_NAME_VECTOR_BEGIN,
            bdlat_TypeName::name(*(TYPE*)0),
            (const char*)BDLAT_NAME_VECTOR_END,
        };

        initialized = bdlat_TypeName_Imp::idempotentConcat(name,
                                                           MAX_LEN + 1,
                                                           segments,
                                                           3);
    }

    return name;
}

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName_Imp::xsdName(const TYPE *object, int)
{
    const char *cname = bdlat_TypeName::className(*object);
    return cname ? cname : (const char *)BDLAT_XSDNAME_ANY_TYPE;
}

inline
const char *bdlat_TypeName_Imp::xsdName(const bool *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_DEC     == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_TEXT    == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_BOOLEAN;
}

inline
const char *bdlat_TypeName_Imp::xsdName(const char *, int format)
{
    return xsdName((const signed char*)0, format);
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const unsigned short *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_DEC     == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_UNSIGNED_SHORT;
}

inline
const char *bdlat_TypeName_Imp::xsdName(const int *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_DEC     == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_INT;
}

inline
const char *bdlat_TypeName_Imp::xsdName(const unsigned int *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_DEC     == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_UNSIGNED_INT;
}

inline
const char *bdlat_TypeName_Imp::xsdName(const long *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_DEC     == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_INT;
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const unsigned long *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_DEC     == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_UNSIGNED_INT;
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const bsls::Types::Int64 *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_DEC     == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_LONG;
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const bsls::Types::Uint64 *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK)
                  || FMode::e_DEC     == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_UNSIGNED_LONG;
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const char *const *, int format)
{
    return xsdName((const bsl::string*) 0, format);
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const signed char *const *, int format)
{
    return xsdName((const bsl::string*) 0, format);
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const unsigned char *const *, int format)
{
    return xsdName((const bsl::string*) 0, format);
}

inline
const char *bdlat_TypeName_Imp::xsdName(const bdlt::Date *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_DATE;
}

inline
const char *bdlat_TypeName_Imp::xsdName(const bdlt::DateTz *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_DATE;
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const bdlt::Datetime *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_DATETIME;
}

inline
const char*
bdlat_TypeName_Imp::xsdName(const bdlt::DatetimeTz *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_DATETIME;
}

inline
const char *bdlat_TypeName_Imp::xsdName(const bdlt::Time *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_TIME;
}

inline
const char *bdlat_TypeName_Imp::xsdName(const bdlt::TimeTz *, int format)
{
    BSLS_ASSERT_SAFE(FMode::e_DEFAULT == (format &amp; FMode::e_TYPE_MASK));

    (void)format;  // suppress warning if assert is disabled
    return BDLAT_XSDNAME_TIME;
}

                          // -------------------------------------
                          // namespace bdlat_TypeName_Overloadable
                          // -------------------------------------

template &lt;class TYPE&gt;
inline
const char *
bdlat_TypeName_Overloadable::bdlat_TypeName_className(const TYPE&amp; object)
{
    // Indirection prevents conversion to &#39;TYPE&#39;:
    return bdlat_TypeName_Imp::className(&amp;object);
}

template &lt;class TYPE&gt;
inline
const char *
bdlat_TypeName_Overloadable::bdlat_TypeName_name(const TYPE&amp; object)
{
    // Indirection prevents conversion to &#39;TYPE&#39;:
    return bdlat_TypeName_Imp::name(&amp;object);
}

template &lt;class TYPE&gt;
inline
const char *
bdlat_TypeName_Overloadable::bdlat_TypeName_xsdName(const TYPE&amp; object,
                                                    int         format)
{
    // Indirection prevents conversion to &#39;TYPE&#39;:

    return bdlat_TypeName_Imp::xsdName(&amp;object, format);
}

                            // --------------------
                            // class bdlat_TypeName
                            // --------------------

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName::className(const TYPE&amp; object)
{
    using namespace bdlat_TypeName_Overloadable;

    // Select function using Koenig lookup:

    return bdlat_TypeName_className(object);
}

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName::name(const TYPE&amp; object)
{
    using namespace bdlat_TypeName_Overloadable;

    // Select function using Koenig lookup:

    return bdlat_TypeName_name(object);
}

template &lt;class TYPE&gt;
inline
const char *bdlat_TypeName::xsdName(const TYPE&amp; object, int format)
{
    using namespace bdlat_TypeName_Overloadable;

    // Select function using Koenig lookup:

    return bdlat_TypeName_xsdName(object, format);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
