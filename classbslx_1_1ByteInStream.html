<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bslx::ByteInStream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslx.html">bslx</a>      </li>
      <li><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bslx::ByteInStream Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslx::ByteInStream" -->
<p><code>#include &lt;<a class="el" href="bslx__byteinstream_8h_source.html">bslx_byteinstream.h</a>&gt;</code></p>

<p><a href="classbslx_1_1ByteInStream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a6f3e71d074d5d93de6791607f970b5b3">ByteInStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a0411e86135e06ee920a90012dd9a3fe3">ByteInStream</a> (const char *buffer, bsl::size_t numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a28088a25e565c9deebbb48be4d3bd981">ByteInStream</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#aa79c28681188adc1e9983595953b271b">~ByteInStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#aed69331c5fe75af36a0fd7135fd3f2da">getLength</a> (int &amp;length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ae9c4a1fba04a766d693dfcd48a94d8d4">getVersion</a> (int &amp;version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a9b0d5f34625349e8cf21ad24719f83d4">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a70f7f25ce23bf12635e660b1cf39baff">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a2c864f363d3d03bf83ea366a88bb58e3">reset</a> (const char *buffer, bsl::size_t numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a193087a470bdf23d8eaf548e1349b6b4">reset</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#afbe6de8f5b87b106a3f7e82b798ce12f">getInt64</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#aa45a9296f6dcd69dc2cbe9154b4416a6">getUint64</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#af92668d7e05cb79f5f66db0be00bdd5d">getInt56</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#adce5c1f0c1b9c21e75d9c98263e16a7c">getUint56</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#acafb6d4fc796bfd2e23f4cc4bebea6ad">getInt48</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a69bfbecdc0946def72e0de80b2ee39ce">getUint48</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#aa1bd6ad29f8cfa77fb2aee055dca4c6d">getInt40</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a122d550ea494aa49733716dee906443c">getUint40</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ac7f3f3bce78a27de7c63c1ffa347c8e3">getInt32</a> (int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a046af96693b82fbc6d27c8f4019ab11d">getUint32</a> (unsigned int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a4d72157dc3e349a0af7c1d109947f599">getInt24</a> (int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ae58467c46d78955bdd8cf3181611a7dd">getUint24</a> (unsigned int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a2c7960423b580e2348108039b70de2fb">getInt16</a> (short &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a4f3d13a5a264acce777e6332d57cd46f">getUint16</a> (unsigned short &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a5455a26c7c5a8e446fcce92426fd3c01">getInt8</a> (char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a0ff8be43660ae1607498f7233f8b1cc7">getInt8</a> (signed char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a5d320c0a77e62d3eec15a1f4cb03ccfe">getUint8</a> (char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ad17c89f615c395f03d67df78ae6c69de">getUint8</a> (unsigned char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a25d99dc9f7316f3c1b6b363120253687">getFloat64</a> (double &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a1ebc93a624b882f32b06b6a16a7c120e">getFloat32</a> (float &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#af5f6611d50e8079ed3bc15a8be8301d1">getString</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ab4f7d75de6470a318b72ed1c236155f2">getArrayInt64</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#aa7db11d4f8bb8a78f8fc61cbf665f251">getArrayUint64</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a8af17b1db134e7f27ebe30c0b6db6d62">getArrayInt56</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#af2d7ee2e35afa47fb1946ec0b05086d3">getArrayUint56</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ac70f7033d0e373cc593913c33c65f42f">getArrayInt48</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a5a53495edef64b71c3023629cf293a12">getArrayUint48</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a36e866bb244f820a8f2df5cb5a4c0711">getArrayInt40</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a7d6d16293f9fc77236794f6a415e149f">getArrayUint40</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a705e97889cac19bfe0ca0a95c1cb2b2b">getArrayInt32</a> (int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a31c47de1d03b3e4a8dbf06d032bf91d9">getArrayUint32</a> (unsigned int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a0afc8be0f5d5b253759257ffdf3ca27a">getArrayInt24</a> (int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a6a447e578c620d045ed7dbaaca79d11e">getArrayUint24</a> (unsigned int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a2243ed810f6e4a8d87623e579bf6c01e">getArrayInt16</a> (short *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a0411db2bb770dddc8ae947bdcbe2cfe7">getArrayUint16</a> (unsigned short *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a7ee9b9b1515977711ee792efe36b7310">getArrayInt8</a> (char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ac7699f7c86561846d291e7c28b7376fb">getArrayInt8</a> (signed char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a22a18b8a9e31e504571cc100d24cd3d7">getArrayUint8</a> (char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#aea1f051f64a9abf91c9f4589773344dc">getArrayUint8</a> (unsigned char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#afb89ee37f637cab7583cf21082ded1b4">getArrayFloat64</a> (double *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#aded80a8f0a8f685d27628356d0e4424c">getArrayFloat32</a> (float *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ac26a8a04e56318de2972007e56af0719">operator const void *</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#ac07a06bbe2c8697f175aad0e07db8ac1">cursor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a6f6c69d65c93e50a10249c7b64b5174c">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#aff1c66e8f5d344ec63c58ea9e6d9ae82">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a42b2775c932047f1d1cf2f1945f00c40">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a602e9e2139733f318d63f91f03fa8e16">length</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1ByteInStream.html#a50a084efeb9d8b9ad37feea01cd8e727">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;object)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides input methods to unexternalize values, and C-style arrays of values, of the fundamental integral and floating-point types, as well as <code>bsl::string</code> values, using a byte format documented in the <code>bslx_byteoutstream</code> component. In particular, each <code>get</code> method of this class is guaranteed to read stream data written by the corresponding <code>put</code> method of <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code>. Note that attempting to read beyond the end of a stream will automatically invalidate the stream. See the <code>bslx</code> package-level documentation for the definition of the BDEX <code>InStream</code> protocol. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6f3e71d074d5d93de6791607f970b5b3"></a><!-- doxytag: member="bslx::ByteInStream::ByteInStream" ref="a6f3e71d074d5d93de6791607f970b5b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteInStream::ByteInStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty input byte stream. Note that the constructed object is useless until a buffer is set with the <code>reset</code> method. </p>

</div>
</div>
<a class="anchor" id="a0411e86135e06ee920a90012dd9a3fe3"></a><!-- doxytag: member="bslx::ByteInStream::ByteInStream" ref="a0411e86135e06ee920a90012dd9a3fe3" args="(const char *buffer, bsl::size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteInStream::ByteInStream </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an input byte stream containing the specified initial <code>numBytes</code> from the specified <code>buffer</code>. The behavior is undefined unless <code>0 == numBytes</code> if <code>0 == buffer</code>. </p>

</div>
</div>
<a class="anchor" id="a28088a25e565c9deebbb48be4d3bd981"></a><!-- doxytag: member="bslx::ByteInStream::ByteInStream" ref="a28088a25e565c9deebbb48be4d3bd981" args="(const bslstl::StringRef &amp;srcData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteInStream::ByteInStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcData</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an input byte stream containing the specified <code>srcData</code>. </p>

</div>
</div>
<a class="anchor" id="aa79c28681188adc1e9983595953b271b"></a><!-- doxytag: member="bslx::ByteInStream::~ByteInStream" ref="aa79c28681188adc1e9983595953b271b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteInStream::~ByteInStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aed69331c5fe75af36a0fd7135fd3f2da"></a><!-- doxytag: member="bslx::ByteInStream::getLength" ref="aed69331c5fe75af36a0fd7135fd3f2da" args="(int &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getLength </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the most-significant bit of the one byte of this stream at the current cursor location is set, assign to the specified <code>length</code> the four-byte, two's complement integer (in host byte order) comprised of the four bytes of this stream at the current cursor location (in network byte order) with the most-significant bit unset; otherwise, assign to <code>length</code> the one-byte, two's complement integer comprised of the one byte of this stream at the current cursor location. Update the cursor location and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>length</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="ae9c4a1fba04a766d693dfcd48a94d8d4"></a><!-- doxytag: member="bslx::ByteInStream::getVersion" ref="ae9c4a1fba04a766d693dfcd48a94d8d4" args="(int &amp;version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getVersion </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>version</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>version</code> the one-byte, two's complement unsigned integer comprised of the one byte of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>version</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a9b0d5f34625349e8cf21ad24719f83d4"></a><!-- doxytag: member="bslx::ByteInStream::invalidate" ref="a9b0d5f34625349e8cf21ad24719f83d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::ByteInStream::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put this input stream in an invalid state. This function has no effect if this stream is already invalid. Note that this function should be called whenever a value extracted from this stream is determined to be invalid, inconsistent, or otherwise incorrect. </p>

</div>
</div>
<a class="anchor" id="a70f7f25ce23bf12635e660b1cf39baff"></a><!-- doxytag: member="bslx::ByteInStream::reset" ref="a70f7f25ce23bf12635e660b1cf39baff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::ByteInStream::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the index of the next byte to be extracted from this stream to 0 (i.e., the beginning of the stream) and validate this stream if it is currently invalid. </p>

</div>
</div>
<a class="anchor" id="a2c864f363d3d03bf83ea366a88bb58e3"></a><!-- doxytag: member="bslx::ByteInStream::reset" ref="a2c864f363d3d03bf83ea366a88bb58e3" args="(const char *buffer, bsl::size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::ByteInStream::reset </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this stream to extract from the specified <code>buffer</code> containing the specified <code>numBytes</code>, set the index of the next byte to be extracted to 0 (i.e., the beginning of the stream), and validate this stream if it is currently invalid. The behavior is undefined unless <code>0 == numBytes</code> if <code>0 == buffer</code>. </p>

</div>
</div>
<a class="anchor" id="a193087a470bdf23d8eaf548e1349b6b4"></a><!-- doxytag: member="bslx::ByteInStream::reset" ref="a193087a470bdf23d8eaf548e1349b6b4" args="(const bslstl::StringRef &amp;srcData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::ByteInStream::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcData</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this stream to extract from the specified <code>srcData</code>, set the index of the next byte to be extracted to 0 (i.e., the beginning of the stream), and validate this stream if it is currently invalid. </p>

</div>
</div>
<a class="anchor" id="afbe6de8f5b87b106a3f7e82b798ce12f"></a><!-- doxytag: member="bslx::ByteInStream::getInt64" ref="afbe6de8f5b87b106a3f7e82b798ce12f" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the eight-byte, two's complement integer (in host byte order) comprised of the eight bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="aa45a9296f6dcd69dc2cbe9154b4416a6"></a><!-- doxytag: member="bslx::ByteInStream::getUint64" ref="aa45a9296f6dcd69dc2cbe9154b4416a6" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the eight-byte, two's complement unsigned integer (in host byte order) comprised of the eight bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="af92668d7e05cb79f5f66db0be00bdd5d"></a><!-- doxytag: member="bslx::ByteInStream::getInt56" ref="af92668d7e05cb79f5f66db0be00bdd5d" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the seven-byte, two's complement integer (in host byte order) comprised of the seven bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="adce5c1f0c1b9c21e75d9c98263e16a7c"></a><!-- doxytag: member="bslx::ByteInStream::getUint56" ref="adce5c1f0c1b9c21e75d9c98263e16a7c" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the seven-byte, two's complement unsigned integer (in host byte order) comprised of the seven bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="acafb6d4fc796bfd2e23f4cc4bebea6ad"></a><!-- doxytag: member="bslx::ByteInStream::getInt48" ref="acafb6d4fc796bfd2e23f4cc4bebea6ad" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the six-byte, two's complement integer (in host byte order) comprised of the six bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a69bfbecdc0946def72e0de80b2ee39ce"></a><!-- doxytag: member="bslx::ByteInStream::getUint48" ref="a69bfbecdc0946def72e0de80b2ee39ce" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the six-byte, two's complement unsigned integer (in host byte order) comprised of the six bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="aa1bd6ad29f8cfa77fb2aee055dca4c6d"></a><!-- doxytag: member="bslx::ByteInStream::getInt40" ref="aa1bd6ad29f8cfa77fb2aee055dca4c6d" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the five-byte, two's complement integer (in host byte order) comprised of the five bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a122d550ea494aa49733716dee906443c"></a><!-- doxytag: member="bslx::ByteInStream::getUint40" ref="a122d550ea494aa49733716dee906443c" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the five-byte, two's complement unsigned integer (in host byte order) comprised of the five bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="ac7f3f3bce78a27de7c63c1ffa347c8e3"></a><!-- doxytag: member="bslx::ByteInStream::getInt32" ref="ac7f3f3bce78a27de7c63c1ffa347c8e3" args="(int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt32 </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the four-byte, two's complement integer (in host byte order) comprised of the four bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a046af96693b82fbc6d27c8f4019ab11d"></a><!-- doxytag: member="bslx::ByteInStream::getUint32" ref="a046af96693b82fbc6d27c8f4019ab11d" args="(unsigned int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the four-byte, two's complement unsigned integer (in host byte order) comprised of the four bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a4d72157dc3e349a0af7c1d109947f599"></a><!-- doxytag: member="bslx::ByteInStream::getInt24" ref="a4d72157dc3e349a0af7c1d109947f599" args="(int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt24 </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the three-byte, two's complement integer (in host byte order) comprised of the three bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="ae58467c46d78955bdd8cf3181611a7dd"></a><!-- doxytag: member="bslx::ByteInStream::getUint24" ref="ae58467c46d78955bdd8cf3181611a7dd" args="(unsigned int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the three-byte, two's complement unsigned integer (in host byte order) comprised of the three bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a2c7960423b580e2348108039b70de2fb"></a><!-- doxytag: member="bslx::ByteInStream::getInt16" ref="a2c7960423b580e2348108039b70de2fb" args="(short &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt16 </td>
          <td>(</td>
          <td class="paramtype">short &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the two-byte, two's complement integer (in host byte order) comprised of the two bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a4f3d13a5a264acce777e6332d57cd46f"></a><!-- doxytag: member="bslx::ByteInStream::getUint16" ref="a4f3d13a5a264acce777e6332d57cd46f" args="(unsigned short &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the two-byte, two's complement unsigned integer (in host byte order) comprised of the two bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a5455a26c7c5a8e446fcce92426fd3c01"></a><!-- doxytag: member="bslx::ByteInStream::getInt8" ref="a5455a26c7c5a8e446fcce92426fd3c01" args="(char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt8 </td>
          <td>(</td>
          <td class="paramtype">char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ff8be43660ae1607498f7233f8b1cc7"></a><!-- doxytag: member="bslx::ByteInStream::getInt8" ref="a0ff8be43660ae1607498f7233f8b1cc7" args="(signed char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getInt8 </td>
          <td>(</td>
          <td class="paramtype">signed char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the one-byte, two's complement integer comprised of the one byte of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a5d320c0a77e62d3eec15a1f4cb03ccfe"></a><!-- doxytag: member="bslx::ByteInStream::getUint8" ref="a5d320c0a77e62d3eec15a1f4cb03ccfe" args="(char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint8 </td>
          <td>(</td>
          <td class="paramtype">char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad17c89f615c395f03d67df78ae6c69de"></a><!-- doxytag: member="bslx::ByteInStream::getUint8" ref="ad17c89f615c395f03d67df78ae6c69de" args="(unsigned char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getUint8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the one-byte, two's complement unsigned integer comprised of the one byte of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a25d99dc9f7316f3c1b6b363120253687"></a><!-- doxytag: member="bslx::ByteInStream::getFloat64" ref="a25d99dc9f7316f3c1b6b363120253687" args="(double &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getFloat64 </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the eight-byte IEEE double-precision floating-point number (in host byte order) comprised of the eight bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a1ebc93a624b882f32b06b6a16a7c120e"></a><!-- doxytag: member="bslx::ByteInStream::getFloat32" ref="a1ebc93a624b882f32b06b6a16a7c120e" args="(float &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getFloat32 </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the four-byte IEEE single-precision floating-point number (in host byte order) comprised of the four bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="af5f6611d50e8079ed3bc15a8be8301d1"></a><!-- doxytag: member="bslx::ByteInStream::getString" ref="af5f6611d50e8079ed3bc15a8be8301d1" args="(bsl::string &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the string comprised of the length of the string (see <code>getLength</code>) and the string data (see <code>getUint8</code>), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="ab4f7d75de6470a318b72ed1c236155f2"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt64" ref="ab4f7d75de6470a318b72ed1c236155f2" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive eight-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> eight-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="aa7db11d4f8bb8a78f8fc61cbf665f251"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint64" ref="aa7db11d4f8bb8a78f8fc61cbf665f251" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive eight-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> eight-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a8af17b1db134e7f27ebe30c0b6db6d62"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt56" ref="a8af17b1db134e7f27ebe30c0b6db6d62" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive seven-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> seven-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="af2d7ee2e35afa47fb1946ec0b05086d3"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint56" ref="af2d7ee2e35afa47fb1946ec0b05086d3" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive seven-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> seven-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="ac70f7033d0e373cc593913c33c65f42f"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt48" ref="ac70f7033d0e373cc593913c33c65f42f" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive six-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> six-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a5a53495edef64b71c3023629cf293a12"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint48" ref="a5a53495edef64b71c3023629cf293a12" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive six-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> six-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a36e866bb244f820a8f2df5cb5a4c0711"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt40" ref="a36e866bb244f820a8f2df5cb5a4c0711" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive five-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> five-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a7d6d16293f9fc77236794f6a415e149f"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint40" ref="a7d6d16293f9fc77236794f6a415e149f" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive five-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> five-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a705e97889cac19bfe0ca0a95c1cb2b2b"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt32" ref="a705e97889cac19bfe0ca0a95c1cb2b2b" args="(int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt32 </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive four-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> four-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a31c47de1d03b3e4a8dbf06d032bf91d9"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint32" ref="a31c47de1d03b3e4a8dbf06d032bf91d9" args="(unsigned int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive four-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> four-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a0afc8be0f5d5b253759257ffdf3ca27a"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt24" ref="a0afc8be0f5d5b253759257ffdf3ca27a" args="(int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt24 </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive three-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> three-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a6a447e578c620d045ed7dbaaca79d11e"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint24" ref="a6a447e578c620d045ed7dbaaca79d11e" args="(unsigned int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive three-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> three-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a2243ed810f6e4a8d87623e579bf6c01e"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt16" ref="a2243ed810f6e4a8d87623e579bf6c01e" args="(short *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt16 </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive two-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> two-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a0411db2bb770dddc8ae947bdcbe2cfe7"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint16" ref="a0411db2bb770dddc8ae947bdcbe2cfe7" args="(unsigned short *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive two-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> two-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a7ee9b9b1515977711ee792efe36b7310"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt8" ref="a7ee9b9b1515977711ee792efe36b7310" args="(char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7699f7c86561846d291e7c28b7376fb"></a><!-- doxytag: member="bslx::ByteInStream::getArrayInt8" ref="ac7699f7c86561846d291e7c28b7376fb" args="(signed char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">signed char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive one-byte, two's complement integers comprised of each of the specified <code>numVariables</code> one-byte sequences of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a22a18b8a9e31e504571cc100d24cd3d7"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint8" ref="a22a18b8a9e31e504571cc100d24cd3d7" args="(char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea1f051f64a9abf91c9f4589773344dc"></a><!-- doxytag: member="bslx::ByteInStream::getArrayUint8" ref="aea1f051f64a9abf91c9f4589773344dc" args="(unsigned char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive one-byte, two's complement unsigned integers comprised of each of the specified <code>numVariables</code> one-byte sequences of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="afb89ee37f637cab7583cf21082ded1b4"></a><!-- doxytag: member="bslx::ByteInStream::getArrayFloat64" ref="afb89ee37f637cab7583cf21082ded1b4" args="(double *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayFloat64 </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive eight-byte IEEE double-precision floating-point numbers (in host byte order) comprised of each of the specified <code>numVariables</code> eight-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="aded80a8f0a8f685d27628356d0e4424c"></a><!-- doxytag: member="bslx::ByteInStream::getArrayFloat32" ref="aded80a8f0a8f685d27628356d0e4424c" args="(float *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a>&amp; bslx::ByteInStream::getArrayFloat32 </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive four-byte IEEE single-precision floating-point numbers (in host byte order) comprised of each of the specified <code>numVariables</code> four-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="ac26a8a04e56318de2972007e56af0719"></a><!-- doxytag: member="bslx::ByteInStream::operator const void *" ref="ac26a8a04e56318de2972007e56af0719" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::ByteInStream::operator const void * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-zero value if this stream is valid, and 0 otherwise. An invalid stream is a stream for which an input operation was detected to have failed. </p>

</div>
</div>
<a class="anchor" id="ac07a06bbe2c8697f175aad0e07db8ac1"></a><!-- doxytag: member="bslx::ByteInStream::cursor" ref="ac07a06bbe2c8697f175aad0e07db8ac1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::size_t bslx::ByteInStream::cursor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the next byte to be extracted from this stream. </p>

</div>
</div>
<a class="anchor" id="a6f6c69d65c93e50a10249c7b64b5174c"></a><!-- doxytag: member="bslx::ByteInStream::data" ref="a6f6c69d65c93e50a10249c7b64b5174c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* bslx::ByteInStream::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the contiguous, non-modifiable external memory buffer of this stream. The behavior of accessing elements outside the range <code>[ <a class="el" href="classbslx_1_1ByteInStream.html#a6f6c69d65c93e50a10249c7b64b5174c">data()</a> .. <a class="el" href="classbslx_1_1ByteInStream.html#a6f6c69d65c93e50a10249c7b64b5174c">data()</a> + (<a class="el" href="classbslx_1_1ByteInStream.html#a602e9e2139733f318d63f91f03fa8e16">length()</a> - 1) ]</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="aff1c66e8f5d344ec63c58ea9e6d9ae82"></a><!-- doxytag: member="bslx::ByteInStream::isEmpty" ref="aff1c66e8f5d344ec63c58ea9e6d9ae82" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslx::ByteInStream::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stream is empty, and <code>false</code> otherwise. Note that this function enables higher-level types to verify that, after successfully reading all expected data, no data remains. </p>

</div>
</div>
<a class="anchor" id="a42b2775c932047f1d1cf2f1945f00c40"></a><!-- doxytag: member="bslx::ByteInStream::isValid" ref="a42b2775c932047f1d1cf2f1945f00c40" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslx::ByteInStream::isValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stream is valid, and <code>false</code> otherwise. An invalid stream is a stream in which insufficient or invalid data was detected during an extraction operation. Note that an empty stream will be valid unless an extraction attempt or explicit invalidation causes it to be otherwise. </p>

</div>
</div>
<a class="anchor" id="a602e9e2139733f318d63f91f03fa8e16"></a><!-- doxytag: member="bslx::ByteInStream::length" ref="a602e9e2139733f318d63f91f03fa8e16" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::size_t bslx::ByteInStream::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of bytes stored in the external memory buffer. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a50a084efeb9d8b9ad37feea01cd8e727"></a><!-- doxytag: member="bslx::ByteInStream::operator&lt;&lt;" ref="a50a084efeb9d8b9ad37feea01cd8e727" args="(bsl::ostream &amp;stream, const ByteInStream &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslx_1_1ByteInStream.html">ByteInStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>object</code> to the specified output <code>stream</code> in some reasonable (multi-line) format, and return a reference to <code>stream</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslx__byteinstream_8h_source.html">bslx_byteinstream.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:11 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
