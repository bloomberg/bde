<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_rawdeleterguard.h                                            -*-C++-*-
#ifndef INCLUDED_BSLMA_RAWDELETERGUARD
#define INCLUDED_BSLMA_RAWDELETERGUARD

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a guard to unconditionally manage an object.
//
//@CLASSES:
//  bslma::RawDeleterGuard: guard to unconditionally manage an object
//
//@SEE_ALSO: bslma_rawdeleterproctor, bslma_autorawdeleter
//
//@DESCRIPTION: This component provides a guard class template to
// unconditionally manage an (otherwise-unmanaged) object of parameterized
// &#39;TYPE&#39; supplied at construction.  The managed object is deleted
// automatically when the guard object goes out of scope by first calling the
// (managed) object&#39;s destructor, and then freeing the memory using the
// parameterized &#39;ALLOCATOR&#39; (allocator or pool) also supplied at construction.
//
///&quot;Raw&quot; Warning
///-------------
// Note that this component should be used only if we are sure that the
// supplied pointer is !not! of a type that is a secondary base class -- i.e.,
// the (managed) object&#39;s address is (numerically) the same as when it was
// originally dispensed by &#39;ALLOCATOR&#39;.
//
///Requirement
///-----------
// The parameterized &#39;ALLOCATOR&#39; type of the &#39;bslma::RawDeleterGuard&#39; class
// template must provide a (possibly &#39;virtual&#39;) method:
//..
//  void deallocate(void *address);
//..
// to deallocate memory at the specified &#39;address&#39; (originally supplied by the
// &#39;ALLOCATOR&#39; object).
//
///Usage
///-----
// This example shows how one might use a &#39;bslma::RawDeleterGuard&#39; to guard a
// dynamically-allocated object, deleting that object automatically when the
// guard goes out of scope.
//
// Suppose we have a simple queue class that stores object values using an
// &quot;out-of-place&quot; representation (i.e., an array of dynamically-allocated
// object pointers):
//..
//  // my_queue.h
//  // ...
//
//  template &lt;class TYPE&gt;
//  class my_Queue {
//      // This class is a container that uses an &quot;out-of-place&quot;
//      // representation to manage objects of parameterized &#39;TYPE&#39;.  Note
//      // that this class is implemented with the native version of &#39;deque&#39;,
//      // instead of the version provided in &#39;bslstl_Deque&#39;.  This is so that
//      // a circular dependency in the physical hierarchy will not be created.
//
//      // DATA
//      std::deque&lt;TYPE *&gt;   d_objects;      // objects stored in the queue
//      bslma::Allocator    *d_allocator_p;  // allocator (held, not owned)
//
//    public:
//      // CREATORS
//      my_Queue(bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;my_Queue&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      // ...
//
//      ~my_Queue();
//          // Destroy this &#39;my_Queue&#39; object and all elements currently
//          // stored.
//
//      // MANIPULATORS
//
//      // ...
//
//      void pushBack(const TYPE&amp; object);
//          // Push the value of the specified &#39;object&#39; of parameterized &#39;TYPE&#39;
//          // onto the back of this queue.
//
//      TYPE popFront();
//          // Remove and return (by value) the object of parameterized &#39;TYPE&#39;
//          // that is currently at the front of this queue.
//
//      // ...
//  };
//..
// Note that the &#39;popFront&#39; method returns an object by value because (1) there
// may be no reasonable default object to pass in, (2) there may be no
// reasonable copy-assignment semantics, or (3) it is simply more syntactically
// convenient (e.g., if, say, the queued objects are themselves pointers):
//..
//  // CREATORS
//  template &lt;class TYPE&gt;
//  inline
//  my_Queue&lt;TYPE&gt;::my_Queue(bslma::Allocator *basicAllocator)
//  : d_objects(basicAllocator)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//  }
//
//  template &lt;class TYPE&gt;
//  my_Queue&lt;TYPE&gt;::~my_Queue()
//  {
//      for (int i = 0; i &lt; d_objects.size(); ++i) {
//          d_allocator_p-&gt;deleteObjectRaw(d_objects[i]);
//      }
//  }
//..
// Note that the &#39;pushBack&#39; method should be implemented with a constructor
// proxy that determines whether &#39;TYPE&#39; takes an allocator at construction (see
// &#39;bslalg_constructorproxy&#39;).  However, for the purpose of this example, the
// implementation is simplified by assuming &#39;TYPE&#39; takes an allocator.
//..
//  // MANIPULATORS
//  template &lt;class TYPE&gt;
//  inline
//  void my_Queue&lt;TYPE&gt;::pushBack(const TYPE&amp; object)
//  {
//      TYPE *tmp = (TYPE *)new(*d_allocator_p) TYPE(object);
//      d_objects.push_back(tmp);
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  TYPE my_Queue&lt;TYPE&gt;::popFront()
//  {
//      TYPE *tmp = d_objects.front();
//      d_objects.pop_front();
//
//      //***********************************************************
//      //* Note the use of the raw deleter guard on &#39;tmp&#39; (below). *
//      //***********************************************************
//
//      bslma::RawDeleterGuard&lt;TYPE, bslma::Allocator&gt;
//                                                   guard(tmp, d_allocator_p);
//
//      return *tmp;
//  }
//..
// The &#39;pushBack&#39; method defined above stores a copy of the provided object.
// The &#39;popFront&#39; method returns the leading object by value, and the
// &#39;bslma::RawDeleterGuard&#39; is used to automatically delete the copy the queue
// manages when the guard goes out of scope (i.e., when the function returns).

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DELETERHELPER
#include &lt;bslma_deleterhelper.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

                        // =====================
                        // class RawDeleterGuard
                        // =====================

template &lt;class TYPE, class ALLOCATOR&gt;
class RawDeleterGuard {
    // This class implements a guard that unconditionally deletes a managed
    // object upon destruction by first invoking the object&#39;s destructor, and
    // then invoking the &#39;deallocate&#39; method of an allocator (or pool) of
    // parameterized &#39;ALLOCATOR&#39; type supplied to it at construction.  The
    // managed object of parameterized &#39;TYPE&#39; must have been created using
    // memory provided by this allocator (or pool), which must remain valid
    // throughout the lifetime of the guard object.

    // DATA
    TYPE      *d_object_p;     // managed object
    ALLOCATOR *d_allocator_p;  // allocator or pool (held, not owned)

    // NOT IMPLEMENTED
    RawDeleterGuard(const RawDeleterGuard&amp;);
    RawDeleterGuard&amp; operator=(const RawDeleterGuard&amp;);

  public:
    // CREATORS
    RawDeleterGuard(TYPE *object, ALLOCATOR *allocator);
        // Create a raw deleter guard that unconditionally manages the
        // specified &#39;object&#39;, and that uses the specified &#39;allocator&#39; to
        // delete &#39;object&#39; upon the destruction of this guard.  The behavior is
        // undefined unless &#39;object&#39; and &#39;allocator&#39; are non-zero, and
        // &#39;allocator&#39; supplied the memory for &#39;object&#39;.  Note that &#39;allocator&#39;
        // must remain valid throughout the lifetime of this guard.

    ~RawDeleterGuard();
        // Destroy this raw deleter guard and delete the object it manages by
        // first invoking the destructor of the (managed) object, and then
        // invoking the &#39;deallocate&#39; method of the allocator (or pool) that was
        // supplied with the object at construction.
};

// ============================================================================
//                      TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

                        // ---------------------
                        // class RawDeleterGuard
                        // ---------------------

// CREATORS
template &lt;class TYPE, class ALLOCATOR&gt;
inline
RawDeleterGuard&lt;TYPE, ALLOCATOR&gt;::
RawDeleterGuard(TYPE *object, ALLOCATOR *allocator)
: d_object_p(object)
, d_allocator_p(allocator)
{
    BSLS_ASSERT_SAFE(object);
    BSLS_ASSERT_SAFE(allocator);
}

template &lt;class TYPE, class ALLOCATOR&gt;
inline
RawDeleterGuard&lt;TYPE, ALLOCATOR&gt;::~RawDeleterGuard()
{
    BSLS_ASSERT_SAFE(d_object_p);
    BSLS_ASSERT_SAFE(d_allocator_p);

    DeleterHelper::deleteObjectRaw(d_object_p, d_allocator_p);
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
