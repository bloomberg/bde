<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslma_sharedptrrep.h                                               -*-C++-*-
#ifndef INCLUDED_BSLMA_SHAREDPTRREP
#define INCLUDED_BSLMA_SHAREDPTRREP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide an abstract class for a shared object manager.
//
//@CLASSES:
//  bslma::SharedPtrRep : shared pointer representation abstract class
//
//@SEE_ALSO: bslstl_sharedptr, bslma_sharedptrrep_inplace,
//           bslma_sharedptrrep_outofplace
//
//@DESCRIPTION: This component provides a partially implemented abstract class
// for managing the lifetime of a shared object.  &#39;bslma::SharedPtrRep&#39;
// provides a count of both shared and weak references to a shared object
// (described in more detail in the next section).  In addition,
// &#39;bslma::SharedPtrRep&#39; provides protocol methods that allows a concrete
// implementation to specify what action should be taken when these reference
// counts reach zero.
//
///Shared and Weak References
///--------------------------
// There are two types of references to shared objects:
//
// 1) A shared reference allows users to share the ownership of an object and
// control its lifetime.  A shared object is destroyed only when the last
// shared reference to it is released.  The function &#39;acquireRef&#39; should be
// called when a new shared reference is created and &#39;releaseRef&#39; should be
// called when a share reference is removed.
//
// 2) A weak reference provides users conditional access to an object without
// sharing its ownership (or affecting its lifetime).  A shared object can be
// destroyed even if there are weak references to it.  The function
// &#39;acquireWeakRef&#39; should be called when a new weak reference is created and
// &#39;releaseWeakRef&#39; should be called when a weak reference is removed.
//
///Thread-Safety
///-------------
// &#39;bslma::SharedPtrRep&#39; is thread-safe provided that &#39;disposeObject&#39; and
// &#39;disposeRep&#39; are not called explicitly, meaning that all non-creator
// operations other than &#39;disposeObject&#39; and &#39;disposeRep&#39; on a given instance
// can be safely invoked simultaneously from multiple threads (&#39;disposeObject&#39;
// and &#39;disposeRep&#39; are meant to be implemented by types inheriting
// &#39;bslma::SharedPtrRep&#39;, and invoked only by &#39;releaseRef&#39; and
// &#39;releaseWeakRef&#39;).  Note that there is no thread safety guarantees for
// operations on the managed object.
//
///&#39;disposeObject&#39; and &#39;disposeRep&#39;
///--------------------------------
// &#39;disposeObject&#39; is meant to act as the destructor of the managed object and
// each derived class must override this method to perform an action that
// releases the shared object from management, such as deleting the managed
// object.  &#39;disposeObject&#39; will be called when the last shared reference to
// the object has been released using &#39;releaseRef&#39;.
//
// &#39;disposeRep&#39; is meant to act as the destructor of &#39;bslma::SharedPtrRep&#39;.
// The destructor of &#39;bslma::SharedPtrRep&#39; is declared as private and cannot be
// called.  The derived class must override &#39;disposeRep&#39; to perform an action
// such as deallocating the memory of the instance of the derived class.
// &#39;disposeRep&#39; will be called when both the last shared reference and the last
// weak reference to the object has been released using &#39;releaseRef&#39; or
// &#39;releaseWeakRef&#39;.
//
///Usage
///-----
// The following example demonstrates how to implement a shared &#39;bdet_Datetime&#39;
// using &#39;bslma::SharedPtrRep&#39;.  In this example, the implementation will store
// an object of &#39;bdet_Datetime&#39; in-place.  First, we define an implementation
// of &#39;bslma::SharedPtrRep&#39;:
//..
//  class MySharedDatetimeRepImpl : public bslma::SharedPtrRep {
//      // Implementation of &#39;bslma::SharedPtrRep&#39; for an in-place
//      // &#39;bdet_Datetime&#39; object.
//
//      // DATA
//      bslma::Allocator *d_allocator_p; // memory allocator (held, not owned)
//      bdet_Datetime     d_instance;    // in-place object
//
//    private:
//      // NOT IMPLEMENTED
//      MySharedDatetimeRepImpl(const MySharedDatetimeRepImpl&amp;);
//      MySharedDatetimeRepImpl&amp; operator=(const MySharedDatetimeRepImpl&amp;);
//
//    public:
//      // CREATORS
//      MySharedDatetimeRepImpl(bslma::Allocator *basicAllocator,
//                              int               year,
//                              int               month,
//                              int               day);
//          // Create a shared representation of a &#39;bdet_Datetime&#39; object
//          // having the specified &#39;year&#39;, &#39;month&#39; and &#39;day&#39; using the
//          // specified &#39;basicAllocator&#39; to allocate memory.
//
//      // MANIPULATORS
//      virtual void disposeRep();
//          // Dispose of this &#39;MySharedDatetimeRepImpl&#39; object.
//
//      virtual void disposeObject();
//          // Dispose of the managed &#39;bdet_Datetime&#39; object.
//
//      // ACCESSORS
//      bdet_Datetime *ptr();
//          // Return the address of the modifiable managed &#39;bdet_Datetime&#39;
//          // object.
//
//      virtual void *originalPtr() const;
//          // Return the address of the modifiable managed &#39;bdet_Datetime&#39;
//          // object.
//  };
//..
// Next, we define the implementation:
//..
//  // CREATORS
//  MySharedDatetimeRepImpl::MySharedDatetimeRepImpl(
//                                            bslma::Allocator *basicAllocator,
//                                            int               year,
//                                            int               month,
//                                            int               day)
//  : d_allocator_p(basicAllocator)
//  , d_instance(year, month, day)
//  {
//  }
//
//  void MySharedDatetimeRepImpl::disposeRep()
//  {
//      d_allocator_p-&gt;deallocate(this);
//  }
//
//  void MySharedDatetimeRepImpl::disposeObject()
//  {
//      d_instance.~bdet_Datetime();
//  }
//
//  bdet_Datetime *MySharedDatetimeRepImpl::ptr()
//  {
//      return &amp;d_instance;
//  }
//
//  void *MySharedDatetimeRepImpl::originalPtr() const {
//      return const_cast&lt;void*&gt;(static_cast&lt;const void *&gt;(&amp;d_instance));
//  }
//..
// Next, we implement a shared &#39;bdet_Datetime&#39; class.
//..
//  class MySharedDatetimePtr {
//      // This class provides a reference counted managed pointer to support
//      // shared ownership of a &#39;bdet_Datetime&#39; object.
//
//      bdet_Datetime      *d_ptr_p;  // pointer to the managed object
//      bslma::SharedPtrRep *d_rep_p;  // pointer to the representation object
//
//    private:
//      // NOT IMPLEMENTED
//      MySharedDatetimePtr&amp; operator=(const MySharedDatetimePtr&amp;);
//
//    public:
//      // CREATORS
//      MySharedDatetimePtr();
//          // Create an empty shared datetime.
//
//      MySharedDatetimePtr(bdet_Datetime* ptr, bslma::SharedPtrRep* rep);
//          // Create a shared datetime that adopts ownership of the specified
//          // &#39;ptr&#39; and the specified &#39;rep&#39;.
//
//      MySharedDatetimePtr(const MySharedDatetimePtr&amp; original);
//          // Create a shared datetime that refers to the same object managed
//          // by the specified &#39;original&#39;
//
//      ~MySharedDatetimePtr();
//          // Destroy this shared datetime and release the reference to the
//          // &#39;bdet_Datetime&#39; object to which it might be referring.  If this
//          // is the last shared reference, deleted the managed object.
//
//      // MANIPULATORS
//      void createInplace(bslma::Allocator *basicAllocator,
//                         int               year,
//                         int               month,
//                         int               day);
//          // Create a new &#39;MySharedDatetimeRepImpl&#39;, using the specified
//          // &#39;basicAllocator&#39; to supply memory, using the specified &#39;year&#39;,
//          // &#39;month&#39; and &#39;day&#39; to initialize the &#39;bdet_Datetime&#39; within the
//          // newly created &#39;MySharedDatetimeRepImpl&#39;, and make this
//          // object refer to the newly created &#39;bdet_Datetime&#39; object.
//
//      // ACCESSORS
//      bdet_Datetime&amp; operator*() const;
//          // Return a reference to the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//
//      bdet_Datetime *operator-&gt;() const;
//          // Return the address of the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//
//      bdet_Datetime *ptr() const;
//          // Return the address of the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//  };
//..
// Finally, we implement &#39;MySharedDatetimePtr&#39;:
//..
//  MySharedDatetimePtr::MySharedDatetimePtr()
//  : d_ptr_p(0)
//  , d_rep_p(0)
//  {
//  }
//
//  MySharedDatetimePtr::MySharedDatetimePtr(bdet_Datetime      *ptr,
//                                           bslma::SharedPtrRep *rep)
//  : d_ptr_p(ptr)
//  , d_rep_p(rep)
//  {
//  }
//
//  MySharedDatetimePtr::MySharedDatetimePtr(
//                                         const MySharedDatetimePtr&amp; original)
//  : d_ptr_p(original.d_ptr_p)
//  , d_rep_p(original.d_rep_p)
//  {
//      if (d_ptr_p) {
//          d_rep_p-&gt;acquireRef();
//      } else {
//          d_rep_p = 0;
//      }
//  }
//
//  MySharedDatetimePtr::~MySharedDatetimePtr()
//  {
//      if (d_rep_p) {
//          d_rep_p-&gt;releaseRef();
//      }
//  }
//
//  void MySharedDatetimePtr::createInplace(bslma::Allocator *basicAllocator,
//                                          int               year,
//                                          int               month,
//                                          int               day)
//  {
//      basicAllocator = bslma::Default::allocator(basicAllocator);
//      MySharedDatetimeRepImpl *rep = new (*basicAllocator)
//                                      MySharedDatetimeRepImpl(basicAllocator,
//                                                              year,
//                                                              month,
//                                                              day);
//      MySharedDatetimePtr temp(rep-&gt;ptr(), rep);
//      bsl::swap(d_ptr_p, temp.d_ptr_p);
//      bsl::swap(d_rep_p, temp.d_rep_p);
//  }
//
//  bdet_Datetime&amp; MySharedDatetimePtr::operator*() const
//  {
//      return *d_ptr_p;
//  }
//
//  bdet_Datetime *MySharedDatetimePtr::operator-&gt;() const
//  {
//      return d_ptr_p;
//  }
//
//  bdet_Datetime *MySharedDatetimePtr::ptr() const
//  {
//      return d_ptr_p;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_TYPEINFO
#include &lt;typeinfo&gt;
#define INCLUDED_TYPEINFO
#endif

namespace BloombergLP {
namespace bslma {

                        // ==================
                        // class SharedPtrRep
                        // ==================

class SharedPtrRep {
    // This class provides a partially implemented shared pointer
    // representation (&quot;letter&quot;) protocol.  The class provides two counters for
    // storing the number of shared and weak references, and functions to
    // increment and decrement these counters.  In addition, this class
    // provides protocol methods that allow concrete implementations to specify
    // what action should be taken when these counts reach zero.  The function
    // &#39;disposeRep&#39; is responsible for destroying this object, it is called
    // when the reference count to this object reaches zero.  Thus, the
    // destructor of this object is declared as protected and should never be
    // invoked.

    // DATA
    bsls::AtomicInt d_adjustedSharedCount;
                              // Counter storing a value that allows us to
                              // calculate the number of shared references.
                              // The numerical value of &#39;d_adjustedSharedCount&#39;
                              // is: 2 * number of shared references, plus 1 if
                              // any weak references were *ever* created.

    bsls::AtomicInt d_adjustedWeakCount;
                              // Counter storing a value that allows us to
                              // calculate the number of weak references.  The
                              // numerical value of &#39;d_adjustedWeakCount&#39; is:
                              // 2 * number of weak references, plus 1 if there
                              // are any *outstanding* shared references.

  protected:
    // PROTECTED CREATORS
    virtual ~SharedPtrRep();
        // Destroy this representation object.  Note that this destructor is
        // not intended to be invoked polymorphically, and is marked &#39;virtual&#39;
        // only to silence frequent warnings on popular compilers.

  public:
    // CLASS METHODS
    static void managedPtrDeleter(void *, void *rep);
        // Release the shared reference to an object held by the &#39;SharedPtrRep&#39;
        // object which is pointed to be by specified &#39;rep&#39;.  The behavior is
        // undefined unless &#39;rep&#39; points to an object whose complete type
        // publicly and unambiguously derives from &#39;SharedPtrRep&#39;.  Note that
        // the first argument is ignored.  Also note that this function serves
        // as the managed ptr deleter when converting a &#39;bsl::shared_ptr&#39; to a
        // &#39;bslma::ManagedPtr&#39;.

    // CREATORS
    SharedPtrRep();
        // Create a &#39;SharedPtrRep&#39; object having one shared reference and no
        // weak references.

    // PURE VIRTUAL FUNCTIONS
    virtual void disposeObject() = 0;
        // Dispose of the shared object referred to by this representation.
        // This method is automatically invoked by &#39;releaseRef&#39; when the number
        // of shared references reaches zero and should not be explicitly
        // invoked otherwise.  Note that this virtual &#39;disposeObject&#39; method
        // effectively serves as the shared object&#39;s destructor.  Also note
        // that derived classes must override this method to perform the
        // appropriate action such as deleting the shared object.

    virtual void disposeRep() = 0;
        // Dispose of this representation object.  This method is automatically
        // invoked by &#39;releaseRef&#39; and &#39;releaseWeakRef&#39; when the number of weak
        // references and the number of shared references both reach zero and
        // should not be explicitly invoked otherwise.  The behavior is
        // undefined unless &#39;disposeObject&#39; has already been called for this
        // representation.  Note that this virtual &#39;disposeRep&#39; method
        // effectively serves as the representation object&#39;s destructor.  Also
        // note that derived classes must override this method to perform
        // appropriate action such as deleting this representation, or
        // returning it to an object pool.

    virtual void *getDeleter(const std::type_info&amp; type) = 0;
        // Return a pointer to the deleter stored by the derived representation
        // (if any) if the deleter has the same type as that described by the
        // specified &#39;type&#39;, and a null pointer otherwise.  Note that while
        // this methods appears to be a simple accessor, it is declared as non-
        // &#39;const&#39; qualified to support representations storing the deleter
        // directly as a data member.

    virtual void *originalPtr() const = 0;
        // Return the (untyped) address of the modifiable shared object
        // referred to by this representation.

    // MANIPULATORS
    void acquireRef();
        // Atomically acquire a shared reference to the shared object referred
        // to by this representation.  The behavior is undefined unless
        // &#39;0 &lt; numReferences()&#39;.

    void acquireWeakRef();
        // Atomically acquire a weak reference to the shared object referred to
        // by this representation.  The behavior is undefined unless
        // &#39;0 &lt; numWeakReferences() || 0 &lt; numReferences()&#39;.


    void releaseRef();
        // Atomically release a shared reference to the shared object referred
        // to by this representation, disposing of the shared object if all the
        // shared references to that object are released, and disposing of this
        // representation if all (shared and weak) references to that object
        // are released.  The behavior is undefined unless
        // &#39;0 &lt; numReferences()&#39;.

    void releaseWeakRef();
        // Atomically release a weak reference to the shared object referred to
        // by this representation, disposing of this representation if all
        // (shared and weak) references to the shared object are released.  The
        // behavior is undefined unless &#39;0 &lt; numWeakReferences()&#39;.

    void resetCountsRaw(int numSharedReferences, int numWeakReferences);
        // Reset the number of shared references and the number of weak
        // references stored by this representation to the specified
        // &#39;numSharedReferences&#39; and &#39;numWeakReferences&#39; respectively.  This
        // function is *not* thread-safe and users must ensure that they
        // serialize access to the &#39;SharedPtrRep&#39; object when calling this
        // function.  Note that this function updates the counts, but does not
        // dispose of the representation or the object irrespective of the
        // values of &#39;numSharedReferences&#39; and &#39;numWeakReferences&#39;.

    bool tryAcquireRef();
        // Atomically acquire a shared reference to the shared object referred
        // to by this representation, if the number of shared references is
        // greater than 0, and do nothing otherwise.  Return &#39;true&#39; if the
        // acquire succeeds, and &#39;false&#39; otherwise.  The behavior is undefined
        // unless &#39;0 &lt; numWeakReferences() || 0 &lt; numReferences()&#39;.

    // ACCESSORS
    bool hasUniqueOwner() const;
        // Return &#39;true&#39; if there is only one shared reference and no weak
        // references to the object referred to by this representation, and
        // &#39;false&#39; otherwise.

    int numReferences() const;
        // Return a &quot;snapshot&quot; of the current number of shared references to
        // the shared object referred to by this representation object.

    int numWeakReferences() const;
        // Return a &quot;snapshot&quot; of the current number of weak references to the
        // shared object referred to by this representation object.

};

// ============================================================================
//              INLINE FUNCTION AND FUNCTION TEMPLATE DEFINITIONS
// ============================================================================

                        // ------------------
                        // class SharedPtrRep
                        // ------------------

// PROTECTED CREATORS
inline
SharedPtrRep::~SharedPtrRep()
{
}

// CLASS METHODS
inline
void SharedPtrRep::managedPtrDeleter(void *, void *rep)
{
    BSLS_ASSERT_SAFE(rep);

    static_cast&lt;SharedPtrRep *&gt;(rep)-&gt;releaseRef();
}

// CREATORS
inline
SharedPtrRep::SharedPtrRep()
: d_adjustedSharedCount(2)                      // minimum consistency: relaxed
, d_adjustedWeakCount(1)                        // minimum consistency: relaxed
{
}

// MANIPULATORS
inline
void SharedPtrRep::acquireRef()
{
    BSLS_ASSERT_SAFE(0 &lt; numReferences());

    d_adjustedSharedCount.addRelaxed(2);        // minimum consistency: relaxed
}


inline
void SharedPtrRep::releaseWeakRef()
{
    BSLS_ASSERT_SAFE(0 &lt; numWeakReferences());

    const int weakCount = d_adjustedWeakCount.add(-2);
                                        // release consistency: acquire/release
    if (0 == weakCount) {
        disposeRep();
    }
}

// ACCESSORS
inline
bool SharedPtrRep::hasUniqueOwner() const
{
    const int sharedCount = d_adjustedSharedCount;
                                                // release consistency: acquire
    return 2 == sharedCount
        || (3 == sharedCount
         &amp;&amp; 1 == d_adjustedWeakCount);          // release consistency: acquire
}

inline
int SharedPtrRep::numReferences() const
{
    const int sharedCount = d_adjustedSharedCount.loadRelaxed();
                                                // minimum consistency: relaxed
    return sharedCount / 2;
}

inline
int SharedPtrRep::numWeakReferences() const
{
    const int weakCount = d_adjustedWeakCount.loadRelaxed();
                                                // minimum consistency: relaxed
    return weakCount / 2;
}

}  // close namespace bslma
}  // close namespace BloombergLP

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
