<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_hashtableiterator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Component bslstl_hashtableiterator<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL compliant iterator for hash tables.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
</table>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Iterating a Hash Table Using <code>HashTableIterator</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL compliant iterator for hash tables. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslstl::HashTableIterator </td><td>an STL compliant forward iterator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__bidirectionallink.html" title="Provide a basic link type for building doubly-linked lists.">Component bslalg_bidirectionallink</a>, <a class="el" href="group__bslstl__unorderedmap.html" title="Provide an STL-compliant unordered_map container.">Component bslstl_unorderedmap</a>, <a class="el" href="group__bslstl__unorderedset.html" title="Provide an STL-compliant unordered_set container.">Component bslstl_unorderedset</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a standard-conforming forward iterator, <code>bslstl::HashTableIterator</code>, over a list of elements (of type <code><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a></code>) in a hashtable. The requirements of a forward iterator are outlined in the C++11 standard in section [24.2.5] under the tag [forward.iterators]. The <code>bslstl::HashTableIterator</code> class template has two template parameters: <code>VALUE_TYPE</code>, and <code>DIFFERENCE_TYPE</code>. <code>VALUE_TYPE</code> indicates the type of the value to which this iterator provides references, and may be const-qualified for constant iterators. <code>DIFFERENCE_TYPE</code> determines the (standard mandated) <code>difference_type</code> for the iterator, and will typically be supplied by the allocator used by the hash-table being iterated over. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_iterating_a_hash_table_using_hashtableiterator"></a> <a class="anchor" id="usage.example_1~3A_iterating_a_hash_table_using_hashtableiterator"></a> <a class="anchor" id="description.usage.example_1~3A_iterating_a_hash_table_using_hashtableiterator"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Iterating a Hash Table Using HashTableIterator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following example we create a simple hashtable and then use a <code>HashTableIterator</code> to iterate through its elements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a typedef, <code>Node</code>, prepresenting a bidirectional node holding an integer value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode&lt;int&gt;</a> Node;
</pre></div><br/>
<br/>
 Then, we construct a test allocator, and we use it to allocate an array of <code>Node</code> objects, each holding a unique integer value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> scratch;

  <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_NODES = 5;
  <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_BUCKETS = 3;

  Node *nodes[NUM_NODES];
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_NODES; ++i) {
      nodes[i] = <span class="keyword">static_cast&lt;</span>Node *<span class="keyword">&gt;</span>(scratch.<a class="code" href="classbslma_1_1TestAllocator.html#adadeba443e1ea37730a9cf936a600e56">allocate</a>(<span class="keyword">sizeof</span>(Node)));
      nodes[i]-&gt;value() = i;
  }
</pre></div><br/>
<br/>
 Next, we create an array of <code>HashTableBuckets</code> objects, and we use the array to construct an empty hash table characterized by a <code>HashTableAnchor</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> buckets[NUM_BUCKETS];
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_BUCKETS; ++i) {
      buckets[i].<a class="code" href="structbslalg_1_1HashTableBucket.html#aee49bf0cdaa6765ea776783cc7ba53dc">reset</a>();
  }
  <a class="code" href="classbslalg_1_1HashTableAnchor.html">bslalg::HashTableAnchor</a> hashTable(buckets, NUM_BUCKETS, 0);
</pre></div><br/>
<br/>
 Then, we insert each node in the array of nodes into the hash table using <code><a class="el" href="structbslalg_1_1HashTableImpUtil.html">bslalg::HashTableImpUtil</a></code>, supplying the integer value held by each node as its hash value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_NODES; ++i) {
      <a class="code" href="structbslalg_1_1HashTableImpUtil.html#af289c0c8a875ea816b8d938b02f268be">bslalg::HashTableImpUtil::insertAtFrontOfBucket</a>(&amp;hashTable,
                                                      nodes[i],
                                                      nodes[i]-&gt;value());
  }
</pre></div><br/>
<br/>
 Next, we define a <code>typedef</code> that is an alias an instance of <code>HashTableIterator</code> that can traverse hash tables holding integer values. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> bslstl::HashTableIterator&lt;int, ptrdiff_t&gt; Iter;
</pre></div><br/>
<br/>
 Now, we create two iterators: one pointing to the start of the bidirectional linked list held by the hash table, and the other representing the end sentinel. We use them to navigate and print the elements of the hash table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Iter iter(hashTable.listRootAddress());
  Iter end;
  <span class="keywordflow">for</span> (;iter != end; ++iter) {
      printf(<span class="stringliteral">&quot;%d\n&quot;</span>, *iter);
  }
</pre></div><br/>
<br/>
 Then, we observe the following output: <br/>
<br/>
<div class="fragment"><pre class="fragment"> 2
 4
 1
 3
 0
</pre></div><br/>
<br/>
 Finally, we deallocate the memory used by the hash table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_NODES; ++i) {
      scratch.<a class="code" href="classbslma_1_1TestAllocator.html#aa3d86f105cc1a797cfa5ad9e2bbf6825">deallocate</a>(nodes[i]);
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:04 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
