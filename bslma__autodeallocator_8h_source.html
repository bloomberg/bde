<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslma_autodeallocator.h                                            -*-C++-*-
#ifndef INCLUDED_BSLMA_AUTODEALLOCATOR
#define INCLUDED_BSLMA_AUTODEALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a range proctor to managed a block of memory.
//
//@CLASSES:
//  bslma::AutoDeallocator: range proctor to manage a block of memory
//
//@SEE_ALSO: bslma_deallocatorguard, bslma_deallocatorproctor
//
//@DESCRIPTION: This component provides a range proctor class template to
// manage a sequence of blocks of (otherwise-unmanaged) memory of parameterized
// &#39;TYPE&#39; supplied at construction.  If not explicitly released, the sequence
// of managed memory blocks are deallocated automatically when the range
// proctor goes out of scope by freeing the memory using the parameterized
// &#39;ALLOCATOR&#39; (allocator or pool) supplied at construction.  Note that after a
// range proctor releases its managed sequence of memory, the same proctor can
// be reused to conditionally manage another sequence of memory (allocated from
// the same allocator or pool that was supplied at construction) by invoking
// the &#39;reset&#39; method.
//
///Requirement
///-----------
// The parameterized &#39;ALLOCATOR&#39; type of the &#39;bslma::AutoRawDeleter&#39; class
// template must provide a (possibly &#39;virtual&#39;) method:
//..
//  void deallocate(void *address);
//..
// to deallocate memory at the specified &#39;address&#39; (originally supplied by the
// &#39;ALLOCATOR&#39; object).
//
///Usage
///-----
// The &#39;bslma::AutoDeallocator&#39; proctor object can be used to achieve
// *exception* *safety* in an *exception* *neutral* way during manipulation of
// &quot;out-of-place&quot; arrays of raw resources or memory.  Since there are no
// destructor calls, this component is more efficient compared to the
// &#39;bslma::AutoRawDeleter&#39;.  The following illustrates the insertion operation
// for an &quot;out-of-place&quot; array of raw character sequences.  Assume that an
// array initially contains 5 character sequences as its elements:
//..
//     0     1     2     3     4
//   _____ _____ _____ _____ _____
//  |  o  |  o  |  o  |  o  |  o  |
//  `==|==^==|==^==|==^==|==^==|==&#39;
//     |    _V___  |   __V___  |
//     |   |&quot;Bye&quot;| |  |&quot;berg&quot;| |
//     |   `=====&#39; |  `======&#39; |
//    _V_____     _V_____     _V__
//   |&quot;Hello&quot;|   |&quot;Bloom&quot;|   |&quot;LP&quot;|
//   `=======&#39;   `=======&#39;   `====&#39;
//..
// To insert two more character sequences at index position 2, the array is
// first reallocated if it is not big enough, and then the existing elements at
// index positions 2, 3, and 4 are shifted:
//..
//     0     1     2     3     4     5     6
//   _____ _____ _____ _____ _____ _____ _____
//  |  o  |  o  |xxxxx|xxxxx|  o  |  o  |  o  |
//  `==|==^==|==^=====^=====^==|==^==|==^==|==&#39;
//     |    _V___              |   __V___  |
//     |   |&quot;Bye&quot;|             |  |&quot;berg&quot;| |
//     |   `=====&#39;             |  `======&#39; |
//    _V_____                 _V_____     _V__
//   |&quot;Hello&quot;|               |&quot;Bloom&quot;|   |&quot;LP&quot;|
//   `=======&#39;               `=======&#39;   `====&#39;
//
//  Note: &quot;xxxxx&quot; denotes undefined value.
//..
// Next, two new memory blocks must be allocated to position 2 and 3.  If, one
// of the two allocations fails and an exception is thrown, the array will be
// left in an invalid state because the addresses contained at index positions
// 2 and 3 may be duplicates of those at index positions 4 and 5, or, if a
// resize occurred, invalid altogether.  We can restore exception neutrality by
// setting the array&#39;s length to 2 before attempting to create the string
// objects, but there is still a problem: the character sequences &quot;Bloom&quot;,
// &quot;berg&quot;, and &quot;LP&quot; (at index positions 4, 5, and 6) are &quot;orphaned&quot; and will
// never be deallocated -- a memory leak.  To prevent this potential memory
// leak, we can additionally create a &#39;bslma::AutoDeallocator&#39; object to manage
// (temporarily) the memory at index positions 4, 5, and 6 prior to allocating
// the new memory:
//..
//      0     1     2     3     4     5     6
//    _____ _____ _____ _____ _____ _____ _____
//   |  o  |  o  |xxxxx|xxxxx|  o  |  o  |  o  |
//   `==|==^==|==^=====^=====^==|==^==|==^==|==&#39;
//      |    _V___              |   __V___  |
//      |   |&quot;Bye&quot;|             |  |&quot;berg&quot;| |
//      |   `=====&#39;             |  `======&#39; |
//     _V_____                 _V_____     _V__
//    |&quot;Hello&quot;|               |&quot;Bloom&quot;|   |&quot;LP&quot;|
//    `=======&#39;               `=======&#39;   `====&#39;
//   my_StrArray              ^---------------bslma::AutoDeallocator
//   (length = 2)                          (origin = 4, length = 3)
//
//  Note: Configuration after initializing the proctor.
//..
// If an exception occurs, the array (now of length 2) is in a perfectly valid
// state, while the proctor is responsible for deallocating the orphaned memory
// at index positions 4, 5, and 6.  If no exception is thrown, the length is
// set to 7 and the proctor&#39;s &#39;release&#39; method is called, releasing its control
// over the (temporarily) managed memory.
//
// The following example illustrates the use of &#39;bslma::AutoDeallocator&#39; to
// manage temporarily an &quot;out-of-place&quot; array of character sequences during the
// array&#39;s insertion operation.
//
// First we define a &#39;my_StrArray&#39; class which stores an array of character
// sequences.
//..
//  // my_strarray.h
//  // ...
//
//  template &lt;class ALLOCATOR&gt;
//  class my_StrArray {
//      // This class is a container that stores an array of character
//      // sequences.  Memory will be supplied by the parameterized &#39;ALLOCATOR&#39;
//      // type provided at construction (which must remain valid throughout
//      // the lifetime of this guard object).  Note that memory is managed by
//      // a parameterized &#39;ALLOCATOR&#39; type, instead of a &#39;bslma::Allocator&#39;, to
//      // enable clients to pass in a pool (such as a sequential pool)
//      // optimized for allocations of character sequences.
//
//      // DATA
//      char      **d_array_p;      // dynamically allocated array of character
//                                  // sequence
//
//      int         d_length;       // logical length of this array
//
//      int         d_size;         // physical capacity of this array
//
//      ALLOCATOR  *d_allocator_p;  // allocator or pool (held, not owned)
//
//    public:
//      // CREATORS
//      my_StrArray(ALLOCATOR *basicAllocator);
//          // Create a &#39;my_StrArray&#39; object using the specified
//          // &#39;basicAllocator&#39; used to supply memory.
//
//      ~my_StrArray();
//          // Destroy this &#39;my_StrArray&#39; object and all elements currently
//          // stored.
//
//      // MANIPULATORS
//      void append(const char *src);
//          // Append to this array the string &#39;src&#39;.
//
//      void insert(int dstIndex, const my_StrArray&amp; srcArray);
//          // Insert into this array at the specified &#39;dstIndex&#39;, the
//          // character sequences in the specified &#39;srcArray&#39;.  All values
//          // with initial indices at or above &#39;dstIndex&#39; are shifted up by
//          // unless &#39;0 &lt;= dstIndex&#39; and &#39;dstIndex &lt;= length()&#39;.  Note that
//          // this method is functionally the same as &#39;insert2&#39;, but has a
//          // different implementation to facilitate the usage example.
//
//      void insert2(int dstIndex, const my_StrArray&amp; srcArray);
//          // Insert into this array at the specified &#39;dstIndex&#39;, the
//          // character sequences in the specified &#39;srcArray&#39;.  All values
//          // with initial indices at or above &#39;dstIndex&#39; are shifted up by
//          // unless &#39;0 &lt;= dstIndex&#39; and &#39;dstIndex &lt;= length()&#39;.  Note that
//          // this method is functionally the same as &#39;insert&#39;, but has a
//          // different implementation to facilitate the usage example.
//
//      // ...
//
//      // ACCESSORS
//      int length() const;
//          // Return the logical length of this array.
//
//      const char *operator[](int index) const;
//          // Return a pointer to the &#39;index&#39;th string in the array.  Note
//          // the pointer is returned by value, it is not a reference to a
//          // pointer.
//
//      // ...
//  };
//..
// Next, we define the &#39;insert&#39; method of &#39;my_StrArray&#39;:
//..
//  template &lt;class ALLOCATOR&gt;
//  void my_StrArray&lt;ALLOCATOR&gt;::insert(int                           dstIndex,
//                                      const my_StrArray&lt;ALLOCATOR&gt;&amp; srcArray)
//  {
//      int srcLength  = srcArray.d_length;
//      int newLength  = d_length + srcLength;
//      int numShifted = d_length - dstIndex;
//
//      if (newLength &gt; d_size) {
//          while (d_size &lt; newLength) {
//              d_size = ! d_size ? 1 : 2 * d_size;
//          }
//
//          char ** newArray =
//                  (char **) d_allocator_p-&gt;allocate(d_size * sizeof(char *));
//          memcpy(newArray, d_array_p, d_length * sizeof(char *));
//          if (d_array_p) {
//              d_allocator_p-&gt;deallocate(d_array_p);
//          }
//          d_array_p = newArray;
//      }
//
//      char **tmpSrc = srcArray.d_array_p;
//      if (this == &amp;srcArray) {
//          // self-alias
//          int size = srcLength * sizeof(char *);
//          tmpSrc = (char **) d_allocator_p-&gt;allocate(size);
//          memcpy(tmpSrc, d_array_p, size);
//      }
//      bslma::DeallocatorProctor&lt;ALLOCATOR&gt; proctor(
//                                              this == &amp;srcArray ? tmpSrc : 0,
//                                              d_allocator_p);
//
//      // First shift the elements to the back of the array.
//      memmove(d_array_p + dstIndex + srcLength,
//              d_array_p + dstIndex,
//              numShifted * sizeof *d_array_p);
//
//      // Shorten &#39;d_length&#39; and use &#39;bslma::AutoDeallocator&#39; to proctor the
//      // memory shifted.
//      d_length = dstIndex;
//
//      //*******************************************************
//      // Note use of auto deallocator on tail memory (below). *
//      //*******************************************************
//
//      bslma::AutoDeallocator&lt;ALLOCATOR&gt; tailDeallocator(
//                                  (void **) d_array_p + dstIndex + srcLength,
//                                  d_allocator_p,
//                                  numShifted);
//..
// Now, if any allocation for the inserted character sequences throws, the
// memory used for the character sequences that had been moved to the end of
// array will be deallocated automatically by the &#39;bslma::AutoDeallocator&#39;.
//..
//      // Copy the character sequences from the &#39;srcArray&#39;.
//      for (int i = 0; i &lt; srcLength; ++i, ++d_length) {
//          std::size_t size = std::strlen(tmpSrc[i]) + 1;
//          d_array_p[dstIndex + i] = (char *) d_allocator_p-&gt;allocate(size);
//          memcpy(d_array_p[dstIndex + i], tmpSrc[i], size);
//      }
//
//      //*********************************************
//      // Note that the proctor is released (below). *
//      //*********************************************
//
//      tailDeallocator.release();
//      d_length = newLength;
//  }
//..
// The above method copies the source elements (visually) from left to right.
// Another (functionally equivalent) implementation copies the source elements
// from right to left, and makes use of the &#39;operator--()&#39; of the
// &#39;bslma::AutoDeallocator&#39; interface:
//..
//  template &lt;class ALLOCATOR&gt;
//  void my_StrArray&lt;ALLOCATOR&gt;::insert2(int                          dstIndex,
//                                      const my_StrArray&lt;ALLOCATOR&gt;&amp; srcArray)
//  {
//      int srcLength  = srcArray.d_length;
//      int newLength  = d_length + srcLength;
//      int numShifted = d_length - dstIndex;
//
//      if (newLength &gt; d_size) {
//          while (d_size &lt; newLength) {
//              d_size = ! d_size ? 1 : 2 * d_size;
//          }
//
//          char ** newArray =
//                  (char **) d_allocator_p-&gt;allocate(d_size * sizeof(char *));
//          memcpy(newArray, d_array_p, d_length * sizeof(char *));
//          if (d_array_p) {
//              d_allocator_p-&gt;deallocate(d_array_p);
//          }
//          d_array_p = newArray;
//      }
//
//      char **tmpSrc = srcArray.d_array_p;
//      if (this == &amp;srcArray) {
//          // self-alias
//          int size = srcLength * sizeof(char *);
//          tmpSrc = (char **) d_allocator_p-&gt;allocate(size);
//          memcpy(tmpSrc, d_array_p, size);
//      }
//      bslma::DeallocatorProctor&lt;ALLOCATOR&gt; proctor(
//                                              this == &amp;srcArray ? tmpSrc : 0,
//                                              d_allocator_p);
//
//      // First shift the elements to the back of the array.
//      memmove(d_array_p + dstIndex + srcLength,
//              d_array_p + dstIndex,
//              numShifted * sizeof *d_array_p);
//
//      // Shorten &#39;d_length&#39; and use &#39;bslma::AutoDeallocator&#39; to proctor the
//      // memory shifted.
//      d_length = dstIndex;
//
//      //********************************************
//      //* Note the use of auto deallocator on tail *
//      //* memory with negative length (below).     *
//      //********************************************
//
//      bslma::AutoDeallocator&lt;ALLOCATOR&gt; tailDeallocator(
//                     (void **) d_array_p + d_length + srcLength + numShifted,
//                     d_allocator_p,
//                     -numShifted);
//..
// Since we have decided to copy the source elements from right to left, we set
// the origin of the &#39;bslma::AutoDeallocator&#39; to the end of the array, and
// decrement the (signed) length on each copy to extend the proctor range by 1.
//..
//      // Copy the character sequences from the &#39;srcArray&#39;.  Note that the
//      // &#39;tailDeallocator&#39; has to be decremented to cover the newly
//      // created object.
//
//      for (int i = srcLength - 1; i &gt;= 0; --i, --tailDeallocator) {
//          std::size_t size = std::strlen(tmpSrc[i]) + 1;
//          d_array_p[dstIndex + i] = (char *)d_allocator_p-&gt;allocate(size);
//          memcpy(d_array_p[dstIndex + i], tmpSrc[i], size);
//      }
//
//      //*********************************************
//      // Note that the proctor is released (below). *
//      //*********************************************
//
//      tailDeallocator.release();
//      d_length = newLength;
//  }
//..
// Note that though the two implementations are functionally equivalent, they
// are logically different.  First of all, the second implementation will be
// slightly slower because it is accessing memory backwards when compared to
// the normal forward sequential access.  Secondly, in case of an exception,
// the first implementation will retain all the elements copied prior to the
// exception, whereas the second implementation will remove them.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

                        // =====================
                        // class AutoDeallocator
                        // =====================

template &lt;class ALLOCATOR&gt;
class AutoDeallocator {
    // This class implements a range proctor that, unless its &#39;release&#39; method
    // has previously been invoked, automatically deallocates the contiguous
    // sequence of managed memory blocks upon its own destruction by invoking
    // the &#39;deallocate&#39; method of an allocator (or pool) of parameterized
    // &#39;ALLOCATOR&#39; type supplied to it at construction.  Each of the managed
    // memory blocks must have been supplied by this allocator (or pool), which
    // must remain valid throughout the lifetime of the range proctor.  Note
    // that when the length of this object is non-zero, it must refer to a
    // non-null array of memory blocks.

    // DATA
    void      **d_origin_p;     // reference location for the sequence of
                                // managed memory

    int         d_length;       // number of memory blocks managed (sign
                                // encodes direction)

    ALLOCATOR  *d_allocator_p;  // allocator or pool (held, not owned)

    // NOT IMPLEMENTED
    AutoDeallocator(const AutoDeallocator&amp;);
    AutoDeallocator&amp; operator=(const AutoDeallocator&amp;);

  private:
    // PRIVATE MANIPULATORS
    void deallocate();
        // Deallocate the contiguous sequence of memory blocks managed by this
        // auto deallocator (if any) by invoking the &#39;deallocate&#39; method of the
        // allocator (or pool) supplied at construction on each memory block.
        // Note that the order in which the managed memory blocks are
        // deallocated is undefined.  Also note that this method factors out
        // the deallocation logic, which allows the destructor to be declared
        // &#39;inline&#39; for the common case (the range proctor is released before
        // being destroyed).

  public:
    // CREATORS
    template &lt;class TYPE&gt;
    AutoDeallocator(TYPE      **origin,
                    ALLOCATOR  *allocator,
                    int         length = 0);
    AutoDeallocator(void      **origin,
                    ALLOCATOR  *allocator,
                    int         length = 0);
        // Create an auto deallocator to manage a sequence of memory blocks at
        // the specified &#39;origin&#39;, and that uses the specified &#39;allocator&#39; to
        // deallocate the sequence of memory blocks managed by this range
        // proctor (if not released -- see &#39;release&#39;) upon destruction.
        // Optionally specify &#39;length&#39; to define its range, which by default is
        // empty (i.e., &#39;length = 0&#39;).  The sequence of memory blocks may
        // extend in either direction from &#39;origin&#39;.  A positive &#39;length&#39;
        // represents the sequence of memory blocks starting at &#39;origin&#39; and
        // extending &quot;up&quot; to &#39;length&#39; (*not* including the memory block at the
        // index position &#39;origin + length&#39;).  A negative &#39;length&#39; represents
        // the sequence of memory blocks starting at one position below
        // &#39;origin&#39; and extending &quot;down&quot; to the absolute value of &#39;length&#39;
        // (including the memory block at index position &#39;origin + length&#39;).
        // If &#39;length&#39; is 0, then this range proctor manages no memory blocks.
        // If &#39;origin&#39; is non-zero, all memory blocks within the proctored
        // range (if any) must be supplied by &#39;allocator&#39;.  The behavior is
        // undefined unless &#39;allocator&#39; is non-zero, and, if &#39;origin&#39; is 0,
        // &#39;length&#39; is also 0.  Note that when &#39;length&#39; is non-positive, the
        // memory block at the origin is *not* managed by this range proctor.
        // For example, if &#39;origin&#39; is at the index position 2, a &#39;length&#39; of 2
        // signifies that the memory blocks at positions 2 and 3 are managed,
        // whereas a &#39;length&#39; of -2 signifies that the memory blocks at
        // positions 0 and 1 are managed:
        //..
        //     length = -2                            length = 2
        //     |&lt;-----&gt;|                              |&lt;-----&gt;|
        //      ___ ___ ___ ___ ___            ___ ___ ___ ___ ___
        //     | 0 | 1 | 2 | 3 | 4 |          | 0 | 1 | 2 | 3 | 4 |
        //     `===^===^===^===^===&#39;          `===^===^===^===^===&#39;
        //             ^------------ origin           ^------------ origin
        //..

    ~AutoDeallocator();
        // Destroy this range proctor and deallocate the contiguous sequence of
        // memory blocks it manages (if any) by invoking the &#39;deallocate&#39;
        // method of the allocator (or pool) supplied at construction on each
        // memory block.  Note that the order in which the managed memory
        // blocks are deallocated is undefined.

    // MANIPULATORS
    void operator++();
        // Increase by one the (signed) length of the sequence of memory blocks
        // managed by this range proctor.  The behavior is undefined unless the
        // origin of the sequence of memory blocks managed by this proctor is
        // non-zero.  The behavior is undefined unless the origin or this range
        // proctor is non-zero.  Note that if the length of this proctor is
        // currently negative, the number of managed memory blocks will
        // decrease by one, whereas if the length is non-negative, the number
        // of managed memory blocks will increase by one.

    void operator--();
        // Decrease by one the (signed) length of the sequence of memory blocks
        // managed by this range proctor.  The behavior is undefined unless the
        // origin of the sequence of memory blocks managed by this proctor is
        // non-zero.  The behavior is undefined unless the origin or this range
        // proctor is non-zero.  Note that if the length of this proctor is
        // currently positive, the number of managed memory blocks will
        // decrease by one, whereas if the length is non-positive, the number
        // of managed memory blocks will increase by one.

    void release();
        // Release from management the sequence of memory blocks currently
        // managed by this range proctor by setting the length of the managed
        // sequence to 0.  All memory blocks currently under management will
        // become unmanaged (i.e., when the proctor goes out of scope and it
        // was not assigned another sequence of memory blocks to manage by
        // invoking &#39;reset&#39;, no memory blocks will be deallocated).  If no
        // memory blocks are currently being managed, this method has no
        // effect.  Note that the origin is not affected.

    template &lt;class TYPE&gt;
    void reset(TYPE **origin);
    void reset(void **origin);
        // Set the specified &#39;origin&#39; as the origin of the sequence of memory
        // blocks to be managed by this range proctor.  The behavior is
        // undefined unless &#39;origin&#39; is non-zero.  Note that the length of the
        // sequence of memory blocks managed by this proctor is not affected,
        // and &#39;setLength&#39; should be invoked if the managed range is different
        // from the previously managed sequence of memory blocks.  Also note
        // that this method releases any previously-managed memory blocks from
        // management (without deallocating them), and so may be called with or
        // without having called &#39;release&#39; when reusing this object.

    void setLength(int length);
        // Set the (signed) length of the sequence of memory blocks managed by
        // this range proctor to the specified &#39;length&#39;.  The behavior is
        // undefined unless the origin of this range proctor is non-zero.

    // ACCESSORS
    int length() const;
        // Return the (signed) length of the sequence of memory blocks managed
        // by this proctor.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // ---------------------
                        // class AutoDeallocator
                        // ---------------------

// PRIVATE MANIPULATORS
template &lt;class ALLOCATOR&gt;
void AutoDeallocator&lt;ALLOCATOR&gt;::deallocate()
{
    if (d_length &gt; 0) {
        for (; d_length &gt; 0; --d_length, ++d_origin_p) {
            d_allocator_p-&gt;deallocate(*d_origin_p);
        }
    }
    else {
        --d_origin_p;
        for (; d_length &lt; 0; ++d_length, --d_origin_p) {
            d_allocator_p-&gt;deallocate(*d_origin_p);
        }
    }
}

// CREATORS
template &lt;class ALLOCATOR&gt;
template &lt;class TYPE&gt;
inline
AutoDeallocator&lt;ALLOCATOR&gt;
::AutoDeallocator(TYPE      **origin,
                  ALLOCATOR  *allocator,
                  int         length)
: d_origin_p((void **)origin)
, d_length(length)
, d_allocator_p(allocator)
{
    BSLS_ASSERT_SAFE(allocator);
    BSLS_ASSERT_SAFE(origin || !length);
}

template &lt;class ALLOCATOR&gt;
inline
AutoDeallocator&lt;ALLOCATOR&gt;
::AutoDeallocator(void      **origin,
                  ALLOCATOR  *allocator,
                  int         length)
: d_origin_p(origin)
, d_length(length)
, d_allocator_p(allocator)
{
    BSLS_ASSERT_SAFE(allocator);
    BSLS_ASSERT_SAFE(origin || !length);
}

template &lt;class ALLOCATOR&gt;
inline
AutoDeallocator&lt;ALLOCATOR&gt;::~AutoDeallocator()
{
    BSLS_ASSERT_SAFE(d_origin_p || !d_length);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_length)) {
        deallocate();
    }
}

// MANIPULATORS
template &lt;class ALLOCATOR&gt;
inline
void AutoDeallocator&lt;ALLOCATOR&gt;::operator++()
{
    BSLS_ASSERT_SAFE(d_origin_p);

    ++d_length;
}

template &lt;class ALLOCATOR&gt;
inline
void AutoDeallocator&lt;ALLOCATOR&gt;::operator--()
{
    BSLS_ASSERT_SAFE(d_origin_p);

    --d_length;
}

template &lt;class ALLOCATOR&gt;
inline
void AutoDeallocator&lt;ALLOCATOR&gt;::release()
{
    d_length = 0;
}

template &lt;class ALLOCATOR&gt;
template &lt;class TYPE&gt;
inline
void AutoDeallocator&lt;ALLOCATOR&gt;::reset(TYPE **origin)
{
    BSLS_ASSERT_SAFE(origin);

    d_origin_p = (void **)origin;
}

template &lt;class ALLOCATOR&gt;
inline
void AutoDeallocator&lt;ALLOCATOR&gt;::reset(void **origin)
{
    BSLS_ASSERT_SAFE(origin);

    d_origin_p = origin;
}

template &lt;class ALLOCATOR&gt;
inline
void
AutoDeallocator&lt;ALLOCATOR&gt;::setLength(int length)
{
    BSLS_ASSERT_SAFE(d_origin_p);

    d_length = length;
}

// ACCESSORS
template &lt;class ALLOCATOR&gt;
inline
int AutoDeallocator&lt;ALLOCATOR&gt;::length() const
{
    return d_length;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
