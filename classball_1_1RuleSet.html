<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class ball::RuleSet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceball.html">ball</a>      </li>
      <li><a class="el" href="classball_1_1RuleSet.html">ball::RuleSet</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>ball::RuleSet Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ball::RuleSet" -->
<p><code>#include &lt;<a class="el" href="ball__ruleset_8h_source.html">ball_ruleset.h</a>&gt;</code></p>

<p><a href="classball_1_1RuleSet-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RuleHash</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classball_1_1RuleSet.html#a098c31eb413bb8a14151fe4cc6207161ab902eed6ce0f9deb757c6789aa39a74b">e_MAX_NUM_RULES</a> =  8 * sizeof(MaskType)
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#ae21d0fdd3949f0b115d7f923741e4f91">MaskType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a906fb35c1a7276e083e20702fc852309">BSLMF_NESTED_TRAIT_DECLARATION</a> (<a class="el" href="classball_1_1RuleSet.html">RuleSet</a>, <a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a866b4b73e9d38b4dbfd636d17d9fc6bf">RuleSet</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a3730721b72606663bcf1bc44189c7308">RuleSet</a> (const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;original, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a502fd4dba359660f7d262bfacdddc170">~RuleSet</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a47e737512c7c537c438e65f739bcd5ff">addRule</a> (const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a5825efdcd8ea33db65f35387fe668d04">addRules</a> (const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;rules)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a1e7557ccf354041e5a805486f05b4838">removeRuleById</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#adc4b6a185316492cbd34bd64b74e872f">removeRule</a> (const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#ab95dbb2d9df9f5aed8695e711384ce2f">removeRules</a> (const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;rules)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#abdfcfb6b77196f4114e8acc4f4fc98ff">removeAllRules</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#ae5dfd58fa792c5fa38ad70db1d513c22">operator=</a> (const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a8e1be8dbe307221421fe524bd4ba2a3a">ruleId</a> (const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;value) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classball_1_1Rule.html">Rule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#aa4a354ecb794d2cbf8a69bf7df82fab3">getRuleById</a> (int id) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a53e652ecad79fcc3db5af13ad4e56eb0">numRules</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a566db92e6bad0a3ac5b97cd2889fb951">numPredicates</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a5acd6619b125d0fb7de5796a26e2c153">print</a> (bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#afadac07dd4247dcfb3a2d905740051f2">maxNumRules</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a339a5afc57d4a09bd340b427419422d1">printMask</a> (bsl::ostream &amp;stream, <a class="el" href="classball_1_1RuleSet.html#ae21d0fdd3949f0b115d7f923741e4f91">MaskType</a> mask, int level=0, int spacesPerLevel=0)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a54a1535053069dedceb7f8aec754c710">operator==</a> (const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;, const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#a0ba6107a929569024ab0426ae3d5ccec">operator!=</a> (const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;, const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html#ae3ce946996895a2da935faddacb884c6">operator&lt;&lt;</a> (bsl::ostream &amp;, const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class manages a set of unique rule values. Rules may be added to or removed from the set; however, rules having duplicate values will not be added. For the definition of two rules having the same value, please refer to the function-level documentation associated with the <code><a class="el" href="classball_1_1Rule.html#adcd8e4f05c8ed1e65df74b89562a3c55">Rule::operator==</a></code> function. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae21d0fdd3949f0b115d7f923741e4f91"></a><!-- doxytag: member="ball::RuleSet::MaskType" ref="ae21d0fdd3949f0b115d7f923741e4f91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="classball_1_1RuleSet.html#ae21d0fdd3949f0b115d7f923741e4f91">ball::RuleSet::MaskType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a098c31eb413bb8a14151fe4cc6207161"></a><!-- doxytag: member="ball::RuleSet::@91" ref="a098c31eb413bb8a14151fe4cc6207161" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a098c31eb413bb8a14151fe4cc6207161ab902eed6ce0f9deb757c6789aa39a74b"></a><!-- doxytag: member="e_MAX_NUM_RULES" ref="a098c31eb413bb8a14151fe4cc6207161ab902eed6ce0f9deb757c6789aa39a74b" args="" -->e_MAX_NUM_RULES</em>&nbsp;</td><td>
<p>The maximum number of rules managed by this object. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a866b4b73e9d38b4dbfd636d17d9fc6bf"></a><!-- doxytag: member="ball::RuleSet::RuleSet" ref="a866b4b73e9d38b4dbfd636d17d9fc6bf" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ball::RuleSet::RuleSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty rule set. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator will be used. </p>

</div>
</div>
<a class="anchor" id="a3730721b72606663bcf1bc44189c7308"></a><!-- doxytag: member="ball::RuleSet::RuleSet" ref="a3730721b72606663bcf1bc44189c7308" args="(const RuleSet &amp;original, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ball::RuleSet::RuleSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classball_1_1RuleSet.html">RuleSet</a></code> object having the same value as that of the specified <code>original</code> object. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator will be used. </p>

</div>
</div>
<a class="anchor" id="a502fd4dba359660f7d262bfacdddc170"></a><!-- doxytag: member="ball::RuleSet::~RuleSet" ref="a502fd4dba359660f7d262bfacdddc170" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ball::RuleSet::~RuleSet </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this rule set. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afadac07dd4247dcfb3a2d905740051f2"></a><!-- doxytag: member="ball::RuleSet::maxNumRules" ref="afadac07dd4247dcfb3a2d905740051f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ball::RuleSet::maxNumRules </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of rules that can be simultaneously maintained by this object. </p>

</div>
</div>
<a class="anchor" id="a339a5afc57d4a09bd340b427419422d1"></a><!-- doxytag: member="ball::RuleSet::printMask" ref="a339a5afc57d4a09bd340b427419422d1" args="(bsl::ostream &amp;stream, MaskType mask, int level=0, int spacesPerLevel=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ball::RuleSet::printMask </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classball_1_1RuleSet.html#ae21d0fdd3949f0b115d7f923741e4f91">MaskType</a>&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format the specified <code>mask</code> to the specified output <code>stream</code> at the optionally specified indentation <code>level</code> and return a reference to the modifiable <code>stream</code>. If <code>level</code> is specified, optionally specify <code>spacesPerLevel</code>, the number of spaces per indentation level for this and all of its nested objects. Each line is indented by the absolute value of <code>level * spacesPerLevel</code>. If <code>level</code> is negative, suppress indentation of the first line. If <code>spacesPerLevel</code> is negative, suppress line breaks and format the entire output on one line. If <code>stream</code> is initially invalid, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a906fb35c1a7276e083e20702fc852309"></a><!-- doxytag: member="ball::RuleSet::BSLMF_NESTED_TRAIT_DECLARATION" ref="a906fb35c1a7276e083e20702fc852309" args="(RuleSet, bslma::UsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ball::RuleSet::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classball_1_1RuleSet.html">RuleSet</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a47e737512c7c537c438e65f739bcd5ff"></a><!-- doxytag: member="ball::RuleSet::addRule" ref="a47e737512c7c537c438e65f739bcd5ff" args="(const Rule &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ball::RuleSet::addRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <code><a class="el" href="classball_1_1Rule.html">Rule</a></code> object having the specified <code>value</code>. Return the non-negative id of this non-modifiable object on success, and a negative value otherwise. A return value of -1 indicates that another rule having this value already exists. A return value of -2 indicates that the maximum number of rules for this rule set has been reached. </p>

</div>
</div>
<a class="anchor" id="a5825efdcd8ea33db65f35387fe668d04"></a><!-- doxytag: member="ball::RuleSet::addRules" ref="a5825efdcd8ea33db65f35387fe668d04" args="(const RuleSet &amp;rules)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ball::RuleSet::addRules </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rules</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add each rule in the specified <code>rules</code> to this rule set. Return the number of rules added. Note that a rule in <code>rules</code> will be ignored if there is an existing rule having the same value or if the number of rules in the set has reached the upper limit. Also note that if not all valid rules will fit, the (possibly empty) subset of unique values that will be added is implementation dependent. </p>

</div>
</div>
<a class="anchor" id="a1e7557ccf354041e5a805486f05b4838"></a><!-- doxytag: member="ball::RuleSet::removeRuleById" ref="a1e7557ccf354041e5a805486f05b4838" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ball::RuleSet::removeRuleById </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this rule set the rule having the specified <code>id</code>. Return the number of rules removed (i.e., 1 on success and 0 if there is no rule whose id is <code>id</code>). The behavior is undefined unless <code>0 &lt;= id &lt; e_MAX_NUM_RULES</code>. </p>

</div>
</div>
<a class="anchor" id="adc4b6a185316492cbd34bd64b74e872f"></a><!-- doxytag: member="ball::RuleSet::removeRule" ref="adc4b6a185316492cbd34bd64b74e872f" args="(const Rule &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ball::RuleSet::removeRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the rule having the specified <code>value</code> from this rule set. Return the number of rules removed (i.e., 1 on success and 0 if there is no such a rule). </p>

</div>
</div>
<a class="anchor" id="ab95dbb2d9df9f5aed8695e711384ce2f"></a><!-- doxytag: member="ball::RuleSet::removeRules" ref="ab95dbb2d9df9f5aed8695e711384ce2f" args="(const RuleSet &amp;rules)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ball::RuleSet::removeRules </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rules</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove each rule in the specified <code>rules</code> from this rule set. Return the number of rules removed. </p>

</div>
</div>
<a class="anchor" id="abdfcfb6b77196f4114e8acc4f4fc98ff"></a><!-- doxytag: member="ball::RuleSet::removeAllRules" ref="abdfcfb6b77196f4114e8acc4f4fc98ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ball::RuleSet::removeAllRules </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove every rule in the rule set maintained by this object. </p>

</div>
</div>
<a class="anchor" id="ae5dfd58fa792c5fa38ad70db1d513c22"></a><!-- doxytag: member="ball::RuleSet::operator=" ref="ae5dfd58fa792c5fa38ad70db1d513c22" args="(const RuleSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classball_1_1RuleSet.html">RuleSet</a>&amp; ball::RuleSet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object. </p>

</div>
</div>
<a class="anchor" id="a8e1be8dbe307221421fe524bd4ba2a3a"></a><!-- doxytag: member="ball::RuleSet::ruleId" ref="a8e1be8dbe307221421fe524bd4ba2a3a" args="(const Rule &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ball::RuleSet::ruleId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the id of the rule having the specified <code>value</code> if such a rule exists, and a negative value otherwise. Note that if there are multiple rules having <code>value</code>, the id of the first one found will be returned and the order in which rules are searched is implementation dependent. </p>

</div>
</div>
<a class="anchor" id="aa4a354ecb794d2cbf8a69bf7df82fab3"></a><!-- doxytag: member="ball::RuleSet::getRuleById" ref="aa4a354ecb794d2cbf8a69bf7df82fab3" args="(int id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classball_1_1Rule.html">Rule</a>* ball::RuleSet::getRuleById </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the rule having the specified <code>id</code> if such a rule exists, and 0 otherwise. The behavior is undefined unless <code>0 &lt;= id &lt; <a class="el" href="classball_1_1RuleSet.html#afadac07dd4247dcfb3a2d905740051f2">maxNumRules()</a></code>. Note that rules may be assigned non-sequential identifiers, and that there may be a valid rule whose identifier is greater than <code><a class="el" href="classball_1_1RuleSet.html#a53e652ecad79fcc3db5af13ad4e56eb0">numRules()</a></code> (i.e., valid rules may appear anywhere in the range <code>0 &lt;= id &lt; <a class="el" href="classball_1_1RuleSet.html#afadac07dd4247dcfb3a2d905740051f2">maxNumRules()</a></code>). </p>

</div>
</div>
<a class="anchor" id="a53e652ecad79fcc3db5af13ad4e56eb0"></a><!-- doxytag: member="ball::RuleSet::numRules" ref="a53e652ecad79fcc3db5af13ad4e56eb0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ball::RuleSet::numRules </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of unique rules maintained in this <code><a class="el" href="classball_1_1RuleSet.html">RuleSet</a></code> object. Note that this value is <em>not</em> the maximum identifier for the rules currently in this container. </p>

</div>
</div>
<a class="anchor" id="a566db92e6bad0a3ac5b97cd2889fb951"></a><!-- doxytag: member="ball::RuleSet::numPredicates" ref="a566db92e6bad0a3ac5b97cd2889fb951" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ball::RuleSet::numPredicates </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of predicates in all rules maintained by this object. </p>

</div>
</div>
<a class="anchor" id="a5acd6619b125d0fb7de5796a26e2c153"></a><!-- doxytag: member="ball::RuleSet::print" ref="a5acd6619b125d0fb7de5796a26e2c153" args="(bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::RuleSet::print </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format this object to the specified output <code>stream</code> at the (absolute value of) the optionally specified indentation <code>level</code> and return a reference to <code>stream</code>. If <code>level</code> is specified, optionally specify <code>spacesPerLevel</code>, the number of spaces per indentation level for this and all of its nested objects. If <code>level</code> is negative, suppress indentation of the first line. If <code>spacesPerLevel</code> is negative, format the entire output on one line, suppressing all but the initial indentation (as governed by <code>level</code>). If <code>stream</code> is not valid on entry, this operation has no effect. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a54a1535053069dedceb7f8aec754c710"></a><!-- doxytag: member="ball::RuleSet::operator==" ref="a54a1535053069dedceb7f8aec754c710" args="(const RuleSet &amp;, const RuleSet &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> rule sets have the same value, and <code>false</code> otherwise. Two rule sets have the same value if every rule that exists in one rule set also exists in the other. </p>

</div>
</div>
<a class="anchor" id="a0ba6107a929569024ab0426ae3d5ccec"></a><!-- doxytag: member="ball::RuleSet::operator!=" ref="a0ba6107a929569024ab0426ae3d5ccec" args="(const RuleSet &amp;, const RuleSet &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> rule sets do not have the same value, and <code>false</code> otherwise. Two rule sets do not have the same value if there is at least one rule that exists in one rule but does not exist in the other. </p>

</div>
</div>
<a class="anchor" id="ae3ce946996895a2da935faddacb884c6"></a><!-- doxytag: member="ball::RuleSet::operator&lt;&lt;" ref="ae3ce946996895a2da935faddacb884c6" args="(bsl::ostream &amp;, const RuleSet &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>rules</code> to the specified <code>output</code> stream. Return the specified <code>output</code> stream </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ball__ruleset_8h_source.html">ball_ruleset.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:03 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
