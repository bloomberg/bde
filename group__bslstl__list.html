<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslstl_list Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_list<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant list class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1List__Node.html">bsl::List_Node&lt; VALUE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator&lt; VALUE, NODEPTR, DIFFTYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1list.html">bsl::list&lt; VALUE, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::list&lt; VALUE, ALLOCATOR &gt;::AllocAndSizeWrapper</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::list&lt; VALUE, ALLOCATOR &gt;::NodeProctor</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::list&lt; VALUE, ALLOCATOR &gt;::Comp_Elems</b></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef List_Node *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaf815581e2308619d4a9e3774edae3abb">bsl::List_Node::NodePtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
std::bidirectional_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga99035f72f8d2a8e5b4a0e6a01ec554e3">bsl::List_Iterator::iterator_category</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NcType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gae587c4c5ab83fc61478ff24cd65c8ac8">bsl::List_Iterator::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DIFFTYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga0f5e919b5e0b9f8cd55fa5a4e301fe82">bsl::List_Iterator::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga06524091d9d29ed5e7c62c4d0d97487e">bsl::List_Iterator::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga2f780dcee1597126e4d5f4cbf4a79b39">bsl::List_Iterator::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga354a59e4d412aff0e67e638ca94af47d">bsl::list::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga2e3f3328259cbdc8b5a0f5bfee00c64c">bsl::list::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef List_Iterator&lt; VALUE, <br class="typebreak"/>
NodePtr, DiffType &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gadae00a5c78863ff92d6e77e2cf388622">bsl::list::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef List_Iterator&lt; const <br class="typebreak"/>
VALUE, NodePtr, DiffType &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga96acee73ee24f4fd427c5ba7d9c648dc">bsl::list::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef allocator_traits<br class="typebreak"/>
&lt; ALLOCATOR &gt;::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaa0a48db204680d3df9d9db5b71133058">bsl::list::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef allocator_traits<br class="typebreak"/>
&lt; ALLOCATOR &gt;::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gab80e535f7b84aefcf2bad8cdaf190eab">bsl::list::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga00bb9bf4714747111e362ca39476707e">bsl::list::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocTraits::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga9f67192213bfdb95f22d7b1b610c5b7f">bsl::list::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gab0fb67f9e0f76ab21274a36c5c814a4a">bsl::list::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gadaaad03e2cba0f3a51f84ad7831e2eea">bsl::list::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaf598f948bdd4e91919484812c11319fd">bsl::list::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga78a6b4ad2af1d580c77227f142ba30ff">bsl::list::const_reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaa8a0f35828e45b6d2832c58f89d03af8">bsl::List_Node::init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga38a1556f33400b4b8de55200667de77d">bsl::List_Node::destroy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacaaaaf59392eae3b16aeb2c193207f7a">bsl::List_Iterator::List_Iterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gad585c1a634d413181f9513406d804b7d">bsl::List_Iterator::List_Iterator</a> (NODEPTR p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga3eb711082c14e90dc20c01c66d6090e1">bsl::List_Iterator::List_Iterator</a> (const NcIter &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga4f04a48b228dd7e252e7aa42121b4941">bsl::List_Iterator::~List_Iterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">List_Iterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacc5a185c2c4b16bf4975346fc4aaf921">bsl::List_Iterator::operator=</a> (const List_Iterator &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">List_Iterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga5f1690199dec612cb00fed1561de7d03">bsl::List_Iterator::operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">List_Iterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga1d14432ea0742329aa39d6ccb5b1f7d2">bsl::List_Iterator::operator--</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">List_Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga16d86d7044dcdb007193b96a1d8c068e">bsl::List_Iterator::operator++</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">List_Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaa015da46a6ff05c792f61e2154549fc8">bsl::List_Iterator::operator--</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga239062ffd0744a049cdddce9d167213b">bsl::List_Iterator::operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga38c28ce8769c2ac8698bd647be9d04f6">bsl::List_Iterator::operator-&gt;</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class NODEPTR , class DIFFTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga4d35eb893ce83ba11f7e4dac35ee2a2d">bsl::operator==</a> (List_Iterator&lt; T1, NODEPTR, DIFFTYPE &gt; lhs, List_Iterator&lt; T2, NODEPTR, DIFFTYPE &gt; rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class NODEPTR , class DIFFTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8fa345b57fb8278d8760d1fd90157eae">bsl::operator!=</a> (List_Iterator&lt; T1, NODEPTR, DIFFTYPE &gt; lhs, List_Iterator&lt; T2, NODEPTR, DIFFTYPE &gt; rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga14e0970920d10125a523f238052435f1">bsl::list::AllocAndSizeWrapper::AllocAndSizeWrapper</a> (const NodeAlloc &amp;basicAllocator, size_type size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gae7b0eedbab7e56698c79ad138db95d71">bsl::list::NodeProctor::NodeProctor</a> (list *l, NodePtr p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga120ff40696869806bd6b38356c1037c7">bsl::list::NodeProctor::~NodeProctor</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga83166666b5e33d6fc5fe0821cfeaf629">bsl::list::NodeProctor::release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga11be106b342e6a1f7968c74e3c7c5ac5">bsl::list::BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (list, BloombergLP::bslmf::IsBitwiseMoveable, BloombergLP::bslmf::IsBitwiseMoveable&lt; ALLOCATOR &gt;::value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gadef726b48222232514e79e7d8f356198">bsl::list::BSLMF_NESTED_TRAIT_DECLARATION</a> (list, BloombergLP::bslalg::HasStlIterators)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga0f46a4651257cfbe01a76c37ecad1a46">bsl::list::BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (list, BloombergLP::bslma::UsesBslmaAllocator,(is_convertible&lt; BloombergLP::bslma::Allocator *, ALLOCATOR &gt;::value))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga9c13fee93cfc41bc5d89c92cb98af37a">bsl::list::list</a> (const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga43078d5ea06d115bb8d182b04dc9bd61">bsl::list::list</a> (size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8f8183f6122f62ee78140532fd698d25">bsl::list::list</a> (size_type n, const VALUE &amp;value, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga5bb6a12020db04f7426f4cb84c767995">bsl::list::list</a> (InputIter first, InputIter last, const ALLOCATOR &amp;basicAllocator=ALLOCATOR(), typename enable_if&lt; !is_fundamental&lt; InputIter &gt;::value &amp;&amp;!is_enum&lt; InputIter &gt;::value &gt;::type *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga2f7e69d139593183cc48fc3f6d95d8ae">bsl::list::list</a> (const list &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gad4d59f5cf8ece1ffb015e1d2768d19b6">bsl::list::list</a> (const list &amp;original, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gad80ef45bdd6d00dab48ed19c4c1b23a8">bsl::list::~list</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">list &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaccb07d1aa59aedc3570bed9d407fa5f1">bsl::list::operator=</a> (const list &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaaffd7b613113b8f37262b27820268a37">bsl::list::assign</a> (InputIter first, InputIter last, typename enable_if&lt; !is_fundamental&lt; InputIter &gt;::value &amp;&amp;!is_enum&lt; InputIter &gt;::value &gt;::type *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga2b7d4db579127e781bf8d2d8aa40a07d">bsl::list::assign</a> (size_type n, const VALUE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">bsl::list::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaaff91bdeee8bf00648c6f0ea63e89c5d">bsl::list::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga6d15e56f92de469716ddf36f684f523a">bsl::list::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga33f0e03614b05890d7e21193e7429295">bsl::list::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga7098a7468e7f7827d3b5c7393d21684d">bsl::list::resize</a> (size_type sz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga1c16ce53bdb1263a8b938c596bd1b001">bsl::list::resize</a> (size_type sz, const VALUE &amp;c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gadae817babcef4d91eaa3f185f98f010b">bsl::list::front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gadaa3ddc8ebbf689e5ed3183dd6f8434f">bsl::list::back</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class... ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga5f2acf4754c4d72925594bebe75827b7">bsl::list::emplace_front</a> (ARGS &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8cf8146a292b5257e7c8d9134f5bf188">bsl::list::pop_front</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class... ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga6a839494fae21862de65edd52588d7ed">bsl::list::emplace_back</a> (ARGS &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gab2fb73df84ac2640d87e9a29eac289f3">bsl::list::pop_back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga17708602439730f5c84e1638036a0292">bsl::list::push_front</a> (const VALUE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga27eeff2501848585019524dc10f27f12">bsl::list::push_back</a> (const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class... ARGS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga98cc46a578156771ccf9f5b661ac9209">bsl::list::emplace</a> (const_iterator position, ARGS &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gac8430d1383d5d6bc57602e490b0ecc0c">bsl::list::insert</a> (const_iterator position, const VALUE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga97efa9459209cb9d21d841014bf478a4">bsl::list::insert</a> (const_iterator position, size_type n, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gadeb98f74827b9950281c3e2052cfdd59">bsl::list::insert</a> (const_iterator position, InputIter first, InputIter last, typename enable_if&lt; !is_fundamental&lt; InputIter &gt;::value &amp;&amp;!is_enum&lt; InputIter &gt;::value &gt;::type *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gad9acaadae5c8562714adb86525bd7773">bsl::list::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaa9f7761eba7da78a9506d9097890fdb1">bsl::list::erase</a> (const_iterator position, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga7368b6af294baa8309b32a811e8d581a">bsl::list::swap</a> (list &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8b445f02e90e38f5d7cd2f8e1f3a0cff">bsl::list::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaf4e981f4e303a7a983b0606170d09530">bsl::list::splice</a> (const_iterator position, list &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga897cecfd9bfea47bbf2358eac5df69b8">bsl::list::splice</a> (const_iterator position, list &amp;x, const_iterator i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga17a290c325f23a517640b43a44f47b20">bsl::list::splice</a> (const_iterator position, list &amp;x, const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga7e9fcd8a5f57c36f26f5eaf29aae7479">bsl::list::remove</a> (const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga68543b87d393c34790c387ca9c5dc59e">bsl::list::remove_if</a> (Predicate pred)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga82f5de958e913d73ced2ef6134de5572">bsl::list::unique</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EqPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaf78b98fa826460641a8f8b34b4032b64">bsl::list::unique</a> (EqPredicate binary_pred)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga427a9819bd93f5d66a6dd61e834c140f">bsl::list::merge</a> (list &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPARE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaf7aa6d8260eb0f7f90894860b501c12e">bsl::list::merge</a> (list &amp;other, COMPARE comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga748a9f987759dd0cb85cddb343c3a807">bsl::list::sort</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPARE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacd98bc33503dc5c7a91b7243eb7a97b8">bsl::list::sort</a> (COMPARE comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga77b4a81041a41048e87f93852ed9aaa3">bsl::list::reverse</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga444c64ece23c850f771a6acabc4ceaf3">bsl::list::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaaeba5e48e2564e2975f8a73bf038cf26">bsl::list::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gae8b31fdd693b70e4c29f8bb2625e3767">bsl::list::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga2238735ea85677aa2c3123f5b7a9d4f8">bsl::list::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga0a790a21e9f378cdcba75eb0fe2f6cd3">bsl::list::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaced4a510e95a473ab0d6172def0ed714">bsl::list::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga66457b97f8c525546b3773bd3cb1223e">bsl::list::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga61dff8fef269f5ae29a51105dbd4e5d0">bsl::list::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga195576747609462cda1a5f4afe3fe5c2">bsl::list::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga9788ff6ad6aa73bb50cfcb1453aba282">bsl::list::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga1545c56b20443bb83944eecd2d336f65">bsl::list::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaeed01b7632ba60d2e0430852f46c8cee">bsl::list::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8d699005d3266376fa0098b09cf57919">bsl::list::front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaa726208e09ae77d9305bfef41ecf1b42">bsl::list::back</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga39c2b71f4356c6f9f1a69d441dda4c26">bsl::operator==</a> (const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacea9175011d9b18a01cb38e6e23d56e0">bsl::operator!=</a> (const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gacd1873ee9d29582411de3abe4a3e79ee">bsl::operator&lt;</a> (const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8f4598ceb1aee9f39781704c381ed8d1">bsl::operator&gt;</a> (const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga7e448645b21786d13f6377a64adfce1f">bsl::operator&lt;=</a> (const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga009bc1ba641b09a01e9e0c516cba7092">bsl::operator&gt;=</a> (const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8a4fac7379d969587e69a3186c91f583">bsl::swap</a> (list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gade9b97ce7a3862897a9ea8ea6a0c0cad">bsl::List_Node::d_prev</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaaab50cdc91f4e6a2e8770eb0d07a3df1">bsl::List_Node::d_next</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaf999f184f71f64160c304112a724c0ab">bsl::List_Node::d_value</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaa2dc7fbe23580d0871dd33f3001e9306">bsl::list::AllocAndSizeWrapper::d_size</a></td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaf487851297bff2935c50a15ddc1b79dd">bsl::List_Iterator::List_Iterator&lt; const VALUE, NODEPTR, DIFFTYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#gaccd8fce66e676a9bc1c5f7e6a671450e">bsl::list::AllocAndSizeWrapper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga8438538c02f3493d2e178ebb04591068">bsl::list::NodeProctor</a></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class NODEP , class DIFFT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__list.html#ga86f0255807453efe1bbe545680f21219">bsl::List_Iterator::operator==</a> (List_Iterator&lt; T1, NODEP, DIFFT &gt;, List_Iterator&lt; T2, NODEP, DIFFT &gt;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Memory Allocation</a> <ul>
<li>
<a href="#3.1.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Operations</a> </li>
<li>
<a href="#3.3">Thread-Safety</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Filter "Twinkle Star"</a> </li>
<li>
<a href="#3.4.2">Example 2: Combine Two Star Surveys</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant list class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1list.html">bsl::list</a> </td><td>STL-compatible list template  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__deque.html" title="Provide an STL-compliant deque class.">Component bslstl_deque</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template, <code>list</code>, implementing the standard container holding a sequence of elements (of a template parameter type, <code>VALUE</code>). All list operations involving single element are constant-time, including insertion and removal of elements anywhere in the list. Operations that do not change the number of elements are performed without calling constructors, destructors, swap, or assignment on the individual elements. (I.e., they are performed by pointer-manipulation alone.) A <code>list</code> does not provide random access to its elements; although access to the first and last element of a <code>list</code> is constant-time, other elements can be accessed only by traversing the list (forwards or backwards) from the beginning or end. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>list</code> is an allocator-aware, in-core value-semantic type whose salient attributes are its size (number of elements) and the sequence of its contained element values (in order). If <code>list</code> is instantiated with a type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if a type cannot be tested for equality, then a <code>list</code> containing that type cannot be tested for equality. It is even possible to instantiate <code>list</code> with a type that does not have a copy-constructor, in which case the <code>list</code> will not be copyable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>list</code> meets the requirements of a sequence container with bidirectional iterators in the C++ standard [23.3]. The <code>list</code> implemented here adheres to the C++11 standard, except that it does not have interfaces that take rvalue references, <code>initializer_list</code>, <code>emplace</code>, or operations taking a variadic number of template parameters. Note that excluded C++11 features are those that require C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a list's <code>ALLOCATOR</code> template parameter determines how that list will allocate memory. The <code>list</code> template supports allocators meeting the requirements of the C++11 standard [17.6.3.5], in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the parameterized <code>ALLOCATOR</code> type of an <code>list</code> instantiation is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that list type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a list accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it will be used to supply memory for the list throughout its lifetime; otherwise, the list will use the default allocator installed at the time of the list's construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, a list supplies that allocator's address to the constructors of contained objects of the (template parameter) <code>VALUE</code> type, if respectively, the parameterized types define the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code>list</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;V&#39;</span>             - parameterized <span class="stringliteral">&#39;VALUE&#39;</span> type of the list
  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>        - two distinct objects of type <span class="stringliteral">&#39;list&lt;V&gt;&#39;</span>
  <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;m&#39;</span>        - number of elements in <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span> respectively
  <span class="stringliteral">&#39;value_type&#39;</span>    - list&lt;V&gt;::value_type
  <span class="stringliteral">&#39;al&#39;</span>            - an STL-style memory allocator
  <span class="stringliteral">&#39;i1&#39;</span>, <span class="stringliteral">&#39;i2&#39;</span>      - two iterators defining a sequence of <span class="stringliteral">&#39;value_type&#39;</span> objects
  <span class="charliteral">&#39;v&#39;</span>             - an <span class="keywordtype">object</span> of type <span class="charliteral">&#39;V&#39;</span>
  <span class="stringliteral">&#39;p1&#39;</span>, <span class="stringliteral">&#39;p2&#39;</span>      - two iterators belonging to <span class="charliteral">&#39;a&#39;</span>
  <span class="stringliteral">&#39;s1&#39;</span>, <span class="stringliteral">&#39;s2&#39;</span>      - two iterators belonging to <span class="charliteral">&#39;b&#39;</span>
  <span class="stringliteral">&#39;pred&#39;</span>          - a unary predicate
  <span class="stringliteral">&#39;binary_pred&#39;</span>   - a binary predicate
  <span class="stringliteral">&#39;comp&#39;</span>          - a binary predicate implementing a strict-weak ordering
  <span class="stringliteral">&#39;args...&#39;</span>       - a variadic list of (up to 5) arguments
  distance(i1,i2) - the number of elements in the range [i1, i2)

  +----------------------------------------------------+--------------------+
  | Operation                                          | Complexity         |
  +====================================================+====================+
  | list&lt;V&gt; a;    (<span class="keywordflow">default</span> construction)               | O(1)               |
  | list&lt;V&gt; a(al);                                     |                    |
  +----------------------------------------------------+--------------------+
  | list&lt;V&gt; a(b); (copy construction)                  | O(n)               |
  | list&lt;V&gt; a(b, al);                                  |                    |
  +----------------------------------------------------+--------------------+
  | list&lt;V&gt; a(n);                                      | O(n)               |
  | list&lt;V&gt; a(n, value_type(v));                       |                    |
  | list&lt;V&gt; a(n, value_type(v), al);                   |                    |
  +----------------------------------------------------+--------------------+
  | list&lt;V&gt; a(i1, i2);                                 | O(distance(i1,i2)) |
  | list&lt;V&gt; a(i1, i2, al);                             |                    |
  +----------------------------------------------------+--------------------+
  | a.~list&lt;V&gt;(); (destruction)                        | O(n)               |
  +----------------------------------------------------+--------------------+
  | a = b;        (assignment)                         | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O(1)               |
  | a.rbegin(), a.rend(), a.crbegin(), a.crend()       |                    |
  +----------------------------------------------------+--------------------+
  | a == b, a != b                                     | O(n)               |
  +----------------------------------------------------+--------------------+
  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b                       | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.swap(b), <a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(a,b)                               | O(1) if &#39;a&#39; and &#39;b&#39;|
  |                                                    | use the same       |
  |                                                    | allocator,         |
  |                                                    | O[n + m] otherwise |
  +----------------------------------------------------+--------------------+
  | a.size()                                           | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.max_size()                                       | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.empty()                                          | O(1)               |
  +----------------------------------------------------+--------------------+
  | get_allocator()                                    | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.emplace(p1, args...)                             | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.insert(p1, value_type(v))                        | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.insert(p1, n, value_type(v))                     | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.insert(p1, i1, i2)                               | O(distance(i1, i2))|
  +----------------------------------------------------+--------------------+
  | a.erase(p1)                                        | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.erase(p1, p2)                                    | O(distance(p1, p2))|
  +----------------------------------------------------+--------------------+
  | a.clear()                                          | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.assign(i1,i2)                                    | O(distance(i1, i2))|
  +----------------------------------------------------+--------------------+
  | a.assign(n, value_type(v))                         | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.front(), a.back()                                | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.emplace_front(args...), a.emplace_back(args...)  | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.push_front(value_type(v)),                       |                    |
  | a.push_back(value_type(v))                         | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.pop_front(), a.pop_back()                        | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.resize(n), a.resize(n, value_type(v))            | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.splice(p, b), a.splice(p, b, s1)                 | O(1)               |
  +----------------------------------------------------+--------------------+
  | a.splice(p, b, s1, s2)                             | O(distance(s1, s2))|
  +----------------------------------------------------+--------------------+
  | a.remove(t), a.remove_if(pred)                     | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.unique(), a.unique(binary_pred)                  | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.merge(b), a.merge(b, comp)                       | O(n)               |
  +----------------------------------------------------+--------------------+
  | a.sort(), a.sort(comp)                             | O(n*log(n))        |
  +----------------------------------------------------+--------------------+
  | a.reverse()                                        | O(n)               |
  +----------------------------------------------------+--------------------+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread-safety"></a> <a class="anchor" id="description.thread-safety"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Thread-Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>list</code> is <a href="group__bsldoc__glossary.html#const_thread-safe_~5Bts.2~5D" class="glossary"><code>const</code> Thread-Safe [TS.2]</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>). Separate threads can safely access and modify separate <code>list</code> objects. Separate threads can safely perform <code>const</code> operations on a single <code>list</code> object. Separate threads cannot safely perform operations on a single <code>list</code> object if at least one of those operations modifies the list. If an iterator or reference to a list element is obtained in one thread, it may become invalidated if the list is modified in the same or another thread, even if the iterator is a <code>const_iterator</code> or the reference is a reference-to-'const'. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_filter_~22twinkle_star~22"></a> <a class="anchor" id="usage.example_1~3A_filter_~22twinkle_star~22"></a> <a class="anchor" id="description.usage.example_1~3A_filter_~22twinkle_star~22"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Filter "Twinkle Star": </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose an observatory needs to analyze the results of a sky survey. The raw data is a text file of star observations where each star is represented by a tuple of three numbers: (x, y, b), where x and y represent the angular coordinates of the star in the sky and b represents its brightness on a scale of 0 to 100. A star having brightness 75 or higher is of particular interest, which is called "twinkle star". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Our first example will read such a data file as described above, filter out the dim stars (brightness less than 75), and count the twinkle stars left in the list. Our test data set has been selected such that there are 10 stars in the set, of which 4 are sufficiently bright as to pass our filter. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the class <code>Star</code> that encapsulates a single tuple, and provides accessors functions <code>x</code>, <code>y</code>, and <code>brightness</code>, file I/O functions <code>read</code> and <code>write</code>, and free operators <code>==</code>, <code>!=</code>, and <code>&lt;</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;cstdio&gt;</span>
  <span class="keyword">using namespace </span>std;

  <span class="keyword">class </span>Star
      <span class="comment">// This class represents a star as seen through a digital telescope.</span>
  {
      <span class="comment">// DATA</span>
      <span class="keywordtype">double</span> d_x, d_y;     <span class="comment">// coordinates</span>

      <span class="keywordtype">int</span>    d_brightness; <span class="comment">// brightness on a scale of 0 to 100</span>

  <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      Star()
          <span class="comment">// Create a &#39;Star&#39; object located at coordinates &#39;(0, 0)&#39; having</span>
          <span class="comment">// &#39;0&#39; brightness.</span>
      : d_x(0), d_y(0), d_brightness(0)
      {
      }

      Star(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">int</span> b)
          <span class="comment">// Create a &#39;Star&#39; object located at the specified coordinates</span>
          <span class="comment">// &#39;(x, y)&#39; having the specified &#39;b&#39; brightness.</span>
      : d_x(x), d_y(y), d_brightness(b)
      {
      }

      <span class="comment">// Compiler-generated copy construction, assignment, and destructor</span>
      <span class="comment">// Star(const Star&amp;) = default;</span>
      <span class="comment">// Star&amp; operator=(const Star&amp;) = default;</span>
      <span class="comment">// ~Star() = default;</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">bool</span> read(FILE *input);
          <span class="comment">// Read x, y, and brightness from the specified &#39;input&#39; file.</span>
          <span class="comment">// Return &#39;true&#39; if the read succeeded and &#39;false&#39; otherwise.</span>

      <span class="keywordtype">void</span> write(FILE *output) <span class="keyword">const</span>;
          <span class="comment">// Write x, y, and brightness to the specified &#39;output&#39; file</span>
          <span class="comment">// followed by a newline.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">double</span> x() const
          <span class="comment">// Return the x coordinate of this &#39;Star&#39; object.</span>
      {
          <span class="keywordflow">return</span> d_x;
      }

      <span class="keywordtype">double</span> y() const
          <span class="comment">// Return the y coordinate of this &#39;Star&#39; object.</span>
      {
          <span class="keywordflow">return</span> d_y;
      }

      <span class="keywordtype">int</span> brightness() const
          <span class="comment">// Return the brightness of this &#39;Star&#39; object.</span>
      {
          <span class="keywordflow">return</span> d_brightness;
      }
  };

  <span class="comment">// FREE FUNCTIONS</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> Star&amp; lhs, <span class="keyword">const</span> Star&amp; rhs);
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> Star&amp; lhs, <span class="keyword">const</span> Star&amp; rhs);
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">operator&lt; </a>(<span class="keyword">const</span> Star&amp; lhs, <span class="keyword">const</span> Star&amp; rhs);
</pre></div><br/>
<br/>
 Then, we define a <code>readData</code> method that reads a file of data points and appends each onto a list. The stars are stored in the data file in ascending sorted order by x and y coordinates. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> readData(list&lt;Star&gt; *starList, FILE *input)
  {
      Star s;
      <span class="keywordflow">while</span> (s.read(input)) {
          starList-&gt;push_back(s);
      }
  }
</pre></div><br/>
<br/>
 Now, we define the <code>filter</code> method, which is responsible for removing stars with a brightness of less than 75 from the data set. It does this by iterating over the list and erasing any element that does not pass the filter. The list object features a fast <code>erase</code> member function. The return value of <code>erase</code> is an iterator to the element immediately following the erased element: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> filter(list&lt;Star&gt; *starList)
  {
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> threshold = 75;

      list&lt;Star&gt;::iterator i = starList-&gt;begin();
      <span class="keywordflow">while</span> (i != starList-&gt;end()) {
          <span class="keywordflow">if</span> (i-&gt;brightness() &lt; threshold) {
              i = starList-&gt;erase(i);  <span class="comment">// Erase and advance to next element.</span>
          }
          <span class="keywordflow">else</span> {
              ++i;  <span class="comment">// Advance to next element without erasing</span>
          }
      }
  }
</pre></div><br/>
<br/>
 Finally, we use the methods defined in above steps to put together our program to find twinkle stars: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample1(<span class="keywordtype">int</span> verbose)
  {
      FILE *input = fopen(<span class="stringliteral">&quot;star_data1.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);  <span class="comment">// Open input file.</span>
      assert(input);

      list&lt;Star&gt; starList;                         <span class="comment">// Define a list of stars.</span>
      assert(starList.empty());                    <span class="comment">// A list should be empty</span>
                                                   <span class="comment">// after default</span>
                                                   <span class="comment">// construction.</span>

      readData(&amp;starList, input);                  <span class="comment">// Read input to the list.</span>
      assert(10 == starList.size());               <span class="comment">// Verify correct reading.</span>
      fclose(input);                               <span class="comment">// Close input file.</span>

      filter(&amp;starList);                           <span class="comment">// Pick twinkle stars.</span>
      assert(4 == starList.size());                <span class="comment">// Verify correct filter.</span>

      <span class="comment">// Print out twinkle stars.</span>
      <span class="keywordflow">if</span> (verbose) {
          <span class="keywordflow">for</span> (list&lt;Star&gt;::const_iterator i = starList.begin();
               i != starList.end(); ++i) {
              i-&gt;write(stdout);
          }
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_combine_two_star_surveys"></a> <a class="anchor" id="usage.example_2~3A_combine_two_star_surveys"></a> <a class="anchor" id="description.usage.example_2~3A_combine_two_star_surveys"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Combine Two Star Surveys: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the second example, we want to combine the results from two star surveys into a single list, using the same <code>Star</code> class defined in the first usage example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we begin by reading both lists and filtering them. (Our test data is selected so that the second data file contains 8 stars of which 3 are sufficiently bright as to pass our filter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample2(<span class="keywordtype">int</span> verbose)
  {
      FILE *input = fopen(<span class="stringliteral">&quot;star_data1.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);  <span class="comment">// Open first input file.</span>
      assert(input);

      list&lt;Star&gt; starList1;                        <span class="comment">// Define first star list.</span>
      assert(starList1.empty());

      readData(&amp;starList1, input);                 <span class="comment">// Read input into list.</span>
      assert(10 == starList1.size());
      fclose(input);                               <span class="comment">// Close first input file.</span>

      input = fopen(<span class="stringliteral">&quot;star_data2.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);        <span class="comment">// Open second input file.</span>
      assert(input);

      list&lt;Star&gt; starList2;                        <span class="comment">// Define second list.</span>
      assert(starList2.empty());

      readData(&amp;starList2, input);                 <span class="comment">// Read input into list.</span>
      assert(8 == starList2.size());
      fclose(input);                               <span class="comment">// Close input file.</span>

      filter(&amp;starList1);                          <span class="comment">// Pick twinkle stars from</span>
                                                   <span class="comment">// the first star list.</span>
      assert(4 == starList1.size());

      filter(&amp;starList2);                          <span class="comment">// Pick twinkle stars from</span>
                                                   <span class="comment">// the second star list.</span>
      assert(3 == starList2.size());
</pre></div><br/>
<br/>
 Then, we combine the two lists, <code>starList1</code> and <code>starList2</code>. One way to do this is to simply insert the second list at the end of the first: <br/>
<br/>
<div class="fragment"><pre class="fragment">      list&lt;Star&gt; tmp1(starList1);  <span class="comment">// Make a copy of the first list</span>
      list&lt;Star&gt; tmp2(starList2);  <span class="comment">// Make a copy of the second list</span>
      tmp1.insert(tmp1.end(), tmp2.begin(), tmp2.end());
      assert(7 == tmp1.size());    <span class="comment">// Verify combined size.</span>
      assert(3 == tmp2.size());    <span class="comment">// &#39;tmp2&#39; should be unchanged.</span>
</pre></div><br/>
<br/>
 Next, let's have a closer look of the above code and see if we can improve the combination performance. The above <code>insert</code> method appends a copy of each element in <code>tmp2</code> onto the end of <code>tmp1</code>. This copy is unnecessary because we have no need for <code>tmp2</code> after the lists have been combined. A faster and less-memory-intensive technique is to use the <code>splice</code> function, which <em>moves</em> rather than <em>copies</em> elements from one list to another: <br/>
<br/>
<div class="fragment"><pre class="fragment">      tmp1 = starList1;
      tmp2 = starList2;
      tmp1.splice(tmp1.begin(), tmp2);
      assert(7 == tmp1.size());    <span class="comment">// Verify combined size.</span>
      assert(0 == tmp2.size());    <span class="comment">// &#39;tmp2&#39; should be emptied by the splice.</span>
</pre></div><br/>
<br/>
 Notice that, while the original lists were sorted in ascending order (because the data files were originally sorted), the combined list is no longer sorted. To fix it, we sort <code>tmp1</code> using the <code>sort</code> member function: <br/>
<br/>
<div class="fragment"><pre class="fragment">      tmp1.sort();
</pre></div><br/>
<br/>
 Then, we suggest a third, and also the best approach to combine two lists, which is to take advantage of the fact that the lists were originally sorted, using the <code>merge</code> function: <br/>
<br/>
<div class="fragment"><pre class="fragment">      starList1.merge(starList2);     <span class="comment">// Merge &#39;starList2&#39; into &#39;starList1&#39;.</span>
      assert(7 == starList1.size());  <span class="comment">// Verify combined size.</span>
      assert(0 == starList2.size());  <span class="comment">// starList2 should be emptied by the</span>
                                      <span class="comment">// merge.</span>
</pre></div><br/>
<br/>
 Now, since the two star surveys may overlap, we want to eliminate duplicates. We accomplish this by using the <code>unique</code> member function: <br/>
<br/>
<div class="fragment"><pre class="fragment">      starList1.unique();             <span class="comment">// Eliminate duplicates in &#39;starList1&#39;.</span>
      assert(6 == starList1.size());  <span class="comment">// Verify size after elimination.</span>
</pre></div><br/>
<br/>
 Finally, we print the result: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (verbose) {
          <span class="keywordflow">for</span> (list&lt;Star&gt;::const_iterator i = starList1.begin();
               i != starList1.end(); ++i) {
              i-&gt;write(stdout);
          }
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 For completeness, the implementations of the <code>read</code>, <code>write</code>, and comparison functions for class <code>Star</code> are shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> Star::read(FILE *input)
  {
      <span class="keywordtype">int</span> ret = fscanf(input, <span class="stringliteral">&quot;%lf %lf %d&quot;</span>, &amp;d_x, &amp;d_y, &amp;d_brightness);
      <span class="keywordflow">return</span> 3 == ret;
  }

  <span class="keywordtype">void</span> Star::write(FILE *output)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      fprintf(output, <span class="stringliteral">&quot;%f %f %d\n&quot;</span>, d_x, d_y, d_brightness);
  }

  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> Star&amp; lhs, <span class="keyword">const</span> Star&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.x() == rhs.x()
          &amp;&amp; lhs.y() == rhs.y()
          &amp;&amp; lhs.brightness() == rhs.brightness();
  }

  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aceb1a703f6f64327cd3cdcd03a557f4a">operator!=</a>(<span class="keyword">const</span> Star&amp; lhs, <span class="keyword">const</span> Star&amp; rhs)
  {
      <span class="keywordflow">return</span> ! (lhs == rhs);
  }

  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#ad07f3843b29d0d2bdc6cad3e1fa4a009">operator&lt;</a>(<span class="keyword">const</span> Star&amp; lhs, <span class="keyword">const</span> Star&amp; rhs)
  {
      <span class="keywordflow">if</span> (lhs.x() &lt; rhs.x())
          <span class="keywordflow">return</span> <span class="keyword">true</span>;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rhs.x() &lt; lhs.x())
          <span class="keywordflow">return</span> <span class="keyword">false</span>;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs.y() &lt; rhs.y())
          <span class="keywordflow">return</span> <span class="keyword">true</span>;
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rhs.y() &lt; lhs.y())
          <span class="keywordflow">return</span> <span class="keyword">true</span>;
      <span class="keywordflow">else</span>
          <span class="keywordflow">return</span> lhs.brightness() &lt; rhs.brightness();
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaf815581e2308619d4a9e3774edae3abb"></a><!-- doxytag: member="bsl::List_Node::NodePtr" ref="gaf815581e2308619d4a9e3774edae3abb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef List_Node* <a class="el" href="structbsl_1_1List__Node.html">bsl::List_Node</a>&lt; VALUE &gt;::NodePtr<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga99035f72f8d2a8e5b4a0e6a01ec554e3"></a><!-- doxytag: member="bsl::List_Iterator::iterator_category" ref="ga99035f72f8d2a8e5b4a0e6a01ec554e3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::bidirectional_iterator_tag <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::iterator_category<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae587c4c5ab83fc61478ff24cd65c8ac8"></a><!-- doxytag: member="bsl::List_Iterator::value_type" ref="gae587c4c5ab83fc61478ff24cd65c8ac8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NcType <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0f5e919b5e0b9f8cd55fa5a4e301fe82"></a><!-- doxytag: member="bsl::List_Iterator::difference_type" ref="ga0f5e919b5e0b9f8cd55fa5a4e301fe82" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DIFFTYPE <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga06524091d9d29ed5e7c62c4d0d97487e"></a><!-- doxytag: member="bsl::List_Iterator::pointer" ref="ga06524091d9d29ed5e7c62c4d0d97487e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE* <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2f780dcee1597126e4d5f4cbf4a79b39"></a><!-- doxytag: member="bsl::List_Iterator::reference" ref="ga2f780dcee1597126e4d5f4cbf4a79b39" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE&amp; <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga354a59e4d412aff0e67e638ca94af47d"></a><!-- doxytag: member="bsl::list::reference" ref="ga354a59e4d412aff0e67e638ca94af47d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE&amp; <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2e3f3328259cbdc8b5a0f5bfee00c64c"></a><!-- doxytag: member="bsl::list::const_reference" ref="ga2e3f3328259cbdc8b5a0f5bfee00c64c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const VALUE&amp; <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadae00a5c78863ff92d6e77e2cf388622"></a><!-- doxytag: member="bsl::list::iterator" ref="gadae00a5c78863ff92d6e77e2cf388622" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef List_Iterator&lt;VALUE,NodePtr,DiffType&gt; <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga96acee73ee24f4fd427c5ba7d9c648dc"></a><!-- doxytag: member="bsl::list::const_iterator" ref="ga96acee73ee24f4fd427c5ba7d9c648dc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef List_Iterator&lt;const VALUE,NodePtr,DiffType&gt; <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa0a48db204680d3df9d9db5b71133058"></a><!-- doxytag: member="bsl::list::pointer" ref="gaa0a48db204680d3df9d9db5b71133058" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_traits&lt;ALLOCATOR&gt;::pointer <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab80e535f7b84aefcf2bad8cdaf190eab"></a><!-- doxytag: member="bsl::list::const_pointer" ref="gab80e535f7b84aefcf2bad8cdaf190eab" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_traits&lt;ALLOCATOR&gt;::const_pointer <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga00bb9bf4714747111e362ca39476707e"></a><!-- doxytag: member="bsl::list::size_type" ref="ga00bb9bf4714747111e362ca39476707e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocTraits::size_type <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9f67192213bfdb95f22d7b1b610c5b7f"></a><!-- doxytag: member="bsl::list::difference_type" ref="ga9f67192213bfdb95f22d7b1b610c5b7f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocTraits::difference_type <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab0fb67f9e0f76ab21274a36c5c814a4a"></a><!-- doxytag: member="bsl::list::value_type" ref="gab0fb67f9e0f76ab21274a36c5c814a4a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadaaad03e2cba0f3a51f84ad7831e2eea"></a><!-- doxytag: member="bsl::list::allocator_type" ref="gadaaad03e2cba0f3a51f84ad7831e2eea" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf598f948bdd4e91919484812c11319fd"></a><!-- doxytag: member="bsl::list::reverse_iterator" ref="gaf598f948bdd4e91919484812c11319fd" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga78a6b4ad2af1d580c77227f142ba30ff"></a><!-- doxytag: member="bsl::list::const_reverse_iterator" ref="ga78a6b4ad2af1d580c77227f142ba30ff" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa8a0f35828e45b6d2832c58f89d03af8"></a><!-- doxytag: member="bsl::List_Node::init" ref="gaa8a0f35828e45b6d2832c58f89d03af8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structbsl_1_1List__Node.html">bsl::List_Node</a>&lt; VALUE &gt;::init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Value-initialize the <code>d_prev</code> and <code>d_next</code> members of this node, but do not touch <code>d_value</code>. The behavior is undefined unless <code>this</code> points to allocated (uninitialized) storage'. Note: <code>d_value</code> continues to hold uninitialized storage after this call. </p>

</div>
</div>
<a class="anchor" id="ga38a1556f33400b4b8de55200667de77d"></a><!-- doxytag: member="bsl::List_Node::destroy" ref="ga38a1556f33400b4b8de55200667de77d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structbsl_1_1List__Node.html">bsl::List_Node</a>&lt; VALUE &gt;::destroy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the <code>d_prev</code> and <code>d_next</code> members of this node but do not touch <code>d_value</code>. After calling <code>destroy</code>, <code>this</code> points to allocated (uninitialized) storage. The behavior is undefined unless <code>d_prev</code> and <code>d_next</code> have valid values and <code>d_value</code> holds allocated (uninitialized) storage. </p>

</div>
</div>
<a class="anchor" id="gacaaaaf59392eae3b16aeb2c193207f7a"></a><!-- doxytag: member="bsl::List_Iterator::List_Iterator" ref="gacaaaaf59392eae3b16aeb2c193207f7a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::List_Iterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a singular iterator (i.e., one that cannot be incremented, decremented, or dereferenced. </p>

</div>
</div>
<a class="anchor" id="gad585c1a634d413181f9513406d804b7d"></a><!-- doxytag: member="bsl::List_Iterator::List_Iterator" ref="gad585c1a634d413181f9513406d804b7d" args="(NODEPTR p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::List_Iterator </td>
          <td>(</td>
          <td class="paramtype">NODEPTR&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator that references the value pointed to by the specified pointer <code>p</code>. </p>

</div>
</div>
<a class="anchor" id="ga3eb711082c14e90dc20c01c66d6090e1"></a><!-- doxytag: member="bsl::List_Iterator::List_Iterator" ref="ga3eb711082c14e90dc20c01c66d6090e1" args="(const NcIter &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::List_Iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1List__Iterator.html">NcIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator to <code>VALUE</code> from the corresponding iterator to non-const <code>VALUE</code>. If <code>VALUE</code> is not const-qualified, then this constructor becomes the copy constructor. Otherwise, the copy constructor is implicitly generated. </p>

</div>
</div>
<a class="anchor" id="ga4f04a48b228dd7e252e7aa42121b4941"></a><!-- doxytag: member="bsl::List_Iterator::~List_Iterator" ref="ga4f04a48b228dd7e252e7aa42121b4941" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::~List_Iterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacc5a185c2c4b16bf4975346fc4aaf921"></a><!-- doxytag: member="bsl::List_Iterator::operator=" ref="gacc5a185c2c4b16bf4975346fc4aaf921" args="(const List_Iterator &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">List_Iterator&amp; <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5f1690199dec612cb00fed1561de7d03"></a><!-- doxytag: member="bsl::List_Iterator::operator++" ref="ga5f1690199dec612cb00fed1561de7d03" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">List_Iterator&amp; <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance this iterator to the next element in this list and return its new value. The behavior is undefined unless this iterator is in the range <code>[ begin(), end() )</code> for some list (i.e., the iterator is not singular, is not <code>end()</code> and has not be invalidated). </p>

</div>
</div>
<a class="anchor" id="ga1d14432ea0742329aa39d6ccb5b1f7d2"></a><!-- doxytag: member="bsl::List_Iterator::operator&#45;&#45;" ref="ga1d14432ea0742329aa39d6ccb5b1f7d2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">List_Iterator&amp; <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the previous element in this list and return its new value. The behavior is undefined unless this iterator is in the range <code>( begin(), end() ]</code> for some list (i.e., the iterator is not singular, is not <code>begin()</code> and has not be invalidated). </p>

</div>
</div>
<a class="anchor" id="ga16d86d7044dcdb007193b96a1d8c068e"></a><!-- doxytag: member="bsl::List_Iterator::operator++" ref="ga16d86d7044dcdb007193b96a1d8c068e" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">List_Iterator <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance this iterator to the next element in this list and return its previous value. The behavior is undefined unless this iterator is in the range <code>[ begin(), end() )</code> for some list (i.e., the iterator is not singular, is not <code>end()</code> and has not be invalidated). </p>

</div>
</div>
<a class="anchor" id="gaa015da46a6ff05c792f61e2154549fc8"></a><!-- doxytag: member="bsl::List_Iterator::operator&#45;&#45;" ref="gaa015da46a6ff05c792f61e2154549fc8" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">List_Iterator <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the previous element in this list and return its previous value. The behavior is undefined unless this iterator is in the range <code>( begin(), end() ]</code> for some list (i.e., the iterator is not singular, is not <code>begin()</code> and has not be invalidated). </p>

</div>
</div>
<a class="anchor" id="ga239062ffd0744a049cdddce9d167213b"></a><!-- doxytag: member="bsl::List_Iterator::operator*" ref="ga239062ffd0744a049cdddce9d167213b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to this list object referenced by this iterator. The behavior is undefined unless this iterator is in the range <code>[ begin(), end() )</code> for some list (i.e., the iterator is not singular, is not <code>end()</code> and has not be invalidated). </p>

</div>
</div>
<a class="anchor" id="ga38c28ce8769c2ac8698bd647be9d04f6"></a><!-- doxytag: member="bsl::List_Iterator::operator&#45;&gt;" ref="ga38c28ce8769c2ac8698bd647be9d04f6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classbsl_1_1List__Iterator.html">bsl::List_Iterator</a>&lt; VALUE, NODEPTR, DIFFTYPE &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to this list object referenced by this iterator. The behavior is undefined unless this iterator is in the range <code>[ begin(), end() )</code> for some list (i.e., the iterator is not singular, is not <code>end()</code> and has not be invalidated). </p>

</div>
</div>
<a class="anchor" id="ga4d35eb893ce83ba11f7e4dac35ee2a2d"></a><!-- doxytag: member="bsl::operator==" ref="ga4d35eb893ce83ba11f7e4dac35ee2a2d" args="(List_Iterator&lt; T1, NODEPTR, DIFFTYPE &gt; lhs, List_Iterator&lt; T2, NODEPTR, DIFFTYPE &gt; rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class NODEPTR , class DIFFTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">List_Iterator&lt; T1, NODEPTR, DIFFTYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List_Iterator&lt; T2, NODEPTR, DIFFTYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified iterators <code>lhs</code> and <code>rhs</code> have the same value and <code>false</code> otherwise. Two iterators have the same value if both refer to the same element of the same list or both are the end() iterator of the same list. The return value is undefined unless both <code>lhs</code> and <code>rhs</code> are non-singular. </p>

</div>
</div>
<a class="anchor" id="ga8fa345b57fb8278d8760d1fd90157eae"></a><!-- doxytag: member="bsl::operator!=" ref="ga8fa345b57fb8278d8760d1fd90157eae" args="(List_Iterator&lt; T1, NODEPTR, DIFFTYPE &gt; lhs, List_Iterator&lt; T2, NODEPTR, DIFFTYPE &gt; rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class NODEPTR , class DIFFTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">List_Iterator&lt; T1, NODEPTR, DIFFTYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List_Iterator&lt; T2, NODEPTR, DIFFTYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified iterators <code>lhs</code> and <code>rhs</code> do not have the same value and <code>false</code> otherwise. Two iterators have the same value if both refer to the same element of the same list or both are the end() iterator of the same list. The return value is undefined unless both <code>lhs</code> and <code>rhs</code> are non-singular. </p>

</div>
</div>
<a class="anchor" id="ga14e0970920d10125a523f238052435f1"></a><!-- doxytag: member="bsl::list::AllocAndSizeWrapper::AllocAndSizeWrapper" ref="ga14e0970920d10125a523f238052435f1" args="(const NodeAlloc &amp;basicAllocator, size_type size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::AllocAndSizeWrapper::AllocAndSizeWrapper </td>
          <td>(</td>
          <td class="paramtype">const NodeAlloc &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__list.html#ga00bb9bf4714747111e362ca39476707e">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Create an allocator wrapper having the specified allocator type <code>allocator</code> and the specified allocated <code>size</code>. </p>

</div>
</div>
<a class="anchor" id="gae7b0eedbab7e56698c79ad138db95d71"></a><!-- doxytag: member="bsl::list::NodeProctor::NodeProctor" ref="gae7b0eedbab7e56698c79ad138db95d71" args="(list *l, NodePtr p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::NodeProctor::NodeProctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtr&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Create a node proctor object that will use the specified list <code>l</code> to free the specified node <code>p</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga120ff40696869806bd6b38356c1037c7"></a><!-- doxytag: member="bsl::list::NodeProctor::~NodeProctor" ref="ga120ff40696869806bd6b38356c1037c7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::NodeProctor::~NodeProctor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga83166666b5e33d6fc5fe0821cfeaf629"></a><!-- doxytag: member="bsl::list::NodeProctor::release" ref="ga83166666b5e33d6fc5fe0821cfeaf629" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::NodeProctor::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga11be106b342e6a1f7968c74e3c7c5ac5"></a><!-- doxytag: member="bsl::list::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="ga11be106b342e6a1f7968c74e3c7c5ac5" args="(list, BloombergLP::bslmf::IsBitwiseMoveable, BloombergLP::bslmf::IsBitwiseMoveable&lt; ALLOCATOR &gt;::value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::IsBitwiseMoveable&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::IsBitwiseMoveable&lt; ALLOCATOR &gt;::value&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadef726b48222232514e79e7d8f356198"></a><!-- doxytag: member="bsl::list::BSLMF_NESTED_TRAIT_DECLARATION" ref="gadef726b48222232514e79e7d8f356198" args="(list, BloombergLP::bslalg::HasStlIterators)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslalg::HasStlIterators&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0f46a4651257cfbe01a76c37ecad1a46"></a><!-- doxytag: member="bsl::list::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="ga0f46a4651257cfbe01a76c37ecad1a46" args="(list, BloombergLP::bslma::UsesBslmaAllocator,(is_convertible&lt; BloombergLP::bslma::Allocator *, ALLOCATOR &gt;::value))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::UsesBslmaAllocator&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(<a class="el" href="structbsl_1_1is__convertible.html">is_convertible</a>&lt; BloombergLP::bslma::Allocator *, ALLOCATOR &gt;::value)&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9c13fee93cfc41bc5d89c92cb98af37a"></a><!-- doxytag: member="bsl::list::list" ref="ga9c13fee93cfc41bc5d89c92cb98af37a" args="(const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty list that allocates memory using the specified <code>basicAllocator</code>. </p>

</div>
</div>
<a class="anchor" id="ga43078d5ea06d115bb8d182b04dc9bd61"></a><!-- doxytag: member="bsl::list::list" ref="ga43078d5ea06d115bb8d182b04dc9bd61" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__list.html#ga00bb9bf4714747111e362ca39476707e">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a list containing the specified <code>n</code> elements and using a default-constructed allocator. The initial elements in this list are constructed by "default-insertion". </p>

</div>
</div>
<a class="anchor" id="ga8f8183f6122f62ee78140532fd698d25"></a><!-- doxytag: member="bsl::list::list" ref="ga8f8183f6122f62ee78140532fd698d25" args="(size_type n, const VALUE &amp;value, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__list.html#ga00bb9bf4714747111e362ca39476707e">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a list using the specified <code>basicAllocator</code> and insert the specified <code>n</code> number of elements created by "copy-insertion" from <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="ga5bb6a12020db04f7426f4cb84c767995"></a><!-- doxytag: member="bsl::list::list" ref="ga5bb6a12020db04f7426f4cb84c767995" args="(InputIter first, InputIter last, const ALLOCATOR &amp;basicAllocator=ALLOCATOR(), typename enable_if&lt; !is_fundamental&lt; InputIter &gt;::value &amp;&amp;!is_enum&lt; InputIter &gt;::value &gt;::type *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::list </td>
          <td>(</td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structbsl_1_1enable__if.html">enable_if</a>&lt; !<a class="el" href="structbsl_1_1is__fundamental.html">is_fundamental</a>&lt; InputIter &gt;::value &amp;&amp;!<a class="el" href="structbsl_1_1is__enum.html">is_enum</a>&lt; InputIter &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">bsl::list&lt; VALUE, ALLOCATOR &gt;::begin()</a>, and <a class="el" href="group__bslstl__list.html#gac8430d1383d5d6bc57602e490b0ecc0c">bsl::list&lt; VALUE, ALLOCATOR &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2f7e69d139593183cc48fc3f6d95d8ae"></a><!-- doxytag: member="bsl::list::list" ref="ga2f7e69d139593183cc48fc3f6d95d8ae" args="(const list &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a list having the same value as that of the specified <code>original</code>. If <code>ALLOCATOR</code> is convertible from <code>bslma_Allocator*</code>, then the resulting list will use the default allocator; otherwise, the resulting list will use a copy of <code>original.get_allocator()</code>. Each element in the resulting list is constructed by "copy-insertion" from the corresponding element in <code>original</code>. </p>

</div>
</div>
<a class="anchor" id="gad4d59f5cf8ece1ffb015e1d2768d19b6"></a><!-- doxytag: member="bsl::list::list" ref="gad4d59f5cf8ece1ffb015e1d2768d19b6" args="(const list &amp;original, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a list having the same value as that of the specified <code>original</code> that will use the specified <code>basicAllocator</code> to supply memory. Each element in the resulting list is constructed by "copy-insertion" from the corresponding element in <code>allocator</code>. </p>

</div>
</div>
<a class="anchor" id="gad80ef45bdd6d00dab48ed19c4c1b23a8"></a><!-- doxytag: member="bsl::list::~list" ref="gad80ef45bdd6d00dab48ed19c4c1b23a8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::~list </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this list by calling the destructor for each element and deallocating all allocated storage. </p>

</div>
</div>
<a class="anchor" id="gaccb07d1aa59aedc3570bed9d407fa5f1"></a><!-- doxytag: member="bsl::list::operator=" ref="gaccb07d1aa59aedc3570bed9d407fa5f1" args="(const list &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">list&amp; <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this list the value of the specified list <code>rhs</code>, and return a reference providing modifiable access to this list. Each element of this list is either copy-assigned or copy-inserted from the corresponding element of <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="gaaffd7b613113b8f37262b27820268a37"></a><!-- doxytag: member="bsl::list::assign" ref="gaaffd7b613113b8f37262b27820268a37" args="(InputIter first, InputIter last, typename enable_if&lt; !is_fundamental&lt; InputIter &gt;::value &amp;&amp;!is_enum&lt; InputIter &gt;::value &gt;::type *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structbsl_1_1enable__if.html">enable_if</a>&lt; !<a class="el" href="structbsl_1_1is__fundamental.html">is_fundamental</a>&lt; InputIter &gt;::value &amp;&amp;!<a class="el" href="structbsl_1_1is__enum.html">is_enum</a>&lt; InputIter &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">bsl::list&lt; VALUE, ALLOCATOR &gt;::begin()</a>, <a class="el" href="group__bslstl__list.html#ga98cc46a578156771ccf9f5b661ac9209">bsl::list&lt; VALUE, ALLOCATOR &gt;::emplace()</a>, <a class="el" href="group__bslstl__list.html#gaaff91bdeee8bf00648c6f0ea63e89c5d">bsl::list&lt; VALUE, ALLOCATOR &gt;::end()</a>, and <a class="el" href="group__bslstl__list.html#gad9acaadae5c8562714adb86525bd7773">bsl::list&lt; VALUE, ALLOCATOR &gt;::erase()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2b7d4db579127e781bf8d2d8aa40a07d"></a><!-- doxytag: member="bsl::list::assign" ref="ga2b7d4db579127e781bf8d2d8aa40a07d" args="(size_type n, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__list.html#ga00bb9bf4714747111e362ca39476707e">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the contents of this list with the specified <code>n</code> copies of the specified <code>value</code>. Each element in this list is set by either copy-assignment or "copy-insertion" from <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="ga5c31176fa2f214a7932d504200b37f9f"></a><!-- doxytag: member="bsl::list::begin" ref="ga5c31176fa2f214a7932d504200b37f9f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a mutating iterator referring to the first element in the list, if any, or one past the end of this list if this list is empty. </p>

<p>Referenced by <a class="el" href="group__bslstl__list.html#gaaffd7b613113b8f37262b27820268a37">bsl::list&lt; VALUE, ALLOCATOR &gt;::assign()</a>, and <a class="el" href="group__bslstl__list.html#ga5bb6a12020db04f7426f4cb84c767995">bsl::list&lt; VALUE, ALLOCATOR &gt;::list()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaff91bdeee8bf00648c6f0ea63e89c5d"></a><!-- doxytag: member="bsl::list::end" ref="gaaff91bdeee8bf00648c6f0ea63e89c5d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a mutating iterator referring to one past the end of this list. </p>

<p>Referenced by <a class="el" href="group__bslstl__list.html#gaaffd7b613113b8f37262b27820268a37">bsl::list&lt; VALUE, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d15e56f92de469716ddf36f684f523a"></a><!-- doxytag: member="bsl::list::rbegin" ref="ga6d15e56f92de469716ddf36f684f523a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a mutating reverse iterator referring to the last element of this list (i.e., the first element of the reverse sequence), if any, or one before the start if this list is empty. </p>

</div>
</div>
<a class="anchor" id="ga33f0e03614b05890d7e21193e7429295"></a><!-- doxytag: member="bsl::list::rend" ref="ga33f0e03614b05890d7e21193e7429295" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a mutating reverse iterator referring to one before the start of this list. </p>

</div>
</div>
<a class="anchor" id="ga7098a7468e7f7827d3b5c7393d21684d"></a><!-- doxytag: member="bsl::list::resize" ref="ga7098a7468e7f7827d3b5c7393d21684d" args="(size_type sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__list.html#ga00bb9bf4714747111e362ca39476707e">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resize this list to the specified <code>sz</code> elements. If <code>sz</code> is less than or equal to the previous size of this list, then erase the excess elements from the end. Otherwise, append additional elements to the end using "default-insertion" until there are a total of <code>sz</code> elements. </p>

</div>
</div>
<a class="anchor" id="ga1c16ce53bdb1263a8b938c596bd1b001"></a><!-- doxytag: member="bsl::list::resize" ref="ga1c16ce53bdb1263a8b938c596bd1b001" args="(size_type sz, const VALUE &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__list.html#ga00bb9bf4714747111e362ca39476707e">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resize this list to the specified <code>sz</code> elements, with added elements being copies of the specified value <code>c</code>. If <code>sz</code> is less than or equal to the previous size of this list, then erase the excess elements from the end. Otherwise, append additional elements to the end using "copy-insertion" from <code>c</code> until there are a total of <code>sz</code> elements. </p>

</div>
</div>
<a class="anchor" id="gadae817babcef4d91eaa3f185f98f010b"></a><!-- doxytag: member="bsl::list::front" ref="gadae817babcef4d91eaa3f185f98f010b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the first element of this list. The behavior is undefined unless this list contains at least one element. </p>

</div>
</div>
<a class="anchor" id="gadaa3ddc8ebbf689e5ed3183dd6f8434f"></a><!-- doxytag: member="bsl::list::back" ref="gadaa3ddc8ebbf689e5ed3183dd6f8434f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the last element of this list. The behavior is undefined unless this list contains at least one element. </p>

</div>
</div>
<a class="anchor" id="ga5f2acf4754c4d72925594bebe75827b7"></a><!-- doxytag: member="bsl::list::emplace_front" ref="ga5f2acf4754c4d72925594bebe75827b7" args="(ARGS &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">ARGS &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a new element at the front of this list and construct it using "emplace-construction" from the specified <code>args</code>. </p>

</div>
</div>
<a class="anchor" id="ga8cf8146a292b5257e7c8d9134f5bf188"></a><!-- doxytag: member="bsl::list::pop_front" ref="ga8cf8146a292b5257e7c8d9134f5bf188" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove and destroy the first element of this list. The behavior is undefined unless this list contains at least one element. </p>

</div>
</div>
<a class="anchor" id="ga6a839494fae21862de65edd52588d7ed"></a><!-- doxytag: member="bsl::list::emplace_back" ref="ga6a839494fae21862de65edd52588d7ed" args="(ARGS &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">ARGS &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a new element at the back of this list and construct it using "emplace-construction" from the specified <code>args</code>. </p>

</div>
</div>
<a class="anchor" id="gab2fb73df84ac2640d87e9a29eac289f3"></a><!-- doxytag: member="bsl::list::pop_back" ref="gab2fb73df84ac2640d87e9a29eac289f3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove and destroy the last element of this list. The behavior is undefined unless this list contains at least one element. </p>

</div>
</div>
<a class="anchor" id="ga17708602439730f5c84e1638036a0292"></a><!-- doxytag: member="bsl::list::push_front" ref="ga17708602439730f5c84e1638036a0292" args="(const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a new element at the front of this list using "copy-insertion" from the specified value <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="ga27eeff2501848585019524dc10f27f12"></a><!-- doxytag: member="bsl::list::push_back" ref="ga27eeff2501848585019524dc10f27f12" args="(const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a new element to the end of this list using "copy-insertion" from the specified value <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="ga98cc46a578156771ccf9f5b661ac9209"></a><!-- doxytag: member="bsl::list::emplace" ref="ga98cc46a578156771ccf9f5b661ac9209" args="(const_iterator position, ARGS &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a new element into this list before the element at the specified <code>position</code> using "emplace-construction" from the specified <code>args</code>. </p>

<p>Referenced by <a class="el" href="group__bslstl__list.html#gaaffd7b613113b8f37262b27820268a37">bsl::list&lt; VALUE, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="gac8430d1383d5d6bc57602e490b0ecc0c"></a><!-- doxytag: member="bsl::list::insert" ref="gac8430d1383d5d6bc57602e490b0ecc0c" args="(const_iterator position, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert into this list a copy of the specified <code>value</code> before the element at the specified <code>position</code> of this list. The newly inserted elements in this list is copy-constructed from <code>value</code>. </p>

<p>Referenced by <a class="el" href="group__bslstl__list.html#gadeb98f74827b9950281c3e2052cfdd59">bsl::list&lt; VALUE, ALLOCATOR &gt;::insert()</a>, and <a class="el" href="group__bslstl__list.html#ga5bb6a12020db04f7426f4cb84c767995">bsl::list&lt; VALUE, ALLOCATOR &gt;::list()</a>.</p>

</div>
</div>
<a class="anchor" id="ga97efa9459209cb9d21d841014bf478a4"></a><!-- doxytag: member="bsl::list::insert" ref="ga97efa9459209cb9d21d841014bf478a4" args="(const_iterator position, size_type n, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__list.html#ga00bb9bf4714747111e362ca39476707e">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert into this list the specified <code>n</code> copies of the specified <code>value</code> before the element at the specified <code>position</code> of this list. Each of the <code>n</code> newly inserted elements in this list is copy-constructed from <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="gadeb98f74827b9950281c3e2052cfdd59"></a><!-- doxytag: member="bsl::list::insert" ref="gadeb98f74827b9950281c3e2052cfdd59" args="(const_iterator position, InputIter first, InputIter last, typename enable_if&lt; !is_fundamental&lt; InputIter &gt;::value &amp;&amp;!is_enum&lt; InputIter &gt;::value &gt;::type *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structbsl_1_1enable__if.html">enable_if</a>&lt; !<a class="el" href="structbsl_1_1is__fundamental.html">is_fundamental</a>&lt; InputIter &gt;::value &amp;&amp;!<a class="el" href="structbsl_1_1is__enum.html">is_enum</a>&lt; InputIter &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__bslstl__list.html#gac8430d1383d5d6bc57602e490b0ecc0c">bsl::list&lt; VALUE, ALLOCATOR &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="gad9acaadae5c8562714adb86525bd7773"></a><!-- doxytag: member="bsl::list::erase" ref="gad9acaadae5c8562714adb86525bd7773" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this list the element at the specified <code>position</code>, and return an iterator referring to the element immediately following the removed element, or to the position returned by the <code>end</code> method if the removed element was the last in the sequence. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() )</code>. </p>

<p>Referenced by <a class="el" href="group__bslstl__list.html#gaaffd7b613113b8f37262b27820268a37">bsl::list&lt; VALUE, ALLOCATOR &gt;::assign()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa9f7761eba7da78a9506d9097890fdb1"></a><!-- doxytag: member="bsl::list::erase" ref="gaa9f7761eba7da78a9506d9097890fdb1" args="(const_iterator position, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this list the elements starting at the specified <code>first</code> position that are before the specified <code>last</code> position, and return an iterator referring to the element immediately following the last removed element, or the position returned by the method <code>end</code> if the removed elements were last in the sequence. The behavior is undefined unless <code>first</code> is an iterator in the range <code>[ begin(), end() ]</code> and <code>last</code> is an iterator in the range <code>[ first, end() ]</code> (both endpoints included). </p>

</div>
</div>
<a class="anchor" id="ga7368b6af294baa8309b32a811e8d581a"></a><!-- doxytag: member="bsl::list::swap" ref="ga7368b6af294baa8309b32a811e8d581a" args="(list &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this list with that of the specified <code>other</code> list, such that each list has, upon return, the value of the other list prior to this call. This method does not throw or invalidate iterators if <code>get_allocator</code>, invoked on this list and <code>other</code>, returns the same value. </p>

</div>
</div>
<a class="anchor" id="ga8b445f02e90e38f5d7cd2f8e1f3a0cff"></a><!-- doxytag: member="bsl::list::clear" ref="ga8b445f02e90e38f5d7cd2f8e1f3a0cff" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the elements from this list. </p>

</div>
</div>
<a class="anchor" id="gaf4e981f4e303a7a983b0606170d09530"></a><!-- doxytag: member="bsl::list::splice" ref="gaf4e981f4e303a7a983b0606170d09530" args="(const_iterator position, list &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert elements of the specified list <code>x</code> before the element at the specified <code>position</code> of this list, and remove those elements from <code>x</code>. The behavior is undefined unless <code>x</code> is not this list. </p>

</div>
</div>
<a class="anchor" id="ga897cecfd9bfea47bbf2358eac5df69b8"></a><!-- doxytag: member="bsl::list::splice" ref="ga897cecfd9bfea47bbf2358eac5df69b8" args="(const_iterator position, list &amp;x, const_iterator i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the element at the specified <code>i</code> position before the element at the specified <code>position</code> of this list, and remove this element from the specified list <code>x</code>. The behavior is undefined unless <code>i</code> refers to a valid element in <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga17a290c325f23a517640b43a44f47b20"></a><!-- doxytag: member="bsl::list::splice" ref="ga17a290c325f23a517640b43a44f47b20" args="(const_iterator position, list &amp;x, const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the elements starting at the specified <code>first</code> position and before the specified <code>last</code> position into this list, right before the element at the specified <code>position</code>, and remove those elements from the specified list <code>x</code>. The behavior is undefined unless <code>[first, last)</code> represents a range of valid elements in <code>x</code>, and <code>position</code> is not in the range <code>[first, last)</code>. </p>

</div>
</div>
<a class="anchor" id="ga7e9fcd8a5f57c36f26f5eaf29aae7479"></a><!-- doxytag: member="bsl::list::remove" ref="ga7e9fcd8a5f57c36f26f5eaf29aae7479" args="(const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase all the elements having the specified <code>value</code> from this list. </p>

</div>
</div>
<a class="anchor" id="ga68543b87d393c34790c387ca9c5dc59e"></a><!-- doxytag: member="bsl::list::remove_if" ref="ga68543b87d393c34790c387ca9c5dc59e" args="(Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">Predicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase from this list all the elements that are not predicted <code>false</code> by the specified predicate <code>pred</code>. </p>

</div>
</div>
<a class="anchor" id="ga82f5de958e913d73ced2ef6134de5572"></a><!-- doxytag: member="bsl::list::unique" ref="ga82f5de958e913d73ced2ef6134de5572" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase from this list all but the first element of every consecutive group of elements that have the same value. </p>

</div>
</div>
<a class="anchor" id="gaf78b98fa826460641a8f8b34b4032b64"></a><!-- doxytag: member="bsl::list::unique" ref="gaf78b98fa826460641a8f8b34b4032b64" args="(EqPredicate binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class EqPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">EqPredicate&nbsp;</td>
          <td class="paramname"> <em>binary_pred</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase from this list all but the first element of every consecutive group of elements that have the specified <code>binary_pred</code> predicates <code>true</code> for any two consecutive elements in the group. </p>

</div>
</div>
<a class="anchor" id="ga427a9819bd93f5d66a6dd61e834c140f"></a><!-- doxytag: member="bsl::list::merge" ref="ga427a9819bd93f5d66a6dd61e834c140f" args="(list &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Merge the specified sorted list <code>other</code> into this sorted list. The method has no effect if <code>other</code> is this list. The behavior is undefined unless both <code>other</code> and this list are sorted in non-decreasing order according to the ordering returned by <code>operator&lt;</code>. </p>

</div>
</div>
<a class="anchor" id="gaf7aa6d8260eb0f7f90894860b501c12e"></a><!-- doxytag: member="bsl::list::merge" ref="gaf7aa6d8260eb0f7f90894860b501c12e" args="(list &amp;other, COMPARE comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class COMPARE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1list.html">list</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMPARE&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Merge the specified sorted list <code>other</code> into this sorted list, using the specified <code>comp</code>, which defines a strict weak ordering, to order elements. The method has no effect if <code>other</code> is this list. The behavior is undefined unless both <code>other</code> and this list are sorted in non-decreasing order according to the ordering returned by <code>comp</code>. </p>

</div>
</div>
<a class="anchor" id="ga748a9f987759dd0cb85cddb343c3a807"></a><!-- doxytag: member="bsl::list::sort" ref="ga748a9f987759dd0cb85cddb343c3a807" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sort this list in non-decreasing order according to the orders returned by <code>operator&lt;</code>. </p>

</div>
</div>
<a class="anchor" id="gacd98bc33503dc5c7a91b7243eb7a97b8"></a><!-- doxytag: member="bsl::list::sort" ref="gacd98bc33503dc5c7a91b7243eb7a97b8" args="(COMPARE comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class COMPARE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">COMPARE&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sort this list in non-decreasing order according to the orders returned by the specified <code>comp</code> comparator. </p>

</div>
</div>
<a class="anchor" id="ga77b4a81041a41048e87f93852ed9aaa3"></a><!-- doxytag: member="bsl::list::reverse" ref="ga77b4a81041a41048e87f93852ed9aaa3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reverse the order of the elements in this list. </p>

</div>
</div>
<a class="anchor" id="ga444c64ece23c850f771a6acabc4ceaf3"></a><!-- doxytag: member="bsl::list::get_allocator" ref="ga444c64ece23c850f771a6acabc4ceaf3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a copy of the allocator used for memory allocation by this list. </p>

</div>
</div>
<a class="anchor" id="gaaeba5e48e2564e2975f8a73bf038cf26"></a><!-- doxytag: member="bsl::list::begin" ref="gaaeba5e48e2564e2975f8a73bf038cf26" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-mutating iterator referring to the first element in the list, if any, or one past the end of this list if this list is empty. </p>

</div>
</div>
<a class="anchor" id="gae8b31fdd693b70e4c29f8bb2625e3767"></a><!-- doxytag: member="bsl::list::end" ref="gae8b31fdd693b70e4c29f8bb2625e3767" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-mutating iterator referring to one past the end of this list. </p>

</div>
</div>
<a class="anchor" id="ga2238735ea85677aa2c3123f5b7a9d4f8"></a><!-- doxytag: member="bsl::list::rbegin" ref="ga2238735ea85677aa2c3123f5b7a9d4f8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a const reverse iterator referring to the last element of this list (i.e., the first element of the reverse sequence), if any, or one before the start if this list is empty. </p>

</div>
</div>
<a class="anchor" id="ga0a790a21e9f378cdcba75eb0fe2f6cd3"></a><!-- doxytag: member="bsl::list::rend" ref="ga0a790a21e9f378cdcba75eb0fe2f6cd3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a const reverse iterator referring to one before the start of this list. </p>

</div>
</div>
<a class="anchor" id="gaced4a510e95a473ab0d6172def0ed714"></a><!-- doxytag: member="bsl::list::cbegin" ref="gaced4a510e95a473ab0d6172def0ed714" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-mutating iterator referring to the first element in the list, if any, or one past the end of this list if this list is empty. </p>

</div>
</div>
<a class="anchor" id="ga66457b97f8c525546b3773bd3cb1223e"></a><!-- doxytag: member="bsl::list::cend" ref="ga66457b97f8c525546b3773bd3cb1223e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-mutating iterator referring to one past the end of the list. </p>

</div>
</div>
<a class="anchor" id="ga61dff8fef269f5ae29a51105dbd4e5d0"></a><!-- doxytag: member="bsl::list::crbegin" ref="ga61dff8fef269f5ae29a51105dbd4e5d0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a const reverse iterator referring to the last element of this list (i.e., the first element of the reverse sequence), if any, or one before the start if this list is empty. </p>

</div>
</div>
<a class="anchor" id="ga195576747609462cda1a5f4afe3fe5c2"></a><!-- doxytag: member="bsl::list::crend" ref="ga195576747609462cda1a5f4afe3fe5c2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a const reverse iterator referring to one before the start of this list. </p>

</div>
</div>
<a class="anchor" id="ga9788ff6ad6aa73bb50cfcb1453aba282"></a><!-- doxytag: member="bsl::list::empty" ref="ga9788ff6ad6aa73bb50cfcb1453aba282" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this list has no elements and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga1545c56b20443bb83944eecd2d336f65"></a><!-- doxytag: member="bsl::list::size" ref="ga1545c56b20443bb83944eecd2d336f65" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this list. </p>

</div>
</div>
<a class="anchor" id="gaeed01b7632ba60d2e0430852f46c8cee"></a><!-- doxytag: member="bsl::list::max_size" ref="gaeed01b7632ba60d2e0430852f46c8cee" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an upper bound on the largest number of elements that this list could possibly hold. Note that return value of this function does not guarantee that this list can successfully grow that large, or even close to that large without running out of resources. </p>

</div>
</div>
<a class="anchor" id="ga8d699005d3266376fa0098b09cf57919"></a><!-- doxytag: member="bsl::list::front" ref="ga8d699005d3266376fa0098b09cf57919" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the first element of this list. The behavior is undefined unless this list contains at least one element. </p>

</div>
</div>
<a class="anchor" id="gaa726208e09ae77d9305bfef41ecf1b42"></a><!-- doxytag: member="bsl::list::back" ref="gaa726208e09ae77d9305bfef41ecf1b42" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the last element of this list. The behavior is undefined unless this list contains at least one element. </p>

</div>
</div>
<a class="anchor" id="ga39c2b71f4356c6f9f1a69d441dda4c26"></a><!-- doxytag: member="bsl::operator==" ref="ga39c2b71f4356c6f9f1a69d441dda4c26" args="(const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> lists have the same value, and <code>false</code> otherwise. The <code>lhs</code> and the <code>rhs</code> objects have the same value if they have the same number of elements, and each element of <code>lhs</code> has same value as that of the corresponding element in <code>rhs</code>. This method requires that the (template parameter) <code>VALUE</code> type has <code>operator==</code> defined. </p>

</div>
</div>
<a class="anchor" id="gacea9175011d9b18a01cb38e6e23d56e0"></a><!-- doxytag: member="bsl::operator!=" ref="gacea9175011d9b18a01cb38e6e23d56e0" args="(const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> lists do not have the same value, and <code>false</code> otherwise. The <code>lhs</code> and the <code>rhs</code> objects do have the same value if they do not have the same number of elements, or at least one element of <code>lhs</code> does not have same value as that of the corresponding element in <code>rhs</code>. This method requires that the (template parameter) <code>VALUE</code> type has <code>operator==</code> defined. </p>

</div>
</div>
<a class="anchor" id="gacd1873ee9d29582411de3abe4a3e79ee"></a><!-- doxytag: member="bsl::operator&lt;" ref="gacd1873ee9d29582411de3abe4a3e79ee" args="(const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> list is lexicographically smaller than the specified <code>rhs</code> list, and <code>false</code> otherwise. The <code>lhs</code> is lexicographically smaller than the <code>rhs</code> if there exists an element <code>v</code> in <code>lhs</code> such that <code>v</code> is smaller than the corresponding element in <code>rhs</code>, and all elements before <code>v</code> in <code>lhs</code> have the same values as those of the corresponding elements in <code>rhs</code>. This method requires that the (template parameter) <code>VALUE</code> type has <code>operator&lt;</code> defined. </p>

</div>
</div>
<a class="anchor" id="ga8f4598ceb1aee9f39781704c381ed8d1"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga8f4598ceb1aee9f39781704c381ed8d1" args="(const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> list is lexicographically larger than the specified <code>rhs</code> list, and <code>false</code> otherwise. This method requires that the (template parameter) <code>VALUE</code> type has <code>operator&lt;</code> defined. </p>

</div>
</div>
<a class="anchor" id="ga7e448645b21786d13f6377a64adfce1f"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga7e448645b21786d13f6377a64adfce1f" args="(const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> list is lexicographically smaller than or equal to the specified <code>rhs</code> list, and <code>false</code> otherwise. This method requires that the (template parameter) <code>VALUE</code> type has <code>operator&lt;</code> defined. </p>

</div>
</div>
<a class="anchor" id="ga009bc1ba641b09a01e9e0c516cba7092"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga009bc1ba641b09a01e9e0c516cba7092" args="(const list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, const list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> list is lexicographically larger than or equal to the specified <code>rhs</code> list, and <code>false</code> otherwise. This method requires that the (template parameter) <code>VALUE</code> type has <code>operator&lt;</code> defined. </p>

</div>
</div>
<a class="anchor" id="ga8a4fac7379d969587e69a3186c91f583"></a><!-- doxytag: member="bsl::swap" ref="ga8a4fac7379d969587e69a3186c91f583" args="(list&lt; VALUE, ALLOCATOR &gt; &amp;lhs, list&lt; VALUE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of the specified <code>lhs</code> list with that of the specified <code>rhs</code> list, such that each list has upon return the value of the other list prior to this call. Note that this function does not throw if <code>lhs.get_allocator()</code> and <code>rhs.get_allocator()</code> are equal. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gade9b97ce7a3862897a9ea8ea6a0c0cad"></a><!-- doxytag: member="bsl::List_Node::d_prev" ref="gade9b97ce7a3862897a9ea8ea6a0c0cad" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodePtr <a class="el" href="structbsl_1_1List__Node.html">bsl::List_Node</a>&lt; VALUE &gt;::d_prev<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>pointer to the previous node in this list </p>

</div>
</div>
<a class="anchor" id="gaaab50cdc91f4e6a2e8770eb0d07a3df1"></a><!-- doxytag: member="bsl::List_Node::d_next" ref="gaaab50cdc91f4e6a2e8770eb0d07a3df1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodePtr <a class="el" href="structbsl_1_1List__Node.html">bsl::List_Node</a>&lt; VALUE &gt;::d_next<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>pointer to the next node in this list </p>

</div>
</div>
<a class="anchor" id="gaf999f184f71f64160c304112a724c0ab"></a><!-- doxytag: member="bsl::List_Node::d_value" ref="gaf999f184f71f64160c304112a724c0ab" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE <a class="el" href="structbsl_1_1List__Node.html">bsl::List_Node</a>&lt; VALUE &gt;::d_value<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>list element </p>

</div>
</div>
<a class="anchor" id="gaa2dc7fbe23580d0871dd33f3001e9306"></a><!-- doxytag: member="bsl::list::AllocAndSizeWrapper::d_size" ref="gaa2dc7fbe23580d0871dd33f3001e9306" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt; VALUE, ALLOCATOR &gt;::AllocAndSizeWrapper::d_size<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>allocated size </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="gaf487851297bff2935c50a15ddc1b79dd"></a><!-- doxytag: member="bsl::List_Iterator::List_Iterator&lt; const VALUE, NODEPTR, DIFFTYPE &gt;" ref="gaf487851297bff2935c50a15ddc1b79dd" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class List_Iterator&lt; const VALUE, NODEPTR, DIFFTYPE &gt;<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaccd8fce66e676a9bc1c5f7e6a671450e"></a><!-- doxytag: member="bsl::list::AllocAndSizeWrapper" ref="gaccd8fce66e676a9bc1c5f7e6a671450e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend struct AllocAndSizeWrapper<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8438538c02f3493d2e178ebb04591068"></a><!-- doxytag: member="bsl::list::NodeProctor" ref="ga8438538c02f3493d2e178ebb04591068" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR = bsl::allocator&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class NodeProctor<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga86f0255807453efe1bbe545680f21219"></a><!-- doxytag: member="bsl::List_Iterator::operator==" ref="ga86f0255807453efe1bbe545680f21219" args="(List_Iterator&lt; T1, NODEP, DIFFT &gt;, List_Iterator&lt; T2, NODEP, DIFFT &gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODEPTR, class DIFFTYPE&gt; </div>
<div class="memtemplate">
template&lt;class T1 , class T2 , class NODEP , class DIFFT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T1, NODEP, DIFFT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1List__Iterator.html">List_Iterator</a>&lt; T2, NODEP, DIFFT &gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:22 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
