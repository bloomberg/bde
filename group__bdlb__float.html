<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlb_float Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlb_float<br/>
<small>
[<a class="el" href="group__bdlb.html">Package bdlb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide floating-point classification types and functions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html">bdlb</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Classification of Floating-Point Numbers</a> </li>
<li>
<a href="#3.2">Future Enhancements</a> </li>
<li>
<a href="#3.3">Thread Safety</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Basic Syntax</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide floating-point classification types and functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlb_1_1Float.html">bdlb::Float</a> </td><td>namespace for floating-point classification types and functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a utility <code>struct</code>, <code><a class="el" href="structbdlb_1_1Float.html">bdlb::Float</a></code>, that provides functions analogous to C99 <code>&lt;math.h&gt;</code> library macros such as <code>isinf</code> and <code>isnan</code> that return whether a <code>float</code> or <code>double</code> value is infinite or not-a-number, respectively. These macros are not available in C++98 and so are provided as functions in this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classification_of_floating-point_numbers"></a> <a class="anchor" id="description.classification_of_floating-point_numbers"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Classification of Floating-Point Numbers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Floating-point numbers are used to represent a subset of the set of real numbers. The C++ <code>float</code> and <code>double</code> types are used to hold floating-point numbers, with <code>float</code> having (much) less precision than <code>double</code>. Floating point numbers can be classified into the following disjoint sets: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Zero       positive and negative zero
  Normal     full-precision, non-zero, normal numbers
  Subnormal  reduced-precision numbers with small absolute values
  Infinity   positive and negative infinities
  NaN        not a number
</pre></div><br/>
<br/>
 A NaN value can be further classified into two disjoint subsets: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Signaling NaN  invalid values that raises a signal in computations
  Quiet NaN      indeterminate values that propagate through computations
</pre></div><br/>
<br/>
 Note that not all platforms support signaling NaNs and that even those that do often require a specific action to enable signals on floating-point traps. Signaling NaNs are never the result of a normal floating-point operation. They are most often used as sentinels to detect the use of a value that has not yet been computed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Quiet NaNs are the result of certain operations where the result is not defined mathematically. If an expression that results in a (quiet) NaN is used in a subsequent computation, the result is usually also a (quiet) NaN. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>On platforms that implement the IEEE 754 standard for floating-point arithmetic, the following conditions result in non-normal floating-point values. In the following table, "NaN" always refers to a quiet NaN: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Condition                   Result
  -------------------         -----------------
  Overflow                    Infinity
  Underflow                   Subnormal or Zero
  Normal / Infinity           Zero
  Infinity * Infinity         Infinity
  nonzero / Zero              Infinity
  Infinity + Infinity         Infinity
  Zero / Zero                 NaN
  Infinity - Infinity         NaN
  Infinity / Infinity         NaN
  Infinity * Zero             NaN
</pre></div><br/>
<br/>
 Note that the operations that result in Infinity follow the normal rules for sign propagation, e.g., -5.0 / 0.0 results in negative Infinity. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="future_enhancements"></a> <a class="anchor" id="description.future_enhancements"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Future Enhancements: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>At present, this component works with <code>float</code> and <code>double</code> numbers. In the future, it will also work with <code>long double</code>. Note that casting a <code>long double</code> to <code>double</code> before applying these classification functions will not always yield correct results. For example, a large <code>long double</code> may get demoted to an infinite <code>double</code>. Similarly, a small <code>long double</code> may get demoted to a subnormal or zero <code>double</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Any of the functions in this component may safely be called simultaneously from multiple threads, even with the same arguments. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_syntax"></a> <a class="anchor" id="usage.example_1~3A_basic_syntax"></a> <a class="anchor" id="description.usage.example_1~3A_basic_syntax"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Syntax: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>On platforms that the implement IEEE 754 standard for floating-point arithmetic, dividing a positive number by zero yields positive infinity and dividing a negative number by zero yields negative infinity. The result of division by zero will therefore be detected as infinite by the <code>isInfinite</code> method and classified as infinity by the <code>classify</code> and <code>classifyFine</code> methods in this component: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> zero =  0.0;
  <span class="keywordtype">double</span> a    =  2.3  / zero;
  <span class="keywordtype">double</span> b    = -0.55 / zero;
  assert(<span class="keyword">true</span>                             == <a class="code" href="structbdlb_1_1Float.html#a3da67a9132bc88c4dbfacf2002f42d0f">bdlb::Float::isZero</a>(zero));
  assert(<span class="keyword">true</span>                             == <a class="code" href="structbdlb_1_1Float.html#a8e840f8e9e7f937406ef7fab03914745">bdlb::Float::isInfinite</a>(a));
  assert(<span class="keyword">true</span>                             == <a class="code" href="structbdlb_1_1Float.html#a8e840f8e9e7f937406ef7fab03914745">bdlb::Float::isInfinite</a>(b));
  assert(<a class="code" href="structbdlb_1_1Float.html#a1a4f190ba22c78dd5a4f2d1a835c9137a5681a8c9c03e24ff5a1103a9614d71a0" title="positive or negative zero">bdlb::Float::k_ZERO</a>              == <a class="code" href="structbdlb_1_1Float.html#ae8ceabbb8f0ccddb4d80bb97249d8cf8">bdlb::Float::classify</a>(zero));
  assert(<a class="code" href="structbdlb_1_1Float.html#a1a4f190ba22c78dd5a4f2d1a835c9137a506bf12920064eac5e3716c2ebc3f1fe" title="positive or negative infinity">bdlb::Float::k_INFINITE</a>          == <a class="code" href="structbdlb_1_1Float.html#ae8ceabbb8f0ccddb4d80bb97249d8cf8">bdlb::Float::classify</a>(a));
  assert(<a class="code" href="structbdlb_1_1Float.html#a1a4f190ba22c78dd5a4f2d1a835c9137a506bf12920064eac5e3716c2ebc3f1fe" title="positive or negative infinity">bdlb::Float::k_INFINITE</a>          == <a class="code" href="structbdlb_1_1Float.html#ae8ceabbb8f0ccddb4d80bb97249d8cf8">bdlb::Float::classify</a>(b));
  assert(<a class="code" href="structbdlb_1_1Float.html#ab9fadf3988569b87af1909e714077340ae5423a3f9949349a32b243182086be4e">bdlb::Float::k_POSITIVE_INFINITY</a> == <a class="code" href="structbdlb_1_1Float.html#a5fad19b785cdac7d1fa4a070062f8bc3">bdlb::Float::classifyFine</a>(a));
  assert(<a class="code" href="structbdlb_1_1Float.html#ab9fadf3988569b87af1909e714077340a95f70105d20a7360c32d6a811fc3f99e">bdlb::Float::k_NEGATIVE_INFINITY</a> == <a class="code" href="structbdlb_1_1Float.html#a5fad19b785cdac7d1fa4a070062f8bc3">bdlb::Float::classifyFine</a>(b));
</pre></div><br/>
<br/>
 Note that the sign rules apply as usual: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> nzero = -0.0;
  <span class="keywordtype">double</span> bn    = -0.55 / nzero;
  assert(<a class="code" href="structbdlb_1_1Float.html#ab9fadf3988569b87af1909e714077340ae5423a3f9949349a32b243182086be4e">bdlb::Float::k_POSITIVE_INFINITY</a> == <a class="code" href="structbdlb_1_1Float.html#a5fad19b785cdac7d1fa4a070062f8bc3">bdlb::Float::classifyFine</a>(bn));
</pre></div><br/>
<br/>
 The result of multiplying infinity by infinity is also infinity, but the result of multiplying infinity by zero is an indeterminate value (quiet NaN): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> c = a * b;
  <span class="keywordtype">double</span> d = a * zero;
  assert(<span class="keyword">true</span>  == <a class="code" href="structbdlb_1_1Float.html#a8e840f8e9e7f937406ef7fab03914745">bdlb::Float::isInfinite</a>(c));
  assert(<span class="keyword">false</span> == <a class="code" href="structbdlb_1_1Float.html#a8e840f8e9e7f937406ef7fab03914745">bdlb::Float::isInfinite</a>(d));
  assert(<span class="keyword">true</span>  == <a class="code" href="structbdlb_1_1Float.html#a0c30435d684fc5f7bf021fb4496c2411">bdlb::Float::isNan</a>(d));
  assert(<span class="keyword">true</span>  == <a class="code" href="structbdlb_1_1Float.html#a22b7725e5d450e461e5a7d3af419ff6f">bdlb::Float::isQuietNan</a>(d));
  assert(<span class="keyword">false</span> == <a class="code" href="structbdlb_1_1Float.html#ab4a1e9ca38dfe2c808b72c320eb45bda">bdlb::Float::isSignalingNan</a>(d));
</pre></div><br/>
<br/>
 Quiet NaNs propagate such that further calculations also yield quiet NaNs: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> g = d - 3.4e12;
  assert(<span class="keyword">false</span> == <a class="code" href="structbdlb_1_1Float.html#a8e840f8e9e7f937406ef7fab03914745">bdlb::Float::isInfinite</a>(g));
  assert(<span class="keyword">true</span>  == <a class="code" href="structbdlb_1_1Float.html#a0c30435d684fc5f7bf021fb4496c2411">bdlb::Float::isNan</a>(g));
  assert(<span class="keyword">true</span>  == <a class="code" href="structbdlb_1_1Float.html#a22b7725e5d450e461e5a7d3af419ff6f">bdlb::Float::isQuietNan</a>(g));
</pre></div><br/>
<br/>
 We can also detect whether a value has full precision (normal) or is so small (close to zero) that precision has been lost (subnormal): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> e = -10.0 / 11.0;    <span class="comment">// Full precision</span>
  <span class="keywordtype">double</span> f = e     / DBL_MAX; <span class="comment">// Lost precision</span>
  assert(<span class="keyword">true</span>                     == <a class="code" href="structbdlb_1_1Float.html#a6784c20506066d18914e1e957bcf1bf0">bdlb::Float::isNormal</a>(e));
  assert(<span class="keyword">false</span>                    == <a class="code" href="structbdlb_1_1Float.html#ab46eb7f71e84025c8510522cbf4189d6">bdlb::Float::isSubnormal</a>(e));
  assert(<span class="keyword">false</span>                    == <a class="code" href="structbdlb_1_1Float.html#a6784c20506066d18914e1e957bcf1bf0">bdlb::Float::isNormal</a>(f));
  assert(<span class="keyword">true</span>                     == <a class="code" href="structbdlb_1_1Float.html#ab46eb7f71e84025c8510522cbf4189d6">bdlb::Float::isSubnormal</a>(f));
  assert(<a class="code" href="structbdlb_1_1Float.html#a1a4f190ba22c78dd5a4f2d1a835c9137a1be764f622fe7c910280a1f7f22d095e" title="full-precision, non-zero, normal number">bdlb::Float::k_NORMAL</a>    == <a class="code" href="structbdlb_1_1Float.html#ae8ceabbb8f0ccddb4d80bb97249d8cf8">bdlb::Float::classify</a>(e));
  assert(<a class="code" href="structbdlb_1_1Float.html#a1a4f190ba22c78dd5a4f2d1a835c9137a43742d0b835fb9eff9b8c72893849eb8" title="reduced-precision numb with a small abs value">bdlb::Float::k_SUBNORMAL</a> == <a class="code" href="structbdlb_1_1Float.html#ae8ceabbb8f0ccddb4d80bb97249d8cf8">bdlb::Float::classify</a>(f));
</pre></div><br/>
<br/>
 The <code>Classification</code> enumeration type is designed so that each classification occupies a separate bit. This makes it easy to test for multiple classifications in one test. For example, if we are interested in very that zero or denormalized (i.e., very small), we can detect both conditions with a single mask: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">int</span> SMALL_MASK = <a class="code" href="structbdlb_1_1Float.html#a1a4f190ba22c78dd5a4f2d1a835c9137a5681a8c9c03e24ff5a1103a9614d71a0" title="positive or negative zero">bdlb::Float::k_ZERO</a> | bdlb::Float::k_SUBNORMAL;
  assert(0 != (SMALL_MASK &amp; <a class="code" href="structbdlb_1_1Float.html#ae8ceabbb8f0ccddb4d80bb97249d8cf8">bdlb::Float::classify</a>(0.0)));
  assert(0 != (SMALL_MASK &amp; <a class="code" href="structbdlb_1_1Float.html#ae8ceabbb8f0ccddb4d80bb97249d8cf8">bdlb::Float::classify</a>(f)));
  assert(0 == (SMALL_MASK &amp; <a class="code" href="structbdlb_1_1Float.html#ae8ceabbb8f0ccddb4d80bb97249d8cf8">bdlb::Float::classify</a>(e)));
</pre></div><br/>
<br/>
 Note, however, that although we can create a mask with several classification bits, a single number belongs to only one classification and the return value of <code>classify</code> will have only one bit set at a time. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:34 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
