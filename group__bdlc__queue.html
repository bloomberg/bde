<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlc_queue Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlc_queue<br/>
<small>
[<a class="el" href="group__bdlc.html">Package bdlc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an in-place double-ended queue of <code>T</code> values.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html">bdlc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Abstract Representation</a> </li>
<li>
<a href="#3.2">Performance</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an in-place double-ended queue of <code>T</code> values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a></code> instead. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a> </td><td>memory manager for in-place queue of <code>T</code> values  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements an efficient, in-place, indexable, double-ended queue of <code>T</code> values, where <code>T</code> is a templatized, user-defined type. The functionality of a <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> is relatively rich; it is almost a proper superset of a vector, with efficient implementations of <code>front</code>, <code>back</code>, <code>pushFront</code>, and <code>popBack</code> methods added. However, the queue does <em>not</em> provide a <code>data</code> method (yielding direct access to the underlying memory), because its internal organization is not array-like. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Typical usage involves pushing (appending) values to the back of the queue, popping (removing) values from the front of the queue, and retrieving (operator[]) values from a specified index; unlike the O[n] runtime cost for an <code>insert(0, v)</code>, however, a <code>pushFront</code> has a constant average-case cost. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that appending, inserting, removing or pushing (back and front) elements potentially alters the memory address of other element in the queue, and there is no guarantee of contiguous storage of consecutive queued elements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="abstract_representation"></a> <a class="anchor" id="description.abstract_representation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Abstract Representation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The logical organization of an indexable, in-place, double-ended <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> object <code>q</code> is shown below, along with an illustration of some of its most common methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">                                    QUEUE
                 v = q.front()                          v = q.back()
                  +------+------+------+------+--<span class="comment">//--+------+</span>
   q.popFront() &lt;-|      |      |      |      |      |      |&lt;- pushBack(v)
 q.pushFront(v) -&gt;|      |      |      |      |      |      |-&gt; popBack()
                  +------+------+------+------+--<span class="comment">//--+------+</span>
                    q[0]   q[1]                       q[n-1]
                  &lt;------------ n = q.length() --<span class="comment">//---------&gt;</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance"></a> <a class="anchor" id="description.performance"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Performance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following characterizes the performance of representative operations using big-oh notation, O[f(N,M)], where the names <code>N</code> and <code>M</code> also refer to the number of respective elements in each container (i.e., its <code>length</code>). Here the average case, A[f(N)], is the amortized cost, which is defined as the cost of <code>N</code> successive invocations of the operation divided by <code>N</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">     Operation           Worst Case          Average Case
     ---------           ----------          ------------
     DEFAULT CTOR        O[1]
     COPY CTOR(N)        O[N]
     N.DTOR()            O[1]
     N.OP=(M)            O[M]
     OP==(N,M)           O[min(N,M)]

     N.pushFront(value)  O[N]                A[1]
     N.pushBack(value)   O[N]                A[1]
     N.popFront()        O[1]
     N.popBack()         O[1]

     N.append(value)     O[N]                A[1]
     N.insert(value)     O[N]
     N.replace(value)    O[1]
     N.remove(index)     O[N]

     N.OP[]()            O[1]
     N.length()          O[1]
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate how to create and use a queue. First, create an empty <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt;double&gt;</code> <code>q</code> and populate it with two elements <code>E1</code> and <code>E2</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">double</span> E1 = 100.01;
      <span class="keyword">const</span> <span class="keywordtype">double</span> E2 = 200.02;

      <a class="code" href="classbdlc_1_1Queue.html">bdlc::Queue&lt;double&gt;</a> q;          assert( 0 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());

      q.<a class="code" href="classbdlc_1_1Queue.html#af6dac14aff49a2d906ce7832089f6ab9">append</a>(E1);                   assert( 1 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E1 == q[0]);
                                      assert(E1 == q.<a class="code" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a>());
                                      assert(E1 == q.<a class="code" href="classbdlc_1_1Queue.html#a6596119eeb67ef808cf52ab98a906693">back</a>());

      q.<a class="code" href="classbdlc_1_1Queue.html#af6dac14aff49a2d906ce7832089f6ab9">append</a>(E2);                   assert( 2 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E1 == q[0]);
                                      assert(E2 == q[1]);
                                      assert(E1 == q.<a class="code" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a>());
                                      assert(E2 == q.<a class="code" href="classbdlc_1_1Queue.html#a6596119eeb67ef808cf52ab98a906693">back</a>());
</pre></div><br/>
<br/>
 Now, pop the first element (<code>E1</code>) from <code>q</code> and push the same value to the front of the queue. <br/>
<br/>
<div class="fragment"><pre class="fragment">      q.<a class="code" href="classbdlc_1_1Queue.html#a69b2057cdc8eebc6a7b616ebfb8daadd">popFront</a>();                   assert( 1 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E2 == q[0]);
                                      assert(E2 == q.<a class="code" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a>());
                                      assert(E2 == q.<a class="code" href="classbdlc_1_1Queue.html#a6596119eeb67ef808cf52ab98a906693">back</a>());

      q.<a class="code" href="classbdlc_1_1Queue.html#ae062b1d0a7f732e6cb97544781432e20">pushFront</a>(E1);                assert( 2 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E1 == q[0]);
                                      assert(E2 == q[1]);
                                      assert(E1 == q.<a class="code" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a>());
                                      assert(E2 == q.<a class="code" href="classbdlc_1_1Queue.html#a6596119eeb67ef808cf52ab98a906693">back</a>());
</pre></div><br/>
<br/>
 Then, pop the last element (<code>E2</code>) from the back of <code>q</code> and push a new value <code>E3</code> at the end of the queue. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">double</span> E3 = 300.03;

      q.<a class="code" href="classbdlc_1_1Queue.html#ab89dbf8bdc8bc2d15d27f51843e19ac2">popBack</a>();                    assert( 1 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E1 == q[0]);
                                      assert(E1 == q.<a class="code" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a>());
                                      assert(E1 == q.<a class="code" href="classbdlc_1_1Queue.html#a6596119eeb67ef808cf52ab98a906693">back</a>());

      q.<a class="code" href="classbdlc_1_1Queue.html#a9172a19b3e9d34b5a82fdc1c7f77de2d">pushBack</a>(E3);                 assert( 2 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E1 == q[0]);
                                      assert(E3 == q[1]);
                                      assert(E1 == q.<a class="code" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a>());
                                      assert(E3 == q.<a class="code" href="classbdlc_1_1Queue.html#a6596119eeb67ef808cf52ab98a906693">back</a>());
</pre></div><br/>
<br/>
 Now, assign <code>E2</code> to the first element (index position 0) of <code>q</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      q[0] = E2;                      assert( 2 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E2 == q[0]);
                                      assert(E3 == q[1]);
</pre></div><br/>
<br/>
 Then, insert a new value in the middle (index position 1) of <code>q</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">double</span> E4 = 400.04;

      q.<a class="code" href="classbdlc_1_1Queue.html#acbf8e4df0a442b760d9970a780b5e3aa">insert</a>(1, E4);                assert( 3 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E2 == q[0]);
                                      assert(E4 == q[1]);
                                      assert(E3 == q[2]);
</pre></div><br/>
<br/>
 Next, iterate over the elements in <code>q</code>, printing them in increasing order of their index positions, <code>[0 .. q.length() - 1]</code>, <br/>
<br/>
<div class="fragment"><pre class="fragment">      bsl::cout &lt;&lt; <span class="charliteral">&#39;[&#39;</span>;
      <span class="keywordtype">int</span> len = q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i) {
          bsl::cout &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; q[i];
      }
      bsl::cout &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span> &lt;&lt; bsl::endl;
</pre></div><br/>
<br/>
 which produces the following output on <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      [ 200.02 400.04 300.03 ]
</pre></div><br/>
<br/>
 Finally, remove the elements from queue <code>q</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      q.<a class="code" href="classbdlc_1_1Queue.html#a83284e23c41b9dcb6301b5dafdc22ae6">remove</a>(2);                    assert( 2 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E2 == q[0]);
                                      assert(E4 == q[1]);

      q.<a class="code" href="classbdlc_1_1Queue.html#a83284e23c41b9dcb6301b5dafdc22ae6">remove</a>(0);                    assert( 1 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
                                      assert(E4 == q[0]);

      q.<a class="code" href="classbdlc_1_1Queue.html#a83284e23c41b9dcb6301b5dafdc22ae6">remove</a>(0);                    assert( 0 == q.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>());
</pre></div><br/>
<br/>
 Note that, in general, specifying index positions greater than or equal to length() will result in undefined behavior. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:37 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
