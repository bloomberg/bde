<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlsb_overflowmemoutstreambuf Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlsb_overflowmemoutstreambuf<br/>
<small>
[<a class="el" href="group__bdlsb.html">Package bdlsb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an overflowable output <code>streambuf</code> using a client buffer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlsb.html">bdlsb</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Overflow Buffer</a> </li>
<li>
<a href="#3.2">Streaming Architecture</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Basic Use of <code>bdlsb::OverflowMemOutStreamBuf</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an overflowable output <code>streambuf</code> using a client buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a> </td><td>overflowable output <code>bsl::streambuf</code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlsb__overflowmemoutput.html" title="Provide an overflowable output streambuf using a client buffer.">Component bdlsb_overflowmemoutput</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements the output portion of the <code>bsl::basic_streambuf</code> protocol using a user-supplied initial buffer and a dynamically allocated overflow buffer. As with <code>bdlsb_fixedmemoutput</code>, users supply the character buffer at construction. Unlike <code>bdlsb_fixedmemoutput</code>, they can no longer reinitialize the stream buffer with a different character buffer by calling the <code>pubsetbuf</code> method; instead, if that buffer runs out, the <code><a class="el" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a></code> will allocate another buffer (see "Overflow Buffer" below). The only difference between this component and <code>bdlsb_overflowmemoutput</code> is that the class <code><a class="el" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a></code> is derived from a <code>bsl::streambuf</code>. Method names necessarily correspond to those specified by the protocol. Refer to the C++ Standard, Section 27.5.2, for a full specification of the <code>bsl::basic_streambuf</code> interface. This component provides none of the input-related functionality of <code>basic_streambuf</code> (see Streaming Architecture, below), nor does it use locales in any way. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="overflow_buffer"></a> <a class="anchor" id="description.overflow_buffer"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Overflow Buffer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This output stream buffer will use the initial buffer (supplied at construction) as its output buffer. If an overflow of the initial buffer were to occur, an additional buffer (the overflow buffer) will be allocated. If this overflow buffer ever becomes full, it will be automatically grown. The overflow buffer grows geometrically (to twice the current overflow buffer size) whenever the amount of data written exceeds the amount of space available. On growth, the old overflow buffer is copied over to the newly allocated overflow buffer, and then deallocated, thus after any write/seek forward one cannot assume that the overflow buffer is still the same memory. Data in the overflow buffer beyond the reach of the current write position is not guaranteed to be preserved after a growth operation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="streaming_architecture"></a> <a class="anchor" id="description.streaming_architecture"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Streaming Architecture: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Stream buffers are designed to decouple device handling from content formatting, providing the requisite device handling and possible buffering services, and leaving the formatting to the client stream. The standard C++ IOStreams library further partitions streaming into input streaming and output streaming, separating responsibilities for each at both the stream layer and the stream buffer layer. The BDE streaming library for <code>bdex</code>, including all of <code>bdlsb</code>, follows this model. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_use_of_bdlsb~3A~3Aoverflowmemoutstreambuf"></a> <a class="anchor" id="usage.example_1~3A_basic_use_of_bdlsb~3A~3Aoverflowmemoutstreambuf"></a> <a class="anchor" id="description.usage.example_1~3A_basic_use_of_bdlsb~3A~3Aoverflowmemoutstreambuf"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Use of bdlsb::OverflowMemOutStreamBuf: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates using a <code><a class="el" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a></code> in order to test a user defined stream type, <code>CapitalizingStream</code>. In this example, we'll define a simple example stream type <code>CapitalizingStream</code> that capitalizes lower-case ASCII data written to the stream. In order to test this <code>CapitalizingStream</code> type, we'll create an instance, and supply it a <code><a class="el" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a></code> object as its stream buffer; after we write some character data to the <code>CapitalizingStream</code> we'll inspect the buffer of the <code><a class="el" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a></code> and verify its contents match our expected output. Note that to simplify the example, we do not include the functions for streaming non-character data, e.g., numeric values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define our example stream class, <code>CapitalizingStream</code> (which we will later test using 'bdlsbOverflowMemOutStreamBuf): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>CapitalizingStream {
      <span class="comment">// This class capitalizes lower-case ASCII characters that are output.</span>

      <span class="comment">// DATA</span>
      bsl::streambuf  *d_streamBuffer_p;   <span class="comment">// pointer to a stream buffer</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> CapitalizingStream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(CapitalizingStream&amp;  stream,
                                            <span class="keyword">const</span> <span class="keywordtype">char</span>          *data);
    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> CapitalizingStream(bsl::streambuf *streamBuffer);
          <span class="comment">// Create a capitalizing stream using the specified &#39;streamBuffer&#39;</span>
          <span class="comment">// as the underlying stream buffer for the stream.</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  CapitalizingStream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(CapitalizingStream&amp;  stream,
                                 <span class="keyword">const</span> <span class="keywordtype">char</span>          *data);
      <span class="comment">// Write the specified &#39;data&#39; in capitalized form to the specified</span>
      <span class="comment">// &#39;stream&#39;.</span>

  CapitalizingStream::CapitalizingStream(bsl::streambuf *streamBuffer)
  : d_streamBuffer_p(streamBuffer)
  {
  }
</pre></div><br/>
<br/>
 As is typical, the streaming operators are made friends of the class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that we cannot directly use <code>bsl::toupper</code> to capitalize each individual character, because <code>bsl::toupper</code> operates on <code>int</code> instead of <code>char</code>. Instead, we call a function <code>ucharToUpper</code> that works in terms of <code>unsigned char</code>. some care must be made to avoid undefined and implementation-specific behavior during the conversions to and from <code>int</code>. Therefore we wrap <code>bsl::toupper</code> in an interface that works in terms of <code>unsigned char</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ucharToUpper(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> input)
      <span class="comment">// Return the upper-case equivalent to the specified &#39;input&#39; character.</span>
  {
      <span class="keywordflow">return</span> bsl::toupper(input);
  }
</pre></div><br/>
<br/>
 Finally, we use the <code>transform</code> algorithm to convert lower-case characters to upper-case. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// FREE OPERATORS</span>
  CapitalizingStream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(CapitalizingStream&amp;  stream,
                                 <span class="keyword">const</span> <span class="keywordtype">char</span>          *data)
  {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> tmp(data);
      bsl::transform(tmp.begin(),
                     tmp.end(),
                     tmp.begin(),
                     ucharToUpper);
      stream.d_streamBuffer_p-&gt;sputn(tmp.data(), tmp.length());
      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 Now, we create an instance of <code><a class="el" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a></code> that will serve as underlying stream buffer for our <code>CapitalingStream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { INITIAL_CAPACITY = 10 };
  <span class="keywordtype">char</span> buffer[INITIAL_CAPACITY];

  <a class="code" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a> streamBuffer(buffer, INITIAL_CAPACITY);
</pre></div><br/>
<br/>
 Now, we test our <code>CapitalingStream</code> by supplying the created instance of <code><a class="el" href="classbdlsb_1_1OverflowMemOutStreamBuf.html">bdlsb::OverflowMemOutStreamBuf</a></code> and using it to inspect the output of the stream: <br/>
<br/>
<div class="fragment"><pre class="fragment">  CapitalizingStream  testStream(&amp;streamBuffer);
  testStream &lt;&lt; <span class="stringliteral">&quot;Hello world.&quot;</span>;
</pre></div><br/>
<br/>
 Finally, we verify that the streamed data has been capitalized and the portion of the data that does not fit into initial buffer is placed into dynamically allocated overflow buffer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(10 == streamBuffer.dataLengthInInitialBuffer());
  assert(0  == strncmp(<span class="stringliteral">&quot;HELLO WORL&quot;</span>,
                       streamBuffer.initialBuffer(),
                       streamBuffer.dataLengthInInitialBuffer()));
  assert(2  == streamBuffer.dataLengthInOverflowBuffer());
  assert(0  == strncmp(<span class="stringliteral">&quot;D.&quot;</span>,
                       streamBuffer.overflowBuffer(),
                       streamBuffer.dataLengthInOverflowBuffer()));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:48 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
