<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsc_cbchannelallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsc_cbchannelallocator<br/>
<small>
[<a class="el" href="group__btlsc.html">Package btlsc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide protocol for non-blocking stream-based channel allocators.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsc.html">btlsc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Protocol Hierarchy</a> </li>
<li>
<a href="#3.2">Non-Blocking Channel Allocation</a> <ul>
<li>
<a href="#3.2.1">Callback Functor Registration</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Asynchronous Events</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Server Side</a> </li>
<li>
<a href="#3.4.2">Client Side</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide protocol for non-blocking stream-based channel allocators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a> </td><td>non-blocking stream-based channel allocator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsc__channelallocator.html" title="Provide protocol for blocking stream-based channel allocators.">Component btlsc_channelallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code>, that defines an abstract interface for a non-blocking mechanism that allocates and deallocates non-blocking channels with and without timeout capability; the allocation itself does <em>not</em> have timeout capability. Each channel allocated through this interface is an end point of a bi-directional stream-based communication connection to a peer; connection details, such as who the peer is, whether there is indeed one peer or multiple similar peers, and how the connection came to be, are not relevant to this channel-allocator protocol, and are therefore abstracted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In particular, <code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code> can allocate non-blocking channels of type <code><a class="el" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a></code> and <code><a class="el" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a></code>, i.e., untimed and timed non-blocking channels. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="protocol_hierarchy"></a> <a class="anchor" id="description.protocol_hierarchy"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Protocol Hierarchy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code> forms the base of an interface hierarchy; other interfaces may be defined by direct public inheritance: <br/>
<br/>
<div class="fragment"><pre class="fragment">                     ,-------------------------.
                    ( <a class="code" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a> )
                     `-------------------------<span class="stringliteral">&#39;</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="non-blocking_channel_allocation"></a> <a class="anchor" id="description.non-blocking_channel_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Non-Blocking Channel Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This protocol establishes methods for allocating non-blocking stream-based channels in a non-blocking manner; each method registers a user-supplied callback function object (functor) and returns immediately. A successful return status implies that the registered callback will be invoked (and, conversely, an unsuccessful status implies otherwise). The callback, in turn, will communicate the results of the registered allocation attempt. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Enqueued allocation operations proceed asynchronously to one of three possible results: (1) "success" -- the requested channel is allocated and its address is passes to the callback function: in this case the callback "status" argument has no meaning, (2) "interrupted" -- the operation was interrupted (e.g., via an asynchronous event): the channel address is null and the (non-negative) status conveys the nature of the interruption, (3) "canceled" -- the operation was aborted (synchronously) by an explicit call to <code>cancelAll</code>: the channel address in null and the "status" is -1, or (4) "error" -- an implementation-dependent error occurred: the channel address is null and status is less than -1. The user may retry interrupted and canceled operations with a reasonable expectation of success. An "error" status implies that the allocation is unlikely to succeed if retried, but does not necessarily invalidate the allocator. The <code>isInvalid</code> method may be used to confirm the occurrence of a permanent error. If the allocator is valid, an allocation request will be enqueued and may succeed. Otherwise, the allocation request itself will not succeed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The meanings of the callback function status value for an unsuccessful allocation (i.e., a null channel address) are summarized as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot;status&quot;</span>    meaning (only when returned channel address is null)
  --------    ---------------------------------------------------------
  positive    Interruption by an <span class="stringliteral">&quot;asynchronous event&quot;</span>

  -1          Operation explicitly canceled (synchronously) by the user

  &lt; -1        Allocation operation unable to succeed at this time
</pre></div><br/>
<br/>
 Note that unless asynchronous events are explicitly enabled (see below), they are ignored, and "status" will never be positive. Also note that whether the callback is invoked before or after the registering method returns is not specified; in either case, if the registration was successful, then the return value will reflect success. Finally, note that, for consistency with timed allocators, a status of 0 is reserved for a timeout (which is not supported in this untimed allocator). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="callback_functor_registration"></a> <a class="anchor" id="non-blocking_channel_allocation.callback_functor_registration"></a> <a class="anchor" id="description.non-blocking_channel_allocation.callback_functor_registration"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Callback Functor Registration: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once an operation is successfully initiated, a (reference-counted) copy of the (<code>bdlf</code>) callback functor is retained by the concrete allocator until the callback is executed. Therefore, the user need not be concerned with preserving any resources used by the callback. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="asynchronous_events"></a> <a class="anchor" id="description.asynchronous_events"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Asynchronous Events: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Allocation methods in this protocol anticipate the possible occurrence of an "asynchronous event" (AE) during execution. A common example of an AE is a Unix signal, but note that a specific Unix signal <em>may</em> not result in an AE, and an AE is certainly not limited to signals, even on Unix platforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface cannot fully specify either the nature of or the behavior resulting from an AE, but certain restrictions can be (and are) imposed. By default, AEs are either ignored or, if that is not possible, cause an error. At the user's option, however, a concrete implementation can be authorized to return, if possible, with an "interrupted" status (leaving the allocator unaffected) upon the occurrence of an AE. Such authorizations are made explicitly by incorporating into the optional (trailing) integer <code>flags</code> argument to a method call the <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code> value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The purpose of the <code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code> protocol is to isolate the act of requesting a connection from details such as to whom the connection will be to and which side initiated the connection. In this example we will consider both the Server and Client sides of a <code>my_Tick</code> reporting service. Since each side of this service could potentially be a library component, we do not want to embed into either side the details of how connections will be established. It is sufficient that, when a tick needs to be sent or received, a channel is obtained, the tick is transmitted, and the channel is returned to its allocator. Note that this example serves to illustrate the use of the <code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code> and does not represent production-quality software. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Tick {
      <span class="keywordtype">char</span>   d_name[5];
      <span class="keywordtype">double</span> d_bestBid;
      <span class="keywordtype">double</span> d_bestOffer;

    <span class="keyword">public</span>:
      my_Tick() { }
      my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker);
      my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker, <span class="keywordtype">double</span> bestBid, <span class="keywordtype">double</span> bestOffer);
      ~my_Tick() { assert(d_bestBid &gt; 0); };

      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> versionSelector) { <span class="keywordflow">return</span> 1; }

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write this value to the specified output &#39;stream&#39; using the</span>
          <span class="comment">// specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.</span>
          <span class="comment">// If &#39;stream&#39; is initially invalid, this operation has no effect.</span>
          <span class="comment">// If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but</span>
          <span class="comment">// otherwise unmodified.  Note that &#39;version&#39; is not written to</span>
          <span class="comment">// &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more</span>
          <span class="comment">// information on BDEX streaming of value-semantic types and</span>
          <span class="comment">// containers.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>

      <span class="keywordtype">void</span> <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(bsl::ostream&amp; stream) <span class="keyword">const</span>;
  };

  my_Tick::my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker)
  : d_bestBid(0)
  , d_bestOffer(0)
  {
     snprintf(d_name, <span class="keyword">sizeof</span> d_name, <span class="stringliteral">&quot;%s&quot;</span>, ticker);
  }

  my_Tick::my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker, <span class="keywordtype">double</span> bestBid, <span class="keywordtype">double</span> bestOffer)
  : d_bestBid(bestBid)
  , d_bestOffer(bestOffer)
  {
      snprintf(d_name, <span class="keyword">sizeof</span> d_name, <span class="stringliteral">&quot;%s&quot;</span>, ticker);
  }

  <span class="keywordtype">void</span> <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">my_Tick::print</a>(bsl::ostream&amp; stream)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      stream &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; d_name &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d_bestBid &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d_bestOffer
             &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;
  }

  <span class="keyword">inline</span>
  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> my_Tick&amp; tick)
  {
      tick.print(stream);
      <span class="keywordflow">return</span> stream;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">my_Tick::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putString(d_name);
          stream.putFloat64(d_bestBid);
          stream.putFloat64(d_bestOffer);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">my_Tick::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> temp1;
          stream.getString(temp1);
          <span class="keywordtype">int</span> maxLen = <span class="keyword">sizeof</span> d_name - 1;  <span class="comment">// the valid name length</span>
          <span class="keywordtype">int</span> len    = temp1.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>();
          <span class="keywordflow">if</span> (len &lt; maxLen) {
              strcpy(d_name, temp1.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>());
          }
          <span class="keywordflow">else</span> {
              strncpy(d_name, temp1.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>(), len);
              d_name[len] = 0;
          }
          stream.getFloat64(d_bestBid);
          stream.getFloat64(d_bestOffer);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 Let's also assume that we have a function that knows how to print platform neutral encodings of type <code>my_Tick</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> myPrintTick(bsl::ostream&amp; stream, <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> len)
      <span class="comment">// Print the value of the specified &#39;buffer&#39; interpreted as a</span>
      <span class="comment">// BDEX byte-stream representation of a &#39;my_Tick&#39; value, to the</span>
      <span class="comment">// specified &#39;stream&#39; or report an error to &#39;stream&#39; if &#39;buffer&#39; is</span>
      <span class="comment">// determined *not* to hold an encoding of a valid &#39;my_Tick&#39; value.</span>
  {
      my_Tick tick;
      <a class="code" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a> input(buffer, len);
      input &gt;&gt; tick;

      stream &lt;&lt; tick;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="server_side"></a> <a class="anchor" id="usage.server_side"></a> <a class="anchor" id="description.usage.server_side"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Server Side: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following class illustrates how we might implement a tick-reporter server using just the <code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code> and <code><a class="el" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a></code> protocols. In this implementation the "allocate" functor (but not the "read" functor) is created in the constructor and cached for repeated use. Note that buffered reads avoid having to supply a buffer, and <em>may</em> improve throughput if connections are preserved (pooled) in the particular <em>concrete</em> channel allocator (supplied at construction): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_TickReporter {
      <span class="comment">// This class implements a server that accepts connections, extracts</span>
      <span class="comment">// from each connection a single &#39;my_Tick&#39; value, and reports that</span>
      <span class="comment">// value to a console stream; both the acceptor and console stream are</span>
      <span class="comment">// supplied at construction.</span>

      <a class="code" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a> *d_acceptor_p;    <span class="comment">// incoming connections</span>
      bsl::ostream&amp;              d_console;       <span class="comment">// where to put tick info</span>

      btlsc::TimedCbChannel::TimedCallback
                                 d_allocFunctor;  <span class="comment">// reused</span>

    <span class="keyword">private</span>:
      <span class="keywordtype">void</span> acceptCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a>     *clientChannel,
                    <span class="keywordtype">int</span>                        status,
                    <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  timeout);
          <span class="comment">// Called when a new client channel has been accepted.</span>
          <span class="comment">// ...</span>

      <span class="keywordtype">void</span> readCb(<span class="keyword">const</span> <span class="keywordtype">char</span>            *buffer,
                  <span class="keywordtype">int</span>                    status,
                  <span class="keywordtype">int</span>                    asyncStatus,
                  <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *clientChannel);
          <span class="comment">// Called when a &#39;my_Tick&#39; value has been read from the channel.</span>
          <span class="comment">// ...</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_TickReporter(<span class="keyword">const</span> my_TickReporter&amp;);
      my_TickReporter&amp; operator=(<span class="keyword">const</span> my_TickReporter&amp;);

    <span class="keyword">public</span>:
      my_TickReporter(bsl::ostream&amp;              console,
                      <a class="code" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a> *acceptor);
          <span class="comment">// Create a non-blocking tick-reporter using the specified</span>
          <span class="comment">// &#39;acceptor&#39; to establish incoming client connections, each</span>
          <span class="comment">// transmitting a single &#39;my_Tick&#39; value; write these values to the</span>
          <span class="comment">// specified &#39;console&#39; stream.  If the &#39;acceptor&#39; is idle for more</span>
          <span class="comment">// than five minutes, print a message to the &#39;console&#39; stream</span>
          <span class="comment">// supplied at construction and continue.  To guard against</span>
          <span class="comment">// malicious clients, a connection that does not produce a tick</span>
          <span class="comment">// value within one minute will be summarily dropped.</span>

      ~my_TickReporter();
          <span class="comment">// Destroy this server object.</span>
  };

<span class="preprocessor">  #define VERSION_SELECTOR 20140601</span>
<span class="preprocessor"></span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> ACCEPT_TIME_LIMIT = 300;               <span class="comment">// 5 minutes</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span>   READ_TIME_LIMIT =  60;               <span class="comment">// 1 minutes</span>

  <span class="keyword">static</span> <span class="keywordtype">int</span> calculateMyTickMessageSize()
      <span class="comment">// Calculate and return the number of bytes in a BDEX byte-stream</span>
      <span class="comment">// encoding of a (dummy) &#39;my_Tick&#39; value (called just once, see below).</span>
  {
      my_Tick dummy;
      <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> bos(VERSION_SELECTOR);
      bos &lt;&lt; dummy;
      <span class="keywordflow">return</span> bos.length();
  }

  <span class="keyword">static</span> <span class="keywordtype">int</span> myTickMessageSize()
      <span class="comment">// Return the number of bytes in a BDEX byte-stream encoding of a</span>
      <span class="comment">// &#39;my_Tick&#39; value without creating a runtime-initialized file-scope</span>
      <span class="comment">// static variable (which is link-order dependent).</span>
  {
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> MESSAGE_SIZE = calculateMyTickMessageSize();
      <span class="keywordflow">return</span> MESSAGE_SIZE;
  }

  <span class="keywordtype">void</span> my_TickReporter::acceptCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a>     *clientChannel,
                                 <span class="keywordtype">int</span>                        status,
                                 <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  timeout))
  {
      <span class="keywordflow">if</span> (clientChannel) {     <span class="comment">// Successfully created a connection.</span>

          <span class="keyword">const</span> <span class="keywordtype">int</span>                numBytes = ::myTickMessageSize();
          <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> now      = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();

          <span class="comment">// Create one-time (buffered) read functor holding &#39;clientChannel&#39;.</span>

          <span class="keyword">using namespace </span>bdlf::PlaceHolders;
          <a class="code" href="classbtlsc_1_1TimedCbChannel.html#a59d8adcfe643e0468504b0b0342dd2f8">btlsc::TimedCbChannel::BufferedReadCallback</a> readFunctor(
              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                       <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_TickReporter::readCb, <span class="keyword">this</span>)
                     , <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, _2, _3
                     , clientChannel));

          <span class="comment">// Install read callback (timeout, but no raw or async interrupt).</span>

          <span class="keywordflow">if</span> (clientChannel-&gt;timedBufferedRead(numBytes,
                                               now + READ_TIME_LIMIT,
                                               readFunctor)) {
              d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable even to register a read operation&quot;</span>
                           <span class="stringliteral">&quot; on this channel.&quot;</span> &lt;&lt; bsl::endl;
              d_acceptor_p-&gt;deallocate(clientChannel);
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == status) {  <span class="comment">// Not possible for this untimed allocator.</span>
          assert(status)       <span class="comment">// Might as well abort.</span>
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &gt; 0) {   <span class="comment">// Interrupted by unspecified event.</span>
          assert(0); <span class="comment">// Impossible, &quot;async interrupts&quot; were not authorized.</span>
      }
      <span class="keywordflow">else</span> {                   <span class="comment">// Allocation operation is unable to succeed.</span>
          assert(status &lt; 0);

          d_console &lt;&lt; <span class="stringliteral">&quot;Error: The channel allocator is not working now.&quot;</span>
                    &lt;&lt; bsl::endl;

          <span class="comment">// Note that attempting to re-register an allocate operation below</span>
          <span class="comment">// will fail only if the channel allocator is permanently disabled.</span>
      }

      <span class="comment">// In all cases, attempt to reinstall the (reusable) accept callback.</span>

      <span class="keywordflow">if</span> (d_acceptor_p-&gt;allocateTimed(d_allocFunctor)) {
          d_console &lt;&lt; <span class="stringliteral">&quot;Error: unable to register accept operation.&quot;</span>
                    &lt;&lt; bsl::endl;
          <span class="comment">// This server is broken.</span>
      }
  }

  <span class="keywordtype">void</span> my_TickReporter::readCb(<span class="keyword">const</span> <span class="keywordtype">char</span>            *buffer,
                               <span class="keywordtype">int</span>                    status,
                               <span class="keywordtype">int</span>                    asyncStatus,
                               <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *clientChannel)
  {
      assert(clientChannel);

      <span class="keyword">const</span> <span class="keywordtype">int</span> msgSize = ::myTickMessageSize();

      <span class="keywordflow">if</span> (msgSize == status) {  <span class="comment">// Encoded-tick value read successfully.</span>
          assert(buffer);

          ::myPrintTick(d_console, buffer, msgSize);
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 &lt;= status) {   <span class="comment">// Tick message was interrupted.</span>

          assert(buffer); <span class="comment">// Data in buffer is available for inspection (but</span>
                          <span class="comment">// remains in the channel&#39;s buffer).</span>

          <span class="comment">// Must be a timeout event since neither raw (partial) reads nor</span>
          <span class="comment">// (external) asynchronous interrupts were authorized.</span>

          assert(0 == asyncStatus);   <span class="comment">// must be timeout event!</span>

          d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to read tick value from channel&quot;</span>
                       <span class="stringliteral">&quot; before timing out; read aborted.&quot;</span> &lt;&lt; bsl::endl;
      }
      <span class="keywordflow">else</span> { <span class="comment">// Tick-message read failed.</span>
          assert(0 &gt; status);

          d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to read tick value from channel.&quot;</span>
                    &lt;&lt; bsl::endl;
      }

      d_acceptor_p-&gt;deallocate(clientChannel);
  }

  my_TickReporter::my_TickReporter(bsl::ostream&amp;              console,
                                   <a class="code" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a> *acceptor)
  : d_console(console)
  , d_acceptor_p(acceptor)
  {
      assert(&amp;d_console);
      assert(d_acceptor_p);

      <span class="comment">// Attempt to install the first accept callback.</span>

      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> timeout =
                     <a class="code" href="structbsls_1_1SystemTime.html#ab0ea90384d46487a1dce4487aaa12455">bsls::SystemTime::now</a>(<a class="code" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba4b4f6a6781cc76138225ba163ed717a8">bsls::SystemClockType::e_REALTIME</a>)
                     + ACCEPT_TIME_LIMIT;

      <span class="comment">// load reusable allocate functor</span>

      <span class="keyword">using namespace </span>bdlf::PlaceHolders;
      d_allocFunctor = <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                     <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_TickReporter::acceptCb, <span class="keyword">this</span>)
                   , <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, _2
                   , timeout);

      <span class="keywordflow">if</span> (d_acceptor_p-&gt;allocateTimed(d_allocFunctor)) {
          d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to install accept operation.&quot;</span>
                    &lt;&lt; bsl::endl;
          <span class="comment">// This server is broken.</span>
      }
  }

  my_TickReporter::~my_TickReporter()
  {
      assert(&amp;d_console);
      assert(d_acceptor_p);
  }
</pre></div><br/>
<br/>
 In order to make this <code>my_TickReporter</code> work, we will need to instantiate a concrete (e.g., socket) callback channel allocator that is hooked up to an appropriate event manager. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
  {
      <span class="keyword">enum</span> { DEFAULT_PORT = 5000 };

      <span class="keyword">const</span> <span class="keywordtype">int</span> portNumber = argc &gt; 1 ? atoi(argv[1]) : DEFAULT_PORT;

      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> address(btlso::IPv4Address::ANY, portNumber);
      btlso::InetTimedSocketEventManager manager;  <span class="comment">// concrete manager</span>
      btlso::Tcpipv4StreamSocketFactory sf;        <span class="comment">// concrete factory</span>
      btlsos::TimedCbChannelAcceptor acceptor(address, &amp;sf, &amp;manager);

      <span class="keywordflow">if</span> (acceptor.<a class="code" href="classbtlsc_1_1CbChannelAllocator.html#af1470913f03f57b1a88a3a91c1992b13">isInvalid</a>()) {
           bsl::cout &lt;&lt; <span class="stringliteral">&quot;Error: Unable to create acceptor&quot;</span> &lt;&lt; bsl::endl;
           <span class="keywordflow">return</span> -1;                                               <span class="comment">// RETURN</span>
      }

      my_TickReporter reporter(bsl::cout, &amp;acceptor);

      <span class="keywordflow">while</span> (0 != manager.dispatch()) {
           <span class="comment">// Do nothing.</span>
      }

      <span class="comment">// Done only when there are no more events to process.</span>

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Note that when the server can go out of scope before all events are processed, it is important to implement it using the envelope/letter pattern where a <em>counted</em> <em>handle</em> to the internal letter representation is present in each active callback functor to preserve the server's internal state until all functors operating on it have been invoked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="client_side"></a> <a class="anchor" id="usage.client_side"></a> <a class="anchor" id="description.usage.client_side"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Client Side: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to use this <code>my_Tick</code> reporting service, clients will need to know where such a service resides and how to establish such connections on demand. We will use the <code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code> protocol to abstract those details out of the stable software that generates (or forwards) ticks. For the purposes of this example, let's assume that ticks are generated in some ASCII format and arrive in fixed size chunks (e.g., 80 bytes) from a separate process. Note that of the three callback methods <code>readCb</code>, <code>connectCb</code>, and <code>writeCb</code>, only <code>readCb</code> requires no additional, call-specific user data; hence we can easily create it once at construction, and productively cache it for repeated used. We will choose to reload the others each time (which is admittedly somewhat less efficient). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_TickerplantSimulator {
      <span class="comment">// Accept raw tick values in ASCII sent as fixed-sized packets via a</span>
      <span class="comment">// single &#39;btlsc::TimedCbChannel&#39; and send them asynchronously one by</span>
      <span class="comment">// one to a peer (or similar peers) connected via channels provided via</span>
      <span class="comment">// a &#39;btlsc::CbChannelAllocator&#39;.  Both the output channel allocator</span>
      <span class="comment">// and the input channel are supplied at construction.</span>

      <a class="code" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a>
                            *d_connector_p;       <span class="comment">// outgoing connections</span>
      <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *d_input_p;           <span class="comment">// incoming packets</span>
      bsl::ostream&amp;          d_console;           <span class="comment">// where to write errors</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span>              d_inputSize;         <span class="comment">// input packet size</span>
      <span class="keywordtype">int</span>                    d_parserErrorCount;  <span class="comment">// consecutive errors</span>

      <a class="code" href="classbtlsc_1_1TimedCbChannel.html#a59d8adcfe643e0468504b0b0342dd2f8">btlsc::TimedCbChannel::BufferedReadCallback</a> d_readFunctor;  <span class="comment">// reused</span>

    <span class="keyword">private</span>:
      <span class="keywordtype">void</span> readCb(<span class="keyword">const</span> <span class="keywordtype">char</span>               *buffer,
                  <span class="keywordtype">int</span>                       status,
                  <span class="keywordtype">int</span>                       asyncStatus);
          <span class="comment">// Called when a fixed-size record has been read from the input.</span>
          <span class="comment">// ...</span>

      <span class="keywordtype">void</span> connectCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *serverChannel,
                     <span class="keywordtype">int</span>                    status,
                     <span class="keyword">const</span> my_Tick&amp;         tick);
          <span class="comment">// Called when a new server channel has been established.</span>
          <span class="comment">// ...</span>

      <span class="keywordtype">void</span> writeCb(<span class="keywordtype">int</span>                    status,
                   <span class="keywordtype">int</span>                    asyncStatus,
                   <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *serverChannel,
                   <span class="keywordtype">int</span>                    msgSize);
          <span class="comment">// Called when a write operation to the server channel ends.</span>
          <span class="comment">// ...</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_TickerplantSimulator(<span class="keyword">const</span> my_TickerplantSimulator&amp;);
      my_TickerplantSimulator&amp; operator=(<span class="keyword">const</span> my_TickerplantSimulator&amp;);

    <span class="keyword">public</span>:
      my_TickerplantSimulator(bsl::ostream&amp;              console,
                              <a class="code" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a> *connector,
                              <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a>     *input,
                              <span class="keywordtype">int</span>                        inputSize);
          <span class="comment">// Create a non-blocking ticker-plant simulator using the specified</span>
          <span class="comment">// &#39;input&#39; channel to read ASCII tick records of the specified</span>
          <span class="comment">// &#39;inputSize&#39; and convert each record to a &#39;my_Tick&#39; structure;</span>
          <span class="comment">// each tick value is sent asynchronously to a peer via a distinct</span>
          <span class="comment">// channel obtained from the specified &#39;connector&#39;, reporting any</span>
          <span class="comment">// errors to the specified &#39;console&#39;.  If &#39;connector&#39; fails or is</span>
          <span class="comment">// unable to succeed after 30 seconds, or if transmission itself</span>
          <span class="comment">// exceeds 10 seconds, display a message on &#39;console&#39; and abort the</span>
          <span class="comment">// transmission.  If three successive reads of the input channel</span>
          <span class="comment">// fail to produce a valid ticks, invalidate the channel and shut</span>
          <span class="comment">// down this simulator.  The behavior is undefined unless</span>
          <span class="comment">// &#39;0 &lt; inputSize&#39;.</span>

      ~my_TickerplantSimulator();
          <span class="comment">// Destroy this simulator object.</span>
  };

  <span class="keyword">const</span> <span class="keywordtype">double</span> CONNECT_TIME_LIMIT = 30;  <span class="comment">// 30 seconds</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> WRITE_TIME_LIMIT   = 10;  <span class="comment">// 10 seconds</span>

  <span class="keyword">enum</span> { MAX_PARSER_ERRORS = 3 };

  <span class="keyword">static</span>
  <span class="keywordtype">int</span> parseTick(my_Tick *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> numBytes)
      <span class="comment">// Parse a tick value from the specified input &#39;buffer&#39; of the</span>
      <span class="comment">// specified &#39;numBytes&#39; and load that value into the specified</span>
      <span class="comment">// &#39;result&#39;.  Return 0 on success, and a non-zero value (with no effect</span>
      <span class="comment">// on &#39;result&#39;) otherwise.  The behavior is undefined unless</span>
      <span class="comment">// &#39;0 &lt;= numBytes&#39;.</span>
  {
      <span class="comment">// ...</span>
      <span class="keywordflow">return</span> 0;
  }

  <span class="keywordtype">void</span> my_TickerplantSimulator::readCb(<span class="keyword">const</span> <span class="keywordtype">char</span> *buffer,
                                       <span class="keywordtype">int</span>         status,
                                       <span class="keywordtype">int</span>         asyncStatus)
  {
      assert(status &lt;= d_inputSize);

      <span class="keywordflow">if</span> (d_inputSize == status) {  <span class="comment">// Tick message read successfully.</span>
          my_Tick tick;

          <span class="keywordflow">if</span> (0 == ::parseTick(&amp;tick, buffer, d_inputSize)) {
              d_parserErrorCount = 0;  <span class="comment">// Successfully parsed tick value.</span>

              <span class="comment">// Create a connect functor with this tick value as user data.</span>

              <span class="keyword">using namespace </span>bdlf::PlaceHolders;
              <a class="code" href="classbtlsc_1_1CbChannelAllocator.html#acd87f760d0ab81f21fd9a9db99505a49">btlsc::CbChannelAllocator::TimedCallback</a> functor(
                  <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
            <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_TickerplantSimulator::connectCb, <span class="keyword">this</span>)
          , <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, _2
          , tick));

              <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> now =
                    <a class="code" href="structbsls_1_1SystemTime.html#ab0ea90384d46487a1dce4487aaa12455">bsls::SystemTime::now</a>(<a class="code" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba4b4f6a6781cc76138225ba163ed717a8">bsls::SystemClockType::e_REALTIME</a>);

              <span class="comment">// Initiate a non-blocking timed allocate operation.</span>

              <span class="keywordflow">if</span> (d_connector_p-&gt;allocateTimed(functor)) {
                  bsl::cout &lt;&lt; <span class="stringliteral">&quot;Error: Unable to install accept operation.&quot;</span>
                            &lt;&lt; bsl::endl;

                  <span class="comment">// This simulator is broken; invalidate input channel.</span>

                  d_input_p-&gt;invalidate();
              }
          }
          <span class="keywordflow">else</span> {  <span class="comment">// parsing error</span>
              d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to parse tick data!&quot;</span> &lt;&lt; bsl::endl;

              ++d_parserErrorCount;

              <span class="keywordflow">if</span> (d_parserErrorCount &gt;= MAX_PARSER_ERRORS) {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Reached maximum parser error limit;&quot;</span>
                               <span class="stringliteral">&quot; invalidating input channel.&quot;</span> &lt;&lt; bsl::endl;

                  d_input_p-&gt;invalidate();
              }
              <span class="keywordflow">else</span> {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Continuing with next record.&quot;</span> &lt;&lt; bsl::endl;
              }
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &gt;= 0) {  <span class="comment">// partial (incomplete) read</span>
          assert(0);  <span class="comment">// Impossible, no form of partial read was authorized.</span>
      }
      <span class="keywordflow">else</span> {  <span class="comment">// Hard error.</span>
          assert(status &lt; 0);

          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Error: Read Failed.&quot;</span> &lt;&lt; bsl::endl;
                                                   <span class="comment">// Cannot be re-installed.</span>
      }

      <span class="comment">// Attempt to reinstall buffered read operation (pass/fail).</span>

      <span class="keywordflow">if</span> (d_input_p-&gt;bufferedRead(d_inputSize, d_readFunctor)) {
          d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to reregister (untimed)&quot;</span>
                       <span class="stringliteral">&quot; read operation.&quot;</span> &lt;&lt; bsl::endl;
          <span class="comment">// This simulator is broken.</span>
      }
  }

  <span class="keywordtype">void</span> my_TickerplantSimulator::connectCb(
                                        <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *serverChannel,
                                        <span class="keywordtype">int</span>                    status,
                                        <span class="keyword">const</span> my_Tick&amp;         tick)
  {
      <span class="keywordflow">if</span> (serverChannel) {     <span class="comment">// Successfully created a connection.</span>
          <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> bos(VERSION_SELECTOR);
          bos &lt;&lt; tick;
          <span class="keywordtype">int</span> msgSize = bos.length();

          <span class="comment">// Install write callback and embed both &#39;serverChannel&#39; and the</span>
          <span class="comment">// streamed tick-value&#39;s message size as user data.</span>

          <span class="keyword">using namespace </span>bdlf::PlaceHolders;
          <a class="code" href="classbtlsc_1_1TimedCbChannel.html#aae5dd7f12c6b1d98eab280fd8f64060b">btlsc::TimedCbChannel::WriteCallback</a> functor(
              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
              <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_TickerplantSimulator::writeCb, <span class="keyword">this</span>)
            , <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, _2
            , serverChannel
            , msgSize));

          <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> now =
                    <a class="code" href="structbsls_1_1SystemTime.html#ab0ea90384d46487a1dce4487aaa12455">bsls::SystemTime::now</a>(<a class="code" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba4b4f6a6781cc76138225ba163ed717a8">bsls::SystemClockType::e_REALTIME</a>);

          <span class="comment">// Initiate a timed non-blocking write operation.</span>

          <span class="keywordflow">if</span> (serverChannel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aec7af32d3d17c756292f391f8c5652eb">timedBufferedWrite</a>(bos.data(), msgSize,
                                                now + WRITE_TIME_LIMIT,
                                                functor)) {

              d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable even to register a write&quot;</span>
                           <span class="stringliteral">&quot; operation on this channel.&quot;</span> &lt;&lt; bsl::endl;

              <span class="comment">// Give this invalid output channel back (but do not</span>
              <span class="comment">// invalidate the input channel).</span>

              d_connector_p-&gt;deallocate(serverChannel);
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &gt; 0) {  <span class="comment">// Interrupted due to external event.</span>
          assert(0);  <span class="comment">// Impossible, not authorized.</span>
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == status) {  <span class="comment">// Interrupted due to timeout event.</span>
          d_console &lt;&lt; <span class="stringliteral">&quot;Error: Connector timed out, transition aborted.&quot;</span>
                    &lt;&lt; bsl::endl;
      }
      <span class="keywordflow">else</span> {  <span class="comment">// Connector failed.</span>
          assert(0 &lt; status);

          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Error: Unable to connect to server.&quot;</span> &lt;&lt; bsl::endl;

          <span class="comment">// The server is down; invalidate the input channel, allowing</span>
          <span class="comment">// existing write operations to complete before the simulator</span>
          <span class="comment">// shuts down.</span>

          d_input_p-&gt;invalidate();
      }
  }

  <span class="keywordtype">void</span> my_TickerplantSimulator::writeCb(<span class="keywordtype">int</span>                    status,
                                        <span class="keywordtype">int</span>                    asyncStatus,
                                        <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *serverChannel,
                                        <span class="keywordtype">int</span>                    msgSize)
  {
      assert(serverChannel);
      assert(0 &lt; msgSize);
      assert(status &lt;= msgSize);

      <span class="keywordflow">if</span> (msgSize == status) {
          <span class="comment">// Encoded tick value written successfully.</span>
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 &lt;= status) {   <span class="comment">// Tick message timed out.</span>

          assert(0 == asyncStatus  <span class="comment">// only form of partial-write authorized</span>
              || 0 &gt;  asyncStatus  <span class="comment">// This operations was dequeued due to a</span>
                 &amp;&amp; 0 == status);  <span class="comment">// previous partial write operation.</span>

          <span class="keywordflow">if</span> (0 == asyncStatus) {
              d_console &lt;&lt; <span class="stringliteral">&quot;Write of tick data timed out.&quot;</span> &lt;&lt; bsl::endl;

              <span class="keywordflow">if</span> (status &gt; 0) {
                  <span class="comment">// If we had the data, we could retry, but since it was a</span>
                  <span class="comment">// buffered write, we&#39;ll just invalidate the channel.</span>

                  d_console &lt;&lt; <span class="stringliteral">&quot;Partial tick data written;&quot;</span>
                               <span class="stringliteral">&quot; invalidating channel.&quot;</span> &lt;&lt; bsl::endl;

                  <span class="comment">// If we know its data stream is corrupted, we typically</span>
                  <span class="comment">// invalidate a channel before allocating it.</span>

                  serverChannel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#a4864a8e61648ff1937000b69ee2c721b">invalidate</a>();
              }
              <span class="keywordflow">else</span> {
                  d_console &lt;&lt; <span class="stringliteral">&quot;No data was written; channel is still valid.&quot;</span>
                            &lt;&lt; bsl::endl;
              }
          }
          <span class="keywordflow">else</span> {
              assert(0 &lt; asyncStatus &amp;&amp; 0 == status);

              d_console &lt;&lt; <span class="stringliteral">&quot;This operation was dequeued due to previous&quot;</span>
                           <span class="stringliteral">&quot; partial write (no data was written).&quot;</span>
                        &lt;&lt; bsl::endl;
          }
      }
      <span class="keywordflow">else</span> {  <span class="comment">// Tick message write failed.</span>
          assert(0 &gt; status);

          d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to write tick value to server.&quot;</span>
                    &lt;&lt; bsl::endl;
      }

      <span class="comment">// In all cases, return the server channel to the allocator.</span>

      d_connector_p-&gt;deallocate(serverChannel);
  }

  my_TickerplantSimulator::my_TickerplantSimulator(
                               bsl::ostream&amp;              console,
                               <a class="code" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a> *connector,
                               <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a>     *input,
                               <span class="keywordtype">int</span>                        inputSize)
  : d_connector_p(connector)
  , d_console(console)
  , d_input_p(input)
  , d_inputSize(inputSize)
  , d_parserErrorCount(0)
  {
      assert(&amp;console);
      assert(connector);
      assert(input);
      assert(0 &lt; inputSize);

      <span class="comment">// load reusable buffered read functor</span>
      d_readFunctor = <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(
                                     &amp;my_TickerplantSimulator::readCb, <span class="keyword">this</span>);

      <span class="comment">// Attempt to initiate the first read operation (pass/fail).</span>
      <span class="keywordflow">if</span> (d_input_p-&gt;bufferedRead(d_inputSize, d_readFunctor)) {
          d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to register (untimed) read operation.&quot;</span>
                    &lt;&lt; bsl::endl;
          <span class="comment">// This simulator is broken.</span>
      }
  }

  my_TickerplantSimulator::~my_TickerplantSimulator()
  {
      assert(&amp;d_console);
      assert(d_connector_p);
      assert(0 &lt; d_inputSize);
      assert(0 &lt;= d_parserErrorCount);
      assert(d_parserErrorCount &lt;= MAX_PARSER_ERRORS);
  }
</pre></div><br/>
<br/>
 In order to make this <code>my_TickerplantSimulator</code> work, we will need to instantiate a concrete callback channel allocator (i.e., socket connector) and channel that is hooked up to an appropriate event manager: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
  {
      <span class="comment">// OUTBOUND:</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> DEFAULT_HOST = <span class="stringliteral">&quot;widget&quot;</span>;
      <span class="keyword">enum</span> { DEFAULT_PORT = 5001 };
      <span class="keyword">enum</span> { DEFAULT_SIZE = 80   };

      <span class="keyword">const</span> <span class="keywordtype">char</span> *hostName   = argc &gt; 1 ? argv[1]       : DEFAULT_HOST;
      <span class="keyword">const</span> <span class="keywordtype">int</span>   portNumber = argc &gt; 2 ? atoi(argv[2]) : DEFAULT_PORT;
      <span class="keyword">const</span> <span class="keywordtype">int</span>   inputSize  = argc &gt; 3 ? atoi(argv[3]) : DEFAULT_SIZE;

      <span class="comment">// INBOUND:</span>
      <span class="comment">// This simulator accepts connections on port &#39;DEFAULT_PORT&#39; only.</span>

      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> address;
      <a class="code" href="structbtlso_1_1ResolveUtil.html">btlso::ResolveUtil&lt;btlso::IPv4Address&gt;::resolve</a>(&amp;address,
                                                      hostName,
                                                      portNumber);
      btlso::Tcpipv4StreamSocketFactory sf;
      btlso::InetTimedSocketEventManager manager;
      btlsos::TimedCbChannelConnector connector(address, &amp;sf, &amp;manager);

      my_TickerplantSimulator
                          simulator(bsl::cout, &amp;connector, input, inputSize);

      <span class="keywordflow">while</span> (0 != manager.dispatch()) {
          <span class="comment">// Do nothing.</span>
      }
      <span class="comment">// Done only when there are no more events to process.</span>
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Please remember that these example code snippets are intended to illustrate the use of <code><a class="el" href="classbtlsc_1_1CbChannelAllocator.html">btlsc::CbChannelAllocator</a></code> and do not represent production-quality software. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
