<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bsltf_testvaluesarray Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bsltf_testvaluesarray<br/>
<small>
[<a class="el" href="group__bsltf.html">Package bsltf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a container for values used for testing.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator&lt; VALUE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray&lt; VALUE, CONVERTER &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBloombergLP_1_1bsltf_1_1TestValuesArray__DefaultConverter.html">BloombergLP::bsltf::TestValuesArray_DefaultConverter&lt; VALUE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray__PostIncrementPtr.html">BloombergLP::bsltf::TestValuesArray_PostIncrementPtr&lt; VALUE &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
native_std::input_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gae13db2728b25b0ebcaa3767089a43863">BloombergLP::bsltf::TestValuesArrayIterator::iterator_category</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gaf48b4c071ec89a280532321c2485481b">BloombergLP::bsltf::TestValuesArrayIterator::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga9aeba74a062347ae90d347f9cba4aeb0">BloombergLP::bsltf::TestValuesArrayIterator::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga66730646a1a1575645fca4d07d6860e3">BloombergLP::bsltf::TestValuesArrayIterator::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga19f61404a2251f38760b2952fb027c38">BloombergLP::bsltf::TestValuesArrayIterator::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
TestValuesArrayIterator&lt; VALUE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gaa5086928cae2b06ea9773528d9c4926f">BloombergLP::bsltf::TestValuesArray::iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga529c7d14365ef1014d0fdda2d727916e">BloombergLP::bsltf::TestValuesArrayIterator::TestValuesArrayIterator</a> (const VALUE *object, const VALUE *end, bool *dereferenceable, bool *isValid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gad484fb56b295e0476e4877515d061169">BloombergLP::bsltf::TestValuesArrayIterator::TestValuesArrayIterator</a> (const TestValuesArrayIterator &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TestValuesArrayIterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga486197a7ab39df1c0aa906e4906a5cd9">BloombergLP::bsltf::TestValuesArrayIterator::operator=</a> (const TestValuesArrayIterator &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TestValuesArrayIterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gaed1f1885109f1c9b86a3a8a8f1699058">BloombergLP::bsltf::TestValuesArrayIterator::operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TestValuesArray_PostIncrementPtr<br class="typebreak"/>
&lt; VALUE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gae4dab06f552ca098fa285ef909465e3f">BloombergLP::bsltf::TestValuesArrayIterator::operator++</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga042d88485f3796c4465542b2204436d8">BloombergLP::bsltf::TestValuesArrayIterator::operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga712dc5f13fe713ce44071695836f8a81">BloombergLP::bsltf::TestValuesArrayIterator::operator-&gt;</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga612289a8e315f02bafc0edf5fa071b44">BloombergLP::bsltf::operator==</a> (const TestValuesArrayIterator&lt; VALUE &gt; &amp;lhs, const TestValuesArrayIterator&lt; VALUE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga68a5635a6ca62d46fb6e80a8115db246">BloombergLP::bsltf::operator!=</a> (const TestValuesArrayIterator&lt; VALUE &gt; &amp;lhs, const TestValuesArrayIterator&lt; VALUE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga8c79368372719df150e9634fdf7012a0">BloombergLP::bsltf::TestValuesArray::TestValuesArray</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gabe144a7a5f4f872e56d4b978dc87244e">BloombergLP::bsltf::TestValuesArray::TestValuesArray</a> (const char *spec, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gaeb84197bc3b0dcab476beefb7b7f5ff8">BloombergLP::bsltf::TestValuesArray::~TestValuesArray</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga1faa03a12984e9d501e21c0cfb6d9814">BloombergLP::bsltf::TestValuesArray::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga88f3e6d4df92a4dd1b0efd2f5a8e7637">BloombergLP::bsltf::TestValuesArray::index</a> (size_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gac9b5023916e3601f63c3706bafc87c14">BloombergLP::bsltf::TestValuesArray::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gadf099a5577fb4cf420bd77624af46285">BloombergLP::bsltf::TestValuesArray::resetIterators</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gaee94f19821bf8fc90a48901b9c68e029">BloombergLP::bsltf::TestValuesArray::data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga1855a7574290718ae3a02fc0a274135f">BloombergLP::bsltf::TestValuesArray::operator[]</a> (size_t index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gaad8b190b93769110b277fb995c26ca37">BloombergLP::bsltf::TestValuesArray::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#gae46d89fca517bc1d338cabc04218e725">BloombergLP::bsltf::TestValuesArray_PostIncrementPtr::TestValuesArray_PostIncrementPtr</a> (const VALUE *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga1627626d2f701b5c1d6348a1b3a33554">BloombergLP::bsltf::TestValuesArray_PostIncrementPtr::operator*</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class OTHER_VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga6f08f542463f71c5a72ef132db2278e2">BloombergLP::bsltf::TestValuesArrayIterator::operator==</a> (const TestValuesArrayIterator&lt; OTHER_VALUE &gt; &amp;, const TestValuesArrayIterator&lt; OTHER_VALUE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class OTHER_VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bsltf__testvaluesarray.html#ga8cadd85c0160f053847fa25a1a266a27">BloombergLP::bsltf::TestValuesArrayIterator::operator!=</a> (const TestValuesArrayIterator&lt; OTHER_VALUE &gt; &amp;, const TestValuesArrayIterator&lt; OTHER_VALUE &gt; &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Iterator</a> </li>
<li>
<a href="#3.2">Thread Safety</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Testing a Simple Template Function</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a container for values used for testing. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">bsltf::TestValuesArray</a> </td><td>container for values used for testing.  </td></tr>
<tr>
<td><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">bsltf::TestValuesArrayIterator</a> </td><td>iterators for the container  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bsltf_testfacility </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a class <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">TestValuesArray</a></code> providing a a uniform interface for creating and accessing a sequence of test values of type that has a copy constructor, and may or may not have a default constructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also defines an iterator class <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a></code> providing access to elements in a <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">TestValuesArray</a></code> object. <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a></code> is designed to satisfies the minimal requirement of an input iterator as defined by the C++11 standard [24.2.3]. It uses the <code>BSLS_ASSERT</code> macro to detect undefined behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The sequence described by this container is an input-range, that may be traversed exactly once. Once an iterator increments, any other iterator at the same point in the sequence is invalidated. The <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">TestValuesArray</a></code> object provides a <code>resetIterators</code> method that invalidates all existing iterators, and allows a new traversal of the sequence to start. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="iterator"></a> <a class="anchor" id="description.iterator"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Iterator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The requirements of the input iterators as defined by the C++11 standard may not be as tight as the users of the input iterators expected. Incorrect assumptions about the properties of the input iterator may result in undefined behavior. <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a></code> is designed to detect possible incorrect usages. Specifically, <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a></code> put restriction on when it can be dereferenced or compared. A <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a></code> is considered to be <em>dereferenceable</em> if it satisfies all of the following: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
The iterator refers to a valid element (not <code>end</code>).  </li>
<li>
The iterator has not been dereferenced. (*)  </li>
<li>
The iterator is not a copy of another iterator of which <code>operator++</code> have been invoked. (see [table 107] of the C++11 standard)  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>*note: An input iterator may not be dereferenced more than once is a common requirement of a container method that takes input iterators as arguments. Other standard algorithms may allow the iterator to be dereferenced more than once, in which case, <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a></code> is not suitable to be used to with those algorithms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a></code> is comparable if the iterator is not a copy of another iterator of which <code>operator++</code> have been invoked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is <em>not</em> thread-safe, by any definition of the term, and should not be used in test scenarios concerned with concurrent code. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_testing_a_simple_template_function"></a> <a class="anchor" id="usage.example_1~3A_testing_a_simple_template_function"></a> <a class="anchor" id="description.usage.example_1~3A_testing_a_simple_template_function"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Testing a Simple Template Function: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we have a function that we would like to test. This function take in a range defined by two input iterators and returns the largest value in that range. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the function we would like to test: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE, <span class="keyword">class</span> INPUT_ITERATOR&gt;
  VALUE myMaxValue(INPUT_ITERATOR first, INPUT_ITERATOR last)
      <span class="comment">// Return the largest value referred to by the iterators in the range</span>
      <span class="comment">// beginning at the specified &#39;first&#39; and up to, but not including, the</span>
      <span class="comment">// specified &#39;last&#39;.  The behavior is undefined unless [first, last)</span>
      <span class="comment">// specifies a valid range and &#39;first != last&#39;.</span>
  {
      assert(first != last);

      VALUE largestValue(*first);
      ++first;
      <span class="keywordflow">for</span>(;first != last; ++first) {
          <span class="comment">// Store in temporary variable to avoid dereferencing twice.</span>

          <span class="keyword">const</span> VALUE&amp; temp = *first;
          <span class="keywordflow">if</span> (largestValue &lt; temp) {
              largestValue = temp;
          }
      }
      <span class="keywordflow">return</span> largestValue;
  }
</pre></div><br/>
<br/>
 Next, we implement a test function <code>runTest</code> that allows the function to be tested with different types: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE&gt;
  <span class="keywordtype">void</span> runTest()
  {
</pre></div><br/>
<br/>
 Then, we define a set of test values and expected results: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">struct </span>{
          <span class="keyword">const</span> <span class="keywordtype">char</span> *d_spec;
          <span class="keyword">const</span> <span class="keywordtype">char</span>  d_result;
      } DATA[] = {
          { <span class="stringliteral">&quot;A&quot;</span>,     <span class="charliteral">&#39;A&#39;</span> },
          { <span class="stringliteral">&quot;ABC&quot;</span>,   <span class="charliteral">&#39;C&#39;</span> },
          { <span class="stringliteral">&quot;ADCB&quot;</span>,  <span class="charliteral">&#39;D&#39;</span> },
          { <span class="stringliteral">&quot;EDCBA&quot;</span>, <span class="charliteral">&#39;E&#39;</span> }
      };
      <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_DATA = <span class="keyword">sizeof</span> DATA / <span class="keyword">sizeof</span> *DATA;
</pre></div><br/>
<br/>
 Now, for each set of test values, verify that the function return the expected result. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_DATA; ++i) {
          <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> SPEC = DATA[i].d_spec;
          <span class="keyword">const</span> VALUE       EXP  =
                bsltf::TemplateTestFacility::create&lt;VALUE&gt;(DATA[i].d_result);

          bsltf::TestValuesArray&lt;VALUE&gt; values(SPEC);
          assert(EXP == myMaxValue&lt;VALUE&gt;(values.begin(), values.end()));
      }
  }
</pre></div><br/>
<br/>
 Finally, we invoke the test function to verify our function is implemented correctly. The test function to run without triggering the <code>assert</code> statement: <br/>
<br/>
<div class="fragment"><pre class="fragment">  runTest&lt;char&gt;();
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gae13db2728b25b0ebcaa3767089a43863"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::iterator_category" ref="gae13db2728b25b0ebcaa3767089a43863" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef native_std::input_iterator_tag <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::iterator_category<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf48b4c071ec89a280532321c2485481b"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::value_type" ref="gaf48b4c071ec89a280532321c2485481b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9aeba74a062347ae90d347f9cba4aeb0"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::difference_type" ref="ga9aeba74a062347ae90d347f9cba4aeb0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ptrdiff_t <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga66730646a1a1575645fca4d07d6860e3"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::pointer" ref="ga66730646a1a1575645fca4d07d6860e3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const VALUE* <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga19f61404a2251f38760b2952fb027c38"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::reference" ref="ga19f61404a2251f38760b2952fb027c38" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const VALUE&amp; <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa5086928cae2b06ea9773528d9c4926f"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::iterator" ref="gaa5086928cae2b06ea9773528d9c4926f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TestValuesArrayIterator&lt;VALUE&gt; <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga529c7d14365ef1014d0fdda2d727916e"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::TestValuesArrayIterator" ref="ga529c7d14365ef1014d0fdda2d727916e" args="(const VALUE *object, const VALUE *end, bool *dereferenceable, bool *isValid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::TestValuesArrayIterator </td>
          <td>(</td>
          <td class="paramtype">const VALUE *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE *&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>dereferenceable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>isValid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator referring to the specified <code>object</code> for a container with the specified <code>end</code>, with two arrays of boolean referred to by the specified <code>dereferenceable</code> and <code>isValid</code> to indicate whether this iterator and its subsequent values until <code>end</code> is allowed to be dereferenced and is not yet invalidated respectively. </p>

</div>
</div>
<a class="anchor" id="gad484fb56b295e0476e4877515d061169"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::TestValuesArrayIterator" ref="gad484fb56b295e0476e4877515d061169" args="(const TestValuesArrayIterator &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::TestValuesArrayIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a>&lt; VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga486197a7ab39df1c0aa906e4906a5cd9"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::operator=" ref="ga486197a7ab39df1c0aa906e4906a5cd9" args="(const TestValuesArrayIterator &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TestValuesArrayIterator&amp; <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a>&lt; VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaed1f1885109f1c9b86a3a8a8f1699058"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::operator++" ref="gaed1f1885109f1c9b86a3a8a8f1699058" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TestValuesArrayIterator&amp; <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the next element in the container. Any copies of this iterator are no longer dereferenceable or comparable. The behavior is undefined unless this iterator refers to a valid value in the container. </p>

</div>
</div>
<a class="anchor" id="gae4dab06f552ca098fa285ef909465e3f"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::operator++" ref="gae4dab06f552ca098fa285ef909465e3f" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TestValuesArray_PostIncrementPtr&lt;VALUE&gt; <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the next element in the container, and return an object that can be dereferenced to refer to the same object that this iterator initially points to. Any copies of this iterator are no longer dereferenceable or comparable. The behavior is undefined unless this iterator refers to a valid value in the container. </p>

</div>
</div>
<a class="anchor" id="ga042d88485f3796c4465542b2204436d8"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::operator*" ref="ga042d88485f3796c4465542b2204436d8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE&amp; <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value referred to by this object. This object is no longer dereferenceable after a call to this function. The behavior is undefined unless this iterator is dereferenceable. </p>

</div>
</div>
<a class="anchor" id="ga712dc5f13fe713ce44071695836f8a81"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::operator&#45;&gt;" ref="ga712dc5f13fe713ce44071695836f8a81" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE* <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">BloombergLP::bsltf::TestValuesArrayIterator</a>&lt; VALUE &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the value (of the parameterized <code>VALUE_TYPE</code>) of the element at which this iterator is positioned. The behavior is undefined unless this iterator dereferenceable. </p>

</div>
</div>
<a class="anchor" id="ga612289a8e315f02bafc0edf5fa071b44"></a><!-- doxytag: member="BloombergLP::bsltf::operator==" ref="ga612289a8e315f02bafc0edf5fa071b44" args="(const TestValuesArrayIterator&lt; VALUE &gt; &amp;lhs, const TestValuesArrayIterator&lt; VALUE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bsltf::operator== </td>
          <td>(</td>
          <td class="paramtype">const TestValuesArrayIterator&lt; VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TestValuesArrayIterator&lt; VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this object and <code>rhs</code> refers to the same element, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are comparable. </p>

</div>
</div>
<a class="anchor" id="ga68a5635a6ca62d46fb6e80a8115db246"></a><!-- doxytag: member="BloombergLP::bsltf::operator!=" ref="ga68a5635a6ca62d46fb6e80a8115db246" args="(const TestValuesArrayIterator&lt; VALUE &gt; &amp;lhs, const TestValuesArrayIterator&lt; VALUE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool BloombergLP::bsltf::operator!= </td>
          <td>(</td>
          <td class="paramtype">const TestValuesArrayIterator&lt; VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TestValuesArrayIterator&lt; VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this object and <code>rhs</code> does <em>not</em> refers to the same element, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> are comparable. </p>

</div>
</div>
<a class="anchor" id="ga8c79368372719df150e9634fdf7012a0"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::TestValuesArray" ref="ga8c79368372719df150e9634fdf7012a0" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::TestValuesArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabe144a7a5f4f872e56d4b978dc87244e"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::TestValuesArray" ref="gabe144a7a5f4f872e56d4b978dc87244e" args="(const char *spec, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::TestValuesArray </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">TestValuesArray</a></code> object. Optionally, specify <code>spec</code> to indicate the values this object should contain, where the values are created by invoking the <code><a class="el" href="structbsltf_1_1TemplateTestFacility.html#a25bdbb625d95655860cda3626e35e29a">bsltf::TemplateTestFacility::create</a></code> method on each character of <code>spec</code>. If no <code>spec</code> is supplied, the object will contain 52 distinct values of type <code>VALUE</code>. Optionally, specify <code>basicAllocator</code> to used to supply memory. If no allocator is supplied, a <code>bslma::MallocFree</code> allocator will be used to supply memory. </p>

</div>
</div>
<a class="anchor" id="gaeb84197bc3b0dcab476beefb7b7f5ff8"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::~TestValuesArray" ref="gaeb84197bc3b0dcab476beefb7b7f5ff8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::~TestValuesArray </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object and all contained objects. </p>

</div>
</div>
<a class="anchor" id="ga1faa03a12984e9d501e21c0cfb6d9814"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::begin" ref="ga1faa03a12984e9d501e21c0cfb6d9814" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the first element. </p>

</div>
</div>
<a class="anchor" id="ga88f3e6d4df92a4dd1b0efd2f5a8e7637"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::index" ref="ga88f3e6d4df92a4dd1b0efd2f5a8e7637" args="(size_t value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::index </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the element at the specified <code>index</code>. </p>

</div>
</div>
<a class="anchor" id="gac9b5023916e3601f63c3706bafc87c14"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::end" ref="gac9b5023916e3601f63c3706bafc87c14" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator to the past-the-end element. </p>

</div>
</div>
<a class="anchor" id="gadf099a5577fb4cf420bd77624af46285"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::resetIterators" ref="gadf099a5577fb4cf420bd77624af46285" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::resetIterators </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make all iterators dereferenceable and comparable again. </p>

</div>
</div>
<a class="anchor" id="gaee94f19821bf8fc90a48901b9c68e029"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::data" ref="gaee94f19821bf8fc90a48901b9c68e029" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE* <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the first element in this object. </p>

</div>
</div>
<a class="anchor" id="ga1855a7574290718ae3a02fc0a274135f"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::operator[]" ref="ga1855a7574290718ae3a02fc0a274135f" args="(size_t index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE&amp; <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the element at the specified <code>index</code>. </p>

</div>
</div>
<a class="anchor" id="gaad8b190b93769110b277fb995c26ca37"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray::size" ref="gaad8b190b93769110b277fb995c26ca37" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONVERTER  = TestValuesArray_DefaultConverter&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray.html">BloombergLP::bsltf::TestValuesArray</a>&lt; VALUE, CONVERTER &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return number of elements in this object. </p>

</div>
</div>
<a class="anchor" id="gae46d89fca517bc1d338cabc04218e725"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray_PostIncrementPtr::TestValuesArray_PostIncrementPtr" ref="gae46d89fca517bc1d338cabc04218e725" args="(const VALUE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray__PostIncrementPtr.html">BloombergLP::bsltf::TestValuesArray_PostIncrementPtr</a>&lt; VALUE &gt;::TestValuesArray_PostIncrementPtr </td>
          <td>(</td>
          <td class="paramtype">const VALUE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1627626d2f701b5c1d6348a1b3a33554"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArray_PostIncrementPtr::operator*" ref="ga1627626d2f701b5c1d6348a1b3a33554" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE&amp; <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArray__PostIncrementPtr.html">BloombergLP::bsltf::TestValuesArray_PostIncrementPtr</a>&lt; VALUE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="ga6f08f542463f71c5a72ef132db2278e2"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::operator==" ref="ga6f08f542463f71c5a72ef132db2278e2" args="(const TestValuesArrayIterator&lt; OTHER_VALUE &gt; &amp;, const TestValuesArrayIterator&lt; OTHER_VALUE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a>&lt; OTHER_VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a>&lt; OTHER_VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8cadd85c0160f053847fa25a1a266a27"></a><!-- doxytag: member="BloombergLP::bsltf::TestValuesArrayIterator::operator!=" ref="ga8cadd85c0160f053847fa25a1a266a27" args="(const TestValuesArrayIterator&lt; OTHER_VALUE &gt; &amp;, const TestValuesArrayIterator&lt; OTHER_VALUE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a>&lt; OTHER_VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBloombergLP_1_1bsltf_1_1TestValuesArrayIterator.html">TestValuesArrayIterator</a>&lt; OTHER_VALUE &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:00 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
