<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bsls_spinlock Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_spinlock<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a spin lock.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Maintaining Static Count/Max Values</a> </li>
<li>
<a href="#3.1.2">Example 2: Fine-Grained Locking</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a spin lock. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>SpinLock </td><td>A mutex using "busy waiting" atomic operations.  </td></tr>
<tr>
<td>SpinLockGuard </td><td>Automatic locking-unlocking of SpinLock  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a "busy wait" mutual exclusion lock primitive ("mutex"). A <code>SpinLock</code> is small and statically-initializable, but because it "spins" in a tight loop rather than using system operations to block the thread of execution, it is unsuited for use cases involving high contention or long critical regions. Additionally, this component does not provide any guarantee of fairness when multiple threads are contending for the same lock. Use <code>SpinLockGuard</code> for automatic locking-unlocking in a scope. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_maintaining_static_count~2Fmax_values"></a> <a class="anchor" id="usage.example_1~3A_maintaining_static_count~2Fmax_values"></a> <a class="anchor" id="description.usage.example_1~3A_maintaining_static_count~2Fmax_values"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Maintaining Static Count/Max Values: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we want to determine the maximum number of threads executing a block of code concurrently. Note that such a use case naturally calls for a statically initialized lock and the critical region involves a few integer operations; SpinLock may be suitable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a type to manage the count within a scope: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MaxConcurrencyCounter {
     <span class="comment">// This type manages a count and high-water-mark within a scope.</span>
     <span class="comment">// It decrements the count in its destructor upon leaving the scope.</span>

     <span class="comment">// DATA</span>
     <span class="keywordtype">int</span>            *d_count_p;
     <a class="code" href="structbsls_1_1SpinLock.html" title="A mutex using &amp;quot;busy waiting&amp;quot; atomic operations.">bsls::SpinLock</a> *d_lock_p;

   <span class="keyword">public</span>:
     <span class="comment">// CREATORS</span>
     MaxConcurrencyCounter(<span class="keywordtype">int</span> *count, <span class="keywordtype">int</span> *max, <a class="code" href="structbsls_1_1SpinLock.html" title="A mutex using &amp;quot;busy waiting&amp;quot; atomic operations.">bsls::SpinLock</a> *lock);
         <span class="comment">// Acquire the specified &#39;lock&#39; and increment the specified &#39;count&#39;.</span>
         <span class="comment">// If the resulting value is larger than the specified &#39;max&#39;,</span>
         <span class="comment">// load it into &#39;max&#39;. Release &#39;lock&#39; and create a scoped guard to</span>
         <span class="comment">// decrement &#39;count&#39; on destruction.</span>

     ~MaxConcurrencyCounter();
         <span class="comment">// Acquire the lock specified at construction, decrement the count</span>
         <span class="comment">// variable, and release the lock.</span>
   };

   MaxConcurrencyCounter::MaxConcurrencyCounter(<span class="keywordtype">int</span>            *count,
                                                <span class="keywordtype">int</span>            *max,
                                                <a class="code" href="structbsls_1_1SpinLock.html" title="A mutex using &amp;quot;busy waiting&amp;quot; atomic operations.">bsls::SpinLock</a> *lock)
   : d_count_p(count)
   , d_lock_p(lock) {
      <a class="code" href="classbsls_1_1SpinLockGuard.html" title="Automatic locking-unlocking of SpinLock.">bsls::SpinLockGuard</a> guard(lock);
      <span class="keywordtype">int</span> result = ++(*count);
      <span class="keywordflow">if</span> (result &gt; *max) {
         *max = result;
      }
   }

   MaxConcurrencyCounter::~MaxConcurrencyCounter() {
      <a class="code" href="classbsls_1_1SpinLockGuard.html" title="Automatic locking-unlocking of SpinLock.">bsls::SpinLockGuard</a> guard(d_lock_p);
      --(*d_count_p);
   }
</pre></div><br/>
<br/>
 Next, we declare static variables to track the call count and a SpinLock to guard them. <code>SpinLock</code> may be statically initialized using the <code>BSLS_SPINLOCK_UNLOCKED</code> constant: <br/>
<br/>
<div class="fragment"><pre class="fragment">   {
      <span class="keyword">static</span> <span class="keywordtype">int</span>            threadCount = 0;
      <span class="keyword">static</span> <span class="keywordtype">int</span>            maxThreads = 0;
      <span class="keyword">static</span> <a class="code" href="structbsls_1_1SpinLock.html" title="A mutex using &amp;quot;busy waiting&amp;quot; atomic operations.">bsls::SpinLock</a> threadLock = BSLS_SPINLOCK_UNLOCKED;
</pre></div><br/>
<br/>
 Next, by creating a <code>MaxConcurrencyCounter</code> object, each thread entering the block of code uses the <code>SpinLock</code> to synchronize manipulation of the static count variables: <br/>
<br/>
<div class="fragment"><pre class="fragment">      MaxConcurrencyCounter counter(&amp;threadCount, &amp;maxThreads, &amp;threadLock);
</pre></div><br/>
<br/>
 Finally, closing the block synchronizes on the <code>SpinLock</code> again to decrement the thread count. Any intervening code can run in parallel. <br/>
<br/>
<div class="fragment"><pre class="fragment">   }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_fine-grained_locking"></a> <a class="anchor" id="usage.example_2~3A_fine-grained_locking"></a> <a class="anchor" id="description.usage.example_2~3A_fine-grained_locking"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Fine-Grained Locking: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we have a large array of objects to be manipulated concurrently by multiple threads, but the size of the array itself does not change. (This might be because it represents an inherently fixed number of objects or because changes to the array size are infrequent and controlled by some other synchronization mechanism like a "reader-writer" lock). Thus one thread can manipulate a particular object in the array concurrently with a different thread manipulating another. If the manipulations are short and contention is likely to be low, SpinLock might be suitable due to its small size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In particular, imagine we want a threadsafe "multi-queue". In this case, we would have an array of queues, each with a SpinLock member for fine-grained locking. First, we define the type to be held in the array. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TYPE&gt;
  <span class="keyword">class </span>LightweightThreadsafeQueue {
     <span class="comment">// This type implements a threadsafe queue with a small memory</span>
     <span class="comment">// footprint and low initialization costs. It is designed for</span>
     <span class="comment">// low-contention use only.</span>

     <span class="comment">// TYPES</span>
     <span class="keyword">struct </span>Node {
          TYPE  d_item;
          Node *d_next_p;

          Node(<span class="keyword">const</span> TYPE&amp; item) : d_item(item), d_next_p(0) {}
      };

     <span class="comment">// DATA</span>
     Node           *d_front_p; <span class="comment">// Front of queue, or 0 if empty</span>
     Node           *d_back_p; <span class="comment">// Back of queue, or 0 if empty</span>
     <a class="code" href="structbsls_1_1SpinLock.html" title="A mutex using &amp;quot;busy waiting&amp;quot; atomic operations.">bsls::SpinLock</a>  d_lock;

   <span class="keyword">public</span>:
     <span class="comment">// CREATORS</span>
     LightweightThreadsafeQueue();
       <span class="comment">// Create an empty queue.</span>

     ~LightweightThreadsafeQueue();
       <span class="comment">// Destroy this object.</span>

     <span class="comment">// MANIPULATORS</span>
     <span class="keywordtype">int</span> dequeue(TYPE* value);
        <span class="comment">// Remove the element at the front of the queue and load it into the</span>
        <span class="comment">// specified &#39;value&#39;. Return &#39;0&#39; on success, or a nonzero value if</span>
        <span class="comment">// the queue is empty.</span>

     <span class="keywordtype">void</span> enqueue(<span class="keyword">const</span> TYPE&amp; value);
        <span class="comment">// Add the specified &#39;value&#39; to the back of the queue.</span>
   };
</pre></div><br/>
<br/>
 Next, we implement the creators. Note that a different idiom is used to initialize member variables of <code>SpinLock</code> type than is used for static variables: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TYPE&gt;
  LightweightThreadsafeQueue&lt;TYPE&gt;::LightweightThreadsafeQueue()
  : d_front_p(0)
  , d_back_p(0)
  , d_lock(bsls::SpinLock::s_unlocked)
  {}

  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TYPE&gt;
  LightweightThreadsafeQueue&lt;TYPE&gt;::~LightweightThreadsafeQueue() {
     <span class="keywordflow">for</span> (Node *node = d_front_p; 0 != node; ) {
         Node *next = node-&gt;d_next_p;
         <span class="keyword">delete</span> node;
         node = next;
     }
  }
</pre></div><br/>
<br/>
 Then we implement the manipulator functions using <code>SpinLockGuard</code> to ensure thread safety. Note that we do memory allocation and deallocation outside the scope of the lock, as these may involve system calls that should be avoided in the scope of a SpinLock. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TYPE&gt;
  <span class="keywordtype">int</span> LightweightThreadsafeQueue&lt;TYPE&gt;::dequeue(TYPE* value) {
     Node *front;
     {
        <a class="code" href="classbsls_1_1SpinLockGuard.html" title="Automatic locking-unlocking of SpinLock.">bsls::SpinLockGuard</a> guard(&amp;d_lock);
        front = d_front_p;
        <span class="keywordflow">if</span> (0 == front) {
          <span class="keywordflow">return</span> 1;
        }

        *value = front-&gt;d_item;

        <span class="keywordflow">if</span> (d_back_p == front) {
           d_front_p = d_back_p = 0;
        } <span class="keywordflow">else</span> {
           d_front_p = front-&gt;d_next_p;
        }
     }
     <span class="keyword">delete</span> front;
     <span class="keywordflow">return</span> 0;
  }

  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TYPE&gt;
  <span class="keywordtype">void</span> LightweightThreadsafeQueue&lt;TYPE&gt;::enqueue(<span class="keyword">const</span> TYPE&amp; value) {
     Node *node = <span class="keyword">new</span> Node(value);
     <a class="code" href="classbsls_1_1SpinLockGuard.html" title="Automatic locking-unlocking of SpinLock.">bsls::SpinLockGuard</a> guard(&amp;d_lock);
     <span class="keywordflow">if</span> (0 == d_front_p &amp;&amp; 0 == d_back_p) {
        d_front_p = d_back_p = node;
     } <span class="keywordflow">else</span> {
        d_back_p-&gt;d_next_p = node;
        d_back_p = node;
     }
  }
</pre></div><br/>
<br/>
 To illustrate fine-grained locking with this queue, we create a thread function that will manipulate queues out of a large array at random. Since each element in the array is locked independently, these threads will rarely contend for the same queue and can run largely in parallel. <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_QUEUES = 10000;
 <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_ITERATIONS = 20000;

 <span class="keyword">struct </span>QueueElement {
    <span class="keywordtype">int</span> d_threadId;
    <span class="keywordtype">int</span> d_value;
 };

 <span class="keyword">struct </span>ThreadParam {
    LightweightThreadsafeQueue&lt;QueueElement&gt; *d_queues_p;
    <span class="keywordtype">int</span>                                       d_threadId;
 };

 <span class="keywordtype">void</span> *addToRandomQueues(<span class="keywordtype">void</span> *paramAddr) {
    ThreadParam *param = (ThreadParam*)paramAddr;
    LightweightThreadsafeQueue&lt;QueueElement&gt; *queues = param-&gt;d_queues_p;
    <span class="keywordtype">int</span> threadId = param-&gt;d_threadId;
    <span class="keywordtype">unsigned</span> seed = threadId;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_ITERATIONS; ++i) {
       <span class="keywordtype">int</span> queueIndex = rand_r(&amp;seed) % NUM_QUEUES;
       LightweightThreadsafeQueue&lt;QueueElement&gt; *queue = queues + queueIndex;
       QueueElement value = { threadId, i };
       queue-&gt;enqueue(value);
    }
    <span class="keywordflow">return</span> 0;
 }
</pre></div><br/>
<br/>
 Finally, we create the "multi-queue" and several of these threads to manipulate it. We assume the existence of a createThread() function that starts a new thread of execution with a parameter, and we omit details of "joining" these threads. <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">enum</span> { NUM_THREADS = 3};
 LightweightThreadsafeQueue&lt;QueueElement&gt; multiQueue[NUM_QUEUES];
 ThreadParam threadParams[NUM_THREADS];
 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_THREADS; ++i) {
   threadParams[i].d_queues_p = multiQueue;
   threadParams[i].d_threadId = i + 1;
   createThread(addToRandomQueues, threadParams + i);
 }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:02 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
