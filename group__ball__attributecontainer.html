<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: ball_attributecontainer Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component ball_attributecontainer<br/>
<small>
[<a class="el" href="group__ball.html">Package ball</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for containers holding logging attributes.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html">ball</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: An Implementation of <code>ball::AttributeContainer</code></a> </li>
<li>
<a href="#3.1.2">Example 2: A Generic Implementation of <code>ball::AttributeContainer</code></a> </li>
<li>
<a href="#3.1.3">Example 3. Using a <code>ball::AttributeContainer</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for containers holding logging attributes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a> </td><td>a protocol for a collection of attributes  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ball__attribute.html" title="Provide a representation of (literal) name/value pairs.">Component ball_attribute</a>, ball_attributeset </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a protocol class, <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code>, for containers of <code><a class="el" href="classball_1_1Attribute.html">ball::Attribute</a></code> values. The <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> protocol primarily provides a <code>hasValue()</code> method, allowing clients to determine if a given attribute value is held by the container. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following examples we examine two derived implementations of the <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> protocol. The first implementation is potentially more efficient, holding a specific group of attributes relevant to a particular application. The second implementation is more general, and can hold any valid <code><a class="el" href="classball_1_1Attribute.html">ball::Attribute</a></code> value. In the final example we demonstrate how to call the methods of the <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> protocol. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_an_implementation_of_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="usage.example_1~3A_an_implementation_of_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="description.usage.example_1~3A_an_implementation_of_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: An Implementation of ball::AttributeContainer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following example we develop a <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> implementation specifically intended for a service offline that will perform rule-based logging, governed by the service client's bloomberg "uuid", "luw", and "firm number". We define a class <code>ServiceAttributes</code> that contains three integer <code><a class="el" href="classball_1_1Attribute.html">ball::Attribute</a></code> values having the names "uuid", "luw", and "firmNumber". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that this implementation requires no memory allocation, so it will be more efficient than a more general set-based implementation if the container is frequently created, destroyed, or modified. We will develop a <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> implementation that can hold any <code><a class="el" href="classball_1_1Attribute.html">ball::Attribute</a></code> value in example 2 (and one is provided by the <code>ball</code> package in the <code>ball_defaultattributecontainer</code> component). <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="comment">// serviceattributes.h</span>

  <span class="keyword">class </span>ServiceAttributes : <span class="keyword">public</span> <a class="code" href="ball__category_8h.html#a999861d42e34880988db462fdc96354d">ball</a>::AttributeContainer {
      <span class="comment">// Provide a concrete implementation of the &#39;ball::AttributeContainer&#39;</span>
      <span class="comment">// that holds the &#39;uuid&#39;, &#39;luw&#39;, and &#39;firmNumber&#39; associated with a</span>
      <span class="comment">// request to the example service.  This concrete container</span>
      <span class="comment">// exposes those properties in attributes named &quot;uuid&quot;, &quot;luw&quot;, and</span>
      <span class="comment">// &quot;firmNumber&quot; respectively.</span>
</pre></div><br/>
<br/>
 Note that we use the type <code><a class="el" href="classball_1_1Attribute.html">ball::Attribute</a></code> for our data members for simplicity. It would be a little more efficient to use <code>int</code> data members, but the implementation of <code>hasValue()</code> would be less readable. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a> d_uuid;        <span class="comment">// bloomberg user id</span>
      <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a> d_luw;         <span class="comment">// bloomberg luw</span>
      <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a> d_firmNumber;  <span class="comment">// bloomberg firm number</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC CONSTANTS</span>
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> UUID_ATTRIBUTE_NAME;
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> LUW_ATTRIBUTE_NAME;
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> FIRMNUMBER_ATTRIBUTE_NAME;
          <span class="comment">// The names of the attributes exposed by this attribute container.</span>

      <span class="comment">// CREATORS</span>
      ServiceAttributes(<span class="keywordtype">int</span> uuid, <span class="keywordtype">int</span> luw, <span class="keywordtype">int</span> firmNumber);
          <span class="comment">// Create a service-attributes object with the specified &#39;uuid&#39;,</span>
          <span class="comment">// &#39;luw&#39;, and &#39;firmNumber&#39;.</span>

      <span class="keyword">virtual</span> ~ServiceAttributes();
          <span class="comment">// Destroy this service-attributes object.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">bool</span> hasValue(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; value) <span class="keyword">const</span>;
          <span class="comment">// Return &#39;true&#39; if the attribute having specified &#39;value&#39; exists</span>
          <span class="comment">// in this object, and &#39;false&#39; otherwise.  This implementation will</span>
          <span class="comment">// return &#39;true&#39; if &#39;value.name()&#39; equals &quot;uuid&quot;, &quot;luw&quot;, or &quot;firm&quot;</span>
          <span class="comment">// and &#39;value.value()&#39; is an &#39;int&#39; equal to the corresponding</span>
          <span class="comment">// property value supplied at construction.</span>

      <span class="keyword">virtual</span> bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(bsl::ostream&amp; stream,
                                  <span class="keywordtype">int</span>           level = 0,
                                  <span class="keywordtype">int</span>           spacesPerLevel = 4) <span class="keyword">const</span>;
          <span class="comment">// Format this object to the specified output &#39;stream&#39;.</span>
  };

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  ServiceAttributes::ServiceAttributes(<span class="keywordtype">int</span> uuid, <span class="keywordtype">int</span> luw, <span class="keywordtype">int</span> firmNumber)
  : d_uuid(UUID_ATTRIBUTE_NAME, uuid)
  , d_luw(LUW_ATTRIBUTE_NAME, luw)
  , d_firmNumber(FIRMNUMBER_ATTRIBUTE_NAME, firmNumber)
  {
  }

    <span class="comment">// serviceattributes.cpp</span>

  <span class="comment">// PUBLIC CONSTANTS</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> ServiceAttributes::UUID_ATTRIBUTE_NAME       = <span class="stringliteral">&quot;uuid&quot;</span>;
  <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> ServiceAttributes::LUW_ATTRIBUTE_NAME        = <span class="stringliteral">&quot;luw&quot;</span>;
  <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> ServiceAttributes::FIRMNUMBER_ATTRIBUTE_NAME =
                                                                <span class="stringliteral">&quot;firmNumber&quot;</span>;

  <span class="comment">// CREATORS</span>
  ServiceAttributes::~ServiceAttributes()
  {
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keywordtype">bool</span> ServiceAttributes::hasValue(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; value)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_uuid == value || d_luw == value || d_firmNumber == value;
  }

  bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">ServiceAttributes::print</a>(bsl::ostream&amp; stream,
                                         <span class="keywordtype">int</span>           level,
                                         <span class="keywordtype">int</span>           spacesPerLevel)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;stream, level, spacesPerLevel);
      printer.start();
      printer.printAttribute(<span class="stringliteral">&quot;uuid&quot;</span>, d_uuid);
      printer.printAttribute(<span class="stringliteral">&quot;luw&quot;</span>, d_luw);
      printer.printAttribute(<span class="stringliteral">&quot;firmNumber&quot;</span>, d_firmNumber);
      printer.end();
      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_a_generic_implementation_of_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="usage.example_2~3A_a_generic_implementation_of_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="description.usage.example_2~3A_a_generic_implementation_of_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: A Generic Implementation of ball::AttributeContainer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this second example we define a <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> that can contain any valid <code><a class="el" href="classball_1_1Attribute.html">ball::Attribute</a></code> value (a "generic" <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code>). In practice, an implementation that can contain any attribute values may be less efficient than one specifically created for a particular group of attributes needed by an application (as shown in <a href="group__ball__attributecontainer.html#example_1" class="el">Example 1</a>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the <code>ball</code> package provides a similar <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> implementation in the <code>ball_defaultattributecontainer</code> component. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="comment">// attributeset.h</span>

  <span class="keyword">class </span>AttributeSet : <span class="keyword">public</span> <a class="code" href="ball__category_8h.html#a999861d42e34880988db462fdc96354d">ball</a>::AttributeContainer {
      <span class="comment">// A simple set-based implementation of the &#39;ball::AttributeContainer&#39;</span>
      <span class="comment">// protocol, used for testing.</span>
</pre></div><br/>
<br/>
 To define an stl-set (or hash set) for <code><a class="el" href="classball_1_1Attribute.html">ball::Attribute</a></code> values, we must define a comparison (or hash) operation for attribute values. Here we define a comparison functor that compares attributes by name, then by value-type, and finally by value. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">struct </span>AttributeComparator {
          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; lhs,
                          <span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; rhs) <span class="keyword">const</span>
              <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; attribute is ordered</span>
              <span class="comment">// before the specified &#39;rhs&#39; attribute, and &#39;false&#39; otherwise.</span>
          {
              <span class="keywordtype">int</span> cmp = bsl::strcmp(lhs.name(), rhs.name());
              <span class="keywordflow">if</span> (0 != cmp) {
                  <span class="keywordflow">return</span> cmp &lt; 0;
              }
              <span class="keywordflow">if</span> (lhs.value().typeIndex() != rhs.value().typeIndex()) {
                  <span class="keywordflow">return</span> lhs.value().typeIndex() &lt; rhs.value().typeIndex();
              }
              <span class="keywordflow">switch</span> (lhs.value().typeIndex()) {
                <span class="keywordflow">case</span> 0: <span class="comment">// unset</span>
                  <span class="keywordflow">return</span> <span class="keyword">true</span>;
                <span class="keywordflow">case</span> 14: <span class="comment">// int</span>
                  <span class="keywordflow">return</span> lhs.value().the&lt;<span class="keywordtype">int</span>&gt;() &lt; rhs.value().the&lt;<span class="keywordtype">int</span>&gt;();
                <span class="keywordflow">case</span> 2: <span class="comment">// int64</span>
                  <span class="keywordflow">return</span> lhs.value().the&lt;<a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&gt;() &lt;
                         rhs.value().the&lt;<a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&gt;();
               <span class="keywordflow">case</span> 3: <span class="comment">// string</span>
                  <span class="keywordflow">return</span> lhs.value().the&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;() &lt;
                         rhs.value().the&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;();
              }
              <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(<span class="keyword">false</span>);
              <span class="keywordflow">return</span> <span class="keyword">false</span>;
          }
      };

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1set.html">bsl::set&lt;ball::Attribute, AttributeComparator&gt;</a> d_set;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      AttributeSet(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an attribute set.</span>

      <span class="keyword">virtual</span> ~AttributeSet();
          <span class="comment">// Destroy this attribute set.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> insert(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; value);
          <span class="comment">// Add the specified value to this attribute set.</span>

      <span class="keywordtype">bool</span> <span class="keyword">remove</span>(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; value);
          <span class="comment">// Remove the specified value from this attribute set.  Return</span>
          <span class="comment">// &#39;true&#39; if the attribute was found, and &#39;false&#39; if &#39;value&#39; was</span>
          <span class="comment">// not a member of this set.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">bool</span> hasValue(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; value) <span class="keyword">const</span>;
          <span class="comment">// Return &#39;true&#39; if the attribute having specified &#39;value&#39; exists</span>
          <span class="comment">// in this object, and &#39;false&#39; otherwise.</span>

      <span class="keyword">virtual</span> bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(bsl::ostream&amp; stream,
                                  <span class="keywordtype">int</span>           level = 0,
                                  <span class="keywordtype">int</span>           spacesPerLevel = 4) <span class="keyword">const</span>;
          <span class="comment">// Format this object to the specified output &#39;stream&#39; at the</span>
          <span class="comment">// (absolute value of) the optionally specified indentation &#39;level&#39;</span>
          <span class="comment">// and return a reference to &#39;stream&#39;.</span>
  };
</pre></div><br/>
<br/>
 The <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> methods are simple wrappers around <code><a class="el" href="classbsl_1_1set.html">bsl::set</a></code> methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  AttributeSet::AttributeSet(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_set(AttributeComparator(), basicAllocator)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> AttributeSet::insert(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; value)
  {
      d_set.insert(value);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> AttributeSet::remove(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; value)
  {
      <span class="keywordflow">return</span> d_set.erase(value) &gt; 0;
  }

  <span class="comment">// attributeset.cpp</span>

  <span class="comment">// CREATORS</span>
  AttributeSet::~AttributeSet()
  {
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keywordtype">bool</span> AttributeSet::hasValue(<span class="keyword">const</span> <a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>&amp; value)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_set.find(value) != d_set.end();
  }

  bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">AttributeSet::print</a>(bsl::ostream&amp; stream,
                                    <span class="keywordtype">int</span>           level,
                                    <span class="keywordtype">int</span>           spacesPerLevel)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;stream, level, spacesPerLevel);
      printer.start();

      <a class="code" href="group__bslstl__set.html#ga6b8f1e11518593aa25a17ac44dec29a0">bsl::set&lt;ball::Attribute&gt;::const_iterator</a> it = d_set.begin();
      <span class="keywordflow">for</span> (; it != d_set.<a class="code" href="group__bslstl__set.html#gab180d3123dea011341881e0b40c3d3e5">end</a>(); ++it) {
          printer.printValue(*it);
      }
      printer.end();

      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3._using_a_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="usage.example_3._using_a_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="description.usage.example_3._using_a_ball~3A~3Aattributecontainer"></a> <a class="anchor" id="example_3._using_a_ball"></a> <a class="anchor" id="usage.example_3._using_a_ball"></a> <a class="anchor" id="description.usage.example_3._using_a_ball"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3. Using a ball::AttributeContainer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this final example, we demonstrate how to call the methods of the <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> protocol. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we create an object of a concrete type that implements the <code><a class="el" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a></code> protocol (e.g., <code>ServiceAttributes</code> defined in <a href="group__ball__attributecontainer.html#example_1" class="el">Example 1</a>). Then we obtain a reference to this object. <br/>
<br/>
<div class="fragment"><pre class="fragment">  ServiceAttributes serviceAttributes(3938908, 1, 9001);
  <span class="keyword">const</span> <a class="code" href="classball_1_1AttributeContainer.html">ball::AttributeContainer</a>&amp; attributes = serviceAttributes;
</pre></div><br/>
<br/>
 We use <code>hasValue()</code> to examine the values in the container: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == attributes.<a class="code" href="classball_1_1AttributeContainer.html#a8f3ce299a32164133d1097452d9bd68d">hasValue</a>(<a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>(<span class="stringliteral">&quot;uuid&quot;</span>, 3938908)));
  assert(<span class="keyword">true</span> == attributes.<a class="code" href="classball_1_1AttributeContainer.html#a8f3ce299a32164133d1097452d9bd68d">hasValue</a>(<a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>(<span class="stringliteral">&quot;luw&quot;</span>,  1)));
  assert(<span class="keyword">true</span> == attributes.<a class="code" href="classball_1_1AttributeContainer.html#a8f3ce299a32164133d1097452d9bd68d">hasValue</a>(<a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>(<span class="stringliteral">&quot;firmNumber&quot;</span>, 9001)));

  assert(<span class="keyword">false</span> == attributes.<a class="code" href="classball_1_1AttributeContainer.html#a8f3ce299a32164133d1097452d9bd68d">hasValue</a>(<a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>(<span class="stringliteral">&quot;uuid&quot;</span>, 1391015)));
  assert(<span class="keyword">false</span> == attributes.<a class="code" href="classball_1_1AttributeContainer.html#a8f3ce299a32164133d1097452d9bd68d">hasValue</a>(<a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>(<span class="stringliteral">&quot;luw&quot;</span>,  2)));
  assert(<span class="keyword">false</span> == attributes.<a class="code" href="classball_1_1AttributeContainer.html#a8f3ce299a32164133d1097452d9bd68d">hasValue</a>(<a class="code" href="classball_1_1Attribute.html">ball::Attribute</a>(<span class="stringliteral">&quot;bad name&quot;</span>, 3938908)));
</pre></div><br/>
<br/>
 Finally we can print the attribute values in the container: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::cout &lt;&lt; attributes &lt;&lt; bsl::endl;
</pre></div><br/>
<br/>
 The resulting output should look like: <br/>
<br/>
<div class="fragment"><pre class="fragment"> [ [ uuid = 3938908 ] [ luw = 1 ] [ firmNumber = 9001 ] ]
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:31 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
