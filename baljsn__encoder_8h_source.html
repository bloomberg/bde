<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// baljsn_encoder.h                                                   -*-C++-*-
#ifndef INCLUDED_BALJSN_ENCODER
#define INCLUDED_BALJSN_ENCODER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a JSON encoder for &#39;bdeat&#39; compatible types.
//
//@CLASSES:
// baljsn::Encoder: JSON decoder for &#39;bdeat&#39;-compliant types
//
//@SEE_ALSO: baljsn_decoder, baljsn_printutil
//
//@DESCRIPTION: This component provides a class, &#39;baljsn::Encoder&#39;, for
// encoding value-semantic objects in the JSON format.  In particular, the
// &#39;class&#39; contains a parameterized &#39;encode&#39; function that encodes an object
// into a specified stream.  There are two overloaded versions of this
// function:
//
//: o one that writes to a &#39;bsl::streambuf&#39;
//: o one that writes to an &#39;bsl::ostream&#39;
//
// This component can be used with types that support the &#39;bdeat&#39; framework
// (see the &#39;bdeat&#39; package for details), which is a compile-time interface for
// manipulating struct-like and union-like objects.  In particular, types
// generated by the &#39;bas_codegen.pl&#39; tool, and other dynamic types, can be
// encoded using this &#39;class&#39;.  The &#39;encode&#39; function can be invoked on any
// object that satisfies the requirements of a sequence, choice, or array
// object as defined in the &#39;bdlat_sequencefunctions&#39;, &#39;bdlat_choicefunctions&#39;,
// and &#39;bdlat_arrayfunctions&#39; components.
//
// Although the JSON format is easy to read and write and is very useful for
// debugging, it is relatively expensive to encode and decode and relatively
// bulky to transmit.  It is more efficient to use a binary encoding (such as
// BER) if the encoding format is under your control (see &#39;balber_berencoder&#39;).
//
///Encoding Format for a Simple Type
///---------------------------------
// The following table describes how various Simple types are encoded.
//..
//  Simple Type          JSON Type  Notes
//  -----------          ---------  -----
//  char                 number     The integer value of the character
//  unsigned char        number     The integer value of the character
//  int                  number
//  unsigned int         number
//  bsls::Types::Int64   number
//  bsls::Types::Uint64  number
//  float                number
//  double               number
//  char *               string
//  bsl::string          string
//  bdlt::Date            string     ISO 8601 format
//  bdlt::DateTz          string     ISO 8601 format
//  bdlt::Time            string     ISO 8601 format
//  bdlt::TimeTz          string     ISO 8601 format
//  bdlt::DatetimeTz      string     ISO 8601 format
//  bdlt::DatetimeTz      string     ISO 8601 format
//..
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Encoding a &#39;bas_codegen.pl&#39;-Generated Object into JSON
///-----------------------------------------------------------------
// Consider that we want to exchange an employee&#39;s information between two
// processes.  To allow this information exchange we will define the XML schema
// representation for that class, use &#39;bas_codegen.pl&#39; to create the &#39;Employee&#39;
// &#39;class&#39; for storing that information, populate an &#39;Employee&#39; object, and
// encode that object using the baljsn encoder.
//
// First, we will define the XML schema inside a file called &#39;employee.xsd&#39;:
//..
//  &lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;
//  &lt;xs:schema xmlns:xs=&#39;http://www.w3.org/2001/XMLSchema&#39;
//             xmlns:test=&#39;http://bloomberg.com/schemas/test&#39;
//             targetNamespace=&#39;http://bloomberg.com/schemas/test&#39;
//             elementFormDefault=&#39;unqualified&#39;&gt;
//
//      &lt;xs:complexType name=&#39;Address&#39;&gt;
//          &lt;xs:sequence&gt;
//              &lt;xs:element name=&#39;street&#39; type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;city&#39;   type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;state&#39;  type=&#39;xs:string&#39;/&gt;
//          &lt;/xs:sequence&gt;
//      &lt;/xs:complexType&gt;
//
//      &lt;xs:complexType name=&#39;Employee&#39;&gt;
//          &lt;xs:sequence&gt;
//              &lt;xs:element name=&#39;name&#39;        type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;homeAddress&#39; type=&#39;test:Address&#39;/&gt;
//              &lt;xs:element name=&#39;age&#39;         type=&#39;xs:int&#39;/&gt;
//          &lt;/xs:sequence&gt;
//      &lt;/xs:complexType&gt;
//
//      &lt;xs:element name=&#39;Employee&#39; type=&#39;test:Employee&#39;/&gt;
//
//  &lt;/xs:schema&gt;
//..
// Then, we will use the &#39;bas_codegen.pl&#39; tool, to generate the C++ classes for
// this schema.  The following command will generate the header and
// implementation files for the all the classes in the &#39;test_messages&#39;
// components in the current directory:
//..
//  $ bas_codegen.pl -m msg -p test xsdfile.xsd
//..
// Next, we will populate a &#39;test::Employee&#39; object:
//..
//  test::Employee employee;
//  employee.name()                 = &quot;Bob&quot;;
//  employee.homeAddress().street() = &quot;Lexington Ave&quot;;
//  employee.homeAddress().city()   = &quot;New York City&quot;;
//  employee.homeAddress().state()  = &quot;New York&quot;;
//  employee.age()                  = 21;
//..
// Then, we will create a &#39;baljsn::Encoder&#39; object:
//..
//  baljsn::Encoder encoder;
//..
// Now, we will output this object in the JSON format by invoking the &#39;encode&#39;
// method of the encoder.  We will also create a &#39;baljsn::EncoderOptions&#39;
// object that allows us to specify that the encoding should be done in a
// pretty format, and what the initial indent level and spaces per level should
// be.  We will then pass that object to the &#39;encode&#39; method:
//..
//  bsl::ostringstream os;
//
//  baljsn::EncoderOptions options;
//  options.setEncodingStyle(baljsn::EncoderOptions::e_PRETTY);
//  options.setInitialIndentLevel(1);
//  options.setSpacesPerLevel(4);
//
//  const int rc = encoder.encode(os, employee, options);
//  assert(!rc);
//  assert(os);
//..
// Finally, we will verify that the output is as expected:
//..
//  const char EXP_OUTPUT[] = &quot;    {\n&quot;
//                            &quot;        \&quot;name\&quot; : \&quot;Bob\&quot;,\n&quot;
//                            &quot;        \&quot;homeAddress\&quot; : {\n&quot;
//                            &quot;            \&quot;street\&quot; : \&quot;Lexington Ave\&quot;,\n&quot;
//                            &quot;            \&quot;city\&quot; : \&quot;New York City\&quot;,\n&quot;
//                            &quot;            \&quot;state\&quot; : \&quot;New York\&quot;\n&quot;
//                            &quot;        },\n&quot;
//                            &quot;        \&quot;age\&quot; : 21\n&quot;
//                            &quot;    }\n&quot;;
//
//  assert(EXP_OUTPUT == os.str());
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALJSN_ENCODEROPTIONS
#include &lt;baljsn_encoderoptions.h&gt;
#endif

#ifndef INCLUDED_BALJSN_PRINTUTIL
#include &lt;baljsn_printutil.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ATTRIBUTEINFO
#include &lt;bdlat_attributeinfo.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CHOICEFUNCTIONS
#include &lt;bdlat_choicefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CUSTOMIZEDTYPEFUNCTIONS
#include &lt;bdlat_customizedtypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CUSTOMIZEDTYPEFUNCTIONS
#include &lt;bdlat_customizedtypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ENUMFUNCTIONS
#include &lt;bdlat_enumfunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_FORMATTINGMODE
#include &lt;bdlat_formattingmode.h&gt;
#endif

#ifndef INCLUDED_BDLAT_SEQUENCEFUNCTIONS
#include &lt;bdlat_sequencefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPECATEGORY
#include &lt;bdlat_typecategory.h&gt;
#endif

#ifndef INCLUDED_BDLAT_VALUETYPEFUNCTIONS
#include &lt;bdlat_valuetypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLB_PRINT
#include &lt;bdlb_print.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSTREAM
#include &lt;bsl_iostream.h&gt;
#endif

#ifndef INCLUDED_BSL_SSTREAM
#include &lt;bsl_sstream.h&gt;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace baljsn {

                               // =============
                               // class Encoder
                               // =============

class Encoder {
    // This class provides a mechanism for encoding value-semantic objects in
    // the JSON format.  The &#39;encode&#39; methods are function templates that will
    // encode any object that meets the requirements of a sequence, choice, or
    // array object as defined in the &#39;bdlat_sequencefunctions&#39;,
    // &#39;bdlat_choicefunctions&#39;, and &#39;bdlat_choicefunctions&#39; components
    // respectively.  These generic frameworks provide a common compile-time
    // interface for accessing struct-like and union-like objects.  In
    // particular, the types generated by &#39;bas_codegen.pl&#39; provide the
    // necessary interface and can be encoded using this component.

    // FRIENDS
    friend class Encoder_EncodeImpl;

  private:
    // DATA
    bsl::ostringstream d_logStream;  // stream used for logging

  private:
    // PRIVATE MANIPULATORS
    bsl::ostream&amp; logStream();
        // Return the stream for logging.

    // Not implemented:
    Encoder(const Encoder&amp;);

  public:
    // CREATORS
    explicit Encoder(bslma::Allocator *basicAllocator = 0);
        // Create a encoder object.  Optionally specify a &#39;basicAllocator&#39; used
        // to supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    //! ~Encoder() = default;
        // Destroy this object.

    // MANIPULATORS
    template &lt;class TYPE&gt;
    int encode(bsl::streambuf        *streamBuf,
               const TYPE&amp;            value,
               const EncoderOptions&amp;  options);
        // Encode the specified &#39;value&#39;, of (template parameter) &#39;TYPE&#39;, in the
        // JSON format using the specified &#39;options&#39; and output it onto the
        // specified &#39;streamBuf&#39;.  &#39;TYPE&#39; shall be a &#39;bdeat&#39;-compatible
        // sequence, choice, or array type, or a &#39;bdeat&#39;-compatible dynamic
        // type referring to one of those types.  Return 0 on success, and a
        // non-zero value otherwise.

    template &lt;class TYPE&gt;
    int encode(bsl::ostream&amp;         stream,
               const TYPE&amp;           value,
               const EncoderOptions&amp; options);
        // Encode the specified &#39;value&#39;, of (template parameter) &#39;TYPE&#39;, in the
        // JSON format using the specified &#39;options&#39; and output it onto the
        // specified &#39;stream&#39;.  &#39;TYPE&#39; shall be a &#39;bdeat&#39;-compatible sequence,
        // choice, or array type, or a &#39;bdeat&#39;-compatible dynamic type
        // referring to one of those types.  Return 0 on success, and a
        // non-zero value otherwise.

    template &lt;class TYPE&gt;
    int encode(bsl::streambuf *streamBuf, const TYPE&amp; value);
        // Encode the specified &#39;value&#39; of (template parameter) &#39;TYPE&#39; into the
        // specified &#39;streamBuf&#39;.  Return 0 on success, and a non-zero value
        // otherwise.
        //
        // DEPRECATED: Use the &#39;encode&#39; function passed a reference to a
        // non-modifiable &#39;EncoderOptions&#39; object instead.

    template &lt;class TYPE&gt;
    int encode(bsl::ostream&amp; stream, const TYPE&amp; value);
        // Encode the specified &#39;value&#39; of (template parameter) &#39;TYPE&#39; into the
        // specified &#39;stream&#39;.  Return 0 on success, and a non-zero value
        // otherwise.  Note that &#39;stream&#39; will be invalidated if the encoding
        // failed.
        //
        // DEPRECATED: Use the &#39;encode&#39; function passed a reference to a
        // non-modifiable &#39;EncoderOptions&#39; object instead.

    // ACCESSORS
    bsl::string loggedMessages() const;
        // Return a string containing any error, warning, or trace messages
        // that were logged during the last call to the &#39;encode&#39; method.  The
        // log is reset each time &#39;encode&#39; is called.
};

                          // =======================
                          // class Encoder_Formatter
                          // =======================

class Encoder_Formatter {
    // This class implements a formatter providing operations for rending JSON
    // text elements to an output stream (supplied at construction) according
    // to a set of formatting options (also supplied at construction).  This is
    // a component-private class and should not be used outside of this
    // component.

    // DATA
    bsl::ostream&amp; d_outputStream;     // stream for output (held, not owned)
    bool          d_usePrettyStyle;   // encoding style
    int           d_indentLevel;      // initial indent level
    int           d_spacesPerLevel;   // spaces per level
    bool          d_isArrayElement;   // is current element part of an array

  public:
    // CREATORS
    Encoder_Formatter(bsl::ostream&amp; stream, const EncoderOptions&amp; options);
        // Create a &#39;Encoder_Formatter&#39; object using the specified &#39;stream&#39; and
        // &#39;options&#39;.

    //! ~Encoder_Formatter() = default;
        // Destroy this object.

    // MANIPULATORS
    void openObject();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of an object.

    void closeObject();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of an object.

    void openArray(bool formatAsEmptyArrayFlag = false);
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of an array.  Optionally specify
        // &#39;formatAsEmptyArrayFlag&#39; denoting if the array being opened should
        // be formatted as an empty array.  If &#39;formatAsEmptyArrayFlag&#39; is not
        // specified then the array being opened is formatted as an array
        // having elements.  Note that the formatting (and as a consequence the
        // &#39;formatAsEmptyArrayFlag&#39;) is relevant only if this formatter encodes
        // in the pretty style and is ignored otherwise.

    void closeArray(bool formatAsEmptyArrayFlag = false);
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of an array.  Optionally specify
        // &#39;formatAsEmptyArrayFlag&#39; denoting if the array being closed should
        // be formatted as an empty array.  If &#39;formatAsEmptyArrayFlag&#39; is not
        // specified then the array being closed is formatted as an array
        // having elements.  Note that the formatting (and as a consequence the
        // &#39;formatAsEmptyArrayFlag&#39;) is relevant only if this formatter encodes
        // in the pretty style and is ignored otherwise.

    void indent();
        // Print onto the stream supplied at construction the sequence of
        // whitespace characters for the proper indentation of an element given
        // the encoding options supplied at construction.

    int openElement(const bsl::string&amp; name);
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of an element having the specified
        // &#39;name&#39;.  Return 0 on success and a non-zero value otherwise.

    void closeElement();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of an element.

    void openDocument();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of the document.

    void closeDocument();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of the document.

    void setIsArrayElement(bool isArrayElement);
        // Set the flag denoting if the current element refers to an array
        // element to the specified &#39;isArrayElement&#39;.

    // ACCESSORS
    bool isArrayElement() const;
        // Return the value of the flag denoting if the current element refers
        // to an array element.
};

                          // ========================
                          // class Encoder_EncodeImpl
                          // ========================

class Encoder_EncodeImpl {
    // This class implements the parameterized &#39;encode&#39; functions that encode
    // &#39;bdeat&#39; types in the JSON format.  This is a component-private class and
    // should not be used outside of this component.

    // DATA
    Encoder                       *d_encoder_p;         // encoder
                                                               // (held, not
                                                               // owned)

    bsl::ostream                          d_outputStream;      // stream for
                                                               // output

    Encoder_Formatter              d_formatter;         // formatter

    const EncoderOptions          *d_encoderOptions_p;  // encoder
                                                               // options

    // FRIENDS
    friend struct Encoder_DynamicTypeDispatcher;
    friend struct Encoder_ElementVisitor;
    friend class Encoder_SequenceVisitor;

  private:
    // PRIVATE MANIPULATORS
    bsl::ostream&amp; logStream();
        // Return the stream used for logging.

    int encodeImp(const bsl::vector&lt;char&gt;&amp;  value,
                  int,
                  bdlat_TypeCategory::Array);
    template &lt;class TYPE&gt;
    int encodeImp(const TYPE&amp; value, int mode, bdlat_TypeCategory::Array);
    template &lt;class TYPE&gt;
    int encodeImp(const TYPE&amp; value, int mode, bdlat_TypeCategory::Choice);
    template &lt;class TYPE&gt;
    int encodeImp(const TYPE&amp;                        value,
                  int                                mode,
                  bdlat_TypeCategory::CustomizedType);
    template &lt;class TYPE&gt;
    int encodeImp(const TYPE&amp;                     value,
                  int                             mode,
                  bdlat_TypeCategory::DynamicType);
    template &lt;class TYPE&gt;
    int encodeImp(const TYPE&amp;                     value,
                  int                             mode,
                  bdlat_TypeCategory::Enumeration);
    template &lt;class TYPE&gt;
    int encodeImp(const TYPE&amp;                       value,
                  int                               mode,
                  bdlat_TypeCategory::NullableValue);
    template &lt;class TYPE&gt;
    int encodeImp(const TYPE&amp; value, int mode, bdlat_TypeCategory::Sequence);
    template &lt;class TYPE&gt;
    int encodeImp(const TYPE&amp; value, int, bdlat_TypeCategory::Simple);
        // Encode the specified &#39;value&#39;, of a (template parameter) &#39;TYPE&#39;
        // corresponding to the specified &#39;bdeat&#39; category, into JSON onto the
        // &#39;streambuf&#39; supplied at construction, using the specified formatting
        // &#39;mode&#39;.  Return 0 on success and a non-zero value otherwise.  The
        // behavior is undefined unless &#39;value&#39; corresponds to the specified
        // &#39;bdeat&#39; category and &#39;mode&#39; is a valid formatting mode as specified
        // in &#39;bdlat_FormattingMode&#39;.

  public:
    // CREATORS
    Encoder_EncodeImpl(Encoder               *encoder,
                       bsl::streambuf        *streambuf,
                       const EncoderOptions&amp;  options);
        // Create a &#39;Encoder_EncodeImpl&#39; object using the specified &#39;encoder&#39;
        // and &#39;options&#39; and writing the encoded output to the specified
        // &#39;streamBuf&#39;.

    //! ~Encoder_EncodeImpl() = default;
        // Destroy this object.

    // MANIPULATORS
    void openDocument();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of the document.

    template &lt;class TYPE&gt;
    int encode(const TYPE&amp; value, int mode);
        // Encode the specified &#39;value&#39; in the JSON format using the specified
        // formatting &#39;mode&#39;.  Return 0 on success and a non-zero value
        // otherwise.

    void closeDocument();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of the document.

    // ACCESSORS
    const EncoderOptions *encoderOptions() const;
        // Return a reference to the non-modifiable encoder options currently
        // being used by this encoder.
};

                       // =============================
                       // struct Encoder_ElementVisitor
                       // =============================

struct Encoder_ElementVisitor {
    // This class encodes elements in an array or a choice in the JSON format.
    // This is a component-private class and should not be used outside of this
    // component.  Note that the operators provided in this &#39;class&#39; match the
    // function signatures required of visitors encoding elements of compatible
    // types.

    // DATA
    Encoder_EncodeImpl *d_encoder_p; // encoder (held, not owned)
    int                        d_mode;      // formatting mode

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // MANIPULATORS
    template &lt;class TYPE&gt;
    int operator()(const TYPE&amp; value);
        // Encode the specified &#39;value&#39; in the JSON format.  Return 0 on
        // success and a non-zero value otherwise.

    template &lt;class TYPE, class INFO&gt;
    int operator()(const TYPE&amp; value, const INFO&amp; info);
        // Encode the specified &#39;value&#39; using the specified &#39;info&#39; in the JSON
        // format.  Return 0 on success and a non-zero value otherwise.
};

                       // =============================
                       // class Encoder_SequenceVisitor
                       // =============================

class Encoder_SequenceVisitor {
    // This functor class encodes element in a sequence.  It should be passed
    // as an argument to the &#39;bdlat_SequenceFunctions::accessAttributes&#39;
    // function.  Note that the operators provided in this &#39;class&#39; match the
    // function signatures required of visitors encoding elements of &#39;bdeat&#39;
    // sequence types.

    // DATA
    Encoder_EncodeImpl *d_encoder_p;        // encoder (held, not owned)
    bool                       d_isFirstElement;   // flag indicating if an
                                                   // current element is the
                                                   // first

    // PRIVATE CLASS METHODS
    template &lt;class TYPE&gt;
    bool skipNullableAttribute(const TYPE&amp;, bslmf::MetaInt&lt;0&gt;);
    template &lt;class TYPE&gt;
    bool skipNullableAttribute(const TYPE&amp; value, bslmf::MetaInt&lt;1&gt;);
    template &lt;class TYPE&gt;
    bool skipNullableAttribute(const TYPE&amp; value);
        // Return &#39;true&#39; if the specified &#39;value&#39; represents a
        // &#39;bdlat_NullableValue&#39; type and should be skipped, and &#39;false&#39;
        // otherwise.

    template &lt;class TYPE&gt;
    static bool isEmptyArray(const TYPE&amp;, bslmf::MetaInt&lt;0&gt;);
    template &lt;class TYPE&gt;
    static bool isEmptyArray(const TYPE&amp; value, bslmf::MetaInt&lt;1&gt;);
    template &lt;class TYPE&gt;
    static bool isEmptyArray(const TYPE&amp; value);
        // Return &#39;true&#39; if the specified &#39;value&#39; represents an empty array and
        // &#39;false&#39; otherwise.

  public:
    // CREATORS
    explicit Encoder_SequenceVisitor(Encoder_EncodeImpl *encoder);
        // Create a &#39;Encoder_SequenceVisitor&#39; object using the specified
        // &#39;encoder&#39;.

    // MANIPULATORS
    template &lt;class TYPE, class INFO&gt;
    int operator()(const TYPE&amp; value, const INFO &amp;info);
        // Encode the specified &#39;value&#39; using the specified &#39;info&#39; in the JSON
        // format.  Return 0 on success and a non-zero value otherwise.
};

                    // ====================================
                    // struct Encoder_DynamicTypeDispatcher
                    // ====================================

struct Encoder_DynamicTypeDispatcher {
    // This class is used to dispatch the appropriate &#39;encodeImp&#39; method for a
    // &#39;bdeat&#39; Dynamic type.  This is a component-private class and should not
    // be used outside of this component.  Note that the operators provided in
    // this &#39;class&#39; match the function signatures required of visitors encoding
    // elements of &#39;bdeat&#39; dynamic types.

    // DATA
    Encoder_EncodeImpl *d_encoder_p; // encoder (held, not owned)
    int                        d_mode;      // formatting mode

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // MANIPULATORS
    template &lt;class TYPE&gt;
    int operator()(const TYPE&amp;, bslmf::Nil);
    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int operator()(const TYPE&amp; value, ANY_CATEGORY category);
        // Encode the specified &#39;value&#39; of the specified &#39;bdeat&#39; &#39;category&#39; in
        // the JSON format.  Return 0 on success and a non-zero value
        // otherwise.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                               // -------------
                               // class Encoder
                               // -------------

// PRIVATE MANIPULATORS
inline
bsl::ostream&amp; Encoder::logStream()
{
    return d_logStream;
}

// CREATORS
inline
Encoder::Encoder(bslma::Allocator *basicAllocator)
: d_logStream(basicAllocator)
{
}

// MANIPULATORS
template &lt;class TYPE&gt;
inline
int Encoder::encode(bsl::streambuf *streamBuf, const TYPE&amp; value)
{
    const EncoderOptions options;
    return encode(streamBuf, value, options);
}

template &lt;class TYPE&gt;
inline
int Encoder::encode(bsl::ostream&amp; stream, const TYPE&amp; value)
{
    const EncoderOptions options;
    return encode(stream, value, options);
}

template &lt;class TYPE&gt;
int Encoder::encode(bsl::streambuf        *streamBuf,
                    const TYPE&amp;            value,
                    const EncoderOptions&amp;  options)
{
    BSLS_ASSERT(streamBuf);

    bdlat_TypeCategory::Value category =
                                    bdlat_TypeCategoryFunctions::select(value);
    if (bdlat_TypeCategory::e_SEQUENCE_CATEGORY != category
     &amp;&amp; bdlat_TypeCategory::e_CHOICE_CATEGORY != category
     &amp;&amp; bdlat_TypeCategory::e_ARRAY_CATEGORY != category) {
        logStream()
                  &lt;&lt; &quot;Encoded object must be a Sequence, Choice or Array type.&quot;
                  &lt;&lt; bsl::endl;
        return -1;                                                    // RETURN
    }

    d_logStream.clear();
    d_logStream.str(&quot;&quot;);

    Encoder_EncodeImpl encoderImpl(this, streamBuf, options);

    encoderImpl.openDocument();

    const int rc = encoderImpl.encode(value, 0);

    if (!rc) {
        encoderImpl.closeDocument();
    }

    streamBuf-&gt;pubsync();

    return rc;
}

template &lt;class TYPE&gt;
int Encoder::encode(bsl::ostream&amp;         stream,
                    const TYPE&amp;           value,
                    const EncoderOptions&amp; options)
{
    if (!stream.good()) {
        logStream() &lt;&lt; &quot;Invalid stream.&quot; &lt;&lt; bsl::endl;
        return -1;                                                    // RETURN
    }

    const int rc = this-&gt;encode(stream.rdbuf(), value, options);
    if (rc) {
        stream.setstate(bsl::ios_base::failbit);
        return rc;                                                    // RETURN
    }

    return 0;
}

// ACCESSORS
inline
bsl::string Encoder::loggedMessages() const
{
    return d_logStream.str();
}

                        // ------------------------------
                        // class Encoder_Formatter
                        // ------------------------------
// MANIPULATORS
inline
void Encoder_Formatter::setIsArrayElement(bool isArrayElement)
{
    d_isArrayElement = isArrayElement;
}

// ACCESSORS
inline
bool Encoder_Formatter::isArrayElement() const
{
    return d_isArrayElement;
}

                          // ------------------------
                          // class Encoder_EncodeImpl
                          // ------------------------

// PRIVATE MANIPULATORS
inline
bsl::ostream&amp; Encoder_EncodeImpl::logStream()
{
    return d_encoder_p-&gt;logStream();
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeImpl::encodeImp(const TYPE&amp;                        value,
                                  int                                mode,
                                  bdlat_TypeCategory::CustomizedType)
{
    return encode(bdlat_CustomizedTypeFunctions::convertToBaseType(value),
                  mode);
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeImpl::encodeImp(const TYPE&amp;                     value,
                                  int                             mode,
                                  bdlat_TypeCategory::DynamicType)
{
    Encoder_DynamicTypeDispatcher proxy = { this, mode };
    return bdlat_TypeCategoryUtil::accessByCategory(value, proxy);
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeImpl::encodeImp(const TYPE&amp;                     value,
                                  int                             mode,
                                  bdlat_TypeCategory::Enumeration)
{
    bsl::string valueString;
    bdlat_EnumFunctions::toString(&amp;valueString, value);
    return encode(valueString, mode);
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeImpl::encodeImp(const TYPE&amp;                value,
                                  int,
                                  bdlat_TypeCategory::Simple)
{
    d_formatter.indent();
    return PrintUtil::printValue(d_outputStream, value);
}

template &lt;class TYPE&gt;
int Encoder_EncodeImpl::encodeImp(const TYPE&amp;                  value,
                                  int                          mode,
                                  bdlat_TypeCategory::Sequence)
{
    if (!(bdlat_FormattingMode::e_UNTAGGED &amp; mode)) {
        d_formatter.openObject();
    }

    Encoder_SequenceVisitor visitor(this);

    const bool isArrayElement = d_formatter.isArrayElement();

    d_formatter.setIsArrayElement(false);

    const int rc = bdlat_SequenceFunctions::accessAttributes(value, visitor);
    if (rc) {
        return rc;                                                    // RETURN
    }

    d_formatter.setIsArrayElement(isArrayElement);

    if (!(bdlat_FormattingMode::e_UNTAGGED &amp; mode)) {
        d_formatter.closeObject();
    }

    return 0;
}

template &lt;class TYPE&gt;
int Encoder_EncodeImpl::encodeImp(const TYPE&amp;                value,
                                  int                        mode,
                                  bdlat_TypeCategory::Choice)
{
    if (bdlat_ChoiceFunctions::k_UNDEFINED_SELECTION_ID !=
                                   bdlat_ChoiceFunctions::selectionId(value)) {
        if (!(bdlat_FormattingMode::e_UNTAGGED &amp; mode)) {
            d_formatter.openObject();
        }

        Encoder_ElementVisitor visitor = { this, mode };

        const bool isArrayElement = d_formatter.isArrayElement();

        d_formatter.setIsArrayElement(false);

        const int rc = bdlat_ChoiceFunctions::accessSelection(value, visitor);
        if (rc) {
            return rc;                                                // RETURN
        }

        d_formatter.setIsArrayElement(isArrayElement);

        if (!(bdlat_FormattingMode::e_UNTAGGED &amp; mode)) {
            d_formatter.closeObject();
        }
    }
    else {
        logStream() &lt;&lt; &quot;Undefined selection for Choice object&quot; &lt;&lt; bsl::endl;
        return -1;                                                    // RETURN
    }
    return 0;
}

template &lt;class TYPE&gt;
int Encoder_EncodeImpl::encodeImp(const TYPE&amp;               value,
                                  int                       mode,
                                  bdlat_TypeCategory::Array)
{
    const int size = static_cast&lt;int&gt;(bdlat_ArrayFunctions::size(value));
    if (0 &lt; size) {
        d_formatter.openArray();

        Encoder_ElementVisitor visitor = { this, mode };

        d_formatter.setIsArrayElement(true);

        int rc = bdlat_ArrayFunctions::accessElement(value, visitor, 0);
        if (rc) {
            return rc;                                                // RETURN
        }

        for (int i = 1; i &lt; size; ++i) {
            d_formatter.closeElement();
            rc = bdlat_ArrayFunctions::accessElement(value, visitor, i);
            if (rc) {
                return rc;                                            // RETURN
            }
        }

        d_formatter.setIsArrayElement(false);

        d_formatter.closeArray();
    }
    else if (d_encoderOptions_p-&gt;encodeEmptyArrays()) {
        d_formatter.openArray(true);
        d_formatter.closeArray(true);
    }

    return 0;
}

template &lt;class TYPE&gt;
int Encoder_EncodeImpl::encodeImp(const TYPE&amp;                       value,
                                  int                               mode,
                                  bdlat_TypeCategory::NullableValue)
{
    if (bdlat_NullableValueFunctions::isNull(value)) {
        d_formatter.indent();
        d_outputStream &lt;&lt; &quot;null&quot;;
        return 0;                                                     // RETURN
    }

    Encoder_ElementVisitor visitor = { this, mode };
    return bdlat_NullableValueFunctions::accessValue(value, visitor);
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeImpl::encode(const TYPE&amp; value, int mode)
{
    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;
    return encodeImp(value, mode, TypeCategory());
}

// CREATORS
inline
Encoder_EncodeImpl::Encoder_EncodeImpl(Encoder               *encoder,
                                       bsl::streambuf        *streambuf,
                                       const EncoderOptions&amp;  options)
: d_encoder_p(encoder)
, d_outputStream(streambuf)
, d_formatter(d_outputStream, options)
, d_encoderOptions_p(&amp;options)
{
}

inline
void Encoder_EncodeImpl::openDocument()
{
    d_formatter.openDocument();
}

inline
void Encoder_EncodeImpl::closeDocument()
{
    d_formatter.closeDocument();
}

// ACCESSORS
inline
const EncoderOptions *Encoder_EncodeImpl::encoderOptions() const
{
    return d_encoderOptions_p;
}

                       // ------------------------------
                       // struct Encoder_SequenceVisitor
                       // ------------------------------

// PRIVATE CLASS METHODS
template &lt;class TYPE&gt;
inline
bool Encoder_SequenceVisitor::skipNullableAttribute(const TYPE&amp;,
                                                    bslmf::MetaInt&lt;0&gt;)
{
    return false;
}

template &lt;class TYPE&gt;
bool Encoder_SequenceVisitor::skipNullableAttribute(const TYPE&amp;       value,
                                                    bslmf::MetaInt&lt;1&gt;)
{
    if (bdlat_TypeCategory::e_NULLABLE_VALUE_CATEGORY ==
                                  bdlat_TypeCategoryFunctions::select(value)) {
        return bdlat_NullableValueFunctions::isNull(value)
            &amp;&amp; !d_encoder_p-&gt;encoderOptions()-&gt;encodeNullElements();  // RETURN
    }
    return false;
}

template &lt;class TYPE&gt;
inline
bool Encoder_SequenceVisitor::skipNullableAttribute(const TYPE&amp; value)
{
    return skipNullableAttribute(value,
                                 bslmf::MetaInt&lt;bdlat_NullableValueFunctions
                                            ::IsNullableValue&lt;TYPE&gt;::VALUE&gt;());
}

template &lt;class TYPE&gt;
bool Encoder_SequenceVisitor::isEmptyArray(const TYPE&amp;, bslmf::MetaInt&lt;0&gt;)
{
    return false;
}

template &lt;class TYPE&gt;
inline
bool Encoder_SequenceVisitor::isEmptyArray(const TYPE&amp;       value,
                                           bslmf::MetaInt&lt;1&gt;)
{
    if (bdlat_TypeCategory::e_ARRAY_CATEGORY ==
                                  bdlat_TypeCategoryFunctions::select(value)) {
        return 0 == bdlat_ArrayFunctions::size(value);                // RETURN
    }
    return false;
}

template &lt;class TYPE&gt;
inline
bool Encoder_SequenceVisitor::isEmptyArray(const TYPE&amp; value)
{
    return isEmptyArray(
                 value,
                 bslmf::MetaInt&lt;bdlat_ArrayFunctions::IsArray&lt;TYPE&gt;::VALUE&gt;());
}

// CREATORS
inline
Encoder_SequenceVisitor::Encoder_SequenceVisitor(
                                            Encoder_EncodeImpl *encoder)
: d_encoder_p(encoder)
, d_isFirstElement(true)
{
}

// MANIPULATORS
template &lt;class TYPE, class INFO&gt;
int Encoder_SequenceVisitor::operator()(const TYPE&amp; value, const INFO&amp; info)
{
    // Determine if &#39;value&#39; is null or an empty array where we don&#39;t want to
    // encode empty arrays.  In either of those cases, do not encode &#39;value&#39;.

    if (skipNullableAttribute(value)
     || (isEmptyArray(value)
      &amp;&amp; !d_encoder_p-&gt;encoderOptions()-&gt;encodeEmptyArrays())) {
        return 0;                                                     // RETURN
    }

    if (!d_isFirstElement) {
        d_encoder_p-&gt;d_formatter.closeElement();
    }

    d_isFirstElement = false;

    Encoder_ElementVisitor visitor = { d_encoder_p,
                                              info.formattingMode() };
    return visitor(value, info);
}

                       // -----------------------------
                       // struct Encoder_ElementVisitor
                       // -----------------------------

template &lt;class TYPE&gt;
inline
int Encoder_ElementVisitor::operator()(const TYPE &amp;value)
{
    return d_encoder_p-&gt;encode(value, d_mode);
}

template &lt;class TYPE, class INFO&gt;
int Encoder_ElementVisitor::operator()(const TYPE&amp; value, const INFO&amp; info)
{
    // Skip encoding of anonymous elements

    const int mode = info.formattingMode();
    if (!(bdlat_FormattingMode::e_UNTAGGED &amp; mode)) {

        const int rc = d_encoder_p-&gt;d_formatter.openElement(info.name());
        if (rc) {
            d_encoder_p-&gt;logStream() &lt;&lt; &quot;Unable to encode element named: &#39;&quot;
                                     &lt;&lt; info.name() &lt;&lt; &quot;&#39;.&quot; &lt;&lt; bsl::endl;
            return rc;                                                // RETURN
        }
    }

    const int rc = d_encoder_p-&gt;encode(value, mode);
    if (rc) {
        d_encoder_p-&gt;logStream() &lt;&lt; &quot;Unable to encode value of element &quot;
                                 &lt;&lt; &quot;named: &#39;&quot; &lt;&lt; info.name() &lt;&lt; &quot;&#39;.&quot;
                                 &lt;&lt; bsl::endl;
        return rc;                                                    // RETURN
    }
    return 0;
}

                    // ------------------------------------
                    // struct Encoder_DynamicTypeDispatcher
                    // ------------------------------------

// MANIPULATORS
template &lt;class TYPE&gt;
inline
int Encoder_DynamicTypeDispatcher::operator()(const TYPE&amp;, bslmf::Nil)
{
    BSLS_ASSERT_OPT(!&quot;Should be unreachable!&quot;);

    return -1;
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
inline
int Encoder_DynamicTypeDispatcher::operator()(const TYPE&amp;  value,
                                              ANY_CATEGORY category)
{
    return d_encoder_p-&gt;encodeImp(value, d_mode, category);
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
