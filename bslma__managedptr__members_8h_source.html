<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_managedptr_members.h                                         -*-C++-*-
#ifndef INCLUDED_BSLMA_MANAGEDPTR_MEMBERS
#define INCLUDED_BSLMA_MANAGEDPTR_MEMBERS

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide the internal state of a managed pointer class.
//
//@CLASSES:
//  bslma::ManagedPtr_Members: internal state of a bcema_ManagedPtr object
//
//@SEE_ALSO: bslma_managedptr
//
//@DESCRIPTION: This component provides a class to store and manage the
// internal state of a &#39;bslma::ManagedPtr&#39; object.  It enforces the rules for
// correct transfer of ownership from one &#39;bslma::ManagedPtr_Members&#39; object to
// another.  A &#39;bslma::ManagedPtr&#39; object has two attributes:
//..
//  pointer   The address of the object being managed
//  deleter   The address of a function used to destroy the object at &#39;pointer&#39;
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTRDELETER
#include &lt;bslma_managedptrdeleter.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {
namespace bslma {

                     // ========================
                     // class ManagedPtr_Members
                     // ========================

class ManagedPtr_Members {
    // This class provides a type-agnostic container for managed pointer data
    // members.  This type exists so that a &#39;ManagedPtr_Ref&#39; can point to the
    // representation of a &#39;ManagedPtr&#39; even if the &#39;_Ref&#39; object is
    // instantiated on a different type than the managed pointer type (e.g., in
    // the case of conversions or aliasing).  &#39;ManagerPtr_Members&#39; also
    // &quot;erases&quot; the types of each member, so that the same object code can be
    // shared between multiple instantiations of the &#39;ManagedPtr&#39; class
    // template, reducing template bloat.  Note that objects of this type may
    // have an &quot;unset&quot; state, where the &#39;d_obj_p&#39; pointer has a null value, and
    // the &#39;d_deleter&#39; member does not have a specified value.  If &#39;d_obj_p&#39;
    // has a null pointer value, then this object must be in an unset state.

  private:
    // PRIVATE TYPES
    typedef ManagedPtrDeleter::Deleter DeleterFunc;

    void              *d_obj_p;     // pointer to the managed object.
                                    // A pointer to void is used so that this
                                    // single (non-template) class may be used
                                    // for any instantiation of the
                                    // &#39;bslma::ManagedPtrRef&#39; template.

    ManagedPtrDeleter  d_deleter;   // deleter-related information

  private:
    // NOT IMPLEMENTED
    ManagedPtr_Members&amp; operator=(const ManagedPtr_Members&amp;);

  public:
    // CREATORS
    ManagedPtr_Members();
        // Create a &#39;ManagedPtr_Members&#39; object in an unset state.  Sets
        // &#39;pointer&#39; to 0.

    explicit ManagedPtr_Members(ManagedPtr_Members&amp; other);
        // Create a &#39;ManagedPtr_Members&#39; object having the same &#39;pointer&#39; as
        // the specified &#39;other&#39; object, and, if &#39;pointer&#39; is not 0, the same
        // deleter as &#39;other&#39;, and then put &#39;other&#39; into an unset state.

    ManagedPtr_Members(void *object, void *factory, DeleterFunc deleter);
        // Create a &#39;ManagedPtr_Members&#39; object having the specified &#39;object&#39;,
        // &#39;factory&#39;, and &#39;deleter&#39; unless &#39;0 == object&#39;, in which case create
        // a &#39;ManagedPtr_Members&#39; object that does not manage a pointer.

    ManagedPtr_Members(void        *object,
                       void        *factory,
                       DeleterFunc  deleter,
                       void        *alias);
        // Create a &#39;ManagedPtr_Members&#39; object having the specified &#39;object&#39;,
        // &#39;factory&#39;, and &#39;deleter&#39;, but aliasing the specified &#39;alias&#39;, unless
        // &#39;0 == object&#39;; if &#39;0 == object&#39; create a &#39;ManagedPtr_Members&#39; object
        // that does not manage any pointer.  Note that this constructor is
        // important for managed pointers pointing to one of multiple base
        // classes of a class using multiple inheritance.

    //! ~ManagedPtr_Members() = default;
        // Destroy this &#39;ManagedPtr_Members&#39; object.  Note that this trivial
        // destructor&#39;s definition is compiler generated.

    // MANIPULATORS
    void clear();
        // Reset this object to an unset state.  Note that any previously
        // managed object will not be destroyed.

    void move(ManagedPtr_Members *other);
        // Re-initialize this object, having the same &#39;pointer&#39; as the
        // specified &#39;other&#39; object, and, if &#39;pointer&#39; is not 0, the same
        // deleter as &#39;other&#39;, and then put &#39;other&#39; into an unset set.  Note
        // that any previously managed object will not be destroyed.

    void moveAssign(ManagedPtr_Members *other);
        // Destroy the currently managed object (if any) unless the specified
        // &#39;other&#39; refers to this object, then re-initialize this object,
        // having the same &#39;pointer&#39; as the &#39;other&#39; object, and, if &#39;pointer&#39;
        // is not 0, the same deleter as &#39;other&#39;, and then put &#39;other&#39; into an
        // unset state.

    void set(void *object, void *factory, DeleterFunc deleter);
        // Re-initialize this object with the specified &#39;object&#39; pointer value,
        // and the specified &#39;deleter&#39; function, using the specified &#39;factory&#39;.
        // Note that any previously managed object will not be destroyed.

    void setAliasPtr(void *ptr);
        // Set &#39;pointer&#39; to have the specified &#39;ptr&#39; value.  If &#39;0 == ptr&#39; then
        // this object will have an unset state.

    void swap(ManagedPtr_Members&amp; other);
        // Efficiently exchange the state of this object with the state of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.  Note that if either object is in an
        // unset state, then the only guarantee about the unset state that may
        // be exchanged is that the &#39;pointer&#39; value shall be null.

    // ACCESSORS
    const ManagedPtrDeleter&amp; deleter() const;
        // Return the &#39;ManagedPtrDeleter&#39; object that should be used to destroy
        // the currently managed object, if any.  Behavior is undefined unless
        // &#39;pointer&#39; is not null.

    void *pointer() const;
        // Return the address of the currently managed object.

    void runDeleter() const;
        // Destroy the currently managed object (if any).  Note that calling
        // this method twice without assigning a new pointer to manage will
        // produce undefined behavior, unless this object&#39;s current deleter
        // specifically supports such usage.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                    // ------------------------
                    // class ManagedPtr_Members
                    // ------------------------

// CREATORS
inline
ManagedPtr_Members::ManagedPtr_Members()
: d_obj_p(0)
{
}

inline
ManagedPtr_Members::ManagedPtr_Members(void        *object,
                                       void        *factory,
                                       DeleterFunc  deleter)
: d_obj_p(object)
, d_deleter(object, factory, deleter)
{
    BSLS_ASSERT_SAFE(0 != deleter || 0 == object);
}

inline
ManagedPtr_Members::ManagedPtr_Members(void        *object,
                                       void        *factory,
                                       DeleterFunc  deleter,
                                       void        *alias)
: d_obj_p(alias)
, d_deleter(object, factory, deleter)
{
    BSLS_ASSERT_SAFE(0 != deleter || 0 == object);
}

inline
ManagedPtr_Members::ManagedPtr_Members(ManagedPtr_Members&amp; other)
: d_obj_p(other.d_obj_p)
{
    if (d_obj_p) {
        d_deleter = other.d_deleter;
    }
    other.clear();
}

// MANIPULATORS
inline
void ManagedPtr_Members::clear()
{
    d_obj_p = 0;
}

inline
void ManagedPtr_Members::move(ManagedPtr_Members *other)
{
    // if &#39;other.d_obj_p&#39; is null then &#39;other.d_deleter&#39; may not be initialized
    // but &#39;set&#39; takes care of that concern.  deleter passed by ref, so no read
    // of uninitialized memory occurs

    BSLS_ASSERT_SAFE(other);
    BSLS_ASSERT_SAFE(this != other);

    d_obj_p = other-&gt;d_obj_p;
    if (other-&gt;d_obj_p) {
        d_deleter = other-&gt;d_deleter;
    }

    other-&gt;clear();
}

inline
void ManagedPtr_Members::moveAssign(ManagedPtr_Members *other)
{
    BSLS_ASSERT_SAFE(other);

    // Must protect against self-assignment due to destructive move.

    if (this != other) {
        runDeleter();
        move(other);
    }
}

inline
void ManagedPtr_Members::set(void        *object,
                             void        *factory,
                             DeleterFunc  deleter)
{
    // Note that &#39;factory&#39; may be null if &#39;deleter&#39; supports it, so cannot be
    // asserted here.

    BSLS_ASSERT_SAFE(0 != deleter || 0 == object);

    d_obj_p = object;
    if (object) {
        d_deleter.set(object, factory, deleter);
    }
}

inline
void ManagedPtr_Members::setAliasPtr(void *ptr)
{
    BSLS_ASSERT_SAFE(!ptr == !d_obj_p); // both are null, or neither is null

    d_obj_p = ptr;
}

// ACCESSORS
inline
const ManagedPtrDeleter&amp; ManagedPtr_Members::deleter() const
{
    BSLS_ASSERT_SAFE(d_obj_p);

    return d_deleter;
}

inline
void *ManagedPtr_Members::pointer() const
{
    return d_obj_p;
}

inline
void ManagedPtr_Members::runDeleter() const
{
    if (d_obj_p) {
        d_deleter.deleteManagedObject();
    }
}

}  // close package namespace

// TYPE TRAITS
namespace bslmf {

template &lt;&gt;
struct IsBitwiseMoveable&lt;bslma::ManagedPtr_Members&gt; : bsl::true_type {};

}  // close namespace bslmf
}  // close enterprise namespace

#endif


// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
