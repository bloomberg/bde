<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bsls_alignedbuffer.h                                               -*-C++-*-
#ifndef INCLUDED_BSLS_ALIGNEDBUFFER
#define INCLUDED_BSLS_ALIGNEDBUFFER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide raw buffers with user-specified size and alignment.
//
//@CLASSES:
//  bsls::AlignedBuffer: Uninitialized buffer of specified size and alignment
//
//@SEE_ALSO: bsls_objectbuffer, bsls_alignmenttotype
//
//@DESCRIPTION: This component provides a templated buffer type with a
// user-specified compile-time size and user-specified alignment.  The user
// instantiates &#39;bsls::AlignedBuffer&#39; with specific size and alignment
// requirements, and then uses that memory as needed.  If an alignment is not
// specified at template instantiation, then the buffer object is maximally
// aligned.
//
// Typically, &#39;bsls::AlignedBuffer&#39; is used in situations where it is desirable
// to allocate a block of properly-aligned raw memory from somewhere other than
// the heap, e.g., on the stack or within an aggregate object, including within
// a union.  It is a convenient way to create a small heap from which one or
// more objects are allocated at run-time.
//
///Single-Object Buffers
///---------------------
// Although, for a given type &#39;T&#39;,
// &#39;bsls::AlignedBuffer&lt;sizeof(T), bsls::AlignmentFromType&lt;T&gt;::VALUE&gt;&#39; will
// produce a buffer properly sized and aligned to hold a &#39;T&#39; object, it is
// simpler and clearer to use &#39;bsls::ObjectBuffer&lt;T&gt;&#39; for this purpose.  See
// the &#39;bsls_objectbuffer&#39; component for more information.
//
///Stack Alignment
///---------------
// On platforms with 32-bit words, there is usually no efficiency gain by using
// more than 4-byte alignment.  Yet some compilers use 8-byte alignment for
// &#39;long long&#39; or &#39;double&#39;, presumably so that the code will run faster on a
// future 64-bit CPU.  The program loader, however, has no reason to presume
// more than 4-byte alignment when allocating the program stack.  This can
// result in stack objects appearing to be misaligned relative to the
// alignments computed by this component.  This is not a bug in either this
// component nor in the compiler, but it is somewhat surprising.  We have seen
// this behavior on the MS VC++ 7 platform.  See also the &quot;Surprises and
// Anomalies&quot; section in &#39;bsls_alignmentfromtype.h&#39;.
//
///Usage
///-----
// The &#39;allocateFromBuffer&#39; function below uses an aligned buffer as a small
// heap from which objects can be allocated.  We choose &#39;int&#39; alignment (4-byte
// alignment) for our buffer because the objects we are allocating are composed
// of &#39;char&#39;, &#39;short&#39;, and &#39;int&#39; values only.  If no alignment were specified,
// the buffer would be maximally aligned, which could be wasteful on some
// platforms.
//..
//  const int MY_ALIGNMENT = bsls::AlignmentFromType&lt;int&gt;::VALUE;
//  bsls::AlignedBuffer&lt;1000, MY_ALIGNMENT&gt; my_AllocBuffer;
//  const char* my_AllocEnd = my_AllocBuffer.buffer() + 1000;
//  char *my_AllocPtr = my_AllocBuffer.buffer();
//      // Invariant: my_AllocPtr is always aligned on a multiple of 4 bytes
//
//  static void *allocateFromBuffer(int size)
//  {
//      if (size &gt; my_AllocEnd - my_AllocPtr)
//          return 0;       // Out of buffer space
//
//      void *result = my_AllocPtr;
//      my_AllocPtr += size;
//      if (size % MY_ALIGNMENT) {
//          // re-establish invariant by re-aligning my_AllocPtr
//          my_AllocPtr += MY_ALIGNMENT - size % MY_ALIGNMENT;
//      }
//
//      assert(0 == size_t(my_AllocPtr) % MY_ALIGNMENT);     // Test invariant
//
//      return result;
//  }
//..
// Below, we use our allocation function to allocate arrays of &#39;char&#39;, &#39;short&#39;,
// and user-defined &#39;Object&#39; types from the static buffer.  Note that our
// &#39;Object&#39; structure is composed of members that have alignment requirements
// less than or equal to &#39;int&#39;s alignment requirements.
//..
//  struct Object {
//      char  d_c;
//      short d_s;
//      int   d_i;
//  };
//
//  int main()
//  {
//      // Allocate three &#39;char&#39;s from the buffer.
//      char *charPtr   = (char *)   allocateFromBuffer(3 * sizeof(char));
//      assert(0 == size_t(charPtr) % MY_ALIGNMENT);
//
//      // Allocate three &#39;short&#39;s from the buffer.
//      short *shortPtr = (short *)  allocateFromBuffer(3 * sizeof(short));
//      assert(0 == size_t(shortPtr) % MY_ALIGNMENT);
//
//      // Allocate three &#39;Object&#39;s from the buffer
//      Object *objPtr = (Object *)  allocateFromBuffer(3 * sizeof(Object));
//      assert(0 == size_t(objPtr) % MY_ALIGNMENT);
//
//      if (!charPtr || !shortPtr || !objPtr) {
//          fprintf(stderr, &quot;Global buffer is not large enough.\n&quot;);
//          return -1;
//      }
//
//      // ...
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLS_ALIGNMENTTOTYPE
#include &lt;bsls_alignmenttotype.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTUTIL
#include &lt;bsls_alignmentutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

namespace BloombergLP {

namespace bsls {

                        // ========================
                        // union AlignedBuffer_Data
                        // ========================

template &lt;int SIZE, int ALIGNMENT&gt;
union AlignedBuffer_Data {
    // This *private* implementation type provides a public &#39;char&#39; array
    // data member &#39;d_buffer&#39; whose length is the specifed (template parameter)
    // &#39;SIZE&#39; and which is aligned according to the specified (template
    // parameter) &#39;ALIGNMENT&#39;.

  public:
    typedef typename AlignmentToType&lt;ALIGNMENT&gt;::Type AlignmentType;
        // Define an alias for alignment type to work around a Sun CC 5.5 bug
        // that gives a warning if the type is directly accessed in the union.
        // Note that to allow the union to access this typedef it must be
        // declared with public access.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_ALIGNAS)
    // The C++11 implementation uses the &#39;alignas&#39; keyword to ensure the
    // alignment of &#39;d_buffer&#39;.

    alignas(ALIGNMENT) char d_buffer[SIZE];
#else
    // The C++03 implementation uses a union data member to ensure the
    // alignment of &#39;d_buffer&#39;.

    char          d_buffer[SIZE];
    AlignmentType d_align;
#endif
};

#if defined(BSLS_PLATFORM_CMP_MSVC) &amp;&amp; !defined(BSLS_COMPILERFEATURES_SUPPORT_ALIGNAS)
// We provide template specializations for MSVC using __declspec(align).
// Note that MSVC does not enforce the alignment of (at least) &#39;double&#39;
// variables on the stack.  (internal issue 64140445).

#define BSLS_ALIGNAS(N) __declspec(align(N))
template &lt;int SIZE&gt;
union AlignedBuffer_Data&lt;SIZE, 1&gt; {BSLS_ALIGNAS(1) char d_buffer[SIZE]; };
template &lt;int SIZE&gt;
union AlignedBuffer_Data&lt;SIZE, 2&gt; {BSLS_ALIGNAS(2) char d_buffer[SIZE]; };
template &lt;int SIZE&gt;
union AlignedBuffer_Data&lt;SIZE, 4&gt; {BSLS_ALIGNAS(4) char d_buffer[SIZE]; };
template &lt;int SIZE&gt;
union AlignedBuffer_Data&lt;SIZE, 8&gt; {BSLS_ALIGNAS(8) char d_buffer[SIZE]; };
template &lt;int SIZE&gt;
union AlignedBuffer_Data&lt;SIZE, 16&gt; {BSLS_ALIGNAS(16) char d_buffer[SIZE]; };
#undef BSLS_ALIGNAS
#endif  // defined(BSLS_PLATFORM_CMP_MSVC)

                        // ===================
                        // class AlignedBuffer
                        // ===================

template &lt;int SIZE, int ALIGNMENT = AlignmentUtil::BSLS_MAX_ALIGNMENT&gt;
class AlignedBuffer {
    // An instance of this union is a block of raw memory of specified &#39;SIZE&#39;
    // and &#39;ALIGNMENT&#39;.  A &#39;AlignedBuffer&#39; object does not manage the
    // construction or destruction of any other objects.  &#39;SIZE&#39; is rounded up
    // to the nearest multiple of &#39;ALIGNMENT&#39;.  An instantiation of this union
    // template will not compile unless &#39;ALIGNMENT&#39; is a power of two not
    // larger than &#39;AlignmentUtil::BSLS_MAX_ALIGNMENT&#39;.

    // DATA
    AlignedBuffer_Data&lt;SIZE, ALIGNMENT&gt; d_data;

  public:
    // CREATORS Note that We deliberately omit defining constructors and
    // destructors in order to keep this union &quot;POD-like&quot;.  In particular, a
    // &#39;AlignedBuffer&#39; may be used as a member in another &#39;union&#39;.  Copying a
    // &#39;AlignedBuffer&#39; assignment or copy construction will result in a
    // bit-wise copy and will not invoke any user-defined assignment operators
    // or copy constructors.

    // MANIPULATORS
    char *buffer();
        // Return a the address of the first byte of this object, cast to a
        // &#39;char*&#39; pointer.

    // ACCESSORS
    const char *buffer() const;
        // Return a the address of the first byte of this object, cast to a
        // &#39;const char*&#39; pointer.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

// MANIPULATORS
template &lt;int SIZE, int ALIGNMENT&gt;
inline
char *AlignedBuffer&lt;SIZE, ALIGNMENT&gt;::buffer()
{
    return d_data.d_buffer;
}

// ACCESSORS
template &lt;int SIZE, int ALIGNMENT&gt;
inline
const char *AlignedBuffer&lt;SIZE, ALIGNMENT&gt;::buffer() const
{
    return d_data.d_buffer;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
