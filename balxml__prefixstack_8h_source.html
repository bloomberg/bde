<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balxml_prefixstack.h                                               -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALXML_PREFIXSTACK
#define INCLUDED_BALXML_PREFIXSTACK

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a unique integer ID for each XML namespace.
//
//@CLASSES:
//  balxml::PrefixStack: stack of (namespace prefix, unique integer ID) pairs
//
//@SEE_ALSO: balxml_namespaceregistry
//
//@DESCRIPTION: &#39;balxml::PrefixStack&#39; keeps a collection of pairs - the prefix
// string and the integer associated with each namespace uri.  Registration of
// prefix with namespace works similar to &quot;pushing in stack&quot;, i.e., it hides
// the previous prefix&lt;-&gt;namespaces association.  Deregistration of prefix
// removes the current association and opens the previous association of given
// prefix.
//
// It is safe to read or modify multiple instances of &#39;balxml::PrefixStack&#39;
// simultaneously, each from a separate thread.  It is safe to read a single
// instance of &#39;balxml::PrefixStack&#39; from multiple threads, provided no thread
// is modifying it at the same time.  It is not safe to read or modify an
// instance of &#39;balxml::PrefixStack&#39; from one thread while any other thread is
// modifying the same instance.  Modifying a &#39;balxml::PrefixStack&#39; objects may
// modify the referenced &#39;balxml::NamespaceRegistry&#39; object.  It is not safe to
// read or modify an instance of &#39;balxml::PrefixStack&#39; from one thread while
// any other thread is (directly or indirectly) modifying the referenced
// &#39;balxml::NamespaceRegistry&#39;.
//
///Usage
///-----
// In this example we demonstrate registering several prefixes with different
// namespaces and printing them along with their ID.
//..
//    balxml::NamespaceRegistry namespaces;
//    balxml::PrefixStack    prefixes(namespaces, allocator);
//
//    bsl::string uri1 = &quot;http://www.google.com&quot;;
//    bsl::string uri2 = &quot;http://www.yahoo.com&quot;;
//    bsl::string uri3 = &quot;http://www.hotmail.com&quot;;
//    bsl::string uri4 = &quot;http://www.msn.com&quot;;
//
//    bsl::string prefix1 = &quot;a&quot;;
//    bsl::string prefix2 = &quot;b&quot;;
//    bsl::string prefix3 = &quot;c&quot;;
//
//    int namespaceId1 = prefixes.pushPrefix(prefix1, uri1);
//    int namespaceId2 = prefixes.pushPrefix(prefix2, uri2);
//    int namespaceId3 = prefixes.pushPrefix(prefix3, uri3);
//
//    bsl::cout &lt;&lt; prefix1 &lt;&lt; &quot;:&quot; &lt;&lt; namespaceId1 &lt;&lt; bsl::endl;
//    bsl::cout &lt;&lt; prefix2 &lt;&lt; &quot;:&quot; &lt;&lt; namespaceId2 &lt;&lt; bsl::endl;
//    bsl::cout &lt;&lt; prefix3 &lt;&lt; &quot;:&quot; &lt;&lt; namespaceId3 &lt;&lt; bsl::endl;
//
//    int namespaceId4 = prefixes.pushPrefix(prefix1, uri4);
//
//    bsl::cout &lt;&lt; prefix1 &lt;&lt; &quot;:&quot; &lt;&lt; namespaceId1 &lt;&lt; bsl::endl;
//
//    prefixes.popPrefix(prefix1);
//
//    bsl::cout &lt;&lt; prefix1 &lt;&lt; &quot;:&quot; &lt;&lt; namespaceId1 &lt;&lt; bsl::endl;
//
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_UTILITY
#include &lt;bsl_utility.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {

namespace balxml {class NamespaceRegistry;

                             // =================
                             // class PrefixStack
                             // =================

class PrefixStack {
    // &#39;PrefixStack&#39; allows associating a unique integer (namespace ID) with
    // prefix.

    // PRIVATE TYPES
    typedef bsl::vector&lt; bsl::pair&lt;bsl::string, int&gt; &gt; PrefixVector;

    // DATA
    NamespaceRegistry        *d_namespaceRegistry;

    PrefixVector              d_prefixes;     // vector of pairs of namespace
                                              // prefix and integer id of the
                                              // namespace

    int                       d_numPrefixes;  // number of prefixes

    // NOT IMPLEMENTED
    PrefixStack&amp; operator=(const PrefixStack&amp;);  // = delete

  public:
    // CREATORS
    PrefixStack(NamespaceRegistry *namespaceRegistry,
                bslma::Allocator  *basicAllocator = 0);
        // Create an empty registry.  Optionally specify a &#39;basicAllocator&#39; used
        // to supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    PrefixStack(const PrefixStack&amp;  original,
                bslma::Allocator   *basicAllocator = 0);
        // Create a registry object having the same value as the specified
        // &#39;original&#39; object.  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    ~PrefixStack();
        // Destroy this object.

    // MANIPULATORS
    int pushPrefix(const bslstl::StringRef&amp; prefix,
                   const bslstl::StringRef&amp; namespaceUri);
        // Map the specified &#39;namespaceUri&#39; to the specified &#39;prefix&#39; and
        // return the namespace Id.  New mapping eclipses previous mapping.

    int popPrefixes(int count);
        // Remove the specified last &#39;count&#39; number prefixes.  Return the
        // number of actually removed prefixes.

    void reset();
        // Removes all prefixes from the internal collection.

    void restoreToSize(int size);
        // Restore stack to the specified &#39;size&#39;.  The behavior is undefined if
        // PrefixStack contains fewer prefixes than requested size.

    // ACCESSORS
    int numPrefixes() const;
        // Return the current number of prefixes in the stack.

    NamespaceRegistry *namespaceRegistry() const;
        // Return the pointer of &#39;NamespaceRegistry&#39; associated with this
        // PrefixStack.

    const char *lookupNamespacePrefix(const bslstl::StringRef&amp; prefix) const;
        // Return a copy of the specified &#39;prefix&#39; if &#39;prefix&#39; is registered or
        // an empty string if &#39;prefix&#39; is not registered.

    int lookupNamespaceId(const bslstl::StringRef&amp; prefix) const;
        // Return ID of the namespace registered for the specified &#39;prefix&#39; or
        // -1 if not registered.

    const char *lookupNamespaceUri(const bslstl::StringRef&amp; prefix) const;
        // Return the URI of the namespace registered for the specified
        // &#39;prefix&#39; or empty string if not registered.

    const char *lookupNamespaceUri(int nsId) const;
        // Return the URI of the namespace of the specified &#39;nsId&#39; or empty
        // string if not registered.

    const char *namespacePrefixByIndex(int index) const;
        // Return the namespace prefix at the specified &#39;index&#39; in the prefix
        // stack, where an &#39;index&#39; of 0 is the oldest prefix on the stack.  If
        // &#39;index&#39; is negative, return the prefix at position &#39;numPrefixes() -
        // index&#39;.  Thus, an &#39;index&#39; of -1 will return the most recent prefix
        // on the stack (i.e., the top of the stack).  The behavior is
        // undefined if &#39;index &gt; numPrefixes()&#39; or &#39;index &lt; -numPrefixes()&#39;.

    int namespaceIdByIndex(int index) const;
        // Return the namespace ID at the specified &#39;index&#39; in the prefix
        // stack, where an &#39;index&#39; of 0 is the oldest ID on the stack.  If
        // &#39;index&#39; is negative, return the ID at position &#39;numPrefixes() -
        // index&#39;.  Thus, an &#39;index&#39; of -1 will return the most recent ID on
        // the stack (i.e., the top of the stack).  The behavior is undefined
        // if &#39;index &gt; numPrefixes()&#39; or &#39;index &lt; -numPrefixes()&#39;.

    const char *namespaceUriByIndex(int index) const;
        // Return the namespace URI at the specified &#39;index&#39; in the prefix
        // stack, where an &#39;index&#39; of 0 is the oldest URI on the stack.  If
        // &#39;index&#39; is negative, return the URI at position &#39;numPrefixes() -
        // index&#39;.  Thus, an &#39;index&#39; of -1 will return the most recent URI on
        // the stack (i.e., the top of the stack).  The behavior is undefined
        // if &#39;index &gt; numPrefixes()&#39; or &#39;index &lt; -numPrefixes()&#39;.

    void print(bsl::ostream&amp; stream, bool fullNames = false) const;
        // Print the content of this object to the specified &#39;stream&#39;.  The
        // optionally specified &#39;fullNames&#39; specifies how namespaces should be
        // printed: &#39;true&#39; for the full names and &#39;false&#39; only for IDs.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

// CREATORS
inline
PrefixStack::~PrefixStack()
{
}

// MANIPULATORS
inline
void PrefixStack::reset()
{
    d_numPrefixes = 0;
    d_prefixes.clear();
}

inline
void PrefixStack::restoreToSize(int size)
{
    BSLS_ASSERT_SAFE(size &lt;= d_numPrefixes);
    d_numPrefixes = size;
}

// ACCESSORS
inline
NamespaceRegistry *PrefixStack::namespaceRegistry() const
{
    return d_namespaceRegistry;
}

inline
int PrefixStack::numPrefixes() const
{
    return d_numPrefixes;
}

inline
const char *PrefixStack::namespacePrefixByIndex(int index) const
{
    index = (index &lt; 0 ? d_numPrefixes + index : index);
    BSLS_ASSERT_SAFE(0 &lt;= index &amp;&amp; index &lt; d_numPrefixes);
    return d_prefixes[index].first.c_str();
}

inline
int PrefixStack::namespaceIdByIndex(int index) const
{
    index = (index &lt; 0 ? d_numPrefixes + index : index);
    BSLS_ASSERT_SAFE(0 &lt;= index &amp;&amp; index &lt; d_numPrefixes);
    return d_prefixes[index].second;
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
