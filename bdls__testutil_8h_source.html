<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdls_testutil.h                                                    -*-C++-*-
#ifndef INCLUDED_BDLS_TESTUTIL
#define INCLUDED_BDLS_TESTUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide test utilities for components in &#39;bdl&#39; and above.
//
//@DEPRECATED: Use &#39;bslim_testutil&#39; instead.
//
//@CLASSES:
//
//@MACROS:
//  BDLS_TESTUTIL_LOOP_ASSERT(I, X): print args if &#39;!X&#39;
//  BDLS_TESTUTIL_LOOP2_ASSERT(I, J, X): print args if &#39;!X&#39;
//  BDLS_TESTUTIL_LOOP3_ASSERT(I, J, K, X): print args if &#39;!X&#39;
//  BDLS_TESTUTIL_LOOP4_ASSERT(I, J, K, L, X): print args if &#39;!X&#39;
//  BDLS_TESTUTIL_LOOP5_ASSERT(I, J, K, L, M, X): print args if &#39;!X&#39;
//  BDLS_TESTUTIL_LOOP6_ASSERT(I, J, K, L, M, N, X): print args if &#39;!X&#39;
//  BDLS_TESTUTIL_ASSERTV(..., x): generic print args if &#39;!X&#39;
//  BDLS_TESTUTIL_Q(X): quote identifier literally
//  BDLS_TESTUTIL_P(X): print identifier and value
//  BDLS_TESTUTIL_P_(X): print identifier and value without &#39;\n&#39;
//  BDLS_TESTUTIL_L_: current line number
//  BDLS_TESTUTIL_T_: print tab without &#39;\n&#39;
//
//@SEE_ALSO: bslim_testutil
//
//@DESCRIPTION: This component provides the standard print macros used in
// BDE-style test drivers (&#39;ASSERT&#39;, &#39;LOOP_ASSERT&#39;, &#39;ASSERTV&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;L&#39;,
// and &#39;T&#39;) for components in the &#39;bdl&#39; package group and above.
//
// This component also define a set of overloads for the insertion operator
// (&#39;&lt;&lt;&#39;) to support the streaming of test types defined in the &#39;bsltf&#39;
// package.  This is required for test drivers in the &#39;bdl&#39; package group and
// above to print the objects of these types to &#39;bsl::cout&#39;.
//
// Note that the &#39;bsltf&#39; package resides below &#39;bsl+bslhdrs&#39;, in which
// &#39;bsl::cout&#39; is defined; therefore, the components in &#39;bsltf&#39; cannot
// directly define the overloads of the insertion operator to support printing
// the test types.  Instead, an alternate method supplied in &#39;bsls_bsltestutil&#39;
// is used for test drivers in the &#39;bsl&#39; package group.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Writing a Test Driver
/// - - - - - - - - - - - - - - - -
// First, we write a component to test, which provides a utility class:
//..
//  namespace bdlabc {
//
//  struct BdlExampleUtil {
//      // This utility class provides sample functionality to demonstrate how
//      // a test driver might be written validating its only method.
//
//      static int fortyTwo();
//          // Return the integer value &#39;42&#39;.
//  };
//
//  inline
//  int BdlExampleUtil::fortyTwo()
//  {
//      return 42;
//  }
//
//  }  // close package namespace
//..
// Then, we can write a test driver for this component.  We start by providing
// the standard BDE assert test macro:
//..
//  //=========================================================================
//  //                       STANDARD BDE ASSERT TEST MACRO
//  //-------------------------------------------------------------------------
//  static int testStatus = 0;
//
//  static void aSsErT(bool b, const char *s, int i)
//  {
//      if (b) {
//          printf(&quot;Error &quot; __FILE__ &quot;(%d): %s    (failed)\n&quot;, i, s);
//          if (testStatus &gt;= 0 &amp;&amp; testStatus &lt;= 100) ++testStatus;
//      }
//  }
//..
// Next, we define the standard print and &#39;LOOP_ASSERT&#39; macros, as aliases to
// the macros defined by this component:
//..
//  //=========================================================================
//  //                       STANDARD BDE TEST DRIVER MACROS
//  //-------------------------------------------------------------------------
//
//  #define ASSERT       BDLS_TESTUTIL_ASSERT
//  #define LOOP_ASSERT  BDLS_TESTUTIL_LOOP_ASSERT
//  #define LOOP0_ASSERT BDLS_TESTUTIL_LOOP0_ASSERT
//  #define LOOP1_ASSERT BDLS_TESTUTIL_LOOP1_ASSERT
//  #define LOOP2_ASSERT BDLS_TESTUTIL_LOOP2_ASSERT
//  #define LOOP3_ASSERT BDLS_TESTUTIL_LOOP3_ASSERT
//  #define LOOP4_ASSERT BDLS_TESTUTIL_LOOP4_ASSERT
//  #define LOOP5_ASSERT BDLS_TESTUTIL_LOOP5_ASSERT
//  #define LOOP6_ASSERT BDLS_TESTUTIL_LOOP6_ASSERT
//  #define ASSERTV      BDLS_TESTUTIL_ASSERTV
//
//  #define Q   BDLS_TESTUTIL_Q   // Quote identifier literally.
//  #define P   BDLS_TESTUTIL_P   // Print identifier and value.
//  #define P_  BDLS_TESTUTIL_P_  // P(X) without &#39;\n&#39;.
//  #define T_  BDLS_TESTUTIL_T_  // Print a tab (w/o newline).
//  #define L_  BDLS_TESTUTIL_L_  // current Line number
//..
// Now, using the (standard) abbreviated macro names we have just defined, we
// write a test function for the &#39;static&#39; &#39;fortyTwo&#39; method, to be called from
// a test case in a test driver.
//..
//  void testFortyTwo(bool verbose)
//  {
//      const int value = bdlabc::BdlExampleUtil::fortyTwo();
//      if (verbose) P(value);
//      LOOP_ASSERT(value, 42 == value);
//  }
//..
// Finally, when &#39;testFortyTwo&#39; is called from a test case in verbose mode we
// observe the console output:
//..
//  value = 42
//..
//
///Example 2: Print the Value of a Test Type
///- - - - - - - - - - - - - - - - - - - - -
// Suppose we want to print the value of an object of a test type defined the
// &#39;bsltf&#39; package using &#39;bsl::cout&#39;.  This component supplies the necessary
// overloads of the insertion operator for this to be done directly.
//
// First, include the header of this component:
//..
//  #include &lt;bdls_testutil.h&gt;
//..
// Now, we construct a &#39;SimpleTestType&#39; object and stream its value to
// &#39;bsl::cout&#39; using the &#39;&lt;&lt;&#39; operator:
//..
//  bsltf::SimpleTestType a(10);
//  bsl::cout &lt;&lt; a;
//..
// Finally, we observe the following console output:
//..
//  10
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSTREAM
#include &lt;bsl_iostream.h&gt;
#endif

#ifndef INCLUDED_BSLTF_TEMPLATETESTFACILITY
#include &lt;bsltf_templatetestfacility.h&gt;
#endif

                       // =================
                       // Macro Definitions
                       // =================

#define BDLS_TESTUTIL_ASSERT(X)                                               \
    aSsErT(!(X), #X, __LINE__);

#define BDLS_TESTUTIL_LOOP0_ASSERT                                            \
    BDLS_TESTUTIL_ASSERT

#define BDLS_TESTUTIL_LOOP_ASSERT(I,X)                                        \
    if (!(X)) { cout &lt;&lt; #I &lt;&lt; &quot;: &quot; &lt;&lt; I &lt;&lt; &quot;\n&quot;;                              \
                aSsErT(1, #X, __LINE__); }

#define BDLS_TESTUTIL_LOOP1_ASSERT                                            \
    BDLS_TESTUTIL_LOOP_ASSERT

#define BDLS_TESTUTIL_LOOP2_ASSERT(I,J,X)                                     \
    if (!(X)) { cout &lt;&lt; #I &lt;&lt; &quot;: &quot; &lt;&lt; I &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #J &lt;&lt; &quot;: &quot; &lt;&lt; J &lt;&lt; &quot;\n&quot;;                              \
                aSsErT(1, #X, __LINE__); }

#define BDLS_TESTUTIL_LOOP3_ASSERT(I,J,K,X)                                   \
    if (!(X)) { cout &lt;&lt; #I &lt;&lt; &quot;: &quot; &lt;&lt; I &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #J &lt;&lt; &quot;: &quot; &lt;&lt; J &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #K &lt;&lt; &quot;: &quot; &lt;&lt; K &lt;&lt; &quot;\n&quot;;                              \
                aSsErT(1, #X, __LINE__); }

#define BDLS_TESTUTIL_LOOP4_ASSERT(I,J,K,L,X)                                 \
    if (!(X)) { cout &lt;&lt; #I &lt;&lt; &quot;: &quot; &lt;&lt; I &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #J &lt;&lt; &quot;: &quot; &lt;&lt; J &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #K &lt;&lt; &quot;: &quot; &lt;&lt; K &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #L &lt;&lt; &quot;: &quot; &lt;&lt; L &lt;&lt; &quot;\n&quot;;                              \
                aSsErT(1, #X, __LINE__); }

#define BDLS_TESTUTIL_LOOP5_ASSERT(I,J,K,L,M,X)                               \
    if (!(X)) { cout &lt;&lt; #I &lt;&lt; &quot;: &quot; &lt;&lt; I &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #J &lt;&lt; &quot;: &quot; &lt;&lt; J &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #K &lt;&lt; &quot;: &quot; &lt;&lt; K &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #L &lt;&lt; &quot;: &quot; &lt;&lt; L &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #M &lt;&lt; &quot;: &quot; &lt;&lt; M &lt;&lt; &quot;\n&quot;;                              \
               aSsErT(1, #X, __LINE__); }

#define BDLS_TESTUTIL_LOOP6_ASSERT(I,J,K,L,M,N,X)                             \
    if (!(X)) { cout &lt;&lt; #I &lt;&lt; &quot;: &quot; &lt;&lt; I &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #J &lt;&lt; &quot;: &quot; &lt;&lt; J &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #K &lt;&lt; &quot;: &quot; &lt;&lt; K &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #L &lt;&lt; &quot;: &quot; &lt;&lt; L &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #M &lt;&lt; &quot;: &quot; &lt;&lt; M &lt;&lt; &quot;\t&quot;                               \
                     &lt;&lt; #N &lt;&lt; &quot;: &quot; &lt;&lt; N &lt;&lt; &quot;\n&quot;;                              \
               aSsErT(1, #X, __LINE__); }


// The &#39;BDLS_TESTUTIL_EXPAND&#39; macro is required to workaround a pre-processor
// issue on windows that prevents __VA_ARGS__ to be expanded in the definition
// of &#39;BDLS_TESTUTIL_NUM_ARGS&#39;
#define BDLS_TESTUTIL_EXPAND(X)                                               \
    X

#define BDLS_TESTUTIL_NUM_ARGS_IMPL(X6, X5, X4, X3, X2, X1, X0, N, ...)       \
    N

#define BDLS_TESTUTIL_NUM_ARGS(...)                                           \
    BDLS_TESTUTIL_EXPAND(BDLS_TESTUTIL_NUM_ARGS_IMPL(                         \
                                         __VA_ARGS__, 6, 5, 4, 3, 2, 1, 0, &quot;&quot;))

#define BDLS_TESTUTIL_LOOPN_ASSERT_IMPL(N, ...)                               \
    BDLS_TESTUTIL_EXPAND(BDLS_TESTUTIL_LOOP ## N ## _ASSERT(__VA_ARGS__))

#define BDLS_TESTUTIL_LOOPN_ASSERT(N, ...)                                    \
    BDLS_TESTUTIL_LOOPN_ASSERT_IMPL(N, __VA_ARGS__)

#define BDLS_TESTUTIL_ASSERTV(...)                                            \
    BDLS_TESTUTIL_LOOPN_ASSERT(                                               \
                              BDLS_TESTUTIL_NUM_ARGS(__VA_ARGS__), __VA_ARGS__)

#define BDLS_TESTUTIL_Q(X)                                                    \
    cout &lt;&lt; &quot;&lt;| &quot; #X &quot; |&gt;&quot; &lt;&lt; endl;
    // Quote identifier literally.

#define BDLS_TESTUTIL_P(X)                                                    \
    cout &lt;&lt; #X &quot; = &quot; &lt;&lt; (X) &lt;&lt; endl;
    // Print identifier and its value.

#define BDLS_TESTUTIL_P_(X)                                                   \
    cout &lt;&lt; #X &quot; = &quot; &lt;&lt; (X) &lt;&lt; &quot;, &quot; &lt;&lt; flush;
    // &#39;P(X)&#39; without &#39;\n&#39;

#define BDLS_TESTUTIL_L_                                                      \
    __LINE__
    // current Line number

#define BDLS_TESTUTIL_T_                                                      \
    cout &lt;&lt; &quot;\t&quot; &lt;&lt; flush;
    // Print tab (w/o newline).


namespace BloombergLP {
namespace bsltf {

// FREE OPERATORS
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const EnumeratedTestType::Enum&amp;        obj);
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const UnionTestType&amp;                   obj);
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const SimpleTestType&amp;                  obj);
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const AllocTestType&amp;                   obj);
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const BitwiseMoveableTestType&amp;         obj);
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const AllocBitwiseMoveableTestType&amp;    obj);
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const NonTypicalOverloadsTestType&amp;     obj);
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const NonAssignableTestType&amp;           obj);
#if 0
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const NonCopyConstructibleTestType&amp;    obj);
#endif
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const NonDefaultConstructibleTestType&amp; obj);
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const NonEqualComparableTestType&amp;      obj);
    // Write the value of the specified &#39;object&#39; to the specified output
    // &#39;stream&#39; in a single-line format, and return a reference providing
    // modifiable access to &#39;stream&#39;.  If &#39;stream&#39; is not valid on entry, this
    // operation has no effect.


// ============================================================================
//                          INLINE DEFINITIONS
// ============================================================================

// FREE OPERATORS
inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                   stream,
                         const EnumeratedTestType::Enum&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;        stream,
                         const UnionTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;         stream,
                         const SimpleTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;        stream,
                         const AllocTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                  stream,
                         const BitwiseMoveableTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                       stream,
                         const AllocBitwiseMoveableTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                      stream,
                         const NonTypicalOverloadsTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                stream,
                         const NonAssignableTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

#if 0
inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                       stream,
                         const NonCopyConstructibleTestType&amp; obj)
{
    return stream &lt;&lt; obj.data();
}
#endif

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                          stream,
                         const NonDefaultConstructibleTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                     stream,
                         const NonEqualComparableTestType&amp; obj)
{
    return stream &lt;&lt; bsltf::TemplateTestFacility::getIdentifier(obj);
}

}  // close namespace bsltf
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2012 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
