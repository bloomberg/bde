<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmt_qlock.h                                                      -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BSLMT_QLOCK
#define INCLUDED_BSLMT_QLOCK

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide small, statically-initializable mutex lock.
//
//@CLASSES:
//       bslmt::QLock: Small, statically-initializable intra-process mutex
//  bslmt::QLockGuard: Automatic locking-unlocking of bslmt::QLock
//
//@SEE_ALSO: bslmt_mutex, bslmt_atomictypes, bslmt_lockguard, bslmt_once
//
//@DESCRIPTION: This component defines a portable and efficient lock for
// ensuring that only one thread at a time enters a specific &quot;critical region&quot;
// -- a section of code that accesses a shared resource -- &#39;bslmt::Qlock&#39; and
// its associated &#39;bslmt::QLockGuard&#39;.  The functionality of the &#39;bslmt::QLock&#39;
// class overlaps those of the &#39;bslmt::Mutex&#39; and &#39;bsls::SpinLock&#39; classes, but
// with different usage and performance characteristics, as shown in the
// following grid:
//..
//                                    | QLock | Mutex | SpinLock
// -----------------------------------+-------+-------+---------
// Memory footprint                   | small | large | small
// Cost of construction/destruction   | cheap | costly| cheap
// Statically initializable           | yes   | no    | yes
// Speed at low contention            | fast  | fast  | fast
// Speed at high contention           | slow  | fast  | very slow
// Suitable for long critical regions | yes   | yes   | no
// Fair                               | yes   | no    | no
//..
// The performance trade-offs for a QLock are quite different than those for a
// conventional mutex.  QLocks are best suited for low-contention applications
// where large numbers of locks may be needed.  For example, a node-based data
// structure that needs a lock for each node can benefit from the small size
// and low initialization cost of a QLock compared to that of a conventional
// mutex.  A &#39;bslmt::Mutex&#39; object cannot be initialized statically because
// some platforms (e.g., Windows XP) do not have a native
// statically-initializable mutex type.  A &#39;bslmt::QLock&#39; object, in contrast
// is statically initializable on all platforms.
//
// The performance characteristics of a QLock are very similar to those of a
// SpinLock.  However, a QLock is much more suitable than a SpinLock for
// situations where the critical region is more than a few instructions long.
// Also, although QLocks are best for low-contention situations, they do not
// degrade nearly as badly as SpinLocks if there is a lot of contention for the
// lock.  They also use significantly fewer CPU cycles in high-contention
// situations than do SpinLocks.
//
// A unique characteristic of QLocks is that they are fair.  If there is
// contention for a lock, each thread is given the lock in the order in which
// it requested it.  Consequently, every thread competing for the lock will get
// a chance before any other thread can have a second turn; no thread is ever
// &quot;starved&quot; out of the critical region.  This fairness comes at a cost,
// however, in that the scheduler is given less leeway to schedule threads in
// the most efficient manner.
//
///The &#39;bslmt::QLockGuard&#39; Class
///-----------------------------
// A &#39;bslmt::QLock&#39; is different from other locking classes such as
// &#39;bslmt::Mutex&#39; and &#39;bsls::SpinLock&#39; in that it cannot be manipulated except
// through the auxiliary &#39;bslmt::QLockGuard&#39; class.  The reason for this
// limited interface is that a QLock requires a small amount of additional
// storage for each thread that is holding or waiting for the lock.  The
// &#39;bslmt::QLockGuard&#39; provides this extra storage efficiently on the stack.
//
// In typical usage, a &#39;bslmt::QLockGuard&#39; is created as a local (stack)
// variable, acquires the lock in its constructor and releases the lock in its
// destructor.  If the lock is in use at construction time, then the current
// thread blocks until the lock becomes available.  Although the QLock itself
// is intended to be shared among multiple threads, the guard object must never
// be used by more than one thread at a time.  When multiple threads want to
// acquire the same QLock, each must use its own &#39;bslmt::QLockGuard&#39; object.
//
// &#39;bslmt::QLockGuard&#39; also provides the following manipulators typical of
// locking classes:
//..
//  void lock();    // Acquire the lock, waiting if necessary
//  int tryLock();  // Acquire the lock if possible.  Fail if lock is in use.
//  void unlock();  // Free the lock.
//..
// As with other types of mutexes, only one thread my hold the lock at a time.
// Other threads attempting to call &#39;lock&#39; will block until the lock becomes
// available.  However, it is important to remember that the manipulators
// listed above are only pass-through operations on the shared &#39;bslmt::QLock&#39;
// object.  In other words, upon return from calling &#39;lock&#39; on a
// &#39;bslmt::QLockGuard&#39; object, a thread has actually acquired the lock to the
// underlying &#39;bslmt::QLock&#39;.
//
// Although it is only a proxy for the actual QLock, &#39;lock&#39;/&#39;unlock&#39;/&#39;tryLock&#39;
// interface of &#39;bslmt::QLockGuard&#39; allows it to be treated as though it were
// itself a lock.  In particular, it is possible to instantiate the
// &#39;bslmt::LockGuard&#39; and &#39;bslmt::LockGuardUnlock&#39; class templates using
// &#39;bslmt::QLockGuard&#39;.  This layering of guard classes is useful for creating
// regions where the QLock is locked or unlocked.  For example, if a thread
// acquires a QLock and then needs to temporarily relinquish it, it could use a
// &#39;bslmt::LockGuardUnlock&#39; as follows:
//..
//  void Node::update()
//  {
//     bslmt::QLockGuard qguard(&amp;d_qlock);  // &#39;d_qlock&#39; is a &#39;bslmt::QLock&#39;.
//     readLunarState();
//     if (d_moonIsFull) {
//         // Free lock while we sleep
//         bslmt::LockGuardUnlock&lt;bslmt::QLockGuard&gt; unlock(&amp;qguard)
//         sleep(TWENTY_FOUR_HOURS);
//     }
//     // Lock has been re-acquired
//     ...
//  }
//..
// The behavior is undefined if &#39;unlock&#39; is invoked from a thread that did not
// successfully acquire the lock, or if &#39;lock&#39; is called twice in a thread
// without an intervening call to &#39;unlock&#39; (i.e., &#39;bslmt::QLockGuard&#39; is
// non-recursive).
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Using &#39;bslmt::QLock&#39; to Implement a Thread-Safe Singleton
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// For this example, assume that we have the need to use the string &quot;Hello&quot;
// repeatedly in the form of an &#39;bsl::string&#39; object.  Rather than construct
// the string each time we use it, it would be nice to have only one copy so
// that we can amortize the memory allocation and construction cost over all
// the uses of the string.  It is thus logical to have a single, static
// variable (a singleton) of type &#39;bsl::string&#39; initialized with the value,
// &quot;Hello&quot;.  Unfortunately, as this is a multithreaded application, there is
// the danger that more than one thread will attempt to initialize the
// singleton simultaneously, causing a memory leak at best and memory
// corruption at worse.  To solve this problem, we use a &#39;bslmt::QLock&#39; to
// synchronize access to the singleton.
//
// We begin by wrapping the singleton in a function:
//..
//  const bsl::string&amp; helloString()
//  {
//..
// This function defines two static variables, a pointer to the singleton, and
// a QLock to control access to the singleton.  Note that both of these
// variables are statically initialized, so there is no need for a run-time
// constructor and hence no danger of a race condition among threads.  The need
// for static initialization is the main reason we choose to use &#39;bslmt::QLock&#39;
// over &#39;bslmt::Mutex&#39;:
//..
//      static const bsl::string *singletonPtr = 0;
//      static bslmt::QLock qlock = BSLMT_QLOCK_INITIALIZER;
//..
// Before checking the status of the singleton pointer, we must make sure that
// we are not accessing the pointer at the same time that some other thread is
// modifying the pointer.  We do this by acquiring the lock by constructing a
// &#39;bslmt::QLockGuard&#39; object:
//..
//      bslmt::QLockGuard qlockGuard(&amp;qlock);
//..
// Now we are inside the critical region.  If the pointer has not already been
// set, we can initialize the singleton knowing that no other thread is
// manipulating or accessing these variables at the same time.  Note that this
// critical region involves constructing a variable of type &#39;bsl::string&#39;.
// This operation, while not ultra-expensive, is too lengthy for comfortably
// holding a spinlock.  Again, the characteristics of &#39;bslmt::QLock&#39; are
// superior to the alternatives for this application.  (It is worth noting that
// the QLock concept was created specifically to permit this kind of one-time
// processing.  See also &#39;bslmt_once&#39;.)
//..
//      if (! singletonPtr) {
//          static bsl::string singleton(&quot;Hello&quot;);
//          singletonPtr = &amp;singleton;
//      }
//..
// Finally, we return a reference to the singleton.  The destructor for
// &#39;bslmt::QLockGuard&#39; will automatically unlock the QLock and allow another
// thread into the critical region.
//..
//      return *singletonPtr;
//  }
//..
// The following test program shows how our singleton function can be called.
// Note that &#39;hello1&#39; and &#39;hello2&#39; have the same address, demonstrating that
// there was only one string created.
//..
//  int usageExample1()
//  {
//      const bsl::string EXPECTED(&quot;Hello&quot;);
//
//      const bsl::string&amp; hello1 = helloString();
//      assert(hello1 == EXPECTED);
//
//      const bsl::string&amp; hello2 = helloString();
//      assert(hello2  == EXPECTED);
//      assert(&amp;hello2 == &amp;hello1);
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMICOPERATIONS
#include &lt;bsls_atomicoperations.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {
namespace bslmt {

class Semaphore;

#define BSLMT_QLOCK_INITIALIZER  { {0} }
    // Use this macro as the value for initializing an object of type &#39;QLock&#39;
    // For example:
    //..
    //  QLock mylock = BSLMT_QLOCK_INITIALIZER;
    //..

                               // ============
                               // struct QLock
                               // ============

struct QLock {
    // An efficient statically-initializable synchronization primitive that
    // enables serialized access to shared resources.  Objects of this class
    // can only be manipulated through the use of a &#39;QLockGuard&#39;.  The
    // following idiom is used to initialize objects of type &#39;QLock&#39;:
    //..
    //  QLock mylock = BSLMT_QLOCK_INITIALIZER;
    //..

  private:
    // NOT IMPLEMENTED
    QLock&amp; operator=(const QLock&amp;);

    // We would like to prohibit copy construction, but then this class would
    // not be a POD and we would lose the ability to initialize objects of this
    // class statically.

    // QLock(const QLock&amp;);

  public:
    bsls::AtomicOperations::AtomicTypes::Pointer d_guardQueueTail;
        // Pointer to the last guard in the queue of guards waiting for this
        // lock, or 0 if the lock is unlocked.
        //
        // Note that the first guard in the queue owns the lock so that
        // &#39;d_guardQueueTail&#39; points to the owner of the lock when the lock is
        // locked and there are no additional guards waiting.
        //
        // It would have been preferable for this member to be private, but
        // then this class would not be statically initializable.  Also, it
        // would have been preferable to make this member an instance of
        // &#39;bsls::AtomicPointer&lt;&gt;&#39;, but again, we would lose the ability to
        // initialize statically.

  public:
    // MANIPULATORS
    void initialize();
        // Set this lock into the initial unlocked state.

    // ACCESSORS
    bool isLocked() const;
        // Return true if this lock is locked and false otherwise.
};

                          // =====================
                          // class QLock_EventFlag
                          // =====================

class QLock_EventFlag {
    // [!PRIVATE!] This class provides a thread-safe mechanism for one thread
    // to inform another thread that some event has occurred.  A flag provides
    // two primary manipulators, &#39;set&#39;, which indicates the event has occurred,
    // and &#39;waitUntilSet&#39;, which waits until that event has occurred (or
    // returns immediately if it has already occurred).  A flag is intended to
    // be used by only two threads: a thread setting the flag, and a thread
    // waiting for the flag to be set, and the behavior is undefined if &#39;set&#39;
    // is called while the flag is already set, or if &#39;waitUntilSet&#39; is called
    // while another thread is waiting for the flag.
    //
    // This class is an implementation detail of the &#39;bslmt_qlock&#39;, and must
    // not be used by client code.

  private:
    // PRIVATE TYPES
    typedef bsls::AtomicPointer&lt;Semaphore&gt; AtomicSemaphorePtr;

    // DATA
    AtomicSemaphorePtr d_status;  // status of this flag

  private:
    // NOT IMPLEMENTED
    QLock_EventFlag(const QLock_EventFlag&amp;);
    QLock_EventFlag&amp; operator=(const QLock_EventFlag&amp;);

  public:

    // CREATORS
    QLock_EventFlag();
        // Create an unset flag.

    ~QLock_EventFlag();
        // Destroy this flag.  The behavior is undefined if a thread is
        // currently waiting for the flag to be set.

    // MANIPULATORS
    void reset();
        // Reset this flag to the unset state.  The behavior is undefined if a
        // thread is waiting for this flag to be set.

    void set();
        // Set this flag, and if a thread is waiting for it, signal the waiting
        // thread.  The behavior is undefined if this flag is already set.

    void waitUntilSet(int spinRetryCount);
        // Wait until this flag has been set (returning immediately if this
        // flag is already set), and, if this flag is not already set, spin for
        // the specified &#39;spinCount&#39; iterations before waiting on a semaphore.
        // The behavior is undefined unless there are no other threads waiting
        // for this flag to be set.
};

                             // ================
                             // class QLockGuard
                             // ================

class QLockGuard  {
    // This class provides the means to acquire and release the lock on a
    // &#39;QLock&#39; object.  Typically, the lock is acquired at construction and
    // released automatically on destruction.  This class also provides
    // explicit &#39;lock&#39;, &#39;tryLock&#39;, and &#39;unlock&#39; primitives.

  private:

    QLock           *d_qlock_p;    // points to tail of the queue.

    QLockGuard      *d_next;       // next object in queue.

    QLock_EventFlag  d_readyFlag;  // flag indicating when the lock is released
                                   // by its predecessor in the queue

    QLock_EventFlag  d_nextFlag;   // flag indicating &#39;d_next&#39; is set by its
                                   // successor.

    bool             d_locked;     // &#39;true&#39; if this guard holds the lock

  private:
    // NOT IMPLEMENTED
    QLockGuard(const QLockGuard&amp;);
    QLockGuard&amp; operator=(const QLockGuard&amp;);

    // PRIVATE MANIPULATORS
    void unlockRaw();
        // Free the lock but do not clear the member variables of this class.

  public:
    // CREATORS
    QLockGuard();
        // Create a guard in the unlocked state, not associated with any
        // &#39;QLock&#39; objects.

    explicit QLockGuard(QLock *qlock, bool doLock = true);
        // Create a guard associated with the specified &#39;qlock&#39;.  Acquire the
        // lock unless the (optionally) specified &#39;doLock&#39; is false.  If the
        // &#39;lock&#39; is not free, block until it can be acquired.

    ~QLockGuard();
        // Destroy this object.  If this object holds a lock, automatically
        // free it.

    // MANIPULATORS
    void setQLock(QLock *qlock);
        // Associate this guard with the specified &#39;qlock&#39;.  The behavior is
        // undefined if this object is already in a locked state.

    void lock();
        // Acquire a lock on the associated &#39;QLock&#39; object.  If the &#39;lock&#39; is
        // not free, block until it can be acquired.  The behavior is undefined
        // if the calling thread already owns the lock on the QLock.

    void lock(QLock *qlock);
        // Associate this guard with the specified &#39;qlock&#39; and acquire the
        // lock.  If the &#39;lock&#39; is not free, block until it can be acquired.
        // The behavior is undefined if the calling thread already owns the
        // lock on &#39;qlock&#39; or if this object is in the locked state.

    int tryLock();
        // Attempt to acquire a lock on the associated &#39;QLock&#39; object.  Return
        // 0 on success, a positive value of the associated QLock object is
        // already locked, or a negative value if an error occurs.

    void unlock();
        // Release the lock on the associated &#39;QLock&#39;.  The behavior is
        // undefined unless this guard previously acquired the lock and has not
        // already released it.
};

}  // close package namespace

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

                               // -----------
                               // class QLock
                               // -----------

// MANIPULATORS
inline
void bslmt::QLock::initialize()
{
    bsls::AtomicOperations::setPtrRelaxed(&amp;d_guardQueueTail, 0);
}

// ACCESSORS
inline
bool bslmt::QLock::isLocked() const
{
    return bsls::AtomicOperations::getPtr(&amp;d_guardQueueTail) != 0;
}

                          // ---------------------
                          // class QLock_EventFlag
                          // ---------------------

// CREATORS
inline
bslmt::QLock_EventFlag::QLock_EventFlag()
: d_status(0)
{
}

inline
bslmt::QLock_EventFlag::~QLock_EventFlag()
{
}

// MANIPULATORS
inline
void bslmt::QLock_EventFlag::reset()
{
    d_status = 0;
}

                             // ----------------
                             // class QLockGuard
                             // ----------------

// CREATORS
inline
bslmt::QLockGuard::QLockGuard()
: d_qlock_p   (0)
, d_next      (0)
, d_readyFlag ()
, d_nextFlag  ()
, d_locked    (false)
{
}

inline
bslmt::QLockGuard::QLockGuard(QLock *qlock, bool doLock)
: d_qlock_p   (qlock)
, d_next      (0)
, d_readyFlag ()
, d_nextFlag  ()
, d_locked    (false)
{
    if (doLock) {
        lock();
    }
}

inline
bslmt::QLockGuard::~QLockGuard()
{
    if (d_locked) {
        unlockRaw();
    }
}

// MANIPULATORS
inline
void bslmt::QLockGuard::setQLock(QLock *qlock)
{
    BSLS_ASSERT_SAFE(!d_locked);

    d_qlock_p = qlock;
}

inline
void bslmt::QLockGuard::lock(QLock *qlock)
{
    BSLS_ASSERT_SAFE(!d_locked);
    BSLS_ASSERT_SAFE(qlock);

    d_qlock_p = qlock;
    lock();
}

inline
void bslmt::QLockGuard::unlock()
{
    if (d_locked) {
        // Release the lock, and reset the state variables so it can be
        // relocked.

        unlockRaw();

        d_locked = false;
        d_next   = 0;
        d_readyFlag.reset();
        d_nextFlag.reset();
    }
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
