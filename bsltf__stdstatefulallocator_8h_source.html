<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bsltf_stdstatefulallocator.h                                       -*-C++-*-
#ifndef INCLUDED_BSLTF_STDSTATEFULALLOCATOR
#define INCLUDED_BSLTF_STDSTATEFULALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a minimal standard compliant allocator.
//
//@CLASSES:
//  bsltf::StdStatefulAllocator: standard compliant allocator managing state
//
//@SEE_ALSO: bsltf_stdtestallocator
//
//@DESCRIPTION: This component provides an allocator, &#39;StdStatefulAllocator&#39;,
// that defines the minimal interface to comply with section 17.6.3.5
// ([allocator.requirements]) of the C++11 standard, while still providing an
// externally visible and potentially distinct state for each allocator object.
// This type can be used to verify that constructs designed to support a
// standard-compliant allocator access the allocator only through the
// standard-defined interface.
//
// &#39;StdStatefulAllocator&#39; delegates its operations to &#39;bslma::TestAllocator&#39;
// (delegate allocator) that is also the sole attribute of this class.  We
// choose to store a test allocator as the attribute constituting state as
// this allows a common test strategy to support testing allocation with BDE
// allocators, and testing the general notion of stateful STL allocators.  The
// key differences between this test allocator and a regular BDE allocator are:
//
//: o This allocator does not support the &#39;scoped&#39; allocation model, so that
//:   elements in a container will often have a different allocator to the
//:   container object itself.
//:
//: o This allocator may propagate through copy operations, move operations
//:   and &#39;swap&#39; operations, depending on how the template is configured as
//:   it is instantiated.
//:
//: o This allocator is not DefaultConstructible, and has no notion of the
//:   default allocator.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Testing The Support for STL-Compliant Allocator
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In this example we will verify that a type supports the use of a
// STL-compliant allocator.
//
// First we define a simple container type intended to be used with a C++03
// standard compliant allocator:
//..
//  template &lt;class TYPE, class ALLOCATOR&gt;
//  class MyContainer {
//      // This container type is parameterized on a standard allocator type
//      // and contains a single object, always initialized, which can be
//      // replaced and accessed.
//
//      // DATA MEMBERS
//      ALLOCATOR  d_allocator;  // allocator used to supply memory (held, not
//                               // owned)
//
//      TYPE      *d_object_p;   // pointer to the contained object
//
//    public:
//      // CONSTRUCTORS
//      MyContainer(const TYPE&amp; object);
//          // Create an container containing the specified &#39;object&#39;, using the
//          // parameterized &#39;ALLOCATOR&#39; to allocate memory.
//
//      ~MyContainer();
//          // Destroy this container.
//
//      // MANIPULATORS
//      TYPE&amp; object();
//
// // Return a reference providing modifiable access to the object
//          // contained in this container.
//
//      // ACCESSORS
//      const TYPE&amp; object() const;
//          // Return a reference providing non-modifiable access to the object
//          // contained in this container.
//  };
//..
// Then, we define the member functions of &#39;MyContainer&#39;:
//..
//  // CREATORS
//  template &lt;class TYPE, class ALLOCATOR&gt;
//  MyContainer&lt;TYPE, ALLOCATOR&gt;::MyContainer(const TYPE&amp; object)
//  {
//      d_object_p = d_allocator.allocate(1);
//      d_allocator.construct(d_object_p, object);
//  }
//
//  template &lt;class TYPE, class ALLOCATOR&gt;
//  MyContainer&lt;TYPE, ALLOCATOR&gt;::~MyContainer()
//  {
//      d_allocator.destroy(d_object_p);
//      d_allocator.deallocate(d_object_p);
//  }
//
//  // MANIPULATORS
//  template &lt;class TYPE, class ALLOCATOR&gt;
//  TYPE&amp; MyContainer&lt;TYPE, ALLOCATOR&gt;::object()
//  {
//      return *d_object_p;
//  }
//
//  // ACCESSORS
//  template &lt;class TYPE, class ALLOCATOR&gt;
//  const TYPE&amp; MyContainer&lt;TYPE, ALLOCATOR&gt;::object() const
//  {
//      return *d_object_p;
//  }
//..
// Now, we use &#39;StdStatefulAllocator&#39; to implement a simple test for
// &#39;MyContainer&#39; to verify it correctly uses a parameterized allocator using
// only the C++03 standard methods:
//..
//  bslma_TestAllocator oa(&quot;object&quot;, veryVeryVeryVerbose);
//  StdStatefulAllocatorConfigurationGuard stag(&amp;oa);
//  {
//      typedef MyContainer&lt;int, StdStatefulAllocator&lt;int&gt; &gt; Obj;
//
//      Obj mX(2); const Obj&amp; X = mX;
//      assert(sizeof(int) == oa.numBytesInUse());
//
//      assert(X.object() == 2);
//
//      mX.object() = -10;
//      assert(X.object() == -10);
//  }
//
//  assert(0 == oa.numBytesInUse());
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_TESTALLOCATOR
#include &lt;bslma_testallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISSAME
#include &lt;bslmf_issame.h&gt;
#endif

namespace BloombergLP {
namespace bsltf {

                        // ==========================
                        // class StdStatefulAllocator
                        // ==========================

template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION = true,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT = true,
          bool  PROPAGATE_ON_CONTAINER_SWAP = true,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT = true&gt;
class StdStatefulAllocator {
    // This allocator implements the minimal interface to comply with section
    // 17.6.3.5 ([allocator.requirements]) of the C++11 standard, while
    // maintaining a distinct object state - in this case a wrapped pointer to
    // a &#39;bslma::TestAllocator&#39;.  The template is configurable to control its
    // allocator propagation properties, but does not support the BDE &quot;scoped&quot;
    // allocator model, as scoped allocators should never propagate.  Instances
    // of this allocator delegate their operations to the wrapped test
    // allocator that constitutes its state.  Note that meeting only the
    // minimal requirements means that this class is not DefaultConstructible.
    // Note that while we define the various traits used by the C++11 allocator
    // traits facility, they actually mean very little for this component, as
    // it is the consumer of the allocator&#39;s responsibility to check and apply
    // the traits correctly, typically by using &#39;bsl::allocator_traits&#39; to
    // perform all memory allocation tasks rather than using the allocator
    // directly.  The &#39;PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION&#39; flag is
    // consumed directly though, in the static member function
    // &#39;select_on_container_copy_construction&#39;.

  private:
    // CLASS DATA
    bslma::TestAllocator *d_allocator_p; // the wrapped test allocator

  public:
    // PUBLIC TYPES
    typedef TYPE value_type;

    // For a minimal allocator, these should all be deducible for a C++11
    // container implementation.  Unfortunately, the C++03 implementation of
    // &#39;allocator_traits&#39; supported by BDE does not try the leaps of template
    // metaprogramming necessary to deduce these types.  That is left for a
    // future C++11 implementation, where language makes such metaprograms
    // much simpler to write.

#if !defined(BSLSTL_ALLOCATOR_TRAITS_SUPPORTS_ALL_CPP11_DEDUCTIONS)
    typedef std::size_t     size_type;
    typedef std::ptrdiff_t  difference_type;
    typedef TYPE           *pointer;
    typedef const TYPE     *const_pointer;
#endif

    typedef bsl::integral_constant&lt;bool,
                                   PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT&gt;
                                        propagate_on_container_copy_assignment;

    typedef bsl::integral_constant&lt;bool, PROPAGATE_ON_CONTAINER_SWAP&gt;
                                                   propagate_on_container_swap;

    typedef bsl::integral_constant&lt;bool,
                                   PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
                                        propagate_on_container_move_assignment;

    template &lt;class OTHER_TYPE&gt;
    struct rebind
    {
        // This nested &#39;struct&#39; template, parameterized by some &#39;OTHER_TYPE&#39;,
        // provides a namespace for an &#39;other&#39; type alias, which is an
        // allocator type following the same template as this one but that
        // allocates elements of &#39;OTHER_TYPE&#39;.  Note that this allocator type
        // is convertible to and from &#39;other&#39; for any &#39;OTHER_TYPE&#39; including
        // &#39;void&#39;.

        typedef StdStatefulAllocator&lt;
                                 OTHER_TYPE,
                                 PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                 PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                 PROPAGATE_ON_CONTAINER_SWAP,
                                 PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt; other;
    };

    // CREATORS
    explicit StdStatefulAllocator(bslma::TestAllocator *testAllocator);
        // Create a &#39;StdStatefulAllocator&#39; object wrapping the specified
        // &#39;testAllocator&#39;.

    // StdStatefulAllocator(const StdStatefulAllocator&amp; original) = default;
        // Create a &#39;StdStatefulAllocator&#39; object.  Note that this object will
        // compare equal to the default constructed object, because this type
        // has no state.

    template &lt;class OTHER_TYPE&gt;
    StdStatefulAllocator(const StdStatefulAllocator&lt;
                            OTHER_TYPE,
                            PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                            PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                            PROPAGATE_ON_CONTAINER_SWAP,
                            PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; original);
        // Create a &#39;StdStatefulAllocator&#39; object wrapping the same test
        // allocator as the specified &#39;original&#39;.

    // ~StdStatefulAllocator() = default;
        // Destroy this object.

    // MANIPULATORS
    // StdStatefulAllocator&amp;
    // operator=(const StdStatefulAllocator&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.

    TYPE *allocate(bslma::Allocator::size_type numElements);
        // Allocate enough (properly aligned) space for the specified
        // &#39;numElements&#39; of type &#39;TYPE&#39;.

    void deallocate(TYPE *address, bslma::Allocator::size_type numElements);
        // Return memory previously at the specified &#39;address&#39; for
        // &#39;numElements&#39; back to this allocator.  The &#39;numElements&#39; argument is
        // ignored by this allocator type.  The behavior is undefined unless
        // &#39;address&#39; was allocated using this allocator object and has not
        // already been deallocated.

    // ACCESSORS
    bslma::TestAllocator *testAllocator() const;
        // Return the address of the test allocator wrapped by this object.

    StdStatefulAllocator select_on_container_copy_construction() const;
        // Return a copy of this object if the &#39;bool&#39; template parameter
        // &#39;PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION&#39; is true, and a copy
        // of a &#39;StdStatefulAllocator&#39; object wrapping the default allocator
        // otherwise.  The behavior is undefined unless the template parameter
        // &#39;PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION&#39; is true, or unless a
        // &#39;bslma::TestAllocator&#39; object has been installed as the default
        // allocator.

#if !defined(BSLSTL_ALLOCATOR_TRAITS_SUPPORTS_ALL_CPP11_DEDUCTIONS)
    size_type max_size() const;
        // Return the maximum number of elements of type &#39;TYPE&#39; that can be
        // allocated using this allocator in a single call to the &#39;allocate&#39;
        // method.  Note that there is no guarantee that attempts at allocating
        // less elements than the value returned by &#39;max_size&#39; will not throw.
        // *** DO NOT RELY ON THE CONTINUING PRESENT OF THIS METHOD ***
        // THIS METHOD WILL BE REMOVED ONCE &#39;bslstl::allocator_traits&#39; PROPERLY
        // DEDUCES AN IMPLEMENTATION FOR THIS FUNCTION WHEN NOT SUPPLIED BY THE
        // ALLOCATOR DIRECTLY.
#endif
};

// FREE OPERATORS
template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
bool operator==(const StdStatefulAllocator&lt;
                                 TYPE,
                                 PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                 PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                 PROPAGATE_ON_CONTAINER_SWAP,
                                 PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; lhs,
                const StdStatefulAllocator&lt;
                                 TYPE,
                                 PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                 PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                 PROPAGATE_ON_CONTAINER_SWAP,
                                 PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same underlying
    // test allocator, and &#39;false&#39; otherwise.

template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
bool operator!=(const StdStatefulAllocator&lt;
                                 TYPE,
                                 PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                 PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                 PROPAGATE_ON_CONTAINER_SWAP,
                                 PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; lhs,
                const StdStatefulAllocator&lt;
                                 TYPE,
                                 PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                 PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                 PROPAGATE_ON_CONTAINER_SWAP,
                                 PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have different underlying
    // test allocators, and &#39;false&#39; otherwise.


// ============================================================================
//                  INLINE AND TEMPLATE FUNCTION IMPLEMENTATIONS
// ============================================================================

                        // --------------------------
                        // class StdStatefulAllocator
                        // --------------------------

// CREATORS
template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
inline
StdStatefulAllocator&lt;TYPE,
                     PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                     PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                     PROPAGATE_ON_CONTAINER_SWAP,
                     PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;::
StdStatefulAllocator(bslma::TestAllocator *testAllocator)
: d_allocator_p(testAllocator)
{
    BSLS_ASSERT_SAFE(testAllocator);
}

// CREATORS
template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
template &lt;class OTHER_TYPE&gt;
inline
StdStatefulAllocator&lt;TYPE,
                     PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                     PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                     PROPAGATE_ON_CONTAINER_SWAP,
                     PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;::
StdStatefulAllocator(const StdStatefulAllocator&lt;
                             OTHER_TYPE,
                             PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                             PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                             PROPAGATE_ON_CONTAINER_SWAP,
                             PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; original)
: d_allocator_p(original.testAllocator())
{
}

// MANIPULATORS
template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
inline
TYPE *
StdStatefulAllocator&lt;TYPE,
                     PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                     PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                     PROPAGATE_ON_CONTAINER_SWAP,
                     PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;::allocate(
                                       bslma::Allocator::size_type numElements)
{
    return static_cast&lt;TYPE *&gt;(d_allocator_p-&gt;allocate(
                     bslma::Allocator::size_type(numElements * sizeof(TYPE))));
}

template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
inline
void StdStatefulAllocator&lt;TYPE,
                          PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                          PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                          PROPAGATE_ON_CONTAINER_SWAP,
                          PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;::
deallocate(TYPE *address, bslma::Allocator::size_type)
{
    d_allocator_p-&gt;deallocate(address);
}

template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
inline
bslma::TestAllocator *
StdStatefulAllocator&lt;TYPE,
                     PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                     PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                     PROPAGATE_ON_CONTAINER_SWAP,
                     PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;::
testAllocator() const
{
    return d_allocator_p;
}

template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
inline
StdStatefulAllocator&lt;TYPE,
                     PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                     PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                     PROPAGATE_ON_CONTAINER_SWAP,
                     PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
StdStatefulAllocator&lt;TYPE,
                     PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                     PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                     PROPAGATE_ON_CONTAINER_SWAP,
                     PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;::
select_on_container_copy_construction() const
{
    if (PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION) {
        return *this;                                                 // RETURN
    }

    // else

    return StdStatefulAllocator(dynamic_cast&lt;bslma::TestAllocator *&gt;(
                                          bslma::Default::defaultAllocator()));
}


template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
inline
typename StdStatefulAllocator&lt;
                             TYPE,
                             PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                             PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                             PROPAGATE_ON_CONTAINER_SWAP,
                             PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;::size_type
StdStatefulAllocator&lt;TYPE,
                     PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                     PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                     PROPAGATE_ON_CONTAINER_SWAP,
                     PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;::
max_size() const
{
    // Return the largest value, &#39;v&#39;, such that &#39;v * sizeof(T)&#39; fits in a
    // &#39;size_type&#39; (copied from bslstl_allocator).

    // We will calculate MAX_NUM_BYTES based on our knowledge that
    // &#39;bslma::Allocator::size_type&#39; is just an alias for &#39;std::size_t&#39;.  First
    // demonstrate that is true:

    BSLMF_ASSERT((bsl::is_same&lt;BloombergLP::bslma::Allocator::size_type,
                                                         std::size_t&gt;::value));

    static const std::size_t MAX_NUM_BYTES    = ~std::size_t(0);
    static const std::size_t MAX_NUM_ELEMENTS =
                                     std::size_t(MAX_NUM_BYTES) / sizeof(TYPE);
    return MAX_NUM_ELEMENTS;
}

}  // close package namespace

// FREE OPERATORS
template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
inline
bool bsltf::operator==(const StdStatefulAllocator&lt;
                                  TYPE,
                                  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                  PROPAGATE_ON_CONTAINER_SWAP,
                                  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; lhs,
                       const StdStatefulAllocator&lt;
                                  TYPE,
                                  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                  PROPAGATE_ON_CONTAINER_SWAP,
                                  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; rhs)
{
    return lhs.testAllocator() == rhs.testAllocator();
}

template &lt;class TYPE,
          bool  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
          bool  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
          bool  PROPAGATE_ON_CONTAINER_SWAP,
          bool  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;
inline
bool bsltf::operator!=(const StdStatefulAllocator&lt;
                                  TYPE,
                                  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                  PROPAGATE_ON_CONTAINER_SWAP,
                                  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; lhs,
                       const StdStatefulAllocator&lt;
                                  TYPE,
                                  PROPAGATE_ON_CONTAINER_COPY_CONSTRUCTION,
                                  PROPAGATE_ON_CONTAINER_COPY_ASSIGNMENT,
                                  PROPAGATE_ON_CONTAINER_SWAP,
                                  PROPAGATE_ON_CONTAINER_MOVE_ASSIGNMENT&gt;&amp; rhs)
{
    return lhs.testAllocator() != rhs.testAllocator();
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
