<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslalg_bidirectionalnode.h                                         -*-C++-*-
#ifndef INCLUDED_BSLALG_BIDIRECTIONALNODE
#define INCLUDED_BSLALG_BIDIRECTIONALNODE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a node holding a value in a doubly-linked list.
//
//@CLASSES:
//   bslalg::BidirectionalNode : Node holding a value in a linked list
//
//@SEE_ALSO: bslalg_bidirectionallink, bslalg_bidirectionallinklistutil,
//           bslalg_hashtableimputil
//
//@DESCRIPTION: This component provides a single POD-like class,
// &#39;bslalg::BidirectionalNode&#39;, used to represent a node in a doubly-linked
// (bidirectional) list holding a value of a parameterized type.  A
// &#39;bslalg::BidirectionalNode&#39; publicly derives from
// &#39;bslalg::BidirectionalLink&#39;, so it may be used with
// &#39;bslalg::BidirectionalLinkListUtil&#39; functions, and adds an attribute &#39;value&#39;
// of the template parameter type &#39;VALUE&#39;.  The following inheritance hierarchy
// diagram shows the classes involved and their methods:
//..
//                  ,-------------------------.
//                 ( bslalg::BidirectionalNode )
//                  `-------------------------&#39;
//                               |      value
//                               |      (all CREATORS unimplemented)
//                               V
//                  ,-------------------------.
//                 ( bslalg::BidirectionalLink )
//                  `-------------------------&#39;
//                                      ctor
//                                      dtor
//                                      setNextLink
//                                      setPreviousLink
//                                      nextLink
//                                      previousLink
//..
// This class is &quot;POD-like&quot; to facilitate efficient allocation and use in the
// context of container implementations.  In order to meet the essential
// requirements of a POD type, neither this &#39;class&#39; nor
// &#39;bslalg::BidirectionalLink&#39; define a constructor or destructor.  The
// manipulator, &#39;value&#39;, returns a modifiable reference to the stored object
// that may be constructed in-place, for example, by the appropriate
// &#39;bsl::allocator_traits&#39; methods.  While not strictly a POD, this class is a
// *standard-layout* type according to the C++11 standard.
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Creating and Using a List Template Class
///- - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to create a linked list template class called &#39;MyList&#39;.
//
// First, we create an iterator helper class, which will eventually be defined
// as a nested type within the &#39;MyList&#39; class.
//..
//                              // ===============
//                              // MyList_Iterator
//                              // ===============
//
//  template &lt;class PAYLOAD&gt;
//  class MyList_Iterator {
//      // This iterator is used to refer to positions within a list.
//
//      // PRIVATE TYPES
//      typedef bslalg::BidirectionalNode&lt;PAYLOAD&gt; Node;
//
//      // DATA
//      Node *d_node;    // Pointer to a node within a list.
//
//      // FRIENDS
//      template &lt;class OTHER_PAYLOAD&gt;
//      friend bool operator==(MyList_Iterator&lt;OTHER_PAYLOAD&gt;,
//                             MyList_Iterator&lt;OTHER_PAYLOAD&gt;);
//
//    public:
//      // CREATORS
//      MyList_Iterator() : d_node(0) {}
//      explicit
//      MyList_Iterator(Node *node) : d_node(node) {}
//      //! MyList_Iterator(const MyList_Iterator&amp; original) = default;
//      //! MyList_Iterator&amp; operator=(const MyList_Iterator&amp; other) = default;
//      //! ~MyList_Iterator() = default;
//
//      // MANIPULATORS
//      MyList_Iterator operator++();
//
//      // ACCESSORS
//      const PAYLOAD&amp; operator*() const { return d_node-&gt;value(); }
//  };
//
// ============================================================================
//                                FREE OPERATORS
// ----------------------------------------------------------------------------
//
//  template &lt;class PAYLOAD&gt;
//  bool operator==(MyList_Iterator&lt;PAYLOAD&gt; lhs,
//                  MyList_Iterator&lt;PAYLOAD&gt; rhs);
//
//  template &lt;class PAYLOAD&gt;
//  bool operator!=(MyList_Iterator&lt;PAYLOAD&gt; lhs,
//                  MyList_Iterator&lt;PAYLOAD&gt; rhs);
//..
// Then, we implement the functions for the iterator type.
//..
//                                  // ---------------
//                                  // MyList_Iterator
//                                  // ---------------
//
//  // MANIPULATORS
//  template &lt;class PAYLOAD&gt;
//  inline
//  MyList_Iterator&lt;PAYLOAD&gt; MyList_Iterator&lt;PAYLOAD&gt;::operator++()
//  {
//      d_node = static_cast&lt;Node *&gt;(d_node-&gt;nextLink());
//      return *this;
//  }
//
//  template &lt;class PAYLOAD&gt;
//  inline
//  bool operator==(MyList_Iterator&lt;PAYLOAD&gt; lhs,
//                  MyList_Iterator&lt;PAYLOAD&gt; rhs)
//  {
//      return lhs.d_node == rhs.d_node;
//  }
//
//  template &lt;class PAYLOAD&gt;
//  inline
//  bool operator!=(MyList_Iterator&lt;PAYLOAD&gt; lhs,
//                  MyList_Iterator&lt;PAYLOAD&gt; rhs)
//  {
//      return !(lhs == rhs);
//  }
//..
// Next, we define our &#39;MyList&#39; class, with &#39;MyList::Iterator&#39; being a public
// typedef of &#39;MyList_Iterator&#39;.  For brevity, we will omit much of te that a
// full, general-purpose list class would have.
//..
//                                  // ======
//                                  // MyList
//                                  // ======
//
//  template &lt;class PAYLOAD&gt;
//  class MyList {
//      // Doubly-linked list storing objects of type &#39;PAYLOAD&#39;.
//
//      // PRIVATE TYPES
//      typedef bslalg::BidirectionalNode&lt;PAYLOAD&gt; Node;
//
//    public:
//      // PUBLIC TYPES
//      typedef PAYLOAD                    ValueType;
//      typedef MyList_Iterator&lt;ValueType&gt; Iterator;
//
//      // DATA
//      Node             *d_begin;          // First node, if any, in the list.
//      Node             *d_end;            // Last node, if any, in the list.
//      bslma::Allocator *d_allocator_p;    // Allocator used for allocating
//                                          // and freeing nodes.
//
//    public:
//      // CREATORS
//      explicit
//      MyList(bslma::Allocator *basicAllocator = 0)
//      : d_begin(0)
//      , d_end(0)
//      , d_allocator_p(bslma::Default::allocator(basicAllocator))
//      {}
//
//      ~MyList();
//
//      // MANIPULATORS
//      Iterator begin();
//      Iterator end();
//      void pushBack(const ValueType&amp; value);
//      void popBack();
//  };
//..
// Then, we implement the functions for the &#39;MyList&#39; class:
//..
//                                  // ------
//                                  // MyList
//                                  // ------
//
//  // CREATORS
//  template &lt;class PAYLOAD&gt;
//  MyList&lt;PAYLOAD&gt;::~MyList()
//  {
//      for (Node *p = d_begin; p; ) {
//          Node *toDelete = p;
//          p = (Node *) p-&gt;nextLink();
//
//          bslalg::ScalarDestructionPrimitives::destroy(&amp;toDelete-&gt;value());
//          d_allocator_p-&gt;deleteObjectRaw(
//                         static_cast&lt;bslalg::BidirectionalLink *&gt;(toDelete));
//      }
//  }
//
//  // MANIPULATORS
//  template &lt;class PAYLOAD&gt;
//  inline
//  typename MyList&lt;PAYLOAD&gt;::Iterator MyList&lt;PAYLOAD&gt;::begin()
//  {
//      return Iterator(d_begin);
//  }
//
//  template &lt;class PAYLOAD&gt;
//  inline
//  typename MyList&lt;PAYLOAD&gt;::Iterator MyList&lt;PAYLOAD&gt;::end()
//  {
//      return Iterator(0);
//  }
//
//  template &lt;class PAYLOAD&gt;
//  void MyList&lt;PAYLOAD&gt;::pushBack(const PAYLOAD&amp; value)
//  {
//      Node *node = (Node *) d_allocator_p-&gt;allocate(sizeof(Node));
//      node-&gt;setNextLink(0);
//      node-&gt;setPreviousLink(d_end);
//      bslalg::ScalarPrimitives::copyConstruct(&amp;node-&gt;value(),
//                                              value,
//                                              d_allocator_p);
//
//      if (d_end) {
//          BSLS_ASSERT_SAFE(d_begin);
//
//          d_end-&gt;setNextLink(node);
//          d_end = node;
//      }
//      else {
//          BSLS_ASSERT_SAFE(0 == d_begin);
//
//          d_begin = d_end = node;
//      }
//  }
//
//  template &lt;class PAYLOAD&gt;
//  void MyList&lt;PAYLOAD&gt;::popBack()
//  {
//      BSLS_ASSERT_SAFE(d_begin &amp;&amp; d_end);
//
//      Node *toDelete = d_end;
//      d_end = (Node *) d_end-&gt;previousLink();
//
//      if (d_begin != toDelete) {
//          BSLS_ASSERT_SAFE(0 != d_end);
//          d_end-&gt;setNextLink(0);
//      }
//      else {
//          BSLS_ASSERT_SAFE(0 == d_end);
//          d_begin = 0;
//      }
//
//      bslalg::ScalarDestructionPrimitives::destroy(&amp;toDelete-&gt;value());
//      d_allocator_p-&gt;deleteObjectRaw(
//                         static_cast&lt;bslalg::BidirectionalLink *&gt;(toDelete));
//  }
//..
// Next, in &#39;main&#39;, we use our &#39;MyList&#39; class to store a list of ints:
//..
//  MyList&lt;int&gt; intList;
//..
// Then, we declare an array of ints to populate it with:
//..
//  int intArray[] = { 8, 2, 3, 5, 7, 2 };
//  enum { NUM_INTS = sizeof intArray / sizeof *intArray };
//..
// Now, we iterate, pushing ints to the list:
//..
//  for (const int *pInt = intArray; pInt &lt; intArray + NUM_INTS; ++pInt) {
//      intList.pushBack(*pInt);
//  }
//..
// Finally, we use our &#39;Iterator&#39; type to traverse the list and observe its
// values:
//..
//  MyList&lt;int&gt;::Iterator it = intList.begin();
//  assert(8 == *it);
//  assert(2 == *++it);
//  assert(3 == *++it);
//  assert(5 == *++it);
//  assert(7 == *++it);
//  assert(2 == *++it);
//  assert(intList.end() == ++it);
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

namespace BloombergLP {
namespace bslalg {

                        // =======================
                        // class BidirectionalNode
                        // =======================

template &lt;class VALUE&gt;
class BidirectionalNode : public bslalg::BidirectionalLink {
    // This POD-like &#39;class&#39; describes a node suitable for use in a
    // doubly-linked list of values of the template parameter type &#39;VALUE&#39;.
    // This class is a &quot;POD-like&quot; to facilitate efficient allocation and use in
    // the context of a container implementation.  In order to meet the
    // essential requirements of a POD type, this &#39;class&#39; does not define a
    // constructor or destructor.  The manipulator, &#39;value&#39;, returns a
    // modifiable reference to &#39;d_value&#39; so that it may be constructed in-place
    // by the appropriate &#39;bsl::allocator_traits&#39; object.

  public:
    // PUBLIC TYPES
    typedef VALUE ValueType;      // payload type

  private:
    // DATA
    VALUE d_value;  // payload value

    // The following creators are not defined because a &#39;BidirectionalNode&#39;
    // should never be constructed, destructed, or assigned.  The &#39;d_value&#39;
    // member should be separately constructed and destroyed using an
    // appropriate &#39;bsl::allocator_traits&#39; object.

  private:
    // NOT IMPLEMENTED
    BidirectionalNode();
    BidirectionalNode(const BidirectionalNode&amp;);
    BidirectionalNode&amp; operator=(const BidirectionalNode&amp;);
    ~BidirectionalNode();

  public:
    // MANIPULATORS
    ValueType&amp; value();
        // Return a reference providing modifiable access to the &#39;value&#39; held
        // by this object.

    // ACCESSORS
    const ValueType&amp; value() const;
        // Return a reference providing non-modifiable access to the &#39;value&#39;
        // held by this object.
};

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // -----------------------
                        // class BidirectionalNode
                        // -----------------------

template &lt;class VALUE&gt;
inline
VALUE&amp; BidirectionalNode&lt;VALUE&gt;::value()
{
    return d_value;
}

template &lt;class VALUE&gt;
inline
const VALUE&amp; BidirectionalNode&lt;VALUE&gt;::value() const
{
    return d_value;
}

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
