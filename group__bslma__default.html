<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_default Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_default<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide utilities to set/fetch the default and global allocators.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Default Allocator</a> </li>
<li>
<a href="#3.2">Global Allocator</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Usage 1 -- Basic Default Allocator Use</a> </li>
<li>
<a href="#3.3.2">Usage 2 -- Detecting Allocator Propagation Bugs</a> </li>
<li>
<a href="#3.3.3">Usage 3 -- Basic Global Allocator Use</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide utilities to set/fetch the default and global allocators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslma_1_1Default.html">bslma::Default</a> </td><td>namespace for default/global allocator management utilities  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__allocator.html" title="Provide a pure abstract interface for memory-allocation mechanisms.">Component bslma_allocator</a>, <a class="el" href="group__bslma__newdeleteallocator.html" title="Provide singleton new/delete adaptor to bslma::Allocator protocol.">Component bslma_newdeleteallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a set of utility functions that manage the addresses of two distinguished memory allocators: the <em>default</em> allocator and the <em>global</em> allocator. Each of these allocators are of type derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>. Note that for brevity, in the following we will generally refer to "the address of the default allocator" as simply "the default allocator" (and similarly for the global allocator). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The global allocator is intended to be used as the allocator for (global) singleton objects. In general, the default allocator is for all other memory allocations in contexts where an alternative allocator is not explicitly specified (or <em>cannot</em> be specified as, for example, when a compiler-generated temporary object of a type that requires an allocator is created). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Initially, both the default allocator and global allocator resolve to the address of the <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> singleton, i.e.: <br/>
<br/>
<div class="fragment"><pre class="fragment">  &amp;<a class="code" href="classbslma_1_1NewDeleteAllocator.html#a1d38f6dd5b0f1cf4744c4cf7bcb69da1">bslma::NewDeleteAllocator::singleton</a>()
</pre></div><br/>
<br/>
 Methods are provided to retrieve and set the two allocators independently. The following two subsections supply further details, in turn, on the methods that pertain to the default and global allocators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="default_allocator"></a> <a class="anchor" id="description.default_allocator"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Default Allocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Two methods provide access to the default allocator, <code><a class="el" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a></code> and <code><a class="el" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a></code> (the latter when called with no argument, or an explicit 0). When <code><a class="el" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a></code> is supplied with a non-0 argument, it simply returns that argument to the caller, (i.e., it acts as a pass-through). A (non-singleton) class that is designed to take advantage of an allocator will typically revert to the default allocator whenever a constructor is called without an allocator (yielding the default argument value of 0). The <code><a class="el" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a></code> method facilitates this behavior. See the usage examples below for an illustration of this technique. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default allocator can be set <em>prior</em> to a call to <code><a class="el" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a></code>, to <code><a class="el" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a></code> with no argument or an explicit 0, or to <code><a class="el" href="structbslma_1_1Default.html#ae8a10e6fa97abff8a1fca844ecf0e0aa">bslma::Default::lockDefaultAllocator</a></code>, by calling <code><a class="el" href="structbslma_1_1Default.html#af60e1ab6d61791aaadcbf91e159639f3">bslma::Default::setDefaultAllocator</a></code>. This method returns 0 on success and a non-zero value on failure. This method fails if the default allocator is "locked". The default allocator is initially unlocked. It is <em>explicitly</em> locked by calling <code><a class="el" href="structbslma_1_1Default.html#ae8a10e6fa97abff8a1fca844ecf0e0aa">bslma::Default::lockDefaultAllocator</a></code>. In addition, the default allocator is <em>implicitly</em> locked as a <em>side-effect</em> of calling <code><a class="el" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a></code>, or <code><a class="el" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a></code> with no argument or an explicit 0. Once locked, the default allocator cannot be unlocked. However, the <code><a class="el" href="structbslma_1_1Default.html#add7167d78cd52cc9f99ae8d98aa4360c">bslma::Default::setDefaultAllocatorRaw</a></code> method will unconditionally set the default allocator regardless of whether it is locked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A well-behaved program should call <code><a class="el" href="structbslma_1_1Default.html#af60e1ab6d61791aaadcbf91e159639f3">bslma::Default::setDefaultAllocator</a></code> <em>once</em>. It should be invoked in <code>main</code> before starting any threads, and be followed immediately by a call to 'bslmaDefault::lockDefaultAllocator. Note that <code><a class="el" href="structbslma_1_1Default.html#add7167d78cd52cc9f99ae8d98aa4360c">bslma::Default::setDefaultAllocatorRaw</a></code> is provided for <em>testing</em> <em>only</em>, and should typically <em>never</em> be used in a production environment. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>WARNING</em>: Note that the default allocator can become locked prior to entering <code>main</code> as a side-effect of initializing a file-scope static object. For example, the presence of a global <code>bsl::string</code> object in an executable will have this unintended consequence. Further note that this phenomenon can <em>vary</em> <em>across</em> <em>platforms</em>. In particular, linkers differ as to the aggressiveness with which they pull in file-scope static objects from the libraries that are on the link line. <em>AVOID</em> file-scope static objects that require runtime initialization, <em>especially</em> those that take an allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="global_allocator"></a> <a class="anchor" id="description.global_allocator"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Global Allocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The interface pertaining to the global allocator is comparatively much simpler, consisting of just two methods. The <code><a class="el" href="structbslma_1_1Default.html#af3987226527d8682872331e2b20d8004">bslma::Default::globalAllocator</a></code> method, when called with no argument (or an explicit 0), returns the global allocator currently in effect at the point of call. It has <em>no</em> side-effects. When supplied with a non-0 argument, <code><a class="el" href="structbslma_1_1Default.html#af3987226527d8682872331e2b20d8004">bslma::Default::globalAllocator</a></code> simply returns that argument to the caller (i.e., it acts as a pass-through similar to <code><a class="el" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a></code> when it is supplied with a non-0 argument). The global allocator may be set using the <code><a class="el" href="structbslma_1_1Default.html#a4eff7796b5cbda07b9bcb8a98691ca8b">bslma::Default::setGlobalAllocator</a></code> method. This method <em>always</em> succeeds. In that respect, the global allocator cannot become locked like the default allocator. <code><a class="el" href="structbslma_1_1Default.html#a4eff7796b5cbda07b9bcb8a98691ca8b">bslma::Default::setGlobalAllocator</a></code> returns the global allocator that is in effect upon entry to the function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that <code><a class="el" href="structbslma_1_1Default.html#a4eff7796b5cbda07b9bcb8a98691ca8b">bslma::Default::setGlobalAllocator</a></code> should be used with <em>extreme</em> <em>caution</em>. In particular, a well-behaved program should call this function at most once. If called, it should be invoked in <code>main</code> before starting any threads and before initializing singletons. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following sequence of usage examples illustrate recommended use of the default and global allocators. The examples employ the following simple memory allocator, <code>my_CountingAllocator</code>, that counts both the number of memory blocks that have been allocated, but not yet deallocated, and the cumulative number of blocks ever allocated. The two values are available through the accessors <code>numBlocksInUse</code> and <code>numBlocksTotal</code>, respectively. For actual allocations and deallocations, <code>my_CountingAllocator</code> uses global operators <code>new</code> and <code>delete</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_countingallocator.h</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bslma__allocator_8h.html" title="Provide a pure abstract interface for memory-allocation mechanisms.">bslma_allocator.h</a>&gt;</span>

  <span class="keyword">class </span>my_CountingAllocator : <span class="keyword">public</span> bslma::Allocator {
      <span class="comment">// This concrete allocator maintains: (1) a count of the number of</span>
      <span class="comment">// blocks allocated that have not yet been deallocated, and (2) a count</span>
      <span class="comment">// of the cumulative number of blocks ever allocated.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_numBlocksInUse;  <span class="comment">// number of blocks currently allocated</span>
      <span class="keywordtype">int</span> d_numBlocksTotal;  <span class="comment">// cumulative blocks ever requested</span>

      <span class="comment">// NOT IMPLEMENTED</span>
      my_CountingAllocator(<span class="keyword">const</span> my_CountingAllocator&amp;);
      my_CountingAllocator&amp; operator=(<span class="keyword">const</span> my_CountingAllocator&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_CountingAllocator();
          <span class="comment">// Create a counting allocator.</span>

      <span class="keyword">virtual</span> ~my_CountingAllocator();
          <span class="comment">// Destroy this counting allocator.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(size_type size);
          <span class="comment">// Return a newly allocated block of memory of (at least) the</span>
          <span class="comment">// specified positive &#39;size&#39; (bytes).  If &#39;size&#39; is 0, a null</span>
          <span class="comment">// pointer is returned with no effect.  The behavior is undefined</span>
          <span class="comment">// if &#39;size &lt; 0&#39;.  Note that the alignment of the address returned</span>
          <span class="comment">// is the maximum alignment for any fundamental type defined for</span>
          <span class="comment">// this platform.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
          <span class="comment">// Return the memory at the specified &#39;address&#39; back to this</span>
          <span class="comment">// allocator.  If &#39;address&#39; is 0, this function has no effect.  The</span>
          <span class="comment">// behavior is undefined if &#39;address&#39; was not allocated using this</span>
          <span class="comment">// allocator, or has already been deallocated.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> numBlocksInUse() <span class="keyword">const</span>;
          <span class="comment">// Return the number of blocks currently in use from this counting</span>
          <span class="comment">// allocator.</span>

      <span class="keywordtype">int</span> numBlocksTotal() <span class="keyword">const</span>;
          <span class="comment">// Return the cumulative number of blocks ever allocated using this</span>
          <span class="comment">// counting allocator.  Note that</span>
          <span class="comment">// numBlocksTotal() &gt;= numBlocksInUse().</span>
  };

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_CountingAllocator::my_CountingAllocator()
  : d_numBlocksInUse(0)
  , d_numBlocksTotal(0)
  {
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_CountingAllocator::numBlocksInUse()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_numBlocksInUse;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_CountingAllocator::numBlocksTotal()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_numBlocksTotal;
  }
</pre></div><br/>
<br/>
 The <code>virtual</code> methods of <code>my_CountingAllocator</code> are defined in the component <code>.cpp</code> <a href="file:">file:</a> <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_countingallocator.cpp</span>
<span class="preprocessor">  #include &lt;my_countingallocator.h&gt;</span>

  <span class="comment">// CREATORS</span>
  my_CountingAllocator::~my_CountingAllocator()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> *my_CountingAllocator::allocate(size_type size)
  {
      ++d_numBlocksInUse;
      ++d_numBlocksTotal;
      <a class="code" href="group__bslma__allocator.html#gac5363158ac0ed1690a6a09e3300c19e5">return ::operator new</a>(size);
  }

  <span class="keywordtype">void</span> my_CountingAllocator::deallocate(<span class="keywordtype">void</span> *address)
  {
      --d_numBlocksInUse;
      ::operator <span class="keyword">delete</span>(address);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_1_--_basic_default_allocator_use"></a> <a class="anchor" id="usage.usage_1_--_basic_default_allocator_use"></a> <a class="anchor" id="description.usage.usage_1_--_basic_default_allocator_use"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage 1 -- Basic Default Allocator Use: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This usage example illustrates the basics of class design that relate to proper use of the default allocator, and introduces the standard pattern to apply when setting (and <em>locking</em>) the default allocator. First we define a trivial class, <code>my_Id</code>, that uses an allocator. <code>my_Id</code> simply encapsulates a C-style (null-terminated) id string that is accessible through the <code>id</code> method. Note that each constructor is declared to take an <em>optional</em> <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> as its last argument. Also note that the expression: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(basicAllocator)
</pre></div><br/>
<br/>
 is used in applicable member initializers to propagate each constructor's allocator argument to the data members that require it (in this case, the object allocator that is held by each <code>my_Id</code> object). If <code>basicAllocator</code> is 0, the object is created using the default allocator. Otherwise, the explicitly supplied allocator is used: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_id.h</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bslma__allocator_8h.html" title="Provide a pure abstract interface for memory-allocation mechanisms.">bslma_allocator.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bslma__default_8h.html" title="Provide utilities to set/fetch the default and global allocators.">bslma_default.h</a>&gt;</span>

  <span class="keyword">class </span>my_Id {
      <span class="comment">// This is a trivial class solely intended to illustrate proper use</span>
      <span class="comment">// of the default allocator.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span>             *d_buffer_p;     <span class="comment">// allocated (*owned*)</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;  <span class="comment">// allocator (held, not owned)</span>

      <span class="comment">// NOT IMPLEMENTED (in order to reduce example size)</span>
      my_Id&amp; operator=(<span class="keyword">const</span> my_Id&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_Id(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an Id object having the specified &#39;id&#39;.  Optionally</span>
          <span class="comment">// specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

      my_Id(<span class="keyword">const</span> my_Id&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an Id object initialized to the value of the specified</span>
          <span class="comment">// &#39;original&#39; Id object.  Optionally specify a &#39;basicAllocator&#39;</span>
          <span class="comment">// used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      ~my_Id();
          <span class="comment">// Destroy this Id object.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *id() <span class="keyword">const</span>;
          <span class="comment">// Return the id of this Id object.</span>
  };

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_Id::my_Id(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
      d_buffer_p = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(std::strlen(<span class="keywordtype">id</span>) + 1);
      std::strcpy(d_buffer_p, <span class="keywordtype">id</span>);
  }

  <span class="keyword">inline</span>
  my_Id::my_Id(<span class="keyword">const</span> my_Id&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
      <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = original.id();
      d_buffer_p = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(std::strlen(<span class="keywordtype">id</span>) + 1);
      std::strcpy(d_buffer_p, <span class="keywordtype">id</span>);
  }

  <span class="keyword">inline</span>
  my_Id::~my_Id()
  {
      d_allocator_p-&gt;deallocate(d_buffer_p);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *my_Id::id()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_buffer_p;
  }
</pre></div><br/>
<br/>
 Next we set the default allocator to one of our counting allocator objects. Note that immediately after successfully setting it, we lock the default allocator, so that subsequent calls to <code><a class="el" href="structbslma_1_1Default.html#af60e1ab6d61791aaadcbf91e159639f3">bslma::Default::setDefaultAllocator</a></code> fail. (The default allocator can still be modified by calling <code><a class="el" href="structbslma_1_1Default.html#add7167d78cd52cc9f99ae8d98aa4360c">bslma::Default::setDefaultAllocatorRaw</a></code>, but calling that function in production code is anti-social. Our usage examples expressly do <em>not</em> call that method.) With the possible exception of test drivers, the default allocator should be set and locked early in <code>main</code> before threads are started and before objects are initialized: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> my_CountingAllocator defaultCountingAllocator;

  <span class="keywordtype">int</span> status =
              <a class="code" href="structbslma_1_1Default.html#af60e1ab6d61791aaadcbf91e159639f3">bslma::Default::setDefaultAllocator</a>(&amp;defaultCountingAllocator);
  assert(0 == status);
  <a class="code" href="structbslma_1_1Default.html#ae8a10e6fa97abff8a1fca844ecf0e0aa">bslma::Default::lockDefaultAllocator</a>();  <span class="comment">// subsequent calls to &quot;set&quot; fail</span>
  assert(<a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>() == &amp;defaultCountingAllocator);

  status = <a class="code" href="structbslma_1_1Default.html#af60e1ab6d61791aaadcbf91e159639f3">bslma::Default::setDefaultAllocator</a>(
                                    &amp;<a class="code" href="classbslma_1_1NewDeleteAllocator.html#a1d38f6dd5b0f1cf4744c4cf7bcb69da1">bslma::NewDeleteAllocator::singleton</a>());
  assert(0 != status);
  assert(<a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>() == &amp;defaultCountingAllocator);
</pre></div><br/>
<br/>
 In the following, we instantiate two objects of type <code>my_Id</code>. The first object, <code>idA</code>, is not supplied with an allocator, so it uses the default allocator. The second object, <code>idB</code>, is supplied with an object of type <code>my_CountingAllocator</code>. The assertions track the states of the two allocators at each point in the code fragment. In particular, note that the state of the default allocator does not change during the lifetime of <code>idB</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == defaultCountingAllocator.numBlocksInUse());
  assert(0 == defaultCountingAllocator.numBlocksTotal());
  {
      my_Id id(<span class="stringliteral">&quot;A&quot;</span>);
      assert(1 == defaultCountingAllocator.numBlocksInUse());
      assert(1 == defaultCountingAllocator.numBlocksTotal());
  }
  assert(0 == defaultCountingAllocator.numBlocksInUse());
  assert(1 == defaultCountingAllocator.numBlocksTotal());

  my_CountingAllocator objectCountingAllocator;
  assert(0 == objectCountingAllocator.numBlocksInUse());
  assert(0 == objectCountingAllocator.numBlocksTotal());
  {
      my_Id idB(<span class="stringliteral">&quot;B&quot;</span>, &amp;objectCountingAllocator);
      assert(1 == objectCountingAllocator.numBlocksInUse());
      assert(1 == objectCountingAllocator.numBlocksTotal());
      assert(0 == defaultCountingAllocator.numBlocksInUse());
      assert(1 == defaultCountingAllocator.numBlocksTotal());
  }
  assert(0 == objectCountingAllocator.numBlocksInUse());
  assert(1 == objectCountingAllocator.numBlocksTotal());
  assert(0 == defaultCountingAllocator.numBlocksInUse());
  assert(1 == defaultCountingAllocator.numBlocksTotal());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_2_--_detecting_allocator_propagation_bugs"></a> <a class="anchor" id="usage.usage_2_--_detecting_allocator_propagation_bugs"></a> <a class="anchor" id="description.usage.usage_2_--_detecting_allocator_propagation_bugs"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage 2 -- Detecting Allocator Propagation Bugs: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates how the default allocator is used to detect a very common programming error pertaining to allocator usage. First we define the trivial (but buggy) <code>my_IdPair</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_idpair.h</span>
<span class="preprocessor">  #include &lt;my_id.h&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bslma__default_8h.html" title="Provide utilities to set/fetch the default and global allocators.">bslma_default.h</a>&gt;</span>

  <span class="keyword">class </span>my_IdPair {
      <span class="comment">// This is a trivial class solely intended to help illustrate a common</span>
      <span class="comment">// programming error.  This class has two objects of type &#39;my_Id&#39;, only</span>
      <span class="comment">// one of which has the allocator correctly passed to it in the</span>
      <span class="comment">// definition of the constructor.</span>

      <span class="comment">// DATA</span>
      my_Id d_id;     <span class="comment">// primary id (allocating)</span>
      my_Id d_alias;  <span class="comment">// alias (allocating)</span>

      <span class="comment">// NOT IMPLEMENTED (in order to reduce example size)</span>
      my_IdPair(<span class="keyword">const</span> my_IdPair&amp;);
      my_IdPair&amp; operator=(<span class="keyword">const</span> my_IdPair&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_IdPair(<span class="keyword">const</span> <span class="keywordtype">char</span>       *<span class="keywordtype">id</span>,
                <span class="keyword">const</span> <span class="keywordtype">char</span>       *alias,
                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an Id pair having the specified &#39;id&#39; and &#39;alias&#39; ids.</span>
          <span class="comment">// Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

      ~my_IdPair();
          <span class="comment">// Destroy this Id pair.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *id() <span class="keyword">const</span>;
          <span class="comment">// Return the primary id of this Id pair.</span>

      <span class="keyword">const</span> <span class="keywordtype">char</span> *alias() <span class="keyword">const</span>;
          <span class="comment">// Return the alias of this Id pair.</span>
  };

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_IdPair::my_IdPair(<span class="keyword">const</span> <span class="keywordtype">char</span>       *<span class="keywordtype">id</span>,
                       <span class="keyword">const</span> <span class="keywordtype">char</span>       *alias,
                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_id(id, bslma::Default::allocator(basicAllocator))
  , d_alias(alias)  <span class="comment">// drat! (forgot to pass along &#39;basicAllocator&#39;)</span>
  {
  }

  <span class="keyword">inline</span>
  my_IdPair::~my_IdPair()
  {
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *my_IdPair::id()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_id.id();
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *my_IdPair::alias()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_alias.id();
  }
</pre></div><br/>
<br/>
 The definition of the <code>my_IdPair</code> constructor above intentionally includes a common programming error: The allocator in use by the object is not passed to <em>all</em> data members that require it. We will see shortly how this error is detected at runtime using the default allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, the default allocator is set and locked identically to what was done in usage example 1: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> my_CountingAllocator defaultCountingAllocator;

  <span class="keywordtype">int</span> status =
              <a class="code" href="structbslma_1_1Default.html#af60e1ab6d61791aaadcbf91e159639f3">bslma::Default::setDefaultAllocator</a>(&amp;defaultCountingAllocator);
  assert(0 == status);
  <a class="code" href="structbslma_1_1Default.html#ae8a10e6fa97abff8a1fca844ecf0e0aa">bslma::Default::lockDefaultAllocator</a>();
  assert(<a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>() == &amp;defaultCountingAllocator);
</pre></div><br/>
<br/>
 Now we instantiate an object of type <code>my_IdPair</code> without explicitly specifying an allocator. As a result, the object uses the default allocator. The assertions verify the expected changes in the state of the default allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == defaultCountingAllocator.numBlocksInUse());
  assert(0 == defaultCountingAllocator.numBlocksTotal());
  {
      my_IdPair idPair(<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>);
      assert(2 == defaultCountingAllocator.numBlocksInUse());
      assert(2 == defaultCountingAllocator.numBlocksTotal());
  }
  assert(0 == defaultCountingAllocator.numBlocksInUse());
  assert(2 == defaultCountingAllocator.numBlocksTotal());
</pre></div><br/>
<br/>
 Next we instantiate a second object of type <code>my_IdPair</code>, this time supplying it with a counting allocator object that is distinct from the default allocator. The assertions in the following code fragment that are commented out indicate the <em>expected</em> states of the allocators (i.e., in a bug-free implementation of <code>my_IdPair</code>) after the object has been constructed and again after it has been destroyed. However, due to the (intentional) bug in the constructor, the uncommented assertions reveal the <em>true</em> state of affairs: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_CountingAllocator objectCountingAllocator;
  assert(0 == objectCountingAllocator.numBlocksInUse());
  assert(0 == objectCountingAllocator.numBlocksTotal());
  {
      my_IdPair idPair(<span class="stringliteral">&quot;X&quot;</span>, <span class="stringliteral">&quot;Y&quot;</span>, &amp;objectCountingAllocator);
      <span class="comment">// assert(2 == objectCountingAllocator.numBlocksInUse());</span>
      <span class="comment">// assert(2 == objectCountingAllocator.numBlocksTotal());</span>
      <span class="comment">// assert(0 == defaultCountingAllocator.numBlocksInUse());</span>
      <span class="comment">// assert(2 == defaultCountingAllocator.numBlocksTotal());</span>
      assert(1 == objectCountingAllocator.numBlocksInUse());
      assert(1 == objectCountingAllocator.numBlocksTotal());
      assert(1 == defaultCountingAllocator.numBlocksInUse());
      assert(3 == defaultCountingAllocator.numBlocksTotal());
  }
  <span class="comment">// assert(0 == objectCountingAllocator.numBlocksInUse());</span>
  <span class="comment">// assert(2 == objectCountingAllocator.numBlocksTotal());</span>
  <span class="comment">// assert(0 == defaultCountingAllocator.numBlocksInUse());</span>
  <span class="comment">// assert(2 == defaultCountingAllocator.numBlocksTotal());</span>
  assert(0 == objectCountingAllocator.numBlocksInUse());
  assert(1 == objectCountingAllocator.numBlocksTotal());
  assert(0 == defaultCountingAllocator.numBlocksInUse());
  assert(3 == defaultCountingAllocator.numBlocksTotal());
</pre></div><br/>
<br/>
 Note that, although not necessary in the case of the simple <code>my_IdPair</code> class, the default allocator can be used (and typically <em>should</em> be used) within the body of a constructor, or any other member function, to allocate dynamic memory that is <em>temporarily</em> needed by the method (and, hence, not owned by the object after the method has returned). Thus, the invariant that must hold immediately after a method of an object returns is that the value returned by <code>defaultCountingAllocator.numBlocksInUse()</code> must be <em>identical</em> to what it was immediately prior to calling the method. Of course, note that the above invariant pertains to cases in <em>single</em>-threaded programs where the object allocator in use by the object is <em>distinct</em> from the default allocator. Also note that the value returned by <code>defaultCountingAllocator.numBlocksTotal()</code> <em>can</em> differ across function invocations (i.e., even in correct code). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_3_--_basic_global_allocator_use"></a> <a class="anchor" id="usage.usage_3_--_basic_global_allocator_use"></a> <a class="anchor" id="description.usage.usage_3_--_basic_global_allocator_use"></a> <a class="anchor" id="3.3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage 3 -- Basic Global Allocator Use: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next we define a simple singleton class, <code>my_Singleton</code>, that defaults to using the global allocator if one is not explicitly specified when the singleton object is initialized. Toward that end, note that in contrast to <code>my_Id</code>, the constructor for <code>my_Singleton</code> uses: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslma_1_1Default.html#af3987226527d8682872331e2b20d8004">bslma::Default::globalAllocator</a>(basicAllocator)
</pre></div><br/>
<br/>
 in its member initializer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_singleton.h</span>
  <span class="keyword">class </span>my_Singleton {
      <span class="comment">// This is a trivial singleton class solely intended to illustrate use</span>
      <span class="comment">// of the global allocator.</span>

      <span class="comment">// CLASS DATA</span>
      <span class="keyword">static</span> my_Singleton *d_singleton_p;  <span class="comment">// pointer to singleton object</span>

      <span class="comment">// DATA</span>
      my_Id d_id;  <span class="comment">// allocating</span>

      <span class="comment">// NOT IMPLEMENTED</span>
      my_Singleton(<span class="keyword">const</span> my_Singleton&amp;, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> * = 0);
      my_Singleton&amp; operator=(<span class="keyword">const</span> my_Singleton&amp;);

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE CREATORS</span>
      <span class="keyword">explicit</span> my_Singleton(<span class="keyword">const</span> <span class="keywordtype">char</span>       *<span class="keywordtype">id</span>,
                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a singleton having the specified &#39;id&#39;.  Optionally</span>
          <span class="comment">// specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed global allocator</span>
          <span class="comment">// is used.</span>

      ~my_Singleton();
          <span class="comment">// Destroy this singleton.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">void</span> initSingleton(<span class="keyword">const</span> <span class="keywordtype">char</span>       *<span class="keywordtype">id</span>,
                                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Initialize the singleton with the specified &#39;id&#39;.  Optionally</span>
          <span class="comment">// specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed global allocator</span>
          <span class="comment">// is used.</span>

      <span class="keyword">static</span> <span class="keyword">const</span> my_Singleton&amp; singleton();
          <span class="comment">// Return a reference to the non-modifiable singleton of this</span>
          <span class="comment">// class.  The behavior is undefined unless the singleton has been</span>
          <span class="comment">// initialized.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *id() <span class="keyword">const</span>;
          <span class="comment">// Return the id of this singleton.</span>
  };

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keyword">const</span> my_Singleton&amp; my_Singleton::singleton()
  {
      <span class="keywordflow">return</span> *d_singleton_p;
  }

  <span class="comment">// PRIVATE CREATORS</span>
  <span class="keyword">inline</span>
  my_Singleton::my_Singleton(<span class="keyword">const</span> <span class="keywordtype">char</span>       *<span class="keywordtype">id</span>,
                             <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_id(id, bslma::Default::globalAllocator(basicAllocator))
  {
  }

  <span class="keyword">inline</span>
  my_Singleton::~my_Singleton()
  {
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *my_Singleton::id()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_id.id();
  }
</pre></div><br/>
<br/>
 The following completes the definition of <code>my_Singleton</code> in the component <code>.cpp</code> <a href="file:">file:</a> <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_singleton.cpp</span>
<span class="preprocessor">  #include &lt;my_singleton.h&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bsls__alignedbuffer_8h.html" title="Provide raw buffers with user-specified size and alignment.">bsls_alignedbuffer.h</a>&gt;</span>

  my_Singleton *my_Singleton::d_singleton_p;

  <span class="comment">// CLASS METHODS</span>
  <span class="keywordtype">void</span> my_Singleton::initSingleton(<span class="keyword">const</span> <span class="keywordtype">char</span>       *<span class="keywordtype">id</span>,
                                   <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  {
      <span class="keyword">static</span> <a class="code" href="unionbsls_1_1AlignedBuffer.html">bsls::AlignedBuffer&lt;sizeof(my_Singleton)&gt;</a> singleton;
      d_singleton_p = <span class="keyword">new</span> (singleton.<a class="code" href="unionbsls_1_1AlignedBuffer.html#a46dbd83076424915a6cab625e2088ca4">buffer</a>()) my_Singleton(<span class="keywordtype">id</span>,
                                                            basicAllocator);
  }
</pre></div><br/>
<br/>
 In the following, the default and global allocators are set to distinct objects of type <code>my_CountingAllocator</code>. Note that the default allocator is set and locked identically to what was done in the previous two usage examples: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> my_CountingAllocator defaultCountingAllocator;

  <span class="keywordtype">int</span> status =
              <a class="code" href="structbslma_1_1Default.html#af60e1ab6d61791aaadcbf91e159639f3">bslma::Default::setDefaultAllocator</a>(&amp;defaultCountingAllocator);
  assert(0 == status);
  <a class="code" href="structbslma_1_1Default.html#ae8a10e6fa97abff8a1fca844ecf0e0aa">bslma::Default::lockDefaultAllocator</a>();
  assert(<a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>() == &amp;defaultCountingAllocator);

  <span class="keyword">static</span> my_CountingAllocator globalCountingAllocator;

  <a class="code" href="structbslma_1_1Default.html#a4eff7796b5cbda07b9bcb8a98691ca8b">bslma::Default::setGlobalAllocator</a>(&amp;globalCountingAllocator);
  assert(<a class="code" href="structbslma_1_1Default.html#af3987226527d8682872331e2b20d8004">bslma::Default::globalAllocator</a>() == &amp;globalCountingAllocator);
</pre></div><br/>
<br/>
 Finally, we initialize the singleton object. We explicitly specify the desired allocator in the call to <code>initSingleton</code> to make our intentions as clear as possible. Of course, because of the way the <code>my_Singleton</code> constructor was written, the result would have been the same if no allocator had been specified. As in previous examples, the states of the default and global allocators are asserted before and after initializing the singleton: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == defaultCountingAllocator.numBlocksInUse());
  assert(0 == defaultCountingAllocator.numBlocksTotal());
  assert(0 == globalCountingAllocator.numBlocksInUse());
  assert(0 == globalCountingAllocator.numBlocksTotal());

  my_Singleton::initSingleton(<span class="stringliteral">&quot;S&quot;</span>, <a class="code" href="structbslma_1_1Default.html#af3987226527d8682872331e2b20d8004">bslma::Default::globalAllocator</a>());

  assert(0 == defaultCountingAllocator.numBlocksInUse());
  assert(0 == defaultCountingAllocator.numBlocksTotal());
  assert(1 == globalCountingAllocator.numBlocksInUse());
  assert(1 == globalCountingAllocator.numBlocksTotal());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
