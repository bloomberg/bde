<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslalg_hashtableanchor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_hashtableanchor<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a type holding the constituent parts of a hash table.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Attributes</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a type holding the constituent parts of a hash table. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslalg_1_1HashTableAnchor.html">bslalg::HashTableAnchor</a> </td><td>(in-core) bucket-array and node list  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__hashtable.html" title="Provide a hash-container with support for duplicate values.">Component bslstl_hashtable</a>, <a class="el" href="group__bslalg__hashtableimputil.html" title="Provide algorithms for implementing a hash table.">Component bslalg_hashtableimputil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a single, complex-constrained <em>in</em>-*core* (value-semantic) attribute class, <code><a class="el" href="classbslalg_1_1HashTableAnchor.html">bslalg::HashTableAnchor</a></code>, that is used to hold (not own) the array of buckets and the list of nodes that form the key data elements of a hash-table. This class is typically used with the utilities provided in <code>bslstl_hashtableimputil</code>. Note that the decision to store nodes in a linked list (i.e., resolving collisions through chaining) is intended to facilitate a hash-table implementation meeting the requirements of a C++11 standard unordered container. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="attributes"></a> <a class="anchor" id="description.attributes"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Attributes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">  Name                Type                  Simple Constraints
  ------------------  -------------------   ------------------
  bucketArrayAddress  HashTableBucket *     none

  bucketArraySize     <span class="keywordtype">size_t</span>                none

  listRootAddress     BidirectionalLink *   none

  Complex Constraint
  -------------------------------------------------------------------------
  <span class="stringliteral">&#39;bucketArrayAddress&#39;</span> must refer to a contiguous sequence of valid
  <span class="stringliteral">&#39;bslalg::HashTableBucket&#39;</span> objects of at least the specified
  <span class="stringliteral">&#39;bucketArraySize&#39;</span> or both <span class="stringliteral">&#39;bucketArrayAddress&#39;</span> and <span class="stringliteral">&#39;bucketArraySize&#39;</span> must
  be 0.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code>listRootAddress</code>: address of the head of the linked list of nodes holding the elements contained in a hash table  </li>
<li>
<code>bucketArrayAddress</code>: address of the first element of the sequence of <code>HashTableBucket</code> objects, each of which refers to the first and last node (from <code>listRootAddress</code>) in that bucket  </li>
<li>
<code>bucketArraySize</code>: the number of (contiguous) buckets in the array of buckets at <code>bucketArrayAddress</code>  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to create a hash table that keeps track of pointers. Pointers can be added (<code>insert</code>ed) or removed (<code>erase</code>d) from the table, and the table will keep track, at any time, of whether a pointer is currently stored in the table using the <code>count</code> method. It will also be table to return the total number of objects stored in the table (the <code>size</code> method). Redundant <code>insert</code>s have no effect -- a given pointer may only be stored in the table once. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create our class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>PtrHashSet : <span class="keyword">public</span> bslalg::HashTableAnchor {
      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="structbsls_1_1Types.html#a2545b393332503ecc0bebec56249546a">bsls::Types::UintPtr</a>              UintPtr;
      <span class="keyword">typedef</span> <a class="code" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode&lt;void *&gt;</a> Node;
      <span class="keyword">typedef</span> <a class="code" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a>           Bucket;
      <span class="keyword">typedef</span> bslalg::BidirectionalLinkListUtil Util;

      <span class="comment">// DATA</span>
      <span class="keywordtype">double</span>            d_maxLoadFactor;
      <span class="keywordtype">unsigned</span>          d_numNodes;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;

      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> grow();
          <span class="comment">// Roughly double the number of buckets, such that the number of</span>
          <span class="comment">// buckets shall always be &#39;2^N - 1&#39;.</span>

      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keywordtype">bool</span> checkInvariants() <span class="keyword">const</span>;
          <span class="comment">// Perform sanity checks on this table, returning &#39;true&#39; if all the</span>
          <span class="comment">// tests pass and &#39;false&#39; otherwise.  Note that many of the checks</span>
          <span class="comment">// are done with the &#39;ASSERTV&#39; macro and will cause messages to be</span>
          <span class="comment">// written to the console.</span>

      <span class="keywordtype">bool</span> find(Node **node, Bucket **bucket, <span class="keyword">const</span> <span class="keywordtype">void</span> *ptr) <span class="keyword">const</span>;
          <span class="comment">// If the specified value &#39;ptr&#39; is stored in this table, return</span>
          <span class="comment">// pointers to its node and bucket in the specified &#39;node&#39; and</span>
          <span class="comment">// &#39;bucket&#39;.  If it is not in this table, return the bucket it</span>
          <span class="comment">// should be in, and a pointer to the first node, if any, in that</span>
          <span class="comment">// bucket.  If the bucket is empty, return with</span>
          <span class="comment">// &#39;*node == listRootAddress()&#39;.  Return &#39;true&#39; if &#39;ptr&#39; was found</span>
          <span class="comment">// in the table and &#39;false&#39; otherwise.  Note that it is permissible</span>
          <span class="comment">// to pass 0 to &#39;node&#39; and / or &#39;bucket&#39;, in which case these</span>
          <span class="comment">// arguments are ignored.</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      PtrHashSet(<span class="keyword">const</span> PtrHashSet&amp;, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *);
      PtrHashSet&amp; operator=(<span class="keyword">const</span> PtrHashSet&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span>
      PtrHashSet(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0);
          <span class="comment">// Create a &#39;PtrHashSet&#39;, using the specified &#39;allocator&#39;.  If no</span>
          <span class="comment">// allocator is specified, use the default allocator.</span>

      ~PtrHashSet();
          <span class="comment">// Destroy this &#39;PtrHashSet&#39;, freeing all its memory.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">bool</span> insert(<span class="keywordtype">void</span> *ptr);
          <span class="comment">// If the specfied &#39;ptr&#39; is not in this hash table, add it,</span>
          <span class="comment">// returning &#39;true&#39;.  If it is already in the table, return &#39;false&#39;</span>
          <span class="comment">// with no action taken.</span>

      <span class="keywordtype">bool</span> erase(<span class="keywordtype">void</span> *ptr);
          <span class="comment">// If the specfied &#39;ptr&#39; is in this hash table, remove it,</span>
          <span class="comment">// returning &#39;true&#39;.  If it is not found in the table, return</span>
          <span class="comment">// &#39;false&#39; with no action taken.</span>

      <span class="comment">// ACCESSORS</span>
      native_std::size_t count(<span class="keywordtype">void</span> *ptr) <span class="keyword">const</span>;
          <span class="comment">// Return 1 if the specified value &#39;ptr&#39; is in this table and 0</span>
          <span class="comment">// otherwise.</span>

      native_std::size_t size() <span class="keyword">const</span>;
          <span class="comment">// Return the number of discrete values that are stored in this</span>
          <span class="comment">// table.</span>
  };

  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keywordtype">void</span> PtrHashSet::grow()
  {
      <span class="comment">// &#39;bucketArraySize&#39; will always be &#39;2^N - 1&#39;, so that when pointers</span>
      <span class="comment">// are aligned by some 2^N they&#39;re likely to be relatively prime.</span>

      native_std::size_t newBucketArraySize = bucketArraySize() * 2 + 1;
      native_std::size_t newBucketArraySizeInBytes =
                                         newBucketArraySize * <span class="keyword">sizeof</span>(Bucket);
      memset(bucketArrayAddress(), 0x5a, size() * <span class="keyword">sizeof</span>(Bucket));
      d_allocator_p-&gt;deallocate(bucketArrayAddress());
      setBucketArrayAddressAndSize(
               (Bucket *) d_allocator_p-&gt;allocate(newBucketArraySizeInBytes),
               newBucketArraySize);
      memset(bucketArrayAddress(), 0, newBucketArraySizeInBytes);
      Node *newListRootAddress = 0;

      <span class="keywordtype">unsigned</span> numNodes = 0;
      <span class="keywordflow">for</span> (Node *node = (Node *) listRootAddress(); node; ++numNodes) {
          Node *rippedOut = node;
          node = (Node *) node-&gt;nextLink();

          native_std::size_t index =
                            (UintPtr) rippedOut-&gt;value() % bucketArraySize();
          Bucket&amp; bucket = bucketArrayAddress()[index];
          <span class="keywordflow">if</span> (bucket.first()) {
              <span class="keywordflow">if</span> (0 == bucket.first()-&gt;previousLink()) {
                  newListRootAddress = rippedOut;
              }
              Util::insertLinkBeforeTarget(rippedOut, bucket.first());
              bucket.setFirst(rippedOut);
          }
          <span class="keywordflow">else</span> {
              Util::insertLinkBeforeTarget(rippedOut,
                                           newListRootAddress);
              newListRootAddress = rippedOut;
              bucket.setFirstAndLast(rippedOut, rippedOut);
          }
      }
      assert(size() == numNodes);

      setListRootAddress(newListRootAddress);

      checkInvariants();
  }

  <span class="comment">// PRIVATE ACCESSORS</span>
  <span class="keywordtype">bool</span> PtrHashSet::checkInvariants()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordtype">bool</span> ok;

      <span class="keywordtype">unsigned</span> numNodes = 0;
      Node *prev = 0;
      <span class="keywordflow">for</span> (Node *node = (Node *) listRootAddress(); node;
                             prev = node, node = (Node *) node-&gt;nextLink()) {
          ok = node-&gt;previousLink() == prev;
          assert(ok &amp;&amp; <span class="stringliteral">&quot;node-&gt;previousLink() == prev&quot;</span>);
          <span class="keywordflow">if</span> (!ok) <span class="keywordflow">return</span> <span class="keyword">false</span>;                                    <span class="comment">// RETURN</span>
          ++numNodes;
      }
      ok = size() == numNodes;
      assert(ok &amp;&amp; <span class="stringliteral">&quot;size() == numNodes&quot;</span>);
      <span class="keywordflow">if</span> (!ok) <span class="keywordflow">return</span> <span class="keyword">false</span>;                                        <span class="comment">// RETURN</span>

      numNodes = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; bucketArraySize(); ++i) {
          Bucket&amp; bucket = bucketArrayAddress()[i];
          <span class="keywordflow">if</span> (bucket.first()) {
              ++numNodes;
              <span class="keywordflow">for</span> (Node *node = (Node *) bucket.first();
                                bucket.last() != node;
                                          node = (Node *) node-&gt;nextLink()) {
                  ++numNodes;
              }
          }
          <span class="keywordflow">else</span> {
              ok = !bucket.last();
              assert(ok &amp;&amp; <span class="stringliteral">&quot;!bucket.last()&quot;</span>);
              <span class="keywordflow">if</span> (!ok) <span class="keywordflow">return</span> <span class="keyword">false</span>;                                <span class="comment">// RETURN</span>
          }
      }
      ok = size() == numNodes;
      assert(ok &amp;&amp; <span class="stringliteral">&quot;size() == numNodes&quot;</span>);

      <span class="keywordflow">return</span> ok;
  }

  <span class="keywordtype">bool</span> PtrHashSet::find(Node **node, Bucket **bucket, <span class="keyword">const</span> <span class="keywordtype">void</span> *ptr)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      Node   *dummyNodePtr;
      Bucket *dummyBucketPtr;
      <span class="keywordflow">if</span> (!node  ) node   = &amp;dummyNodePtr;
      <span class="keywordflow">if</span> (!bucket) bucket = &amp;dummyBucketPtr;

      Node *&amp; nodePtrRef = *node;
      <span class="keywordtype">unsigned</span> index = (UintPtr) ptr % bucketArraySize();
      Bucket&amp; bucketRef = bucketArrayAddress()[index];
      *bucket = &amp;bucketRef;
      <span class="keywordflow">if</span> (bucketRef.first()) {
          Node *begin      = (Node *) bucketRef.first();
          Node * <span class="keyword">const</span> end = (Node *) bucketRef.last()-&gt;nextLink();
          <span class="keywordflow">for</span> (Node *n = begin; end != n; n = (Node *) n-&gt;nextLink()) {
              <span class="keywordflow">if</span> (n-&gt;value() == ptr) {
                  <span class="comment">// found</span>

                  nodePtrRef = n;
                  <span class="keywordflow">return</span> <span class="keyword">true</span>;                                      <span class="comment">// RETURN</span>
              }
          }
          <span class="comment">// not found</span>

          nodePtrRef = begin;
          <span class="keywordflow">return</span> <span class="keyword">false</span>;                                             <span class="comment">// RETURN</span>
      }
      <span class="comment">// empty bucket</span>

      nodePtrRef = (Node *) listRootAddress();
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }

  <span class="comment">// CREATORS</span>
  PtrHashSet::PtrHashSet(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
  : HashTableAnchor(0, 0, 0)
  , d_maxLoadFactor(0.4)
  , d_numNodes(0)
  {
      <span class="keyword">enum</span> { NUM_BUCKETS = 3 };

      d_allocator_p = <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(allocator);
      native_std::size_t bucketArraySizeInBytes =
                                                NUM_BUCKETS * <span class="keyword">sizeof</span>(Bucket);
      setBucketArrayAddressAndSize(
                  (Bucket *) d_allocator_p-&gt;allocate(bucketArraySizeInBytes),
                  NUM_BUCKETS);
      memset(bucketArrayAddress(), 0, bucketArraySizeInBytes);
  }

  PtrHashSet::~PtrHashSet()
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(checkInvariants());

      <span class="keywordflow">for</span> (Node *node = (Node *) listRootAddress(); node; ) {
          Node *toDelete = node;
          node = (Node *) node-&gt;nextLink();

          memset(toDelete, 0x5a, <span class="keyword">sizeof</span>(*toDelete));
          d_allocator_p-&gt;deallocate(toDelete);
      }

      d_allocator_p-&gt;deallocate(bucketArrayAddress());
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">bool</span> PtrHashSet::erase(<span class="keywordtype">void</span> *ptr)
  {
      Bucket *bucket;
      Node   *node;

      <span class="keywordflow">if</span> (!find(&amp;node, &amp;bucket, ptr)) {
          <span class="keywordflow">return</span> <span class="keyword">false</span>;                                             <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">if</span> (bucket-&gt;first() == node) {
          <span class="keywordflow">if</span> (bucket-&gt;last() == node) {
              bucket-&gt;reset();
          }
          <span class="keywordflow">else</span> {
              bucket-&gt;setFirst(node-&gt;nextLink());
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bucket-&gt;last() == node) {
          bucket-&gt;setLast(node-&gt;previousLink());
      }

      --d_numNodes;
      Util::unlink(node);

      d_allocator_p-&gt;deallocate(node);

      checkInvariants();

      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }

  <span class="keywordtype">bool</span> PtrHashSet::insert(<span class="keywordtype">void</span> *ptr)
  {
      Bucket *bucket;
      Node *insertionPoint;

      <span class="keywordflow">if</span> (find(&amp;insertionPoint, &amp;bucket, ptr)) {
          <span class="comment">// Already in set, do nothing.</span>

          <span class="keywordflow">return</span> <span class="keyword">false</span>;                                             <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">if</span> (bucketArraySize() * d_maxLoadFactor &lt; d_numNodes + 1) {
          grow();
          <span class="keywordtype">bool</span> found = find(&amp;insertionPoint, &amp;bucket, ptr);
          <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(!found);
      }

      ++d_numNodes;
      Node *node = (Node *) d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span>(Node));

      Util::insertLinkBeforeTarget(node, insertionPoint);
      node-&gt;value() = ptr;
      <span class="keywordflow">if</span> (listRootAddress() == insertionPoint) {
          <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(0 == node-&gt;previousLink());
          setListRootAddress(node);
      }

      <span class="keywordflow">if</span> (bucket-&gt;first()) {
          <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(bucket-&gt;first() == insertionPoint);

          bucket-&gt;setFirst(node);
      }
      <span class="keywordflow">else</span> {
          <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(!bucket-&gt;last());

          bucket-&gt;setFirstAndLast(node, node);
      }

      assert(count(ptr));

      checkInvariants();

      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }

  <span class="comment">// ACCESSORS</span>
  native_std::size_t PtrHashSet::count(<span class="keywordtype">void</span> *ptr)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> find(0, 0, ptr);
  }

  native_std::size_t PtrHashSet::size()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_numNodes;
  }
</pre></div><br/>
<br/>
 Then, in <code>main</code>, we create a test allocator for use in this example to ensure that no memory is leaked: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta(<span class="stringliteral">&quot;test&quot;</span>, veryVeryVeryVerbose);
</pre></div><br/>
<br/>
 Next, we declare our table using that allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  PtrHashSet phs(&amp;ta);
</pre></div><br/>
<br/>
 Then, we create an area of memory from which our pointers will come: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { SEGMENT_LENGTH = 1000 };
  <span class="keywordtype">char</span> *pc = (<span class="keywordtype">char</span> *) ta.<a class="code" href="classbslma_1_1TestAllocator.html#adadeba443e1ea37730a9cf936a600e56">allocate</a>(SEGMENT_LENGTH);
</pre></div><br/>
<br/>
 Next, we iterate through the length of the segment, insert those pointers for which <code>ptr - pc == N * 7</code> is true. We keep a count of the number of items we insert into the table in the variable <code>sevens</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> sevens = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; SEGMENT_LENGTH; i += 7) {
      ++sevens;
      <span class="keywordtype">bool</span> status = phs.insert(&amp;pc[i]);
      assert(status);
  }
</pre></div><br/>
<br/>
 Then, we verify the number of objects we've placed in the table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(phs.size() == sevens);
</pre></div><br/>
<br/>
 Next, we iterate through ALL pointers in the <code>pc</code> array, using the <code>count</code> method to verify that the ones we expect are in the table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; SEGMENT_LENGTH; ++i) {
      assert(phs.count(&amp;pc[i]) == (0 == i % 7));
  }
</pre></div><br/>
<br/>
 Then, we iterate, deleting all elements from the table for which <code>ptr - pc == 3 * N</code> is true. We keep a count of the number of elements which were in the table which we delete in the variable <code>killed</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> killed = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; SEGMENT_LENGTH; i += 3) {
      <span class="keyword">const</span> <span class="keywordtype">bool</span> deleted = phs.erase(&amp;pc[i]);
      assert(deleted == (0 == i % 7));
      killed += deleted;
  }
</pre></div><br/>
<br/>
 Next, we verify the number of remaining elements in the table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(killed &lt; sevens);
  assert(phs.size() == sevens - killed);
</pre></div><br/>
<br/>
 Then, in verbose mode we print our tallies: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (verbose) {
      printf(<span class="stringliteral">&quot;sevens = %u, killed = %u, phs.size() = %u\n&quot;</span>, sevens,
                                          killed, (<span class="keywordtype">unsigned</span>) phs.size());
  }
</pre></div><br/>
<br/>
 Now, we iterate through every element of the <code>pc</code> array, verifying that the surviving elements are exactly those for which <code>ptr - pc</code> was divisible by 7 and not by 3: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; SEGMENT_LENGTH; ++i) {
      <span class="keyword">const</span> <span class="keywordtype">bool</span> present = phs.count(&amp;pc[i]);
      assert(present == ((0 == i % 7) &amp;&amp; (0 != i % 3)));
  }
</pre></div><br/>
<br/>
 Finally, we clean up our <code>pc</code> array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  ta.<a class="code" href="classbslma_1_1TestAllocator.html#aa3d86f105cc1a797cfa5ad9e2bbf6825">deallocate</a>(pc);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
