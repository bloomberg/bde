<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// ball_recordbuffer.h                                                -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALL_RECORDBUFFER
#define INCLUDED_BALL_RECORDBUFFER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a protocol for managing log record handles.
//
//@CLASSES:
//  ball::RecordBuffer: protocol class for managing log record handles
//
//@SEE_ALSO: ball_record, ball_fixedsizerecordbuffer
//
//@DESCRIPTION: This component defines the base-level protocol,
// &#39;ball::RecordBuffer&#39;, for managing record handles (specifically instances of
// &#39;bsl::shared_ptr&lt;ball::Record&gt;&#39;) in a double-ended buffer.  In particular,
// the &#39;ball::RecordBuffer&#39; protocol class provides abstract methods to push a
// record handle into either end (back or front) of the buffer (&#39;pushBack&#39; and
// &#39;pushFront&#39;), to obtain read-only access to the log record positioned at
// either end (&#39;back&#39; and &#39;front&#39;) and to remove the record positioned at
// either end (&#39;popBack&#39; and &#39;popFront&#39;).  Note that the classes implementing
// this protocol are supposed to manage record handles and not the records
// themselves, specifically, they should not allocate the memory for records
// and should not explicitly destroy records (a record is destroyed
// automatically when the reference count associated with its handle becomes
// zero).  The push methods (&#39;pushBack&#39; and &#39;pushFront&#39;) are not guaranteed to
// succeed.  Concrete implementations implementations are permitted to remove
// records from the buffer in order to attempt to accommodate a push request
// (which implies that, after a successful call to a push method, &#39;length&#39; is
// not guaranteed to be more than one, and an unsuccessful call to a push
// method is permitted to leave the buffer empty).
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Defining a Concrete &#39;RecordBuffer&#39; Type
///- - - - - - - - - - - - - - - - - -- - - - - - - -
// This example shows the definition of a simple concrete record buffer.  The
// requisite steps are:
//
//: 1 Define a concrete class derived from &#39;ball::RecordBuffer&#39;.
//: 2 Implement all pure virtual functions.
//
// The concrete thread-safe &#39;my_RecordBuffer&#39; class in this example implements
// the &#39;ball::RecordBuffer&#39; protocol by delegating to an instance of
// &#39;bsl::vector&lt;bsl::shared_ptr&lt;ball::Record&gt; &gt; &#39;:
//..
//  // my_recordbuffer.h
//
//  class my_RecordBuffer : public ball::RecordBuffer {
//      // This class provides a thread-safe implementation of the
//      // &#39;ball::RecordBuffer&#39; protocol.  This implementation employs a vector
//      // to hold an unlimited number of record handles.
//
//      mutable bslmt::RecursiveMutex d_mutex;
//                                   // thread safety provider (see
//                                   // the implementation notes for the
//                                   // justification for using recursive mutex
//                                   // rather a plain mutex)
//
//      bsl::vector&lt;bsl::shared_ptr&lt;ball::Record&gt; &gt;
//                         d_buffer; // buffer of record handles
//
//    private:
//      // NOT IMPLEMENTED
//      my_RecordBuffer(const my_RecordBuffer&amp;);
//      my_RecordBuffer&amp; operator=(const my_RecordBuffer&amp;);
//
//    public:
//      // CREATORS
//      my_RecordBuffer();
//      virtual ~my_RecordBuffer();
//
//      // MANIPULATORS
//      virtual void beginSequence();
//      virtual void endSequence();
//      virtual void popBack();
//      virtual void popFront();
//      virtual int pushBack(const bsl::shared_ptr&lt;ball::Record&gt;&amp; handle);
//      virtual int pushFront(
//                   const bsl::shared_ptr&lt;ball::Record&gt;&amp; handle);
//      virtual void removeAll();
//
//      // ACCESSORS
//      virtual const bsl::shared_ptr&lt;ball::Record&gt;&amp; back() const;
//      virtual const bsl::shared_ptr&lt;ball::Record&gt;&amp; front() const;
//      virtual int length() const;
//  };
//..
//
///Implementation Notes
/// - - - - - - - - - -
// Recursive mutex (rather than plain mutex) is chosen to provide thread
// safety.  This allows the manipulation of the record buffer between the call
// to &#39;beginSequence&#39; and &#39;endSequence&#39;.  If we had used plain mutex, calling
// any method on the record buffer between the calls to &#39;beginSequence&#39; and
// &#39;endSequence&#39; would result in a deadlock.
//..
//  // CREATORS
//  inline
//  my_RecordBuffer::my_RecordBuffer() { }
//
//  // MANIPULATORS
//  inline
//  void my_RecordBuffer::beginSequence()
//  {
//      d_mutex.lock();
//  }
//
//  inline
//  void my_RecordBuffer::endSequence()
//  {
//      d_mutex.unlock();
//  }
//
//  inline
//  void my_RecordBuffer::popBack()
//  {
//      bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
//      d_buffer.pop_back();
//  }
//
//  inline
//  void my_RecordBuffer::popFront()
//  {
//      bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
//      d_buffer.erase(d_buffer.begin());
//  }
//
//  inline
//  int my_RecordBuffer::pushBack(
//                       const bsl::shared_ptr&lt;ball::Record&gt;&amp; handle)
//  {
//      bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
//      d_buffer.push_back(handle);
//      return 0;
//  }
//
//  inline
//  int my_RecordBuffer::pushFront(
//                       const bsl::shared_ptr&lt;ball::Record&gt;&amp; handle)
//  {
//      bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
//      d_buffer.insert(d_buffer.begin(), handle);
//      return 0;
//  }
//
//  inline
//  void my_RecordBuffer::removeAll()
//  {
//      bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
//      d_buffer.clear();
//  }
//
//  // ACCESSORS
//  inline
//  const bsl::shared_ptr&lt;ball::Record&gt;&amp; my_RecordBuffer::back() const
//  {
//      bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
//      return d_buffer.back();
//  }
//
//  inline
//  const bsl::shared_ptr&lt;ball::Record&gt;&amp; my_RecordBuffer::front() const
//  {
//      bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
//      return d_buffer.front();
//  }
//
//  inline
//  int my_RecordBuffer::length() const
//  {
//      bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt; guard(&amp;d_mutex);
//      return d_buffer.size();
//  }
//..
// Note that we always implement a virtual destructor (non-inline) in the .cpp
// file (to indicate the *unique* location of the class&#39;s virtual table):
//..
//  // my_recordbuffer.cpp
//
//  my_RecordBuffer::~my_RecordBuffer() { }
//..
//
///Example 2: Using a &#39;ball::RecordBuffer&#39;
///- - - - - - - - - - - - - - - - - - - -
// This example demonstrates working with the &#39;ball::RecordBuffer&#39; protocol.
// We implement a function &#39;processRecord&#39; that processes a specified record
// handle based on its severity.
//..
//  void processRecord(const bsl::shared_ptr&lt;ball::Record&gt;&amp; handle,
//                           ball::RecordBuffer&amp;            buffer)
//      // Process the specified &#39;handle&#39;, based on it&#39;s severity.  Records
//      // (encapsulated in &#39;handle&#39;) with severity equal to or *greater*
//      // severe than (i.e., with *numerical* value *less* than or equal to)
//      // &#39;ball::Severity::e_WARN&#39; are pushed back into the specified
//      // &#39;buffer&#39;.  Records with a severity equal to or more severe than
//      // &#39;ball::Severity::e_ERROR&#39; are (in addition to get pushed back
//      // into the &#39;buffer&#39;) printed to &#39;stdout&#39;, and then each record
//      // contained in &#39;buffer&#39; is in turn printed to &#39;stdout&#39; and then
//      // removed from &#39;buffer&#39;.  That is, any severity level equal to or
//      // more severe than &#39;ball::Severity::e_ERROR&#39; triggers a trace-back
//      // of all records accumulated in the buffer and flushes the buffer.
//      // The function is thread safe and thus allows multiple concurrent
//      // invocations of this function with the same record buffer.
//
//  {
//      int severity = handle-&gt;fixedFields().severity();
//
//      if (ball::Severity::e_WARN &gt;= severity) {
//          buffer.pushBack(handle);
//      }
//      if (ball::Severity::e_ERROR &gt;= severity) {
//          bsl::cout &lt;&lt; *handle;
//          buffer.beginSequence(); // lock the buffer before traversing
//          int length = buffer.length();
//          while (length--) {
//              bsl::cout &lt;&lt; buffer.back();
//              buffer.popBack();
//          }
//          buffer.endSequence();   // unlock the buffer after traversing
//      }
//
//  }
//..


#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

namespace BloombergLP {

namespace ball {

class Record;

                           // ==================
                           // class RecordBuffer
                           // ==================

class RecordBuffer {
    // Provide a protocol (or pure interface) for managing record handles
    // (specifically instances of &#39;bsl::shared_ptr&lt;Record&gt;&#39;).

  public:
    // CREATORS
    virtual ~RecordBuffer();
        // Remove all record handles stored in this record buffer and destroy
        // this record buffer.

    // MANIPULATORS
    virtual void popBack() = 0;
        // Remove from this record buffer the record handle positioned at the
        // back of the buffer.  The behavior is undefined unless
        // &#39;0 &lt; length()&#39;.

    virtual void popFront() = 0;
        // Remove from this record buffer the record handle positioned at the
        // front of the buffer.  The behavior is undefined unless
        // &#39;0 &lt; length()&#39;.

    virtual int pushBack(const bsl::shared_ptr&lt;Record&gt;&amp; handle) = 0;
        // Append the specified &#39;handle&#39; to the back of this record buffer.
        // Return 0 on success, and a non-zero value otherwise.  Note that
        // concrete implementations are permitted to remove records from the
        // buffer in order to attempt to accommodate a &#39;pushBack&#39; request
        // (which implies that, after a successful call to &#39;pushBack&#39;, &#39;length&#39;
        // is not guaranteed to be more than one, and an unsuccessful call to
        // &#39;pushBack&#39; is permitted to leave the buffer empty).

    virtual int pushFront(const bsl::shared_ptr&lt;Record&gt;&amp; handle) = 0;
        // Insert the specified &#39;handle&#39; at the front of this record buffer.
        // Return 0 on success, and a non-zero value otherwise.  Note that
        // concrete implementations are permitted to remove records from the
        // buffer in order to attempt to accommodate a &#39;pushFront&#39; request
        // (which implies that, after a successful call to &#39;pushFront&#39;,
        // &#39;length&#39; is not guaranteed to be more than one, and an unsuccessful
        // call to &#39;pushFront&#39; is permitted to leave the buffer empty).

    virtual void removeAll() = 0;
        // Remove all record handles stored in this record buffer.  Note that
        // &#39;length()&#39; is now 0.

    virtual void beginSequence() = 0;
        // *Lock* this record buffer so that a sequence of method invocations
        // on this record buffer can occur uninterrupted by other threads.  The
        // buffer will remain *locked* until &#39;endSequence&#39; is called.

    virtual void endSequence() = 0;
        // *Unlock* this record buffer, thus allowing other threads to access
        // it.  The behavior is undefined unless the buffer is already *locked*
        // by &#39;beginSequence&#39; method.

    // ACCESSORS
    virtual const bsl::shared_ptr&lt;Record&gt;&amp; back() const = 0;
        // Return a reference of the shared pointer referring to the record
        // positioned at the back of this record buffer.  The behavior is
        // undefined unless this record buffer has been locked by the
        // &#39;beginSequence&#39; method and &#39;0 &lt; length()&#39;.

    virtual const bsl::shared_ptr&lt;Record&gt;&amp; front() const = 0;
        // Return a reference of the shared pointer referring to the record
        // positioned at the front of this record buffer.  The behavior is
        // undefined unless this record buffer has been locked by the
        // &#39;beginSequence&#39; method and &#39;0 &lt; length()&#39;.

    virtual int length() const = 0;
        // Return the number of record handles in this record buffer.
};

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
