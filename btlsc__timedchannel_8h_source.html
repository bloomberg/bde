<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlsc_timedchannel.h                                               -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLSC_TIMEDCHANNEL
#define INCLUDED_BTLSC_TIMEDCHANNEL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a protocol for stream-based communication with a timeout.
//
//@CLASSES:
//  btlsc::TimedChannel: synchronous stream-based channel protocol with timeout
//
//@SEE_ALSO: btlsc_timedcbchannel, btlsc_timedchannelallocator
//
//@DESCRIPTION: This component provides a class, &#39;btlsc::TimedChannel&#39;, that
// defines an abstract interface for an end-point of a bi-directional
// synchronous (i.e., blocking) stream-based communication channel with timeout
// capability.  The &#39;btlsc::TimedChannel&#39; protocol supports efficient
// &quot;buffered&quot; transport and the syntax to enable efficient vector I/O
// operations (i.e., Unix-style scatter/gather &quot;readv&quot; and &quot;writev&quot;).  Various
// forms of &quot;partial transmission&quot; authorizations (i.e., &quot;raw&quot; OS-level atomic
// operations and interruptions due to a user-specified &quot;timeout&quot; or an
// &quot;asynchronous event&quot;) are also supported as appropriate.
//
///Protocol Hierarchy
///------------------
// The interface hierarchy (defined by direct public inheritance) of the
// &#39;btlsc::TimedChannel&#39; protocol is as follows:
//..
//                        ,-------------------.
//                       ( btlsc::TimedChannel )
//                        `-------------------&#39;
//                                  |
//                                  V
//                           ,--------------.
//                          ( btlsc::Channel )
//                           `--------------&#39;
//..
// This protocol adds a &quot;timeout&quot; capability for read and write methods.
//
///Synchronous Stream-Based Transport
///----------------------------------
// This interface establishes methods for synchronous stream-based transport.
// Each read and write method will block until one of three possible outcomes
// is reached: (1) &quot;success&quot; -- the specified number of bytes was transmitted,
// (2) &quot;partial result&quot; -- the operation was interrupted (e.g., via a timeout),
// (3) &quot;error&quot; -- an implementation-dependent error occurred.  In all cases, a
// &quot;status&quot; value is returned; an optional leading (&#39;int *&#39;) &#39;augStatus&#39;
// argument may be provided to enable the caller to distinguish among various
// reasons for a partial result (see below).  The user may retry a
// partial-result operation (with method arguments suitably adjusted), with a
// reasonable expectation of success.  Finally, concrete blocking stream-based
// channels do a &quot;best effort&quot; in sending and receiving the specified data, but
// need not guarantee successful transmission.
//
///Buffered Transport
///------------------
// Non-vector read operations support a &quot;buffered&quot; variant that may be more
// efficient in some situations.  For such operations, the prefix &quot;buffered&quot;
// (or infix &quot;Buffered&quot;) appears before the basic operation name in the full
// method name (e.g., &#39;bufferedRead&#39;, &#39;timedBufferedRead&#39;).  Note that, for
// synchronous channels, there is no need for buffered write operations.
//
// In the buffered operations, the caller does not provide a buffer, but rather
// receives direct (non-modifiable) access to the implementation&#39;s buffer.  In
// the event of a partial read (see below), the data remains buffered and
// subsequent reads will behave as if the buffered operation had never
// occurred.  Once a buffered read operation succeeds (i.e., receives the
// requested number of bytes) the buffered contents will remain valid only as
// long as the channel is not modified (or deallocated).  Note that &quot;buffered&quot;
// and &quot;vector&quot; (&#39;readv&#39;, see below) are incompatible read options.
//
///Partial Results
///---------------
// The &quot;simple&quot; results of read and write operations are &quot;success&quot; (with a
// status equal to the requested number of bytes) and &quot;error&quot; (with a negative
// status).  More complex behavior is also supported, some of which is at the
// option of the user.  Specifically, the caller may authorize the possibility
// of another outcome via combinations of the following two mechanisms: (1) a
// user-requested timeout, and (2) an interruption due to an asynchronous
// event.  These two mechanisms (discussed in more detail below) may each
// return with a &quot;partial result&quot;, indicated by a non-negative status that is
// less than the requested number of bytes.  Note that timeouts and
// asynchronous events may result in a return status of zero bytes.
//
///Asynchronous Events
///- - - - - - - - - -
// Methods in this protocol anticipate the possible occurrence of an
// &quot;asynchronous event&quot; (AE) during execution.  A common example of an AE is a
// Unix signal, but note that a specific Unix signal, if not detected or
// implemented, *may* not result in an AE, and an AE is certainly not limited
// to signals, even on Unix platforms.
//
// This interface cannot fully specify either the nature of or the behavior
// resulting from an AE, but certain restrictions can be (and are) imposed.  By
// default, AEs are either ignored or, if that is not possible, cause an error.
// At the user&#39;s option, however, a concrete implementation can be authorized
// to return, if such occurrence is detected, a &quot;partial result&quot; upon
// occurrence of an AE.  Such authorizations are made explicitly by
// incorporating into the optional (trailing) integer &#39;flags&#39; argument to a
// method call the &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39; value.
//
///Timeouts
/// - - - -
// A timeout is registered by the caller, when a method is invoked, as a
// &#39;bsls::TimeInterval&#39; value indicating the absolute *system* time after which
// the operation should be interrupted.  A timeout expiration will return a
// &quot;partial result&quot; (see above).  Information regarding the nature of a partial
// result is provided if the optional &#39;augStatus&#39; argument is specified (see
// below).
//
// The concrete channel will make a &quot;best effort&quot; to honor the timeout request
// promptly, but no guarantee can be made as to the maximum duration of any
// particular I/O attempt.  Any implementation of this interface will support a
// timeout granularity of ten milliseconds (0.01s) or less.  The timeout is
// guaranteed *not* to occur before the specified time has passed.  If a
// timeout is specified with a time that has already passed, the I/O operation
// will be attempted, but will not block.
//
///Raw Transmissions Cannot Produce &quot;Partial Results&quot;
/// - - - - - - - - - - - - - - - - - - - - - - - - -
// All read and unbuffered write methods support a &quot;raw&quot; variant in which the
// operation is allowed to return after transmitting at least one byte, but
// less than a &quot;partial result&quot; if (1) *at* *least* *one* *byte* has been
// transmitted and (2) no additional bytes are *immediately* transmittable.
// The &quot;raw&quot; mode is particularly useful to callers waiting for some read
// activity, who will then follow up with additional read requests after
// observing the initial transmission.  Raw transmissions are authorized by
// methods whose names end in the suffix &#39;Raw&#39;.  Note that the &quot;raw&quot; mode is
// not supported for buffered-write operations.
//
///&#39;augStatus&#39;
///- - - - - -
// Since there are several possible reasons for a &quot;partial result&quot;, the caller
// may wish to know the specific cause.  A second status value, &#39;augStatus&#39;
// (&quot;augmented status&quot;) may be requested as an optional *initial* (&#39;int *&#39;)
// argument to each transmission function.  If specified, &#39;augStatus&#39; will be
// set to 0 if a user-supplied timeout interrupted the operation, and to a
// positive value if the interruption was due to an &quot;asynchronous event&quot;.  Note
// that &#39;augStatus&#39; will not be modified on success or error, but only on a
// partial result.
//
///Scatter/Gather (&#39;readv&#39;/&#39;writev&#39;)
///---------------------------------
// This interface supports &quot;vector I/O&quot; -- the simultaneous reading from or
// writing to multiple buffers -- via Unix-style &#39;readv&#39; and &#39;writev&#39; variants
// of the normal single-buffer methods.  Scatter/Gather operations use either
// the &#39;btls::Iovec&#39; or &#39;btls::Ovec&#39; objects which use a &#39;iovec&#39; &#39;struct&#39; on
// Unix platforms or a &#39;WSABUF&#39; &#39;struct&#39; on Windows.  In either structure, the
// total number of bytes to be read or written is determined by the sum of each
// buffer of the non-negative &#39;numBuffers&#39;.  Note that the &#39;btls::Ovec&#39; variant
// enables write operations to avoid having to cast away &#39;const&#39; in order to
// hold the address of non-modifiable data to be written.  The following simple
// example shows how to create and populate a &#39;btls::Ovec&#39; array in
// preparation for a &#39;writev&#39; operation:
//..
//  static void myPrintWriteStatus(int status, int augStatus, int numBytes)
//      // Print to the user console the result of a attempting to write
//      // the specified &#39;numBytes&#39; based on the specified write &#39;status&#39;
//      // and the auxiliary &#39;augStatus&#39; (discussed below).  The behavior
//      // is undefined unless &#39;0 &lt; numBytes&#39; and &#39;status &lt;= numBytes&#39;.  Note
//      // that &#39;augStatus&#39; is ignored unless &#39;0 &lt;= status &lt; numBytes&#39;.
//     {
//         assert(0 &lt; numBytes);
//         assert(status &lt;= numBytes);
//
//         if (status == numBytes) {
//             bsl::cout &lt;&lt; &quot;All requested bytes written successfully.&quot;
//                       &lt;&lt; bsl::endl;
//         }
//         else if (status &gt;= 0) { // PARTIAL RESULTS ARE NOT AUTHORIZED BELOW.
//
//             if (augStatus &gt; 0) {
//                 bsl::cout &lt;&lt; &quot;Write interrupted (not by time out) after &quot;
//                           &lt;&lt; &quot;writing &quot; &lt;&lt; status &lt;&lt; &quot; of &quot; &lt;&lt; numBytes
//                           &lt;&lt; &quot; bytes.&quot; &lt;&lt; bsl::endl;
//             }
//             else (0 == augStatus) {
//                 bsl::cout &lt;&lt; &quot;Write timed out after writing &quot; &lt;&lt; status
//                           &lt;&lt; &quot; of &quot; &lt;&lt; numBytes &lt;&lt; &quot; bytes.&quot; &lt;&lt; bsl::endl;
//             }
//             else {
//                 assert(0 &lt; status);
//                 bsl::cout &lt;&lt; &quot;Write (efficiently) transmitted &quot;
//                           &lt;&lt; status &lt;&lt; &quot; of &quot; &lt;&lt; numBytes &lt;&lt; bytes.&quot;
//                           &lt;&lt; bsl::endl;
//             }
//         }
//         else if (-1 == status) {
//             bsl::cout &lt;&lt; &quot;Write failed: connection was closed by peer.&quot;
//                       &lt;&lt; bsl::endl;
//         }
//         else {
//             assert(-1 &gt; status);
//             bsl::cout &lt;&lt; &quot;Write failed: the reason is unknown.&quot;
//                       &lt;&lt; bsl::endl;
//         }
//     }
//
//     void myWritevAndPrintStatusWhenAvailable(btlsc::TimedChannel *channel)
//         // Write the integer representation of the length of a character
//         // string followed by the (null-terminated) string data itself to
//         // the specified &#39;channel&#39;; upon completion, report the status
//         // of the &quot;write&quot; operation to &#39;cout&#39;.
//     {
//         const char *const MESSAGE     = &quot;Hello World!&quot;;
//         const int         HEADER      = strlen(MESSAGE);
//         const int         NUM_BUFFERS = 2;
//
//         btls::Ovec buffers[NUM_BUFFERS];
//
//         // Set each buffer&#39;s data and corresponding length.
//
//         buffer[0].setBuffer(&amp;HEADER, sizeof HEADER);
//         buffer[1].setBuffer(MESSAGE, HEADER);
//
//         if (0 &gt; channel-&gt;writev(buffers, NUM_BUFFERS)) {
//             bsl::cout &lt;&lt; &quot;Buffered write operation failed!&quot; &lt;&lt; bsl::endl;
//         }
//
//         // Notice that the &#39;writev&#39; operation above does not
//         // authorize any partial write operations whatsoever.
//    }
//..
//
///Synopsis
///--------
// The following chart summarizes the set of 20 transmission methods that are
// available to read and write data from and to a &#39;btlsc::TimedChannel&#39;; note
// that &quot;buffered readv&quot; and all &quot;buffered write (and writev)&quot; operations (and
// their &quot;timed&quot; counterparts) are nonsensical and, therefore, omitted from the
// protocol:
//..
//    Buffered  Re/Wr  Vec  Raw  Untimed Method Name  Timed Method Name
//    --------  -----  ---  ---  -------------------  -----------------
//              READ             read                 timedRead
//              READ        RAW  readRaw              timedReadRaw
//
//              READ   VEC       readv                timedReadv
//              READ   VEC  RAW  readvRaw             timedReadvRaw
//
//    BUFFERED  READ             bufferedRead         timedBufferedRead
//    BUFFERED  READ        RAW  bufferedReadRaw      timedBufferedReadRaw
//
//              WRITE            write                timedWrite
//              WRITE       RAW  writeRaw             timedWriteRaw
//
//              WRITE  VEC       writev               timedWritev
//              WRITE  VEC  RAW  writevRaw            timedWritevRaw
//
//..
// Each of these methods supports the specification of a flag value:
//..
//  btlsc::Flag::k_ASYNC_INTERRUPT
//..
// supplied in an optional trailing integer to enable &quot;asynchronous events&quot; to
// cause partial results; by default, such events are ignored.
//
// Each of these methods is overloaded to allow the caller to optionally
// specify the address of an &#39;augStatus&#39;, which will then be modified in the
// event of a partial result.
//
///Usage
///-----
// The &#39;btlsc&#39; style of channel interface is used to transmit sequences of
// specified size across some concrete channel implementation.  In this example
// we demonstrate how to implement a remote procedure call (RPC) to a factorial
// function taking an &#39;int&#39; and returning a &#39;double&#39;.  For simplicity, we will
// assume that both the &#39;int&#39; and &#39;double&#39; formats are binary compatible across
// client and server platforms.
//..
//  double factorial(int number)
//      // Return the factorial of the specified integral &#39;number&#39; as a value
//      // of type &#39;double&#39;.  The behavior is undefined unless &#39;0 &lt;= number&#39;.
//      // Note that this helper function is provided for the server to
//      // calculate the factorial value.
//  {
//      if (0 == number) {
//          return 1;                                                 // RETURN
//      }
//      else {
//          return number * factorial(number - 1);                    // RETURN
//      }
//  }
//
//  int factorialClient(double              *result,
//                      int                  input,
//                      btlsc::TimedChannel *channel)
//      // Load into the specified &#39;result&#39; the factorial of the specified
//      // &#39;input&#39; using the specified &#39;channel&#39; (which is assumed to be
//      // connected to an appropriate factorial service).  Return 0 on
//      // success, and -1, with no effect on &#39;result&#39;, on error.  The behavior
//      // is undefined unless &#39;0 &lt;= input&#39;.
//  {
//      ASSERT(0 &lt;= input);
//
//      enum {
//          k_ERROR_STATUS   = -1,
//          k_SUCCESS_STATUS =  0,
//          k_TIMEOUT_STATUS =  1
//      };
//
//      enum {
//          k_WRITE_TIMEOUT = 1,     // seconds
//          k_READ_TIMEOUT  = 5      // seconds
//      };
//      bsls::TimeInterval timeNow = bdlt::CurrentTime::now();
//      bsls::TimeInterval writeTimeout(timeNow + k_WRITE_TIMEOUT);
//      bsls::TimeInterval readTimeout(timeNow + k_READ_TIMEOUT);
//
//      int numBytes = sizeof input;
//      int writeStatus = channel-&gt;timedWrite((const char *)&amp;input,
//                                             numBytes,
//                                             writeTimeout);
//      ASSERT(0 != writeStatus);
//
//      if (writeStatus != numBytes) {
//          return k_ERROR_STATUS;                                    // RETURN
//      }
//
//      int readStatus = channel-&gt;timedRead((char *)result,
//                                          sizeof *result,
//                                          readTimeout);
//      if (readStatus != sizeof *result) {
//          return k_ERROR_STATUS;                                    // RETURN
//      }
//
//      return k_SUCCESS_STATUS;                                      // RETURN
//  }
//
//  int factorialServer(btlsc::TimedChannel *channel)
//      // Repeatedly read integer sequences from the specified &#39;channel&#39;.
//      // When a read succeeds, interpret the byte sequence as an integer
//      // value in host-byte order.  Return -1 if that value is negative.
//      // Otherwise, calculate the factorial of the (non-negative) integer and
//      // write back the result to &#39;channel&#39; as a sequence of bytes
//      // representing a &#39;double&#39; in the host&#39;s native format.  Return a
//      // negative value if any write operation doesn&#39;t succeed (refer to the
//      // following &#39;enum&#39; values for specific errors).  Note that this
//      // implementation is just to show how a channel could be used; there is
//      // much room to improve.
//  {
//      enum {
//          k_SUCCESS            =  0,
//          k_INVALID_INPUT      = -1,
//          k_ERROR_READ         = -2,
//          k_ERROR_WRITE        = -3,
//          k_ERROR_TIMEOUT      = -4,
//          k_ERROR_INTERRUPTED  = -5,
//          k_ERROR_UNCLASSIFIED = -6
//      };
//
//      enum {
//          k_READ_TIME  = 3600, // an hour
//          k_WRITE_TIME = 2     // 2 seconds
//      };
//      bsls::TimeInterval timeNow = bdlt::CurrentTime::now();
//      const bsls::TimeInterval k_READ_TIMEOUT(timeNow + k_READ_TIME),
//                              k_WRITE_TIMEOUT(timeNow + k_WRITE_TIME);
//
//      while (1) {
//          int input, augStatus;
//          int readStatus = channel-&gt;timedRead(&amp;augStatus,
//                                              (char *)&amp;input,
//                                              sizeof input,
//                                              k_READ_TIMEOUT);
//          if (readStatus &lt; 0) {
//              return k_ERROR_READ;                                  // RETURN
//          }
//          if (readStatus != sizeof input) {
//              if (0 == augStatus) {
//                  return k_ERROR_TIMEOUT;                           // RETURN
//              }
//              else if (augStatus &gt; 0) {
//                  return k_ERROR_INTERRUPTED;                       // RETURN
//              }
//              return k_ERROR_UNCLASSIFIED;                          // RETURN
//          }
//          if (input &lt; 0) {
//              return k_INVALID_INPUT;                               // RETURN
//          }
//
//          augStatus = 0;
//          double result = factorial(input);
//          int writeStatus = channel-&gt;timedWrite(&amp;augStatus,
//                                                (const char *)&amp;result,
//                                                sizeof input,
//                                                k_WRITE_TIMEOUT);
//          if (writeStatus &lt; 0) {
//              return k_ERROR_WRITE;                                 // RETURN
//          }
//          else if (writeStatus != sizeof input){
//              if (0 == augStatus) {
//                  return k_ERROR_TIMEOUT;                           // RETURN
//              }
//              else if (augStatus &gt; 0) {
//                  return k_ERROR_INTERRUPTED;                       // RETURN
//              }
//              return k_ERROR_UNCLASSIFIED;                          // RETURN
//          }
//      }
//  }
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLSC_CHANNEL
#include &lt;btlsc_channel.h&gt;
#endif

#ifndef INCLUDED_BTLS_IOVEC
#include &lt;btls_iovec.h&gt;
#endif

namespace BloombergLP {

namespace bsls { class TimeInterval; }

namespace btlsc {

                             // ==================
                             // class TimedChannel
                             // ==================

class TimedChannel : public Channel {
    // This class defines a protocol (pure abstract interface) for a
    // synchronous communication channel that supports timed (blocking) read,
    // write, and buffered read operations on a byte stream.  In general, a
    // non-negative status indicates the number of bytes read or written, while
    // a negative status implies an unspecified error.  Note that an error
    // status of -1 indicates that the connection is *known* to have been
    // closed by the peer.

  public:
    // CREATORS
    virtual ~TimedChannel();
        // Destroy this object.

    // MANIPULATORS
    virtual int read(char *buffer, int numBytes, int flags = 0) = 0;
    virtual int read(int  *augStatus,
                     char *buffer,
                     int   numBytes,
                     int   flags = 0) = 0;
        // Read from this channel into the specified &#39;buffer&#39; the specified
        // &#39;numBytes&#39;.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // on success, a negative value on error, and the number of bytes newly
        // read into &#39;buffer&#39; (indicating a partial result) otherwise.  On a
        // partial result, load &#39;augStatus&#39;, if supplied, with a positive
        // value, indicating that an asynchronous event caused the
        // interruption; otherwise, &#39;augStatus&#39; is unmodified.  A partial
        // result typically does not invalidate this channel; hence, this (or
        // another) operation may be retried (with arguments suitably adjusted)
        // with some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error (leaving the contents of &#39;buffer&#39;
        // undefined); -1 implies that the connection was closed by the peer
        // (but the converse is not guaranteed).  The behavior is undefined
        // unless &#39;buffer&#39; has sufficient capacity to hold the requested data
        // and &#39;0 &lt; numBytes&#39;.

    virtual int timedRead(char                      *buffer,
                          int                        numBytes,
                          const bsls::TimeInterval&amp;  timeout,
                          int                        flags = 0) = 0;
    virtual int timedRead(int                       *augStatus,
                          char                      *buffer,
                          int                        numBytes,
                          const bsls::TimeInterval&amp;  timeout,
                          int                        flags = 0) = 0;
        // Read from this channel into the specified &#39;buffer&#39; the specified
        // &#39;numBytes&#39; or interrupt after the specified absolute &#39;timeout&#39; time
        // is reached.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // on success, a negative value on error, and the number of bytes newly
        // read into &#39;buffer&#39; (indicating a partial result) otherwise.  On a
        // partial result, load &#39;augStatus&#39;, if supplied, with 0 if &#39;timeout&#39;
        // interrupted this operation, or a positive value if the interruption
        // was due to an asynchronous event; otherwise, &#39;augStatus&#39; is
        // unmodified.  A partial result typically does not invalidate this
        // channel; hence, this (or another) operation may be retried (with
        // arguments suitably adjusted) with some reasonable hope of success.
        // A negative &quot;status&quot;, however, indicates a permanent error (leaving
        // the contents of &#39;buffer&#39; undefined); -1 implies that the connection
        // was closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;buffer&#39; has sufficient capacity to
        // hold the requested data and &#39;0 &lt; numBytes&#39;.  Note that if the
        // &#39;timeout&#39; value has already passed, the &quot;read&quot; operation will still
        // be attempted, but the attempt will not block.

    virtual int readv(const btls::Iovec *buffers,
                      int                numBuffers,
                      int                flags = 0) = 0;
    virtual int readv(int               *augStatus,
                      const btls::Iovec *buffers,
                      int                numBuffers,
                      int                flags = 0) = 0;
        // Read from this channel into the specified sequence of &#39;buffers&#39; of
        // the specified &#39;numBuffers&#39;, the respective number of bytes as
        // specified in each corresponding &#39;btls::Iovec&#39; buffer.  If the
        // optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a partial result.  Return &#39;numBytes&#39;
        // (i.e., the sum of calls to &#39;length&#39; on the &#39;numBuffers&#39; &#39;buffers&#39;)
        // on success, a negative value on error, and the number of bytes newly
        // read into &#39;buffers&#39; (indicating a partial result) otherwise.  On a
        // partial result, load &#39;augStatus&#39;, if supplied, with a positive
        // value, indicating that an asynchronous event caused the
        // interruption; otherwise, &#39;augStatus&#39; is unmodified.  A partial
        // result typically does not invalidate this channel; hence, this (or
        // another) operation may be retried (with arguments suitably adjusted)
        // with some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error (leaving the contents of &#39;buffers&#39;
        // undefined); -1 implies that the connection was closed by the peer
        // (but the converse is not guaranteed).  The behavior is undefined
        // unless &#39;buffers&#39; have sufficient capacity to hold the requested data
        // and &#39;0 &lt; numBytes&#39;.

    virtual int timedReadv(const btls::Iovec         *buffers,
                           int                        numBuffers,
                           const bsls::TimeInterval&amp;  timeout,
                           int                        flags = 0) = 0;
    virtual int timedReadv(int                       *augStatus,
                           const btls::Iovec         *buffers,
                           int                        numBuffers,
                           const bsls::TimeInterval&amp;  timeout,
                           int                        flags = 0) = 0;
        // Read from this channel into the specified sequence of &#39;buffers&#39; of
        // the specified &#39;numBuffers&#39;, the respective number of bytes as
        // specified in each corresponding &#39;btls::Iovec&#39; buffer, or interrupted
        // after the specified absolute &#39;timeout&#39; time is reached.  If the
        // optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // (i.e., the sum of calls to &#39;length&#39; on the &#39;numBuffers&#39; &#39;buffers&#39;)
        // on success, a negative value on error, and the number of bytes newly
        // read into &#39;buffers&#39; (indicating a partial result) otherwise.  On a
        // partial result, load &#39;augStatus&#39;, if supplied, with 0 if &#39;timeout&#39;
        // interrupted this operation or a positive value if the interruption
        // was due to an asynchronous event; otherwise, &#39;augStatus&#39; is
        // unmodified.  A partial result typically does not invalidate this
        // channel; hence, this (or another) operation may be retried (with
        // arguments suitably adjusted) with some reasonable hope of success.
        // A negative &quot;status&quot;, however, indicates a permanent error (leaving
        // the contents of &#39;buffers&#39; undefined); -1 implies that the connection
        // was closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;buffers&#39; have sufficient capacity to
        // hold the requested data and &#39;0 &lt; numBytes&#39;.  Note that if the
        // &#39;timeout&#39; value has already passed, the &quot;read&quot; operation will still
        // be attempted, but the attempt will not block.

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    virtual int readRaw(char *buffer,
                        int   numBytes,
                        int   flags = 0) = 0;
    virtual int readRaw(int  *augStatus,
                        char *buffer,
                        int   numBytes,
                        int   flags = 0) = 0;
        // *Atomically* read from this channel into the specified &#39;buffer&#39; *at*
        // *most* the specified &#39;numBytes&#39;.  If the optionally specified
        // &#39;flags&#39; incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;,
        // &quot;asynchronous events&quot; are permitted to interrupt this operation; by
        // default, such events are ignored.  Optionally specify (as a
        // *leading* argument) &#39;augStatus&#39; to receive status specific to a
        // &quot;partial result&quot;.  Return &#39;numBytes&#39; on success, a negative value on
        // error, and the number of bytes newly read into &#39;buffer&#39; (indicating
        // a partial result) otherwise.  On a partial result, load &#39;augStatus&#39;,
        // if supplied, with a positive value if an asynchronous event
        // interrupted this operation and a negative value if the atomic
        // OS-level operation transmitted at least one byte, but less than
        // &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is unmodified.  A partial result
        // typically does not invalidate this channel; hence, this (or another)
        // operation may be retried (with arguments suitably adjusted) with
        // some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error (leaving the contents of &#39;buffer&#39;
        // undefined); -1 implies that the connection was closed by the peer
        // (but the converse is not guaranteed).  The behavior is undefined
        // unless &#39;buffer&#39; has sufficient capacity to hold the requested data
        // and &#39;0 &lt; numBytes&#39;.

    virtual int timedReadRaw(char                      *buffer,
                             int                        numBytes,
                             const bsls::TimeInterval&amp;  timeout,
                             int                        flags = 0) = 0;
    virtual int timedReadRaw(int                       *augStatus,
                             char                      *buffer,
                             int                        numBytes,
                             const bsls::TimeInterval&amp;  timeout,
                             int                        flags = 0) = 0;
        // *Atomically* read from this channel into the specified &#39;buffer&#39; *at*
        // *most* the specified &#39;numBytes&#39; or interrupt after the specified
        // absolute &#39;timeout&#39; time is reached.  If the optionally specified
        // &#39;flags&#39; incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;,
        // &quot;asynchronous events&quot; are permitted to interrupt this operation; by
        // default, such events are ignored.  Optionally specify (as a
        // *leading* argument) &#39;augStatus&#39; to receive status specific to a
        // &quot;partial result&quot;.  Return &#39;numBytes&#39; on success, a negative value on
        // error, and the number of bytes newly read into &#39;buffer&#39; (indicating
        // a partial result) otherwise.  On a partial result, load &#39;augStatus&#39;,
        // if supplied, with 0 if &#39;timeout&#39; interrupted this operation, a
        // positive value if an asynchronous event caused an interruption, or a
        // negative value if the atomic OS-level operation transmitted at least
        // one byte, but less than &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is
        // unmodified.  A partial result typically does not invalidate this
        // channel; hence, this (or another) operation may be retried (with
        // arguments suitably adjusted) with some reasonable hope of success.
        // A negative &quot;status&quot;, however, indicates a permanent error (leaving
        // the contents of &#39;buffer&#39; undefined); -1 implies that the connection
        // was closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;buffer&#39; has sufficient capacity to
        // hold the requested data and &#39;0 &lt; numBytes&#39;.  Note that if the
        // &#39;timeout&#39; value has already passed, the &quot;read&quot; operation will still
        // be attempted, but the attempt will not block.

    virtual int readvRaw(const btls::Iovec *buffers,
                         int                numBuffers,
                         int                flags = 0) = 0;
    virtual int readvRaw(int               *augStatus,
                         const btls::Iovec *buffers,
                         int                numBuffers,
                         int                flags = 0) = 0;
        // *Atomically* read from this channel into the specified sequence of
        // &#39;buffers&#39; of the specified &#39;numBuffers&#39;, *at* *most* the respective
        // number of bytes as specified in each corresponding &#39;btls::Iovec&#39;
        // buffer.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // (i.e., the sum of calls to &#39;length&#39; on the &#39;numBuffers&#39; &#39;buffers&#39;)
        // on success, a negative value on error, and the number of bytes newly
        // read into &#39;buffers&#39; (indicating a partial result) otherwise.  On a
        // partial result, load &#39;augStatus&#39;, if supplied, with a positive value
        // if an asynchronous event interrupted this operation and a negative
        // value if the atomic OS-level operation transmitted at least one
        // byte, but less than &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is
        // unmodified.  A partial result typically does not invalidate this
        // channel; hence, this (or another) operation may be retried (with
        // arguments suitably adjusted) with some reasonable hope of success.
        // A negative &quot;status&quot;, however, indicates a permanent error (leaving
        // the contents of &#39;buffers&#39; undefined); -1 implies that the connection
        // was closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;buffers&#39; have sufficient capacity to
        // hold the requested data and &#39;0 &lt; numBytes&#39;.

    virtual int timedReadvRaw(int                       *augStatus,
                              const btls::Iovec         *buffers,
                              int                        numBuffers,
                              const bsls::TimeInterval&amp;  timeout,
                              int                        flags = 0) = 0;
    virtual int timedReadvRaw(const btls::Iovec         *buffers,
                              int                        numBuffers,
                              const bsls::TimeInterval&amp;  timeout,
                              int                        flags = 0) = 0;
        // *Atomically* read from this channel into the specified sequence of
        // &#39;buffers&#39; of the specified &#39;numBuffers&#39; *at* *most* the respective
        // number of bytes as specified in each corresponding &#39;btls::Iovec&#39;
        // buffer, or interrupted after the specified absolute &#39;timeout&#39; time
        // is reached.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // (i.e., the sum of calls to &#39;length&#39; on the &#39;numBuffers&#39; &#39;buffers&#39;)
        // on success, a negative value on error, and the number of bytes newly
        // read into &#39;buffers&#39; (indicating a partial result) otherwise.  On a
        // partial result, load &#39;augStatus&#39;, if supplied, with 0 if &#39;timeout&#39;
        // interrupted this operation, a positive value if an asynchronous
        // event caused an interruption, or a negative value if the atomic
        // OS-level operation transmitted at least one byte, but less than
        // &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is unmodified.  A partial result
        // typically does not invalidate this channel; hence, this (or another)
        // operation may be retried (with arguments suitably adjusted) with
        // some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error (leaving the contents of &#39;buffers&#39;
        // undefined); -1 implies that the connection was closed by the peer
        // (but the converse is not guaranteed).  The behavior is undefined
        // unless &#39;buffers&#39; have sufficient capacity to hold the requested data
        // and &#39;0 &lt; numBytes&#39;.  Note that if the &#39;timeout&#39; value has already
        // passed, the &quot;read&quot; operation will still be attempted, but the
        // attempt will not block.

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    virtual int bufferedRead(const char **buffer,
                             int          numBytes,
                             int          flags = 0) = 0;
    virtual int bufferedRead(int         *augStatus,
                             const char **buffer,
                             int          numBytes,
                             int          flags = 0) = 0;
        // Read from this channel into a channel-supplied buffer, identified
        // via the specified &#39;buffer&#39;, the specified &#39;numBytes&#39;.  If the
        // optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // on success, a negative value on error, and the number of bytes
        // (indicating a partial result) otherwise.  Any positive return value
        // guarantees that &#39;*buffer&#39; will remain valid until this channel is
        // modified.  On a partial result, load &#39;augStatus&#39;, if supplied, with
        // a positive value, indicating that an asynchronous event caused the
        // interruption; otherwise, &#39;augStatus&#39; is unmodified.  A partial
        // result typically does not invalidate this channel; hence, this (or
        // another) operation may be retried with some reasonable hope of
        // success -- buffered data from a partial result remains available
        // until consumed by subsequent read operations.  A negative &quot;status&quot;,
        // however, indicates a permanent error (leaving &#39;buffer&#39; undefined);
        // -1 implies that the connection was closed by the peer (but the
        // converse is not guaranteed).  The behavior is undefined unless
        // &#39;0 &lt; numBytes&#39;.

    virtual int timedBufferedRead(const char                **buffer,
                                  int                         numBytes,
                                  const bsls::TimeInterval&amp;   timeout,
                                  int                         flags = 0) = 0;
    virtual int timedBufferedRead(int                        *augStatus,
                                  const char                **buffer,
                                  int                         numBytes,
                                  const bsls::TimeInterval&amp;   timeout,
                                  int                         flags = 0) = 0;
        // Read from this channel into a channel-supplied buffer, identified
        // via the specified &#39;buffer&#39;, the specified &#39;numBytes&#39;, or interrupt
        // after the specified absolute &#39;timeout&#39; time is reached.  If the
        // optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // on success, a negative value on error, and the number of bytes
        // (indicating a partial result) otherwise.  Any positive return value
        // guarantees that &#39;*buffer&#39; will remain valid until this channel is
        // modified.  On a partial result, load &#39;augStatus&#39;, if supplied, with
        // 0 if &#39;timeout&#39; interrupted this operation, or a positive value if
        // the interruption was due to an asynchronous event; otherwise,
        // &#39;augStatus&#39; is unmodified.  A partial result typically does not
        // invalidate this channel; hence, this (or another) operation may be
        // retried with some reasonable hope of success -- buffered data from a
        // partial result remains available until consumed by subsequent read
        // operations.  A negative &quot;status&quot;, however, indicates a permanent
        // error (leaving &#39;buffer&#39; undefined); -1 implies that the connection
        // was closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;0 &lt; numBytes&#39;.  Note that if the
        // &#39;timeout&#39; value has already passed, the &quot;read&quot; operation will still
        // be attempted, but the attempt will not block.

    virtual int bufferedReadRaw(const char **buffer,
                                int          numBytes,
                                int          flags = 0) = 0;
    virtual int bufferedReadRaw(int         *augStatus,
                                const char **buffer,
                                int          numBytes,
                                int          flags = 0) = 0;
        // *Atomically* read from this channel into a channel-supplied buffer,
        // identified via the specified &#39;buffer&#39;, *at* *most* the specified
        // &#39;numBytes&#39;.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // on success, a negative value on error, and the number of bytes newly
        // read into &#39;buffer&#39; (indicating a partial result) otherwise.  Any
        // positive return value guarantees that &#39;*buffer&#39; will remain valid
        // until this channel is modified.  On a partial result, load
        // &#39;augStatus&#39;, if supplied, with a positive value if an asynchronous
        // event interrupted this operation, or a negative value if the atomic
        // OS-level operation transmitted at least one but less than
        // &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is unmodified.  A partial result
        // typically does not invalidate this channel; hence, this (or another)
        // operation may be retried with some reasonable hope of success --
        // buffered data from a partial result remains available until consumed
        // by subsequent read operations.  A negative &quot;status&quot;, however,
        // indicates a permanent error (leaving &#39;buffer&#39; unset); -1 implies
        // that the connection was closed by the peer (but the converse is not
        // guaranteed).  The behavior is undefined unless &#39;0 &lt; numBytes&#39;.

    virtual int timedBufferedReadRaw(
                                    const char                **buffer,
                                    int                         numBytes,
                                    const bsls::TimeInterval&amp;   timeout,
                                    int                         flags = 0) = 0;
    virtual int timedBufferedReadRaw(
                                    int                        *augStatus,
                                    const char                **buffer,
                                    int                         numBytes,
                                    const bsls::TimeInterval&amp;   timeout,
                                    int                         flags = 0) = 0;
        // *Atomically* read from this channel into a channel-supplied buffer,
        // identified via the specified &#39;buffer&#39;, *at* *most* the specified
        // &#39;numBytes&#39; or interrupt after the specified absolute &#39;timeout&#39; time
        // is reached.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // on success, a negative value on error, and the number of bytes newly
        // read into &#39;buffer&#39; (indicating a partial result) otherwise.  On a
        // partial result, load &#39;augStatus&#39;, if supplied, with 0 if &#39;timeout&#39;
        // interrupted this operation, a positive value if an asynchronous
        // event caused an interruption, or a negative value if the atomic
        // OS-level operation transmitted at least one byte, but less than
        // &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is unmodified.  A partial result
        // typically does not invalidate this channel; hence, this (or another)
        // operation may be retried with some reasonable hope of success --
        // buffered data from a partial result remains available until consumed
        // by subsequent read operations.  A negative &quot;status&quot;, however,
        // indicates a permanent error (leaving &#39;*buffer&#39; unset); -1 implies
        // that the connection was closed by the peer (but the converse is not
        // guaranteed).  The behavior is undefined unless &#39;0 &lt; numBytes&#39;.  Note
        // that if the &#39;timeout&#39; value has already passed, the &quot;read&quot; operation
        // will still be attempted, but the attempt will not block.

    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    virtual int write(const char *buffer,
                      int         numBytes,
                      int         flags = 0) = 0;
    virtual int write(int        *augStatus,
                      const char *buffer,
                      int         numBytes,
                      int         flags = 0) = 0;
        // Write to this channel from the specified &#39;buffer&#39; the specified
        // &#39;numBytes&#39;.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // on success, a negative value on error, and the number of bytes newly
        // written from &#39;buffer&#39; (indicating a partial result) otherwise.  On a
        // partial result, load &#39;augStatus&#39;, if supplied, with a positive
        // value, indicating that an asynchronous event caused the
        // interruption; otherwise, &#39;augStatus&#39; is unmodified.  A partial
        // result typically does not invalidate this channel; hence, this (or
        // another) operation may be retried (with arguments suitably adjusted)
        // with some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error; -1 implies that the connection was
        // closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;0 &lt; numBytes&#39;.

    virtual int timedWrite(int                       *augStatus,
                           const char                *buffer,
                           int                        numBytes,
                           const bsls::TimeInterval&amp;  timeout,
                           int                        flags = 0) = 0;
    virtual int timedWrite(const char                *buffer,
                           int                        numBytes,
                           const bsls::TimeInterval&amp;  timeout,
                           int                        flags = 0) = 0;
        // Write to this channel from the specified &#39;buffer&#39; the specified
        // &#39;numBytes&#39; or interrupt after the specified absolute &#39;timeout&#39; time
        // is reached.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Return &#39;numBytes&#39; on success, a negative value on error,
        // and the number of bytes newly written from &#39;buffer&#39; (indicating a
        // partial result) otherwise.  On a partial result, load &#39;augStatus&#39;,
        // if supplied, with 0 if &#39;timeout&#39; interrupted this operation, or a
        // positive value if the interruption was due to an asynchronous event;
        // otherwise, &#39;augStatus&#39; is unmodified.  A partial result typically
        // does not invalidate this channel; hence, this (or another) operation
        // may be retried (with arguments suitably adjusted) with some
        // reasonable hope of success.  A negative &quot;status&quot;, however, indicates
        // a permanent error; -1 implies that the connection was closed by the
        // peer (but the converse is not guaranteed).  The behavior is
        // undefined unless &#39;0 &lt; numBytes&#39;.  Note that if the &#39;timeout&#39; value
        // has already passed, the &quot;write&quot; operation will still be attempted,
        // but the attempt will not block.

    virtual int writeRaw(const char *buffer,
                         int         numBytes,
                         int         flags = 0) = 0;
    virtual int writeRaw(int        *augStatus,
                         const char *buffer,
                         int         numBytes,
                         int         flags = 0) = 0;
        // *Atomically* write to this channel from the specified &#39;buffer&#39; *at*
        // *most* the specified &#39;numBytes&#39;.  If the optionally specified
        // &#39;flags&#39; incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;,
        // &quot;asynchronous events&quot; are permitted to interrupt this operation; by
        // default, such events are ignored.  Optionally specify (as a
        // *leading* argument) &#39;augStatus&#39; to receive status specific to a
        // &quot;partial result&quot;.  Return &#39;numBytes&#39; on success, a negative value on
        // error, and the number of bytes newly written from &#39;buffer&#39;
        // (indicating a partial result) otherwise.  On a partial result, load
        // &#39;augStatus&#39;, if supplied, with a positive value if an asynchronous
        // event interrupted this operation and a negative value if the atomic
        // OS-level operation transmitted at least one byte, but less than
        // &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is unmodified.  A partial result
        // typically does not invalidate this channel; hence, this (or another)
        // operation may be retried (with arguments suitably adjusted) with
        // some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error; -1 implies that the connection was
        // closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;0 &lt; numBytes&#39;.

    virtual int timedWriteRaw(int                       *augStatus,
                              const char                *buffer,
                              int                        numBytes,
                              const bsls::TimeInterval&amp;  timeout,
                              int                        flags = 0) = 0;
    virtual int timedWriteRaw(const char                *buffer,
                              int                        numBytes,
                              const bsls::TimeInterval&amp;  timeout,
                              int                        flags = 0) = 0;
        // *Atomically* write to this channel from the specified &#39;buffer&#39; *at*
        // *most* the specified &#39;numBytes&#39;, or interrupt after the specified
        // absolute &#39;timeout&#39; time is reached.  If the optionally specified
        // &#39;flags&#39; incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;,
        // &quot;asynchronous events&quot; are permitted to interrupt this operation; by
        // default, such events are ignored.  Optionally specify (as a
        // *leading* argument) &#39;augStatus&#39; to receive status specific to a
        // &quot;partial result&quot;.  Return &#39;numBytes&#39; on success, a negative value on
        // error, and the number of bytes newly written from &#39;buffer&#39;
        // (indicating a partial result) otherwise.  On a partial result, load
        // &#39;augStatus&#39;, if supplied, with 0 if &#39;timeout&#39; interrupted this
        // operation, a positive value if an asynchronous event caused an
        // interruption, or a negative value if the atomic OS-level operation
        // transmitted at least one byte, but less than &#39;numBytes&#39;; otherwise,
        // &#39;augStatus&#39; is unmodified.  A partial result typically does not
        // invalidate this channel; hence, this (or another) operation may be
        // retried (with arguments suitably adjusted) with some reasonable hope
        // of success.  A negative &quot;status&quot;, however, indicates a permanent
        // error; -1 implies that the connection was closed by the peer (but
        // the converse is not guaranteed).  The behavior is undefined unless
        // &#39;0 &lt; numBytes&#39;.  Note that if the &#39;timeout&#39; value has already
        // passed, the &quot;write&quot; operation will still be attempted, but the
        // attempt will not block.

    virtual int writev(const btls::Ovec  *buffers,
                       int                numBuffers,
                       int                flags = 0) = 0;
    virtual int writev(const btls::Iovec *buffers,
                       int                numBuffers,
                       int                flags = 0) = 0;
    virtual int writev(int               *augStatus,
                       const btls::Ovec  *buffers,
                       int                numBuffers,
                       int                flags = 0) = 0;
    virtual int writev(int               *augStatus,
                       const btls::Iovec *buffers,
                       int                numBuffers,
                       int                flags = 0) = 0;
        // Write to this channel from the specified sequence of &#39;buffers&#39; of
        // the specified sequence length &#39;numBuffers&#39;, the respective number of
        // bytes as specified in each corresponding &#39;btls::Ovec&#39; (or
        // &#39;btls::Iovec&#39;) buffer.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt this operation; by default, such events
        // are ignored.  Optionally specify (as a *leading* argument)
        // &#39;augStatus&#39; to receive status specific to a partial result.  Return
        // &#39;numBytes&#39; (i.e., the sum of calls to &#39;length&#39; on the &#39;numBuffers&#39;
        // &#39;buffers&#39;) on success, a negative value on error, and the number of
        // bytes newly written from &#39;buffers&#39; (indicating a partial result)
        // otherwise.  On a partial result, load &#39;augStatus&#39;, if supplied, with
        // a positive value, indicating that an asynchronous event caused the
        // interruption; otherwise, &#39;augStatus&#39; is unmodified.  A partial
        // result typically does not invalidate this channel; hence, this (or
        // another) operation may be retried (with arguments suitably adjusted)
        // with some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error; -1 implies that the connection was
        // closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;0 &lt; numBytes&#39;.

    virtual int timedWritev(const btls::Ovec          *buffers,
                            int                        numBuffers,
                            const bsls::TimeInterval&amp;  timeout,
                            int                        flags = 0) = 0;
    virtual int timedWritev(const btls::Iovec         *buffers,
                            int                        numBuffers,
                            const bsls::TimeInterval&amp;  timeout,
                            int                        flags = 0) = 0;
    virtual int timedWritev(int                       *augStatus,
                            const btls::Ovec          *buffers,
                            int                        numBuffers,
                            const bsls::TimeInterval&amp;  timeout,
                            int                        flags = 0) = 0;
    virtual int timedWritev(int                       *augStatus,
                            const btls::Iovec         *buffers,
                            int                        numBuffers,
                            const bsls::TimeInterval&amp;  timeout,
                            int                        flags = 0) = 0;
        // Write to this channel from the specified sequence of &#39;buffers&#39; of
        // the specified sequence length &#39;numBuffers&#39; the respective number of
        // bytes specified in each &#39;btls::Ovec&#39; (or &#39;btls::Iovec&#39;) buffer, or
        // interrupted after the specified absolute &#39;timeout&#39; time is reached.
        // If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Optionally specify (as a *leading* argument) &#39;augStatus&#39;
        // to receive status specific to a &quot;partial result&quot;.  Return &#39;numBytes&#39;
        // (i.e., the sum of calls to &#39;length&#39; on the &#39;numBuffers&#39; &#39;buffers&#39;)
        // on success, a negative value on error, and the number of bytes newly
        // written from &#39;buffers&#39; (indicating a partial result) otherwise.  On
        // a partial result, load &#39;augStatus&#39;, if supplied, with 0 if &#39;timeout&#39;
        // interrupted this operation or a positive value if the interruption
        // was due to an asynchronous event; otherwise, &#39;augStatus&#39; is
        // unmodified.  A partial result typically does not invalidate this
        // channel; hence, this (or another) operation may be retried (with
        // arguments suitably adjusted) with some reasonable hope of success.
        // A negative &quot;status&quot;, however, indicates a permanent error; -1
        // implies that the connection was closed by the peer (but the converse
        // is not guaranteed).  The behavior is undefined unless
        // &#39;0 &lt; numBytes&#39;.  Note that if the &#39;timeout&#39; value has already
        // passed, the &quot;write&quot; operation will still be attempted, but the
        // attempt will not block.

    virtual int writevRaw(const btls::Ovec  *buffers,
                          int                numBuffers,
                          int                flags = 0) = 0;
    virtual int writevRaw(const btls::Iovec *buffers,
                          int                numBuffers,
                          int                flags = 0) = 0;
    virtual int writevRaw(int               *augStatus,
                          const btls::Ovec  *buffers,
                          int                numBuffers,
                          int                flags = 0) = 0;
    virtual int writevRaw(int               *augStatus,
                          const btls::Iovec *buffers,
                          int                numBuffers,
                          int                flags = 0) = 0;
        // *Atomically* write to this channel, from the specified sequence of
        // &#39;buffers&#39; of the specified sequence length &#39;numBuffers&#39;, *at* *most*
        // the respective number of bytes as specified in each &#39;btls::Ovec&#39; (or
        // &#39;btls::Iovec&#39;) buffer.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt this operation; by default, such events
        // are ignored.  Optionally specify (as a *leading* argument)
        // &#39;augStatus&#39; to receive status specific to a &quot;partial result&quot;.
        // Return &#39;numBytes&#39; (i.e., the sum of calls to &#39;length&#39; on the
        // &#39;numBuffers&#39; &#39;buffers&#39;) on success, a negative value on error, and
        // the number of bytes newly written from &#39;buffers&#39; (indicating a
        // partial result) otherwise.  On a partial result, load &#39;augStatus&#39;,
        // if supplied, with a positive value if an asynchronous event
        // interrupted this operation and a negative value if the atomic
        // OS-level operation transmitted at least one byte, but less than
        // &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is unmodified.  A partial result
        // typically does not invalidate this channel; hence, this (or another)
        // operation may be retried (with arguments suitably adjusted) with
        // some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error; -1 implies that the connection was
        // closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;0 &lt; numBytes&#39;.

    virtual int timedWritevRaw(const btls::Ovec          *buffers,
                               int                        numBuffers,
                               const bsls::TimeInterval&amp;  timeout,
                               int                        flags = 0) = 0;
    virtual int timedWritevRaw(const btls::Iovec         *buffers,
                               int                        numBuffers,
                               const bsls::TimeInterval&amp;  timeout,
                               int                        flags = 0) = 0;
    virtual int timedWritevRaw(int                       *augStatus,
                               const btls::Ovec          *buffers,
                               int                        numBuffers,
                               const bsls::TimeInterval&amp;  timeout,
                               int                        flags = 0) = 0;
    virtual int timedWritevRaw(int                       *augStatus,
                               const btls::Iovec         *buffers,
                               int                        numBuffers,
                               const bsls::TimeInterval&amp;  timeout,
                               int                        flags = 0) = 0;
        // *Atomically* write to this channel, from the specified sequence of
        // &#39;buffers&#39; of the specified sequence length &#39;numBuffers&#39;, *at* *most*
        // the respective number of bytes specified in each &#39;btls::Ovec&#39; (or
        // &#39;btls::Iovec&#39;) buffer, or interrupted after the specified absolute
        // &#39;timeout&#39; time is reached.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt this operation; by default, such events
        // are ignored.  Optionally specify (as a *leading* argument)
        // &#39;augStatus&#39; to receive status specific to a &quot;partial result&quot;.
        // Return &#39;numBytes&#39; (i.e., the sum of calls to &#39;length&#39; on the
        // &#39;numBuffers&#39; &#39;buffers&#39;) on success, a negative value on error, and
        // the number of bytes newly written from &#39;buffers&#39; (indicating a
        // partial result) otherwise.  On a partial result, load &#39;augStatus&#39;,
        // if supplied, with 0 if &#39;timeout&#39; interrupted this operation, a
        // positive value if an asynchronous event caused an interruption, or a
        // negative value if the atomic OS-level operation transmitted at least
        // one byte, but less than &#39;numBytes&#39;; otherwise, &#39;augStatus&#39; is
        // unmodified.  A partial result typically does not invalidate this
        // channel; hence, this (or another) operation may be retried (with
        // arguments suitably adjusted) with some reasonable hope of success.
        // A negative &quot;status&quot;, however, indicates a permanent error; -1
        // implies that the connection was closed by the peer (but the converse
        // is not guaranteed).  The behavior is undefined unless
        // &#39;0 &lt; numBytes&#39;.  Note that if the &#39;timeout&#39; value has already
        // passed, the &quot;write&quot; operation will still be attempted, but the
        // attempt will not block.

    virtual void invalidate() = 0;
        // Make this channel invalid; no subsequent operations can be completed
        // successfully.

    // ACCESSORS
    virtual int isInvalid() const = 0;
        // Return 1 if this channel is invalid, and 0 otherwise.  Note that
        // once a channel is invalid, no operations can be completed
        // successfully.  Also note that a 0 return value does NOT guarantee
        // that a subsequent I/O operation would not fail.
};

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
