<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlb_hashutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlb_hashutil<br/>
<small>
[<a class="el" href="group__bdlb.html">Package bdlb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a utility of hash functions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html">bdlb</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Hashing Fundamental Types</a> </li>
<li>
<a href="#3.2">Hashing User-defined Types</a> </li>
<li>
<a href="#3.3">Definitions and Formal Statement of No-Funneling Property</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Using Chaining</a> </li>
<li>
<a href="#3.4.2">Example 2: Using Double-Hashing</a> </li>
<li>
<a href="#3.4.3">Example 3: Creating a Generator of Sequential Integers</a> </li>
<li>
<a href="#3.4.4">Example 4: Creating a Character String Generator</a> </li>
<li>
<a href="#3.4.5">Example 5: Creating a Multiple-Field Keys Generator</a> </li>
<li>
<a href="#3.4.6">Example 6: Experimental Results</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a utility of hash functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlb_1_1HashUtil.html">bdlb::HashUtil</a> </td><td>utility for hash functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bdlc_hashtable2, bdeimp_inthash, bdeimp_strhash, <a class="el" href="group__bdlde__crc32.html" title="Provide a mechanism for computing the CRC-32 checksum of a dataset.">Component bdlde_crc32</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a utility <code>struct</code>, <code><a class="el" href="structbdlb_1_1HashUtil.html">bdlb::HashUtil</a></code>, that provides two hash functions, <code>hash1</code> and <code>hash2</code>. These hash functions have a good funneling property, which can be formalized as documented below (see <a href="group__bdlb__hashutil.html#definitions_and_formal_statement_of_no-funneling_property" class="el">Definitions and Formal Statement of No-Funneling Property</a>). In short, these hashes have the property that even if two inputs differ in only a few bits, they have a negligible probability of producing collisions. In addition, these two hash functions produce full 32-bit results and allow hash table sizes to be a power of two. They are fast and reliable. They should work equally well on all types of keys. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The two hash functions <code>hash1</code> and <code>hash2</code> have similar characteristics. <code>hash2</code> is a bit faster than <code>hash1</code>, especially for longer keys; it also does not produce many collisions as determined experimentally for the key types given in the example below. On the other hand, it does not have the formal no-funnel guarantees of <code>hash1</code> which is reasonably fast and provably achieves low collision probability. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Furthermore, this component provides a third hash function <code>hash0</code> that performs a simple hash by taking the modulus of a user specified size on the input key. This hash function has a poor distribution, as the function exhibits a clustering effect when the input keys only differ slightly. However, <code>hash0</code> is about 6 to 8 times faster than <code>hash1</code> and <code>hash2</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In general, use <code>hash0</code> when speed matters, and <code>hash1</code> or <code>hash2</code> when a more thorough hash is needed (e.g., keys exhibit a pattern that results in many collision when using <code>bdeimp</code>, or cost of collision is high but hashing is not a bottleneck). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hashing_fundamental_types"></a> <a class="anchor" id="description.hashing_fundamental_types"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Hashing Fundamental Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to facilitate hashing user-defined types (see next section), this component supports hashing fundamental types in a manner that is both seemingly random (i.e., the hash is good) but predictable (i.e., identical on all platforms, irrespective of endianness). Note that the following expressions for some <code>key</code> of a fundamental integral type: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbdlb_1_1HashUtil.html#ae59c3a17456539f6423aa4552e39ee23">bdlb::HashUtil::hash1</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;key, <span class="keyword">sizeof</span>(key));  <span class="comment">// not recommended</span>
  <a class="code" href="structbdlb_1_1HashUtil.html#ad9c25d1494d9bbb92059ef8b2a7b1cbb">bdlb::HashUtil::hash2</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;key, <span class="keyword">sizeof</span>(key));  <span class="comment">// not recommended</span>
</pre></div><br/>
<br/>
 return values that differ on big- and little-endian platforms if the key size is more than one byte. Instead, the recommended way to hash this <code>key</code> is simply to: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbdlb_1_1HashUtil.html#ae59c3a17456539f6423aa4552e39ee23">bdlb::HashUtil::hash1</a>(key);
  <a class="code" href="structbdlb_1_1HashUtil.html#ad9c25d1494d9bbb92059ef8b2a7b1cbb">bdlb::HashUtil::hash2</a>(key);
</pre></div><br/>
<br/>
 This works if <code>key</code> is of one of the following fundamental types: <br/>
<br/>
<div class="fragment"><pre class="fragment">  char, <span class="keywordtype">signed</span> char, <span class="keywordtype">unsigned</span> char,
  short, <span class="keywordtype">unsigned</span> short,
  int, <span class="keywordtype">unsigned</span> int,
  long, <span class="keywordtype">unsigned</span> long,
  bsls::Types::Int64, bsls::Types::Uint64,
  float, double,
  <span class="keyword">const</span> <span class="keywordtype">void</span> *
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hashing_user-defined_types"></a> <a class="anchor" id="description.hashing_user-defined_types"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Hashing User-defined Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component can be used for hashing a user-defined type as well. The recommended way to do this is to provide a <code>hash</code> class method for the type, that takes an instance of the class and a size. For instance, let us consider the following class (the meaning and implementation are irrelevant here) with the following private data members: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>UserDefinedTickerType {
      <span class="comment">// This class is an aggregate.</span>

      <span class="keyword">enum</span> { CUSIP_LENGTH = 10 };

      <span class="comment">// PRIVATE DATA MEMBERS</span>
      <span class="keywordtype">bool</span>      d_isConstant;          <span class="comment">// not recommended, because of padding</span>
      <span class="keywordtype">char</span>      d_cusip[CUSIP_LENGTH];
      <span class="keywordtype">int</span>       d_value;
</pre></div><br/>
<br/>
 A hash class method can be provided and documented as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> hash(<span class="keyword">const</span> UserDefinedTickerType&amp; <span class="keywordtype">object</span>, <span class="keywordtype">int</span> <a class="code" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size</a>);
          <span class="comment">// Return a hash value calculated from the specified &#39;object&#39; using</span>
          <span class="comment">// the specified &#39;size&#39; as the number of slots.  The hash value</span>
          <span class="comment">// is guaranteed to be in the range [0, size).</span>

      <span class="comment">// Rest of the class definition omitted...</span>
  };
</pre></div><br/>
<br/>
 The implementation of <code>hash</code> can be very simple, depending on the semantics of the class. Here we assume that <code>d_isConstant</code> is an implementation detail and that data members <code>d_cusip</code> and <code>d_value</code> should participate in the hash and that the character string should be hashed by value. The implementation follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> UserDefinedTickerType::hash(<span class="keyword">const</span> UserDefinedTickerType&amp; <span class="keywordtype">object</span>,
                                  <span class="keywordtype">int</span>                          <a class="code" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size</a>)
  {
      <span class="keywordflow">return</span> (<a class="code" href="structbdlb_1_1HashUtil.html#ae59c3a17456539f6423aa4552e39ee23">bdlb::HashUtil::hash1</a>(<span class="keywordtype">object</span>.d_cusip, CUSIP_LENGTH) +
                               <a class="code" href="structbdlb_1_1HashUtil.html#ae59c3a17456539f6423aa4552e39ee23">bdlb::HashUtil::hash1</a>(<span class="keywordtype">object</span>.d_value)) % size;
  }
</pre></div><br/>
<br/>
 Note that more intricate combinations of the individual hashes in the aggregate can be appropriate if the individual members in the aggregate my exhibit a pattern. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>CAVEAT: When hashing user-defined classes, because of the potential padding in the class footprint, the simple-minded hashes <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> UserDefinedTickerType&amp; key;
  <a class="code" href="structbdlb_1_1HashUtil.html#ae59c3a17456539f6423aa4552e39ee23">bdlb::HashUtil::hash1</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;key, <span class="keyword">sizeof</span>(key)); <span class="comment">// wrong, because</span>
  <a class="code" href="structbdlb_1_1HashUtil.html#ad9c25d1494d9bbb92059ef8b2a7b1cbb">bdlb::HashUtil::hash2</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;key, <span class="keyword">sizeof</span>(key)); <span class="comment">// of padding</span>
</pre></div><br/>
<br/>
 may actually <em>not</em> produce the same hash values for copies of the same object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="definitions_and_formal_statement_of_no-funneling_property"></a> <a class="anchor" id="description.definitions_and_formal_statement_of_no-funneling_property"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Definitions and Formal Statement of No-Funneling Property: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Let us say a given bit in the input affects a given bit in the output (which has <code>v</code> bits) if two keys differing only at that input bit will differ at the given output bit about half the time. We define a hash to be a funneling hash if there is some subset of size <code>t</code> of all the input bits that can affect only a subset of size <code>u</code> of bits in the output, and <code>t &gt; u</code> and <code>v &gt; u</code>, and we say that the hash function has a funnel of those <code>t</code> input bits into those <code>u</code> bits. In that case, then <code>u</code> of those <code>t</code> bits can cancel out the effects of the other <code>t - u</code>, and so the set of keys differing only in the input bits of the funnel can produce no more than half that number of hash values. (Those <code>2^t</code> keys can produce no more than <code>2^u</code> out of <code>2^v</code> hash values.) Differing in only a few bits is a common pattern in human and computer keys, so a funneling hash is seriously flawed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component offers a hash function (<code>hash1</code>) that has no funnels, except for a funnel of 32 bits into 31 bits, which is a negligible vulnerability. The <code>hash2</code> does not have known no-funneling properties, but operates on the same principle and is just as good (and faster) in experiments with chaining as in the usage below. In addition, these two hash functions produce full 32-bit results and allow hash table sizes to be a power of two. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For further details and references, the interested reader is invited to consult <code><a href="http://burtleburtle.net/bob/hash/evahash.html">http://burtleburtle.net/bob/hash/evahash.html</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We illustrate the usage of this component by some experiments (code and results) on the number of collision expected for various usage. For returning the results of an experiment, we will use the following structure: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>ExperimentalResult {

      <span class="comment">// DATA MEMBERS</span>
      <span class="keywordtype">int</span>    d_max;     <span class="comment">// maximum length of a chain</span>
      <span class="keywordtype">double</span> d_average; <span class="comment">// average length of a chain</span>
      <span class="keywordtype">double</span> d_sigma;   <span class="comment">// standard deviation</span>

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span>
      ExperimentalResult(<span class="keywordtype">int</span> max = 0, <span class="keywordtype">double</span> avg = 0, <span class="keywordtype">double</span> sigma = 0)
          <span class="comment">// Create an experimental result reporting the optionally specified</span>
          <span class="comment">// &#39;max&#39;, &#39;avg&#39;, and &#39;sigma&#39; values.</span>
      : d_max(max), d_average(avg), d_sigma(sigma)
      {}
  };
</pre></div><br/>
<br/>
 For generating the data, we use a parameterized <code>GENERATOR</code> of which we give three implementations below (sequential integers, character strings, and multiple-field keys). This template parameter needs to validate the following syntactic expressions, which we call in this usage example our <code>GeneratorConcept</code>. In those requirements, <code>generator</code> is an instance of <code>GENERATOR</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> *data   = generator.<a class="code" href="group__bslstl__vector.html#gad98d192f5ea0af3ec3c6b5dabca1faa3">data</a>();   <span class="comment">// address of storage of current</span>
                                           <span class="comment">// value</span>
  <span class="keywordtype">int</span>         length = generator.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>(); <span class="comment">// length of storage of current</span>
                                           <span class="comment">// value</span>

  generator.next();                        <span class="comment">// advance to next value</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_chaining"></a> <a class="anchor" id="usage.example_1~3A_using_chaining"></a> <a class="anchor" id="description.usage.example_1~3A_using_chaining"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using Chaining: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following code will check the number of collisions for a chaining-based hash table given a certain distribution of keys: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> GENERATOR&gt;
  ExperimentalResult computeChainingCollisions(<span class="keywordtype">int</span>       numElements,
                                               <span class="keywordtype">int</span>       size,
                                               GENERATOR input)
      <span class="comment">// Simulate insertion of the specified &#39;numElements&#39; generated by the</span>
      <span class="comment">// specified &#39;input&#39; generator into a hash table of the specified</span>
      <span class="comment">// &#39;size&#39; using chaining as the mechanism to resolve collisions.</span>
      <span class="comment">// Return the results (maximum and average length of a chain, with</span>
      <span class="comment">// standard deviation).  &#39;GENERATOR&#39; must be a model of the</span>
      <span class="comment">// &#39;GeneratorConcept&#39;.  For the good functioning of this function, it</span>
      <span class="comment">// is required that &#39;input&#39; never be default nor repeat itself.</span>
  {
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> table(size);   <span class="comment">// all counters are init&#39;ed to 0</span>

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numElements; ++i, input.next()) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = Util::hash1(input.data(),
                                                   input.length());
          ++table[hash % size];
      }

      <span class="keywordtype">double</span> avgLength    = 0; <span class="comment">// average number of collisions</span>
      <span class="keywordtype">double</span> sigmaLength  = 0; <span class="comment">// standard deviation from average</span>
      <span class="keywordtype">int</span>    maxLength    = 0; <span class="comment">// maximum length of a chain</span>

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; size; ++k) {
          avgLength   += table[k];
          sigmaLength += table[k] * table[k];
          maxLength    = bsl::max(maxLength, table[k]);
      }
      avgLength   /= size;
      sigmaLength  = bsl::sqrt(sigmaLength / size - avgLength * avgLength);

      <span class="keywordflow">return</span> ExperimentalResult(maxLength, avgLength, sigmaLength);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_double-hashing"></a> <a class="anchor" id="usage.example_2~3A_using_double-hashing"></a> <a class="anchor" id="description.usage.example_2~3A_using_double-hashing"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using Double-Hashing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following code will check the number of collisions for a double-hashing based hash table (such as <code>bdlc_hashtable2</code>) given a certain distribution of keys: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> GENERATOR&gt;
  ExperimentalResult computeDoubleHashingCollisions(<span class="keywordtype">int</span>       numElements,
                                                    <span class="keywordtype">int</span>       size,
                                                    GENERATOR input)
      <span class="comment">// Simulate insertion of the specified &#39;numElements&#39; generated by the</span>
      <span class="comment">// specified &#39;input&#39; generator into a hash table of the specified</span>
      <span class="comment">// &#39;size&#39; using double hashing as the mechanism to resolve collisions.</span>
      <span class="comment">// Return the results (maximum and average length of a chain, with</span>
      <span class="comment">// standard deviation).  &#39;GENERATOR&#39; must be a model of the</span>
      <span class="comment">// &#39;GeneratorConcept&#39;.  For the good functioning of this function, it</span>
      <span class="comment">// is required that &#39;input&#39; never be default nor repeat itself.</span>
  {
      <span class="keyword">typedef</span> <span class="keyword">typename</span> GENERATOR::ResultType  ResultType;
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;ResultType&gt;</a> table(size); <span class="comment">// all counters are default-ct&#39;ed</span>

      <span class="keywordtype">double</span> avgLength    = 0; <span class="comment">// average number of collisions</span>
      <span class="keywordtype">double</span> sigmaLength  = 0; <span class="comment">// standard deviation from average</span>
      <span class="keywordtype">int</span>    maxLength    = 0; <span class="comment">// maximum length of a chain</span>

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numElements; ++i, input.next()) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash1 = Util::hash1(input.data(),
                                                    input.length());

          <span class="keywordtype">int</span> chainLength = 0;
          <span class="keywordtype">int</span> bucket      = hash1 % size;
          <span class="keywordflow">if</span> (ResultType() == table[bucket]) {
              table[bucket] = input.current();
          } <span class="keywordflow">else</span> {
              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash2 = Util::hash2(input.data(),
                                                        input.length());
              hash2 = 1 + hash2 % (size - 1);

              <span class="keywordflow">while</span> (++chainLength &lt; size) {
                  bucket = (bucket + hash2) % size;

                  <span class="keywordflow">if</span> (ResultType() == table[bucket]) {
                      table[bucket] = input.current();
                      <span class="keywordflow">break</span>; <span class="comment">// while loop</span>
                  }
              }
          }

          <span class="keywordflow">if</span> (chainLength == size) {
              bsl::cerr &lt;&lt; <span class="stringliteral">&quot;\tCould not insert in doubly-hashed table\n&quot;</span>;
              avgLength   = bsl::numeric_limits&lt;double&gt;::infinity();
              sigmaLength = bsl::numeric_limits&lt;double&gt;::infinity();
              maxLength   = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(
                                    bsl::numeric_limits&lt;double&gt;::infinity());
              <span class="keywordflow">return</span> ExperimentalResult(maxLength, avgLength, sigmaLength);
                                                                    <span class="comment">// RETURN</span>
          }

          avgLength   += chainLength;
          sigmaLength += chainLength * chainLength;
          maxLength    = bsl::max(maxLength, chainLength);
      }
      avgLength   /= numElements;
      sigmaLength  = bsl::sqrt(sigmaLength / numElements
                             -   avgLength * avgLength);

      <span class="keywordflow">return</span> ExperimentalResult(maxLength, avgLength, sigmaLength);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_creating_a_generator_of_sequential_integers"></a> <a class="anchor" id="usage.example_3~3A_creating_a_generator_of_sequential_integers"></a> <a class="anchor" id="description.usage.example_3~3A_creating_a_generator_of_sequential_integers"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Creating a Generator of Sequential Integers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Here is a simple generator that returns a sequence of integers. This generator has a period of <code>INT_MAX / gcd(increment, INT_MAX+1)</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>SequentialIntegers {
      <span class="keywordtype">int</span> d_current;
      <span class="keywordtype">int</span> d_inc;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <span class="keywordtype">int</span> ResultType;
          <span class="comment">// Type returned by this generator.</span>

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> SequentialIntegers(<span class="keywordtype">int</span> first = 1, <span class="keywordtype">int</span> increment = 1)
          <span class="comment">// Create a generator returning integers in a sequence starting at</span>
          <span class="comment">// the optionally specified &#39;first&#39; integer, with the optionally</span>
          <span class="comment">// specified &#39;increment&#39;.</span>
          : d_current(first), d_inc(increment) {}

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> next()
          <span class="comment">// Advance to the next element.</span>
      {
          d_current += d_inc;
      }

      <span class="comment">// ACCESSORS</span>
      ResultType current() const
          <span class="comment">// Return current element.</span>
      {
          <span class="keywordflow">return</span> d_current;
      }

      <span class="keyword">const</span> <span class="keywordtype">char</span> *data() const
          <span class="comment">// Return data buffer of result type.</span>
      {
          <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;d_current);
      }

      <span class="keywordtype">int</span> length() const
          <span class="comment">// Return length of result type (in bytes).</span>
      {
          <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(ResultType);
      }
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_4~3A_creating_a_character_string_generator"></a> <a class="anchor" id="usage.example_4~3A_creating_a_character_string_generator"></a> <a class="anchor" id="description.usage.example_4~3A_creating_a_character_string_generator"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="usage.example_4"></a> <a class="anchor" id="description.usage.example_4"></a> <a class="anchor" id="3.4.4"></a> </dd></dl>
<dl class="user"><dt><b>Example 4: Creating a Character String Generator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Here is a simple generator that returns a sequence of strings that are a permutation of an initial string. This generator has a period of <code>factorial(initial.length())</code> where <code>factorial(N)</code> returns the number of permutations of <code>N</code> distinct elements. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>SequentialStrings {
      <span class="keywordtype">int</span>         d_length;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_current;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> ResultType;
          <span class="comment">// Type returned by this generator.</span>

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> SequentialStrings(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> <span class="keyword">const</span>&amp; initial)
          <span class="comment">// Create a generator returning strings in a sequence starting at</span>
          <span class="comment">// the specified &#39;initial&#39; string (sorted by characters) and</span>
          <span class="comment">// looping through all permutations of &#39;str&#39;.  The behavior is</span>
          <span class="comment">// undefined unless all the characters of the &#39;initial&#39; string are</span>
          <span class="comment">// distinct.</span>
          : d_length(initial.length()), d_current(initial)
      {
          bsl::sort(d_current.begin(), d_current.end());
          assert(bsl::unique(d_current.begin(), d_current.end()) ==
                                                            d_current.end());
      }

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> next()
          <span class="comment">// Advance to the next element.</span>
      {
          bsl::next_permutation(d_current.begin(), d_current.end());
      }

      <span class="comment">// ACCESSORS</span>
      ResultType current() const
          <span class="comment">// Return current element.</span>
      {
          <span class="keywordflow">return</span> d_current;
      }

      <span class="keyword">const</span> <span class="keywordtype">char</span> *data() const
          <span class="comment">// Return data buffer of result type.</span>
      {
          <span class="keywordflow">return</span> d_current.data();
      }
      <span class="keywordtype">int</span> length() const
          <span class="comment">// Return length of result type (in bytes).</span>
      {
          <span class="keywordflow">return</span> d_current.length();
      }
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_5~3A_creating_a_multiple-field_keys_generator"></a> <a class="anchor" id="usage.example_5~3A_creating_a_multiple-field_keys_generator"></a> <a class="anchor" id="description.usage.example_5~3A_creating_a_multiple-field_keys_generator"></a> <a class="anchor" id="example_5"></a> <a class="anchor" id="usage.example_5"></a> <a class="anchor" id="description.usage.example_5"></a> <a class="anchor" id="3.4.5"></a> </dd></dl>
<dl class="user"><dt><b>Example 5: Creating a Multiple-Field Keys Generator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is not uncommon for keys to consist of concatenated keys in multiple combinations. We simulate this by a character string in which each character loops through a specified number of values. The period of this generator is the product of the length of each character range. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>SequentialVector {
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;char&gt;</a> d_ranges;
      <span class="keywordtype">int</span>               d_length;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       d_current;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> ResultType;
          <span class="comment">// Type returned by this generator.</span>

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> SequentialVector(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;char&gt;</a> <span class="keyword">const</span>&amp; ranges)
          <span class="comment">// Create a generator returning strings having the same length as</span>
          <span class="comment">// the specified &#39;ranges&#39; (i.e., &#39;ranges.size()&#39;) in a sequence</span>
          <span class="comment">// starting at the string with all null characters and looping</span>
          <span class="comment">// through all the strings with each character at position &#39;i&#39; in</span>
          <span class="comment">// the specified range from 0 until &#39;ranges[i]&#39; (excluded).  The</span>
          <span class="comment">// behavior is undefined unless &#39;ranges&#39; does not contain zero</span>
          <span class="comment">// entries.</span>
          : d_ranges(ranges)
          , d_length(ranges.size())
          , d_current(d_length, (char)0)
      {
      }

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> next()
          <span class="comment">// Advance to the next element.</span>
      {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;
               i &lt; d_length &amp;&amp; ++d_current[i] == d_ranges[i]; ++i) {
              d_current[i] = 0;
          }
      }

      <span class="comment">// ACCESSORS</span>
      ResultType current() const
          <span class="comment">// Return current element.</span>
      {
          <span class="keywordflow">return</span> d_current;
      }

      <span class="keyword">const</span> <span class="keywordtype">char</span> *data() const
          <span class="comment">// Return data buffer of current value.</span>
      {
          <span class="keywordflow">return</span> d_current.data();
      }

      <span class="keywordtype">int</span> length() const
          <span class="comment">// Return length of current value (in bytes).</span>
      {
          <span class="keywordflow">return</span> d_current.length();
      }
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_6~3A_experimental_results"></a> <a class="anchor" id="usage.example_6~3A_experimental_results"></a> <a class="anchor" id="description.usage.example_6~3A_experimental_results"></a> <a class="anchor" id="example_6"></a> <a class="anchor" id="usage.example_6"></a> <a class="anchor" id="description.usage.example_6"></a> <a class="anchor" id="3.4.6"></a> </dd></dl>
<dl class="user"><dt><b>Example 6: Experimental Results: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Checking the above distributions is done in a straightforward manner. We do this at various load factors (the load factor is the percentage of the table that actually holds data; it is defined as <code>N / SIZE</code> where <code>N</code> is the number of elements and <code>SIZE</code> is the size of the hash table). Note that chaining accommodates arbitrary load factors, while double hashing requires that the load factor be strictly less than 1. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample(<span class="keywordtype">int</span> verbose, <span class="keywordtype">int</span> veryVerbose, <span class="keywordtype">int</span> <span class="comment">/* veryVeryVerbose */</span>) {
      <span class="keyword">const</span> <span class="keywordtype">int</span> SIZE = 10000;
      <span class="keyword">const</span> <span class="keywordtype">int</span> INC  = SIZE / 5; <span class="comment">// load factors for every 20% percentile</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> COLS = (4*SIZE)/INC;

      {
          ExperimentalResult results[3][COLS];
          <a class="code" href="classbsls_1_1Stopwatch.html">bsls::Stopwatch</a>    timer;

          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\nUsing chaining&quot;</span>
                            &lt;&lt; <span class="stringliteral">&quot;\n--------------&quot;</span> &lt;&lt; endl;

          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Sequential Integers\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5cd3418895715a184ca946af1228f3bb">start</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = INC, i = 0; n &lt; 4*SIZE; n += INC, ++i) {
              <span class="keywordflow">if</span> (veryVerbose)
                  cout &lt;&lt; <span class="stringliteral">&quot;\tWith load factor &quot;</span> &lt;&lt;
                                       <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / SIZE &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

              results[0][i] = computeChainingCollisions(
                                                       n,
                                                       SIZE,
                                                       SequentialIntegers());
              assert(results[0][i].d_average &lt; 1.5 * n / SIZE);
          }
          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\t... in &quot;</span> &lt;&lt; timer.<a class="code" href="classbsls_1_1Stopwatch.html#ac288613266a9c668b1101e9d7e9982ce">elapsedTime</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#ad3041f7bc88c5448d58d8231d5d6bd06">reset</a>();

          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Sequential Strings\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5cd3418895715a184ca946af1228f3bb">start</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = INC, i = 0; n &lt; 4*SIZE; n += INC, ++i) {
              <span class="keywordflow">if</span> (veryVerbose)
                  cout &lt;&lt; <span class="stringliteral">&quot;\tWith load factor &quot;</span> &lt;&lt;
                                       <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / SIZE &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

              <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> initial(<span class="stringliteral">&quot;abcdefghij&quot;</span>); <span class="comment">// period = 10! = 3628800</span>
              results[1][i] = computeChainingCollisions(
                                                 n,
                                                 SIZE,
                                                 SequentialStrings(initial));
              assert(results[1][i].d_average &lt; 1.5 * n / SIZE);
          }
          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\t... in &quot;</span> &lt;&lt; timer.<a class="code" href="classbsls_1_1Stopwatch.html#ac288613266a9c668b1101e9d7e9982ce">elapsedTime</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#ad3041f7bc88c5448d58d8231d5d6bd06">reset</a>();

          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Sequential Vector\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5cd3418895715a184ca946af1228f3bb">start</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = INC, i = 0; n &lt; 4*SIZE; n += INC, ++i) {
              <span class="keywordflow">if</span> (veryVerbose)
                  cout &lt;&lt; <span class="stringliteral">&quot;\tWith load factor &quot;</span> &lt;&lt;
                                       <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / SIZE &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

              <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;char&gt;</a> ranges(6, static_cast&lt;char&gt;(4));
                                                       <span class="comment">// period = 4^6 = 4096</span>
              results[2][i] = computeChainingCollisions(
                                                   n,
                                                   SIZE,
                                                   SequentialVector(ranges));
              assert(results[2][i].d_average &lt; 1.5 * n / SIZE);
          }
          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\t... in &quot;</span> &lt;&lt; timer.<a class="code" href="classbsls_1_1Stopwatch.html#ac288613266a9c668b1101e9d7e9982ce">elapsedTime</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#ad3041f7bc88c5448d58d8231d5d6bd06">reset</a>();

          <span class="keywordflow">if</span> (verbose) {
              cout &lt;&lt; <span class="stringliteral">&quot;\nDisplaying average (max) for chaining:&quot;</span>;
              cout &lt;&lt; <span class="stringliteral">&quot;\n--------------------------------------n&quot;</span>;
              <span class="keyword">const</span> <span class="keywordtype">char</span> *ROW_LABELS[] = { <span class="stringliteral">&quot;\nIntegers:&quot;</span>,
                                           <span class="stringliteral">&quot;\nStrings :&quot;</span>,
                                           <span class="stringliteral">&quot;\nVector  :&quot;</span>,
                                           <span class="stringliteral">&quot;\nLoad factor:&quot;</span>,
              };
              <span class="keyword">const</span> <span class="keywordtype">int</span>   NUM_ROWS     = <span class="keyword">sizeof</span>  ROW_LABELS
                                       / <span class="keyword">sizeof</span> *ROW_LABELS - 1;

              cout &lt;&lt; ROW_LABELS[NUM_ROWS] &lt;&lt; bsl::setprecision(2);
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = INC; n &lt; 4*SIZE; n += INC) {
                  cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / SIZE;
              }
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; NUM_ROWS; ++j) {
                  cout &lt;&lt; ROW_LABELS[j];
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; COLS; ++i) {
                      cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; results[j][i].d_average;
                      cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; results[j][i].d_max &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
                  }
                  cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
              }
          }
      }
</pre></div><br/>
<br/>
 We repeat the same steps with double hashing, except that due to the nature of the collision-resolution mechanism, the tolerance for the average must be slightly increased to 2.5 times the load factor, when the load factor is high. <br/>
<br/>
<div class="fragment"><pre class="fragment">      {
          <span class="comment">// const int SIZE = 1000003;   // must be a prime number</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> SIZE = 10007;     <span class="comment">// must be a prime number</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> INC  = SIZE / 5; <span class="comment">// load factors for every 20% percentile</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> COLS = SIZE/INC;

          ExperimentalResult results[3][COLS];
          <a class="code" href="classbsls_1_1Stopwatch.html">bsls::Stopwatch</a>    timer;

          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\nUsing double hashing&quot;</span>
                            &lt;&lt; <span class="stringliteral">&quot;\n--------------------&quot;</span> &lt;&lt; endl;

          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Sequential Integers\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5cd3418895715a184ca946af1228f3bb">start</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = INC/2, i = 0; n &lt; SIZE; n += INC, ++i) {
              <span class="keywordflow">if</span> (veryVerbose)
                  cout &lt;&lt; <span class="stringliteral">&quot;\tWith load factor &quot;</span> &lt;&lt;
                                       <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / SIZE &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

              results[0][i] = computeDoubleHashingCollisions(
                                                       n,
                                                       SIZE,
                                                       SequentialIntegers());
              assert(results[0][i].d_average &lt; 2.5 * n / SIZE);
          }
          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\t... in &quot;</span> &lt;&lt; timer.<a class="code" href="classbsls_1_1Stopwatch.html#ac288613266a9c668b1101e9d7e9982ce">elapsedTime</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#ad3041f7bc88c5448d58d8231d5d6bd06">reset</a>();

          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Sequential Strings\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5cd3418895715a184ca946af1228f3bb">start</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = INC/2, i = 0; n &lt; SIZE; n += INC, ++i) {
              <span class="keywordflow">if</span> (veryVerbose)
                  cout &lt;&lt; <span class="stringliteral">&quot;\tWith load factor &quot;</span> &lt;&lt;
                                       <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / SIZE &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

              <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> initial(<span class="stringliteral">&quot;abcdefghij&quot;</span>); <span class="comment">// period = 10! = 3628800</span>
              results[1][i] = computeDoubleHashingCollisions(
                                                 n,
                                                 SIZE,
                                                 SequentialStrings(initial));
              assert(results[1][i].d_average &lt; 2.5 * n / SIZE);
          }
          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\t... in &quot;</span> &lt;&lt; timer.<a class="code" href="classbsls_1_1Stopwatch.html#ac288613266a9c668b1101e9d7e9982ce">elapsedTime</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#ad3041f7bc88c5448d58d8231d5d6bd06">reset</a>();

          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Sequential Vector\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5cd3418895715a184ca946af1228f3bb">start</a>();
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = INC/2, i = 0; n &lt; SIZE; n += INC, ++i) {
              <span class="keywordflow">if</span> (veryVerbose)
                  cout &lt;&lt; <span class="stringliteral">&quot;\tWith load factor &quot;</span> &lt;&lt;
                                       <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / SIZE &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

              <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;char&gt;</a> ranges(7, static_cast&lt;char&gt;(8));
                                                    <span class="comment">// period = 8^7 = 2097152</span>
              results[2][i] = computeDoubleHashingCollisions(
                                                   n,
                                                   SIZE,
                                                   SequentialVector(ranges));
              assert(results[2][i].d_average &lt; 2.5 * n / SIZE);
          }
          <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\t... in &quot;</span> &lt;&lt; timer.<a class="code" href="classbsls_1_1Stopwatch.html#ac288613266a9c668b1101e9d7e9982ce">elapsedTime</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
          timer.<a class="code" href="classbsls_1_1Stopwatch.html#ad3041f7bc88c5448d58d8231d5d6bd06">reset</a>();

          <span class="keywordflow">if</span> (verbose) {
              cout &lt;&lt; <span class="stringliteral">&quot;\nDisplaying average (max) for double-hashing:&quot;</span>;
              cout &lt;&lt; <span class="stringliteral">&quot;\n--------------------------------------------\n&quot;</span>;
              <span class="keyword">const</span> <span class="keywordtype">char</span> *ROW_LABELS[] = { <span class="stringliteral">&quot;\nIntegers:&quot;</span>,
                                           <span class="stringliteral">&quot;\nStrings :&quot;</span>,
                                           <span class="stringliteral">&quot;\nVector  :&quot;</span>,
                                           <span class="stringliteral">&quot;\nLoad factor:&quot;</span>,
              };
              <span class="keyword">const</span> <span class="keywordtype">int</span>   NUM_ROWS     = <span class="keyword">sizeof</span>  ROW_LABELS
                                       / <span class="keyword">sizeof</span> *ROW_LABELS -1;

              cout &lt;&lt; ROW_LABELS[NUM_ROWS] &lt;&lt; bsl::setprecision(2);
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = INC/2; n &lt; SIZE; n += INC) {
                  cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / SIZE;
              }
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; NUM_ROWS; ++j) {
                  cout &lt;&lt; ROW_LABELS[j];
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; COLS; ++i) {
                      cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; results[j][i].d_average;
                      cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; results[j][i].d_max &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
                  }
                  cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
              }
          }
      }

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 The above code produces the following results. The results for chaining are identical for <code>hash1</code> (used in the code above) or <code>hash2</code> (code identical except <code>hash2</code> is used in place of <code>hash1</code> in <code>computeChainingCollisions</code>). <br/>
<br/>
<div class="fragment"><pre class="fragment">  Displaying average(max) for chaining:
  ---------------------------------------------------------------------------
  Load factor:    0.2     0.4     0.6     0.8     1       1.2     1.4
  Integers:       0.2(3)  0.4(5)  0.6(6)  0.8(6)  1(7)    1.2(7)  1.4(8)
  Strings :       0.2(4)  0.4(4)  0.6(5)  0.8(7)  1(7)    1.2(7)  1.4(7)
  Vector  :       0.2(5)  0.4(5)  0.6(10) 0.8(10) 1(15)   1.2(15) 1.4(20)

  Load factor:    1.6     1.8     2       2.2     2.4     2.6     2.8
  Integers:       1.6(9)  1.8(9)  2(10)   2.2(10) 2.4(10) 2.6(10) 2.8(11)
  Strings :       1.6(7)  1.8(8)  2(9)    2.2(11) 2.4(11) 2.6(11) 2.8(11)
  Vector  :       1.6(20) 1.8(24) 2(25)   2.2(29) 2.4(30) 2.6(34) 2.8(35)

  Load factor:    3       3.2     3.4     3.6     3.8
  Integers:       3(11)   3.2(11) 3.4(12) 3.6(12) 3.8(13)
  Strings :       3(12)   3.2(12) 3.4(13) 3.6(13) 3.8(13)
  Vector  :       3(39)   3.2(40) 3.4(42) 3.6(45) 3.8(46)

  Displaying average(max) for <span class="keywordtype">double</span>-hashing:
  ---------------------------------------------------------------------------
  Load factor:    0.1      0.3     0.5      0.7      0.9
  Integers:       0.046(2) 0.20(4) 0.37(10) 0.71(15) 1.6(59)
  Strings :       0.064(2) 0.20(6) 0.40(12) 0.75(18) 1.6(50)
  Vector  :       0.05(2)  0.19(5) 0.58(9)  1.20(15) 2.4(64)
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:34 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
