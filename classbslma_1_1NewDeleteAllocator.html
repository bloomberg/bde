<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Class bslma::NewDeleteAllocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslma.html">bslma</a>      </li>
      <li><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslma::NewDeleteAllocator Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslma::NewDeleteAllocator" --><!-- doxytag: inherits="bslma::Allocator" -->
<p><code>#include &lt;<a class="el" href="bslma__newdeleteallocator_8h_source.html">bslma_newdeleteallocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bslma::NewDeleteAllocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbslma_1_1NewDeleteAllocator.png" usemap="#bslma::NewDeleteAllocator_map" alt=""/>
  <map id="bslma::NewDeleteAllocator_map" name="bslma::NewDeleteAllocator_map">
<area href="classbslma_1_1Allocator.html" alt="bslma::Allocator" shape="rect" coords="0,0,162,24"/>
</map>
</div>

<p><a href="classbslma_1_1NewDeleteAllocator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsls_1_1Types.html#a6f54590881ef3285caf09a9ec4498046">bsls::Types::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1NewDeleteAllocator.html#ae090a1afd3162367a94ac204d6e30b58">NewDeleteAllocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1NewDeleteAllocator.html#a0b7fb53114fd9b7f9ec2a412ff11b93f">~NewDeleteAllocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1NewDeleteAllocator.html#a4467a22d277e8c0454909d4aad3159af">allocate</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1NewDeleteAllocator.html#a481b3511a0cd4ae014c9d04b38b8e377">deallocate</a> (void *address)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a0e51fc2d107684523cc66bf65293dc37">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a> (const TYPE *object)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbslma_1_1NewDeleteAllocator.html">NewDeleteAllocator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1NewDeleteAllocator.html#a1d38f6dd5b0f1cf4744c4cf7bcb69da1">singleton</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1NewDeleteAllocator.html#a969932d0e1d15fbb2f4b6f7f03d5579e">allocator</a> (<a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a404c0ae3c51f8122a6ca3a62aba8dbf1">throwBadAlloc</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class defines a concrete mechanism that adapts the system-supplied (native) global <code>operator new</code> and <code>operator delete</code> to the <code><a class="el" href="classbslma_1_1Allocator.html">Allocator</a></code> protocol. The class method <code>singleton</code> returns a process-wide unique object of this class whose lifetime is guaranteed to extend from the first call to <code>singleton</code> until the program terminates. A second class method, <code>allocator</code>, allows for conveniently replacing a "null" allocator with this singleton object. Note that this entire class should generally not be used directly by typical clients (see <code>bslma_default</code> for more information). </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a07cd3ddf3fba145a0469a4e867047287"></a><!-- doxytag: member="bslma::NewDeleteAllocator::size_type" ref="a07cd3ddf3fba145a0469a4e867047287" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsls_1_1Types.html#a6f54590881ef3285caf09a9ec4498046">bsls::Types::size_type</a> <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TBD change to unsigned? </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae090a1afd3162367a94ac204d6e30b58"></a><!-- doxytag: member="bslma::NewDeleteAllocator::NewDeleteAllocator" ref="ae090a1afd3162367a94ac204d6e30b58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslma::NewDeleteAllocator::NewDeleteAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a ("stateless") new-delete-allocator object that wraps the global native <code>operator new</code> and <code>operator delete</code> functions in order to supply memory via the <code><a class="el" href="classbslma_1_1Allocator.html">Allocator</a></code> protocol. Note that all objects of this class share the same underlying resource; hence, this constructor should generally not be invoked directly by clients; instead, consider using the <code>static</code> <code>singleton</code> or <code>allocator</code> (factory) methods, or -- better -- the appropriate ones in <code><a class="el" href="structbslma_1_1Default.html">Default</a></code> (see <code>bslma_default</code> for more information). </p>

</div>
</div>
<a class="anchor" id="a0b7fb53114fd9b7f9ec2a412ff11b93f"></a><!-- doxytag: member="bslma::NewDeleteAllocator::~NewDeleteAllocator" ref="a0b7fb53114fd9b7f9ec2a412ff11b93f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bslma::NewDeleteAllocator::~NewDeleteAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this allocator object. Note that destroying this allocator has no effect on any outstanding allocated memory. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1d38f6dd5b0f1cf4744c4cf7bcb69da1"></a><!-- doxytag: member="bslma::NewDeleteAllocator::singleton" ref="a1d38f6dd5b0f1cf4744c4cf7bcb69da1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslma_1_1NewDeleteAllocator.html">NewDeleteAllocator</a>&amp; bslma::NewDeleteAllocator::singleton </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to a process-wide unique object of this class. The lifetime of this object is guaranteed to extend from the first call of this method until the program terminates. Note that this method should generally not be used directly by typical clients (see <code>bslma_default</code> for more information). </p>

</div>
</div>
<a class="anchor" id="a969932d0e1d15fbb2f4b6f7f03d5579e"></a><!-- doxytag: member="bslma::NewDeleteAllocator::allocator" ref="a969932d0e1d15fbb2f4b6f7f03d5579e" args="(Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslma_1_1Allocator.html">Allocator</a>* bslma::NewDeleteAllocator::allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the specified modifiable <code>basicAllocator</code> or, if <code>basicAllocator</code> is 0, the process-wide unique (see <code>singleton</code>) object of this class. Note that the behavior of this function is equivalent to the following expression: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          basicAllocator
          ? basicAllocator
          : &amp;<a class="code" href="classbslma_1_1NewDeleteAllocator.html#a1d38f6dd5b0f1cf4744c4cf7bcb69da1">NewDeleteAllocator::singleton</a>()
</pre></div><p><br/>
<br/>
 Also note that if a <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">NewDeleteAllocator</a></code> object is supplied, it is owned by the class and must NOT be deleted. Finally note that this method should generally not be called directly by typical clients (see <code>bdema_default</code> for more information). </p>

</div>
</div>
<a class="anchor" id="a4467a22d277e8c0454909d4aad3159af"></a><!-- doxytag: member="bslma::NewDeleteAllocator::allocate" ref="a4467a22d277e8c0454909d4aad3159af" args="(size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* bslma::NewDeleteAllocator::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a newly allocated block of memory of (at least) the specified positive <code>size</code> (in bytes). If <code>size</code> is 0, a null pointer is returned with no other effect. The alignment of the address returned is the maximum alignment for any fundamental, pointer, or enumerated type defined for this platform. The behavior is undefined unless <code>0 &lt;= size</code>. Note that global <code>operator new</code> is <em>not</em> called when <code>size</code> is 0 (in order to avoid having to acquire a lock, and potential contention in multi-threaded programs). </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a481b3511a0cd4ae014c9d04b38b8e377"></a><!-- doxytag: member="bslma::NewDeleteAllocator::deallocate" ref="a481b3511a0cd4ae014c9d04b38b8e377" args="(void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bslma::NewDeleteAllocator::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the memory block at the specified <code>address</code> back to this allocator. If <code>address</code> is 0, this function has no effect. The behavior is undefined unless <code>address</code> was allocated using this allocator object and has not already been deallocated. Note that global <code>operator delete</code> is <em>not</em> called when <code>address</code> is 0 (in order to avoid having to acquire a lock, and potential contention in multi-threaded programs). </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a404c0ae3c51f8122a6ca3a62aba8dbf1"></a><!-- doxytag: member="bslma::NewDeleteAllocator::throwBadAlloc" ref="a404c0ae3c51f8122a6ca3a62aba8dbf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslma::Allocator::throwBadAlloc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TBD does this belong here? </p>

</div>
</div>
<a class="anchor" id="a0e51fc2d107684523cc66bf65293dc37"></a><!-- doxytag: member="bslma::NewDeleteAllocator::deleteObject" ref="a0e51fc2d107684523cc66bf65293dc37" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this allocator and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="abeccfe6cfd8205faf528a8e12f97aebe"></a><!-- doxytag: member="bslma::NewDeleteAllocator::deleteObjectRaw" ref="abeccfe6cfd8205faf528a8e12f97aebe" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code> was allocated using this allocator, is <b>not</b> a secondary base class pointer -- i.e., the address is (numerically) the same as when it was originally dispensed by this allocator, and has not already been deallocated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslma__newdeleteallocator_8h_source.html">bslma_newdeleteallocator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:53 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
