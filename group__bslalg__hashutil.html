<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslalg_hashutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_hashutil<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a utility of hash functions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Dumping out hash values</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a utility of hash functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslalg_1_1HashUtil.html">bslalg::HashUtil</a> </td><td>utility for hash functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a namespace class, <code>HashUtil</code>, for hash functions. At the current time it has one hash function, <code>HashUtil::computeHash</code>, which will hash most fundamental types, and pointers, rapidly. Note that when a pointer is passed, only the bits in the pointer itself are hashed, the memory the pointer refers to is not examined. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Dumping out hash values: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to analyze our hash function by seeing how it distributes integers across buckets. We will declare 64 buckets, and distribute hits among the bucket by indexing them with the low order 6 bits of the hash. Then we will display the distribution of hits in each bucket, to see if the hash function is distributing them evenly. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> buckets[64];
</pre></div><br/>
<br/>
 First, we hash on the values of i in the range <code>[ 0, 1 &lt;&lt; 15 )</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (1 &lt;&lt; 15); ++i) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = <a class="code" href="structbslalg_1_1HashUtil.html#a6c8ffaadc9ff7269d8a7195a725948df">bslalg::HashUtil::computeHash</a>(i);

          ++buckets[hash &amp; 63];
      }
      <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;Straight hash:\n&quot;</span>);
      <span class="keywordtype">int</span> col = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 64; ++i) {
          <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;%s%5d&quot;</span>, (0 == col ? <span class="stringliteral">&quot;    &quot;</span> : <span class="stringliteral">&quot;, &quot;</span>),
                                                            buckets[i]);
          ++col;
          <span class="keywordflow">if</span> (8 == col) {
              col = 0;
              <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\n&quot;</span>);
          }
      }
  }
</pre></div><br/>
<br/>
 Then, we will hash on the values of <code>4 * i</code> for i in the range <code>[ 0, 1 &lt;&lt; 15 )</code>. This is interesting because pointers will often be 4-byte aligned and have the 2 low-order bits always zero, so this will be a simulation of that: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (1 &lt;&lt; 15); ++i) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = <a class="code" href="structbslalg_1_1HashUtil.html#a6c8ffaadc9ff7269d8a7195a725948df">bslalg::HashUtil::computeHash</a>(4 * i);

          ++buckets[hash &amp; 63];
      }
      <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\nStraight * 4 hash:\n&quot;</span>);
      <span class="keywordtype">int</span> col = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 64; ++i) {
          <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;%s%5d&quot;</span>, (0 == col ? <span class="stringliteral">&quot;    &quot;</span> : <span class="stringliteral">&quot;, &quot;</span>),
                                                            buckets[i]);
          ++col;
          <span class="keywordflow">if</span> (8 == col) {
              col = 0;
              <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\n&quot;</span>);
          }
      }
  }
</pre></div><br/>
<br/>
 Next, we will xor the bottom 30 bits of the hash into the bottom 6 bits, so we'll be observing more of the whole word: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (1 &lt;&lt; 15); ++i) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = <a class="code" href="structbslalg_1_1HashUtil.html#a6c8ffaadc9ff7269d8a7195a725948df">bslalg::HashUtil::computeHash</a>(i);
          hash = hash ^ (hash &gt;&gt; 6) ^ (hash &gt;&gt; 12) ^ (hash &gt;&gt; 18) ^
                        (hash &gt;&gt; 24);

          ++buckets[hash &amp; 63];
      }
      <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\nFolded hash:\n&quot;</span>);
      <span class="keywordtype">int</span> col = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 64; ++i) {
          <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;%s%5d&quot;</span>, (0 == col ? <span class="stringliteral">&quot;    &quot;</span> : <span class="stringliteral">&quot;, &quot;</span>),
                                                            buckets[i]);
          ++col;
          <span class="keywordflow">if</span> (8 == col) {
              col = 0;
              <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\n&quot;</span>);
          }
      }
  }
</pre></div><br/>
<br/>
 Now, bear in mind that an identity hash will perform very optimally on the first and third tests we did. This time we will take the difference between the current hash and the previous one, a test for which the identity function would perform abominably: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> prev = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (1 &lt;&lt; 15); ++i) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = <a class="code" href="structbslalg_1_1HashUtil.html#a6c8ffaadc9ff7269d8a7195a725948df">bslalg::HashUtil::computeHash</a>(i);

          ++buckets[(hash - prev) &amp; 63];
          prev = hash;
      }
      <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\nDiff hash:\n&quot;</span>);
      <span class="keywordtype">int</span> col = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 64; ++i) {
          <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;%s%5d&quot;</span>, (0 == col ? <span class="stringliteral">&quot;    &quot;</span> : <span class="stringliteral">&quot;, &quot;</span>),
                                                            buckets[i]);
          ++col;
          <span class="keywordflow">if</span> (8 == col) {
              col = 0;
              <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\n&quot;</span>);
          }
      }
  }
</pre></div><br/>
<br/>
 Finally, take the difference between the previous hash and the current one, only this time, instead of subtracting, take a bitwise xor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> prev = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (1 &lt;&lt; 15); ++i) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = <a class="code" href="structbslalg_1_1HashUtil.html#a6c8ffaadc9ff7269d8a7195a725948df">bslalg::HashUtil::computeHash</a>(i);

          ++buckets[(hash ^ prev) &amp; 63];
          prev = hash;
      }
      <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\nXor diff hash:\n&quot;</span>);
      <span class="keywordtype">int</span> col = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 64; ++i) {
          <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;%s%5d&quot;</span>, (0 == col ? <span class="stringliteral">&quot;    &quot;</span> : <span class="stringliteral">&quot;, &quot;</span>),
                                                            buckets[i]);
          ++col;
          <span class="keywordflow">if</span> (8 == col) {
              col = 0;
              <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\n&quot;</span>);
          }
      }
  }
</pre></div><br/>
<br/>
 The output produced by this usage example follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Straight hash:
        508,   501,   511,   502,   522,   524,   515,   500
        501,   519,   523,   520,   495,   514,   540,   497
        500,   523,   525,   518,   491,   515,   527,   509
        513,   500,   511,   520,   487,   515,   505,   520
        519,   516,   505,   534,   507,   514,   522,   517
        538,   514,   510,   510,   531,   491,   513,   506
        515,   497,   504,   496,   541,   508,   501,   523
        501,   523,   485,   492,   517,   510,   503,   534

  Straight * 4 hash:
        513,   512,   493,   517,   514,   472,   501,   527
        528,   504,   527,   507,   516,   494,   534,   514
        517,   500,   513,   533,   507,   499,   511,   540
        492,   518,   530,   522,   503,   522,   505,   494
        520,   492,   490,   508,   538,   560,   522,   487
        521,   516,   493,   491,   532,   504,   497,   530
        495,   534,   537,   504,   487,   525,   533,   497
        510,   499,   511,   506,   523,   512,   498,   517

  Folded hash:
        537,   493,   517,   544,   501,   508,   535,   528
        502,   530,   536,   541,   500,   475,   540,   510
        521,   513,   501,   525,   497,   511,   521,   513
        522,   523,   479,   479,   508,   490,   507,   523
        577,   490,   520,   514,   493,   465,   468,   511
        518,   544,   503,   484,   550,   514,   517,   500
        510,   501,   542,   528,   517,   456,   513,   530
        518,   484,   510,   506,   522,   477,   563,   493

  Diff hash:
        329,   329,   526,   660,   755,   726,   466,   398
        235,   410,   424,   713,   695,   714,   535,   314
        342,   274,   598,   662,   711,   772,   498,   463
        268,   360,   399,   655,   672,   694,   584,   311
        404,   282,   601,   678,   660,   661,   418,   377
        245,   425,   462,   762,   682,   627,   588,   295
        369,   331,   529,   712,   659,   688,   418,   357
        238,   387,   467,   687,   730,   695,   540,   302

  Xor diff hash:
        329,   142,   535,   475,   781,   800,   567,   510
        258,   258,   378,   549,   664,   906,   477,   496
        298,   118,   554,   467,   765,   883,   576,   418
        233,   226,   375,   608,   633,   903,   422,   388
        404,   133,   648,   412,   658,   896,   521,   459
        258,   256,   383,   601,   699,   836,   511,   599
        413,   169,   660,   450,   658,   826,   524,   560
        237,   255,   383,   573,   706,   834,   539,   715
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
