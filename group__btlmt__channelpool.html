<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlmt_channelpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlmt_channelpool<br/>
<small>
[<a class="el" href="group__btlmt.html">Package btlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide thread-enabled stream-based IPv4 communication.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlmt.html">btlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Message Management and Delivery</a> </li>
<li>
<a href="#3.2">Channel Identification</a> </li>
<li>
<a href="#3.3">Asynchronous Connect</a> </li>
<li>
<a href="#3.4">Half-Open Connections</a> </li>
<li>
<a href="#3.5">Resource Limits</a> </li>
<li>
<a href="#3.6">Behavior on <code>fork</code></a> </li>
<li>
<a href="#3.7">Metrics and Capacity</a> </li>
<li>
<a href="#3.8">Thread Safety</a> </li>
<li>
<a href="#3.9">Invocation of High- and Low-Water Mark Callbacks</a> </li>
<li>
<a href="#3.10">Usage</a> <ul>
<li>
<a href="#3.10.1">Example 1: Establishing a Connection</a> </li>
<li>
<a href="#3.10.2">Example 2: Implementing an Echo Server</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide thread-enabled stream-based IPv4 communication. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a> </td><td>channel manager  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlmt__channelpoolconfiguration.html" title="Provide a class for configuring channel pools.">Component btlmt_channelpoolconfiguration</a>, <a class="el" href="group__btlmt__sessionpool.html" title="Provide thread-enabled session-based IPv4 communication.">Component btlmt_sessionpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-enabled manager of IPv4-based byte-stream communication channels. The channels are created automatically when the appropriate events occur and destroyed based on user requests. A new channel is allocated automatically when an incoming connection is accepted, or when the user explicitly requests a connection to a server. Channel pool provides both client (aka connector) and server (aka acceptor) functionality. The channel pool manages efficient delivery of messages to/from the user based on configuration information supplied at construction. The states of individual messages are <em>not</em> reported; rather, channel pool notifies the user when a channel's state changes. It also notifies the user when the pool's state is affected and provides the classification of errors. The notification is done via asynchronous callback that may be invoked from <em>any</em> (managed) thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="message_management_and_delivery"></a> <a class="anchor" id="description.message_management_and_delivery"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Message Management and Delivery: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The channel pool provides an efficient mechanism for the full-duplex delivery of messages trying to achieve fully parallel communication on a socket whenever possible. If a particular socket's system buffers are full, the messages are queued up to a certain (user-defined) limit, at which point an alert is generated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The channel pool tries to achieve optimal performance by enabling zero-copy semantics whenever appropriate. On the read side, a message is read into a buffer that is subsequently passed to the user (via the <code>BlobBasedReadCallback</code>) for accessing and eventual deallocation. On the write side, the channel pool adopts ownership of the buffers passed to <code>write()</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="channel_identification"></a> <a class="anchor" id="description.channel_identification"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Channel Identification: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each channel is identified by an integer ID that is (a) assigned by the channel pool and (b) is guaranteed to be unique for the lifetime of the channel pool. The user can rely on this uniqueness to identify channels. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="asynchronous_connect"></a> <a class="anchor" id="description.asynchronous_connect"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Asynchronous Connect: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The channel pool supports an extended asynchronous connect mechanism, by which the pool will try to establish a connection with the server making up to a (user-provided) number of attempts with a (user-provided) interval between attempts. If a connection attempt cannot succeed within an interval, it is aborted and a new connection request is issued. If a connection is successfully established, the channel state callback (see configuration) is invoked. In that case, if this connection is dropped at a later time, channel pool <em>will</em> <em>not</em> <em>try</em> to reconnect automatically. If <em>all</em> attempts to establish a connection fail, then a pool state callback (see configuration) is invoked. Once initiated, a connect request can lead to only two outcomes -- success or failure. In particular, it can't be canceled. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="half-open_connections"></a> <a class="anchor" id="description.half-open_connections"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Half-Open Connections: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is already possible to import a half-duplex connection into a channel pool, but should any half of any channel be closed, the channel pool would always close the channel (both halves). A new feature, introduced in BCE 1.5.0, allows to keep half-open channels, i.e., single-duplex connections. In particular, it is possible at the creation of the channel to specify what the channel pool should do if only half of the channel is closed. Passing in the following optional parameter (of enumeration type <code><a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">btlmt::ChannelPool::KeepHalfOpenMode</a></code>) to <code>close</code>, <code>import</code>, or <code>listen</code> has the following behavior. <br/>
<br/>
<div class="fragment"><pre class="fragment">  e_KEEP_HALF_OPEN    If a peer closes its write part of the channel,
                      but keeps its receive part open, then the channel pool
                      will keep sending messages to the peer, but will
                      disable reading on the channel.  If a peer closes its
                      receive part of the channel, but keeps its write part
                      open, then the channel pool will keep reading enable
                      on <span class="keyword">this</span> channel, but further calls to writeMessage on
                      <span class="keyword">this</span> channel will fail.

  e_CLOSE_BOTH        If a peer closes either its write or receive part of
                      the channel, the channel pool will simply down the
                      channel.  This is the <span class="keywordflow">default</span> behavior.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="resource_limits"></a> <a class="anchor" id="description.resource_limits"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Resource Limits: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The channel pool limits the resource usage based on the configuration. The user must specify the maximum number of connections that an instance can manage, the maximum number of threads that should be used, and the size (in bytes) of a channel's outgoing buffer. Once the maximum number of connections has been reached, an alert is generated and further channels cannot be created. On the client side, all requests for a connection will be denied. On the server side, no connections will be accepted, though the listening port is <em>not</em> closed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the peer on a particular channel is unable to keep up with the traffic, the system buffers will become full and the channel will queue the outgoing messages up to the specified limit. Once this limit is reached, an alert is generated and all further requests for sending data are denied until there is space available in the channel's buffer. The same limit applies for every channel. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="behavior_on_fork"></a> <a class="anchor" id="description.behavior_on_fork"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Behavior on fork: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>On Unix systems, the channel's underlying sockets (file descriptors) have the close-on-exec flag set by default at construction time, which is passed on to all the child processes created by <code>fork()</code> during the lifetime of the channel pool. This ensures that the channels, which are owned by the channel pool, are not passed on to other applications created by <code>fork()</code> followed by an <code>exec()</code>; instead, all sockets associated to channels are closed in the child process following the <code>exec()</code> command. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This default setting is done for user convenience. The user should realize that the behavior of <code>fork()</code> is actually undefined for multi-threaded processes. Also, beware that this does not guard against <code>fork()</code> <em>not</em> followed by <code>exec()</code>: the file descriptors will remain opened in the child processes, which may potentially outlive the lifetime of the channel pool, preventing the channel's socket files from being closed properly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="metrics_and_capacity"></a> <a class="anchor" id="description.metrics_and_capacity"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Metrics and Capacity: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>By default, the channel pool monitors the workload of managed event managers and reports, upon request, an average value of this workload. The workload of each individual event manager is calculated as the ratio of CPU bound processing time to the total processing time of the event manager (i.e. CPU bound time + I/O bound time) over a user-configured interval. The time line for each event manager is broken into two classifications, I/O bound and CPU bound intervals; an event manager is performing an I/O bound operation when it is blocked on a system call (e.g., <code>select</code>); otherwise, it is performing a CPU bound operation. Note that non-blocking system calls are NOT considered as I/O bound. An average is then calculated over the set of <em>all</em> <em>possible</em> event managers, and the load is taken as 0 if an event manager is not started. The length of interval that metrics are periodically collected over is configured by the <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">btlmt::ChannelPoolConfiguration</a></code> supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For calculating the percentage of CPU time used by the channel pool given that channel pool manages <code>n</code> event pollers at a moment (with the maximum of the number of threads, <code>T</code>), the sum of workloads is taken over the set of <code>T</code> event managers, and the workload is 0 for non-existent managers. Then the sum is divided by the number of event managers, T. The result reflects the workload of the channel pool as "percent busy". Strictly speaking, the following is true: <br/>
<br/>
<div class="fragment"><pre class="fragment">  ] T - maximum number of <span class="keyword">event</span> managers
  ] n - current number of <span class="keyword">event</span> managers.
  Then, the total workload is

       T
      __
      \ <span class="stringliteral">&#39;                                         -</span>
<span class="stringliteral">      /  workload(ev )   , where workload(ev ) = | CPU time/(CPU + I/0 time)</span>
<span class="stringliteral">      --            i                       i    | or</span>
<span class="stringliteral">      i=1                                        | 0 iff i &gt; n</span>
<span class="stringliteral">  W = ----------------                            -</span>
<span class="stringliteral">            T</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The channel pool is <em>thread-enabled</em> meaning that any operation on the same instance can be invoked from any thread. The configuration is thread-safe, but not thread-enabled and requires explicit synchronization in the user space. A user-defined callback can be invoked from <em>any</em> (managed) thread and the user must account for that. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="invocation_of_high-_and_low-water_mark_callbacks"></a> <a class="anchor" id="description.invocation_of_high-_and_low-water_mark_callbacks"></a> <a class="anchor" id="3.9"></a> </dd></dl>
<dl class="user"><dt><b>Invocation of High- and Low-Water Mark Callbacks: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Users of channel pool objects can specify at construction, via the <code>setWriteQueueWatermarks</code> method of <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">btlmt::ChannelPoolConfiguration</a></code>, or later via <code>setWriteQueueHighWatermark</code>, a soft limit on the number of bytes that can be enqueued on a channel for writing. Any time that the write-queue size exceeds this high-water mark value, subsequent <code>write</code> calls on that channel will fail until the size falls back below the limit. When a <code>write</code> call fails for this reason, this event triggers a <code>e_WRITE_QUEUE_HIGHWATER</code> alert to the client via the channel-state callback. Note that <code>write</code> calls also fail if the write-queue size exceeds the optionally specified <code>enqueueWatermark</code> argument provided to <code>write</code>, and then trigger the same alert. Note, too, that the alert callback may be delivered (to a different thread) before the <code>write</code> call returns. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to the high-water mark, users can also specify at construction a low-water mark, again via the <code>setWriteQueueWatermarks</code> function of <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">btlmt::ChannelPoolConfiguration</a></code>, or later via <code>setWriteQueueLowWatermark</code>. After a write fails because a write-queue size limit has been exceeded, the channel pool will later provide a <code>e_WRITE_QUEUE_LOWWATER</code> alert to the client via the channel state callback when the write-queue size falls to, or below, the low-water mark. Note that the alert callback may be delivered (to a different thread) before the <code>write</code> call returns. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Typically, clients will suspend writing to a channel when the write queue tops a high-water mark, and then resume when they receive a low-water mark callback. Since callback alerts are not synchronized with calls to <code>write</code>, programs that rely on a mix of error-return values and callback alerts for flow control must provide their own synchronization. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Values for the high- and low-watermark settings may be chosen according to requirements on data flow rate, latency, and memory usage. A positive low-watermark setting, by notifying the client before the queue is empty, enables clients to ensure that the channel does not go idle while messages are being prepared to send; or it may be used simply to notify a client immediately when the next message may be queued. A high-watermark setting may be chosen to limit the latency between a call to <code>write</code> and actual delivery of a message, or simply to limit the amount of storage used for buffering messages. A high-watermark value less than the low-watermark value, thus, enables tuning to maximize throughput without exceeding message-delivery latency requirements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.10"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_establishing_a_connection"></a> <a class="anchor" id="usage.example_1~3A_establishing_a_connection"></a> <a class="anchor" id="description.usage.example_1~3A_establishing_a_connection"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.10.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Establishing a Connection: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate how to establish connection to a remote host. First of all, we need to create a callback to be invoked once the channel status change (i.e., a new connection is established, in this case): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my_LocalCallback {
      <span class="keywordtype">int</span> d_sourceId;
      <span class="keywordtype">void</span> channelStateCb(<span class="keywordtype">int</span>                 channelId,
                          <span class="keywordtype">int</span>                 sourceId,
                          <span class="keywordtype">int</span>                 status,
                          <span class="keywordtype">void</span>               *arg,
                          <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a> **poolAddr)
      {
          assert(sourceId == d_sourceId);
          <span class="keywordflow">if</span> (<a class="code" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535aeebb10f21cc65b2e7c390ca18b31f9e5">btlmt::ChannelPool::e_CHANNEL_DOWN</a> == status) {
              <span class="comment">// Client disconnected from the server.</span>
              assert(poolAddr &amp;&amp; *poolAddr);
              (*poolAddr)-&gt;shutdown(channelId,
                                    <a class="code" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7a5ff8d9de035666225fde25a0ff36c97d">btlmt::ChannelPool::e_IMMEDIATE</a>);
          } <span class="keywordflow">else</span>
          <span class="keywordflow">if</span> (<a class="code" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535a9460b8d5bd520645793671563f8d25be">btlmt::ChannelPool::e_CHANNEL_UP</a> == status) {
              <span class="comment">// Connected to the server.</span>
              <span class="comment">// ...</span>
          }
          <span class="keywordflow">else</span> {
              <span class="comment">// Handle various failure modes</span>
              <span class="comment">// ...</span>
          }
      }
  };
</pre></div><br/>
<br/>
 Secondly, we need to create a configuration for the channel pool: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {
      my_LocalCallback localCallback;
      <a class="code" href="classbtlmt_1_1ChannelPoolConfiguration.html">btlmt::ChannelPoolConfiguration</a> config;
      config.<a class="code" href="classbtlmt_1_1ChannelPoolConfiguration.html#afe115a2b613dd9e3e41a2b05b47172e3">setMaxThreads</a>(4);
      config.<a class="code" href="classbtlmt_1_1ChannelPoolConfiguration.html#a2a389534d24b9f81dbcc78800fe486cd">setMetricsInterval</a>(10.0);
      config.<a class="code" href="classbtlmt_1_1ChannelPoolConfiguration.html#a31b13cd49445920115af9691e4980457">setMaxConnections</a>(16);
      config.<a class="code" href="classbtlmt_1_1ChannelPoolConfiguration.html#a3d56e7fbd041fc8ca02afefbd0bc2c28">setIncomingMessageSizes</a>(1, 128, 256);

      bsl::function&lt;void(int, int, int, void*)&gt;
                                          ccb;    <span class="comment">// channel state callback</span>
      bsl::function&lt;void(int, int*, int*, void*)&gt;
                                          dcb;    <span class="comment">// data callback</span>
      bsl::function&lt;void(int, int, int)&gt;
                                          pcb;    <span class="comment">// pool state callback</span>

      bslmt::ChannelPool *poolAddr;
      ccb = <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>( &amp;my_LocalCallback::channelStateCb
                               , &amp;local)
                               , <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#aac3f76f26a313c2605937cd4ffef4bf7">_3</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a3c28df00080ea6d7ce9ce2e01087629e">_4</a>
                               , &amp;poolAddr);
      makeNull(&amp;dcb);  <span class="comment">// not interested in data</span>
      makeNull(&amp;pcb);  <span class="comment">// not interested in pool state</span>

      localCallback.d_sourceId = 5;    <span class="comment">// just for a simple verification</span>

      <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a> pool(ccb, dcb, pcb, config);
      poolAddr = &amp;pool;
</pre></div><br/>
<br/>
 Now, start the channel pool, issue the connect request, and wait for completion. Note that main thread is never blocked, so we have to put it to sleep explicitly: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(0 == pool.start());
      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> peer(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7); <span class="comment">// echo server</span>
      assert(0 == pool.connect(peer, 1, <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(10.0), 5));
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a667b0f54d6c038c8ecb851ca66dc0529">bslmt::ThreadUtil::sleep</a>(15000000); <span class="comment">// Give enough time to connect.</span>
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_implementing_an_echo_server"></a> <a class="anchor" id="usage.example_2~3A_implementing_an_echo_server"></a> <a class="anchor" id="description.usage.example_2~3A_implementing_an_echo_server"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.10.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Implementing an Echo Server: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following usage example shows a possible implementation of a multi-user echo server. An echo server accepts connections and, for every connection, sends any received data back to the client (until the connection is terminated). This server requires that data be read from an accepted connection within a certain time interval or else it is dropped on timeout. The echo server is implemented as a separate class (<code>my_EchoServer</code>) that owns a channel pool and its configuration parameters. The configuration parameters are compile-time constants within this class. The definition for <code>my_EchoServer</code> follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_EchoServer {
      <span class="comment">// This class implements a multi-user multi-threaded echo server.</span>

      <span class="keyword">enum</span> {
          SERVER_ID = 0xAB   <span class="comment">// An (arbitrary) constant (passed to &#39;listen&#39;)</span>
                             <span class="comment">// that identifies the channel pool operation</span>
                             <span class="comment">// associated with a pool state or channel</span>
                             <span class="comment">// state callback.</span>
      };

      <span class="comment">// DATA</span>
      <a class="code" href="classbtlmt_1_1ChannelPoolConfiguration.html">btlmt::ChannelPoolConfiguration</a> d_config;        <span class="comment">// pool&#39;s config</span>
      <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a>             *d_channelPool_p; <span class="comment">// managed pool</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>              *d_allocator_p;    <span class="comment">// memory manager</span>
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>                   *d_coutLock_p;   <span class="comment">// synchronize &#39;cout&#39;</span>

    <span class="keyword">private</span>:
      <span class="comment">// Callback functions:</span>
      <span class="keywordtype">void</span> poolStateCb(<span class="keywordtype">int</span> state, <span class="keywordtype">int</span> source, <span class="keywordtype">int</span> severity);
          <span class="comment">// Output a message to &#39;stdout&#39; indicating the specified &#39;state&#39;</span>
          <span class="comment">// associated with the specified &#39;source&#39; has occurred, with the</span>
          <span class="comment">// specified &#39;severity&#39;.  Note that &#39;state&#39; is one of the</span>
          <span class="comment">// &#39;PoolEvents&#39; constants, &#39;source&#39; identifies the channel pool</span>
          <span class="comment">// operation associated with this state (in this case, the</span>
          <span class="comment">// &#39;SERVER_ID&#39; passed to &#39;listen()&#39; or 0 for pool states with no</span>
          <span class="comment">// associated source), and &#39;severity&#39; is one of the</span>
          <span class="comment">// &#39;btlmt::ChannelPool::Severity&#39; values.</span>

      <span class="keywordtype">void</span> channelStateCb(<span class="keywordtype">int</span> channelId, <span class="keywordtype">int</span> sourceId, <span class="keywordtype">int</span> state, <span class="keywordtype">void</span> *ctx);
          <span class="comment">// Output a message to &#39;stdout&#39; indicating the specified &#39;state&#39;,</span>
          <span class="comment">// associated with the specified &#39;channelId&#39; and &#39;sourceId&#39;, has</span>
          <span class="comment">// occurred.  If &#39;state&#39; is &#39;btlmt::ChannelPool::e_CHANNEL_DOWN&#39;</span>
          <span class="comment">// then &#39;shutdown&#39; the channel.  Note that the &#39;channelId&#39; is a</span>
          <span class="comment">// unique identifier chosen by the channel pool for each connection</span>
          <span class="comment">// channel, &#39;sourceId&#39; identifies the channel pool operation</span>
          <span class="comment">// responsible for creating the channel (in this case, the</span>
          <span class="comment">// &#39;SERVER_ID&#39; passed to &#39;listen()&#39;), &#39;state&#39; is a</span>
          <span class="comment">// &#39;btlmt::ChannelPool::ChannelState&#39; enumeration value, and &#39;ctx&#39;</span>
          <span class="comment">// is the address of a context object provided for the channel</span>
          <span class="comment">// (using &#39;setChannelContext()&#39;), in this example we do not</span>
          <span class="comment">// specify a context, so the value will be 0.</span>

      <span class="keywordtype">void</span> dataCb(<span class="keywordtype">int</span>           *numNeeded,
                  <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a>  *msg,
                  <span class="keywordtype">int</span>            channelId
                  <span class="keywordtype">void</span>          *context);
          <span class="comment">// Echo the specified &#39;msg&#39; to the client on the channel</span>
          <span class="comment">// identified by &#39;channelId&#39; channel, load into the</span>
          <span class="comment">// specified &#39;numNeeeded&#39; the minimum length of</span>
          <span class="comment">// additional data that is needed to complete a message, and close</span>
          <span class="comment">// the communication channel.  Because this echo server is not</span>
          <span class="comment">// interested in a discrete messages in a particular message</span>
          <span class="comment">// format, the entire message in &#39;msg&#39; is read, and &#39;numNeeded&#39;</span>
          <span class="comment">// will be set to 1 (indicating this callback should be invoked</span>
          <span class="comment">// again as soon as any new data is read).</span>

      <span class="comment">// NOT IMPLEMENTED</span>
      my_EchoServer(<span class="keyword">const</span> my_EchoServer&amp;);
      my_EchoServer&amp; operator=(<span class="keyword">const</span> my_EchoServer&amp;);

    <span class="keyword">public</span>:
      my_EchoServer(<a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>      *coutLock,
                    <span class="keywordtype">int</span>               portNumber,
                    <span class="keywordtype">int</span>               numConnections,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an echo server that listens for incoming connections on</span>
          <span class="comment">// the specified &#39;portNumber&#39; managing up to the specified</span>
          <span class="comment">// &#39;numConnections&#39; simultaneous connections.  The echo server</span>
          <span class="comment">// will use the specified &#39;coutLock&#39; to synchronize access to the</span>
          <span class="comment">// standard output.  Optionally specify a &#39;basicAllocator&#39; used to</span>
          <span class="comment">// supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.  The behavior is undefined</span>
          <span class="comment">// unless &#39;coutLock&#39; is a valid address for a mutex object.</span>

      ~my_EchoServer();
          <span class="comment">// Destroy this server.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">const</span> <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a>&amp; pool() { <span class="keywordflow">return</span> *d_channelPool_p; }
  };
</pre></div><br/>
<br/>
 In the constructor of <code>my_EchoServer</code>, the configuration is initialized, the channel pool is created, configured, and started. The listening port is established: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_EchoServer::my_EchoServer(<a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>      *coutLock,
                               <span class="keywordtype">int</span>               portNumber,
                               <span class="keywordtype">int</span>               numConnections,
                               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_allocator_p(bslma::Default::allocator(basicAllocator))
  , d_coutLock_p(coutLock) {
      d_config.setMaxThreads(4);
      d_config.setMaxConnections(numConnections);
      d_config.setReadTimeout(5.0);       <span class="comment">// in seconds</span>
      d_config.setMetricsInterval(10.0);  <span class="comment">// seconds</span>
      d_config.setMaxWriteQueue(1&lt;&lt;10);   <span class="comment">// 1MB</span>
      d_config.setIncomingMessageSizes(1, 100, 1024);

      <a class="code" href="classbtlmt_1_1ChannelPool.html#a8007511e7782b66c18acf73c835e9ec4">btlmt::ChannelPool::ChannelStateChangeCallback</a> channelStateFunctor(
              &amp;my_EchoServer::channelStateCb
            , <span class="keyword">this</span>)
            , basicAllocator);

      <a class="code" href="classbtlmt_1_1ChannelPool.html#a6af6150b550904dd0b5601241796814e">btlmt::ChannelPool::PoolStateChangeCallback</a> poolStateFunctor(
              &amp;my_EchoServer::poolStateCb
            , <span class="keyword">this</span>)
            , basicAllocator));

      btlmt::ChannelPool::DataReadCallback dataFunctor(
              &amp;my_EchoServer::dataCb
            , <span class="keyword">this</span>)
            , basicAllocator));

      d_channelPool_p = <span class="keyword">new</span> (*d_allocator_p)
          <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a>(channelStateFunctor,
                            dataFunctor,
                            poolStateFunctor,
                            d_config,
                            basicAllocator);

      assert(0 == d_channelPool_p-&gt;start());
      assert(0 == d_channelPool_p-&gt;listen(portNumber,
                                          numConnections,
                                          SERVER_ID));
  }
</pre></div><br/>
<br/>
 Destructor just stops the pool and destroys it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_EchoServer::~my_EchoServer() {
      d_channelPool_p-&gt;stop();
      d_allocator_p-&gt;deleteObject(d_channelPool_p);
  }
</pre></div><br/>
<br/>
 The pool state callback will just print the new state. The channel state callback will report a new state and the address of the peer. The data state callback will immediately write data back to the channel pool. These methods are documented in the example header, and the implementation for these methods is shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_EchoServer::poolStateCb(<span class="keywordtype">int</span> state, <span class="keywordtype">int</span> source, <span class="keywordtype">int</span> severity) {
      d_coutLock_p-&gt;lock();
      cout &lt;&lt; <span class="stringliteral">&quot;Pool state changed: (&quot;</span>
           &lt;&lt; source &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
           &lt;&lt; severity &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
           &lt;&lt; state &lt;&lt; <span class="stringliteral">&quot;) &quot;</span> &lt;&lt; endl;
      d_coutLock_p-&gt;unlock();
  }

  <span class="keywordtype">void</span> my_EchoServer::channelStateCb(<span class="keywordtype">int</span>   channelId,
                                     <span class="keywordtype">int</span>   sourceId,
                                     <span class="keywordtype">int</span>   state,
                                     <span class="keywordtype">void</span> *context)
  {
      assert(SERVER_ID == sourceId);

      <span class="keywordflow">switch</span>(state) {
        <span class="keywordflow">case</span> <a class="code" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535aeebb10f21cc65b2e7c390ca18b31f9e5">btlmt::ChannelPool::e_CHANNEL_DOWN</a>: {
            <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> peer;
            d_channelPool_p-&gt;getPeerAddress(&amp;peer, channelId);
            d_coutLock_p-&gt;lock();
            cout &lt;&lt; <span class="stringliteral">&quot;Client from &quot;</span> &lt;&lt; peer &lt;&lt; <span class="stringliteral">&quot; has disconnected.&quot;</span> &lt;&lt; endl;
            d_coutLock_p-&gt;unlock();
            d_channelPool_p-&gt;shutdown(channelId,
                                      <a class="code" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7a5ff8d9de035666225fde25a0ff36c97d">btlmt::ChannelPool::e_IMMEDIATE</a>);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535a9460b8d5bd520645793671563f8d25be">btlmt::ChannelPool::e_CHANNEL_UP</a>: {
            <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> peer;
            d_channelPool_p-&gt;getPeerAddress(&amp;peer, channelId);
            d_coutLock_p-&gt;lock();
            cout &lt;&lt; <span class="stringliteral">&quot;Client connected from &quot;</span> &lt;&lt; peer &lt;&lt; endl;
            d_coutLock_p-&gt;unlock();
        } <span class="keywordflow">break</span>;
      }
  }

  <span class="keywordtype">void</span> my_EchoServer::dataCb(<span class="keywordtype">int</span>          *numNeeded,
                             <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *msg,
                             <span class="keywordtype">int</span>           channelId,
                             <span class="keywordtype">void</span>         *context)
  {
      assert(msg);
      assert(0 &lt; msg-&gt;<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>());

      assert(0 == d_channelPool_p-&gt;write(channelId, *msg));

      msg-&gt;<a class="code" href="classbtlb_1_1Blob.html#a0850ccbd58c2f19e5eb5bb91ece9033a">removeAll</a>();

      *numNeeded = 1;

      d_channelPool_p-&gt;shutdown(channelId,
                                <a class="code" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7a5ff8d9de035666225fde25a0ff36c97d">btlmt::ChannelPool::e_IMMEDIATE</a>);
  }
</pre></div><br/>
<br/>
 The implementation of an echo server is now complete. Let's create a small program that uses it. We will create a server object, then the main thread will monitor the channel pool and periodically print its busy metrics. For simplicity, we will use the following function for monitoring: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> monitorPool(<a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>              *coutLock,
                          <span class="keyword">const</span> <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a>&amp;  pool,
                          <span class="keywordtype">int</span>                        numTimes)
      <span class="comment">// Every 10 seconds, output the percent busy of the specified channel</span>
      <span class="comment">// &#39;pool&#39; to the standard output, using the specified &#39;coutLock&#39; to</span>
      <span class="comment">// synchronizing access to the standard output stream; return to the</span>
      <span class="comment">// caller after &#39;numTimes&#39; output operations (i.e. numTimes * 10</span>
      <span class="comment">// seconds).</span>
  {
      <span class="keywordflow">while</span>(--numTimes &gt; 0) {
          coutLock-&gt;<a class="code" href="classbslmt_1_1Mutex.html#a3451960cdbb0ab49bd3c70e8702c2a4f">lock</a>();
          cout &lt;&lt; <span class="stringliteral">&quot;The pool is &quot;</span> &lt;&lt; pool.<a class="code" href="classbtlmt_1_1ChannelPool.html#a06966c1669bd289e6e2773090d421523">busyMetrics</a>() &lt;&lt; <span class="stringliteral">&quot;% busy (&quot;</span>
              &lt;&lt; pool.<a class="code" href="classbtlmt_1_1ChannelPool.html#aadfd61a0a4b47f4d370ad72a902d1a2a">numThreads</a>() &lt;&lt; <span class="stringliteral">&quot; threads).&quot;</span> &lt;&lt; endl;
          coutLock-&gt;<a class="code" href="classbslmt_1_1Mutex.html#ac02d8e714a5dc0330e56d4ef66638d76">unlock</a>();
      }
  }
</pre></div><br/>
<br/>
 The main function is shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> main() {
       <span class="keyword">enum</span> {
           PORT_NUMBER     = 1423
         , MAX_CONNECTIONS = 1000
         , NUM_MONITOR     = 50
       };
       <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a> coutLock;
       my_EchoServer echoServer(&amp;coutLock, PORT_NUMBER, MAX_CONNECTIONS);
       monitorPool(&amp;coutLock, echoServer.pool(), NUM_MONITOR);
       <span class="keywordflow">return</span> 0;

   }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
