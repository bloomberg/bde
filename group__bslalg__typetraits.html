<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslalg_typetraits Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_typetraits<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide compile-time traits that can be associated with types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__typetraits.html#gafa5b1f676ecffe5b54e6f9baf9ed32ea">BSLALG_DECLARE_NESTED_TRAITS2</a>(T, TRAIT1, TRAIT2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__typetraits.html#gadb20cad0a662b326a892ed006d223c98">BSLALG_DECLARE_NESTED_TRAITS3</a>(T, TRAIT1, TRAIT2, TRAIT3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__typetraits.html#ga57dc24f2999bc2959d27e54130b66551">BSLALG_DECLARE_NESTED_TRAITS4</a>(T, TRAIT1, TRAIT2, TRAIT3, TRAIT4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__typetraits.html#ga7f77328d01e42db56818edb1651753f9">BSLALG_DECLARE_NESTED_TRAITS5</a>(T, TRAIT1, TRAIT2, TRAIT3, TRAIT4, TRAIT5)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Usage</a> <ul>
<li>
<a href="#4.1.1">A generic container</a> </li>
<li>
<a href="#4.1.2">Using the type traits</a> </li>
<li>
<a href="#4.1.3">Generic container implementation</a> </li>
<li>
<a href="#4.1.4">Usage verification</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide compile-time traits that can be associated with types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>See <code>bslmf_nestedtraitdeclaration</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslalg_1_1TypeTraitNil.html">bslalg::TypeTraitNil</a> </td><td>nil type trait (no traits)  </td></tr>
<tr>
<td><a class="el" href="structbslalg_1_1TypeTraitBitwiseMoveable.html">bslalg::TypeTraitBitwiseMoveable</a> </td><td>bitwise-moveable trait  </td></tr>
<tr>
<td><a class="el" href="structbslalg_1_1TypeTraitBitwiseCopyable.html">bslalg::TypeTraitBitwiseCopyable</a> </td><td>bitwise-copyable trait  </td></tr>
<tr>
<td><a class="el" href="structbslalg_1_1TypeTraitBitwiseEqualityComparable.html">bslalg::TypeTraitBitwiseEqualityComparable</a> </td><td>bitwise-eq.-comparable trait  </td></tr>
<tr>
<td><a class="el" href="structbslalg_1_1TypeTraitHasStlIterators.html">bslalg::TypeTraitHasStlIterators</a> </td><td>has STL-like iterators  </td></tr>
<tr>
<td><a class="el" href="structbslalg_1_1TypeTraitHasTrivialDefaultConstructor.html">bslalg::TypeTraitHasTrivialDefaultConstructor</a> </td><td>has trivial default ctor  </td></tr>
<tr>
<td><a class="el" href="structbslalg_1_1TypeTraitPair.html">bslalg::TypeTraitPair</a> </td><td>for <code>std::pair</code>-like classes  </td></tr>
<tr>
<td><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a> </td><td>uses <code>bslma</code> allocators  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BSLALG_DECLARE_NESTED_TRAITS </td><td>declares a trait in a nested fashion  </td></tr>
<tr>
<td>BSLALG_DECLARE_NESTED_TRAITS2 </td><td>declares two traits in a nested fashion  </td></tr>
<tr>
<td>BSLALG_DECLARE_NESTED_TRAITS3 </td><td>declares three traits in a nested fashion  </td></tr>
<tr>
<td>BSLALG_DECLARE_NESTED_TRAITS4 </td><td>declares four traits in a nested fashion  </td></tr>
<tr>
<td>BSLALG_DECLARE_NESTED_TRAITS5 </td><td>declares five traits in a nested fashion  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__constructorproxy.html" title="Provide a proxy for constructing and destroying objects.">Component bslalg_constructorproxy</a>, <a class="el" href="group__bslalg__scalarprimitives.html" title="Provide primitive algorithms that operate on single elements.">Component bslalg_scalarprimitives</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a set of type traits, and a set of macros used to assign traits to user-defined class. Traits are used to enable certain optimizations or discriminations at compile-time. For instance, a class having the trait <code><a class="el" href="structbslalg_1_1TypeTraitBitwiseMoveable.html">bslalg::TypeTraitBitwiseMoveable</a></code> may allow resizing an array of objects by simply calling <code>std::memcpy</code> instead of invoking a copy-constructor on every objects. The usage example shows how to use the <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> to propagate allocators to nested objects that may require them. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component should be used in conjunction with other components from the package <code>bslalg</code>. See the package-level documentation for an overview. The most useful classes and macros defined in this component are: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Entity                                    Description
  ------                                    -----------
  <a class="code" href="structbslalg_1_1TypeTraitBitwiseMoveable.html">bslalg::TypeTraitBitwiseMoveable</a>         (See the corresponding <span class="keyword">class</span>-level
  <a class="code" href="structbslalg_1_1TypeTraitBitwiseCopyable.html">bslalg::TypeTraitBitwiseCopyable</a>                            documentation.)
  <a class="code" href="structbslalg_1_1TypeTraitBitwiseEqualityComparable.html">bslalg::TypeTraitBitwiseEqualityComparable</a>
  <a class="code" href="structbslalg_1_1TypeTraitHasStlIterators.html">bslalg::TypeTraitHasStlIterators</a>
  <a class="code" href="structbslalg_1_1TypeTraitHasTrivialDefaultConstructor.html">bslalg::TypeTraitHasTrivialDefaultConstructor</a>
  <a class="code" href="structbslalg_1_1TypeTraitPair.html">bslalg::TypeTraitPair</a>
  <a class="code" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>

  <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(TYPE, TRAIT) A macro to attach a given &#39;TRAIT&#39;
                                            to a given type &#39;T&#39; in a nested
                                            fashion.  This macro must be used
                                            within the &#39;public&#39; section of a
                                            class body.

  bslalg::HasTrait&lt;TYPE, TRAIT&gt;             This meta-function computes
                                            whether the parameterized &#39;TYPE&#39;
                                            possesses the parameterized
                                            &#39;TRAIT&#39;.

  bslalg::SelectTrait&lt;T, TRAIT1, ...&gt;       This meta-function selects the
                                            first trait possessed by the
                                            parameterized &#39;TYPE&#39; from the
                                            ordered list &#39;TRAIT1&#39;, ....
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this usage example, we show how to enable the <code>bslma</code> allocator model for generic containers, by implementing simplified versions of the <code>bslalg_constructorproxy</code> and <code>bslalg_scalarprimitives</code> components. The interested reader should refer to the documentation of those components. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="a_generic_container"></a> <a class="anchor" id="usage.a_generic_container"></a> <a class="anchor" id="description.usage.a_generic_container"></a> <a class="anchor" id="4.1.1"></a> </dd></dl>
<dl class="user"><dt><b>A generic container: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to implement a generic container of a parameterized <code>TYPE</code>, which may or may not follow the <code>bslma</code> allocator model. If it does, our container should pass an extra <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*</code> argument to copy construct a value; but if it does not, then passing this extra argument is going to generate a compile-time error. It thus appears we need two implementations of our container. This can be done more succinctly by encapsulating into the constructor some utilities which will, through a single interface, determine whether <code>TYPE</code> has the trait <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> and copy-construct it accordingly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The container contains a single data member of the parameterized <code>TYPE</code>. Since we are going to initialize this data member manually, we do not want it to be automatically constructed by the compiler. For this reason, we encapsulate it in a <code><a class="el" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_genericcontainer.hpp          -*-C++-*-</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>MyGenericContainer {
      <span class="comment">// This generic container type contains a single object, always</span>
      <span class="comment">// initialized, which can be replaced and accessed.  This container</span>
      <span class="comment">// always takes an allocator argument and thus follows the</span>
      <span class="comment">// &#39;bslalg::TypeTraitUsesBslmaAllocator&#39; protocol.</span>

      <span class="comment">// PRIVATE DATA MEMBERS</span>
      <a class="code" href="unionbsls_1_1ObjectBuffer.html">bsls::ObjectBuffer&lt;TYPE&gt;</a> d_object;
</pre></div><br/>
<br/>
 Since the container offers a uniform interface that always takes an extra allocator argument, regardless of whether <code>TYPE</code> does or not, we can declare it to have the <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> trait: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">public</span>:
    <span class="comment">// TRAITS</span>
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(MyGenericContainer,
                                 <a class="code" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>);
</pre></div><br/>
<br/>
 For simplicity, we let the container contain only a single element, and require that an element always be initialized. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  MyGenericContainer(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0);
      <span class="comment">// Create an container containing the specified &#39;object&#39;, using the</span>
      <span class="comment">// optionally specified &#39;allocator&#39; to allocate memory.  If</span>
      <span class="comment">// &#39;allocator&#39; is 0, the currently installed allocator is used.</span>

  MyGenericContainer(<span class="keyword">const</span> MyGenericContainer&amp;  container,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>          *allocator = 0);
      <span class="comment">// Create an container containing the same object as the specified</span>
      <span class="comment">// &#39;container&#39;, using the optionally specified &#39;allocator&#39; to</span>
      <span class="comment">// allocate memory.  If &#39;allocator&#39; is 0, the currently installed</span>
      <span class="comment">// allocator is used.</span>

  ~MyGenericContainer();
      <span class="comment">// Destroy this container.</span>
</pre></div><br/>
<br/>
 We can also allow the container to change the object it contains, by granting modifiable as well as non-modifiable access to this object: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// MANIPULATORS</span>
      TYPE&amp; object();

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> TYPE&amp; object() <span class="keyword">const</span>;
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="using_the_type_traits"></a> <a class="anchor" id="usage.using_the_type_traits"></a> <a class="anchor" id="description.usage.using_the_type_traits"></a> <a class="anchor" id="4.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Using the type traits: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The challenge in the implementation lays in using the traits of the contained <code>TYPE</code> to determine whether to pass the allocator argument to its copy constructor. We rely here on a property of templates that templates are not compiled (and thus will not generate compilation errors) until they are instantiated. Hence, we can use two function templates, and let the overloading resolution (based on the nested traits) decide which to instantiate. The generic way to create an object, passing through all arguments (value and allocator) is as follows. For brevity and to avoid breaking the flow of this example, we have embedded the function definition into the class. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_genericcontainer.cpp          -*-C++-*-</span>

  <span class="keyword">struct </span>my_GenericContainerUtil {
      <span class="comment">// This &#39;struct&#39; provides a namespace for utilities implementing the</span>
      <span class="comment">// allocator pass-through mechanism in a generic container.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span> copyConstruct(TYPE             *location,
                                <span class="keyword">const</span> TYPE&amp;       value,
                                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator,
                                <a class="code" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)
          <span class="comment">// Create a copy of the specified &#39;value&#39; at the specified</span>
          <span class="comment">// &#39;location&#39;, using the specified &#39;allocator&#39; to allocate memory.</span>
      {
          <span class="keyword">new</span> (location) TYPE(value, allocator);
      }
</pre></div><br/>
<br/>
 For types that don't use an allocator, we offer the following overload which will be selected if the type trait of <code>TYPE</code> cannot be converted to <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code>. In that case, note that the type traits always inherits from <code><a class="el" href="structbslalg_1_1TypeTraitNil.html">bslalg::TypeTraitNil</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">static</span> <span class="keywordtype">void</span> copyConstruct(TYPE             *location,
                            <span class="keyword">const</span> TYPE&amp;       value,
                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator,
                            <a class="code" href="structbslalg_1_1TypeTraitNil.html">bslalg::TypeTraitNil</a>)
      <span class="comment">// Create a copy of the specified &#39;value&#39; at the specified</span>
      <span class="comment">// &#39;location&#39;.  Note that the specified &#39;allocator&#39; is ignored.</span>
  {
      <span class="keyword">new</span> (location) TYPE(value);
  }
</pre></div><br/>
<br/>
 And finally, this function will instantiate the type trait and pass it to the appropriately (compiler-)chosen overload: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
      <span class="keyword">static</span> <span class="keywordtype">void</span> copyConstruct(TYPE             *location,
                                <span class="keyword">const</span> TYPE&amp;       value,
                                <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
          <span class="comment">// Create a copy of the specified &#39;value&#39; at the specified</span>
          <span class="comment">// &#39;location&#39;, optionally using the specified &#39;allocator&#39; to supply</span>
          <span class="comment">// memory if the parameterized &#39;TYPE&#39; possesses the</span>
          <span class="comment">// &#39;bslalg::TypeTraitUsesBslmaAllocator&#39;.</span>
      {
          copyConstruct(location, value, allocator,
              <span class="keyword">typename</span> <a class="code" href="structbslmf_1_1If.html">bslmf::If</a>&lt;HasTrait&lt;TYPE,
                            <a class="code" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&gt;::VALUE,
                        <a class="code" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>,
                        <a class="code" href="structbslalg_1_1TypeTraitNil.html">bslalg::TypeTraitNil</a>&gt;::Type());
      }

  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="generic_container_implementation"></a> <a class="anchor" id="usage.generic_container_implementation"></a> <a class="anchor" id="description.usage.generic_container_implementation"></a> <a class="anchor" id="4.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Generic container implementation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>With these utilities, we can now implement <code>MyGenericContainer</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
  MyGenericContainer&lt;TYPE&gt;::MyGenericContainer(<span class="keyword">const</span> TYPE&amp;       <span class="keywordtype">object</span>,
                                               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
  {
      my_GenericContainerUtil::copyConstruct(&amp;d_object.object(),
                                             object,
                                             allocator);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
  MyGenericContainer&lt;TYPE&gt;::MyGenericContainer(
                                        <span class="keyword">const</span> MyGenericContainer&amp;  container,
                                        <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>          *allocator)
  {
      my_GenericContainerUtil::copyConstruct(&amp;d_object.object(),
                                             container.object(),
                                             allocator);
  }
</pre></div><br/>
<br/>
 Note that all this machinery only affects the constructors, and not the destructor which only invokes the destructor of <code>d_object</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
  MyGenericContainer&lt;TYPE&gt;::~MyGenericContainer()
  {
      (&amp;d_object.object())-&gt;~TYPE();
  }
</pre></div><br/>
<br/>
 To finish, the accessors and manipulators are trivially implemented. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
  TYPE&amp; MyGenericContainer&lt;TYPE&gt;::object()
  {
      <span class="keywordflow">return</span> d_object.object();
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
  <span class="keyword">const</span> TYPE&amp; MyGenericContainer&lt;TYPE&gt;::object()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_object.object();
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_verification"></a> <a class="anchor" id="usage.usage_verification"></a> <a class="anchor" id="description.usage.usage_verification"></a> <a class="anchor" id="4.1.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage verification: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can check that our container actually forwards the correct allocator to its contained objects with a very simple test apparatus, consisting of two classes which have exactly the same signature and implementation except that one has the <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> trait and the other has not: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocSlot;

  <span class="keyword">struct </span>MyTestTypeWithBslmaAllocatorTraits {
      <span class="comment">// Class with declared traits.  Calling copy constructor without an</span>
      <span class="comment">// allocator will compile, but will not set &#39;allocSlot&#39;.</span>

      <span class="comment">// TRAITS</span>
      <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(MyTestTypeWithBslmaAllocatorTraits,
                           BloombergLP::bslalg::TypeTraitUsesBslmaAllocator);

      <span class="comment">// CREATORS</span>
      MyTestTypeWithBslmaAllocatorTraits() {}

      MyTestTypeWithBslmaAllocatorTraits(
                       <span class="keyword">const</span> MyTestTypeWithBslmaAllocatorTraits&amp;,
                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                           *allocator)
      {
          allocSlot = allocator;
      }
  };

  <span class="keyword">struct </span>MyTestTypeWithNoBslmaAllocatorTraits {
      <span class="comment">// Class with no declared traits.  Calling copy constructor without</span>
      <span class="comment">// an allocator will not set the &#39;allocSlot&#39;, but passing it by mistake</span>
      <span class="comment">// will set it.</span>

      <span class="comment">// CREATORS</span>
      MyTestTypeWithNoBslmaAllocatorTraits() {}

      MyTestTypeWithNoBslmaAllocatorTraits(
                    <span class="keyword">const</span> MyTestTypeWithNoBslmaAllocatorTraits &amp;,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                              *allocator)
      {
          allocSlot = allocator;
      }
  };
</pre></div><br/>
<br/>
 Our verification program simply instantiate several <code>MyGenericContainer</code> templates with the two test types above, and checks that the allocator slot is as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta0;
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta1;
</pre></div><br/>
<br/>
 With <code>MyTestTypeWithNoBslmaAllocatorTraits</code>, the slot should never be set. <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyTestTypeWithNoBslmaAllocatorTraits x;

  allocSlot = &amp;ta0;
  MyGenericContainer&lt;MyTestTypeWithNoBslmaAllocatorTraits&gt; x0(x);
  assert(&amp;ta0 == allocSlot);

  allocSlot = &amp;ta0;
  MyGenericContainer&lt;MyTestTypeWithNoBslmaAllocatorTraits&gt; x1(x, &amp;ta1);
  assert(&amp;ta0 == allocSlot);
</pre></div><br/>
<br/>
 With <code>MyTestTypeWithBslmaAllocatorTraits</code>, the slot should be set to the allocator argument, or to 0 if not specified: <br/>
<br/>
<div class="fragment"><pre class="fragment">      MyTestTypeWithBslmaAllocatorTraits y;

      allocSlot = &amp;ta0;
      MyGenericContainer&lt;MyTestTypeWithBslmaAllocatorTraits&gt; y0(y);
      assert(0 == allocSlot);

      allocSlot = &amp;ta0;
      MyGenericContainer&lt;MyTestTypeWithBslmaAllocatorTraits&gt; y1(y, &amp;ta1);
      assert(&amp;ta1 == allocSlot);

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gab7a247c93e0d83c005ceb01cc291937b"></a><!-- doxytag: member="bslalg_typetraits.h::BSLALG_DECLARE_NESTED_TRAITS" ref="gab7a247c93e0d83c005ceb01cc291937b" args="(T, TRAIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLALG_DECLARE_NESTED_TRAITS</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">operator TRAIT::NestedTraitDeclaration&lt;T&gt;()<span class="keyword"> const </span>{   \
        <span class="keywordflow">return</span> TRAIT::NestedTraitDeclaration&lt;T&gt;();        \
    }
</pre></div>
</div>
</div>
<a class="anchor" id="gafa5b1f676ecffe5b54e6f9baf9ed32ea"></a><!-- doxytag: member="bslalg_typetraits.h::BSLALG_DECLARE_NESTED_TRAITS2" ref="gafa5b1f676ecffe5b54e6f9baf9ed32ea" args="(T, TRAIT1, TRAIT2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLALG_DECLARE_NESTED_TRAITS2</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT2</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT1);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT2)
</pre></div>
</div>
</div>
<a class="anchor" id="gadb20cad0a662b326a892ed006d223c98"></a><!-- doxytag: member="bslalg_typetraits.h::BSLALG_DECLARE_NESTED_TRAITS3" ref="gadb20cad0a662b326a892ed006d223c98" args="(T, TRAIT1, TRAIT2, TRAIT3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLALG_DECLARE_NESTED_TRAITS3</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT3</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT1);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT2);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT3)
</pre></div>
</div>
</div>
<a class="anchor" id="ga57dc24f2999bc2959d27e54130b66551"></a><!-- doxytag: member="bslalg_typetraits.h::BSLALG_DECLARE_NESTED_TRAITS4" ref="ga57dc24f2999bc2959d27e54130b66551" args="(T, TRAIT1, TRAIT2, TRAIT3, TRAIT4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLALG_DECLARE_NESTED_TRAITS4</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT4</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT1);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT2);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT3);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT4)
</pre></div>
</div>
</div>
<a class="anchor" id="ga7f77328d01e42db56818edb1651753f9"></a><!-- doxytag: member="bslalg_typetraits.h::BSLALG_DECLARE_NESTED_TRAITS5" ref="ga7f77328d01e42db56818edb1651753f9" args="(T, TRAIT1, TRAIT2, TRAIT3, TRAIT4, TRAIT5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLALG_DECLARE_NESTED_TRAITS5</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT4, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">TRAIT5</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT1);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT2);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT3);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT4);                                  \
    <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(T, TRAIT5)
</pre></div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
