<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_multiset Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_multiset<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant multiset class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1multiset.html">bsl::multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt;::DataWrapper</b></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">bsl::multiset::key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga836c56ba0e227a2ebaa2e9ac005276aa">bsl::multiset::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef COMPARATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga2762d608f899a860fa54791529381bb3">bsl::multiset::key_compare</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef COMPARATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga2ce2df2b63c2a922795c96f6faf7fab3">bsl::multiset::value_compare</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gad66097606b85feb88c65210b78f16e16">bsl::multiset::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga1a248a4bd053c225c55c5b8502f00f3f">bsl::multiset::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gae749d18427aa8d08d5f6f33327026f32">bsl::multiset::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gafb01192076790ad9eb29474c45a73542">bsl::multiset::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaaf6f4354fe4daaa2d8bd8f92218400b9">bsl::multiset::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gac43dc557e91922353623ae35cda62643">bsl::multiset::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaae5ed187e25fc76466158c2d176070c1">bsl::multiset::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::TreeIterator<br class="typebreak"/>
&lt; const value_type, Node, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga29846c31f4e8ff13cbe22c44f32898ed">bsl::multiset::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::TreeIterator<br class="typebreak"/>
&lt; const value_type, Node, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga16d7cd51bad8cbbe7bb2f6c2d05f53be">bsl::multiset::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gae46a5c1b724ee361ab715730a04ee343">bsl::multiset::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga2632d712ac5d1f005d7b6bb8944df409">bsl::multiset::const_reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga667bb70cc434e99476ef49009f266c62">bsl::multiset::DataWrapper::DataWrapper</a> (const COMPARATOR &amp;comparator, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaae4b8deaf428c9d321959a60afc8844e">bsl::multiset::multiset</a> (const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga4e56e5dc184c924fe0bedebaf4fbc792">bsl::multiset::multiset</a> (const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga6890de854a0d629ef6e656d7d664397b">bsl::multiset::multiset</a> (const multiset &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga124343f3b0b5e737cbf5db4f54e221d1">bsl::multiset::multiset</a> (const multiset &amp;original, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga9c602ef4d5974ee6b259b74b1d556698">bsl::multiset::multiset</a> (INPUT_ITERATOR first, INPUT_ITERATOR last, const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga8fb9e08247f0e827f3968188011671bc">bsl::multiset::~multiset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">multiset&lt; KEY, COMPARATOR, <br class="typebreak"/>
ALLOCATOR &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaa37cc872a2ce09d37f6fdd32b3d3e84c">bsl::multiset::operator=</a> (const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga56f615a4fc14f4953bf56e4f3cfe4ba0">bsl::multiset::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gacdd018c996cb2d356b2b446a273925d4">bsl::multiset::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga84713eee80218d58fa095274afe9249d">bsl::multiset::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga8d336fba1428783905d0ac761f3c67aa">bsl::multiset::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga8eb2551443845643c359a9e204a30569">bsl::multiset::insert</a> (const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gab17242e33a57c775ce2ee5dc0d11039a">bsl::multiset::insert</a> (const_iterator hint, const value_type &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaf6ed690d7c9b5225f531912db5b091c7">bsl::multiset::insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga8d7ce0f7ac4800d9e1977f1d9917057a">bsl::multiset::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga757bd4489500b6374a00489cc3b22a13">bsl::multiset::erase</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gae3a272f1d56f4568c41ee09c0e71de21">bsl::multiset::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga0c037f76cf02523dc874ba949c50450a">bsl::multiset::swap</a> (multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaa7ae2bf99f7510d00558251167dac10b">bsl::multiset::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga538652a2c3fb3e9b0700efb5e7d0b8f0">bsl::multiset::find</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga80a753865ba97fc904ce88e093b7dd81">bsl::multiset::lower_bound</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaa3b1b46aa718f5d35aa24284e72d5058">bsl::multiset::upper_bound</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga7fc9cc9bd2f827962cb6399df305162d">bsl::multiset::equal_range</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gabb37ed32a2d3a972c4655010000dab45">bsl::multiset::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaf23ecce841e8897c5adf66d72618bd8d">bsl::multiset::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga1c02b59baa6acacc3d95af0c3d15a144">bsl::multiset::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga66ec99d2cc7b7fbf0c1500233fa50ac7">bsl::multiset::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gad0603e50ff382e2c6f5912b93235bb74">bsl::multiset::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaf61ac11f4d257f79ca0172143ef3410a">bsl::multiset::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga2f927fc2f76c5892989772b7d1180580">bsl::multiset::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga39a868cfb734a6f82c0c8d1553e9d549">bsl::multiset::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga49660436d7ad4cc4154bdcbab7e40c49">bsl::multiset::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga5315ecb5285156c43b74542c2b840d8f">bsl::multiset::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga8024a2ade2ca42fc4171c46b92b33e23">bsl::multiset::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gae1686c2de94f7635f53c06276217a17f">bsl::multiset::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">key_compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga32264cc8a083836d374968c4c74ac228">bsl::multiset::key_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">value_compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gac04f19a5457acf516b7ed69371eadbac">bsl::multiset::value_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaff15c6b84b8f2ebf99a7c971e2f42a32">bsl::multiset::find</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaaa0c47d3476e8d9e1b448f1e4f59c0fd">bsl::multiset::count</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga7408ec0437e1dc8e6d7e44f7fea8d8e4">bsl::multiset::lower_bound</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga31cf6d69d26fde55cf3ce9e0af1dae10">bsl::multiset::upper_bound</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga8e69ed7b9cd1ae83c5238184f4951141">bsl::multiset::equal_range</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga6b27ce014d210bdab4dcc0e8eb313262">bsl::operator==</a> (const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaa9e0287e54abb4f45c0b5d6d81e138cd">bsl::operator!=</a> (const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga5f75f92a4ad3cea69cc8d4dd81f1a892">bsl::operator&lt;</a> (const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#ga0202c754266ad01bd8e5fb5bf3eb0f4b">bsl::operator&gt;</a> (const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gae4d913748cdddae30ae432d7407d94e0">bsl::operator&gt;=</a> (const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gaad5b6eb4abdefb9a20e2af663b822573">bsl::operator&lt;=</a> (const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__multiset.html#gab649ed015369ea41b6e05bc6b524dcd8">bsl::swap</a> (multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;a, multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on <code>KEY</code></a> </li>
<li>
<a href="#3.2">Memory Allocation</a> <ul>
<li>
<a href="#3.2.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Operations</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Creating a Shopping Cart</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant multiset class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a> </td><td>STL-compatible multiset template  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__set.html" title="Provide an STL-compliant set class.">Component bslstl_set</a>, <a class="el" href="group__bslstl__multimap.html" title="Provide an STL-compliant multimap class.">Component bslstl_multimap</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template <code><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a></code>, implementing the standard container holding an ordered sequence of possibly duplicate keys. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>multiset</code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of keys) and the ordered sequence of keys the <code>multiset</code> contains. If <code>multiset</code> is instantiated with a key type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if the key type cannot be tested for equality, then a multiset containing that type cannot be tested for equality. It is even possible to instantiate <code>multiset</code> with a key type that does not have a copy-constructor, in which case the <code>multiset</code> will not be copyable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A multiset meets the requirements of an associative container with bidirectional iterators in the C++ standard [23.2.4]. The <code>multiset</code> implemented here adheres to the C++11 standard, except that it does not have interfaces that take rvalue references, <code>initializer_lists</code>, <code>emplace</code>, or operations taking a variadic number of template parameters. Note that excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_key"></a> <a class="anchor" id="description.requirements_on_key"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on KEY: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>multiset</code> is a fully <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the supplied <code>KEY</code> template parameters is fully value-semantic. It is possible to instantiate a <code>multiset</code> with <code>KEY</code> parameter arguments that do not provide a full multiset of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code>multiset</code> to describe a function's requirements for the <code>KEY</code> template parameter. These terms are also defined in section [17.6.3.1] of the C++11 standard. Note that, in the context of a <code>multiset</code> instantiation, the requirements apply specifically to the multiset's entry type, <code>value_type</code>, which is an alias for <code>KEY</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_key.default-constructible"></a> <a class="anchor" id="description.requirements_on_key.default-constructible"></a> <em>default-constructible</em>: The type provides a default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_key.copy-constructible"></a> <a class="anchor" id="description.requirements_on_key.copy-constructible"></a> <em>copy-constructible</em>: The type provides a copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_key.equality-comparable"></a> <a class="anchor" id="description.requirements_on_key.equality-comparable"></a> <em>equality-comparable</em>: The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="less-than-comparable"></a> <a class="anchor" id="requirements_on_key.less-than-comparable"></a> <a class="anchor" id="description.requirements_on_key.less-than-comparable"></a> <em>less-than-comparable</em>: The type provides a less-than operator, which defines a strict weak ordering relation on values of the type.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a multiset's <code>ALLOCATOR</code> template parameter determines how that multiset will allocate memory. The <code>multiset</code> template supports allocators meeting the requirements of the C++11 standard [17.6.3.5], in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the (template parameter) type <code>ALLOCATOR</code> of an <code>multiset</code> instantiation' is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that multiset type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a multiset accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it is used to supply memory for the multiset throughout its lifetime; otherwise, the multiset will use the default allocator installed at the time of the multiset's construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, a multiset supplies that allocator's address to the constructors of contained objects of the (template parameter) type <code>KEY</code> with the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code>multiset</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;K&#39;</span>             - (<span class="keyword">template</span> parameter) type <span class="stringliteral">&#39;KEY&#39;</span> of the multiset
  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>        - two distinct objects of type <span class="stringliteral">&#39;multiset&lt;K&gt;&#39;</span>
  <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;m&#39;</span>        - number of elements in <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span> respectively
  <span class="charliteral">&#39;c&#39;</span>             - comparator providing an ordering <span class="keywordflow">for</span> objects of type <span class="charliteral">&#39;K&#39;</span>
  <span class="stringliteral">&#39;al             - an STL-style memory allocator</span>
<span class="stringliteral">  &#39;</span>i1<span class="stringliteral">&#39;, &#39;</span>i2<span class="stringliteral">&#39;      - two iterators defining a sequence of &#39;</span>value_type<span class="stringliteral">&#39; objects</span>
<span class="stringliteral">  &#39;</span>k<span class="stringliteral">&#39;             - an object of type &#39;</span>K<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>p1<span class="stringliteral">&#39;, &#39;</span>p2<span class="stringliteral">&#39;      - two iterators belonging to &#39;</span>a<span class="stringliteral">&#39;</span>
<span class="stringliteral">  distance(i1,i2) - the number of elements in the range [i1, i2)</span>
<span class="stringliteral"></span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | Operation                                          | Complexity         |</span>
<span class="stringliteral">  +====================================================+====================+</span>
<span class="stringliteral">  | multiset&lt;K&gt; a;    (default construction)           | O[1]               |</span>
<span class="stringliteral">  | multiset&lt;K&gt; a(al);                                 |                    |</span>
<span class="stringliteral">  | multiset&lt;K&gt; a(c, al);                              |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | multiset&lt;K&gt; a(b); (copy construction)              | O[n]               |</span>
<span class="stringliteral">  | multiset&lt;K&gt; a(b, al);                              |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | multiset&lt;K&gt; a(i1, i2);                             | O[N] if [i1, i2)   |</span>
<span class="stringliteral">  | multiset&lt;K&gt; a(i1, i2, al);                         | is sorted with     |</span>
<span class="stringliteral">  | multiset&lt;K&gt; a(i1, i2, c, al);                      | &#39;</span>a.value_comp()<span class="stringliteral">&#39;,  |</span>
<span class="stringliteral">  |                                                    | O[N * log(N)]      |</span>
<span class="stringliteral">  |                                                    | otherwise, where N |</span>
<span class="stringliteral">  |                                                    | is distance(i1,i2) |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.~multiset&lt;K&gt;(); (destruction)                    | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a = b;            (assignment)                     | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |</span>
<span class="stringliteral">  | a.rbegin(), a.rend(), a.crbegin(), a.crend()       |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a == b, a != b                                     | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b                       | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.swap(b), swap(a,b)                               | O[1] if &#39;</span>a<span class="stringliteral">&#39; and    |</span>
<span class="stringliteral">  |                                                    | &#39;</span>b<span class="stringliteral">&#39; use the same   |</span>
<span class="stringliteral">  |                                                    | allocator,         |</span>
<span class="stringliteral">  |                                                    | O[n + m] otherwise |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.size()                                           | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_size()                                       | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.empty()                                          | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | get_allocator()                                    | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(k)                                        | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(p1, k)                                    | amortized constant |</span>
<span class="stringliteral">  |                                                    | if the value is    |</span>
<span class="stringliteral">  |                                                    | inserted right     |</span>
<span class="stringliteral">  |                                                    | before p1,         |</span>
<span class="stringliteral">  |                                                    | O[log(n)]          |</span>
<span class="stringliteral">  |                                                    | otherwise          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(i1, i2)                                   | O[log(N) *         |</span>
<span class="stringliteral">  |                                                    |   distance(i1,i2)] |</span>
<span class="stringliteral">  |                                                    |                    |</span>
<span class="stringliteral">  |                                                    | where N is         |</span>
<span class="stringliteral">  |                                                    | n + distance(i1,i2)|</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1)                                        | amortized constant |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(k)                                         | O[log(n) +         |</span>
<span class="stringliteral">  |                                                    | a.count(k)]        |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1, p2)                                    | O[log(n) +         |</span>
<span class="stringliteral">  |                                                    | distance(p1, p2)]  |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1, p2)                                    | O[log(n) +         |</span>
<span class="stringliteral">  |                                                    | distance(p1, p2)]  |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.clear()                                          | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.key_comp()                                       | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.value_comp()                                     | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.find(k)                                          | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.count(k)                                         | O[log(n) +         |</span>
<span class="stringliteral">  |                                                    | a.count(k)]        |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.lower_bound(k)                                   | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.upper_bound(k)                                   | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.equal_range(k)                                   | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_shopping_cart"></a> <a class="anchor" id="usage.example_1~3A_creating_a_shopping_cart"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_shopping_cart"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Shopping Cart: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will utilize <code><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a></code> to define a class <code>ShoppingCart</code>, that characterizes a simple online shopping cart with the ability to add, remove, and view items in the shopping cart. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that this example uses a type <code>string</code> that is based on the standard type <code>string</code> (see <code>bslstl_string</code>). For the sake of brevity, the implementation of <code>string</code> is not explored here. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a comparison functor for <code>string</code> objects: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>StringComparator {
      <span class="comment">// This &#39;struct&#39; defines an ordering on &#39;string&#39; values, allowing</span>
      <span class="comment">// them to be included in sorted containers such as &#39;bsl::multiset&#39;.</span>

      <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; lhs, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; rhs) <span class="keyword">const</span>
          <span class="comment">// Return &#39;true&#39; if the value of the specified &#39;lhs&#39; is less than</span>
          <span class="comment">// (ordered before) the value of the specified &#39;rhs&#39;, and &#39;false&#39;</span>
          <span class="comment">// otherwise.</span>
      {
          <span class="keywordtype">int</span> cmp = std::strcmp(lhs.c_str(), rhs.c_str());
          <span class="keywordflow">return</span> cmp &lt; 0;
      }
  };
</pre></div><br/>
<br/>
 Then, we define the public interface for <code>ShoppingCart</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ShoppingCart {
      <span class="comment">// This class provides an ordered collection of (possibly duplicate)</span>
      <span class="comment">// items in a shopping cart.  For simplicity of the usage example, each</span>
      <span class="comment">// item in the shopping cart is represented by a &#39;string&#39;.</span>
</pre></div><br/>
<br/>
 Here, we create a type alias, <code>StringSet</code>, for a <code><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a></code> that will serve as the data member for a <code>ShoppingCart</code>. A <code>StringSet</code> has keys of type <code>string</code>, and uses the default <code>ALLOCATOR</code> template parameter to be compatible with <code>bslma</code> style allocators: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1multiset.html">bsl::multiset&lt;string, StringComparator&gt;</a> StringSet;
          <span class="comment">// This &#39;typedef&#39; is an alias for a set of &#39;string&#39; objects, each</span>
          <span class="comment">// representing an item in a shopping cart;</span>

      <span class="comment">// DATA</span>
      StringSet d_items;  <span class="comment">// set of items in the shopping cart</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> ShoppingCart&amp; lhs,
                             <span class="keyword">const</span> ShoppingCart&amp; rhs);

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> StringSet::const_iterator ConstIterator;
          <span class="comment">// This &#39;typedef&#39; provides an alias for the type of an iterator</span>
          <span class="comment">// providing non-modifiable access to the items in a</span>
          <span class="comment">// &#39;ShoppingCart&#39;.</span>

      <span class="comment">// CREATORS</span>
      ShoppingCart(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;Shopping&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      ShoppingCart(<span class="keyword">const</span> ShoppingCart&amp;  original,
                   <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>    *basicAllocator = 0);
          <span class="comment">// Create a &#39;ShoppingCart&#39; object having the same value as the</span>
          <span class="comment">// specified &#39;original&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      ShoppingCart&amp; operator=(<span class="keyword">const</span> ShoppingCart&amp; rhs);
          <span class="comment">// Assign to this object the value of the specified &#39;rhs&#39; object,</span>
          <span class="comment">// and return a reference providing modifiable access to this</span>
          <span class="comment">// object.</span>

      <span class="keywordtype">void</span> addItem(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name);
          <span class="comment">// Add an item with the specified &#39;name&#39; to this shopping cart.</span>
          <span class="comment">// The behavior is undefined unless &#39;name&#39; is a non-empty strings.</span>

      <span class="keywordtype">int</span> removeItems(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name);
          <span class="comment">// Remove from this phone book all items having the specified</span>
          <span class="comment">// &#39;name&#39;, if they exist, and return the number of removed items;</span>
          <span class="comment">// otherwise, return 0 with no other effects.  The behavior is</span>
          <span class="comment">// undefined unless &#39;name&#39; is a non-empty strings.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> count(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name) <span class="keyword">const</span>;
          <span class="comment">// Return the number of items in the shopping cart with the</span>
          <span class="comment">// specified &#39;name&#39;.  The behavior is undefined unless &#39;name&#39; is a</span>
          <span class="comment">// non-empty strings.</span>

      ConstIterator begin() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the first</span>
          <span class="comment">// item in the ordered sequence of item held in this shopping cart,</span>
          <span class="comment">// or the past-the-end iterator if this shopping cart is empty.</span>

      ConstIterator end() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// past-the-end item in the ordered sequence of items maintained by</span>
          <span class="comment">// this shopping cart.</span>

      <span class="keywordtype">int</span> numItems() <span class="keyword">const</span>;
          <span class="comment">// Return the number of items contained in this shopping cart.</span>
  };
</pre></div><br/>
<br/>
 Then, we declare the free operators for <code>ShoppingCart</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> ShoppingCart&amp; lhs, <span class="keyword">const</span> ShoppingCart&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two &#39;ShoppingCart&#39; objects have the</span>
      <span class="comment">// same value if they have the same number of items, and each</span>
      <span class="comment">// corresponding item, in their respective ordered sequence of items,</span>
      <span class="comment">// is the same.</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> ShoppingCart&amp; lhs, <span class="keyword">const</span> ShoppingCart&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;PhoneBook&#39; objects do</span>
      <span class="comment">// not have the same value if they either differ in their number of</span>
      <span class="comment">// contained items, or if any of the corresponding items, in their</span>
      <span class="comment">// respective ordered sequences of items, is not the same.</span>
</pre></div><br/>
<br/>
 Now, we define the implementations methods of the <code>ShoppingCart</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment"> CREATORS
  <span class="keyword">inline</span>
  ShoppingCart::ShoppingCart(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_items(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Notice that, on construction, we pass the contained <code><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a></code> object the allocator supplied to <code>ShoppingCart</code> at construction'. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  ShoppingCart::ShoppingCart(<span class="keyword">const</span> ShoppingCart&amp;   original,
                             <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>     *basicAllocator)
  : d_items(original.d_items, basicAllocator)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  ShoppingCart&amp; ShoppingCart::operator=(<span class="keyword">const</span> ShoppingCart&amp; rhs)
  {
      d_items = rhs.d_items;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> ShoppingCart::addItem(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(!name.empty());

      d_items.insert(name);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> ShoppingCart::removeItems(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(!name.empty());

      <span class="keywordflow">return</span> d_items.erase(name);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keywordtype">int</span> ShoppingCart::count(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(!name.empty());

      <span class="keywordflow">return</span> d_items.count(name);
  }

  ShoppingCart::ConstIterator ShoppingCart::begin()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_items.begin();
  }

  ShoppingCart::ConstIterator ShoppingCart::end()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_items.end();
  }

  <span class="keywordtype">int</span> ShoppingCart::numItems()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_items.size();
  }
</pre></div><br/>
<br/>
 Finally, we implement the free operators for <code>ShoppingCart</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> ShoppingCart&amp; lhs, <span class="keyword">const</span> ShoppingCart&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_items == rhs.d_items;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> ShoppingCart&amp; lhs, <span class="keyword">const</span> ShoppingCart&amp; rhs)
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaa0c394909b60376ae9f39dea0face1c4"></a><!-- doxytag: member="bsl::multiset::key_type" ref="gaa0c394909b60376ae9f39dea0face1c4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::key_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga836c56ba0e227a2ebaa2e9ac005276aa"></a><!-- doxytag: member="bsl::multiset::value_type" ref="ga836c56ba0e227a2ebaa2e9ac005276aa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2762d608f899a860fa54791529381bb3"></a><!-- doxytag: member="bsl::multiset::key_compare" ref="ga2762d608f899a860fa54791529381bb3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef COMPARATOR <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::key_compare<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2ce2df2b63c2a922795c96f6faf7fab3"></a><!-- doxytag: member="bsl::multiset::value_compare" ref="ga2ce2df2b63c2a922795c96f6faf7fab3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef COMPARATOR <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::value_compare<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad66097606b85feb88c65210b78f16e16"></a><!-- doxytag: member="bsl::multiset::allocator_type" ref="gad66097606b85feb88c65210b78f16e16" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1a248a4bd053c225c55c5b8502f00f3f"></a><!-- doxytag: member="bsl::multiset::reference" ref="ga1a248a4bd053c225c55c5b8502f00f3f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type&amp; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae749d18427aa8d08d5f6f33327026f32"></a><!-- doxytag: member="bsl::multiset::const_reference" ref="gae749d18427aa8d08d5f6f33327026f32" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const value_type&amp; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gafb01192076790ad9eb29474c45a73542"></a><!-- doxytag: member="bsl::multiset::size_type" ref="gafb01192076790ad9eb29474c45a73542" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::size_type <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaaf6f4354fe4daaa2d8bd8f92218400b9"></a><!-- doxytag: member="bsl::multiset::difference_type" ref="gaaf6f4354fe4daaa2d8bd8f92218400b9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::difference_type <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac43dc557e91922353623ae35cda62643"></a><!-- doxytag: member="bsl::multiset::pointer" ref="gac43dc557e91922353623ae35cda62643" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::pointer <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaae5ed187e25fc76466158c2d176070c1"></a><!-- doxytag: member="bsl::multiset::const_pointer" ref="gaae5ed187e25fc76466158c2d176070c1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::const_pointer <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga29846c31f4e8ff13cbe22c44f32898ed"></a><!-- doxytag: member="bsl::multiset::iterator" ref="ga29846c31f4e8ff13cbe22c44f32898ed" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::TreeIterator&lt;const value_type, Node, difference_type&gt; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga16d7cd51bad8cbbe7bb2f6c2d05f53be"></a><!-- doxytag: member="bsl::multiset::const_iterator" ref="ga16d7cd51bad8cbbe7bb2f6c2d05f53be" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::TreeIterator&lt;const value_type, Node, difference_type&gt; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae46a5c1b724ee361ab715730a04ee343"></a><!-- doxytag: member="bsl::multiset::reverse_iterator" ref="gae46a5c1b724ee361ab715730a04ee343" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2632d712ac5d1f005d7b6bb8944df409"></a><!-- doxytag: member="bsl::multiset::const_reverse_iterator" ref="ga2632d712ac5d1f005d7b6bb8944df409" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga667bb70cc434e99476ef49009f266c62"></a><!-- doxytag: member="bsl::multiset::DataWrapper::DataWrapper" ref="ga667bb70cc434e99476ef49009f266c62" args="(const COMPARATOR &amp;comparator, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::DataWrapper::DataWrapper </td>
          <td>(</td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>DataWrapper</code> object with the specified <code>comparator</code> and <code>basicAllocator</code>. </p>

</div>
</div>
<a class="anchor" id="gaae4b8deaf428c9d321959a60afc8844e"></a><!-- doxytag: member="bsl::multiset::multiset" ref="gaae4b8deaf428c9d321959a60afc8844e" args="(const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::multiset </td>
          <td>(</td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em> = <code>COMPARATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicAllocator</em>&nbsp;</td><td>Construct an empty multiset. Optionally specify a <code>comparator</code> used to order keys contained in this object. If <code>comparator</code> is not supplied, a default-constructed object of the (template parameter) type <code>COMPARATOR</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator is used to supply memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4e56e5dc184c924fe0bedebaf4fbc792"></a><!-- doxytag: member="bsl::multiset::multiset" ref="ga4e56e5dc184c924fe0bedebaf4fbc792" args="(const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::multiset </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty multiset that will use the specified <code>basicAllocator</code> to supply memory. Use a default-constructed object of the (template parameter) type <code>COMPARATOR</code> to order the keys contained in this multiset. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="ga6890de854a0d629ef6e656d7d664397b"></a><!-- doxytag: member="bsl::multiset::multiset" ref="ga6890de854a0d629ef6e656d7d664397b" args="(const multiset &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::multiset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a multiset having the same value as the specified <code>original</code>. Use a copy of <code>original.key_comp()</code> to order the keys contained in this multiset. Use the allocator returned by 'bslallocator_traits&lt;ALLOCATOR&gt;:: select_on_container_copy_construction(original.allocator())' to allocate memory. If the (template parameter) type <code>ALLOCATOR</code> is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), the currently installed default allocator is used to supply memory. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga124343f3b0b5e737cbf5db4f54e221d1"></a><!-- doxytag: member="bsl::multiset::multiset" ref="ga124343f3b0b5e737cbf5db4f54e221d1" args="(const multiset &amp;original, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::multiset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a multiset having the same value as that of the specified <code>original</code> that will use the specified <code>basicAllocator</code> to supply memory. Use a copy of <code>original.key_comp()</code> to order the keys contained in this multiset. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga9c602ef4d5974ee6b259b74b1d556698"></a><!-- doxytag: member="bsl::multiset::multiset" ref="ga9c602ef4d5974ee6b259b74b1d556698" args="(INPUT_ITERATOR first, INPUT_ITERATOR last, const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::multiset </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em> = <code>COMPARATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a set, and insert each <code>value_type</code> object in the sequence starting at the specified <code>first</code> element, and ending immediately before the specified <code>last</code> element, ignoring those keys that appears earlier in the sequence. Optionally specify a <code>comparator</code> used to order keys contained in this object. If <code>comparator</code> is not supplied, a default-constructed object of the (template parameter) type <code>COMPARATOR</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator is used to supply memory. If the sequence <code>first</code> and <code>last</code> is ordered according to the identified <code>comparator</code>, then this operation has <code>O[N]</code> complexity, where <code>N</code> is the number of elements between <code>first</code> and <code>last</code>, otherwise this operation has <code>O[N * log(N)]</code> complexity. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8fb9e08247f0e827f3968188011671bc"></a><!-- doxytag: member="bsl::multiset::~multiset" ref="ga8fb9e08247f0e827f3968188011671bc" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::~multiset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gaa37cc872a2ce09d37f6fdd32b3d3e84c"></a><!-- doxytag: member="bsl::multiset::operator=" ref="gaa37cc872a2ce09d37f6fdd32b3d3e84c" args="(const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">multiset&lt;KEY, COMPARATOR, ALLOCATOR&gt;&amp; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value and comparator of the specified <code>rhs</code> object, propagate to this object the allocator of <code>rhs</code> if the <code>ALLOCATOR</code> type has trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga56f615a4fc14f4953bf56e4f3cfe4ba0"></a><!-- doxytag: member="bsl::multiset::begin" ref="ga56f615a4fc14f4953bf56e4f3cfe4ba0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multiset, or the <code>end</code> iterator if this multiset is empty. </p>

</div>
</div>
<a class="anchor" id="gacdd018c996cb2d356b2b446a273925d4"></a><!-- doxytag: member="bsl::multiset::end" ref="gacdd018c996cb2d356b2b446a273925d4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this multiset. </p>

</div>
</div>
<a class="anchor" id="ga84713eee80218d58fa095274afe9249d"></a><!-- doxytag: member="bsl::multiset::rbegin" ref="ga84713eee80218d58fa095274afe9249d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multiset, or <code>rend</code> if this multiset is empty. </p>

</div>
</div>
<a class="anchor" id="ga8d336fba1428783905d0ac761f3c67aa"></a><!-- doxytag: member="bsl::multiset::rend" ref="ga8d336fba1428783905d0ac761f3c67aa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this multiset. </p>

</div>
</div>
<a class="anchor" id="ga8eb2551443845643c359a9e204a30569"></a><!-- doxytag: member="bsl::multiset::insert" ref="ga8eb2551443845643c359a9e204a30569" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#ga836c56ba0e227a2ebaa2e9ac005276aa">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this multiset. If a range containing elements equivalent to <code>value</code> already exist, insert <code>value</code> at the end of that range. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gab17242e33a57c775ce2ee5dc0d11039a"></a><!-- doxytag: member="bsl::multiset::insert" ref="gab17242e33a57c775ce2ee5dc0d11039a" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__multiset.html#ga16d7cd51bad8cbbe7bb2f6c2d05f53be">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#ga836c56ba0e227a2ebaa2e9ac005276aa">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this multiset as close as possible to the position just prior to the specified <code>hint</code> (in amortized constant time if the <code>hint</code> is a valid immediate successor to <code>value</code>). If <code>hint</code> is not a valid immediate successor to <code>value</code>, this operation has <code>O[log(N)]</code> complexity, where <code>N</code> is the size of this set. The behavior is undefined unless <code>hint</code> is a valid iterator into this set. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaf6ed690d7c9b5225f531912db5b091c7"></a><!-- doxytag: member="bsl::multiset::insert" ref="gaf6ed690d7c9b5225f531912db5b091c7" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert into this multiset the value of each <code>value_type</code> object in the range starting at the specified <code>first</code> iterator and ending immediately before the specified <code>last</code> iterator. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8d7ce0f7ac4800d9e1977f1d9917057a"></a><!-- doxytag: member="bsl::multiset::erase" ref="ga8d7ce0f7ac4800d9e1977f1d9917057a" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__multiset.html#ga16d7cd51bad8cbbe7bb2f6c2d05f53be">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this set the <code>value_type</code> object at the specified <code>position</code>, and return an iterator referring to the element immediately following the removed element, or to the past-the-end position if the removed element was the last element in the sequence of elements maintained by this set. The behavior is undefined unless <code>position</code> refers to a <code>value_type</code> object in this multiset. </p>

</div>
</div>
<a class="anchor" id="ga757bd4489500b6374a00489cc3b22a13"></a><!-- doxytag: member="bsl::multiset::erase" ref="ga757bd4489500b6374a00489cc3b22a13" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remote from this multiset all <code>value_type</code> objects having the specified <code>key</code>, if they exist, and return the number of erased objects; otherwise, if there is no <code>value_type</code> objects having <code>key</code>, return 0 with no other effect. </p>

</div>
</div>
<a class="anchor" id="gae3a272f1d56f4568c41ee09c0e71de21"></a><!-- doxytag: member="bsl::multiset::erase" ref="gae3a272f1d56f4568c41ee09c0e71de21" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__multiset.html#ga16d7cd51bad8cbbe7bb2f6c2d05f53be">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__multiset.html#ga16d7cd51bad8cbbe7bb2f6c2d05f53be">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this multiset the <code>value_type</code> objects starting at the specified <code>first</code> position up to, but including the specified <code>last</code> position, and return <code>last</code>. The behavior is undefined unless <code>first</code> and <code>last</code> either refer to elements in this multiset or are the <code>end</code> iterator, and the <code>first</code> position is at or before the <code>last</code> position in the ordered sequence provided by this container. </p>

</div>
</div>
<a class="anchor" id="ga0c037f76cf02523dc874ba949c50450a"></a><!-- doxytag: member="bsl::multiset::swap" ref="ga0c037f76cf02523dc874ba949c50450a" args="(multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1multiset.html">multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object as well as its comparator with those of the specified <code>other</code> object. Additionally, if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code>, then exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees <code>O[1]</code> complexity. The behavior is undefined unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="gaa7ae2bf99f7510d00558251167dac10b"></a><!-- doxytag: member="bsl::multiset::clear" ref="gaa7ae2bf99f7510d00558251167dac10b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all entries from this multiset. Note that the multiset is empty after this call, but allocated memory may be retained for future use. </p>

</div>
</div>
<a class="anchor" id="ga538652a2c3fb3e9b0700efb5e7d0b8f0"></a><!-- doxytag: member="bsl::multiset::find" ref="ga538652a2c3fb3e9b0700efb5e7d0b8f0" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object that is the same as the specified <code>key</code> in ordered sequence maintained by this multiset, if such an object exists; otherwise, return the past-the-end (<code>end</code>) iterator. </p>

</div>
</div>
<a class="anchor" id="ga80a753865ba97fc904ce88e093b7dd81"></a><!-- doxytag: member="bsl::multiset::lower_bound" ref="ga80a753865ba97fc904ce88e093b7dd81" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this multiset greater-than or equal-to the specified <code>key</code>, and the past-the-end iterator if this multiset does not contain a <code>value_type</code> greater-than or equal-to <code>key</code>. Note that this function returns the <em>first</em> position before which <code>key</code> could be inserted into the ordered sequence maintained by this multiset, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="gaa3b1b46aa718f5d35aa24284e72d5058"></a><!-- doxytag: member="bsl::multiset::upper_bound" ref="gaa3b1b46aa718f5d35aa24284e72d5058" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this multiset greater than the specified <code>key</code>, and the past-the-end iterator if this multiset does not contain a <code>value_type</code> object whose key is greater-than <code>key</code>. Note that this function returns the <em>last</em> position before which a <code>key</code> could be inserted into the ordered sequence maintained by this multiset, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga7fc9cc9bd2f827962cb6399df305162d"></a><!-- doxytag: member="bsl::multiset::equal_range" ref="ga7fc9cc9bd2f827962cb6399df305162d" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;iterator, iterator&gt; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing modifiable access to the sequence of <code>value_type</code> objects in this multiset the same as the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. The first returned iterator will be <code>lower_bound(key)</code>; the second returned iterator will be <code>upper_bound(key)</code>; and, if this multiset contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. </p>

</div>
</div>
<a class="anchor" id="gabb37ed32a2d3a972c4655010000dab45"></a><!-- doxytag: member="bsl::multiset::get_allocator" ref="gabb37ed32a2d3a972c4655010000dab45" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the allocator used for memory allocation by this multiset. </p>

</div>
</div>
<a class="anchor" id="gaf23ecce841e8897c5adf66d72618bd8d"></a><!-- doxytag: member="bsl::multiset::begin" ref="gaf23ecce841e8897c5adf66d72618bd8d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multiset, or the <code>end</code> iterator if this multiset is empty. </p>

</div>
</div>
<a class="anchor" id="ga1c02b59baa6acacc3d95af0c3d15a144"></a><!-- doxytag: member="bsl::multiset::end" ref="ga1c02b59baa6acacc3d95af0c3d15a144" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this multiset. </p>

</div>
</div>
<a class="anchor" id="ga66ec99d2cc7b7fbf0c1500233fa50ac7"></a><!-- doxytag: member="bsl::multiset::rbegin" ref="ga66ec99d2cc7b7fbf0c1500233fa50ac7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multiset, or <code>rend</code> if this multiset is empty. </p>

</div>
</div>
<a class="anchor" id="gad0603e50ff382e2c6f5912b93235bb74"></a><!-- doxytag: member="bsl::multiset::rend" ref="gad0603e50ff382e2c6f5912b93235bb74" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this multiset. </p>

</div>
</div>
<a class="anchor" id="gaf61ac11f4d257f79ca0172143ef3410a"></a><!-- doxytag: member="bsl::multiset::cbegin" ref="gaf61ac11f4d257f79ca0172143ef3410a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multiset, or the <code>end</code> iterator if this multiset is empty. </p>

</div>
</div>
<a class="anchor" id="ga2f927fc2f76c5892989772b7d1180580"></a><!-- doxytag: member="bsl::multiset::cend" ref="ga2f927fc2f76c5892989772b7d1180580" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this multiset. </p>

</div>
</div>
<a class="anchor" id="ga39a868cfb734a6f82c0c8d1553e9d549"></a><!-- doxytag: member="bsl::multiset::crbegin" ref="ga39a868cfb734a6f82c0c8d1553e9d549" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this multiset, or <code>rend</code> if this multiset is empty. </p>

</div>
</div>
<a class="anchor" id="ga49660436d7ad4cc4154bdcbab7e40c49"></a><!-- doxytag: member="bsl::multiset::crend" ref="ga49660436d7ad4cc4154bdcbab7e40c49" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this multiset. </p>

</div>
</div>
<a class="anchor" id="ga5315ecb5285156c43b74542c2b840d8f"></a><!-- doxytag: member="bsl::multiset::empty" ref="ga5315ecb5285156c43b74542c2b840d8f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this multiset contains no elements, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga8024a2ade2ca42fc4171c46b92b33e23"></a><!-- doxytag: member="bsl::multiset::size" ref="ga8024a2ade2ca42fc4171c46b92b33e23" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this multiset. </p>

</div>
</div>
<a class="anchor" id="gae1686c2de94f7635f53c06276217a17f"></a><!-- doxytag: member="bsl::multiset::max_size" ref="gae1686c2de94f7635f53c06276217a17f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that this multiset could possibly hold. Note that there is no guarantee that the set can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="ga32264cc8a083836d374968c4c74ac228"></a><!-- doxytag: member="bsl::multiset::key_comp" ref="ga32264cc8a083836d374968c4c74ac228" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">key_compare <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the key-comparison functor (or function pointer) used by this multiset; if a comparator was supplied at construction, return its value, otherwise return a default constructed <code>key_compare</code> object. Note that this comparator compares objects of type <code>KEY</code>, which is the type of the <code>value_type</code> objects contained in this multiset. </p>

</div>
</div>
<a class="anchor" id="gac04f19a5457acf516b7ed69371eadbac"></a><!-- doxytag: member="bsl::multiset::value_comp" ref="gac04f19a5457acf516b7ed69371eadbac" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_compare <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a functor for comparing two <code>value_type</code> objects using <code>key_comp()</code>. Note that since <code>value_type</code> is an alias to <code>KEY</code> for <code>set</code>, this method returns the same functor as <code>key_comp()</code>. </p>

</div>
</div>
<a class="anchor" id="gaff15c6b84b8f2ebf99a7c971e2f42a32"></a><!-- doxytag: member="bsl::multiset::find" ref="gaff15c6b84b8f2ebf99a7c971e2f42a32" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object that is the same as the specified <code>key</code> in ordered sequence maintained by this multiset, if such an object exists; otherwise, return the past-the-end (<code>end</code>) iterator. </p>

</div>
</div>
<a class="anchor" id="gaaa0c47d3476e8d9e1b448f1e4f59c0fd"></a><!-- doxytag: member="bsl::multiset::count" ref="gaaa0c47d3476e8d9e1b448f1e4f59c0fd" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of <code>value_type</code> objects within this multiset the the same as the specified <code>key</code>. </p>

</div>
</div>
<a class="anchor" id="ga7408ec0437e1dc8e6d7e44f7fea8d8e4"></a><!-- doxytag: member="bsl::multiset::lower_bound" ref="ga7408ec0437e1dc8e6d7e44f7fea8d8e4" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this multiset greater-than or equal-to the specified <code>key</code>, and the past-the-end iterator if this multiset does not contain a <code>value_type</code> greater-than or equal-to <code>key</code>. Note that this function returns the <em>first</em> position before which <code>key</code> could be inserted into the ordered sequence maintained by this multiset, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga31cf6d69d26fde55cf3ce9e0af1dae10"></a><!-- doxytag: member="bsl::multiset::upper_bound" ref="ga31cf6d69d26fde55cf3ce9e0af1dae10" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this multiset greater than the specified <code>key</code>, and the past-the-end iterator if this multiset does not contain a <code>value_type</code> object whose key is greater-than <code>key</code>. Note that this function returns the <em>last</em> position before which a <code>key</code> could be inserted into the ordered sequence maintained by this multiset, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga8e69ed7b9cd1ae83c5238184f4951141"></a><!-- doxytag: member="bsl::multiset::equal_range" ref="ga8e69ed7b9cd1ae83c5238184f4951141" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;const_iterator, const_iterator&gt; <a class="el" href="classbsl_1_1multiset.html">bsl::multiset</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__multiset.html#gaa0c394909b60376ae9f39dea0face1c4">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing non-modifiable access to the sequence of <code>value_type</code> objects in this multiset the same as the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. The first returned iterator will be <code>lower_bound(key)</code>; the second returned iterator will be <code>upper_bound(key)</code>; and, if this multiset contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. </p>

</div>
</div>
<a class="anchor" id="ga6b27ce014d210bdab4dcc0e8eb313262"></a><!-- doxytag: member="bsl::operator==" ref="ga6b27ce014d210bdab4dcc0e8eb313262" args="(const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code>multiset</code> objects have the same value if they have the same number of keys, and each key that is contained in one of the objects is also contained in the other object. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaa9e0287e54abb4f45c0b5d6d81e138cd"></a><!-- doxytag: member="bsl::operator!=" ref="gaa9e0287e54abb4f45c0b5d6d81e138cd" args="(const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code>multiset</code> objects do not have the same value if they do not have the same number of keys, or some keys that is contained in one of the objects is not also contained in the other object. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga5f75f92a4ad3cea69cc8d4dd81f1a892"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga5f75f92a4ad3cea69cc8d4dd81f1a892" args="(const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is less than the specified <code>rhs</code> value, and <code>false</code> otherwise. A multiset, <code>lhs</code>, has a value that is less than that of <code>rhs</code>, if, for the first non-equal corresponding key in their respective sequences, the <code>lhs</code> key is less than the <code>rhs</code> key, or, if all their corresponding keys compare equal, <code>lhs</code> has fewer keys than <code>rhs</code>. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga0202c754266ad01bd8e5fb5bf3eb0f4b"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga0202c754266ad01bd8e5fb5bf3eb0f4b" args="(const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is greater than the specified <code>rhs</code> value, and <code>false</code> otherwise. A multiset, <code>lhs</code>, has a value that is greater than that of <code>rhs</code>, if, for the first non-equal corresponding key in their respective sequences, the <code>lhs</code> key is greater than the <code>rhs</code> key, or, if all their keys compare equal, <code>lhs</code> has more keys than <code>rhs</code>. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gae4d913748cdddae30ae432d7407d94e0"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gae4d913748cdddae30ae432d7407d94e0" args="(const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is less-than or equal-to the specified <code>rhs</code> value, and <code>false</code> otherwise. A multiset, <code>lhs</code>, has a value that is less-than or equal-to that of <code>rhs</code>, if, for the first non-equal corresponding key in their respective sequences, the <code>lhs</code> key is less than the <code>rhs</code> key, or, if all of their corresponding keys compare equal, <code>lhs</code> has less-than or equal number of keys as <code>rhs</code>. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaad5b6eb4abdefb9a20e2af663b822573"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gaad5b6eb4abdefb9a20e2af663b822573" args="(const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is greater-than or equal-to the specified <code>rhs</code> value, and <code>false</code> otherwise. A multiset, <code>lhs</code>, has a value that is greater-than or equal-to that of <code>rhs</code>, if, for the first corresponding key in their respective sequences, the <code>lhs</code> key is greater than the <code>rhs</code> key, or, if all of their corresponding keys compare equal, <code>lhs</code> has greater-than or equal number of keys <code>rhs</code>. Note that this method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__multiset.html#requirements_on_key.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__multiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gab649ed015369ea41b6e05bc6b524dcd8"></a><!-- doxytag: member="bsl::swap" ref="gab649ed015369ea41b6e05bc6b524dcd8" args="(multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;a, multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">multiset&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap both the value and the comparator of the specified <code>a</code> object with the value and comparator of the specified <code>b</code> object. Additionally, if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code>, then exchange the allocator of <code>a</code> with that of <code>b</code>, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees <code>O[1]</code> complexity. The behavior is undefined unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:05 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
