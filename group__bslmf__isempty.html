<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmf_isempty Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Component bslmf_isempty<br/>
<small>
[<a class="el" href="group__bslmf.html">Package bslmf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a compile-time check for detecting an empty class type.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Size.html">bsl::Is_Empty_Size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Class__Imp.html">bsl::Is_Empty_Class_Imp&lt; TYPE, IS_CLASS &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Class__Imp_3_01TYPE_00_01true_01_4.html">bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Imp.html">bsl::Is_Empty_Imp&lt; TYPE, IS_CLASS &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Is__Empty__Imp_3_01TYPE_00_01true_01_4.html">bsl::Is_Empty_Imp&lt; TYPE, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__empty.html">bsl::is_empty&lt; TYPE &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef integral_constant<br class="typebreak"/>
&lt; bool, sizeof(Derived)==sizeof(int)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmf__isempty.html#gadf40809bc5adf7678779ec7f62889d32">bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;::type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmf__isempty.html#ga29a28877c2e50494104607489a579a18">bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;::Derived::Derived</a> (const Derived &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmf__isempty.html#gad5596a41611638eb64f8d27c1305bf4e">bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;::Derived::~Derived</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmf__isempty.html#ga70e348a65b102b13483257a0438c5356">bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;::Derived::d_data</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Compute Storage Requirements for a Type</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a compile-time check for detecting an empty class type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsl_1_1is__empty.html">bsl::is_empty</a> </td><td>standard meta-function for detecting empty classes  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bslmf__isclass_8h.html" title="Provide a compile-time check for determining class types.">bslmf_isclass.h</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a metafunction, <code><a class="el" href="structbsl_1_1is__empty.html">bsl::is_empty</a></code>, which may be used to determine whether a type is a <code>class</code> or <code>struct</code> with no non-static data members other than bit-fields of length 0, no virtual member functions, no virtual base classes, and no base class <code>B</code> for which <code><a class="el" href="structbsl_1_1is__empty.html">is_empty</a>&lt;B&gt;value</code> is <code>false</code>. This metafunction conforms to the definition of the C++11 standard 'is_empty metafunction in section [meta.unary.prop]. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An empty class type type is <em>usually</em> stateless and, can be "stored" in a zero-length memory region. (Hypothetically, an empty object can hold state by means a global address-to-state map, but such a design is rare and is discouraged.) When a class inherits from an empty type, the compiler is expected to optimize away the storage requirements of the empty base class. This optimization is known as the "Empty Base Optimization" or "EBO". </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_compute_storage_requirements_for_a_type"></a> <a class="anchor" id="usage.example_1~3A_compute_storage_requirements_for_a_type"></a> <a class="anchor" id="description.usage.example_1~3A_compute_storage_requirements_for_a_type"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Compute Storage Requirements for a Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to create a generic function that will allocate a record comprising a value of specified <code>TYPE</code> and a description in the form of a null-terminated character string. First, we declare the function prototype: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> *makeRecord(<span class="keyword">const</span> TYPE&amp; value, <span class="keyword">const</span> <span class="keywordtype">char</span>* description);
</pre></div><br/>
<br/>
 Next, we implement the function so that the copy of <code>value</code> takes up no space if <code>TYPE</code> is an empty class. We manage this by computing a zero storage requirement if <code><a class="el" href="structbsl_1_1is__empty.html">is_empty</a>&lt;TYPE&gt;value</code> is true: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;cstring&gt;</span>
<span class="preprocessor">  #include &lt;new&gt;</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> *makeRecord(<span class="keyword">const</span> TYPE&amp; value, <span class="keyword">const</span> <span class="keywordtype">char</span>* description)
  {
      <span class="comment">// &#39;ValueSize&#39; is computed at compile time.</span>
      <span class="keyword">static</span> <span class="keyword">const</span> std::size_t ValueSize = <a class="code" href="structbsl_1_1is__empty.html">bsl::is_empty&lt;TYPE&gt;::value</a> ?
          0 : <span class="keyword">sizeof</span>(TYPE);

      <span class="comment">// Allocate memory for value and description</span>
      <span class="keyword">const</span> std::size_t MemSize = ValueSize + std::strlen(description) + 1;
      <span class="keywordtype">void</span> *mem = ::operator <span class="keyword">new</span>(MemSize);

      <span class="comment">// Construct copy of value at front of allocated memory</span>
      ::new(mem) TYPE(value);

      <span class="comment">// Copy description into space following value.</span>
      std::strcpy(static_cast&lt;char*&gt;(mem) + ValueSize, description);

      <span class="keywordflow">return</span> mem;
  }
</pre></div><br/>
<br/>
 Finally, we use <code>makeRecord</code> with both an empty and non-empty value type: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>EmptyMarker { };

  <span class="keywordtype">int</span> main()
  {
      <span class="keywordtype">void</span> *record1 = makeRecord(9999, <span class="stringliteral">&quot;four nines&quot;</span>);
      <span class="comment">// Value takes &#39;sizeof(int)&#39; bytes at front of record.</span>
      assert(9999 == *static_cast&lt;int*&gt;(record1));
      assert(0 == std::strcmp(static_cast&lt;char*&gt;(record1) + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),
                              <span class="stringliteral">&quot;four nines&quot;</span>));

      <span class="keywordtype">void</span> *record2 = makeRecord(EmptyMarker(), <span class="stringliteral">&quot;Empty&quot;</span>);
      <span class="comment">// Value takes no space at front of record.</span>
      assert(0 == std::strcmp(static_cast&lt;char*&gt;(record2), <span class="stringliteral">&quot;Empty&quot;</span>));

      ::operator <span class="keyword">delete</span>(record1);
      ::operator <span class="keyword">delete</span>(record2);

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gadf40809bc5adf7678779ec7f62889d32"></a><!-- doxytag: member="bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;::type" ref="gadf40809bc5adf7678779ec7f62889d32" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef integral_constant&lt;bool, sizeof(Derived) == sizeof(int)&gt; <a class="el" href="structbsl_1_1Is__Empty__Class__Imp.html">bsl::Is_Empty_Class_Imp</a>&lt; TYPE, true &gt;::type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>true_type</code> if (the template parameter) <code>TYPE</code> is an empty class, and <code>false_type</code> otherwise. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga29a28877c2e50494104607489a579a18"></a><!-- doxytag: member="bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;::Derived::Derived" ref="ga29a28877c2e50494104607489a579a18" args="(const Derived &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Is__Empty__Class__Imp.html">bsl::Is_Empty_Class_Imp</a>&lt; TYPE, true &gt;::Derived::Derived </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Declared but not defined </p>

</div>
</div>
<a class="anchor" id="gad5596a41611638eb64f8d27c1305bf4e"></a><!-- doxytag: member="bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;::Derived::~Derived" ref="gad5596a41611638eb64f8d27c1305bf4e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Is__Empty__Class__Imp.html">bsl::Is_Empty_Class_Imp</a>&lt; TYPE, true &gt;::Derived::~Derived </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga70e348a65b102b13483257a0438c5356"></a><!-- doxytag: member="bsl::Is_Empty_Class_Imp&lt; TYPE, true &gt;::Derived::d_data" ref="ga70e348a65b102b13483257a0438c5356" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structbsl_1_1Is__Empty__Class__Imp.html">bsl::Is_Empty_Class_Imp</a>&lt; TYPE, true &gt;::Derived::d_data<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>Derived</code> is not empty </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:59 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
