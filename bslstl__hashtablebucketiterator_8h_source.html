<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslstl_hashtablebucketiterator.h                                   -*-C++-*-
#ifndef INCLUDED_BSLSTL_HASHTABLEBUCKETITERATOR
#define INCLUDED_BSLSTL_HASHTABLEBUCKETITERATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an STL compliant iterator over hash table buckets.
//
//@CLASSES:
// bslstl::HashBucketIterator: iterator to walk a hash-table bucket
//
//@SEE_ALSO: bslstl_unorderedmultimap, bslstl_unorderedmultiset
//
//@DESCRIPTION: This component provides a standard-conforming forward iterator,
// &#39;bslstl::HashTableBucketIterator&#39;, over a list of elements (of
// &#39;bslalg::BidirectionalLinkList&#39; type) in a single bucket (of
// &#39;bslalg::HashTableBucket&#39; type) of a hashtable.  The requirements of a
// forward iterator are outlined in the C++11 standard in section [24.2.5]
// under the tag [forward.iterators].  The &#39;bslstl::HashTableBucketIterator&#39;
// class template has two template parameters: &#39;VALUE_TYPE&#39;, and
// &#39;DIFFERENCE_TYPE&#39;.  &#39;VALUE_TYPE&#39; indicates the type of the value to which
// this iterator provides references, and may be const-qualified for constant
// iterators.  &#39;DIFFERENCE_TYPE&#39; determines the (standard mandated)
// &#39;difference_type&#39; for the iterator, and will typically be supplied by the
// allocator used by the hash-table being iterated over.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Iterating a Hash Table Bucket Using &#39;HashTableIterator&#39;
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In the following example we create a simple hashtable and then use a
// &#39;HashTableBucketIterator&#39; to iterate through the elements in one of its
// buckets.
//
// First, we define a typedef, &#39;Node&#39;, prepresenting a bidirectional node
// holding an integer value:
//..
//  typedef bslalg::BidirectionalNode&lt;int&gt; Node;
//..
// Then, we construct a test allocator, and we use it to allocate an array of
// &#39;Node&#39; objects, each holding a unique integer value:
//..
//  bslma::TestAllocator scratch(&quot;scratch&quot;, veryVeryVeryVerbose);
//
//  const int NUM_NODES = 5;
//  const int NUM_BUCKETS = 3;
//
//  Node *nodes[NUM_NODES];
//  for (int i = 0; i &lt; NUM_NODES; ++i) {
//      nodes[i] = static_cast&lt;Node *&gt;(scratch.allocate(sizeof(Node)));
//      nodes[i]-&gt;value() = i;
//  }
//..
// Next, we create an array of &#39;HashTableBuckets&#39; objects, and we use the array
// to construct an empty hash table characterized by a &#39;HashTableAnchor&#39;
// object:
//..
//  bslalg::HashTableBucket buckets[NUM_BUCKETS];
//  for (int i = 0; i &lt; NUM_BUCKETS; ++i) {
//      buckets[i].reset();
//  }
//  bslalg::HashTableAnchor hashTable(buckets, NUM_BUCKETS, 0);
//..
// Then, we insert each node in the array of nodes into the hash table using
// &#39;bslalg::HashTableImpUtil&#39;, supplying the integer value held by each node as
// its hash value:
//..
//  for (int i = 0; i &lt; NUM_NODES; ++i) {
//      bslalg::HashTableImpUtil::insertAtFrontOfBucket(&amp;hashTable,
//                                                      nodes[i],
//                                                      nodes[i]-&gt;value());
//  }
//..
// Next, we define a &#39;typedef&#39; that is an alias an instance of
// &#39;HashTableBucketIterator&#39; that can traverse buckets in a hash table holding
// integer values.
//..
//  typedef bslstl::HashTableBucketIterator&lt;int, ptrdiff_t&gt; Iter;
//..
// Now, we create two iterators: one pointing to the start the second bucket in
// the hash table, and the other representing the end sentinel.  We use the
// iterators to navigate and print the elements in the hash table bucket:
//..
//  Iter iter(&amp;hashTable.bucketArrayAddress()[1]);
//  Iter end(0, &amp;hashTable.bucketArrayAddress()[1]);
//  for (;iter != end; ++iter) {
//      printf(&quot;%d\n&quot;, *iter);
//  }
//..
// Then, we observe the following output:
//..
// 1
// 3
//..
// Finally, we deallocate the memory used by the hash table:
//..
//  for (int i = 0; i &lt; NUM_NODES; ++i) {
//      scratch.deallocate(nodes[i]);
//  }
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_hashtablebucketiterator.h&gt; header can&#39;t be included directly \
in BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ITERATOR
#include &lt;bslstl_iterator.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALNODE
#include &lt;bslalg_bidirectionalnode.h&gt;
#endif

#ifndef INCLUDED_BSLALG_HASHTABLEBUCKET
#include &lt;bslalg_hashtablebucket.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECVQ
#include &lt;bslmf_removecvq.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

namespace BloombergLP {
namespace bslstl
{

                          // =============================
                          // class HashTableBucketIterator
                          // =============================

#ifdef BSLS_PLATFORM_OS_SOLARIS
// On Solaris just to keep studio12-v4 happy, since algorithms takes only
// iterators inheriting from &#39;std::iterator&#39;.

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
class HashTableBucketIterator
: public native_std::iterator&lt;native_std::forward_iterator_tag, VALUE_TYPE&gt; {
#else
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
class HashTableBucketIterator {
#endif
    // This class template implements an in-core value semantic type that is an
    // standard-conforming forward iterator (see section 24.2.5
    // [forward.iterators] of the C++11 standard) over a list of
    // &#39;bslalg::BidirectionalLink&#39; objects referred to by a single
    // &#39;bslalg::HashTableBucket&#39; object.  A &#39;HashTableBucketIterator&#39; object
    // provides access to values of the (template parameter) &#39;VALUE_TYPE&#39;,
    // stored in a bucket of a hash table.  The (template parameter)
    // &#39;DIFFERENCE_TYPE&#39; determines the standard mandated &#39;difference_type&#39; of
    // the iterator, without requiring access to the allocator-traits for the
    // node.

    // PRIVATE TYPES
    typedef typename bslmf::RemoveCvq&lt;VALUE_TYPE&gt;::Type NcType;
    typedef HashTableBucketIterator&lt;NcType, DIFFERENCE_TYPE&gt; NcIter;

  public:
    // PUBLIC TYPES
    typedef NcType                            value_type;
    typedef DIFFERENCE_TYPE                   difference_type;
    typedef VALUE_TYPE                       *pointer;
    typedef VALUE_TYPE&amp;                       reference;
    typedef native_std::forward_iterator_tag  iterator_category;
        // Standard iterator defined types [24.4.2].

  private:
    // DATA
    bslalg::BidirectionalLink     *d_node_p;
    const bslalg::HashTableBucket *d_bucket_p;

  private:
    // PRIVATE MANIPULATORS
    void advance();
        // Advance to the next element.

  public:
    // CREATORS
    HashTableBucketIterator();
        // Create a default-constructed iterator referring to an empty list of
        // nodes.  All default-constructed iterators are non-dereferenceable
        // and refer to the same empty list.

    explicit HashTableBucketIterator(const bslalg::HashTableBucket *bucket);
        // Create an iterator referring to the specified &#39;bucket&#39;, initially
        // pointing to the first node in that &#39;bucket&#39;, or a past-the-end value
        // if the &#39;bucket&#39; is empty.  Note that this constructor is an
        // implementation detail and is not part of the C++ standard.

    explicit HashTableBucketIterator(bslalg::BidirectionalLink     *node,
                                     const bslalg::HashTableBucket *bucket);
        // Create an iterator referring to the specified &#39;bucket&#39;, initially
        // pointing to the specified &#39;node&#39; in that bucket.  The behavior is
        // undefined unless &#39;node&#39; is part of &#39;bucket&#39;, or &#39;node&#39; is 0.  Note
        // that this constructor is an implementation detail and is not part of
        // the C++ standard.

    HashTableBucketIterator(const NcIter&amp; original);                // IMPLICIT
        // Create an iterator at the same position as the specified &#39;original&#39;
        // iterator.  Note that this constructor enables converting from
        // modifiable to &#39;const&#39; iterator types.

    // HashTableBucketIterator(const HashTableBucketIterator&amp; original)
    //                                                               = default;
        // Create an iterator having the same value as the specified
        // &#39;original&#39;.  Note that this operation is either defined by the
        // constructor taking &#39;NcIter&#39; (if &#39;NcType&#39; is the same as
        // &#39;VALUE_TYPE&#39;), or generated automatically by the compiler.  Also
        // note that this constructor cannot be defined explicitly (without
        // using &#39;bsls::enableif&#39;) to avoid a duplicate declaration when
        // &#39;NcType&#39; is the same as &#39;VALUE_TYPE&#39;.

    //~HashTableBucketIterator() = default;

    // MANIPULATORS
    //HashTableBucketIterator&amp; operator=(const HashTableBucketIterator&amp;)
    //                                                               = default;

    HashTableBucketIterator&amp; operator++();
        // Move this iterator to the next element in the hash table bucket and
        // return a reference providing modifiable access to this iterator.
        // The behavior is undefined unless the iterator refers to a valid (not
        // yet erased) element in a bucket.  Note that this iterator is
        // invalidated when the underlying hash table is rehashed.

    // ACCESSORS
    reference operator*() const;
        // Return a reference providing modifiable access to the element (of
        // the template parameter &#39;VALUE_TYPE&#39;) at which this iterator is
        // positioned.  The behavior is undefined unless the iterator refers to
        // a valid (not yet erased) element in a hash table bucket.  Note that
        // this iterator is invalidated when the underlying hash table is
        // rehashed.

    pointer operator-&gt;() const;
        // Return the address of the element (of the template parameter
        // &#39;VALUE_TYPE&#39;) at which this iterator is positioned.  The behavior is
        // undefined unless the iterator refers to a valid (not yet erased)
        // element a hash table bucket.  Note that this iterator is invalidated
        // when the underlying hash table is rehashed.

    bslalg::BidirectionalLink *node() const;
        // Return the address of the node holding the element at which this
        // iterator is positioned, or 0 if this iterator is positioned after
        // the end of a bucket.  Note that this method is an implementation
        // detail and is not part of the C++ standard.

    const bslalg::HashTableBucket *bucket() const;
        // Return the address of the hash table bucket referred to by this
        // iterator.  Note that this method is an implementation detail
        // intended for debugging purposes only, and is not part of the C++
        // standard.
};

// FREE FUNCTIONS AND OPERATORS
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator==(
              const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
              const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator==(
        const HashTableBucketIterator&lt;      VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator==(
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
        const HashTableBucketIterator&lt;      VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator==(
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and the specified &#39;rhs&#39; iterators
    // have the same value and &#39;false&#39; otherwise.  Two iterators have the same
    // value if they refer to the same element in the same hash table, or if
    // both iterators are positioned after the end of a hash table bucket.

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator!=(
              const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
              const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator!=(
        const HashTableBucketIterator&lt;      VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator!=(
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
        const HashTableBucketIterator&lt;      VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
bool operator!=(
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; lhs,
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and the specified &#39;rhs&#39; iterators
    // do not have the same value and &#39;false&#39; otherwise.  Two iterators do not
    // have the same value if they refer to the different elements in the same
    // hash table, or if either (but not both) of the iterators are positioned
    // after the end of a hash table bucket.

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;
operator++(HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp; iterator,
           int);
    // Move the specified &#39;iter&#39; to the next element in the hash table bucket
    // and return the value of &#39;iter&#39; prior to this call.  The behavior is
    // undefined unless &#39;iter&#39; refers to a valid (not yet erased) element in a
    // bucket.  Note that &#39;iter&#39; is invalidated when the underlying hash table
    // is rehashed.


// INLINE FUNCTION DEFINITIONS

//CREATORS
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
HashTableBucketIterator()
: d_node_p()
, d_bucket_p()
{
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
HashTableBucketIterator(const bslalg::HashTableBucket *bucket)
: d_node_p(bucket ? bucket-&gt;first() : 0)
, d_bucket_p(bucket)
{
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
HashTableBucketIterator(bslalg::BidirectionalLink     *node,
                        const bslalg::HashTableBucket *bucket)
: d_node_p(node)
, d_bucket_p(bucket)
{
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
HashTableBucketIterator(const NcIter&amp; original)
: d_node_p(original.node())
, d_bucket_p(original.bucket())
{
}

// MANIPULATORS
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
void
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
advance()
{
    BSLS_ASSERT_SAFE(this-&gt;d_node_p);
    BSLS_ASSERT_SAFE(this-&gt;d_bucket_p);

    if (this-&gt;d_bucket_p-&gt;last() == this-&gt;d_node_p) {
        this-&gt;d_node_p = 0;
    }
    else {
        this-&gt;d_node_p = this-&gt;d_node_p-&gt;nextLink();
    }
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;&amp;
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
operator++()
{
    BSLS_ASSERT_SAFE(this-&gt;d_node_p);
    BSLS_ASSERT_SAFE(this-&gt;d_bucket_p);

    this-&gt;advance();
    return *this;
}

// ACCESSORS
template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
typename
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::reference
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
operator*() const
{
    BSLS_ASSERT_SAFE(this-&gt;d_node_p);

    return static_cast&lt;bslalg::BidirectionalNode&lt;VALUE_TYPE&gt; *&gt;(
                                                            d_node_p)-&gt;value();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
typename
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::pointer
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::
operator-&gt;() const
{
    BSLS_ASSERT_SAFE(this-&gt;d_node_p);

    return bsls::Util::addressOf(
            static_cast&lt;bslalg::BidirectionalNode&lt;VALUE_TYPE&gt; *&gt;(
                                                           d_node_p)-&gt;value());
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bslalg::BidirectionalLink *
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::node() const
{
    return this-&gt;d_node_p;
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
const bslalg::HashTableBucket *
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;::bucket() const
{
    return this-&gt;d_bucket_p;
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool operator==(
              const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; lhs,
              const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.bucket() == rhs.bucket() );

    return lhs.node() == rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool operator==(
        const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp;       lhs,
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.bucket() == rhs.bucket() );

    return lhs.node() == rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool operator==(
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; lhs,
        const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp;       rhs)
{
    BSLS_ASSERT_SAFE(lhs.bucket() == rhs.bucket() );

    return lhs.node() == rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool operator==(
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; lhs,
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.bucket() == rhs.bucket() );

    return lhs.node() == rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool operator!=(
              const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; lhs,
              const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.bucket() == rhs.bucket() );

    return lhs.node() != rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool operator!=(
        const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp;       lhs,
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.bucket() == rhs.bucket() );

    return lhs.node() != rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool operator!=(
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; lhs,
        const HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp;       rhs)
{
    BSLS_ASSERT_SAFE(lhs.bucket() == rhs.bucket() );

    return lhs.node() != rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
bool operator!=(
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; lhs,
        const HashTableBucketIterator&lt;const VALUE_TYPE, DIFFERENCE_TYPE &gt;&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.bucket() == rhs.bucket() );

    return lhs.node() != rhs.node();
}

template &lt;class VALUE_TYPE, class DIFFERENCE_TYPE&gt;
inline
HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt;
operator++(HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt; &amp;iter, int)
{
    BSLS_ASSERT_SAFE(iter.node());
    BSLS_ASSERT_SAFE(iter.bucket());

    HashTableBucketIterator&lt;VALUE_TYPE, DIFFERENCE_TYPE&gt; temp(iter);
    ++iter;
    return temp;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
