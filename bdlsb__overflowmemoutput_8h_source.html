<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlsb_overflowmemoutput.h                                          -*-C++-*-
#ifndef INCLUDED_BDLSB_OVERFLOWMEMOUTPUT
#define INCLUDED_BDLSB_OVERFLOWMEMOUTPUT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an overflowable output &#39;streambuf&#39; using a client buffer.
//
//@CLASSES:
// bdlsb::OverflowMemOutput: overflowable output stream buffer
//
//@SEE_ALSO: bdlsb_fixedmemoutput, bdlsb_overflowmemoutstreambuf
//
//@DESCRIPTION: This component provides a mechanism,
// &#39;bdlsb::OverflowMemOutput&#39;, that implements the output portion of the
// &#39;bsl::basic_streambuf&#39; protocol using a user-supplied memory buffer and a
// managed, allocator-supplied overflow buffer that is created when the
// client-supplied buffer runs out.  Method names necessarily correspond to the
// protocol-specified method names.  As with &#39;bdlsb_overflowmemoutstreambuf&#39;,
// clients supply the character buffer at construction.  Unlike
// &#39;bdlsb_fixedmemoutput&#39;, they can no longer reinitialize the stream buffer
// with a different character buffer by calling the &#39;pubsetbuf&#39; method;
// instead, if that buffer runs out, the &#39;bdlsb::OverflowMemOutput&#39; will
// allocate another buffer (see &quot;Overflow Buffer&quot; below).  The only difference
// between this component and &#39;bdlsb_overflowmemoutstreambuf&#39; is that the class
// &#39;bdlsb::OverflowMemOutput&#39; does *not* derive from &#39;bsl::streambuf&#39; and does
// not support locales.  This is advantageous for performance reasons, as the
// overhead of the initialization and virtual function calls of a
// &#39;bsl::streambuf&#39; can be undesirable.  The &#39;bdlsb::OverflowMemOutput&#39; is
// designed to be used by generic template code that must be instantiated on a
// type that matches the interface of &#39;bsl::streambuf&#39;, but does not require an
// actual &#39;bsl::streambuf&#39;, in particular &#39;bslx_genericoutstream&#39;.
//
///Overflow Buffer
///---------------
// This output stream buffer uses the initial buffer (supplied at construction)
// as its output buffer.  If an overflow of the initial buffer were to occur,
// an additional buffer (the overflow buffer) will be allocated.  If this
// overflow buffer ever becomes full, it will be automatically grown.  The
// overflow buffer grows geometrically (to twice the current overflow buffer
// size) whenever the amount of data written exceeds the amount of space
// available.  On growth, the old overflow buffer is copied over to the newly
// allocated overflow buffer, and then deallocated, thus after any write one
// cannot assume that the overflow buffer is still the same memory.  Data in
// the overflow buffer beyond the reach of the current write position is not
// guaranteed to be preserved after a growth operation.
//
///Streaming Architecture
///----------------------
// Stream buffers are designed to decouple device handling from content
// formatting, providing the requisite device handling and possible buffering
// services, and leaving the formatting to the client stream.  The standard C++
// IOStreams library further partitions streaming into input streaming and
// output streaming, separating responsibilities for each at both the stream
// layer and the stream buffer layer.  The BDE streaming library for &#39;blsx&#39;,
// including all of &#39;bdlsb&#39;, follows this model.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Use of &#39;bdlsb::OverflowMemOutput&#39;
/// - - - - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates instantiating a template,
// &#39;bslx::GenericOutStream&#39;, on a &#39;bdlsb::OverflowMemOutput&#39; object and using
// the &#39;bslx::GenericOutStream&#39; object to stream out some data.
//
// First, we create a stream buffer, &#39;streamBuf&#39;, and supply it stack allocated
// memory as its initial buffer:
//..
//  enum { k_STREAMBUF_CAPACITY = 8 };
//
//  char                     buffer[k_STREAMBUF_CAPACITY];
//  bdlsb::OverflowMemOutput streamBuf(buffer, k_STREAMBUF_CAPACITY);
//..
// Then, we create an instance of &#39;bslx::GenericOutStream&#39; using &#39;streamBuf&#39;,
// with an arbitrary value for its &#39;versionSelector&#39;, and serialize some data:
//..
//  bslx::GenericOutStream&lt;bdlsb::OverflowMemOutput&gt; outStream(&amp;streamBuf,
//                                                             20150707);
//  int MAGIC = 0x1812;
//  outStream.putInt32(MAGIC);
//  outStream.putInt32(MAGIC+1);
//..
// Next, we verify that the data was correctly serialized and completely filled
// initial buffer supplied at the stream buffer construction:
//..
//  assert(outStream.isValid());
//  assert(8 == streamBuf.dataLength());
//  assert(0 == bsl::memcmp(streamBuf.initialBuffer(),
//                          &quot;\x00\x00\x18\x12\x00\x00\x18\x13&quot;,
//                          8));
//  assert(0 == bsl::memcmp(buffer, &quot;\x00\x00\x18\x12\x00\x00\x18\x13&quot;, 8));
//  assert(0 == streamBuf.overflowBuffer());
//  assert(0 == streamBuf.overflowBufferSize());
//..
// Then, we serialize some more data to trigger allocation of the internal
// overflow buffer:
//..
//  outStream.putString(bsl::string(&quot;test&quot;));
//..
// Finally, we verify that the additional data was serialized correctly and
// landed into dynamically allocated overflow buffer:
//..
//  assert(outStream.isValid());
//  assert(13 == streamBuf.dataLength());
//  assert(0  != streamBuf.overflowBuffer());
//  assert(5  == streamBuf.dataLengthInOverflowBuffer());
//  assert(0  == bsl::memcmp(streamBuf.overflowBuffer(), &quot;\x04test&quot;, 5));
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_IOS
#include &lt;bsl_ios.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace bdlsb {

                       // =======================
                       // class OverflowMemOutput
                       // =======================

class OverflowMemOutput {
    // This class, like &#39;bdlsb::OverflowMemOutStreamBuf&#39;, implements the output
    // functionality of the &#39;bsl::basic_streambuf&#39; interface, using a
    // client-supplied buffer and allocator-supplied overflow buffer if
    // additional memory is needed.  It has an interface similar to
    // &#39;bdlsb::OverflowMemOutStreamBuf&#39; but does *not* inherit from
    // &#39;bsl::streambuf&#39;.  Thus, it is suitable for use as template parameter to
    // &#39;bslx::GenericByteOutStream&#39; (but not to &#39;bslx::ByteOutStream&#39; or
    // &#39;bslx::ByteOutStreamFormatter&#39;).  Note that this class is not designed
    // to be derived from.

    // DATA

    // The order of the data members is determined by our usage pattern for
    // cache efficiency.  Do not reorder them.

    bsl::size_t       d_dataLength;            // total data length

    char             *d_put_p;                 // current put pointer

    char             *d_initialBuffer_p;       // user-supplied buffer (held,
                                               // not owned)

    bsl::size_t       d_initialBufferSize;     // size of &#39;d_initialBuffer_p&#39;
                                               // buffer

    bool              d_inOverflowBufferFlag;  // true if &#39;d_put_p&#39; points into
                                               // the overflow buffer

    char             *d_overflowBuffer_p;      // overflow buffer (owned)

    bsl::size_t       d_overflowBufferSize;    // size of &#39;d_overflowBuffer_p&#39;
                                               // buffer

    bslma::Allocator *d_allocator_p;           // memory allocator (held, not
                                               // owned)

    // NOT IMPLEMENTED
    OverflowMemOutput(const OverflowMemOutput&amp;);
    OverflowMemOutput&amp; operator=(const OverflowMemOutput&amp;);

  private:
    // PRIVATE MANIPULATORS
    void grow(bsl::size_t numBytes, bool copyOrigin = true);
        // Replace the overflow buffer with another buffer, larger then the
        // current buffer by at least the specified &#39;numBytes&#39;, by growing
        // geometrically by a factor of two.  Optionally specify a &#39;copyOrigin&#39;
        // indicating whether the content of the overflow buffer should be
        // copied into new location.  Note that &#39;d_put_p&#39; is not updated, and
        // may be pointing to deallocated memory when the method returns.

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(OverflowMemOutput,
                                   bslma::UsesBslmaAllocator);

    // TYPES
    typedef char                    char_type;
    typedef bsl::char_traits&lt;char&gt;  traits_type;
    typedef traits_type::int_type   int_type;
    typedef traits_type::pos_type   pos_type;
    typedef traits_type::off_type   off_type;

    // CREATORS
    OverflowMemOutput(char             *buffer,
                      bsl::size_t       length,
                      bslma::Allocator *basicAllocator = 0);
        // Create an &#39;OverflowMemOutput&#39; using the specified &#39;buffer&#39; of the
        // specified &#39;length&#39; as the initial output buffer.  Optionally specify
        // a &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  The behavior is
        // undefined unless &#39;buffer != 0 &amp;&amp; length &gt; 0&#39;.  Note that this stream
        // buffer does not assume ownership of &#39;buffer&#39;.

    ~OverflowMemOutput();
        // Destroy this stream buffer.

    // MANIPULATORS
                             // *** 27.5.2.2.2 buffer and positioning ***

    pos_type pubseekoff(off_type                offset,
                        bsl::ios_base::seekdir  way,
                        bsl::ios_base::openmode which = bsl::ios_base::out);
        // Set the position indicator to the relative specified &#39;offset&#39; from
        // the base position indicated by the specified &#39;way&#39; and return the
        // resulting absolute position on success or pos_type(-1) on failure.
        // Optionally specify &#39;which&#39; area of the stream buffer.  The seek
        // operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::out&#39; or if the resulting absolute position is less
        // than zero.

    pos_type pubseekpos(pos_type                position,
                        bsl::ios_base::openmode which = bsl::ios_base::out);
        // Set the position indicator to the specified &#39;position&#39; and return
        // the resulting absolute position on success or pos_type(-1) on
        // failure.  Optionally specify &#39;which&#39; area of the stream buffer.  The
        // &#39;seekpos&#39; operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::out&#39; or if &#39;position&#39; is less then zero.

    OverflowMemOutput *pubsetbuf(char *buffer, bsl::streamsize length);
        // Reinitialize this stream buffer to use the specified character
        // &#39;buffer&#39; having the specified &#39;length&#39;.  Return a pointer providing
        // modifiable access to this stream buffer.  This stream buffer does
        // not support reinitialization of the internal character buffer.

    int pubsync();
        // Synchronize this stream buffer with associated character sequence.
        // Operation has no effect.  Return &#39;0&#39; unconditionally.

                             // *** 27.5.2.2.5 put area ***

    int_type sputc(char c);
        // Write the specified character &#39;c&#39; at the current write position and
        // advance write position of this buffer.  Return &#39;c&#39;, or
        // &#39;traits_type::eof()&#39; if the end of the write buffer is reached.

    bsl::streamsize sputn(const char *source, bsl::streamsize length);
        // Write the specified &#39;length&#39; characters from the specified &#39;source&#39;
        // to this buffer.  Return the number of characters written, which is
        // either &#39;length&#39; or the distance from the current write position to
        // the end of the write buffer, whichever is smaller, and move the
        // write cursor position by this amount.  The behaviour is undefined
        // unless &#39;source != 0 || length &gt; 0&#39;.

    // ACCESSORS
    bsl::size_t dataLength() const;
        // Return the number of bytes that have been written to this object.

    bsl::size_t dataLengthInInitialBuffer() const;
        // Return the length of data in the initial buffer, i.e.,
        // &#39;dataLength()&#39; if there is no overflow buffer, or
        // &#39;initialBufferSize()&#39; if there is one.

    bsl::size_t dataLengthInOverflowBuffer() const;
        // Return the length of the data in the overflow buffer, i.e., 0 if
        // there is no overflow buffer, or &#39;dataLength() - initialBufferSize()&#39;
        // if there is one.

    const char *initialBuffer() const;
        // Return a pointer providing non-modifiable access to the character
        // buffer held by this stream buffer (specified at construction).

    bsl::size_t initialBufferSize() const;
        // Return the size of the initial buffer held by this stream buffer.

    const char *overflowBuffer() const;
        // Return a pointer providing non-modifiable access to the overflow
        // buffer if there is one, or 0 otherwise.

    bsl::size_t overflowBufferSize() const;
        // Return the size of the overflow buffer, or 0 if there is no overflow
        // buffer.
};

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                       // -----------------------
                       // class OverflowMemOutput
                       // -----------------------

// CREATORS
inline
OverflowMemOutput::~OverflowMemOutput()
{
    d_allocator_p-&gt;deallocate(d_overflowBuffer_p);
}

// MANIPULATORS
inline
OverflowMemOutput::pos_type
OverflowMemOutput::pubseekpos(pos_type position, bsl::ios_base::openmode which)
{
    return pubseekoff(off_type(position), bsl::ios_base::beg, which);
}

inline
OverflowMemOutput *OverflowMemOutput::pubsetbuf(char *, bsl::streamsize)
{
    return this;
}

inline
int OverflowMemOutput::pubsync()
{
    return 0;
}

// ACCESSORS
inline
bsl::size_t OverflowMemOutput::dataLength() const
{
    return d_dataLength;
}

inline
bsl::size_t OverflowMemOutput::dataLengthInInitialBuffer() const
{
    return d_inOverflowBufferFlag ? d_initialBufferSize : d_dataLength;
}

inline
bsl::size_t OverflowMemOutput::dataLengthInOverflowBuffer() const
{
    return d_inOverflowBufferFlag ? d_dataLength - d_initialBufferSize : 0;
}

inline
const char *OverflowMemOutput::initialBuffer() const
{
    return d_initialBuffer_p;
}

inline
bsl::size_t OverflowMemOutput::initialBufferSize() const
{
    return d_initialBufferSize;
}

inline
const char *OverflowMemOutput::overflowBuffer() const
{
    return d_overflowBuffer_p;
}

inline
bsl::size_t OverflowMemOutput::overflowBufferSize() const
{
    return d_overflowBufferSize;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
