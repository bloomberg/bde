<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bsls_util.h                                                        -*-C++-*-
#ifndef INCLUDED_BSLS_UTIL
#define INCLUDED_BSLS_UTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide essential, low-level support for portable generic code.
//
//@CLASSES:
//  bsls::Util: utility class supplying essential, low-level functionality
//
//@MACROS:
//  BSLS_UTIL_ADDRESSOF(OBJ): address of &#39;OBJ&#39;, even if &#39;operator&amp;&#39; overloaded
//
//@DESCRIPTION: This component defines a utility &#39;struct&#39;, &#39;bsls::Util&#39;, that
// serves as a namespace for a suite of pure functions that supply essential
// low-level support for implementing portable generic facilities such as might
// be found in the C++ standard library.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Obtain the Address of a &#39;class&#39; That Defines &#39;operator&amp;&#39;.
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// There are times, especially within low-level library functions, where it is
// necessary to obtain the address of an object even if that object&#39;s class
// overloads &#39;operator&amp;&#39; to return something other than the object&#39;s address.
//
// First, we create a special reference-like type that can refer to a single
// bit within a byte (inline implementations are provided in class scope for
// ease of exposition):
//..
//  class BitReference {
//
//      // DATA
//      char *d_byte_p;
//      int   d_bitpos;
//
//    public:
//      // CREATORS
//      BitReference(char *byteptr = 0, int bitpos = 0)             // IMPLICIT
//      : d_byte_p(byteptr)
//      , d_bitpos(bitpos)
//      {
//      }
//
//      // ACCESSORS
//      operator bool() const { return (*d_byte_p &gt;&gt; d_bitpos) &amp; 1; }
//
//      char *byteptr() const { return d_byte_p; }
//      int bitpos() const { return d_bitpos; }
//  };
//..
// Then, we create a pointer-like type that can point to a single bit:
//..
//  class BitPointer {
//
//      // DATA
//      char *d_byte_p;
//      int   d_bitpos;
//
//    public:
//      // CREATORS
//      BitPointer(char *byteptr = 0, int bitpos = 0)               // IMPLICIT
//      : d_byte_p(byteptr)
//      , d_bitpos(bitpos)
//      {
//      }
//
//      // ACCESSORS
//      BitReference operator*() const
//      {
//          return BitReference(d_byte_p, d_bitpos);
//      }
//
//      // etc.
//  };
//..
// Next, we overload &#39;operator&amp;&#39; for &#39;BitReference&#39; to return a &#39;BitPointer&#39;
// instead of a raw pointer, completing the setup:
//..
//  inline BitPointer operator&amp;(const BitReference&amp; ref)
//  {
//      return BitPointer(ref.byteptr(), ref.bitpos());
//  }
//..
// Then, we note that there are times when it might be desirable to get the
// true address of a &#39;BitReference&#39;.  Since the above overload prevents the
// obvious syntax from working, we use &#39;bsls::Util::addressOf&#39; to accomplish
// this task.
//
// Next, we create a &#39;BitReference&#39; object:
//..
//  char c[4];
//  BitReference br(c, 3);
//..
// Now, we invoke &#39;bsls::Util::addressOf&#39; to obtain and save the address of
// &#39;br&#39;:
//..
//  BitReference *p = bsls::Util::addressOf(br);  // OK
//  // BitReference *p = &amp;br;                     // Won&#39;t compile
//..
// Notice that the commented line illustrates canonical use of &#39;operator&amp;&#39; that
// would not compile in this example.
//
// Finally, we verify that address obtained is the correct one, running some
// sanity checks:
//..
//  assert(0 != p);
//  assert(c == p-&gt;byteptr());
//  assert(3 == p-&gt;bitpos());
//..

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

namespace BloombergLP {

namespace bsls {

template &lt;class TYPE&gt;
struct Util_Identity {
    // This class template provides an easy way to alias a function pointer
    // type when used as the return type of a function.  The syntax for a
    // function returning a function pointer is otherwise quite obscure, and
    // difficult to read.  As we want to return function pointers taking
    // parameters and returning a result specified by template parameters
    // below, it is not possible to define a simple typedef to the function
    // type outside the function template itself.

    typedef TYPE type;  // alias of the template parameter &#39;TYPE&#39;.
};

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
template &lt;class TYPE&gt;
struct Util_RemoveReference {
    typedef TYPE type;
};

template &lt;class TYPE&gt;
struct Util_RemoveReference&lt;TYPE&amp;&gt; {
    typedef TYPE type;
};

template &lt;class TYPE&gt;
struct Util_RemoveReference&lt;TYPE&amp;&amp;&gt; {
    typedef TYPE type;
};

#endif // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

                                 // ===========
                                 // struct Util
                                 // ===========

struct Util {
    // This &#39;struct&#39; provides a namespace for essential low-level functions for
    // implementing portable generic facilities such as the C++ standard
    // library.

    // CLASS METHODS
    template &lt;class TYPE&gt;
    static TYPE *addressOf(TYPE&amp; obj);
        // Return the address of the specified &#39;obj&#39;, even if &#39;operator&amp;&#39; is
        // overloaded for objects of type &#39;BSLS_TYPE&#39;.  Behavior is undefined
        // unless &#39;BSLS_TYPE&#39; is an object type.  Note that this function
        // conforms to the C++11 definition for &#39;addressof&#39; as specified in the
        // section [specialized.addressof] (20.6.12.1) of the C++11 standard,
        // except that function types, which are not object types, are
        // supported by &#39;std::addressof&#39; in C++11.

    template &lt;class RESULT&gt;
    static
    typename Util_Identity&lt;RESULT()&gt;::type *addressOf(RESULT (&amp;fn)());
    template &lt;class RESULT, class ARG&gt;
    static
    typename Util_Identity&lt;RESULT(ARG)&gt;::type *addressOf(RESULT (&amp;fn)(ARG));
    template &lt;class RESULT, class ARG1, class ARG2&gt;
    static
    typename Util_Identity&lt;RESULT(ARG1, ARG2)&gt;::type *addressOf(
                                                     RESULT (&amp;fn)(ARG1, ARG2));
        // Return the address of the specified function &#39;fn&#39;.  Note that this
        // implementation supports functions of only a limited number of
        // parameters, determined by the current needs of the BDE software.  A
        // more general form that will support an arbitrary number of function
        // parameters will be available with C++11.

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template &lt;class TYPE&gt;
    static TYPE&amp;&amp; forward(typename Util_RemoveReference&lt;TYPE&gt;::type&amp;  t);
    template &lt;class TYPE&gt;
    static TYPE&amp;&amp; forward(typename Util_RemoveReference&lt;TYPE&gt;::type&amp;&amp; t);
#endif // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
};

}  // close package namespace

                                   // ======
                                   // MACROS
                                   // ======

// The following macros are private to the BDE implementation and not intended
// for widespread use.  They support the BDE STL decision for the standard
// containers to support types that overload &#39;operator&amp;&#39; only on the Microsoft
// platform.  This support is provided on Microsoft to enable containers
// holding the &#39;CComPtr&#39; type from the Microsoft Foundation Class library
// (which overloads &#39;operator&amp;&#39;), but is not provided on UNIX platforms to
// avoid additional template bloat in the &#39;big&#39; only to support a class design
// that is almost certainly an error.
#ifdef BSLS_PLATFORM_CMP_MSVC
#   define BSLS_UTIL_ADDRESSOF(OBJ) ::BloombergLP::bsls::Util::addressOf(OBJ)

#   if !defined(BDE_USE_ADDRESSOF)
#       define BDE_USE_ADDRESSOF
#   endif
#else
#   define BSLS_UTIL_ADDRESSOF(OBJ) (&amp;(OBJ))
#endif

namespace bsls {

// This macro takes the address of an object by calling &#39;Util::addressOf&#39; on
// Windows, and simply taking the address with the &#39;&amp;&#39; operator on all other
// platforms.

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

// CLASS METHODS
template &lt;class TYPE&gt;
inline
TYPE *Util::addressOf(TYPE&amp; obj)
{
    return static_cast&lt;TYPE *&gt;(
        static_cast&lt;void *&gt;(
            const_cast&lt;char *&gt;(&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(obj))));
}

template &lt;class RESULT&gt;
inline
typename Util_Identity&lt;RESULT()&gt;::type *
Util::addressOf(RESULT (&amp;fn)())
{
    return fn;
}

template &lt;class RESULT, class ARG&gt;
inline
typename Util_Identity&lt;RESULT(ARG)&gt;::type *
Util::addressOf(RESULT (&amp;fn)(ARG))
{
    return fn;
}

template &lt;class RESULT, class ARG1, class ARG2&gt;
inline
typename Util_Identity&lt;RESULT(ARG1, ARG2)&gt;::type *
Util::addressOf(RESULT (&amp;fn)(ARG1, ARG2))
{
    return fn;
}

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
template &lt;class TYPE&gt;
TYPE&amp;&amp; Util::forward(typename Util_RemoveReference&lt;TYPE&gt;::type&amp; t)
{
    return static_cast&lt;TYPE&amp;&amp;&gt;(t);
}

template &lt;class TYPE&gt;
TYPE&amp;&amp; Util::forward(typename Util_RemoveReference&lt;TYPE&gt;::type&amp;&amp; t)
{
    return static_cast&lt;TYPE&amp;&amp;&gt;(t);
}
#endif // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
