<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmt_once Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>Component bslmt_once<br/>
<small>
[<a class="el" href="group__bslmt.html">Package bslmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-safe way to execute code once per process.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmt__once.html#ga17699f8f8ac0e009c936f7533f1d4829">BSLMT_ONCE_UNIQNUM</a>&nbsp;&nbsp;&nbsp;__LINE__</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmt__once.html#ga8c39dc6fc4437ba876ee22a0ff278c17">BSLMT_ONCE_DO</a>&nbsp;&nbsp;&nbsp;BSLMT_ONCE_DO_IMP(BSLMT_ONCE_CAT(bslmt_doOnceObj, BSLMT_ONCE_UNIQNUM))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmt__once.html#ga0c158ad1e2fd5deba3501542363f18d9">BSLMT_ONCE_CANCEL</a>()&nbsp;&nbsp;&nbsp;bslmt_doOnceGuard.cancel()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmt__once.html#ga8f94af79f798e90c9108ff4a1943fe67">BSLMT_ONCE_INITIALIZER</a>&nbsp;&nbsp;&nbsp;{ BSLMT_QLOCK_INITIALIZER, { 0 } }</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Warning</a> </li>
<li>
<a href="#3.2">Thread Safety</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">First Implementation</a> </li>
<li>
<a href="#3.3.2">Second Implementation</a> </li>
<li>
<a href="#3.3.3">Third Implementation</a> </li>
<li>
<a href="#3.3.4">Fourth Implementation</a> </li>
<li>
<a href="#3.3.5">Using the Semaphore Implementations</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-safe way to execute code once per process. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a> </td><td>Gate-keeper for code executed only once per process  </td></tr>
<tr>
<td><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a> </td><td>Guard class for safely using <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmt__qlock.html" title="Provide small, statically-initializable mutex lock.">Component bslmt_qlock</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a pair of classes, <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> and <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code>, which give the caller a way to run a body of code exactly once within the current process, particularly in the presence of multiple threads. This component also defines the macro <code>BSLMT_ONCE_DO</code>, which provides syntactic sugar to make one-time execution nearly fool-proof. A common use of one-time execution is the initialization of singletons on first use. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> class is designed to be statically allocated and initialized using the <code>BSLMT_ONCE_INITIALIZER</code> macro. Client code may use the <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object in one of two ways: 1) it may use the <code>callOnce</code> method to call a function or functor or 2) it may call the <code>enter</code> and <code>leave</code> methods just before and after the code that is intended to be executed only once. That code must be executed conditionally on <code>enter</code> returning <code>true</code>, indicating that the caller is the first thread to pass through this region of code. The <code>leave</code> method must be executed at the end of the code region, indicating that the one-time execution has completed and unblocking any threads waiting on <code>enter</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A safer way to use the <code>enter</code> and <code>leave</code> methods of <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> is to manage the <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object using a <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code> object constructed from the <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object. Calling <code>enter</code> on the <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code> object will call <code>enter</code> on its associated <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object. If the call to <code>enter</code> returns <code>true</code>, then the destructor for the guard will automatically call <code>leave</code> on its associated <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object. The <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code> class is intended to be allocated on the stack (i.e., as a local variable) so that it is automatically destroyed at the end of its enclosing block. Thus, the to call <code>leave</code> of the <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object is enforced by the compiler. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An even easier way to use the facilities of this component is to use the <code>BSLMT_ONCE_DO</code> macro. This macro behaves like an <code>if</code> statement -- executing the following [compound] statement the first time the control passes through it in the course of a program's execution, and blocking other calling threads until the [compound] statement is executed the first time. Thus, bracketing arbitrary code in a <code>BSLMT_ONCE_DO</code> construct is the easiest way to ensure that code will be executed only once for a program. The <code>BSLMT_ONCE_DO</code> behaves correctly even if there are <code>return</code> statements within the one-time code block. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The implementation of this component uses appropriate memory barriers so that changes made in the one-time execution code are immediately visible to all threads at the end of the one-time code block. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="warning"></a> <a class="anchor" id="description.warning"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Warning: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>BSLMT_ONCE_DO</code> macro consists of a declaration and a <code>for</code> loop. Consequently, the following is syntactically incorrect: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (xyz) <a class="code" href="group__bslmt__once.html#ga8c39dc6fc4437ba876ee22a0ff278c17">BSLMT_ONCE_DO</a> { stuff() }
</pre></div><br/>
<br/>
 Also, a <code>break</code> or <code>continue</code> statement within a <code>BSLMT_ONCE_DO</code> construct terminates the <code>BSLMT_ONCE_DO</code>, not a surrounding loop or <code>switch</code> statement. For example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">switch</span> (xyz) {
    <span class="keywordflow">case</span> 0: <a class="code" href="group__bslmt__once.html#ga8c39dc6fc4437ba876ee22a0ff278c17">BSLMT_ONCE_DO</a> { stuff(); <span class="keywordflow">break</span>; <span class="comment">/* does not break case */</span> }
    <span class="keywordflow">case</span> 1: <span class="comment">// Oops! case 0 falls through to here.</span>
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Objects of the <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> class are intended to be shared among threads and may be accessed and modified simultaneously in multiple threads by using the methods provided. To allow static initialization, <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> is a POD type with public member variables. It is not safe to directly access or manipulate its member variables (including object initialization) simultaneously from multiple threads. (Note that static initialization takes place before multiple threading begins, and is thus safe.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code> objects are designed to be used only by their creator threads and are typically created on the stack. It is not safe to use a <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code> by a thread other than its creator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Typically, the facilities in this component are used to implement a thread-safe singleton. Below, we implement the a singleton four ways, illustrating the two ways to directly use <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code>, the use of <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code>, and the use of <code>BSLMT_ONCE_DO</code>. In each example, the singleton functions take a C-string (<code>const char*</code>) argument and return a reference to a <code>bsl::string</code> object constructed from the input string. Only the first call to each singleton function affect the contents of the singleton string. (The argument is ignored on subsequent calls.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="first_implementation"></a> <a class="anchor" id="usage.first_implementation"></a> <a class="anchor" id="description.usage.first_implementation"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>First Implementation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Our first implementation uses the <code>BSLMT_ONCE_DO</code> construct, the recommended way to use this component. The function is a variation of the singleton pattern described by Scott Meyers, except that the <code>BSLMT_ONCE_DO</code> macro is used to handle multiple entries to the function in a thread-safe manner: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; singleton0(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
  {
      <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *theSingletonPtr = 0;
      <a class="code" href="group__bslmt__once.html#ga8c39dc6fc4437ba876ee22a0ff278c17">BSLMT_ONCE_DO</a> {
          <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> theSingleton(s,
                                          <a class="code" href="structbslma_1_1Default.html#af3987226527d8682872331e2b20d8004">bslma::Default::globalAllocator</a>());
          theSingletonPtr = &amp;theSingleton;
      }
      <span class="keywordflow">return</span> *theSingletonPtr;
  }
</pre></div><br/>
<br/>
 The <code>BSLMT_ONCE_DO</code> mechanism suffices for most situations; however, if more flexibility is required, review the remaining examples in this series for more design choices. The next example will use the lowest-level facilities of <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code>. The two following examples use progressively higher-level facilities to produce simpler singleton implementations (though none as simple as the <code>BSLMT_ONCE_DO</code> example above). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="second_implementation"></a> <a class="anchor" id="usage.second_implementation"></a> <a class="anchor" id="description.usage.second_implementation"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Second Implementation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The next singleton function implementation directly uses the <code>doOnce</code> method of <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code>. We begin by declaring a simple function that does most of the work of the singleton, i.e., constructing the string and setting a (static) pointer to the string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *theSingletonPtr = 0;

  <span class="keywordtype">void</span> singletonImp(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
  {
      <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> theSingleton(s);
      theSingletonPtr = &amp;theSingleton;
  }
</pre></div><br/>
<br/>
 The above function is <em>not</em> thread-safe. Firstly, many threads might attempt to simultaneously construct the <code>theSingleton</code> object. Secondly, once <code>theSingletonPtr</code> is set by one thread, other threads still might not see the change (and try to initialize the singleton again). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>singleton1</code> function, below, calls <code>singletonImp</code> via the <code>callOnce</code> method of <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> to ensure that <code>singletonImp</code> is called by only one thread and that the result is visible to all threads. We start by creating and initializing a static object of type <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="bdlf__bind_8h.html" title="Provide a signature-specific function object (functor).">bdlf_bind.h</a>&gt;</span>

  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; singleton1(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
  {
      <span class="keyword">static</span> <a class="code" href="classbslmt_1_1Once.html">bslmt::Once</a> once = BSLMT_ONCE_INITIALIZER;
</pre></div><br/>
<br/>
 Since the <code>callOnce</code> method takes only a no-argument functor (or function), to call <code>callOnce</code>, we must bind our argument <code>s</code> to our function, <code>singletonImp</code> using a binder method and then pass that functor to <code>callOnce</code>. The first thread (and only the first thread) entering this section of code we will set <code>theSingleton</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      once.<a class="code" href="classbslmt_1_1Once.html#a495b39de49e6b81abb992ce3597b640f">callOnce</a>(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(singletonImp, s));
      <span class="keywordflow">return</span> *theSingletonPtr;
  }
</pre></div><br/>
<br/>
 Once we return from <code>callOnce</code>, the appropriate memory barrier has been executed so that the change to <code>theSingletonPtr</code> is visible to all threads. A thread calling <code>callOnce</code> after the initialization has completed would immediately return from the call. A thread calling <code>callOnce</code> while initialization is still in progress would block until initialization completes and then return. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Implementation</em> <em>Note</em>: As an optimization, developers sometimes pre-check the value to be set, <code>theSingletonPtr</code> in this case, to avoid (heavy) memory barrier operations; however, that practice is not recommended here. First, the value of the string may be cached by a different CPU, even though the pointer has already been updated on the common memory bus. Second, The implementation of the <code>callOnce</code> method is fast enough that a pre-check would not provide any performance benefit. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The one advantage of this implementation over the previous one is that an exception thrown from within <code>singletonImp</code> will cause the <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object to be restored to its original state, so that the next entry into the singleton will retry the operation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="third_implementation"></a> <a class="anchor" id="usage.third_implementation"></a> <a class="anchor" id="description.usage.third_implementation"></a> <a class="anchor" id="3.3.3"></a> </dd></dl>
<dl class="user"><dt><b>Third Implementation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Our next implementation, <code>singleton2</code>, eliminates the need for the <code>singletonImp</code> function and thereby does away with the use of the <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code> method; however, it does require use of <code><a class="el" href="classbslmt_1_1Once.html#afd2a5f1e281f4ec32ea8334c4a12425f">bslmt::Once::OnceLock</a></code>, created on each thread's stack and passed to the methods of <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code>. First, we declare a static <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object as before, and also declare a static pointer to <code>bsl::string</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; singleton2(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
  {
      <span class="keyword">static</span> <a class="code" href="classbslmt_1_1Once.html">bslmt::Once</a>   once            = BSLMT_ONCE_INITIALIZER;
      <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *theSingletonPtr = 0;
</pre></div><br/>
<br/>
 Next, we define a local <code><a class="el" href="classbslmt_1_1Once.html#afd2a5f1e281f4ec32ea8334c4a12425f">bslmt::Once::OnceLock</a></code> object and pass it to the <code>enter</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslmt_1_1QLockGuard.html">bslmt::Once::OnceLock</a> onceLock;
      <span class="keywordflow">if</span> (once.<a class="code" href="classbslmt_1_1Once.html#a3a4b664fd3ae0618ab4ffa2312e5cb98">enter</a>(&amp;onceLock)) {
</pre></div><br/>
<br/>
 If the <code>enter</code> method returns <code>true</code>, we proceed with the initialization of the singleton, as before. <br/>
<br/>
<div class="fragment"><pre class="fragment">          <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> theSingleton(s);
          theSingletonPtr = &amp;theSingleton;
</pre></div><br/>
<br/>
 When initialization is complete, the <code>leave</code> method is called for the same context cookie previously used in the call to <code>enter</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">          once.<a class="code" href="classbslmt_1_1Once.html#a5d7889096787cb3a0f8cc1f6c55e266a">leave</a>(&amp;onceLock);
      }
</pre></div><br/>
<br/>
 When any thread reaches this point, initialization has been complete and initialized string is returned: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">return</span> *theSingletonPtr;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="fourth_implementation"></a> <a class="anchor" id="usage.fourth_implementation"></a> <a class="anchor" id="description.usage.fourth_implementation"></a> <a class="anchor" id="3.3.4"></a> </dd></dl>
<dl class="user"><dt><b>Fourth Implementation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Our final implementation, <code>singleton3</code>, uses <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code> to simplify the previous implementation by using <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code> to hide (automate) the use of <code><a class="el" href="classbslmt_1_1Once.html#afd2a5f1e281f4ec32ea8334c4a12425f">bslmt::Once::OnceLock</a></code>. We begin as before, defining a static <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object and a static <code>bsl::string</code> pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; singleton3(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
  {
      <span class="keyword">static</span> <a class="code" href="classbslmt_1_1Once.html">bslmt::Once</a>  once            = BSLMT_ONCE_INITIALIZER;
      <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *theSingletonPtr = 0;
</pre></div><br/>
<br/>
 We then declare a local <code><a class="el" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a></code> object and associate it with the <code><a class="el" href="classbslmt_1_1Once.html">bslmt::Once</a></code> object before entering the one-time initialization region: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslmt_1_1OnceGuard.html">bslmt::OnceGuard</a> onceGuard(&amp;once);
      <span class="keywordflow">if</span> (onceGuard.enter()) {
          <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> theSingleton(s);
          theSingletonPtr = &amp;theSingleton;
      }
      <span class="keywordflow">return</span> *theSingletonPtr;
  }
</pre></div><br/>
<br/>
 Note that it is unnecessary to call <code>onceGuard.leave()</code> because that is called automatically before the function returns. This machinery makes the code more robust in the presence of, e.g., return statements in the initialization code. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If there is significant code after the end of the one-time initialization, the guard and the initialization code should be enclosed in an extra block so that the guard is destroyed as soon as validly possible and allow other threads waiting on the initialization to continue. Alternatively, one can call <code>onceGuard.leave()</code> explicitly at the end of the initialization. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="using_the_semaphore_implementations"></a> <a class="anchor" id="usage.using_the_semaphore_implementations"></a> <a class="anchor" id="description.usage.using_the_semaphore_implementations"></a> <a class="anchor" id="3.3.5"></a> </dd></dl>
<dl class="user"><dt><b>Using the Semaphore Implementations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following pair of functions, <code>thread1func</code> and <code>thread2func</code> which will be run by different threads: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> *thread1func(<span class="keywordtype">void</span> *)
  {
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; s0 = singleton0(<span class="stringliteral">&quot;0 hello&quot;</span>);
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; s1 = singleton1(<span class="stringliteral">&quot;1 hello&quot;</span>);
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; s2 = singleton2(<span class="stringliteral">&quot;2 hello&quot;</span>);
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; s3 = singleton3(<span class="stringliteral">&quot;3 hello&quot;</span>);

      assert(<span class="charliteral">&#39;0&#39;</span> == s0[0]);
      assert(<span class="charliteral">&#39;1&#39;</span> == s1[0]);
      assert(<span class="charliteral">&#39;2&#39;</span> == s2[0]);
      assert(<span class="charliteral">&#39;3&#39;</span> == s3[0]);

      <span class="comment">// ... lots more code goes here</span>
      <span class="keywordflow">return</span> 0;
  }

  <span class="keywordtype">void</span> *thread2func(<span class="keywordtype">void</span> *)
  {
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; s0 = singleton0(<span class="stringliteral">&quot;0 goodbye&quot;</span>);
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; s1 = singleton1(<span class="stringliteral">&quot;1 goodbye&quot;</span>);
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; s2 = singleton2(<span class="stringliteral">&quot;2 goodbye&quot;</span>);
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; s3 = singleton3(<span class="stringliteral">&quot;3 goodbye&quot;</span>);

      assert(<span class="charliteral">&#39;0&#39;</span> == s0[0]);
      assert(<span class="charliteral">&#39;1&#39;</span> == s1[0]);
      assert(<span class="charliteral">&#39;2&#39;</span> == s2[0]);
      assert(<span class="charliteral">&#39;3&#39;</span> == s3[0]);

      <span class="comment">// ... lots more code goes here</span>
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Both threads attempt to initialize the four singletons. In our example, each thread passes a distinct argument to the singleton, allowing us to identify the thread that initializes the singleton. (In practice, the arguments passed to a specific singleton are almost always fixed and most singletons don't take arguments at all.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Assuming that the first thread function wins all of the races to initialize the singletons, the first singleton is set to "0 hello", the second singleton to "1 hello", etc. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample1()
  {
      <span class="keywordtype">void</span> startThread1();
      <span class="keywordtype">void</span> startThread2();

      startThread1();
      startThread2();

      assert(singleton0(<span class="stringliteral">&quot;0&quot;</span>) == <span class="stringliteral">&quot;0 hello&quot;</span>);
      assert(singleton1(<span class="stringliteral">&quot;1&quot;</span>) == <span class="stringliteral">&quot;1 hello&quot;</span>);
      assert(singleton2(<span class="stringliteral">&quot;2&quot;</span>) == <span class="stringliteral">&quot;2 hello&quot;</span>);
      assert(singleton3(<span class="stringliteral">&quot;3&quot;</span>) == <span class="stringliteral">&quot;3 hello&quot;</span>);

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga17699f8f8ac0e009c936f7533f1d4829"></a><!-- doxytag: member="bslmt_once.h::BSLMT_ONCE_UNIQNUM" ref="ga17699f8f8ac0e009c936f7533f1d4829" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLMT_ONCE_UNIQNUM&nbsp;&nbsp;&nbsp;__LINE__</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8c39dc6fc4437ba876ee22a0ff278c17"></a><!-- doxytag: member="bslmt_once.h::BSLMT_ONCE_DO" ref="ga8c39dc6fc4437ba876ee22a0ff278c17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLMT_ONCE_DO&nbsp;&nbsp;&nbsp;BSLMT_ONCE_DO_IMP(BSLMT_ONCE_CAT(bslmt_doOnceObj, BSLMT_ONCE_UNIQNUM))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0c158ad1e2fd5deba3501542363f18d9"></a><!-- doxytag: member="bslmt_once.h::BSLMT_ONCE_CANCEL" ref="ga0c158ad1e2fd5deba3501542363f18d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLMT_ONCE_CANCEL</td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;bslmt_doOnceGuard.cancel()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8f94af79f798e90c9108ff4a1943fe67"></a><!-- doxytag: member="bslmt_once.h::BSLMT_ONCE_INITIALIZER" ref="ga8f94af79f798e90c9108ff4a1943fe67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLMT_ONCE_INITIALIZER&nbsp;&nbsp;&nbsp;{ BSLMT_QLOCK_INITIALIZER, { 0 } }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:53 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
