<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslx_testinstream Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>Component bslx_testinstream<br/>
<small>
[<a class="el" href="group__bslx.html">Package bslx</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Enable unexternalization of fundamental types with identification.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslx.html">bslx</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslx__testinstream.html#ga6e4e620b6fdc3c442776032fe961bc86">BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN</a>(testInStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslx__testinstream.html#ga3aaf620a84c8adb8b9a7ab81a2b37bb6">BSLX_TESTINSTREAM_EXCEPTION_TEST_END</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Input Limit</a> </li>
<li>
<a href="#4.2">Exception Test Macros</a> </li>
<li>
<a href="#4.3">Usage</a> <ul>
<li>
<a href="#4.3.1">Example 1: Basic Unexternalization Test</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Enable unexternalization of fundamental types with identification. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a> </td><td>byte-array-based input stream class  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN </td><td>macro to begin testing exceptions  </td></tr>
<tr>
<td>BSLX_TESTINSTREAM_EXCEPTION_TEST_END </td><td>macro to end testing exceptions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslx__testoutstream.html" title="Enable externalization of fundamental types with identification.">Component bslx_testoutstream</a>, <a class="el" href="group__bslx__byteinstream.html" title="Provide a stream class for unexternalization of fundamental types.">Component bslx_byteinstream</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a byte-array-based input stream class, <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code>, that provides platform-independent input methods ("unexternalization") on values, and arrays of values, of fundamental types, and on <code>bsl::string</code>. <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> also verifies, for these types, that the type of data requested from the stream matches what was written to the stream. <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> is meant for testing only. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> type reads from a user-supplied buffer directly, with no data copying or assumption of ownership. The user must therefore make sure that the lifetime and visibility of the buffer is sufficient to satisfy the needs of the input stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is intended to be used in conjunction with the <code>bslx_testoutstream</code> externalization component. Each input method of <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> reads either a value or a homogeneous array of values of a fundamental type, in a format that was written by the corresponding <code><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a></code> method. In general, the user of this component cannot rely on being able to read data that was written by any mechanism other than <code><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The supported types and required content are listed in the <code>bslx</code> package-level documentation under "Supported Types". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that input streams can be <em>invalidated</em> explicitly and queried for <em>validity</em> and <em>emptiness</em>. Reading from an initially invalid stream has no effect. Attempting to read beyond the end of a stream will automatically invalidate the stream. Whenever an inconsistent value is detected, the stream should be invalidated explicitly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="input_limit"></a> <a class="anchor" id="description.input_limit"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Input Limit: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If exceptions are enabled at compile time, the test input stream can be configured to throw an exception after a specified number of input requests is exceeded. If the input limit is less than zero (default), then the stream never throws an exception. Note that a non-negative input limit is decremented after each input attempt, and throws only when the current input limit transitions from 0 to -1; no additional exceptions will be thrown until the input limit is again reset to a non-negative value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The input limit is set using the <code>setInputLimit</code> manipulator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception_test_macros"></a> <a class="anchor" id="description.exception_test_macros"></a> <a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>Exception Test Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a pair of macros: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code><a class="el" href="group__bslx__testinstream.html#ga6e4e620b6fdc3c442776032fe961bc86">BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN(testInStream)</a></code>  </li>
<li>
<code>BSLX_TESTINSTREAM_EXCEPTION_TEST_END</code>  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>These macros can be used for testing exception-safety of classes and their methods when BDEX streaming is involved. A reference to an object of type <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> must be supplied as an argument to the <code>*_BEGIN</code> macro. Note that if exception-handling is disabled (i.e., if <code>-DBDE_BUILD_TARGET_EXC</code> was <em>not</em> supplied at compile time), then the macros simply print the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  BSLX EXCEPTION TEST -- (NOT ENABLED) --
</pre></div><br/>
<br/>
 When exception-handling is enabled (i.e., if <code>-DBDE_BUILD_TARGET_EXC</code> was supplied at compile time), the <code>*_BEGIN</code> macro will set the input limit of the supplied instream to 0, <code>try</code> the code being tested, <code>catch</code> any <code>TestInstreamException</code>s that are thrown, and keep increasing the input limit until the code being tested completes successfully. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_unexternalization_test"></a> <a class="anchor" id="usage.example_1~3A_basic_unexternalization_test"></a> <a class="anchor" id="description.usage.example_1~3A_basic_unexternalization_test"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="4.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Unexternalization Test: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to implement a (deliberately simple) <code>MyPerson</code> class as a value-semantic object that supports BDEX externalization and unexternalization. In addition to whatever data and methods that we choose to put into our design, we must supply three methods having specific names and signatures in order to comply with the BDEX protocol: a class method <code>maxSupportedBdexVersion</code>, an accessor (i.e., a <code>const</code> method) <code>bdexStreamOut</code>, and a manipulator (i.e., a non-'const' method) <code>bdexStreamIn</code>. This example shows how to implement those three methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we will not worry overly about "good design" of the <code>MyPerson</code> component, and we will declare but not implement illustrative methods and free operators, except for the three required BDEX methods, which are implemented in full. In particular, we will not make explicit use of <code>bslma</code> allocators; a more complete design would do so: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we implement <code>MyPerson</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyPerson {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_firstName;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_lastName;
      <span class="keywordtype">int</span>         d_age;

      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPerson&amp;, <span class="keyword">const</span> MyPerson&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> versionSelector);
          <span class="comment">// Return the maximum valid BDEX format version, as indicated by</span>
          <span class="comment">// the specified &#39;versionSelector&#39;, to be passed to the</span>
          <span class="comment">// &#39;bdexStreamOut&#39; method.  Note that it is highly recommended that</span>
          <span class="comment">// &#39;versionSelector&#39; be formatted as &quot;YYYYMMDD&quot;, a date</span>
          <span class="comment">// representation.  Also note that &#39;versionSelector&#39; should be a</span>
          <span class="comment">// *compile*-time-chosen value that selects a format version</span>
          <span class="comment">// supported by both externalizer and unexternalizer.  See the</span>
          <span class="comment">// &#39;bslx&#39; package-level documentation for more information on BDEX</span>
          <span class="comment">// streaming of value-semantic types and containers.</span>

      <span class="comment">// CREATORS</span>
      MyPerson();
          <span class="comment">// Create a default person.</span>

      MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age);
          <span class="comment">// Create a person having the specified &#39;firstName&#39;, &#39;lastName&#39;,</span>
          <span class="comment">// and &#39;age&#39;.</span>

      MyPerson(<span class="keyword">const</span> MyPerson&amp; original);
          <span class="comment">// Create a person having the value of the specified &#39;original&#39;</span>
          <span class="comment">// person.</span>

      ~MyPerson();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      MyPerson&amp; operator=(<span class="keyword">const</span> MyPerson&amp; rhs);
          <span class="comment">// Assign to this person the value of the specified &#39;rhs&#39; person,</span>
          <span class="comment">// and return a reference to this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated, but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>

      <span class="comment">//...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; firstName() <span class="keyword">const</span>;
          <span class="comment">// Return the first name of this person.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; lastName() <span class="keyword">const</span>;
          <span class="comment">// Return the last name of this person.</span>

      <span class="keywordtype">int</span> age() <span class="keyword">const</span>;
          <span class="comment">// Return the age of this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write the value of this object, using the specified &#39;version&#39;</span>
          <span class="comment">// format, to the specified output &#39;stream&#39;, and return a reference</span>
          <span class="comment">// to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation</span>
          <span class="comment">// has no effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is</span>
          <span class="comment">// invalidated, but otherwise unmodified.  Note that &#39;version&#39; is</span>
          <span class="comment">// not written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level</span>
          <span class="comment">// documentation for more information on BDEX streaming of</span>
          <span class="comment">// value-semantic types and containers.</span>

      <span class="comment">//...</span>

  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two person objects have the</span>
      <span class="comment">// same value if they have the same first name, last name, and age.</span>

  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects do not</span>
      <span class="comment">// have the same value, and &#39;false&#39; otherwise.  Two person objects</span>
      <span class="comment">// differ in value if they differ in first name, last name, or age.</span>

  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> MyPerson&amp; person);
      <span class="comment">// Write the specified &#39;person&#39; value to the specified output &#39;stream&#39;</span>
      <span class="comment">// in some reasonable format, and return a reference to &#39;stream&#39;.</span>

  <span class="comment">// ========================================================================</span>
  <span class="comment">//                  INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">MyPerson::maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> <span class="comment">/* versionSelector */</span>) {
      <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyPerson::MyPerson()
  : d_firstName(<span class="stringliteral">&quot;&quot;</span>)
  , d_lastName(<span class="stringliteral">&quot;&quot;</span>)
  , d_age(0)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age)
  : d_firstName(firstName)
  , d_lastName(lastName)
  , d_age(age)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::~MyPerson()
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">MyPerson::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">if</span> (stream) {
          <span class="keywordflow">switch</span> (version) {  <span class="comment">// switch on the &#39;bslx&#39; version</span>
            <span class="keywordflow">case</span> 1: {
              stream.getString(d_firstName);
              <span class="keywordflow">if</span> (!stream) {
                  d_firstName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                 <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
              stream.getString(d_lastName);
              <span class="keywordflow">if</span> (!stream) {
                  d_lastName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
              stream.getInt32(d_age);
              <span class="keywordflow">if</span> (!stream) {
                  d_age = 999;     <span class="comment">// *might* be corrupted; value for testing</span>
                  <span class="keywordflow">return</span> stream;
              }
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>: {
              stream.invalidate();
            }
          }
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">MyPerson::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putString(d_firstName);
          stream.putString(d_lastName);
          stream.putInt32(d_age);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 Then, we can exercise the new <code>MyPerson</code> value-semantic class by externalizing and reconstituting an object. First, create a <code>MyPerson</code> <code>janeSmith</code> and a <code><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a></code> <code>outStream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeSmith(<span class="stringliteral">&quot;Jane&quot;</span>, <span class="stringliteral">&quot;Smith&quot;</span>, 42);
  <a class="code" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a> outStream(20131127);
  <span class="keyword">const</span> <span class="keywordtype">int</span> VERSION = 1;
  outStream.putVersion(VERSION);
  janeSmith.bdexStreamOut(outStream, VERSION);
  assert(outStream.isValid());
</pre></div><br/>
<br/>
 Next, create a <code>MyPerson</code> <code>janeCopy</code> initialized to the default value, and assert that <code>janeCopy</code> is different from <code>janeSmith</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeCopy;
  assert(janeCopy != janeSmith);
</pre></div><br/>
<br/>
 Then, create a <code><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a></code> <code>inStream</code> initialized with the buffer from the <code><a class="el" href="classbslx_1_1TestOutStream.html">bslx::TestOutStream</a></code> object <code>outStream</code> and unexternalize this data into <code>janeCopy</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a> inStream(outStream.data(), outStream.length());
  <span class="keywordtype">int</span> version;
  inStream.getVersion(version);
  janeCopy.bdexStreamIn(inStream, version);
  assert(inStream.isValid());
</pre></div><br/>
<br/>
 Finally, <code>assert</code> the obtained values are as expected and display the results to <code>bsl::stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(version  == VERSION);
  assert(janeCopy == janeSmith);

  <span class="keywordflow">if</span> (janeCopy == janeSmith) {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Successfully serialized and de-serialized Jane Smith:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
  }
  <span class="keywordflow">else</span> {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Serialization unsuccessful.  &#39;janeCopy&#39; holds:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga6e4e620b6fdc3c442776032fe961bc86"></a><!-- doxytag: member="bslx_testinstream.h::BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN" ref="ga6e4e620b6fdc3c442776032fe961bc86" args="(testInStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLX_TESTINSTREAM_EXCEPTION_TEST_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">testInStream</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                             \
    <span class="keyword">static</span> <span class="keywordtype">int</span> firstTime = 1;                                                 \
    <span class="keywordflow">if</span> (verbose &amp;&amp; firstTime) {                                               \
        bsl::cout &lt;&lt; <span class="stringliteral">&quot;### BSLX EXCEPTION TEST -- (NOT ENABLED) --&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;   \
        firstTime = 0;                                                        \
    }                                                                         \
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga3aaf620a84c8adb8b9a7ab81a2b37bb6"></a><!-- doxytag: member="bslx_testinstream.h::BSLX_TESTINSTREAM_EXCEPTION_TEST_END" ref="ga3aaf620a84c8adb8b9a7ab81a2b37bb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSLX_TESTINSTREAM_EXCEPTION_TEST_END</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:12 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
