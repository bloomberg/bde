<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Namespace bdldfp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bdldfp Namespace Reference<br/>
<small>
[<a class="el" href="group__bdldfp__binaryintegraldecimalimputil.html">Component bdldfp_binaryintegraldecimalimputil</a>,&nbsp;<a class="el" href="group__bdldfp__decimal.html">Component bdldfp_decimal</a>,&nbsp;<a class="el" href="group__bdldfp__decimalconvertutil.html">Component bdldfp_decimalconvertutil</a>,&nbsp;<a class="el" href="group__bdldfp__decimalconvertutil__decnumber.html">Component bdldfp_decimalconvertutil_decnumber</a>,&nbsp;<a class="el" href="group__bdldfp__decimalimputil.html">Component bdldfp_decimalimputil</a>,&nbsp;<a class="el" href="group__bdldfp__decimalimputil__decnumber.html">Component bdldfp_decimalimputil_decnumber</a>,&nbsp;<a class="el" href="group__bdldfp__decimalutil.html">Component bdldfp_decimalutil</a>,&nbsp;<a class="el" href="group__bdldfp__denselypackeddecimalimputil.html">Component bdldfp_denselypackeddecimalimputil</a>,&nbsp;<a class="el" href="group__bdldfp__uint128.html">Component bdldfp_uint128</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1BinaryIntegralDecimalImpUtil.html">BinaryIntegralDecimalImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal_Type32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal_Type128</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1DecimalNumGet.html">DecimalNumGet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1DecimalNumPut.html">DecimalNumPut</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__StandardNamespaceCanary.html">Decimal_StandardNamespaceCanary</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1faux__numeric__limits_3_01Decimal__StandardNamespaceCanary_00_01DUMMY_01_4.html">faux_numeric_limits&lt; Decimal_StandardNamespaceCanary, DUMMY &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1faux__numeric__limits_3_01BloombergLP_1_1bdldfp_1_1Decimal32_00_01DUMMY_01_4.html">faux_numeric_limits&lt; BloombergLP::bdldfp::Decimal32, DUMMY &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1faux__numeric__limits_3_01BloombergLP_1_1bdldfp_1_1Decimal64_00_01DUMMY_01_4.html">faux_numeric_limits&lt; BloombergLP::bdldfp::Decimal64, DUMMY &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1faux__numeric__limits_3_01BloombergLP_1_1bdldfp_1_1Decimal128_00_01DUMMY_01_4.html">faux_numeric_limits&lt; BloombergLP::bdldfp::Decimal128, DUMMY &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalConvertUtil.html">DecimalConvertUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalConvertUtil__DecNumber.html">DecimalConvertUtil_DecNumber</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1DecimalImpUtil.html">DecimalImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalImpUtil__DecNumber.html">DecimalImpUtil_DecNumber</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DecimalUtil.html">DecimalUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdldfp_1_1DenselyPackedDecimalImpUtil.html">DenselyPackedDecimalImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal_Type32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a43ae56bdb8dbe611c06497965d404ccf">Decimal32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">Decimal64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal_Type128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a09749072ea49a21ac8b190a712f99dd5">Decimal128</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ab2ecb5051ef405ce62f19e2dd5f09432">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a80639a105b0757c8125c97e7e3084022">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae38909e0885ad40b01e80afb221e6737">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a3be038ba34aba97e5c03f884da729377">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a408762d8205e71a2c0409cb9a07cc213">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aa5065b3fda89037117befbaa2adfdcdc">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a949cd1e4244af4155b81e197834cb28a">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a969a92f292998135b90ccd4fbb8e460d">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHARTYPE , class TRAITS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::basic_istream&lt; CHARTYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a9c5b76fd3135e7a47b3b4941cf6f622a">operator&gt;&gt;</a> (bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;stream, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHARTYPE , class TRAITS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::basic_ostream&lt; CHARTYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1d862754e6d8787eb6849b24bfe6eb6e">operator&lt;&lt;</a> (bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;stream, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a84be4d7983c69ed8978cd7e2188577ae">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a9ca45433eb684154ee7f3e592f2dc5b5">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5f5eb755d568ce6c1e0c8540d53a1990">operator++</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> &amp;value, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6f43514e250d9882695b7130704c2d16">operator--</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> &amp;value, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a712791617f2725f7419f25c86ee67a5b">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a827bda9108253b7a36217ed09cb5889e">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5e7d14e23ed37d739a4184059a2f8c5c">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#abedc3f5b7525de58c81e96b4b1adb8bd">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a23cb2ab08bd60e740b36f3901280fa05">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aa01fdac7c565995f0853b5da747098f9">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6b40dd951ca2bcc31193c780d8c8a281">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a91f8a74d18261c0dfd84d39c61ce1a5d">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a16c1da1431220f77a0325c60582bfd86">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a8c30643d4eacac1aad736c460b7c6bf8">operator+</a> (int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a293f49d22e034e1d407ed10c13948eb2">operator+</a> (unsigned int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a4b901ce48725e89bec42a32ee3b755a7">operator+</a> (long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aefaa35a76ab375ff192c367f332b6a52">operator+</a> (unsigned long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad413c48fc35d1ee6b3b9e60e6aade571">operator+</a> (long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a3e188a7f5230e198fa188aae90af5ed1">operator+</a> (unsigned long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a54884fa256d0a6f24682966bf5b22b74">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a38b03e41269dfb3b9d43b9744467baec">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#abb4fd83ace1d10cf16f1c16d3546f350">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a145a2cedb4755c5a13b7553f2e2fd82d">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a4b7b6c22ed34ff9e106bd7f2d2d445af">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7152e0b014613d0576c8812fd63e320e">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ada4dfbc01b6d7b6a0df206403e454c64">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a475495a793a8b38b1772a7365892444d">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a3c5b0354b930a21fdf3dbf1fb4fd72ac">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a0e77b088a514488d1c2f73b2a7894832">operator-</a> (int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a31174cd680fc7e6be21718b83dd4a61a">operator-</a> (unsigned int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a4fa34a0787256e1913beab4850340d6b">operator-</a> (long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1349838d19e37a10a79d2d4820b18fc7">operator-</a> (unsigned long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a68e3f7815d5911885932b0891ff2b095">operator-</a> (long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a09598033d47e78454b6330d002dd7132">operator-</a> (unsigned long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a8158394e9cee4367a9de15cf73e3646a">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a249b55e1f7199b95dc595676894f4d47">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae2487d1c4a42e219706d6a1ea6ceafcb">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a179c2b50d41e10d0b7d7cc5738d689b9">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#abd90e175c43b96fda0534b3fb9b674cc">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a387d4af9c1c3323c5e35f925fa9a1e2d">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad704977cfb56bce46b42944a84ccd551">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5d1ef66b67025a06fa73f73b9936250b">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a2db6d97a1e4e46a5d2c2a2401d22ebe9">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a4f03a83dcead492322670cfdcdec07e3">operator*</a> (int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7277eafbe0e3e3d50fe9034d4df99923">operator*</a> (unsigned int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a9aece4069ae339c31e170c6f815de63f">operator*</a> (long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a034c1a3122286346440a56f76caf8ab2">operator*</a> (unsigned long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad080c9dec707ddcb43b6b6362b72ac1e">operator*</a> (long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#acc0b67b138b062e980277bad3149d5b3">operator*</a> (unsigned long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a98e1b0a0e35a0e7bb0629c72e76d7972">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ab462462af6b18d3e9caf63e5dbca691b">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7dcfbd82867b90bca4e60e742ed67eb9">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae1b012dc7bf68ecaf70a7757b9e19579">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a74b4147ece5cc88dfb33654f48f422b7">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a40ec48fee99e6fce47d03487d40e7705">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aeb7a13f77b3fe453e5721971bd248101">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ac2a719f2228649060ef7703748e716d4">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a29f336d419a3867412402ae9c75d9726">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a76d423a4b051175c441bf32956ff1d34">operator/</a> (int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a9c4407de5cde0fd91228a5b559925b74">operator/</a> (unsigned int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1377dd223f198a19ae84dcd40b5575f7">operator/</a> (long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#abbd35d0425b68b0a98d68fe5661229af">operator/</a> (unsigned long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a020e579b7b62e386362c95612b56792a">operator/</a> (long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a4f047a5612a9515db198155d2d8f5f1d">operator/</a> (unsigned long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a74959f8841f633e66ac6f391a8fc80b0">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#acbdd44b164ba2501a9c3040d344e19f1">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad313b03cc4cc6cc5572542cabd5522b7">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a40551069dea65d4ff4f4aec1707b7d0f">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#af18f47c14cbe0df3a5b63ff86316339e">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7dcc608283ad8dd48ae9c79fc68bf0e5">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7018b3a586ba40868506eea7374e485f">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a86c6f293382e6323ee61055a0339e74c">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a0b86547f6a8badca9861901147a3fce8">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1ca23bc28412b636d56e651863cc0118">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aee98be433b6e76e628c2078daa94bf98">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5c2c54b8ca1a03db1f18a7709bf0b0ca">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a0e7ad5b9034357a81937c3389b244120">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad3f6faae64c39941d13cf95b4cdc4543">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a663ac2f8d200adc940ff04f3907489a6">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#acd81fb2167db0bbd31949629c9d9687b">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5087844a1adf271f576b59612da366ae">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a90d45d198a18b7cff8046beae3524882">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHARTYPE , class TRAITS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::basic_istream&lt; CHARTYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5787e95fe65b8c7f3b6dbe50409bd385">operator&gt;&gt;</a> (bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;stream, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHARTYPE , class TRAITS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::basic_ostream&lt; CHARTYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ab384ddef0de733b9d19a16feeb7089de">operator&lt;&lt;</a> (bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;stream, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a40790848c2bf7281f2cbdb8253d49ba7">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a0829242a35a258679fc86540482f7706">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#afa28d97911075e510d626c6502034e07">operator++</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> &amp;value, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#add3d813f6d79d475dff28a19aa8895f2">operator--</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> &amp;value, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a2830823ca25dde6449a4399d4fb5c6e7">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae78edd0f19c6340d65c06095da68a0a4">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a651b20b2df48c668f71d111644de4e10">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aee4588b7e74d2bfd7f3527112b81ce62">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5151cf4751fdf90b3aefc0252e9fa4f5">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a3e8b199d2ecf0faffb7a670e42963b96">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7587412884d7514ffb9237b400cd739d">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aa6a1e888524b26fb5ef8b46d40110318">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6c70323323541c2d601b27f78917a06b">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aedd3c98dd85a45d885b5e0a052b7419a">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aac05dae1fa1e373ecfa644fa46b46c89">operator+</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1edd09502b2bf0423c9577f359056bed">operator+</a> (int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a3c4846b6c3a00e07de421c5ce87a528a">operator+</a> (unsigned int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#acd6389909b77735a315778a2a7e809fa">operator+</a> (long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae19c6cc4497a42ed75a7f98559aafb91">operator+</a> (unsigned long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad875ce27e5bb19074045dda14a8adebe">operator+</a> (long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a3136cb28ff8148dd8a026d0ffeaddce5">operator+</a> (unsigned long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a3631988897adb72f9a5f2f4270eb31c3">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6041f0842dcf24a240c48d13a738e1a7">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a418d64bb317a43c40aef052045e962e8">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1f1f2ecf658812ce07f72a3d60bb08e7">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aedda0ed55913c507631ecf1f1f960325">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a2ddd3bd2b2e1edea567d9c2626648ee6">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a29b4548881492b9958fbd3a7e29996bf">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6e559647fd9988dc40862b8c68154925">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ac03704143d6ca989992a4551ab6a99e5">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1d3ef00f800911b021cd9686ce3f17ed">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a68a6493d9eb4ea3ee6052cf338cdc3bc">operator-</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a34f234c4e7a0b47c391b2c4d696d6ef0">operator-</a> (int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a14b114070d2015acab524084b5693cc7">operator-</a> (unsigned int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1c5618920578e2b76a53b30cdfd0a268">operator-</a> (long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a254002d5fb9fa56ae398026f2d83c78c">operator-</a> (unsigned long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a4ef3de36b19b71ea0c823110982c740c">operator-</a> (long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aab92c46957ecd2adc40c4943d935333b">operator-</a> (unsigned long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7723e0e409c55d63f12ac0facb2b4bb9">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae5736fa2e9e77d58c3945c73d50a0783">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aa12e1cec92b32759b966e1d1e4b7103f">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a568e1522baee556b650d53aa58c7106a">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6c6e3e7c1441d10443bac83ac2d5300e">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad4aae18f456c1c4393fe4de691eb9676">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a74a6dab274885acd28d3bbe7ed900b15">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a67fd47bd8b2f463f3e655f380a719b5b">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ac7d6558bac6db436d07ce7142369fd74">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aa5df1d68a2d657fbd81b43ebd25f31be">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a056484711107a67184fe06ca08787d28">operator*</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5ce823c5387254ec5d818ab5bc306ba5">operator*</a> (int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad3a3f0639e487be68cb24ace106cef53">operator*</a> (unsigned int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a895c57b3c0abe260dcbef3fef5f560e8">operator*</a> (long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5d5a64eed1b970b7a4eabeef777cc539">operator*</a> (unsigned long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a10bd8d25ba3d9381d9336b76fb902bc9">operator*</a> (long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a0ef9174dfe623bb5d088a569b5ef4717">operator*</a> (unsigned long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#af67a7e904d73a81f4f2167e5dcf91c49">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ab600df6791ca7221c49c8c0174c71e06">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ab2fa98999a6dbaa739906a5f0a4287b3">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#af3a1365cbd621317c4d601a1fca043a4">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ac757e0e3bd13a55839121256efbf175f">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ab69821350b3dd9ff973a591d13c9ec9b">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a65193fe2cbc07e87e27814d6205de2a5">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a57f6227258a4a3caf42fdb0a33d9fbe3">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a164409a4f7d1198f447d9cbbdbcd38cc">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a750bca3ff1b65a72c451d5918843d105">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a526e3d8d5e180ad629c53303f4a5ff32">operator/</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1152b2d93226f070ce95aac2e2bf4924">operator/</a> (int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a4e9778f587d7e946d34665c4fe2a29bf">operator/</a> (unsigned int lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a22c84b2968cf7610b91b26c12917fd85">operator/</a> (long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae686030e9e376983c0890f8040cd9960">operator/</a> (unsigned long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aea92c22459764282ae0cb7025721fc45">operator/</a> (long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a20daeb0af3a34f1446547a574ed25f4a">operator/</a> (unsigned long long lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae0234bcc7d3130b866529f93080e1b25">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7f08d3001139be01b386a307bc545e70">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad7fabf76eadb1520a9ca352f3392596e">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ac1a88a24414ba370562d2c4fb5e56ee8">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a567f3b624b812a45e51af0caa62d758c">operator==</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a193a6670e2276a5afecc5e92bc687f8a">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad00c974e87f406661c2753eb7c150e07">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a0c4588afdd1c964310da80370e9fac14">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a882ff55643e08a4b27a822a25cb48723">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a34658f603811a331797f2df429adeef9">operator!=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a8bb55d04ccfbaf06ce2de2eb899fa358">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a1d84fc663d04cd193b109b8693aa6d89">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aeefa64f511fe8629decab94df6b77b64">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a92c81dcd32d5b04e933cc9936d23804b">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ab155090f70d753039830394656d15c5c">operator&lt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#aa38a0a8207e675dcc38dea0f490b8c73">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a7cc3bf0add0f602ef5fa1a882fb73bcd">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a8c81b38d293daf693cd217c819deb90e">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a314acb36bbadfb5c6aedd4ae0085d65d">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ace4e79ce738c67680b2ac9b5196ac33f">operator&lt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ac8a23148baef42094366c2beb172e088">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a705c2eff4bf76d5fec1e91402074f360">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a9aa49ea58fcb5801d5d670f3b2abf8ed">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a18a06da25fe68074d0c085f770c3eee7">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a14b1707e55d77701d2e77a743a536c75">operator&gt;</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a051fe28c013cc801774e79af20217e96">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ac2b6f936408fe96448d67da3ecd83c12">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6e8767eca74accbe7631248521019355">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6c67fb28b04ae3185fc2255c309e00e2">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae765601eba0bfa0bc6c841272aebe26f">operator&gt;=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> lhs, <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHARTYPE , class TRAITS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::basic_istream&lt; CHARTYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a6f64ff2b00f00122cab967ea1b27e6fa">operator&gt;&gt;</a> (bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;stream, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHARTYPE , class TRAITS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::basic_ostream&lt; CHARTYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a5acf6deb3166aa8097431a8efa94bc05">operator&lt;&lt;</a> (bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;stream, <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a626622139ddc2e82cc901b9a38384259">operator==</a> (const <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> &amp;lhs, const <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a3f78111da961352d47edd7c9260a6cb0">operator!=</a> (const <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> &amp;lhs, const <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a4c2245e1d2fa23ab02effe9523b2353e">operator|</a> (<a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> lhs, const <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad7816bf075fbe7d979ade785bd6e785e">operator&amp;</a> (<a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> lhs, const <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ad68657eb1663225fa168021193448fa6">operator^</a> (<a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> lhs, const <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#ae822508bd98845fcf7fe388e1c7e0821">operator&lt;&lt;</a> (<a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#abd5a683d365e1583e976e22d22a60dcd">operator&gt;&gt;</a> (<a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> lhs, int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html#a464461bf9fd3ed5060c6fcaee33e3d2d">operator~</a> (<a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> value)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a43ae56bdb8dbe611c06497965d404ccf"></a><!-- doxytag: member="bdldfp::Decimal32" ref="a43ae56bdb8dbe611c06497965d404ccf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal_Type32</a> <a class="el" href="classbdldfp_1_1Decimal__Type32.html">bdldfp::Decimal32</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f13b247a3f13e3bffda9cfe51ee5845"></a><!-- doxytag: member="bdldfp::Decimal64" ref="a5f13b247a3f13e3bffda9cfe51ee5845" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> <a class="el" href="classbdldfp_1_1Decimal__Type64.html">bdldfp::Decimal64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a09749072ea49a21ac8b190a712f99dd5"></a><!-- doxytag: member="bdldfp::Decimal128" ref="a09749072ea49a21ac8b190a712f99dd5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal_Type128</a> <a class="el" href="classbdldfp_1_1Decimal__Type128.html">bdldfp::Decimal128</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab2ecb5051ef405ce62f19e2dd5f09432"></a><!-- doxytag: member="bdldfp::operator+" ref="ab2ecb5051ef405ce62f19e2dd5f09432" args="(Decimal32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a copy of the specified <code>value</code> if the value is not negative zero, and return positive zero otherwise. </p>

</div>
</div>
<a class="anchor" id="a80639a105b0757c8125c97e7e3084022"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a80639a105b0757c8125c97e7e3084022" args="(Decimal32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the result of applying the unary - operator to the specified <code>value</code> as described by IEEE-754, essentially reversing the sign bit. Note that floating-point numbers have signed zero, so this operation is not the same as <code>0 - value</code>. </p>

</div>
</div>
<a class="anchor" id="ae38909e0885ad40b01e80afb221e6737"></a><!-- doxytag: member="bdldfp::operator==" ref="ae38909e0885ad40b01e80afb221e6737" args="(Decimal32 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> have the same value, and <code>false</code> otherwise. Two <code>Decimal32</code> objects have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations equal. In other words, two <code>Decimal32</code> objects have the same value if:</p>
<ul>
<li>
both have a zero value (positive or negative), or  </li>
<li>
both have the same infinity value (both positive or negative), or  </li>
<li>
both have the value of a real number that are equal, even if they are represented differently (cohorts have the same value)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN.</p>
<p>Note that a NaN is never equal to anything, including itself: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdldfp.html#a43ae56bdb8dbe611c06497965d404ccf">Decimal32</a> aNaN = std::numeric_limits&lt;Decimal32&gt;::quiet_NaN();
      assert(!(aNan == aNan));
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a3be038ba34aba97e5c03f884da729377"></a><!-- doxytag: member="bdldfp::operator!=" ref="a3be038ba34aba97e5c03f884da729377" args="(Decimal32 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> do not have the same value, and <code>false</code> otherwise. Two <code>Decimal32</code> objects do not have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations not equal. In other words, two <code>Decimal32</code> objects do not have the same value if:</p>
<ul>
<li>
both are NaN, or  </li>
<li>
one is zero (positive or negative) and the is not, or  </li>
<li>
one is positive infinity and the other is not, or  </li>
<li>
one is negative infinity and the other is not, or  </li>
<li>
both have the value of a real number that are not equal, regardless of their representation (cohorts are equal)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN.</p>
<p>Note that a NaN is never equal to anything, including itself: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdldfp.html#a43ae56bdb8dbe611c06497965d404ccf">Decimal32</a> aNaN = std::numeric_limits&lt;Decimal32&gt;::quiet_NaN();
      assert(aNan != aNan);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a408762d8205e71a2c0409cb9a07cc213"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="a408762d8205e71a2c0409cb9a07cc213" args="(Decimal32 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal32</code> object <code>lhs</code> is less than that of an object <code>rhs</code> if the <code>compareQuietLess</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less than of that of <code>rhs</code>. In other words, <code>lhs</code> is less than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> positive, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> negative, or  </li>
<li>
<code>lhs</code> is not positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="aa5065b3fda89037117befbaa2adfdcdc"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="aa5065b3fda89037117befbaa2adfdcdc" args="(Decimal32 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than or equal the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal32</code> object <code>lhs</code> is less than or equal to the value of an object <code>rhs</code> if the <code>compareQuietLessEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is less or equal than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a949cd1e4244af4155b81e197834cb28a"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="a949cd1e4244af4155b81e197834cb28a" args="(Decimal32 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a greater value than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal32</code> object <code>lhs</code> is greater than that of an object <code>rhs</code> if the <code>compareQuietGreater</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be greater than of that of <code>rhs</code>. In other words, <code>lhs</code> is greater than 'rhs'if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are not both zero (positive or negative), or  </li>
<li>
<code>lhs</code> is not negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a969a92f292998135b90ccd4fbb8e460d"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="a969a92f292998135b90ccd4fbb8e460d" args="(Decimal32 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater than or equal to the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal32</code> object <code>lhs</code> is greater or equal to a <code>Decimal32</code> object <code>rhs</code> if the <code>compareQuietGreaterEqual</code> operation (IEEE-754 defined, non-total ordering comparison ) considers the underlying IEEE representation of <code>lhs</code> to be greater or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is greater than or equal to <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a9c5b76fd3135e7a47b3b4941cf6f622a"></a><!-- doxytag: member="bdldfp::operator&gt;&gt;" ref="a9c5b76fd3135e7a47b3b4941cf6f622a" args="(bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;stream, Decimal32 &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHARTYPE , class TRAITS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp; bdldfp::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read, into the specified <code>object</code>, from the specified input <code>stream</code> an IEEE 32 bit decimal floating-point value as described in the IEEE-754 2008 standard (5.12 Details of conversions between floating point numbers and external character sequences) and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> contains a NaN value, it is unspecified if <code>object</code> will receive a quiet or signaling <code>Nan</code>. If <code>stream</code> is not valid on entry <code>stream.good() == false</code>, this operation has no effect other than setting <code>stream.fail()</code> to <code>true</code>. If eof (end-of-file) is found before any non-whitespace characters <code>stream.fail()</code> is set to <code>true</code> and <code>object</code> remains unchanged. If eof is detected after some characters have been read (and successfully interpreted as part of the textual representation of a floating-point value as specified by IEEE-754) then <code>stream.eof()</code> is set to true. If the first non-whitespace character sequence is not a valid textual representation of a floating-point value (e.g., 12e or e12 or 1*2) the <code>stream.fail()</code> is set to true and <code>object</code> will remain unchanged. If a real number value is represented by the character sequence but it is a large positive or negative value that cannot be stored into <code>object</code> the "overflow" floating-point exception is raised and positive or negative infinity is stored into <code>object</code>, respectively. If a real number value is represented by the character sequence but it is a small positive or negative value that cannot be stored into <code>object</code> the "underflow" floating-point exception is raised and positive or negative zero is stored into <code>object</code>, respectively. If a real number value is represented by the character sequence but it cannot be stored exactly into <code>object</code> the "inexact" floating-point exception is raised, the value is rounded according to the current rounding direction (of the environment) and then stored into <code>object.</code></p>
<p>NOTE: This method does not yet fully support iostream flags or the decimal floating point exception context. </p>

</div>
</div>
<a class="anchor" id="a1d862754e6d8787eb6849b24bfe6eb6e"></a><!-- doxytag: member="bdldfp::operator&lt;&lt;" ref="a1d862754e6d8787eb6849b24bfe6eb6e" args="(bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;stream, Decimal32 object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHARTYPE , class TRAITS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp; bdldfp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single line format as described in the IEEE-754 2008 standard (5.12 Details of conversions between floating point numbers and external character sequences), and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect.</p>
<p>NOTE: This method does not yet fully support iostream flags or the decimal floating point exception context. </p>

</div>
</div>
<a class="anchor" id="a84be4d7983c69ed8978cd7e2188577ae"></a><!-- doxytag: member="bdldfp::operator+" ref="a84be4d7983c69ed8978cd7e2188577ae" args="(Decimal64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a copy of the specified <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="a9ca45433eb684154ee7f3e592f2dc5b5"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a9ca45433eb684154ee7f3e592f2dc5b5" args="(Decimal64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the result of applying the unary - operator to the specified <code>value</code> as described by IEEE-754. Note that floating-point numbers have signed zero, therefore this operation is not the same as <code>0-value</code>. </p>

</div>
</div>
<a class="anchor" id="a5f5eb755d568ce6c1e0c8540d53a1990"></a><!-- doxytag: member="bdldfp::operator++" ref="a5f5eb755d568ce6c1e0c8540d53a1990" args="(Decimal64 &amp;value, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator++ </td>
          <td>(</td>
          <td class="paramtype">Decimal64 &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the prefix ++ operator to the specified <code>value</code> and return its original value. Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to just set it to 1.0 (if the original value is small). </p>

</div>
</div>
<a class="anchor" id="a6f43514e250d9882695b7130704c2d16"></a><!-- doxytag: member="bdldfp::operator&#45;&#45;" ref="a6f43514e250d9882695b7130704c2d16" args="(Decimal64 &amp;value, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator-- </td>
          <td>(</td>
          <td class="paramtype">Decimal64 &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the prefix -- operator to the specified <code>value</code> and return its original value. Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to just set it to 1.0 (if the original value is small). </p>

</div>
</div>
<a class="anchor" id="a712791617f2725f7419f25c86ee67a5b"></a><!-- doxytag: member="bdldfp::operator+" ref="a712791617f2725f7419f25c86ee67a5b" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a827bda9108253b7a36217ed09cb5889e"></a><!-- doxytag: member="bdldfp::operator+" ref="a827bda9108253b7a36217ed09cb5889e" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5e7d14e23ed37d739a4184059a2f8c5c"></a><!-- doxytag: member="bdldfp::operator+" ref="a5e7d14e23ed37d739a4184059a2f8c5c" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the value of the specified <code>rhs</code> to the value of the specified <code>lhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either of <code>lhs</code> or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are infinities of differing signs, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are infinities of the same sign then return infinity of that sign.  </li>
<li>
Otherwise if <code>rhs</code> is zero (positive or negative), return <code>lhs</code>.  </li>
<li>
Otherwise if the sum of <code>lhs</code> and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the sum of the number represented by <code>lhs</code> and the number represented by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="abedc3f5b7525de58c81e96b4b1adb8bd"></a><!-- doxytag: member="bdldfp::operator+" ref="abedc3f5b7525de58c81e96b4b1adb8bd" args="(Decimal64 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a23cb2ab08bd60e740b36f3901280fa05"></a><!-- doxytag: member="bdldfp::operator+" ref="a23cb2ab08bd60e740b36f3901280fa05" args="(Decimal64 lhs, unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa01fdac7c565995f0853b5da747098f9"></a><!-- doxytag: member="bdldfp::operator+" ref="aa01fdac7c565995f0853b5da747098f9" args="(Decimal64 lhs, long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b40dd951ca2bcc31193c780d8c8a281"></a><!-- doxytag: member="bdldfp::operator+" ref="a6b40dd951ca2bcc31193c780d8c8a281" args="(Decimal64 lhs, unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91f8a74d18261c0dfd84d39c61ce1a5d"></a><!-- doxytag: member="bdldfp::operator+" ref="a91f8a74d18261c0dfd84d39c61ce1a5d" args="(Decimal64 lhs, long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a16c1da1431220f77a0325c60582bfd86"></a><!-- doxytag: member="bdldfp::operator+" ref="a16c1da1431220f77a0325c60582bfd86" args="(Decimal64 lhs, unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>rhs</code> to the value of the specified <code>lhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity, then return that infinity.  </li>
<li>
Otherwise if the sum of <code>lhs</code> and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the sum of <code>rhs</code> and the number represented by <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a8c30643d4eacac1aad736c460b7c6bf8"></a><!-- doxytag: member="bdldfp::operator+" ref="a8c30643d4eacac1aad736c460b7c6bf8" args="(int lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a293f49d22e034e1d407ed10c13948eb2"></a><!-- doxytag: member="bdldfp::operator+" ref="a293f49d22e034e1d407ed10c13948eb2" args="(unsigned int lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b901ce48725e89bec42a32ee3b755a7"></a><!-- doxytag: member="bdldfp::operator+" ref="a4b901ce48725e89bec42a32ee3b755a7" args="(long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aefaa35a76ab375ff192c367f332b6a52"></a><!-- doxytag: member="bdldfp::operator+" ref="aefaa35a76ab375ff192c367f332b6a52" args="(unsigned long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad413c48fc35d1ee6b3b9e60e6aade571"></a><!-- doxytag: member="bdldfp::operator+" ref="ad413c48fc35d1ee6b3b9e60e6aade571" args="(long long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e188a7f5230e198fa188aae90af5ed1"></a><!-- doxytag: member="bdldfp::operator+" ref="a3e188a7f5230e198fa188aae90af5ed1" args="(unsigned long long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>lhs</code> to the value of the specified <code>rhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is infinity, then return that infinity.  </li>
<li>
Otherwise if the sum of the value of <code>rhs</code> and <code>lhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the sum of <code>lhs</code> and the number represented by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a54884fa256d0a6f24682966bf5b22b74"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a54884fa256d0a6f24682966bf5b22b74" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a38b03e41269dfb3b9d43b9744467baec"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a38b03e41269dfb3b9d43b9744467baec" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abb4fd83ace1d10cf16f1c16d3546f350"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="abb4fd83ace1d10cf16f1c16d3546f350" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the value of the specified <code>rhs</code> from the value of the specified <code>lhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either <code>lhs</code> or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and the <code>rhs</code> have infinity values of the same sign, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and the <code>rhs</code> have infinity values of differing signs, then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> has a zero value (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if subtracting the value of the <code>rhs</code> object from the value of <code>lhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the result of subtracting the value of <code>rhs</code> from the value of <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a145a2cedb4755c5a13b7553f2e2fd82d"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a145a2cedb4755c5a13b7553f2e2fd82d" args="(Decimal64 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b7b6c22ed34ff9e106bd7f2d2d445af"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a4b7b6c22ed34ff9e106bd7f2d2d445af" args="(Decimal64 lhs, unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7152e0b014613d0576c8812fd63e320e"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a7152e0b014613d0576c8812fd63e320e" args="(Decimal64 lhs, long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ada4dfbc01b6d7b6a0df206403e454c64"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="ada4dfbc01b6d7b6a0df206403e454c64" args="(Decimal64 lhs, unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a475495a793a8b38b1772a7365892444d"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a475495a793a8b38b1772a7365892444d" args="(Decimal64 lhs, long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c5b0354b930a21fdf3dbf1fb4fd72ac"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a3c5b0354b930a21fdf3dbf1fb4fd72ac" args="(Decimal64 lhs, unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the specified <code>rhs</code> from the value of the specified <code>lhs</code> as described by IEEE-754 and return a reference to this object.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity, then return <code>lhs</code>.  </li>
<li>
Otherwise if subtracting <code>rhs</code> from the value of <code>lhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the result of subtracting <code>rhs</code> from the value of <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a0e77b088a514488d1c2f73b2a7894832"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a0e77b088a514488d1c2f73b2a7894832" args="(int lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a31174cd680fc7e6be21718b83dd4a61a"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a31174cd680fc7e6be21718b83dd4a61a" args="(unsigned int lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4fa34a0787256e1913beab4850340d6b"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a4fa34a0787256e1913beab4850340d6b" args="(long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1349838d19e37a10a79d2d4820b18fc7"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a1349838d19e37a10a79d2d4820b18fc7" args="(unsigned long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68e3f7815d5911885932b0891ff2b095"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a68e3f7815d5911885932b0891ff2b095" args="(long long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a09598033d47e78454b6330d002dd7132"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a09598033d47e78454b6330d002dd7132" args="(unsigned long long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the specified <code>rhs</code> from the value of the specified <code>lhs</code> as described by IEEE-754 and return a reference to this object.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity, then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> is zero (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if subtracting <code>rhs</code> from the value of <code>lhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the result of subtracting the value of <code>rhs</code>  </li>
</ul>
<p>from the number <code>lhs</code>. </p>

</div>
</div>
<a class="anchor" id="a8158394e9cee4367a9de15cf73e3646a"></a><!-- doxytag: member="bdldfp::operator*" ref="a8158394e9cee4367a9de15cf73e3646a" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a249b55e1f7199b95dc595676894f4d47"></a><!-- doxytag: member="bdldfp::operator*" ref="a249b55e1f7199b95dc595676894f4d47" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2487d1c4a42e219706d6a1ea6ceafcb"></a><!-- doxytag: member="bdldfp::operator*" ref="ae2487d1c4a42e219706d6a1ea6ceafcb" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the value of the specified <code>lhs</code> object by the value of the specified <code>rhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either of <code>lhs</code> or <code>rhs</code> is NaN, return a NaN.  </li>
<li>
Otherwise if one of the operands is infinity (positive or negative) and the other is zero (positive or negative), then raise the "invalid" floating-point exception raised and return a NaN.  </li>
<li>
Otherwise if both <code>lhs</code> and <code>rhs</code> are infinity (positive or negative), return infinity. The sign of the returned value will be positive if <code>lhs</code> and <code>rhs</code> have the same sign, and negative otherwise.  </li>
<li>
Otherwise, if either <code>lhs</code> or <code>rhs</code> is zero, return zero. The sign of the returned value will be positive if <code>lhs</code> and <code>rhs</code> have the same sign, and negative otherwise.  </li>
<li>
Otherwise if the product of <code>lhs</code> and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the product of <code>lhs</code> and <code>rhs</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the product of the value of <code>rhs</code> and the number represented by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a179c2b50d41e10d0b7d7cc5738d689b9"></a><!-- doxytag: member="bdldfp::operator*" ref="a179c2b50d41e10d0b7d7cc5738d689b9" args="(Decimal64 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd90e175c43b96fda0534b3fb9b674cc"></a><!-- doxytag: member="bdldfp::operator*" ref="abd90e175c43b96fda0534b3fb9b674cc" args="(Decimal64 lhs, unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a387d4af9c1c3323c5e35f925fa9a1e2d"></a><!-- doxytag: member="bdldfp::operator*" ref="a387d4af9c1c3323c5e35f925fa9a1e2d" args="(Decimal64 lhs, long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad704977cfb56bce46b42944a84ccd551"></a><!-- doxytag: member="bdldfp::operator*" ref="ad704977cfb56bce46b42944a84ccd551" args="(Decimal64 lhs, unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d1ef66b67025a06fa73f73b9936250b"></a><!-- doxytag: member="bdldfp::operator*" ref="a5d1ef66b67025a06fa73f73b9936250b" args="(Decimal64 lhs, long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2db6d97a1e4e46a5d2c2a2401d22ebe9"></a><!-- doxytag: member="bdldfp::operator*" ref="a2db6d97a1e4e46a5d2c2a2401d22ebe9" args="(Decimal64 lhs, unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the specified <code>rhs</code> by the value of the specified <code>lhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity (positive or negative), and <code>rhs</code> is zero, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> is zero, then return zero with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if the product of <code>rhs</code> and the value of <code>lhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the product of <code>rhs</code> and the value of <code>lhs</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the product of the value of <code>lhs</code> and value <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a4f03a83dcead492322670cfdcdec07e3"></a><!-- doxytag: member="bdldfp::operator*" ref="a4f03a83dcead492322670cfdcdec07e3" args="(int lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7277eafbe0e3e3d50fe9034d4df99923"></a><!-- doxytag: member="bdldfp::operator*" ref="a7277eafbe0e3e3d50fe9034d4df99923" args="(unsigned int lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9aece4069ae339c31e170c6f815de63f"></a><!-- doxytag: member="bdldfp::operator*" ref="a9aece4069ae339c31e170c6f815de63f" args="(long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a034c1a3122286346440a56f76caf8ab2"></a><!-- doxytag: member="bdldfp::operator*" ref="a034c1a3122286346440a56f76caf8ab2" args="(unsigned long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad080c9dec707ddcb43b6b6362b72ac1e"></a><!-- doxytag: member="bdldfp::operator*" ref="ad080c9dec707ddcb43b6b6362b72ac1e" args="(long long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acc0b67b138b062e980277bad3149d5b3"></a><!-- doxytag: member="bdldfp::operator*" ref="acc0b67b138b062e980277bad3149d5b3" args="(unsigned long long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the specified <code>lhs</code> by the value of the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is infinity (positive or negative), and <code>lhs</code> is zero, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is infinity (positive or negative), then return <code>rhs</code>.  </li>
<li>
Otherwise if <code>lhs</code> is zero, then return zero with the sign of <code>rhs</code>.  </li>
<li>
Otherwise if the product of <code>lhs</code> and the value of <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the product of <code>lhs</code> and the value of <code>rhs</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the product of the value of <code>rhs</code> and value <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a98e1b0a0e35a0e7bb0629c72e76d7972"></a><!-- doxytag: member="bdldfp::operator/" ref="a98e1b0a0e35a0e7bb0629c72e76d7972" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab462462af6b18d3e9caf63e5dbca691b"></a><!-- doxytag: member="bdldfp::operator/" ref="ab462462af6b18d3e9caf63e5dbca691b" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7dcfbd82867b90bca4e60e742ed67eb9"></a><!-- doxytag: member="bdldfp::operator/" ref="a7dcfbd82867b90bca4e60e742ed67eb9" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the value of the specified <code>lhs</code> by the value of the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>lhs</code> or <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are both infinity (positive or negative) or both zero (positive or negative), raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> has a positive zero value, raise the "overflow" floating-point exception and return infinity with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> has a negative zero value, raise the "overflow" floating-point exception and return infinity with the opposite sign as <code>lhs</code>.  </li>
<li>
Otherwise if dividing the value of <code>lhs</code> with the value of <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if dividing the value of <code>lhs</code> with the value of <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the result of dividing the value of <code>lhs</code> with the value of <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="ae1b012dc7bf68ecaf70a7757b9e19579"></a><!-- doxytag: member="bdldfp::operator/" ref="ae1b012dc7bf68ecaf70a7757b9e19579" args="(Decimal64 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74b4147ece5cc88dfb33654f48f422b7"></a><!-- doxytag: member="bdldfp::operator/" ref="a74b4147ece5cc88dfb33654f48f422b7" args="(Decimal64 lhs, unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a40ec48fee99e6fce47d03487d40e7705"></a><!-- doxytag: member="bdldfp::operator/" ref="a40ec48fee99e6fce47d03487d40e7705" args="(Decimal64 lhs, long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb7a13f77b3fe453e5721971bd248101"></a><!-- doxytag: member="bdldfp::operator/" ref="aeb7a13f77b3fe453e5721971bd248101" args="(Decimal64 lhs, unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2a719f2228649060ef7703748e716d4"></a><!-- doxytag: member="bdldfp::operator/" ref="ac2a719f2228649060ef7703748e716d4" args="(Decimal64 lhs, long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a29f336d419a3867412402ae9c75d9726"></a><!-- doxytag: member="bdldfp::operator/" ref="a29f336d419a3867412402ae9c75d9726" args="(Decimal64 lhs, unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the value of the specified <code>lhs</code> by the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity (positive or negative), and <code>rhs</code> is zero, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> is zero, raise the "overflow" floating-point exception return zero with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if the quotient of the value of <code>lhs</code> and <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the quotient of the value of <code>lhs</code> and <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the result of dividing the value of <code>lhs</code> by the value <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a76d423a4b051175c441bf32956ff1d34"></a><!-- doxytag: member="bdldfp::operator/" ref="a76d423a4b051175c441bf32956ff1d34" args="(int lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c4407de5cde0fd91228a5b559925b74"></a><!-- doxytag: member="bdldfp::operator/" ref="a9c4407de5cde0fd91228a5b559925b74" args="(unsigned int lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1377dd223f198a19ae84dcd40b5575f7"></a><!-- doxytag: member="bdldfp::operator/" ref="a1377dd223f198a19ae84dcd40b5575f7" args="(long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abbd35d0425b68b0a98d68fe5661229af"></a><!-- doxytag: member="bdldfp::operator/" ref="abbd35d0425b68b0a98d68fe5661229af" args="(unsigned long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a020e579b7b62e386362c95612b56792a"></a><!-- doxytag: member="bdldfp::operator/" ref="a020e579b7b62e386362c95612b56792a" args="(long long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f047a5612a9515db198155d2d8f5f1d"></a><!-- doxytag: member="bdldfp::operator/" ref="a4f047a5612a9515db198155d2d8f5f1d" args="(unsigned long long lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the specified <code>lhs</code> by the value of the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is infinity (positive or negative), and <code>lhs</code> is zero, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is zero (positive or negative), raise the "overflow" floating-point exception return zero with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if the quotient of <code>rhs</code> and the value of <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the quotient of <code>lhs</code> and the value of <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the result of dividing the value <code>lhs</code> by the value of <code>rhs</code>. Note that this is a floating-point operation, not integer.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a74959f8841f633e66ac6f391a8fc80b0"></a><!-- doxytag: member="bdldfp::operator==" ref="a74959f8841f633e66ac6f391a8fc80b0" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> have the same value, and <code>false</code> otherwise. Two <code>Decimal64</code> objects have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations equal. In other words, two <code>Decimal64</code> objects have the same value if:</p>
<ul>
<li>
both have a zero value (positive or negative), or  </li>
<li>
both have the same infinity value (both positive or negative), or  </li>
<li>
both have the value of a real number that are equal, even if they are represented differently (cohorts have the same value)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN.</p>
<p>Note that a NaN is never equal to anything, including itself: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">Decimal64</a> aNaN = std::numeric_limits&lt;Decimal64&gt;::quiet_NaN();
      assert(!(aNan == aNan));
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="acbdd44b164ba2501a9c3040d344e19f1"></a><!-- doxytag: member="bdldfp::operator==" ref="acbdd44b164ba2501a9c3040d344e19f1" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad313b03cc4cc6cc5572542cabd5522b7"></a><!-- doxytag: member="bdldfp::operator==" ref="ad313b03cc4cc6cc5572542cabd5522b7" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> have the same value, and <code>false</code> otherwise. Two decimal objects have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations equal. In other words, two decimal objects have the same value if:</p>
<ul>
<li>
both have a zero value (positive or negative), or  </li>
<li>
both have the same infinity value (both positive or negative), or  </li>
<li>
both have the value of a real number that are equal, even if they are represented differently (cohorts have the same value)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a40551069dea65d4ff4f4aec1707b7d0f"></a><!-- doxytag: member="bdldfp::operator!=" ref="a40551069dea65d4ff4f4aec1707b7d0f" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> do not have the same value, and <code>false</code> otherwise. Two <code>Decimal64</code> objects do not have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations not equal. In other words, two <code>Decimal64</code> objects do not have the same value if:</p>
<ul>
<li>
both are a NaN, or  </li>
<li>
one has zero value (positive or negative) and the other does not, or  </li>
<li>
one has the value of positive infinity and the other does not, or  </li>
<li>
one has the value of negative infinity and the other does not, or  </li>
<li>
both have the value of a real number that are not equal, regardless of their representation (cohorts are equal)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN.</p>
<p>Note that a NaN is never equal to anything, including itself: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">Decimal64</a> aNaN = std::numeric_limits&lt;Decimal64&gt;::quiet_NaN();
      assert(aNan != aNan);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="af18f47c14cbe0df3a5b63ff86316339e"></a><!-- doxytag: member="bdldfp::operator!=" ref="af18f47c14cbe0df3a5b63ff86316339e" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7dcc608283ad8dd48ae9c79fc68bf0e5"></a><!-- doxytag: member="bdldfp::operator!=" ref="a7dcc608283ad8dd48ae9c79fc68bf0e5" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> do not have the same value, and <code>false</code> otherwise. Two decimal objects do not have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations not equal. In other words, two decimal objects do not have the same value if:</p>
<ul>
<li>
both are NaN, or  </li>
<li>
one has zero value (positive or negative) and the other does not, or  </li>
<li>
one has the value of positive infinity and the other does not, or  </li>
<li>
one has the value of negative infinity and the other does not, or  </li>
<li>
both have the value of a real number that are not equal, regardless of their representation (cohorts are equal)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a7018b3a586ba40868506eea7374e485f"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="a7018b3a586ba40868506eea7374e485f" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal64</code> object <code>lhs</code> is less than that of an object <code>rhs</code> if the <code>compareQuietLess</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less than of that of <code>rhs</code>. In other words, <code>lhs</code> is less than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> is positive, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> negative, or  </li>
<li>
<code>lhs</code> is not positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a86c6f293382e6323ee61055a0339e74c"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="a86c6f293382e6323ee61055a0339e74c" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b86547f6a8badca9861901147a3fce8"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="a0b86547f6a8badca9861901147a3fce8" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a decimal object <code>lhs</code> is less than that of an object <code>rhs</code> if the <code>compareQuietLess</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less than of that of <code>rhs</code>. In other words, <code>lhs</code> is less than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> is positive, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> negative, or  </li>
<li>
<code>lhs</code> is not positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a1ca23bc28412b636d56e651863cc0118"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="a1ca23bc28412b636d56e651863cc0118" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than or equal the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal64</code> object <code>lhs</code> is less than or equal to the value of an object <code>rhs</code> if the <code>compareQuietLessEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is less or equal than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="aee98be433b6e76e628c2078daa94bf98"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="aee98be433b6e76e628c2078daa94bf98" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c2c54b8ca1a03db1f18a7709bf0b0ca"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="a5c2c54b8ca1a03db1f18a7709bf0b0ca" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than or equal the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a decimal object <code>lhs</code> is less than or equal to the value of an object <code>rhs</code> if the <code>compareQuietLessEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is less or equal than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a0e7ad5b9034357a81937c3389b244120"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="a0e7ad5b9034357a81937c3389b244120" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a greater value than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal64</code> object <code>lhs</code> is greater than that of an object <code>rhs</code> if the <code>compareQuietGreater</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be greater than of that of <code>rhs</code>. In other words, <code>lhs</code> is greater than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> positive, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> negative, or  </li>
<li>
<code>lhs</code> is not negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="ad3f6faae64c39941d13cf95b4cdc4543"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="ad3f6faae64c39941d13cf95b4cdc4543" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a663ac2f8d200adc940ff04f3907489a6"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="a663ac2f8d200adc940ff04f3907489a6" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a greater value than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a decimal object <code>lhs</code> is greater than that of an object <code>rhs</code> if the <code>compareQuietGreater</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be greater than of that of <code>rhs</code>. In other words, <code>lhs</code> is greater than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> positive, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> negative, or  </li>
<li>
<code>lhs</code> is not negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="acd81fb2167db0bbd31949629c9d9687b"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="acd81fb2167db0bbd31949629c9d9687b" args="(Decimal64 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater than or equal to the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal64</code> object <code>lhs</code> is greater or equal to a <code>Decimal64</code> object <code>rhs</code> if the <code>compareQuietGreaterEqual</code> operation (IEEE-754 defined, non-total ordering comparison ) considers the underlying IEEE representation of <code>lhs</code> to be greater or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is greater than or equal to <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a5087844a1adf271f576b59612da366ae"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="a5087844a1adf271f576b59612da366ae" args="(Decimal32 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a90d45d198a18b7cff8046beae3524882"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="a90d45d198a18b7cff8046beae3524882" args="(Decimal64 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater than or equal to the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a decimal object <code>lhs</code> is greater or equal to a decimal object <code>rhs</code> if the <code>compareQuietGreaterEqual</code> operation (IEEE-754 defined, non-total ordering comparison ) considers the underlying IEEE representation of <code>lhs</code> to be greater or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is greater than or equal to <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a5787e95fe65b8c7f3b6dbe50409bd385"></a><!-- doxytag: member="bdldfp::operator&gt;&gt;" ref="a5787e95fe65b8c7f3b6dbe50409bd385" args="(bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;stream, Decimal64 &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHARTYPE , class TRAITS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp; bdldfp::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read, into the specified <code>object</code>, from the specified input <code>stream</code> an IEEE 64 bit decimal floating-point value as described in the IEEE-754 2008 standard (5.12 Details of conversions between floating point numbers and external character sequences) and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> contains a Nan value, it is unspecified if <code>object</code> will receive a quiet or signaling <code>Nan</code>. If <code>stream</code> is not valid on entry <code>stream.good() == false</code>, this operation has no effect other than setting <code>stream.fail()</code> to <code>true</code>. If eof (end-of-file) is found before any non-whitespace characters <code>stream.fail()</code> is set to <code>true</code> and <code>object</code> remains unchanged. If eof is detected after some characters have been read (and successfully interpreted as part of the textual representation of a floating-point value as specified by IEEE-754) then <code>stream.eof()</code> is set to true. If the first non-whitespace character sequence is not a valid textual representation of a floating-point value (e.g., 12e or e12 or 1*2) the <code>stream.fail()</code> is set to true and <code>object</code> will remain unchanged. If a real number value is represented by the character sequence but it is a large positive or negative value that cannot be stored into <code>object</code> the "overflow" floating-point exception is raised and positive or negative infinity is stored into <code>object</code>, respectively. If a real number value is represented by the character sequence but it is a small positive or negative value that cannot be stored into <code>object</code> the "underflow" floating-point exception is raised and positive or negative zero is stored into <code>object</code>, respectively. If a real number value is represented by the character sequence but it cannot be stored exactly into <code>object</code> the "inexact" floating-point exception is raised, the value is rounded according to the current rounding direction (of the environment) and then stored into <code>object.</code></p>
<p>NOTE: This method does not yet fully support iostream flags or the decimal floating point exception context. </p>

</div>
</div>
<a class="anchor" id="ab384ddef0de733b9d19a16feeb7089de"></a><!-- doxytag: member="bdldfp::operator&lt;&lt;" ref="ab384ddef0de733b9d19a16feeb7089de" args="(bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;stream, Decimal64 object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHARTYPE , class TRAITS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp; bdldfp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single line format as described in the IEEE-754 2008 standard (5.12 Details of conversions between floating point numbers and external character sequences), and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect.</p>
<p>NOTE: This method does not yet fully support iostream flags or the decimal floating point exception context. </p>

</div>
</div>
<a class="anchor" id="a40790848c2bf7281f2cbdb8253d49ba7"></a><!-- doxytag: member="bdldfp::operator+" ref="a40790848c2bf7281f2cbdb8253d49ba7" args="(Decimal128 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a copy of the specified <code>value</code> if the value is not negative zero, and return positive zero otherwise. </p>

</div>
</div>
<a class="anchor" id="a0829242a35a258679fc86540482f7706"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a0829242a35a258679fc86540482f7706" args="(Decimal128 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the result of applying the unary - operator to the specified <code>value</code> as described by IEEE-754. Note that floating-point numbers have signed zero, therefore this operation is not the same as <code>0-value</code>. </p>

</div>
</div>
<a class="anchor" id="afa28d97911075e510d626c6502034e07"></a><!-- doxytag: member="bdldfp::operator++" ref="afa28d97911075e510d626c6502034e07" args="(Decimal128 &amp;value, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator++ </td>
          <td>(</td>
          <td class="paramtype">Decimal128 &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the prefix ++ operator to the specified <code>value</code> and return its original value. Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to just set it to 1.0 (if the original value is small). </p>

</div>
</div>
<a class="anchor" id="add3d813f6d79d475dff28a19aa8895f2"></a><!-- doxytag: member="bdldfp::operator&#45;&#45;" ref="add3d813f6d79d475dff28a19aa8895f2" args="(Decimal128 &amp;value, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator-- </td>
          <td>(</td>
          <td class="paramtype">Decimal128 &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the prefix -- operator to the specified <code>value</code> and return its original value. Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to just set it to 1.0 (if the original value is small). </p>

</div>
</div>
<a class="anchor" id="a2830823ca25dde6449a4399d4fb5c6e7"></a><!-- doxytag: member="bdldfp::operator+" ref="a2830823ca25dde6449a4399d4fb5c6e7" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae78edd0f19c6340d65c06095da68a0a4"></a><!-- doxytag: member="bdldfp::operator+" ref="ae78edd0f19c6340d65c06095da68a0a4" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a651b20b2df48c668f71d111644de4e10"></a><!-- doxytag: member="bdldfp::operator+" ref="a651b20b2df48c668f71d111644de4e10" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee4588b7e74d2bfd7f3527112b81ce62"></a><!-- doxytag: member="bdldfp::operator+" ref="aee4588b7e74d2bfd7f3527112b81ce62" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5151cf4751fdf90b3aefc0252e9fa4f5"></a><!-- doxytag: member="bdldfp::operator+" ref="a5151cf4751fdf90b3aefc0252e9fa4f5" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the value of the specified <code>rhs</code> to the value of the specified <code>lhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either of <code>lhs</code> or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are infinities of differing signs, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are infinities of the same sign then return infinity of that sign.  </li>
<li>
Otherwise if <code>rhs</code> is zero (positive or negative), return <code>lhs</code>.  </li>
<li>
Otherwise if the sum of <code>lhs</code> and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the sum of the number represented by <code>lhs</code> and the number represented by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a3e8b199d2ecf0faffb7a670e42963b96"></a><!-- doxytag: member="bdldfp::operator+" ref="a3e8b199d2ecf0faffb7a670e42963b96" args="(Decimal128 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7587412884d7514ffb9237b400cd739d"></a><!-- doxytag: member="bdldfp::operator+" ref="a7587412884d7514ffb9237b400cd739d" args="(Decimal128 lhs, unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa6a1e888524b26fb5ef8b46d40110318"></a><!-- doxytag: member="bdldfp::operator+" ref="aa6a1e888524b26fb5ef8b46d40110318" args="(Decimal128 lhs, long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c70323323541c2d601b27f78917a06b"></a><!-- doxytag: member="bdldfp::operator+" ref="a6c70323323541c2d601b27f78917a06b" args="(Decimal128 lhs, unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aedd3c98dd85a45d885b5e0a052b7419a"></a><!-- doxytag: member="bdldfp::operator+" ref="aedd3c98dd85a45d885b5e0a052b7419a" args="(Decimal128 lhs, long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aac05dae1fa1e373ecfa644fa46b46c89"></a><!-- doxytag: member="bdldfp::operator+" ref="aac05dae1fa1e373ecfa644fa46b46c89" args="(Decimal128 lhs, unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>rhs</code> to the value of the specified <code>lhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity, then return that infinity.  </li>
<li>
Otherwise if the sum of <code>lhs</code> and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the sum of <code>rhs</code> and the number represented by <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a1edd09502b2bf0423c9577f359056bed"></a><!-- doxytag: member="bdldfp::operator+" ref="a1edd09502b2bf0423c9577f359056bed" args="(int lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c4846b6c3a00e07de421c5ce87a528a"></a><!-- doxytag: member="bdldfp::operator+" ref="a3c4846b6c3a00e07de421c5ce87a528a" args="(unsigned int lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acd6389909b77735a315778a2a7e809fa"></a><!-- doxytag: member="bdldfp::operator+" ref="acd6389909b77735a315778a2a7e809fa" args="(long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae19c6cc4497a42ed75a7f98559aafb91"></a><!-- doxytag: member="bdldfp::operator+" ref="ae19c6cc4497a42ed75a7f98559aafb91" args="(unsigned long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad875ce27e5bb19074045dda14a8adebe"></a><!-- doxytag: member="bdldfp::operator+" ref="ad875ce27e5bb19074045dda14a8adebe" args="(long long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3136cb28ff8148dd8a026d0ffeaddce5"></a><!-- doxytag: member="bdldfp::operator+" ref="a3136cb28ff8148dd8a026d0ffeaddce5" args="(unsigned long long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator+ </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>lhs</code> to the value of the specified <code>rhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is infinity, then return that infinity.  </li>
<li>
Otherwise if the sum of the value of <code>rhs</code> and <code>lhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the sum of <code>lhs</code> and the number represented by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a3631988897adb72f9a5f2f4270eb31c3"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a3631988897adb72f9a5f2f4270eb31c3" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6041f0842dcf24a240c48d13a738e1a7"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a6041f0842dcf24a240c48d13a738e1a7" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a418d64bb317a43c40aef052045e962e8"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a418d64bb317a43c40aef052045e962e8" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f1f2ecf658812ce07f72a3d60bb08e7"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a1f1f2ecf658812ce07f72a3d60bb08e7" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aedda0ed55913c507631ecf1f1f960325"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="aedda0ed55913c507631ecf1f1f960325" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the value of the specified <code>rhs</code> from the value of the specified <code>lhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either <code>lhs</code> or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and the <code>rhs</code> have infinity values of the same sign, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and the <code>rhs</code> have infinity values of differing signs, then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> has a zero value (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if subtracting the value of the <code>rhs</code> object from the value of <code>lhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the result of subtracting the value of <code>rhs</code> from the value of <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a2ddd3bd2b2e1edea567d9c2626648ee6"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a2ddd3bd2b2e1edea567d9c2626648ee6" args="(Decimal128 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a29b4548881492b9958fbd3a7e29996bf"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a29b4548881492b9958fbd3a7e29996bf" args="(Decimal128 lhs, unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e559647fd9988dc40862b8c68154925"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a6e559647fd9988dc40862b8c68154925" args="(Decimal128 lhs, long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac03704143d6ca989992a4551ab6a99e5"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="ac03704143d6ca989992a4551ab6a99e5" args="(Decimal128 lhs, unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d3ef00f800911b021cd9686ce3f17ed"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a1d3ef00f800911b021cd9686ce3f17ed" args="(Decimal128 lhs, long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68a6493d9eb4ea3ee6052cf338cdc3bc"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a68a6493d9eb4ea3ee6052cf338cdc3bc" args="(Decimal128 lhs, unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the specified <code>rhs</code> from the value of the specified <code>lhs</code> as described by IEEE-754 and return a reference to this object.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity, then return <code>lhs</code>.  </li>
<li>
Otherwise if subtracting <code>rhs</code> from the value of <code>lhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the result of subtracting <code>rhs</code> from the value of <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a34f234c4e7a0b47c391b2c4d696d6ef0"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a34f234c4e7a0b47c391b2c4d696d6ef0" args="(int lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a14b114070d2015acab524084b5693cc7"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a14b114070d2015acab524084b5693cc7" args="(unsigned int lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c5618920578e2b76a53b30cdfd0a268"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a1c5618920578e2b76a53b30cdfd0a268" args="(long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a254002d5fb9fa56ae398026f2d83c78c"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a254002d5fb9fa56ae398026f2d83c78c" args="(unsigned long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ef3de36b19b71ea0c823110982c740c"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="a4ef3de36b19b71ea0c823110982c740c" args="(long long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab92c46957ecd2adc40c4943d935333b"></a><!-- doxytag: member="bdldfp::operator&#45;" ref="aab92c46957ecd2adc40c4943d935333b" args="(unsigned long long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator- </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the specified <code>rhs</code> from the value of the specified <code>lhs</code> as described by IEEE-754 and return a reference to this object.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity, then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> is zero (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if subtracting <code>rhs</code> from the value of <code>lhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise return the result of subtracting the value of <code>rhs</code>  </li>
</ul>
<p>from the number <code>lhs</code>. </p>

</div>
</div>
<a class="anchor" id="a7723e0e409c55d63f12ac0facb2b4bb9"></a><!-- doxytag: member="bdldfp::operator*" ref="a7723e0e409c55d63f12ac0facb2b4bb9" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5736fa2e9e77d58c3945c73d50a0783"></a><!-- doxytag: member="bdldfp::operator*" ref="ae5736fa2e9e77d58c3945c73d50a0783" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa12e1cec92b32759b966e1d1e4b7103f"></a><!-- doxytag: member="bdldfp::operator*" ref="aa12e1cec92b32759b966e1d1e4b7103f" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a568e1522baee556b650d53aa58c7106a"></a><!-- doxytag: member="bdldfp::operator*" ref="a568e1522baee556b650d53aa58c7106a" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c6e3e7c1441d10443bac83ac2d5300e"></a><!-- doxytag: member="bdldfp::operator*" ref="a6c6e3e7c1441d10443bac83ac2d5300e" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the value of the specified <code>lhs</code> object by the value of the specified <code>rhs</code> as described by IEEE-754 and return the result.</p>
<ul>
<li>
If either of <code>lhs</code> or <code>rhs</code> is NaN, return a NaN.  </li>
<li>
Otherwise if one of the operands is infinity (positive or negative) and the other is zero (positive or negative), then raise the "invalid" floating-point exception raised and return a NaN.  </li>
<li>
Otherwise if both <code>lhs</code> and <code>rhs</code> are infinity (positive or negative), return infinity. The sign of the returned value will be positive if <code>lhs</code> and <code>rhs</code> have the same sign, and negative otherwise.  </li>
<li>
Otherwise, if either <code>lhs</code> or <code>rhs</code> is zero, return zero. The sign of the returned value will be positive if <code>lhs</code> and <code>rhs</code> have the same sign, and negative otherwise.  </li>
<li>
Otherwise if the product of <code>lhs</code> and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the product of <code>lhs</code> and <code>rhs</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal128&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the product of the value of <code>rhs</code> and the number represented by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="ad4aae18f456c1c4393fe4de691eb9676"></a><!-- doxytag: member="bdldfp::operator*" ref="ad4aae18f456c1c4393fe4de691eb9676" args="(Decimal128 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74a6dab274885acd28d3bbe7ed900b15"></a><!-- doxytag: member="bdldfp::operator*" ref="a74a6dab274885acd28d3bbe7ed900b15" args="(Decimal128 lhs, unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a67fd47bd8b2f463f3e655f380a719b5b"></a><!-- doxytag: member="bdldfp::operator*" ref="a67fd47bd8b2f463f3e655f380a719b5b" args="(Decimal128 lhs, long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7d6558bac6db436d07ce7142369fd74"></a><!-- doxytag: member="bdldfp::operator*" ref="ac7d6558bac6db436d07ce7142369fd74" args="(Decimal128 lhs, unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5df1d68a2d657fbd81b43ebd25f31be"></a><!-- doxytag: member="bdldfp::operator*" ref="aa5df1d68a2d657fbd81b43ebd25f31be" args="(Decimal128 lhs, long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a056484711107a67184fe06ca08787d28"></a><!-- doxytag: member="bdldfp::operator*" ref="a056484711107a67184fe06ca08787d28" args="(Decimal128 lhs, unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the specified <code>rhs</code> by the value of the specified <code>lhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity (positive or negative), and <code>rhs</code> is zero, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> is zero, then return zero with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if the product of <code>rhs</code> and the value of <code>lhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the product of <code>rhs</code> and the value of <code>lhs</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal128&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the product of the value of <code>lhs</code> and value <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a5ce823c5387254ec5d818ab5bc306ba5"></a><!-- doxytag: member="bdldfp::operator*" ref="a5ce823c5387254ec5d818ab5bc306ba5" args="(int lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3a3f0639e487be68cb24ace106cef53"></a><!-- doxytag: member="bdldfp::operator*" ref="ad3a3f0639e487be68cb24ace106cef53" args="(unsigned int lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a895c57b3c0abe260dcbef3fef5f560e8"></a><!-- doxytag: member="bdldfp::operator*" ref="a895c57b3c0abe260dcbef3fef5f560e8" args="(long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d5a64eed1b970b7a4eabeef777cc539"></a><!-- doxytag: member="bdldfp::operator*" ref="a5d5a64eed1b970b7a4eabeef777cc539" args="(unsigned long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a10bd8d25ba3d9381d9336b76fb902bc9"></a><!-- doxytag: member="bdldfp::operator*" ref="a10bd8d25ba3d9381d9336b76fb902bc9" args="(long long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ef9174dfe623bb5d088a569b5ef4717"></a><!-- doxytag: member="bdldfp::operator*" ref="a0ef9174dfe623bb5d088a569b5ef4717" args="(unsigned long long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator* </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the specified <code>lhs</code> by the value of the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is infinity (positive or negative), and <code>lhs</code> is zero, then raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is infinity (positive or negative), then return <code>rhs</code>.  </li>
<li>
Otherwise if <code>lhs</code> is zero, then return zero with the sign of <code>rhs</code>.  </li>
<li>
Otherwise if the product of <code>lhs</code> and the value of <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the product of <code>lhs</code> and the value of <code>rhs</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal128&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the product of the value of <code>rhs</code> and value <code>lhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="af67a7e904d73a81f4f2167e5dcf91c49"></a><!-- doxytag: member="bdldfp::operator/" ref="af67a7e904d73a81f4f2167e5dcf91c49" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab600df6791ca7221c49c8c0174c71e06"></a><!-- doxytag: member="bdldfp::operator/" ref="ab600df6791ca7221c49c8c0174c71e06" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2fa98999a6dbaa739906a5f0a4287b3"></a><!-- doxytag: member="bdldfp::operator/" ref="ab2fa98999a6dbaa739906a5f0a4287b3" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af3a1365cbd621317c4d601a1fca043a4"></a><!-- doxytag: member="bdldfp::operator/" ref="af3a1365cbd621317c4d601a1fca043a4" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac757e0e3bd13a55839121256efbf175f"></a><!-- doxytag: member="bdldfp::operator/" ref="ac757e0e3bd13a55839121256efbf175f" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the value of the specified <code>lhs</code> by the value of the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>lhs</code> or <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> and <code>rhs</code> are both infinity (positive or negative) or both zero (positive or negative), raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> has a positive zero value, raise the "overflow" floating-point exception and return infinity with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> has a negative zero value, raise the "overflow" floating-point exception and return infinity with the opposite sign as <code>lhs</code>.  </li>
<li>
Otherwise if dividing the value of <code>lhs</code> with the value of <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if dividing the value of <code>lhs</code> with the value of <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal128&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the result of dividing the value of <code>lhs</code> with the value of <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="ab69821350b3dd9ff973a591d13c9ec9b"></a><!-- doxytag: member="bdldfp::operator/" ref="ab69821350b3dd9ff973a591d13c9ec9b" args="(Decimal128 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65193fe2cbc07e87e27814d6205de2a5"></a><!-- doxytag: member="bdldfp::operator/" ref="a65193fe2cbc07e87e27814d6205de2a5" args="(Decimal128 lhs, unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a57f6227258a4a3caf42fdb0a33d9fbe3"></a><!-- doxytag: member="bdldfp::operator/" ref="a57f6227258a4a3caf42fdb0a33d9fbe3" args="(Decimal128 lhs, long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a164409a4f7d1198f447d9cbbdbcd38cc"></a><!-- doxytag: member="bdldfp::operator/" ref="a164409a4f7d1198f447d9cbbdbcd38cc" args="(Decimal128 lhs, unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a750bca3ff1b65a72c451d5918843d105"></a><!-- doxytag: member="bdldfp::operator/" ref="a750bca3ff1b65a72c451d5918843d105" args="(Decimal128 lhs, long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a526e3d8d5e180ad629c53303f4a5ff32"></a><!-- doxytag: member="bdldfp::operator/" ref="a526e3d8d5e180ad629c53303f4a5ff32" args="(Decimal128 lhs, unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the value of the specified <code>lhs</code> by the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>lhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity (positive or negative), and <code>rhs</code> is zero, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>lhs</code> is infinity (positive or negative), then return <code>lhs</code>.  </li>
<li>
Otherwise if <code>rhs</code> is zero, raise the "overflow" floating-point exception return zero with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if the quotient of the value of <code>lhs</code> and <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the quotient of the value of <code>lhs</code> and <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal128&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the result of dividing the value of <code>lhs</code> by the value <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a1152b2d93226f070ce95aac2e2bf4924"></a><!-- doxytag: member="bdldfp::operator/" ref="a1152b2d93226f070ce95aac2e2bf4924" args="(int lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e9778f587d7e946d34665c4fe2a29bf"></a><!-- doxytag: member="bdldfp::operator/" ref="a4e9778f587d7e946d34665c4fe2a29bf" args="(unsigned int lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22c84b2968cf7610b91b26c12917fd85"></a><!-- doxytag: member="bdldfp::operator/" ref="a22c84b2968cf7610b91b26c12917fd85" args="(long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae686030e9e376983c0890f8040cd9960"></a><!-- doxytag: member="bdldfp::operator/" ref="ae686030e9e376983c0890f8040cd9960" args="(unsigned long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea92c22459764282ae0cb7025721fc45"></a><!-- doxytag: member="bdldfp::operator/" ref="aea92c22459764282ae0cb7025721fc45" args="(long long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a20daeb0af3a34f1446547a574ed25f4a"></a><!-- doxytag: member="bdldfp::operator/" ref="a20daeb0af3a34f1446547a574ed25f4a" args="(unsigned long long lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> bdldfp::operator/ </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the specified <code>lhs</code> by the value of the specified <code>rhs</code> as described by IEEE-754, and return the result.</p>
<ul>
<li>
If <code>rhs</code> is NaN, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is infinity (positive or negative), and <code>lhs</code> is zero, raise the "invalid" floating-point exception and return a NaN.  </li>
<li>
Otherwise if <code>rhs</code> is zero (positive or negative), raise the "overflow" floating-pointexception return zero with the sign of <code>lhs</code>.  </li>
<li>
Otherwise if the quotient of <code>rhs</code> and the value of <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal128&gt;max()</code> then raise the "overflow" floating-point exception and return infinity with the same sign as that result.  </li>
<li>
Otherwise if the quotient of <code>lhs</code> and the value of <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal128&gt;min()</code> then raise the "underflow" floating-point exception and return zero with the same sign as that result.  </li>
<li>
Otherwise return the result of dividing the value <code>lhs</code> by the value of <code>rhs</code>. Note that this is a floating-point operation, not integer.  </li>
</ul>

</div>
</div>
<a class="anchor" id="ae0234bcc7d3130b866529f93080e1b25"></a><!-- doxytag: member="bdldfp::operator==" ref="ae0234bcc7d3130b866529f93080e1b25" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> have the same value, and <code>false</code> otherwise. Two <code>Decimal128</code> objects have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations equal. In other words, two <code>Decimal128</code> objects have the same value if:</p>
<ul>
<li>
both have a zero value (positive or negative), or  </li>
<li>
both have the same infinity value (both positive or negative), or  </li>
<li>
both have the value of a real number that are equal, even if they are represented differently (cohorts have the same value)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN.</p>
<p>Note that a NaN is never equal to anything, including itself: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdldfp.html#a09749072ea49a21ac8b190a712f99dd5">Decimal128</a> aNaN = std::numeric_limits&lt;Decimal128&gt;::quiet_NaN();
      assert(!(aNan == aNan));
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a7f08d3001139be01b386a307bc545e70"></a><!-- doxytag: member="bdldfp::operator==" ref="a7f08d3001139be01b386a307bc545e70" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7fabf76eadb1520a9ca352f3392596e"></a><!-- doxytag: member="bdldfp::operator==" ref="ad7fabf76eadb1520a9ca352f3392596e" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1a88a24414ba370562d2c4fb5e56ee8"></a><!-- doxytag: member="bdldfp::operator==" ref="ac1a88a24414ba370562d2c4fb5e56ee8" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a567f3b624b812a45e51af0caa62d758c"></a><!-- doxytag: member="bdldfp::operator==" ref="a567f3b624b812a45e51af0caa62d758c" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> have the same value, and <code>false</code> otherwise. Two decimal objects have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations equal. In other words, two decimal objects have the same value if:</p>
<ul>
<li>
both have a zero value (positive or negative), or  </li>
<li>
both have the same infinity value (both positive or negative), or  </li>
<li>
both have the value of a real number that are equal, even if they are represented differently (cohorts have the same value)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a193a6670e2276a5afecc5e92bc687f8a"></a><!-- doxytag: member="bdldfp::operator!=" ref="a193a6670e2276a5afecc5e92bc687f8a" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> do not have the same value, and <code>false</code> otherwise. Two <code>Decimal128</code> objects do not have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations not equal. In other words, two <code>Decimal128</code> objects do not have the same value if:</p>
<ul>
<li>
both are a NaN, or  </li>
<li>
one has zero value (positive or negative) and the other does not, or  </li>
<li>
one has the value of positive infinity and the other does not, or  </li>
<li>
one has the value of negative infinity and the other does not, or  </li>
<li>
both have the value of a real number that are not equal, regardless of their representation (cohorts are equal)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN.</p>
<p>Note that a NaN is never equal to anything, including itself: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdldfp.html#a09749072ea49a21ac8b190a712f99dd5">Decimal128</a> aNaN = std::numeric_limits&lt;Decimal128&gt;::quiet_NaN();
      assert(aNan != aNan);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ad00c974e87f406661c2753eb7c150e07"></a><!-- doxytag: member="bdldfp::operator!=" ref="ad00c974e87f406661c2753eb7c150e07" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c4588afdd1c964310da80370e9fac14"></a><!-- doxytag: member="bdldfp::operator!=" ref="a0c4588afdd1c964310da80370e9fac14" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a882ff55643e08a4b27a822a25cb48723"></a><!-- doxytag: member="bdldfp::operator!=" ref="a882ff55643e08a4b27a822a25cb48723" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a34658f603811a331797f2df429adeef9"></a><!-- doxytag: member="bdldfp::operator!=" ref="a34658f603811a331797f2df429adeef9" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> do not have the same value, and <code>false</code> otherwise. Two decimal objects do not have the same value if the <code>compareQuietEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representations not equal. In other words, two decimal objects do not have the same value if:</p>
<ul>
<li>
both are NaN, or  </li>
<li>
one has zero value (positive or negative) and the other does not, or  </li>
<li>
one has the value of positive infinity and the other does not, or  </li>
<li>
one has the value of negative infinity and the other does not, or  </li>
<li>
both have the value of a real number that are not equal, regardless of their representation (cohorts are equal)  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a8bb55d04ccfbaf06ce2de2eb899fa358"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="a8bb55d04ccfbaf06ce2de2eb899fa358" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal128</code> object <code>lhs</code> is less than that of an object <code>rhs</code> if the <code>compareQuietLess</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less than of that of <code>rhs</code>. In other words, <code>lhs</code> is less than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> is positive, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> negative, or  </li>
<li>
<code>lhs</code> is not positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a1d84fc663d04cd193b109b8693aa6d89"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="a1d84fc663d04cd193b109b8693aa6d89" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeefa64f511fe8629decab94df6b77b64"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="aeefa64f511fe8629decab94df6b77b64" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a92c81dcd32d5b04e933cc9936d23804b"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="a92c81dcd32d5b04e933cc9936d23804b" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab155090f70d753039830394656d15c5c"></a><!-- doxytag: member="bdldfp::operator&lt;" ref="ab155090f70d753039830394656d15c5c" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a decimal object <code>lhs</code> is less than that of an object <code>rhs</code> if the <code>compareQuietLess</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less than of that of <code>rhs</code>. In other words, <code>lhs</code> is less than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> is positive, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> negative, or  </li>
<li>
<code>lhs</code> is not positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs'is less than that of 'rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="aa38a0a8207e675dcc38dea0f490b8c73"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="aa38a0a8207e675dcc38dea0f490b8c73" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than or equal the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal128</code> object <code>lhs</code> is less than or equal to the value of an object <code>rhs</code> if the <code>compareQuietLessEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is less or equal than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a7cc3bf0add0f602ef5fa1a882fb73bcd"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="a7cc3bf0add0f602ef5fa1a882fb73bcd" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c81b38d293daf693cd217c819deb90e"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="a8c81b38d293daf693cd217c819deb90e" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a314acb36bbadfb5c6aedd4ae0085d65d"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="a314acb36bbadfb5c6aedd4ae0085d65d" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ace4e79ce738c67680b2ac9b5196ac33f"></a><!-- doxytag: member="bdldfp::operator&lt;=" ref="ace4e79ce738c67680b2ac9b5196ac33f" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than or equal the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a decimal object <code>lhs</code> is less than or equal to the value of an object <code>rhs</code> if the <code>compareQuietLessEqual</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be less or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is less or equal than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are positive infinity, or  </li>
<li>
<code>lhs</code> is negative infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is less or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="ac8a23148baef42094366c2beb172e088"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="ac8a23148baef42094366c2beb172e088" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a greater value than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal128</code> object <code>lhs</code> is greater than that of an object <code>rhs</code> if the <code>compareQuietGreater</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be greater than of that of <code>rhs</code>. In other words, <code>lhs</code> is greater than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> positive, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> negative, or  </li>
<li>
<code>lhs</code> is not negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a705c2eff4bf76d5fec1e91402074f360"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="a705c2eff4bf76d5fec1e91402074f360" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9aa49ea58fcb5801d5d670f3b2abf8ed"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="a9aa49ea58fcb5801d5d670f3b2abf8ed" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18a06da25fe68074d0c085f770c3eee7"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="a18a06da25fe68074d0c085f770c3eee7" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a14b1707e55d77701d2e77a743a536c75"></a><!-- doxytag: member="bdldfp::operator&gt;" ref="a14b1707e55d77701d2e77a743a536c75" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a greater value than the specified <code>rhs</code> and <code>false</code> otherwise. The value of a decimal object <code>lhs</code> is greater than that of an object <code>rhs</code> if the <code>compareQuietGreater</code> operation (IEEE-754 defined, non-total ordering comparison) considers the underlying IEEE representation of <code>lhs</code> to be greater than of that of <code>rhs</code>. In other words, <code>lhs</code> is greater than <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>rhs</code> is zero (positive or negative) and <code>lhs</code> positive, or  </li>
<li>
<code>lhs</code> is zero (positive or negative) and <code>rhs</code> negative, or  </li>
<li>
<code>lhs</code> is not negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity and <code>rhs</code> is not, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater than that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a051fe28c013cc801774e79af20217e96"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="a051fe28c013cc801774e79af20217e96" args="(Decimal128 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater than or equal to the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a <code>Decimal128</code> object <code>lhs</code> is greater or equal to a <code>Decimal128</code> object <code>rhs</code> if the <code>compareQuietGreaterEqual</code> operation (IEEE-754 defined, non-total ordering comparison ) considers the underlying IEEE representation of <code>lhs</code> to be greater or equal to that of <code>rhs</code>. In otherwords, <code>lhs</code> is greater than or equal to <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="ac2b6f936408fe96448d67da3ecd83c12"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="ac2b6f936408fe96448d67da3ecd83c12" args="(Decimal32 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e8767eca74accbe7631248521019355"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="a6e8767eca74accbe7631248521019355" args="(Decimal128 lhs, Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal32&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c67fb28b04ae3185fc2255c309e00e2"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="a6c67fb28b04ae3185fc2255c309e00e2" args="(Decimal64 lhs, Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae765601eba0bfa0bc6c841272aebe26f"></a><!-- doxytag: member="bdldfp::operator&gt;=" ref="ae765601eba0bfa0bc6c841272aebe26f" args="(Decimal128 lhs, Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal64&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater than or equal to the value of the specified <code>rhs</code> and <code>false</code> otherwise. The value of a decimal object <code>lhs</code> is greater or equal to a decimal object <code>rhs</code> if the <code>compareQuietGreaterEqual</code> operation (IEEE-754 defined, non-total ordering comparison ) considers the underlying IEEE representation of <code>lhs</code> to be greater or equal to that of <code>rhs</code>. In other words, <code>lhs</code> is greater than or equal to <code>rhs</code> if:</p>
<ul>
<li>
neither <code>lhs</code> nor <code>rhs</code> are NaN, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> are both zero (positive or negative), or  </li>
<li>
both <code>lhs</code> and <code>rhs</code> are negative infinity, or  </li>
<li>
<code>lhs</code> is positive infinity, or  </li>
<li>
<code>lhs</code> and <code>rhs</code> both represent a real number and the real number of <code>lhs</code> is greater or equal to that of <code>rhs</code>  </li>
</ul>
<p>This operation raises the "invalid" floating-point exception if either or both operands are NaN. </p>

</div>
</div>
<a class="anchor" id="a6f64ff2b00f00122cab967ea1b27e6fa"></a><!-- doxytag: member="bdldfp::operator&gt;&gt;" ref="a6f64ff2b00f00122cab967ea1b27e6fa" args="(bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;stream, Decimal128 &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHARTYPE , class TRAITS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp; bdldfp::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">bsl::basic_istream&lt; CHARTYPE, TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read, into the specified <code>object</code>, from the specified input <code>stream</code> an IEEE 128 bit decimal floating-point value as described in the IEEE-754 2008 standard (5.12 Details of conversions between floating point numbers and external character sequences) and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> contains a Nan value, it is unspecified if <code>object</code> will receive a quiet or signaling <code>Nan</code>. If <code>stream</code> is not valid on entry <code>stream.good() == false</code>, this operation has no effect other than setting <code>stream.fail()</code> to <code>true</code>. If eof (end-of-file) is found before any non-whitespace characters <code>stream.fail()</code> is set to <code>true</code> and <code>object</code> remains unchanged. If eof is detected after some characters have been read (and successfully interpreted as part of the textual representation of a floating-point value as specified by IEEE-754) then <code>stream.eof()</code> is set to true. If the first non-whitespace character sequence is not a valid textual representation of a floating-point value (e.g., 12e or e12 or 1*2) the <code>stream.fail()</code> is set to true and <code>object</code> will remain unchanged. If a real number value is represented by the character sequence but it is a large positive or negative value that cannot be stored into <code>object</code> the "overflow" floating-point exception is raised and positive or negative infinity is stored into <code>object</code>, respectively. If a real number value is represented by the character sequence but it is a small positive or negative value that cannot be stored into <code>object</code> the "underflow" floating-point exception is raised and positive or negative zero is stored into <code>object</code>, respectively. If a real number value is represented by the character sequence but it cannot be stored exactly into <code>object</code> the "inexact" floating-point exception is raised, the value is rounded according to the current rounding direction (of the environment) and then stored into <code>object.</code></p>
<p>NOTE: This method does not yet fully support iostream flags or the decimal floating point exception context. </p>

</div>
</div>
<a class="anchor" id="a5acf6deb3166aa8097431a8efa94bc05"></a><!-- doxytag: member="bdldfp::operator&lt;&lt;" ref="a5acf6deb3166aa8097431a8efa94bc05" args="(bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;stream, Decimal128 object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHARTYPE , class TRAITS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp; bdldfp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::basic_ostream&lt; CHARTYPE, TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decimal128&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single line format as described in the IEEE-754 2008 standard (5.12 Details of conversions between floating point numbers and external character sequences), and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect.</p>
<p>NOTE: This method does not yet fully support iostream flags or the decimal floating point exception context. </p>

</div>
</div>
<a class="anchor" id="a626622139ddc2e82cc901b9a38384259"></a><!-- doxytag: member="bdldfp::operator==" ref="a626622139ddc2e82cc901b9a38384259" args="(const Uint128 &amp;lhs, const Uint128 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator== </td>
          <td>(</td>
          <td class="paramtype">const Uint128 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint128 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a></code> objects have the same value if both of their <code>low</code> and <code>high</code> attributes are the same. </p>

</div>
</div>
<a class="anchor" id="a3f78111da961352d47edd7c9260a6cb0"></a><!-- doxytag: member="bdldfp::operator!=" ref="a3f78111da961352d47edd7c9260a6cb0" args="(const Uint128 &amp;lhs, const Uint128 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdldfp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Uint128 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint128 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a></code> objects do not have the same value if either of their <code>low</code> and <code>high</code> attributes are not the same. </p>

</div>
</div>
<a class="anchor" id="a4c2245e1d2fa23ab02effe9523b2353e"></a><!-- doxytag: member="bdldfp::operator|" ref="a4c2245e1d2fa23ab02effe9523b2353e" args="(Uint128 lhs, const Uint128 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> bdldfp::operator| </td>
          <td>(</td>
          <td class="paramtype">Uint128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint128 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> object having the value of a the bitwise or between the specified <code>lhs</code> and the specified <code>rhs</code> value. </p>

</div>
</div>
<a class="anchor" id="ad7816bf075fbe7d979ade785bd6e785e"></a><!-- doxytag: member="bdldfp::operator&amp;" ref="ad7816bf075fbe7d979ade785bd6e785e" args="(Uint128 lhs, const Uint128 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> bdldfp::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">Uint128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint128 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> object having the value of a the bitwise and between the specified <code>lhs</code> and the specified <code>rhs</code> value. </p>

</div>
</div>
<a class="anchor" id="ad68657eb1663225fa168021193448fa6"></a><!-- doxytag: member="bdldfp::operator^" ref="ad68657eb1663225fa168021193448fa6" args="(Uint128 lhs, const Uint128 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> bdldfp::operator^ </td>
          <td>(</td>
          <td class="paramtype">Uint128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint128 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an <a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> object having the value of a the bitwise xor between the specified <code>lhs</code> and the specified <code>rhs</code> value. </p>

</div>
</div>
<a class="anchor" id="ae822508bd98845fcf7fe388e1c7e0821"></a><!-- doxytag: member="bdldfp::operator&lt;&lt;" ref="ae822508bd98845fcf7fe388e1c7e0821" args="(Uint128 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> bdldfp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Uint128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an <code><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a></code> value equal to the value of a bitwise left shift of the specified <code>lhs</code> 128-bit integer shifted by the specified <code>rhs</code> value. The behavior is undefined unless <code>0 &lt;= rhs &lt; 128</code>. </p>

</div>
</div>
<a class="anchor" id="abd5a683d365e1583e976e22d22a60dcd"></a><!-- doxytag: member="bdldfp::operator&gt;&gt;" ref="abd5a683d365e1583e976e22d22a60dcd" args="(Uint128 lhs, int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> bdldfp::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Uint128&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an <code><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a></code> value equal to the value of a bitwise right shift of the specified <code>lhs</code> 128-bit integer shifted by the specified <code>rhs</code> value. The behavior is undefined unless <code>0 &lt;= rhs &lt; 128</code>. </p>

</div>
</div>
<a class="anchor" id="a464461bf9fd3ed5060c6fcaee33e3d2d"></a><!-- doxytag: member="bdldfp::operator~" ref="a464461bf9fd3ed5060c6fcaee33e3d2d" args="(Uint128 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a> bdldfp::operator~ </td>
          <td>(</td>
          <td class="paramtype">Uint128&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an <code><a class="el" href="classbdldfp_1_1Uint128.html">Uint128</a></code> value equal to the bitwise ones compliment of the specified <code>value</code>. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:25 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
