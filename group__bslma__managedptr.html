<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslma_managedptr Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_managedptr<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a managed pointer class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Factories</a> </li>
<li>
<a href="#3.2">Deleters</a> </li>
<li>
<a href="#3.3">Aliasing</a> </li>
<li>
<a href="#3.4">Exception Safety</a> </li>
<li>
<a href="#3.5">Type Casting</a> <ul>
<li>
<a href="#3.5.1">Explicit Casting</a> </li>
<li>
<a href="#3.5.2">Implicit Casting</a> </li>
</ul>
</li>
<li>
<a href="#3.6">Usage</a> <ul>
<li>
<a href="#3.6.1">Example 1: Implementing a Protocol</a> </li>
<li>
<a href="#3.6.2">Example 2: Aliasing</a> </li>
<li>
<a href="#3.6.3">Example 3: Dynamic Objects and Factories</a> </li>
<li>
<a href="#3.6.4">Example 4: Type Casting</a> <ul>
<li>
<a href="#3.6.4.1">Implicit Conversion</a> </li>
<li>
<a href="#3.6.4.2">Explicit Conversion</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a managed pointer class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a> </td><td>proctor for automatic memory management  </td></tr>
<tr>
<td><a class="el" href="structbslma_1_1ManagedPtrUtil.html">bslma::ManagedPtrUtil</a> </td><td>Namespace for deleter for stack-allocated objects  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bslmf_ispolymporphic </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a proctor, <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code>, similar to <code>bsl::auto_ptr</code>, that supports user-specified deleters. The proctor is responsible for the automatic destruction of the object referenced by the managed pointer. As a "smart pointer", this object offers an interface similar to a native pointer, supporting dereference operators (*, -&gt;), (in)equality comparison and testing as if it were a boolean value. However, like <code>bsl::auto_ptr</code> it has unusual "copy-semantics" that transfer ownership of the managed object, rather than making a copy. It should be noted that this signature does not satisfy the requirements for an element-type stored in any of the standard library containers. Note that this component will fail to compile when instantiated for a class that gives a false-positive for the type trait <code><a class="el" href="structbslmf_1_1IsPolymorphic.html">bslmf::IsPolymorphic</a></code>. See the <code>bslmf_ispolymporphic</code> component for more details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="factories"></a> <a class="anchor" id="description.factories"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Factories: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An object that will be managed by a <code>ManagedPtr</code> object is typically dynamically allocated and destroyed by a factory. For the purposes of this, component, a factory is any class that provides a <code>deleteObject</code> function taking a single argument of the (pointer) type of the managed pointer. E.g., <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> is a commonly used factory, and the currently installed default allocator is the factory that is assumed to be used if neither a factory nor deleter (see below) are specified when supplying a pointer to be managed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="deleters"></a> <a class="anchor" id="description.deleters"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When a managed pointer is destroyed, the managed object is destroyed using the user supplied "deleter". A deleter is simply a function that is invoked with two <code>void *</code> arguments: a pointer to the object to be destroyed, and a pointer to a <code>cookie</code> that is supplied at the same time as the <code>deleter</code> and managed object. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> void (*DeleterFunc)(<span class="keywordtype">void</span> *managedObject, <span class="keywordtype">void</span> *cookie);
</pre></div><br/>
<br/>
 The meaning of the <code>cookie</code> depends on the specific deleter. Typically a deleter function will accept the two <code>void *</code> pointers and internally cast them to the appropriate types for pointers to the managed object and <code>cookie</code>. Note that there are no methods taking just a deleter, as the user must always supply a <code>cookie</code> to be passed when the deleter is actually invoked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="aliasing"></a> <a class="anchor" id="description.aliasing"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Aliasing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In a managed pointer, the pointer value (the value returned by the <code>get</code> method) and the pointer to the managed object need not have the same value. The <code>loadAlias</code> method allows a managed pointer to be created as an "alias" to another managed pointer (possibly of a different type), which we'll call the "original" managed pointer. When <code>get</code> is invoked on the alias, the aliased pointer value is returned, but when the managed pointer is destroyed, the original managed object will be passed to the deleter. (See also the documentation of the <code>alias</code> constructor or of the <code>loadAlias</code> method.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception_safety"></a> <a class="anchor" id="description.exception_safety"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Exception Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The principal usage of a managed pointer is to guarantee that a local object will be deallocated properly should an operation throw after its allocation. In this, it is very similar to <code>bsl::auto_ptr</code>. It is required for the proper functioning of this component that a deleter does not throw at invocation (upon destruction or re-assignment of the managed pointer). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="type_casting"></a> <a class="anchor" id="description.type_casting"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Type Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>ManagedPtr</code> objects can be implicitly and explicitly cast to different types in the same way that native pointers can. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="explicit_casting"></a> <a class="anchor" id="type_casting.explicit_casting"></a> <a class="anchor" id="description.type_casting.explicit_casting"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Explicit Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Through "aliasing", a managed pointer of any type can be explicitly cast to a managed pointer of any other type using any legal cast expression. See example 4 on <code>type casting</code> below for more details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implicit_casting"></a> <a class="anchor" id="type_casting.implicit_casting"></a> <a class="anchor" id="description.type_casting.implicit_casting"></a> <a class="anchor" id="3.5.2"></a> </dd></dl>
<dl class="user"><dt><b>Implicit Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>As with native pointers, a managed pointer of the type <code>B</code> that is derived from the type <code>A</code>, can be directly assigned to a <code>ManagedPtr</code> of <code>A</code>. Likewise a managed pointer of type <code>B</code> can be directly assigned to a <code>ManagedPtr</code> of <code>const B</code>. However, the rules for construction are a little more subtle, and apply when passing a <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code> by value into a function, or returning as the result of a function. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span><a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> {};

  <span class="keyword">class </span>B : <span class="keyword">public</span> <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> {};

  <span class="keywordtype">void</span> test()
  {
      B *b_p = 0;
      <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> *a_p = b_p;

      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> b_mp1;
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;A&gt;</a> a_mp1(b_mp1);   <span class="comment">// direct-initialization is valid</span>
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;A&gt;</a> a_mp2 = b_mp1;  <span class="comment">// copy-initialization should fail</span>
}
</pre></div><br/>
<br/>
 Note that <code>std::auto_ptr</code> has the same restriction, and this failure will occur only on compilers that strictly conform to the C++ standard, such as recent gcc compilers or (in this case) IBM xlC. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_protocol"></a> <a class="anchor" id="usage.example_1~3A_implementing_a_protocol"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_a_protocol"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.6.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Protocol: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We demonstrate using <code>ManagedPtr</code> to configure and return a managed object implementing an abstract protocol. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we define our protocol, <code>Shape</code>, a type of object that knows how to compute its <code>area</code>. Note that for expository reasons only, we do <em>nor</em> give <code>Shape</code> a virtual destructor. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Shape {
      <span class="keyword">virtual</span> <span class="keywordtype">double</span> area() <span class="keyword">const</span> = 0;
          <span class="comment">// Return the &#39;area&#39; of this shape.</span>
  };
</pre></div><br/>
<br/>
 Then we define a couple of classes that implement the <code>Shape</code> protocol, a <code>Circle</code> and a <code>Square</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Circle : <span class="keyword">public</span> Shape {
    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <span class="keywordtype">double</span> d_radius;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> Circle(<span class="keywordtype">double</span> radius);
          <span class="comment">// Create a &#39;Circle&#39; object having the specified &#39;radius&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">double</span> area() <span class="keyword">const</span>;
          <span class="comment">// Return the area of this Circle, given by the formula pi*r*r.</span>
  };

  <span class="keyword">class </span>Square : <span class="keyword">public</span> Shape {
    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <span class="keywordtype">double</span> d_sideLength;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> Square(<span class="keywordtype">double</span> side);
          <span class="comment">// Create a &#39;Square&#39; having sides of length &#39;side&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">double</span> area() <span class="keyword">const</span>;
          <span class="comment">// Return the area of this Square, given by the formula side*side</span>
  };
</pre></div><br/>
<br/>
 Next we implement the methods for <code>Circle</code> and <code>Square</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  Circle::Circle(<span class="keywordtype">double</span> radius)
  : d_radius(radius)
  {
  }

  <span class="keywordtype">double</span> Circle::area()<span class="keyword"> const </span>{
      <span class="keywordflow">return</span> 3.141592653589793238462 * d_radius * d_radius;
  }

  Square::Square(<span class="keywordtype">double</span> side)
  : d_sideLength(side)
  {
  }

  <span class="keywordtype">double</span> Square::area()<span class="keyword"> const </span>{
      <span class="keywordflow">return</span> d_sideLength * d_sideLength;
  }
</pre></div><br/>
<br/>
 Then we define an enumeration that lists each implementation of the <code>Shape</code> protocol. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Shapes {
      <span class="keyword">enum</span> VALUES { SHAPE_CIRCLE, SHAPE_SQUARE };
  };
</pre></div><br/>
<br/>
 Now we can define a function that will return a <code>Circle</code> object or a <code>Square</code> object according to the specified <code>kind</code> parameter, and having its <code>dimension</code> specified by the caller. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;Shape&gt;</a> makeShape(Shapes::VALUES kind, <span class="keywordtype">double</span> dimension)
  {
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = <a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>();
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;Shape&gt;</a> result;
      <span class="keywordflow">switch</span> (kind) {
          <span class="keywordflow">case</span> Shapes::SHAPE_CIRCLE : {
              Circle *circ = <span class="keyword">new</span>(*alloc)Circle(dimension);
              result.load(circ);
              <span class="keywordflow">break</span>;
          }
          <span class="keywordflow">case</span> Shapes::SHAPE_SQUARE : {
              Square *sqr = <span class="keyword">new</span>(*alloc)Square(dimension);
              result.load(sqr);
              <span class="keywordflow">break</span>;
          }
      };
      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Then, we can use our function to create shapes of different kinds, and check that they report the correct area. Note that are using a radius of <code>1.0</code> for the <code>Circle</code> and integral side-length for the <code>Square</code> to support an accurate <code>operator==</code> with floating-point quantities. Also note that, despite the destructor for <code>Shape</code> being non-virtual, the correct destructor for the appropriate concrete <code>Shape</code> type is called. This is because the destructor is captured when the <code>ManagedPtr</code> constructor is called, and has access to the complete type of each shape object. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testShapes()
  {
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;Shape&gt;</a> shape = makeShape(Shapes::SHAPE_CIRCLE, 1.0);
      assert(0 != shape);
      assert(3.141592653589793238462 == shape-&gt;area());

      shape = makeShape(Shapes::SHAPE_SQUARE, 2.0);
      assert(0 != shape);
      assert(4.0 == shape-&gt;area());
  }
</pre></div><br/>
<br/>
 Next, we observe that as we are creating objects dynamically, we should pass an allocator to the <code>makeShape</code> function, rather than simply accepting the default allocator each time. Note that when we do this, we pass the user's allocator to the <code>ManagedPtr</code> object as the "factory". <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;Shape&gt;</a> makeShape(Shapes::VALUES    kind,
                                    <span class="keywordtype">double</span>            dimension,
                                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
  {
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(allocator);
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;Shape&gt;</a> result;
      <span class="keywordflow">switch</span> (kind) {
      <span class="keywordflow">case</span> Shapes::SHAPE_CIRCLE : {
              Circle *circ = <span class="keyword">new</span>(*alloc)Circle(dimension);
              result.load(circ, alloc);
              <span class="keywordflow">break</span>;
          }
      <span class="keywordflow">case</span> Shapes::SHAPE_SQUARE : {
              Square *sqr = <span class="keyword">new</span>(*alloc)Square(dimension);
              result.load(sqr, alloc);
              <span class="keywordflow">break</span>;
          }
      };
      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Finally we repeat the earlier test, additionally passing a test allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testShapesToo()
  {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta(<span class="stringliteral">&quot;object&quot;</span>);

      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;Shape&gt;</a> shape =
                                   makeShape(Shapes::SHAPE_CIRCLE, 1.0, &amp;ta);
      assert(0 != shape);
      assert(3.141592653589793238462 == shape-&gt;area());

      shape = makeShape(Shapes::SHAPE_SQUARE, 3.0, &amp;ta);
      assert(0 != shape);
      assert(9.0 == shape-&gt;area());
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_aliasing"></a> <a class="anchor" id="usage.example_2~3A_aliasing"></a> <a class="anchor" id="description.usage.example_2~3A_aliasing"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.6.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Aliasing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we wish to give access to an item in a temporary array via a pointer which we'll call the "finger". The finger is the only pointer to the array or any part of the array, but the entire array must be valid until the finger is destroyed, at which time the entire array must be deleted. We handle this situation by first creating a managed pointer to the entire array, then creating an alias of that pointer for the finger. The finger takes ownership of the array instance, and when the finger is destroyed, it is the array's address, rather than the finger, that is passed to the deleter. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, let's say our array stores data acquired from a ticker plant accessible by a global <code>getQuote</code> function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Ticker {

      <span class="keyword">static</span> <span class="keywordtype">double</span> getQuote() <span class="comment">// From ticker plant.  Simulated here</span>
      {
          <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> QUOTES[] = {
          7.25, 12.25, 11.40, 12.00, 15.50, 16.25, 18.75, 20.25, 19.25, 21.00
          };
          <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_QUOTES = <span class="keyword">sizeof</span>(QUOTES) / <span class="keyword">sizeof</span>(QUOTES[0]);
          <span class="keyword">static</span> <span class="keywordtype">int</span> index = 0;

          <span class="keywordtype">double</span> ret = QUOTES[index];
          index = (index + 1) % NUM_QUOTES;
          <span class="keywordflow">return</span> ret;
      }
  };
</pre></div><br/>
<br/>
 Then, we want to find the first quote larger than a specified threshold, but would also like to keep the earlier and later quotes for possible examination. Our <code>getFirstQuoteLargerThan</code> function must allocate memory for an array of quotes (the threshold and its neighbors). It thus returns a managed pointer to the desired value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">double</span> END_QUOTE = -1;

  <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;double&gt;</a>
  getFirstQuoteLargerThan(<span class="keywordtype">double</span> threshold, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
  {
      assert(END_QUOTE &lt; 0 &amp;&amp; 0 &lt;= threshold);
</pre></div><br/>
<br/>
 Next, we allocate our array with extra room to mark the beginning and end with a special <code>END_QUOTE</code> value: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_QUOTES = 100;
      <span class="keywordtype">int</span> numBytes = (MAX_QUOTES + 2) * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>);
      <span class="keywordtype">double</span> *quotes = (<span class="keywordtype">double</span>*) allocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>(numBytes);
      quotes[0] = quotes[MAX_QUOTES + 1] = END_QUOTE;
</pre></div><br/>
<br/>
 Then, we create a managed pointer to the entire array: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;double&gt;</a> managedQuotes(quotes, allocator);
</pre></div><br/>
<br/>
 Next, we read quotes until the array is full, keeping track of the first quote that exceeds the threshold. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">double</span> *finger = 0;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= MAX_QUOTES; ++i) {
          <span class="keywordtype">double</span> quote = Ticker::getQuote();
          quotes[i] = quote;
          <span class="keywordflow">if</span> (!finger &amp;&amp; quote &gt; threshold) {
              finger = &amp;quotes[i];
          }
      }
</pre></div><br/>
<br/>
 Now, we use the alias constructor to create a managed pointer that points to the desired value (the finger) but manages the entire array: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">return</span> <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;double&gt;</a>(managedQuotes, finger);
  }
</pre></div><br/>
<br/>
 Then, our main program calls <code>getFirstQuoteLargerThan</code> like this: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> aliasExample()
  {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta;
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;double&gt;</a> result = getFirstQuoteLargerThan(16.00, &amp;ta);
      assert(*result &gt; 16.00);
      assert(1 == ta.<a class="code" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a>());
      <span class="keywordflow">if</span> (g_verbose) bsl::cout &lt;&lt; <span class="stringliteral">&quot;Found quote: &quot;</span> &lt;&lt; *result &lt;&lt; bsl::endl;
</pre></div><br/>
<br/>
 Next, We also print the preceding 5 quotes in last-to-first order: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (g_verbose) bsl::cout &lt;&lt; <span class="stringliteral">&quot;Preceded by:&quot;</span>;
      <span class="keywordtype">int</span> i;
      <span class="keywordflow">for</span> (i = -1; i &gt;= -5; --i) {
          <span class="keywordtype">double</span> quote = result.<a class="code" href="classbslma_1_1ManagedPtr.html#a83325a674a64bd8c45607d2822df0d8e">get</a>()[i];
          <span class="keywordflow">if</span> (END_QUOTE == quote) {
              <span class="keywordflow">break</span>;
          }
          assert(quote &lt; *result);
          <span class="keywordflow">if</span> (g_verbose) bsl::cout &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; quote;
      }
      <span class="keywordflow">if</span> (g_verbose) bsl::cout &lt;&lt; bsl::endl;
</pre></div><br/>
<br/>
 Then, to move the finger, e.g., to the last position printed, one must be careful to retain the ownership of the entire array. Using the statement <code>result.load(result.get()-i)</code> would be an error, because it would first compute the pointer value <code>result.get()-i</code> of the argument, then release the entire array before starting to manage what has now become an invalid pointer. Instead, <code>result</code> must retain its ownership to the entire array, which can be attained by: <br/>
<br/>
<div class="fragment"><pre class="fragment">      result.<a class="code" href="classbslma_1_1ManagedPtr.html#acf50f35b32c6b2a8d6638d21fa2df9b8">loadAlias</a>(result, result.<a class="code" href="classbslma_1_1ManagedPtr.html#a83325a674a64bd8c45607d2822df0d8e">get</a>()-i);
</pre></div><br/>
<br/>
 Finally, if we reset the result pointer, the entire array is deallocated: <br/>
<br/>
<div class="fragment"><pre class="fragment">      result.<a class="code" href="classbslma_1_1ManagedPtr.html#af96bb8356e57e2ab6037d45f7f594d86">reset</a>();
      assert(0 == ta.<a class="code" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a>());
      assert(0 == ta.<a class="code" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse</a>());

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_dynamic_objects_and_factories"></a> <a class="anchor" id="usage.example_3~3A_dynamic_objects_and_factories"></a> <a class="anchor" id="description.usage.example_3~3A_dynamic_objects_and_factories"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.6.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Dynamic Objects and Factories: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to track the number of objects currently managed by <code>ManagedPtr</code> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we define a factory type, that holds an allocator and a usage-counter. Note that such a type cannot sensibly be copied, as the notion <code>count</code> becomes confused. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>CountedFactory {
      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span>               d_count;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;

      <span class="comment">// NOT IMPLEMENTED</span>
      CountedFactory(<span class="keyword">const</span> CountedFactory&amp;);
      CountedFactory&amp; operator=(<span class="keyword">const</span> CountedFactory&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> CountedFactory(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0);
          <span class="comment">// Create a &#39;CountedFactory&#39; object which uses the supplied</span>
          <span class="comment">// allocator &#39;alloc&#39;.</span>

      ~CountedFactory();
          <span class="comment">// Destroy this object.</span>
</pre></div><br/>
<br/>
 Next, we provide the <code>createObject</code> and <code>deleteObject</code> functions that are standard for factory objects. Note that the <code>deleteObject</code> function signature has the form required by <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code> for a factory. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
      TYPE *createObject();
          <span class="comment">// Return a pointer to a newly allocated object of type &#39;TYPE&#39;</span>
          <span class="comment">// created using its default constructor.  Memory for the object</span>
          <span class="comment">// is supplied by the allocator supplied to this factory&#39;s</span>
          <span class="comment">// constructor, and the count of valid object is incremented.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
      <span class="keywordtype">void</span> deleteObject(<span class="keyword">const</span> TYPE *target);
          <span class="comment">// Destroy the object pointed to by &#39;target&#39; and reclaim the</span>
          <span class="comment">// memory.  Decrement the count of currently valid objects.</span>
</pre></div><br/>
<br/>
 Then, we round out the class with the ability to query the <code>count</code> of currently allocated objects. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> count() <span class="keyword">const</span>;
          <span class="comment">// Return the number of currently valid objects allocated by this</span>
          <span class="comment">// factory.</span>
  };
</pre></div><br/>
<br/>
 Next, we define the operations declared by the class. <br/>
<br/>
<div class="fragment"><pre class="fragment">  CountedFactory::CountedFactory(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc)
  : d_count(0)
  , d_allocator_p(bslma::Default::allocator(alloc))
  {
  }

  CountedFactory::~CountedFactory()
  {
      assert(0 == d_count);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  TYPE *CountedFactory::createObject()
  {
      TYPE *result = <span class="keyword">new</span>(*d_allocator_p)TYPE;
      ++d_count;
      <span class="keywordflow">return</span> result;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> CountedFactory::deleteObject(<span class="keyword">const</span> TYPE *<span class="keywordtype">object</span>)
  {
      d_allocator_p-&gt;deleteObject(<span class="keywordtype">object</span>);
      --d_count;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> CountedFactory::count()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_count;
  }
</pre></div><br/>
<br/>
 Then, we can create a test function to illustrate how such a factory would be used with <code>ManagedPtr</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testCountedFactory()
  {
</pre></div><br/>
<br/>
 Next, we declare a test allocator, and an object of our <code>CountedFactory</code> type using that allocator. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta;
      CountedFactory cf(&amp;ta);
</pre></div><br/>
<br/>
 Then, we open a new local scope and declare an array of managed pointers. We need a local scope in order to observe the behavior of the destructors at end of the scope, and use an array as an easy way to count more than one object. <br/>
<br/>
<div class="fragment"><pre class="fragment">      {
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;int&gt;</a> pData[4];
</pre></div><br/>
<br/>
 Next, we load each managed pointer in the array with a new <code>int</code> using our factory <code>cf</code> and assert that the factory <code>count</code> is correct after each new <code>int</code> is created. <br/>
<br/>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">int</span> i = 0;
          <span class="keywordflow">while</span> (i != 4) {
              pData[i++].load(cf.createObject&lt;<span class="keywordtype">int</span>&gt;(), &amp;cf);
              assert(cf.count() == i);
          }
</pre></div><br/>
<br/>
 Then, we <code>reset</code> the contents of a single managed pointer in the array, and assert that the factory <code>count</code> is appropriately reduced. <br/>
<br/>
<div class="fragment"><pre class="fragment">          pData[1].<a class="code" href="classbslma_1_1ManagedPtr.html#af96bb8356e57e2ab6037d45f7f594d86">reset</a>();
          assert(3 == cf.count());
</pre></div><br/>
<br/>
 Next, we <code>load</code> a managed pointer with another new <code>int</code> value, again using <code>cf</code> as the factory, and assert that the <code>count</code> of valid objects remains the same (destroy one object and add another). <br/>
<br/>
<div class="fragment"><pre class="fragment">          pData[2].load(cf.createObject&lt;<span class="keywordtype">int</span>&gt;(), &amp;cf);
          assert(3 == cf.count());
      }
</pre></div><br/>
<br/>
 Finally, we allow the array of managed pointers to go out of scope and confirm that when all managed objects are destroyed, the factory <code>count</code> falls to zero, and does not overshoot. <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(0 == cf.count());
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_4~3A_type_casting"></a> <a class="anchor" id="usage.example_4~3A_type_casting"></a> <a class="anchor" id="description.usage.example_4~3A_type_casting"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="usage.example_4"></a> <a class="anchor" id="description.usage.example_4"></a> <a class="anchor" id="3.6.4"></a> </dd></dl>
<dl class="user"><dt><b>Example 4: Type Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>ManagedPtr</code> objects can be implicitly and explicitly cast to different types in the same way that native pointers can. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implicit_conversion"></a> <a class="anchor" id="example_4.implicit_conversion"></a> <a class="anchor" id="usage.example_4.implicit_conversion"></a> <a class="anchor" id="description.usage.example_4.implicit_conversion"></a> <a class="anchor" id="3.6.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Implicit Conversion: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>As with native pointers, a pointer of the type <code>B</code> that is publicly derived from the type <code>A</code>, can be directly assigned a <code>ManagedPtr</code> of <code>A</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, consider the following code snippets: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> implicitCastingExample()
  {
</pre></div><br/>
<br/>
 If the statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> localDefaultTa;
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> localTa;

      <a class="code" href="classbslma_1_1DefaultAllocatorGuard.html">bslma::DefaultAllocatorGuard</a> guard(&amp;localDefaultTa);

      <span class="keywordtype">int</span> numdels = 0;

      {
          B *b_p = 0;
          <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> *a_p = b_p;
</pre></div><br/>
<br/>
 are legal expressions, then the statements <br/>
<br/>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;A&gt;</a> a_mp1;
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> b_mp1;

          assert(!a_mp1 &amp;&amp; !b_mp1);

          a_mp1 = b_mp1;      <span class="comment">// conversion assignment of nil ptr to nil</span>
          assert(!a_mp1 &amp;&amp; !b_mp1);

          B *b_p2 = <span class="keyword">new</span> (localDefaultTa) B(&amp;numdels);
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> b_mp2(b_p2);    <span class="comment">// default allocator</span>
          assert(!a_mp1 &amp;&amp; b_mp2);

          a_mp1 = b_mp2;      <span class="comment">// conversion assignment of nonnil ptr to nil</span>
          assert(a_mp1 &amp;&amp; !b_mp2);

          B *b_p3 = <span class="keyword">new</span> (localTa) B(&amp;numdels);
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> b_mp3(b_p3, &amp;localTa);
          assert(a_mp1 &amp;&amp; b_mp3);

          a_mp1 = b_mp3;      <span class="comment">// conversion assignment of nonnil to nonnil</span>
          assert(a_mp1 &amp;&amp; !b_mp3);

          a_mp1 = b_mp3;      <span class="comment">// conversion assignment of nil to nonnil</span>
          assert(!a_mp1 &amp;&amp; !b_mp3);

          <span class="comment">// constructor conversion init with nil</span>
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;A&gt;</a> a_mp4(b_mp3, b_mp3.get());
          assert(!a_mp4 &amp;&amp; !b_mp3);

          <span class="comment">// constructor conversion init with nonnil</span>
          B *p_b5 = <span class="keyword">new</span> (localTa) B(&amp;numdels);
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> b_mp5(p_b5, &amp;localTa);
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;A&gt;</a> a_mp5(b_mp5, b_mp5.get());
          assert(a_mp5 &amp;&amp; !b_mp5);
          assert(a_mp5.get() == p_b5);

          <span class="comment">// constructor conversion init with nonnil</span>
          B *p_b6 = <span class="keyword">new</span> (localTa) B(&amp;numdels);
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> b_mp6(p_b6, &amp;localTa);
          <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;A&gt;</a> a_mp6(b_mp6);
          assert(a_mp6 &amp;&amp; !b_mp6);
          assert(a_mp6.get() == p_b6);

          <span class="keyword">struct </span>S {
              <span class="keywordtype">int</span> d_i[10];
          };

          assert(200 == numdels);
      }

      assert(400 == numdels);
  } <span class="comment">// implicitCastingExample()</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="explicit_conversion"></a> <a class="anchor" id="example_4.explicit_conversion"></a> <a class="anchor" id="usage.example_4.explicit_conversion"></a> <a class="anchor" id="description.usage.example_4.explicit_conversion"></a> <a class="anchor" id="3.6.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Explicit Conversion: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Through "aliasing", a managed pointer of any type can be explicitly converted to a managed pointer of any other type using any legal cast expression. For example, to static-cast a managed pointer of type A to a managed pointer of type B, one can simply do the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> explicitCastingExample() {

      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;A&gt;</a> a_mp;
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> b_mp1(a_mp, static_cast&lt;B*&gt;(a_mp.<a class="code" href="classbslma_1_1ManagedPtr.html#a83325a674a64bd8c45607d2822df0d8e">get</a>()));
</pre></div><br/>
<br/>
 or even use the less safe "C"-style casts: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// bslma::ManagedPtr&lt;A&gt; a_mp;</span>
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> b_mp2(a_mp, (B*)(a_mp.<a class="code" href="classbslma_1_1ManagedPtr.html#a83325a674a64bd8c45607d2822df0d8e">get</a>()));

  } <span class="comment">// explicitCastingExample()</span>
</pre></div><br/>
<br/>
 Note that when using dynamic cast, if the cast fails, the target managed pointer will be reset to an unset state, and the source will not be modified. Consider for example the following snippet of code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> processPolymorphicObject(<a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;A&gt;</a> aPtr,
                                <span class="keywordtype">bool</span> *castSucceeded)
  {
      <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;B&gt;</a> bPtr(aPtr, dynamic_cast&lt;B*&gt;(aPtr.<a class="code" href="classbslma_1_1ManagedPtr.html#a83325a674a64bd8c45607d2822df0d8e">get</a>()));
      <span class="keywordflow">if</span> (bPtr) {
          assert(!aPtr);
          *castSucceeded = <span class="keyword">true</span>;
      }
      <span class="keywordflow">else</span> {
          assert(aPtr);
          *castSucceeded = <span class="keyword">false</span>;
      }
  }
</pre></div><br/>
<br/>
 If the value of <code>aPtr</code> can be dynamically cast to <code>B*</code> then ownership is transferred to <code>bPtr</code>, otherwise <code>aPtr</code> is to be modified. As previously stated, the managed object will be destroyed correctly regardless of how it is cast. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:58 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
