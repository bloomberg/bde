<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslalg_hashtableimputil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_hashtableimputil<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide algorithms for implementing a hash table.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Hash Table Structure</a> </li>
<li>
<a href="#3.2">Hash Function and the Adjusted Hash Value</a> </li>
<li>
<a href="#3.3">Well-Formed <code>HashTableAnchor</code> Objects</a> </li>
<li>
<a href="#3.4"><code>KEY_CONFIG</code> Template Parameter</a> <ul>
<li>
<a href="#3.4.1"><code>KEY_CONFIG</code></a> </li>
</ul>
</li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Creating and Using a Hash Set</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide algorithms for implementing a hash table. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslalg_1_1HashTableImpUtil.html">bslalg::HashTableImpUtil</a> </td><td>functions used to implement a hash table  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__bidirectionallinklistutil.html" title="Provide utilities to maintain bidirectional list data structures.">Component bslalg_bidirectionallinklistutil</a>, <a class="el" href="group__bslalg__hashtableanchor.html" title="Provide a type holding the constituent parts of a hash table.">Component bslalg_hashtableanchor</a>, <a class="el" href="group__bslstl__hashtable.html" title="Provide a hash-container with support for duplicate values.">Component bslstl_hashtable</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a namespace for utility functions used to implement a hash table container. Almost all the functions provided by this component operate on a <code>HashTableAnchor</code>, a type encapsulating the key data members of a hash table. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hash_table_structure"></a> <a class="anchor" id="description.hash_table_structure"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Hash Table Structure: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The utilities provided by this component are used to create and manipulate a hash table that resolves collisions using a linked-list of elements (i.e., chaining). Many of the operations provided by <code>HashTableImpUtil</code> operate on a <code>HashTableAnchor</code>, which encapsulates the key data members of a hash table. A <code>HashTableAnchor</code> has the address of a single, doubly linked list holding all the elements in the hash table, as well as the address of an array of buckets. Each bucket holds a reference to the first and last element in the linked-list whose <em>adjusted</em> <em>hash</em> <em>value</em> is equal to the index of the bucket. Further, the functions in this component ensure (and require) that all elements that fall within a bucket form a contiguous sequence in the linked list, as can be seen in the diagram below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  FIG 1: a hash table holding 5 elements

  <a class="code" href="classBloombergLP_1_1bslh_1_1Hash.html">Hash</a> Function:  h(n) -&gt; n  [identity function]
  F: First Element
  L: Last Element

                     0       1       2       3       4
                 +-------+-------+-------+-------+-------+--
  bucket array   |  F L  |  F L  |  F L  |  F L  |  F L  |  ...
                 +--+-+--+-------+-------+--+-+--+-------+--
                    | \___         _________/ /
                     \    \       /          |
                     V     V     V           V
                    ,-.   ,-.   ,-.   ,-.   ,-.
  doubly        |---|0|---|0|---|3|---|3|---|3|--|
  linked-list       `-<span class="stringliteral">&#39;   `-&#39;</span>   `-<span class="stringliteral">&#39;   `-&#39;</span>   `-<span class="stringliteral">&#39;</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hash_function_and_the_adjusted_hash_value"></a> <a class="anchor" id="description.hash_function_and_the_adjusted_hash_value"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Hash Function and the Adjusted Hash Value: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The C++11 standard defines a hash function as a function <code>h(k)</code> returning (integral) values of type <code>size_t</code>, such that, for two different values of <code>k1</code> and <code>k2</code>, the probability that <code>h(k1) == h(k2)</code> is true should approach <code>1.0 / numeric_limits&lt;size_t&gt;max()</code> (see 17.6.3.4 [hash.requirements]). Such a function <code>h(k)</code> may return values within the entire range of values that can be described using <code>size_t</code>, [0 .. numeric_limits&lt;size_t&gt;max()], however the array of buckets maintained by a hash table is typically significantly smaller than <code>number_limits&lt;size_t&gt;max()</code>, therefore a hash-table implementation must adjust the returned hash function so that it falls in the valid range of bucket indices (typically either using an integer division or modulo operation) -- we refer to this as the <em>adjusted</em> <em>hash</em> <em>value</em>. Note that currently <code>HashTableImpUtil</code> adjusts the value returned by a supplied hash function using <code>operator%</code> (modulo), which is more resilient to pathological behaviors when used in conjunction with a hash function that may produce contiguous hash values (with the <code>div</code> method lower order bits do not participate to the final adjusted value); however, the means of adjustment may change in the future. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="well-formed_hashtableanchor_objects"></a> <a class="anchor" id="description.well-formed_hashtableanchor_objects"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Well-Formed HashTableAnchor Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Many of the algorithms defined in this component operate on <code>HashTableAnchor</code> objects, which describe the attributes of a hash table. The <code>HashTableAnchor</code> objects supplied to <code>HashTableImpUtil</code> are required to meet a series of constraints that are not enforced by the <code>HashTableAnchor</code> type itself. A <code>HashTableAnchor</code> object meeting these requirements is said to be "well-formed" and the method <code>HashTableImpUtil::isWellFormed</code> returns <code>true</code> for such an object. A <code>HastTableAnchor</code> is considered well-formed for a particular key policy, <code>KEY_CONFIG</code>, and hash functor, <code>HASHER</code>, if all of the following are true: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
The list refers to a well-formed doubly linked list (see <code>bslalg_bidirectionallinklistutil</code>).  </li>
<li>
Each link in the list is an object of type <code>BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;</code>  </li>
<li>
For each bucket, the range of nodes <code>[ bucket.first(), bucket.last() ]</code> contains all nodes in the hash table for which <code>computeBucketIndex(HASHER(extractKey(link)</code> is the index of the bucket, and no other nodes.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="key_config_template_parameter"></a> <a class="anchor" id="description.key_config_template_parameter"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>KEY_CONFIG Template Parameter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Several of the operations provided by <code>HashTableImpUtil</code> are template functions parameterized on the typename <code>KEY_CONFIG</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="key_config"></a> <a class="anchor" id="key_config_template_parameter.key_config"></a> <a class="anchor" id="description.key_config_template_parameter.key_config"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>KEY_CONFIG: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>KEY_CONFIG</code> template parameter must provide the the following type aliases and functions: <br/>
<br/>
<div class="fragment"><pre class="fragment">  typedef &lt;VALUE_TYPE&gt; ValueType;
     <span class="comment">// Alias for the type of the values stored by the &#39;BidirectionalNode&#39;</span>
     <span class="comment">// elements in the hash table.</span>

  typedef &lt;KEY_TYPE&gt; KeyType;
     <span class="comment">// Alias for the type of the key value extracted from the &#39;ValueType&#39;</span>
     <span class="comment">// stored in the &#39;BidirectionalNode&#39; elements of a hash table.</span>

  <span class="keyword">static</span> <span class="keyword">const</span> KeyType&amp; extractKey(<span class="keyword">const</span> ValueType&amp; obj);
      <span class="comment">// Return the &#39;KeyType&#39; information associated with the specified</span>
      <span class="comment">// &#39;object&#39;.</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_and_using_a_hash_set"></a> <a class="anchor" id="usage.example_1~3A_creating_and_using_a_hash_set"></a> <a class="anchor" id="description.usage.example_1~3A_creating_and_using_a_hash_set"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating and Using a Hash Set: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to build a hash set that will keep track of keys stored in set. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define an abstract template class <code>HashSet</code> that will provide a hash set for any type that has a copy constructor, a destructor, an equality comparator and a hash function. We inherit from the <code>HashTableAnchor</code> class use the the <code>BidirectionalLinkListUtil</code> and <code>HashTableImpUtil</code> classes to facilitate building the table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  <span class="keyword">class </span>HashSet : <span class="keyword">public</span> bslalg::HashTableAnchor {
      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>         Link;
      <span class="keyword">typedef</span> <a class="code" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode&lt;KEY&gt;</a>    Node;
      <span class="keyword">typedef</span> <a class="code" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a>           Bucket;
      <span class="keyword">typedef</span> bslalg::BidirectionalLinkListUtil ListUtil;
      <span class="keyword">typedef</span> <a class="code" href="structbslalg_1_1HashTableImpUtil.html">bslalg::HashTableImpUtil</a>          ImpUtil;
      <span class="keyword">typedef</span> native_std::size_t                size_t;

      <span class="keyword">struct </span>Policy {
          <span class="keyword">typedef</span> KEY KeyType;
          <span class="keyword">typedef</span> KEY ValueType;

          <span class="keyword">static</span> <span class="keyword">const</span> KeyType&amp; extractKey(<span class="keyword">const</span> ValueType&amp; value)
          {
              <span class="keywordflow">return</span> value;
          }
      };

      <span class="comment">// DATA</span>
      <span class="keywordtype">double</span>            d_maxLoadFactor;
      <span class="keywordtype">unsigned</span>          d_numNodes;
      HASHER            d_hasher;
      EQUAL             d_equal;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;

      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> grow();
          <span class="comment">// Roughly double the number of buckets, such that the number of</span>
          <span class="comment">// buckets shall always be &#39;2^N - 1&#39;.</span>

      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keywordtype">bool</span> checkInvariants() <span class="keyword">const</span>;
          <span class="comment">// Perform sanity checks on this table, returning &#39;true&#39; if all the</span>
          <span class="comment">// tests pass and &#39;false&#39; otherwise.  Note that many of the checks</span>
          <span class="comment">// are done with the &#39;ASSERTV&#39; macro and will cause messages to be</span>
          <span class="comment">// written to the console.</span>

      Node* find(<span class="keyword">const</span> KEY&amp; key,
                 <span class="keywordtype">size_t</span>     hashCode) <span class="keyword">const</span>;
          <span class="comment">// Return a pointer to the node containing the specified &#39;key&#39;, and</span>
          <span class="comment">// 0 if no such node is in the table.</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      HashSet(<span class="keyword">const</span> HashSet&amp;, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *);
      HashSet&amp; operator=(<span class="keyword">const</span> HashSet&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span>
      HashSet(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0);
          <span class="comment">// Create a &#39;HashSet&#39;, using the specified &#39;allocator&#39;.  If no</span>
          <span class="comment">// allocator is specified, use the default allocator.</span>

      ~HashSet();
          <span class="comment">// Destroy this &#39;HashSet&#39;, freeing all its memory.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">bool</span> insert(<span class="keyword">const</span> KEY&amp; key);
          <span class="comment">// If the specfied &#39;key&#39; is not in this hash table, add it,</span>
          <span class="comment">// returning &#39;true&#39;.  If it is already in the table, return &#39;false&#39;</span>
          <span class="comment">// with no action taken.</span>

      <span class="keywordtype">bool</span> erase(<span class="keyword">const</span> KEY&amp; key);
          <span class="comment">// If the specfied &#39;key&#39; is in this hash table, remove it,</span>
          <span class="comment">// returning &#39;true&#39;.  If it is not found in the table, return</span>
          <span class="comment">// &#39;false&#39; with no action taken.</span>

      <span class="comment">// ACCESSORS</span>
      native_std::size_t count(<span class="keyword">const</span> KEY&amp; key) <span class="keyword">const</span>;
          <span class="comment">// Return 1 if the specified &#39;key&#39; is in this table and 0</span>
          <span class="comment">// otherwise.</span>

      native_std::size_t size() <span class="keyword">const</span>;
          <span class="comment">// Return the number of discrete keys that are stored in this</span>
          <span class="comment">// table.</span>
  };

  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  <span class="keywordtype">void</span> HashSet&lt;KEY, HASHER, EQUAL&gt;::grow()
  {
      <span class="comment">// &#39;bucketArraySize&#39; will always be &#39;2^N - 1&#39;, so that if hashed values</span>
      <span class="comment">// are aligned by some 2^N they&#39;re likely to be relatively prime to the</span>
      <span class="comment">// length of the hash table.</span>

      d_allocator_p-&gt;deallocate(bucketArrayAddress());
      <span class="keywordtype">size_t</span> newBucketArraySize = bucketArraySize() * 2 + 1;
      setBucketArrayAddressAndSize((Bucket *) d_allocator_p-&gt;allocate(
                                        newBucketArraySize * <span class="keyword">sizeof</span>(Bucket)),
                                        newBucketArraySize);

      ImpUtil::rehash&lt;Policy, HASHER&gt;(<span class="keyword">this</span>,
                                      listRootAddress(),
                                      d_hasher);
  }

  <span class="comment">// PRIVATE ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  <span class="keywordtype">bool</span> HashSet&lt;KEY, HASHER, EQUAL&gt;::checkInvariants()<span class="keyword"> const</span>
<span class="keyword">  </span>{
</pre></div><br/>
<br/>
 <code>HashTableImpUtil</code>s <code>isWellFormed</code> will verify that all nodes are in their proper buckets, that there are no buckets containing nodes that are not in the main linked list, and no nodes in the main linked list that are not in buckets. To verify that <code>d_numNodes</code> is correct we have to traverse the list and count the nodes ourselves. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">size_t</span> numNodes = 0;
      <span class="keywordflow">for</span> (BidirectionalLink *cursor = listRootAddress;
                                       cursor; cursor = cursor-&gt;nextLink()) {
          ++numNodes;
      }

      <span class="keywordflow">return</span> size() == numNodes &amp;&amp;
                  ImpUtil::isWellFormed&lt;Policy, HASHER&gt;(<span class="keyword">this</span>, d_allocator_p);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  <a class="code" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode&lt;KEY&gt;</a> *HashSet&lt;KEY, HASHER, EQUAL&gt;::find(
                                           <span class="keyword">const</span> KEY&amp;         key,
                                           native_std::size_t hashCode)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> (Node *) ImpUtil::find&lt;Policy, EQUAL&gt;(*<span class="keyword">this</span>,
                                                   key,
                                                   d_equal,
                                                   hashCode);
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  HashSet&lt;KEY, HASHER, EQUAL&gt;::HashSet(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
  : HashTableAnchor(0, 0, 0)
  , d_maxLoadFactor(0.4)
  , d_numNodes(0)
  {
      <span class="keyword">enum</span> { NUM_BUCKETS = 3 };    <span class="comment">// &#39;NUM_BUCKETS&#39; must be &#39;2^N - 1&#39; for</span>
                                   <span class="comment">// some &#39;N&#39;.</span>

      d_allocator_p = <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(allocator);
      native_std::size_t bucketArraySizeInBytes =
                                                NUM_BUCKETS * <span class="keyword">sizeof</span>(Bucket);
      setBucketArrayAddressAndSize(
                  (Bucket *) d_allocator_p-&gt;allocate(bucketArraySizeInBytes),
                  NUM_BUCKETS);
      memset(bucketArrayAddress(), 0, bucketArraySizeInBytes);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  HashSet&lt;KEY, HASHER, EQUAL&gt;::~HashSet()
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(checkInvariants());

      <span class="keywordflow">for</span> (Link *link = listRootAddress(); link; ) {
          Node *toDelete = (Node *) link;
          link = link-&gt;nextLink();

          toDelete-&gt;value().~KEY();
          d_allocator_p-&gt;deallocate(toDelete);
      }

      d_allocator_p-&gt;deallocate(bucketArrayAddress());
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  <span class="keywordtype">bool</span> HashSet&lt;KEY, HASHER, EQUAL&gt;::erase(<span class="keyword">const</span> KEY&amp; key)
  {
      <span class="keywordtype">size_t</span> hashCode = d_hasher(key);
      Node *node = find(key, hashCode);

      <span class="keywordflow">if</span> (!node) {
          <span class="keywordflow">return</span> <span class="keyword">false</span>;                                             <span class="comment">// RETURN</span>
      }

      <span class="keywordtype">size_t</span> bucketIdx = ImpUtil::computeBucketIndex(hashCode,
                                                     bucketArraySize());
      Bucket&amp; bucket = bucketArrayAddress()[bucketIdx];

      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(bucket.first() &amp;&amp; bucket.last());

      <span class="keywordflow">if</span> (bucket.first() == node) {
          <span class="keywordflow">if</span> (bucket.last() == node) {
              bucket.reset();
          }
          <span class="keywordflow">else</span> {
              bucket.setFirst(node-&gt;nextLink());
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bucket.last() == node) {
          bucket.setLast(node-&gt;previousLink());
      }

      <span class="keywordflow">if</span> (listRootAddress() == node) {
          setListRootAddress(node-&gt;nextLink());
      }

      ListUtil::unlink(node);

      node-&gt;value().~KEY();
      d_allocator_p-&gt;deallocate(node);

      --d_numNodes;
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(checkInvariants());

      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  <span class="keywordtype">bool</span> HashSet&lt;KEY, HASHER, EQUAL&gt;::insert(<span class="keyword">const</span> KEY&amp; key)
  {
      <span class="keywordtype">size_t</span> hashCode = d_hasher(key);

      <span class="keywordflow">if</span> (find(key, hashCode)) {
          <span class="comment">// Already in set, do nothing.</span>

          <span class="keywordflow">return</span> <span class="keyword">false</span>;                                             <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">if</span> (bucketArraySize() * d_maxLoadFactor &lt; d_numNodes + 1) {
          grow();
      }

      ++d_numNodes;
      Node *node = (Node *) d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span>(Node));
      <a class="code" href="structbslalg_1_1ScalarPrimitives.html#a673fd4b551f4e1595cfb0b0da6b75c4f">bslalg::ScalarPrimitives::copyConstruct</a>(&amp;node-&gt;value(),
                                              key,
                                              d_allocator_p);

      ImpUtil::insertAtBackOfBucket(<span class="keyword">this</span>, node, hashCode);

      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(find(key, hashCode));
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(checkInvariants());

      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  native_std::size_t HashSet&lt;KEY, HASHER, EQUAL&gt;::count(<span class="keyword">const</span> KEY&amp; key)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> 0 != find(key, d_hasher(key));
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> KEY, <span class="keyword">class</span> HASHER, <span class="keyword">class</span> EQUAL&gt;
  native_std::size_t HashSet&lt;KEY, HASHER, EQUAL&gt;::size()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_numNodes;
  }
</pre></div><br/>
<br/>
 Then, we customize our table to manipulate zero-terminated <code>const char *</code> strings. We make the simplifying assumption that the strings pointed at by the <code>const char *</code>s are longer-lived that the <code>HashSet</code> will be. We must provide an equality comparator so that two copies, in different locations, of the same sequence of characters will evaluate equal: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>StringEqual {
      <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *lhs, <span class="keyword">const</span> <span class="keywordtype">char</span> *rhs)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">return</span> !strcmp(lhs, rhs);
      }
  };
</pre></div><br/>
<br/>
 Next, we must provide a string hash function to convert a <code>const char *</code> to a <code>size_t</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>StringHash {
      native_std::size_t operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>) <span class="keyword">const</span>;
  };

  native_std::size_t StringHash::operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keyword">enum</span> { BITS_IN_SIZE_T = <span class="keyword">sizeof</span>(size_t) * 8 };

      native_std::size_t result = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> shift = 0; *string;
                            ++string, shift = (shift + 7) % BITS_IN_SIZE_T) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = *string;
          <span class="keywordflow">if</span> (shift &lt;= BITS_IN_SIZE_T - 8) {
              result += c &lt;&lt; shift;
          }
          <span class="keywordflow">else</span> {
              result += c &lt;&lt; shift;
              result += c &gt;&gt; (BITS_IN_SIZE_T - shift);
          }
      }

      <span class="keywordflow">return</span> result;
  };
</pre></div><br/>
<br/>
 Then, we declare a couple of <code>TestAllocator</code>s to use during our example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> da(<span class="stringliteral">&quot;defaultAllocator&quot;</span>);
  <a class="code" href="classbslma_1_1DefaultAllocatorGuard.html">bslma::DefaultAllocatorGuard</a> defaultGuard(&amp;da);

  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> ta(<span class="stringliteral">&quot;testAllocator&quot;</span>);
</pre></div><br/>
<br/>
 Next, in <code>main</code>, we create an instance of our <code>HashSet</code> type, configured to contain <code>const char *</code> strings: <br/>
<br/>
<div class="fragment"><pre class="fragment">  HashSet&lt;const char *, StringHash, StringEqual&gt; hs(&amp;ta);
</pre></div><br/>
<br/>
 Then, we insert a few values: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(1 == hs.insert(<span class="stringliteral">&quot;woof&quot;</span>));
  assert(1 == hs.insert(<span class="stringliteral">&quot;arf&quot;</span>));
  assert(1 == hs.insert(<span class="stringliteral">&quot;meow&quot;</span>));
</pre></div><br/>
<br/>
 Next, we attempt to insert a redundant value, and observe that the <code>insert</code> method returns <code>false</code> to indicate that the insert was refused: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == hs.insert(<span class="stringliteral">&quot;woof&quot;</span>));
</pre></div><br/>
<br/>
 Then, we use to <code>size</code> method to observe that there are 3 strings stored in our <code>HashSet</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(3 == hs.size());
</pre></div><br/>
<br/>
 Next, we use the <code>count</code> method to observe, specifically, which strings are and are not in our <code>HashSet</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(1 == hs.count(<span class="stringliteral">&quot;woof&quot;</span>));
  assert(1 == hs.count(<span class="stringliteral">&quot;arf&quot;</span>));
  assert(1 == hs.count(<span class="stringliteral">&quot;meow&quot;</span>));
  assert(0 == hs.count(<span class="stringliteral">&quot;ruff&quot;</span>));
  assert(0 == hs.count(<span class="stringliteral">&quot;chomp&quot;</span>));
</pre></div><br/>
<br/>
 Then, we attempt to erase a string which is not in our <code>HashSet</code> and observe that <code>false</code> is returned, which tells us the <code>erase</code> attempt was unsuccessful: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == hs.erase(<span class="stringliteral">&quot;ruff&quot;</span>));
</pre></div><br/>
<br/>
 Next, we erase the string "meow", which is stored in our <code>HashSet</code> and observe that <code>true</code> is returned, telling us the <code>erase</code> attempt succeeded: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(1 == hs.erase(<span class="stringliteral">&quot;meow&quot;</span>));
</pre></div><br/>
<br/>
 Now, we use the <code>size</code> method to verify there are 2 strings remaining in our <code>HashSet</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(2 == hs.size());
</pre></div><br/>
<br/>
 Finally, we use the <code>count</code> method to observe specifically which strings are still in our <code>HashSet</code>. Note that "meow" is no longer there. We observe that the default allocator was never used. When we leave the block, our <code>HashSet</code> will be destroyed, freeing its memory, then our <code>TestAllocator</code> will be destroyed, verifying that our destructor worked correctly and that no memory was leaked: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(1 == hs.count(<span class="stringliteral">&quot;woof&quot;</span>));
  assert(1 == hs.count(<span class="stringliteral">&quot;arf&quot;</span>));
  assert(0 == hs.count(<span class="stringliteral">&quot;meow&quot;</span>));
  assert(0 == hs.count(<span class="stringliteral">&quot;ruff&quot;</span>));
  assert(0 == hs.count(<span class="stringliteral">&quot;chomp&quot;</span>));

  assert(0 == da.numAllocations());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
