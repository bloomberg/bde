<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmf_nestedtraitdeclaration.h                                     -*-C++-*-
#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#define INCLUDED_BSLMF_NESTEDTRAITDECLARATION

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a nested declaration to associate a class with a trait.
//
//@MACROS:
//  BSLMF_NESTED_TRAIT_DECLARATION: macro that associates a trait with a class
//  BSLMF_NESTED_TRAIT_DECLARATION_IF: conditional macro to associates a trait
//
//@SEE_ALSO: bslmf_detectnestedtrait
//
//@DESCRIPTION: This component defines a pair of macros,
// &#39;BSLMF_NESTED_TRAIT_DECLARATION&#39; and &#39;BSLMF_NESTED_TRAIT_DECLARATION_IF&#39;,
// that can be used in association with the facilities provided by
// &#39;bslmf_detectnestedtrait&#39; to declare that a given class has a given trait.
//
// Traits provide a mechanism for convenient compile-time discovery of
// information about a class, which is useful in particular for providing
// efficient specializations of generalized containers and algorithms without
// having to rely on knowledge of specific target classes.
//
// The primary public interface of this component consists of two macros that
// provide a facility for declaring that a given class has a given trait.
// These macros embed the association between the type and the trait inside the
// class definition itself, hence the term &quot;nested trait declaration&quot;.
//
// Note that the term &quot;nested&quot; is not meant to imply that this facility
// declares a nested type within the class namespace, only that the trait
// declaration appears as one of the public declarations that make up the class
// definition.  For example, we could declare that a class, &#39;xyza::Foo&#39;, has
// the trait &#39;abcd::BarTrait&#39; in the following way:
//..
//  namespace xyza {
//
//  class Foo {
//      // ... various implementation details ...
//
//    public:
//      // TRAITS
//      BSLMF_NESTED_TRAIT_DECLARATION(Foo, abcd::BarTrait);
//
//      // ... the rest of the public interface ...
//  };
//
//  }  // close namespace xyza
//..
// Two flavors of macro are provided: one for declaring unconditionally that a
// class has a trait, and another for declaring that the class has a trait if
// and only if a given compile-time expression evaluates to &#39;true&#39;.
//
///Relationship with &quot;C++11-style&quot; Type Traits
///-------------------------------------------
// Traits declared using this component are not automatically compatible
// mechanisms designed to detect &quot;C++11-style&quot; traits.  For a full discussion
// of the relationship between nested traits and &quot;C++11-style&quot; traits, as well
// as best practices for defining, associating, and detecting traits, see the
// component documentation for &#39;bslmf_detectnestedtrait&#39;.
//
///Usage
///-----
// This section illustrates the intended use of this component.
//
///Example 1: Testing a Type for a Custom Trait
/// - - - - - - - - - - - - - - - - - - - - - -
// When writing generic infrastructure code, we often need to choose among
// multiple code paths based on the capabilities of the types on which we are
// operating.  If those capabilities are reflected in a type&#39;s public
// interface, we may be able to use techniques such as SFINAE to choose the
// appropriate code path.  However, SFINAE cannot detect all of a type&#39;s
// capabilities.  In particular, SFINAE cannot detect constructors, memory
// allocation, thread-safety characteristics, and so on.  Functions that depend
// on these capabilities must use another technique to determine the correct
// code path to use for a given type.  We can solve this sort of problem by
// associating types with custom traits that indicate what capabilities are
// provided by a given type.
//
// First, assume that a compatible trait, &#39;abcd::RequiresLockTrait&#39;, has been
// defined that indicates that a type&#39;s methods must not be called unless a
// known lock is first acquired:
//..
//  namespace abcd { template &lt;class TYPE&gt; struct RequiresLockTrait; }
//..
// The implementation of &#39;abcd::RequiresLockTrait&#39; is not shown.
//
// Then, in package &#39;xyza&#39;, we declare a type, &#39;DoesNotRequireLockType&#39;, that
// can be used without acquiring the lock:
//..
//  namespace xyza {
//
//  class DoesNotRequireLockType {
//      // ...
//
//    public:
//      // CREATORS
//      DoesNotRequireLockType();
//          // ...
//  };
//..
// Next, we declare a type, &#39;RequiresLockType&#39;, that does require the lock.  We
// use the &#39;BSLMF_NESTED_TRAIT_DECLARATION&#39; macro to associate the type with
// the &#39;abcd::RequiresLockTrait&#39; trait:
//..
//  class RequiresLockType {
//      // ...
//
//    public:
//      // TRAITS
//      BSLMF_NESTED_TRAIT_DECLARATION(RequiresLockType,
//                                     abcd::RequiresLockTrait);
//
//      // CREATORS
//      RequiresLockType();
//          // ...
//
//  };
//..
// Notice that the macro declaration is performed within the scope of the class
// declaration, and must be done with public scope.
//
// Now, we declare a templatized container type, &#39;Container&#39;, that is
// parameterized on some &#39;ELEMENT&#39; type.  If &#39;ELEMENT&#39; requires a lock, then a
// &#39;Container&#39; of &#39;ELEMENT&#39;s will require a lock as well.  This can be
// expressed using the &#39;BSLMF_NESTED_TRAIT_DECLARATION_IF&#39; macro, by providing
// &#39;abcd::RequiresLockTrait&lt;ELEMENT&gt;::value&#39; as the condition for associating
// the trait with &#39;Container&#39;.
//..
//  template &lt;class ELEMENT&gt;
//  struct Container {
//      // ...
//
//    public:
//      // TRAITS
//      BSLMF_NESTED_TRAIT_DECLARATION_IF(Container, abcd::RequiresLockTrait,
//                                    abcd::RequiresLockTrait&lt;ELEMENT&gt;::value);
//
//      // ...
//  };
//
//  } // close package namespace
//..
// Finally, code interacting with &#39;xyza::DoesNotRequireLockType&#39;,
// &#39;xyza::RequiresLockType&#39; or &#39;xyza::Container&#39; objects will be able to choose
// the appropriate code path by checking for the &#39;abcd::RequiresLockTrait&#39;
// trait.  See &#39;bslmf_detectnestedtrait&#39; for an example of how generic code
// would use such a trait.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

namespace BloombergLP {

namespace bslmf {

                        // ============================
                        // class NestedTraitDeclaration
                        // ============================

template &lt;class TYPE, template &lt;class T&gt; class TRAIT, bool COND = true&gt;
class NestedTraitDeclaration {
    // Class &#39;TYPE&#39; will be convertible to
    // &#39;NestedTraitDeclaration&lt;TYPE,TRAIT,true&gt;&#39; if &#39;TRAIT&#39; is associated with
    // &#39;TYPE&#39; using the &#39;BSLMF_NESTED_TRAIT_DECLARATION&#39; macro.  Nested trait
    // detection depends on &#39;COND&#39; being true.  If &#39;COND&#39; is false, the nested
    // trait detection will not see the conversion it is looking for and will
    // not associate &#39;TRAIT&#39; with &#39;TYPE&#39;.  This feature is used by
    // &#39;BSLMF_NESTED_TRAIT_DECLARATION_IF&#39; to turn a trait on or off depending
    // on a compile-time condition (usually another trait).

  public:
    // PUBLIC TYPES
    typedef NestedTraitDeclaration Type;

    // CREATORS
    //! NestedTraitDeclaration();
    //! NestedTraitDeclaration(const  NestedTraitDeclaration&amp;);
    //! NestedTraitDeclaration&amp; operator=(const  NestedTraitDeclaration&amp;);
    //! ~NestedTraitDeclaration();
};

                    // ====================================
                    // macro BSLMF_NESTED_TRAIT_DECLARATION
                    // ====================================

#define BSLMF_NESTED_TRAIT_DECLARATION(TYPE, TRAIT)                          \
    operator BloombergLP::bslmf::NestedTraitDeclaration&lt;TYPE, TRAIT&gt;() const \
    {                                                                        \
        return BloombergLP::bslmf::NestedTraitDeclaration&lt;TYPE, TRAIT&gt;();    \
    }                                                                        \

#ifdef __CDT_PARSER__
// Work around an Eclise CDT bug where it fails to parse the conditional trait
// declaration.  See internal DRQS 47839133.
#define BSLMF_NESTED_TRAIT_DECLARATION_IF(TYPE, TRAIT, COND)
#else
#define BSLMF_NESTED_TRAIT_DECLARATION_IF(TYPE, TRAIT, COND)                 \
    operator BloombergLP::bslmf::NestedTraitDeclaration&lt;TYPE, TRAIT,         \
                                                        COND &gt;() const       \
    {                                                                        \
        return                                                               \
            BloombergLP::bslmf::NestedTraitDeclaration&lt;TYPE, TRAIT, COND &gt;();\
    }
#endif

}  // close package namespace

}  // close enterprise namespace

#endif // ! defined(INCLUDED_BSLMF_NESTEDTRAITDECLARATION)

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
