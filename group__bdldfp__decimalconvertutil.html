<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdldfp_decimalconvertutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdldfp_decimalconvertutil<br/>
<small>
[<a class="el" href="group__bdldfp.html">Package bdldfp</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide decimal floating-point conversion functions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdldfp.html">bdldfp</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Encoding Formats</a> <ul>
<li>
<a href="#3.1.1">IEEE Decimal Interchange Format</a> </li>
<li>
<a href="#3.1.2">Multi-Width Encoding Format</a> </li>
<li>
<a href="#3.1.3">Variable-Width Encoding Formats</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Sending Decimals As Octets Using Network Format</a> </li>
<li>
<a href="#3.2.2">Example 2: Storing/Sending Decimals In Binary Floating-Point</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide decimal floating-point conversion functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdldfp_1_1DecimalConvertUtil.html">bdldfp::DecimalConvertUtil</a> </td><td>Namespace for decimal FP conversion functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdldfp__decimal.html" title="Provide IEEE-754 decimal floating-point types.">Component bdldfp_decimal</a>, <a class="el" href="group__bdldfp__decimalplatform.html" title="Provide decimal floating-point platform information macros.">Component bdldfp_decimalplatform</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides namespace, <code><a class="el" href="structbdldfp_1_1DecimalConvertUtil.html">bdldfp::DecimalConvertUtil</a></code>, containing functions that are able to convert between the native decimal types of the platform and various other possible representations, such as binary floating-point, network encoding formats. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="encoding_formats"></a> <a class="anchor" id="description.encoding_formats"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Encoding Formats: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This utility contains functions to encode decimal values to and from three different encoding formats: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
the IEEE decimal interchange format using decimal encoding for the significant (also known as the Densely Packed Decimal format, see IEEE 754 - 2008, section 3.5.2, for more details)  </li>
<li>
the multi-width encoding format, which is a custom format that can encode subsets of decimal values using a smaller number of bytes  </li>
<li>
the variable-width encoding format, which is a custom format that is similar to the multi-width encoding format with the main difference being that it self describes its own width  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>64-bit decimal values encoded by the IEEE decimal interchange format always uses 8 bytes, which can be inefficient. The two custom encoding formats provided by this to enable more space efficient encoding of values commonly encountered by financial applications. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the full IEEE encoding, 50 bits are used for the trailing bits of the mantissa, 13 bit is used for the combination field (exponent + special states to indicate NaN and Inf values + leading bits of the mantissa), and 1 bit is used for the significant. The basic idea for the custom encoding formats is that the mantissa and exponent of many values (in typical financial applications) can fit into fewer bits than those provided by the full encoding. We can define a set of narrow formats to encode these smaller values without loss of precision. For example, a ticker values less than 100 dollars with a 2 decimal places of precision can be encoded using a 2 bytes encoding, using no sign bit, 3 bits for the exponent, and 13 bits for the mantissa. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="ieee_decimal_interchange_format"></a> <a class="anchor" id="encoding_formats.ieee_decimal_interchange_format"></a> <a class="anchor" id="description.encoding_formats.ieee_decimal_interchange_format"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>IEEE Decimal Interchange Format: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The IEEE decimal interchange format is defined by the IEEE standard. 64 bit decimal values encoded by this format always uses 8 bytes. The <code>decimalFromNetwork</code> and <code>decimalToNetwork</code> functions can be used encode to and decode from this format. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="multi-width_encoding_format"></a> <a class="anchor" id="encoding_formats.multi-width_encoding_format"></a> <a class="anchor" id="description.encoding_formats.multi-width_encoding_format"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Multi-Width Encoding Format: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The multi-width encoding format uses a set of narrow encoding formats having sizes smaller than that used by the for IEEE format. Each of the narrower encoding format is used to encode a subset of values that can be represented by the full format. The following configuration is used to encode 64-bit decimal values: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment"> |------|----------|----------|-----|----------|----------------|
 | size | S (bits) | E (bits) |   B | T (bits) | max signficand |
 |------|----------|----------|-----|----------|----------------|
 |   1* |        0 |        1 |  -2 |        7 |            127 |
 |   2  |        0 |        2 |  -3 |       14 |          16383 |
 |   3  |        0 |        3 |  -6 |       21 |        2097151 |
 |   4  |        1 |        5 | -16 |       26 |       67108863 |
 |   5  |        1 |        5 | -16 |       34 |    17179869183 |
 |------|-------------------------------------------------------|
 |    8 |            FULL IEEE INTERCHANGE FORMAT**             |
 |------|-------------------------------------------------------|

 S = sign, E = exponent, B = bias, T = significant

 1 byte encoding will be supported by the decoder but not the encoder. This
   is done due to the relatively large performance impact of adding the 1
   byte encoding to the encoder (10%). Preserving the encoding size in the
   decoder allows us to easily enable <span class="keyword">this</span> encoding size at a later time.

 If the value to be encoded can not fit in the 5-byte encoding or is -Inf,
    +Inf, or Nan, then the full 8-byte IEEE format will be used.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since the multi-width encoding format consists of subformats having varying widths, the size of the subformat used must be supplied long with the encoding to the decode function. This is not required for either the IEEE format or the variable-width encoding format. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>decimal64ToMultiWidthEncoding</code> and <code>decimal64FromMultiWidthEncoding</code> can be used to encode to and decode from this format. Currently, only 64-bit decimal values are supported by this encoding format. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="variable-width_encoding_formats"></a> <a class="anchor" id="encoding_formats.variable-width_encoding_formats"></a> <a class="anchor" id="description.encoding_formats.variable-width_encoding_formats"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Variable-Width Encoding Formats: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The variable-width encoding format can encode decimal values using a variable number of bytes, similar to the multi-width encoding format. The difference is that the variable-width encoding format can self-describe its own size using special state (typically, predicate bits), so the decode function does not require the size of the encoding to work. The following configuration is used to encode 64-bit decimal values: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment"> |------|------------|---|---|-----|----|-----------------|
 | size |          <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a> | S | E |   B |  T | max significant |
 |------|------------|---|---|-----|----|-----------------|
 |    2 |        0b0 | 0 | 2 |  -2 | 13 |            8191 |
 |    3 |       0b10 | 0 | 3 |  -4 | 19 |          524287 |
 |    4 |       0b11 | 1 | 5 | -16 | 24 |        16777215 |
 |------|------------|------------------------------------|
 |    9 | 0b11111111 |        FULL IEEE FORMAT*           |
 |------|------------|------------------------------------|

 <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a> = predicate (bit values)
 S = sign (bits), E = exponent (bits), B = bias
 T = significant (bits)

 If the value to be encoded can not fit in the 4-byte encoding or is -Inf,
   +Inf, or Nan, then the full 8-byte IEEE format will be used prefixed by a
   1 byte predicate having the value of 0xFF.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>decimal64ToVariableWidthEncoding</code> and <code>decimal64FromVariableWidthEncoding</code> can be used to encode to and decode from this format. Currently, only 64-bit decimal values are supported by this encoding format. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section shows the intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_sending_decimals_as_octets_using_network_format"></a> <a class="anchor" id="usage.example_1~3A_sending_decimals_as_octets_using_network_format"></a> <a class="anchor" id="description.usage.example_1~3A_sending_decimals_as_octets_using_network_format"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Sending Decimals As Octets Using Network Format: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose you have two communicating entities (programs) that talk to each other using a binary (as opposed to text) protocol. In such protocol it is important to establish a so-called network format, and convert to and from that format in the protocol layer. The sender (suppose that it is an IBM server that has just finished an expensive calculation involving millions of numbers and needs to send the result to its client) will need to convert the data to network format before sending: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   msgbuffer[256];
  <a class="code" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">BDEC::Decimal64</a> number(<a class="code" href="bdldfp__decimal_8h.html#a81f966a197ae358644d447b8ff347cb4">BDLDFP_DECIMAL_DD</a>(1.234567890123456e-42));
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   expected[] = {
                            0x25, 0x55, 0x34, 0xb9, 0xc1, 0xe2, 0x8e, 0x56 };

  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *next = msgbuffer;
  next = <a class="code" href="structbdldfp_1_1DecimalConvertUtil.html#aed62605a2152dd64fb11ed8d76908b22">bdldfp::DecimalConvertUtil::decimalToNetwork</a>(next, number);

  assert(memcmp(msgbuffer, expected, <span class="keyword">sizeof</span>(number)) == 0);
</pre></div><br/>
<br/>
 The receiver/client shall then restore the number from network format: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   msgbuffer[] ={
                            0x25, 0x55, 0x34, 0xb9, 0xc1, 0xe2, 0x8e, 0x56 };
  <a class="code" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">BDEC::Decimal64</a> number;
  <a class="code" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">BDEC::Decimal64</a> expected(<a class="code" href="bdldfp__decimal_8h.html#a81f966a197ae358644d447b8ff347cb4">BDLDFP_DECIMAL_DD</a>(1.234567890123456e-42));

  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *next = msgbuffer;
  next = <a class="code" href="structbdldfp_1_1DecimalConvertUtil.html#a22eacf8383f3f9e3ece16cebe415ed56">bdldfp::DecimalConvertUtil::decimalFromNetwork</a>(number, next);

  assert(number == expected);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_storing~2Fsending_decimals_in_binary_floating-point"></a> <a class="anchor" id="usage.example_2~3A_storing~2Fsending_decimals_in_binary_floating-point"></a> <a class="anchor" id="description.usage.example_2~3A_storing~2Fsending_decimals_in_binary_floating-point"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Storing/Sending Decimals In Binary Floating-Point: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose you have two communicating entities (programs) that talk to each other using a legacy protocol that employs binary floating-point formats to send/receive numbers. So your application layer will have to store the decimal into a binary FP variable, ensure that it can be restored (in other words that it has "fit" into the binary type) when sending, and restore the decimal number (from the binary type) when receiving: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">BDEC::Decimal64</a> number(<a class="code" href="bdldfp__decimal_8h.html#a81f966a197ae358644d447b8ff347cb4">BDLDFP_DECIMAL_DD</a>(1.23456789012345e-42));

  <span class="keyword">typedef</span> <a class="code" href="structbdldfp_1_1DecimalConvertUtil.html">bdldfp::DecimalConvertUtil</a> Util;
  <span class="keywordtype">double</span> dbl = Util::decimalToDouble(number);

  <span class="keywordflow">if</span> (Util::decimal64FromDouble(dbl) != number) {
 Do what is appropriate <span class="keywordflow">for</span> the application
  }
</pre></div><br/>
<br/>
 Note that the above assert would probably be a lot more complicated if statement in production code. It may actually be acceptable to put the decimal onto the wire with certain amount of imprecision. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The receiver would then restore the number using the appropriate <code>decimal64FromDouble</code> function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="namespacebdldfp.html#a5f13b247a3f13e3bffda9cfe51ee5845">BDEC::Decimal64</a> restored = Util::decimal64FromDouble(dbl);

  assert(number == restored);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
