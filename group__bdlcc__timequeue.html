<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlcc_timequeue Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlcc_timequeue<br/>
<small>
[<a class="el" href="group__bdlcc.html">Package bdlcc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an efficient queue for time events.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlcc.html">bdlcc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
&nbsp; <ul>
<li>
<a href="#3.0.1"><code>bdlcc::TimeQueue::Handle</code> Uniqueness, Reuse and <code>numIndexBits</code></a> </li>
<li>
<a href="#3.0.2">Thread Safety</a> </li>
</ul>
</li>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Forward Declarations</a> </li>
<li>
<a href="#3.1.2"><code>struct my_Connection</code></a> </li>
<li>
<a href="#3.1.3">Protocol Classes</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an efficient queue for time events. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a> </td><td>Templatized time event queue  </td></tr>
<tr>
<td><a class="el" href="classbdlcc_1_1TimeQueueItem.html">bdlcc::TimeQueueItem</a> </td><td>(<code>struct</code>) Templatized item in the time event queue  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-safe and efficient templatized time queue. The queue stores an ordered list of time values and associated <code>DATA</code>. Each item added to the queue is assigned a unique identifier that can be used to efficiently remove the item making this queue suitable for conditions where time items are added and removed very frequently. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Class <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt;DATA&gt;</code> provides a public interface which is similar in structure and intent to <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt;DATA&gt;</code>, with the exception that each item stored in the <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> is of type <code><a class="el" href="classbdlcc_1_1TimeQueueItem.html">bdlcc::TimeQueueItem</a>&lt;DATA&gt;</code>. This structure contains a single <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code> value along with the <code>DATA</code> value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Idiomatic usage of <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> includes the member function <code>popLE</code>, which finds all items on the queue whose <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code> are less than a specified value, and transfers those items to a provided vector of items. Through the use of this member function, clients can retrieve and process multiple elements that have expired, that is, whose <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code> values are in the past. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> also makes use of an opaque data type <code><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">bdlcc::TimeQueue::Handle</a></code> which serves to identify an individual element on the Time Queue. A value of type <code>Handle</code> is returned from the <code>add</code> member function, and can then be used to remove or modify the corresponding element on the queue. In this way, the <code>update</code> member function can update the time value for a specific <code><a class="el" href="classbdlcc_1_1TimeQueueItem.html">bdlcc::TimeQueueItem</a></code> without removing it from the queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bdlcc~3A~3Atimequeue~3A~3Ahandle_uniqueness,_reuse_and_numindexbits"></a> <a class="anchor" id=".bdlcc~3A~3Atimequeue~3A~3Ahandle_uniqueness,_reuse_and_numindexbits"></a> <a class="anchor" id="description..bdlcc~3A~3Atimequeue~3A~3Ahandle_uniqueness,_reuse_and_numindexbits"></a> <a class="anchor" id="bdlcc"></a> <a class="anchor" id=".bdlcc"></a> <a class="anchor" id="description..bdlcc"></a> <a class="anchor" id="3.0.1"></a> </dd></dl>
<dl class="user"><dt><b>bdlcc::TimeQueue::Handle Uniqueness, Reuse and numIndexBits: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">bdlcc::TimeQueue::Handle</a></code> is an alias for a 32-bit <code>int</code> type. A handle consists of two parts, the "index section" and the "iteration section". The index section, which is the low-order <code>numIndexBits</code> (which defaults to <code>numIndexBits == 17</code>), uniquely identifies the node. Once a node is added, it never ceases to exist - it may be freed, but it will be kept on a free list to be eventually recycled, and the same index section will always identify that node. The iteration section, the high-order <code>32 - numIndexBits</code>, is changed every time a node is freed, so that an out-of-date handle can be identified as out-of-date. But since the iteration section has only a finite number of bits, if a node is freed and re-added enough times, old handle values will eventually be reused. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Up to <code>2 ** numIndexBits - 1</code> nodes can exist in a given time queue. A given handle won't be reused for a node until that node has been freed and reused <code>2 ** (32 - numIndexBits) - 1</code> times. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>numIndexBits</code> is an optional parameter to the time queue constructors. If unspecified, it has a value of 17. The behavior is undefined unless the specified <code>numIndexBits</code> is in the range <code>8 &lt;= numIndexBits &lt;= 24</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id=".thread_safety"></a> <a class="anchor" id="description..thread_safety"></a> <a class="anchor" id="3.0.2"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access or modify two distinct <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> objects simultaneously, each from a separate thread. It is safe to access or modify a single <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> object simultaneously from two or more separate threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to enqueue objects in a <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> object whose destructor may access or even modify the same <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> object. However, there is no guarantee regarding the safety of enqueuing objects whose copy constructors or assignment operators may modify or even merely access the same <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> object (except <code>length</code>). Such attempts generally lead to a deadlock. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following shows a typical usage of the <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> class, implementing a simple threaded server <code>my_Server</code> that manages individual Connections (<code>my_Connection</code>) on behalf of multiple Sessions (<code>my_Session</code>). Each Connection is timed, such that input requests on that Connection will "time out" after a user-specified time interval. When a specific Connection times out, that Connection is removed from the <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> and the corresponding <code>my_Session</code> is informed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this simplified example, class <code>my_Session</code> will terminate when its Connection times out. A more sophisticated implementation of <code>my_Session</code> would attempt recovery, perhaps by closing and reopening the physical Connection. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="forward_declarations"></a> <a class="anchor" id="usage.forward_declarations"></a> <a class="anchor" id="description.usage.forward_declarations"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Forward Declarations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Class <code>my_Server</code> will spawn two service threads to monitor connections for available data and to manage time-outs, respectively. Two forward-declared "C" functions are invoked as the threads are spawned. The signature of each function follows the "C" standard "'void *'" interface for spawning threads. Each function will be called on a new thread when the <code>start</code> method is invoked for a given <code>my_Server</code> object. Each function then delegates processing for the thread back to the <code>my_Server</code> object that spawned it. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {

  <span class="keywordtype">void</span> *my_connectionMonitorThreadEntry(<span class="keywordtype">void</span> *server);

  <span class="keywordtype">void</span> *my_timerMonitorThreadEntry(<span class="keywordtype">void</span> *server);

  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="struct_my_connection"></a> <a class="anchor" id="usage.struct_my_connection"></a> <a class="anchor" id="description.usage.struct_my_connection"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>struct my_Connection: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>my_Connection</code> structure is used by <code>my_Server</code> to manage a single physical connection on behalf of a <code>my_Session</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Session;
  <span class="keyword">struct </span>my_Connection {
      <span class="keywordtype">int</span>         d_timerId;
      my_Session *d_session_p;
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="protocol_classes"></a> <a class="anchor" id="usage.protocol_classes"></a> <a class="anchor" id="description.usage.protocol_classes"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Protocol Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Protocol class <code>my_Session</code> provides a pure abstract protocol to manage a single "session" to be associated with a specific connection on a server. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Session {
      <span class="comment">// Pure protocol class to process a data buffer of arbitrary size.</span>
      <span class="comment">// Concrete implementations in the &quot;real world&quot; would typically manage</span>
      <span class="comment">// an external connection like a socket.</span>

    <span class="keyword">public</span>:
      my_Session();
      <span class="keyword">virtual</span> <span class="keywordtype">int</span> processData(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> length) = 0;
      <span class="keyword">virtual</span> <span class="keywordtype">int</span> handleTimeout(my_Connection *connection) = 0;
      <span class="keyword">virtual</span> ~my_Session();
  };
</pre></div><br/>
<br/>
 The constructor and destructor do nothing: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_Session::my_Session()
  {
  }

  my_Session::~my_Session()
  {
  }
</pre></div><br/>
<br/>
 Protocol class <code>my_Server</code> provides a partial implementation of a simple server that supports and monitors an arbitrary number of connections and handles incoming data for those connections. Clients must provide a concrete implementation that binds connections to concrete <code>my_Session</code> objects and monitors all open connections for incoming requests. The concrete implementation calls <code>my_Server::newConnection()</code> when a new connections is required, and implements the virtual function <code>monitorConnections</code> to monitor all open connections. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Server {
      <span class="comment">// Simple server supporting multiple Connections.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;my_Connection*&gt;</a>      d_connections;
      <a class="code" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue&lt;my_Connection*&gt;</a> d_timeQueue;
      <span class="keywordtype">int</span>                              d_ioTimeout;
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>                     d_timerMonitorMutex;
      <a class="code" href="classbslmt_1_1Condition.html">bslmt::Condition</a>                 d_timerChangedCond;
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a>        d_connectionThreadHandle;
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a>        d_timerThreadHandle;
      <span class="keyword">volatile</span> <span class="keywordtype">bool</span>                    d_done;

    <span class="keyword">protected</span>:
      <span class="keywordtype">void</span> newConnection(my_Connection *connection);
          <span class="comment">// Add the specified &#39;connection&#39; to the current &#39;my_Server&#39;,</span>
          <span class="comment">// setting the new timeout value to the current time plus the</span>
          <span class="comment">// timeout value provided at construction of this &#39;my_Server&#39;</span>
          <span class="comment">// instance.  If the added connection is the new &quot;top&quot; of the</span>
          <span class="comment">// queue, signal that the minimum time on the queue has changed.</span>
          <span class="comment">// Upon seeing this signal, the TimerMonitor thread will wake up</span>
          <span class="comment">// and look for expired timers.</span>
          <span class="comment">//</span>
          <span class="comment">// Behavior is undefined if &#39;connection&#39; has already been added to</span>
          <span class="comment">// any &#39;my_Server&#39; and has not been removed via member function</span>
          <span class="comment">// &#39;closeConnection&#39;.</span>

      <span class="keywordtype">void</span> removeConnection(my_Connection *connection);
          <span class="comment">// Remove the specified &#39;connection&#39; from the current &#39;my_Server&#39;,</span>
          <span class="comment">// so that it will no longer be monitored for available data.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> closeConnection(my_Connection *connection)=0;
          <span class="comment">// Provide a mechanism for a concrete implementation to close a</span>
          <span class="comment">// specified &#39;connection&#39;.</span>

      <span class="keywordtype">void</span> dataAvailable(my_Connection *connection,
                         <span class="keywordtype">void</span>          *buffer_p,
                         <span class="keywordtype">int</span>            length);
          <span class="comment">// Receive in the specified &#39;buffer_p&#39; a pointer to a data buffer</span>
          <span class="comment">// of the specified &#39;length&#39; bytes, and pass this to the specified</span>
          <span class="comment">// &#39;connection&#39; to be processed.  Behavior is undefined if</span>
          <span class="comment">// &#39;connection&#39; is not currently added to this &#39;my_Server&#39; object,</span>
          <span class="comment">// or if &#39;length&#39; &lt;= 0.</span>

    <span class="keyword">protected</span>:
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> monitorConnections()=0;
          <span class="comment">// Monitor all connections in the current &#39;my_Server&#39;.  When data</span>
          <span class="comment">// becomes available for a given connection, pass the data to that</span>
          <span class="comment">// connection for processing.</span>

      <span class="keywordtype">void</span> monitorTimers();
          <span class="comment">// Monitor all timers in the current &#39;my_Server&#39;, and handle each</span>
          <span class="comment">// timer as it expires.</span>

      <span class="keyword">friend</span> <span class="keywordtype">void</span> *my_connectionMonitorThreadEntry(<span class="keywordtype">void</span> *server);
      <span class="keyword">friend</span> <span class="keywordtype">void</span> *my_timerMonitorThreadEntry(<span class="keywordtype">void</span> *server);

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_Server(<span class="keyword">const</span> my_Server&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span>
      my_Server(<span class="keywordtype">int</span> ioTimeout, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Construct a &#39;my_Server&#39; object with a timeout value of the</span>
          <span class="comment">// specified &#39;ioTimeout&#39; seconds.  Use the optionally specified</span>
          <span class="comment">// &#39;basicAllocator&#39; for all memory allocation for data members of</span>
          <span class="comment">// &#39;my_Server&#39;.</span>

      <span class="keyword">virtual</span> ~my_Server();

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> start();
          <span class="comment">// Begin monitoring timers and connections.</span>
  };
</pre></div><br/>
<br/>
 The constructor is simple: it initializes the internal <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code> and sets the I/O timeout value. The virtual destructor does nothing. <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_Server::my_Server(<span class="keywordtype">int</span> ioTimeout, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_timeQueue(basicAllocator)
  , d_ioTimeout(ioTimeout)
  , d_connectionThreadHandle(bslmt::ThreadUtil::invalidHandle())
  , d_timerThreadHandle(bslmt::ThreadUtil::invalidHandle())
  {
  }

  my_Server::~my_Server()
  {
      d_done = <span class="keyword">true</span>;
      d_timerChangedCond.broadcast();
      <span class="keywordflow">if</span> (<a class="code" href="structbslmt_1_1ThreadUtil.html#a6ac8cf16bde241bc72c8ed38c3f0364f">bslmt::ThreadUtil::invalidHandle</a>() != d_connectionThreadHandle) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(d_connectionThreadHandle);
      }
      <span class="keywordflow">if</span> (<a class="code" href="structbslmt_1_1ThreadUtil.html#a6ac8cf16bde241bc72c8ed38c3f0364f">bslmt::ThreadUtil::invalidHandle</a>()!= d_timerThreadHandle) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(d_timerThreadHandle);
      }
  }
</pre></div><br/>
<br/>
 Member function <code>newConnection</code> adds the <code>connection</code> to the current set of connections to be monitored. This is done in two steps. First, the <code>connection</code> is added to the internal array, and then a timer is set for the <code>connection</code> by creating a corresponding entry in the internal <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_Server::newConnection(my_Connection *connection)
  {
      d_connections.push_back(connection);
      <span class="keywordtype">int</span> isNewTop = 0;
      connection-&gt;d_timerId = d_timeQueue.add(<a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() +
                                                                 d_ioTimeout,
                                              connection,
                                              &amp;isNewTop);
      <span class="keywordflow">if</span> (isNewTop) {
          <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> lock(&amp;d_timerMonitorMutex);
          d_timerChangedCond.signal();
      }
  }
</pre></div><br/>
<br/>
 Member function <code>monitorConnections</code>, provided by the concrete implementation class, can use the internal array to determine the set of connections to be monitored. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Member function <code>removeConnection</code> removes the <code>connection</code> from the current set of connections to be monitored. This is done in two steps, in reversed order from <code>newConnection</code>. First, the <code>connection</code> is removed from the internal <code><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a></code>, and then the <code>connection</code> is removed from the internal array. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The concrete implementation class must provide an implementation of virtual function <code>closeConnection</code>; this implementation must call <code>removeConnection</code> when the actual connection is to be removed from the <code>my_Server</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Function <code>closeConnection</code> is in turn called by function <code>monitorTimers</code>, which manages the overall timer monitor thread. Because <code>monitorTimers</code> takes responsibility for notifying other threads when the queue status changes, function <code>removeConnection</code> does not address these concerns. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_Server::removeConnection(my_Connection *connection)
  {
      <span class="comment">// Remove from d_timeQueue</span>
      d_timeQueue.remove(connection-&gt;d_timerId);
      <span class="comment">// Remove from d_connections</span>
      <a class="code" href="group__bslstl__vector.html#ga24d7c145ce94bf2f3ae8068569c143b8">bsl::vector&lt;my_Connection*&gt;::iterator</a> begin = d_connections.begin(),
          end = d_connections.end(),
          it = begin;
      <span class="keywordflow">for</span> (; it != end; ++it) {
          <span class="keywordflow">if</span> (connection == *it) {
              d_connections.<a class="code" href="group__bslstl__vector.html#ga8398ddeb0509741ce8734bc4eb5d5654">erase</a>(it);
          }
      }
  }
</pre></div><br/>
<br/>
 The <code>dataAvailable</code> function will be called when data becomes available for a specific connection. It removes the connection from the timer queue while the connection is busy, processes the available data, and returns the connection to the queue with a new time value. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_Server::dataAvailable(my_Connection *connection,
                                <span class="keywordtype">void</span>          *buffer_p,
                                <span class="keywordtype">int</span>            length)
  {
      <span class="keywordflow">if</span> (connection-&gt;d_timerId) {
          <span class="keywordflow">if</span> (d_timeQueue.remove(connection-&gt;d_timerId))  <span class="keywordflow">return</span>;   <span class="comment">// RETURN</span>
          connection-&gt;d_timerId = 0;
      }
      connection-&gt;d_session_p-&gt;processData(buffer_p, length);

      <span class="keywordtype">int</span> isNewTop = 0;

      connection-&gt;d_timerId = d_timeQueue.add(<a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() +
                                                                 d_ioTimeout,
                                              connection,
                                              &amp;isNewTop);
      <span class="keywordflow">if</span> (isNewTop) {
          <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> lock(&amp;d_timerMonitorMutex);
          d_timerChangedCond.signal();
      }
  }
</pre></div><br/>
<br/>
 Function <code>monitorTimers</code> manages the timer monitor thread; it is called when the thread is spawned, and checks repeatedly for expired timers; after each check, it does a timed wait based upon the minimum time value seen in the queue after all expired timers have been removed. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_Server::monitorTimers()
  {
      <span class="keywordflow">while</span> (!d_done) {
          <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bdlcc::TimeQueueItem&lt;my_Connection*&gt;</a> &gt; expiredTimers;
          {
              <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> lock(&amp;d_timerMonitorMutex);
              <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> minTime;
              <span class="keywordtype">int</span> newLength;

              d_timeQueue.popLE(<a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>(),
                                &amp;expiredTimers,
                                &amp;newLength,
                                &amp;minTime );

              <span class="keywordflow">if</span> (!expiredTimers.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>()) {
                  <span class="keywordflow">if</span> (newLength) {
                      <span class="comment">// no expired timers, but unexpired timers remain.</span>
                      d_timerChangedCond.timedWait(&amp;d_timerMonitorMutex,
                                                   minTime);
                  }
                  <span class="keywordflow">else</span> {
                      <span class="comment">// no expired timers, and timer queue is empty.</span>
                      d_timerChangedCond.wait(&amp;d_timerMonitorMutex);
                  }
                  <span class="keywordflow">continue</span>;
              }
          }

          <span class="keywordtype">int</span> length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(expiredTimers.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());
          <span class="keywordflow">if</span> (length) {
              <a class="code" href="classbdlcc_1_1TimeQueueItem.html">bdlcc::TimeQueueItem&lt;my_Connection*&gt;</a> *data =
                                                      &amp;expiredTimers.<a class="code" href="group__bslstl__vector.html#ga547e809dc68789a250cd367760601d78">front</a>();
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; length; ++i) {
                  closeConnection(data[i].data());
              }
          }
      }
  }
</pre></div><br/>
<br/>
 Function <code>start</code> spawns two separate threads. The first thread will monitor connections and handle any data received on them. The second monitors the internal timer queue and removes connections that have timed out. Function <code>start</code> calls <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a></code>, which expects a function pointer to a function with the standard "C" callback signature <code>void *fn(void *data)</code>. This non-member function will call back into the <code>my_Server</code> object immediately. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> my_Server::start()
  {
      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> attr;

      <span class="keywordflow">if</span> (<a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;d_connectionThreadHandle, attr,
                                   &amp;my_connectionMonitorThreadEntry,
                                   <span class="keyword">this</span>)) {
          <span class="keywordflow">return</span> -1;                                                <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">if</span> (<a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;d_timerThreadHandle, attr,
                                   &amp;my_timerMonitorThreadEntry,
                                   <span class="keyword">this</span>)) {
          <span class="keywordflow">return</span> -1;                                                <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Finally, we are now in a position to implement the two thread dispatchers: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {

  <span class="keywordtype">void</span> *my_connectionMonitorThreadEntry(<span class="keywordtype">void</span> *server)
  {
      ((my_Server*)server)-&gt;monitorConnections();
      <span class="keywordflow">return</span> server;
  }

  <span class="keywordtype">void</span> *my_timerMonitorThreadEntry(<span class="keywordtype">void</span> *server)
  {
      ((my_Server*)server)-&gt;monitorTimers();
      <span class="keywordflow">return</span> server;
  }

  }
</pre></div><br/>
<br/>
 In order to test our server, we provide two concrete implementations of a test session and of a test server as follows. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// myTestSession.h             -*-C++-*-</span>

  <span class="keyword">class </span>my_TestSession : <span class="keyword">public</span> my_Session {
      <span class="comment">// Concrete implementation of my_Session, providing simple test</span>
      <span class="comment">// semantics In particular, implement the virtual function</span>
      <span class="comment">// processData() to record all incoming data for the controlling</span>
      <span class="comment">// connection, and virtual function handleTimeout() for handling</span>
      <span class="comment">// timeouts.</span>

      <span class="keywordtype">int</span> d_verbose;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span>
      my_TestSession(<span class="keywordtype">int</span> verbose) : my_Session(), d_verbose(verbose) { }

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">int</span> handleTimeout(my_Connection *connection)
      {
          <span class="comment">// Do something to handle timeout.</span>
          <span class="keywordflow">if</span> (d_verbose) {
              bsl::cout &lt;&lt; <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
              bsl::cout &lt;&lt; <span class="stringliteral">&quot;Connection &quot;</span> &lt;&lt; connection &lt;&lt; <span class="stringliteral">&quot;timed out.\n&quot;</span>;
          }
          <span class="keywordflow">return</span> 0;
      }

      <span class="keyword">virtual</span> <span class="keywordtype">int</span> processData(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> length)
      {
          <span class="comment">// Do something with the data...</span>
          <span class="keywordflow">if</span> (d_verbose) {
              bsl::cout &lt;&lt; <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
              bsl::cout &lt;&lt; <span class="stringliteral">&quot;Processing data at address &quot;</span> &lt;&lt; data
                        &lt;&lt; <span class="stringliteral">&quot; and length &quot;</span> &lt;&lt; length &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span>;
          }
          <span class="keywordflow">return</span> 0;
      }
  };

  <span class="comment">// myTestSession.h             -*-C++-*-</span>

  <span class="keyword">class </span>my_TestServer :  <span class="keyword">public</span> my_Server {
      <span class="comment">// Concrete implementation of my_Server, providing connection logic.</span>

      <span class="keywordtype">int</span> d_verbose;

    <span class="keyword">protected</span>:
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> closeConnection(my_Connection *connection);
          <span class="comment">// Close the specified external &#39;connection&#39; and call</span>
          <span class="comment">// &#39;removeConnection&#39; when done.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> monitorConnections();
          <span class="comment">// Monitor all connections in the current &#39;my_Server&#39;.  When data</span>
          <span class="comment">// becomes available for a given connection, pass the data to that</span>
          <span class="comment">// connection for processing.</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_TestServer(<span class="keyword">const</span> my_TestServer&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span>
      my_TestServer(<span class="keywordtype">int</span>               ioTimeout,
                    <span class="keywordtype">int</span>               verbose = 0,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : my_Server(ioTimeout, basicAllocator)
      , d_verbose(verbose)
      {
      }

      <span class="keyword">virtual</span> ~my_TestServer();
  };

  <span class="comment">// myTestSession.cpp             -*-C++-*-</span>

  my_TestServer::~my_TestServer()
  {
  }

  <span class="keywordtype">void</span> my_TestServer::closeConnection(my_Connection *connection)
  {
      <span class="keywordflow">if</span> (d_verbose) {
          bsl::cout &lt;&lt; <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Closing connection &quot;</span> &lt;&lt; connection &lt;&lt; bsl::endl;
      }
      <span class="keyword">delete</span> connection;
  }

  <span class="keywordtype">void</span> my_TestServer::monitorConnections()
  {
      my_Session *session = <span class="keyword">new</span> my_TestSession(d_verbose);

      <span class="comment">// Simulate connection monitor logic...</span>
      my_Connection *connection1 = <span class="keyword">new</span> my_Connection;
      connection1-&gt;d_session_p = session;
      newConnection(connection1);
      <span class="keywordflow">if</span> (d_verbose) {
          bsl::cout &lt;&lt; <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Opening connection &quot;</span> &lt;&lt; connection1 &lt;&lt; endl;
      }

      my_Connection *connection2 = <span class="keyword">new</span> my_Connection;
      connection2-&gt;d_session_p = session;
      newConnection(connection2);
      <span class="keywordflow">if</span> (d_verbose) {
          bsl::cout &lt;&lt; <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Opening connection &quot;</span> &lt;&lt; connection2 &lt;&lt; endl;
      }

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a667b0f54d6c038c8ecb851ca66dc0529">bslmt::ThreadUtil::sleep</a>(<a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(2)); <span class="comment">// 2s</span>

      <span class="comment">// Simulate transmission...</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span>  length = 1024;
      <span class="keyword">const</span> <span class="keywordtype">char</span>*buffer[length];
      <span class="keywordflow">if</span> (d_verbose) {
          bsl::cout &lt;&lt; <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Connection &quot;</span> &lt;&lt; connection1
                    &lt;&lt; <span class="stringliteral">&quot; receives &quot;</span> &lt;&lt; length &lt;&lt; <span class="stringliteral">&quot; bytes &quot;</span> &lt;&lt; endl;
      }
      dataAvailable(connection1, buffer, length);

      <span class="comment">// Wait for timeout to occur, otherwise session gets destroyed from</span>
      <span class="comment">// stack too early.</span>

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a667b0f54d6c038c8ecb851ca66dc0529">bslmt::ThreadUtil::sleep</a>(<a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(8)); <span class="comment">// 8s</span>
  }
</pre></div><br/>
<br/>
 The program that would exercise this test server would simply consist of: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample(<span class="keywordtype">int</span> verbose)
  {
      my_TestServer mX(5, verbose); <span class="comment">// timeout for connections: 5s</span>
      mX.start();

      <span class="comment">// Wait sufficiently long to observe all events.</span>
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a667b0f54d6c038c8ecb851ca66dc0529">bslmt::ThreadUtil::sleep</a>(<a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(10)); <span class="comment">// 10s</span>

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 The output of this program would look something as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  17:10:35.000: Opening connection 0x00161880
  17:10:35.000: Opening connection 0x001618b0
  17:10:37.000: Connection 0x00161880 receives 1024 bytes
  17:10:37.000: Processing data at address 0xfeefaf04 and length 1024.
  17:10:40.000: Closing connection 0x001618b0
  17:10:42.000: Closing connection 0x00161880
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:42 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
