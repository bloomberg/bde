<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_concurrentmultipoolallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_concurrentmultipoolallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an allocator to manage pools of varying object sizes.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Configuration at Construction</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using a <code>bdlma::ConcurrentMultipoolAllocator</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an allocator to manage pools of varying object sizes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a> </td><td>allocator managing varying size pools  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__concurrentpool.html" title="Provide thread-safe allocation of memory blocks of uniform size.">Component bdlma_concurrentpool</a>, <a class="el" href="group__bdlma__concurrentmultipool.html" title="Provide a memory manager to manage pools of varying block sizes.">Component bdlma_concurrentmultipool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides an allocator, <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code>, that implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> protocol and provides an allocator that maintains a configurable number of <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> objects, each dispensing memory blocks of a unique size. The <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code> objects are placed in an array, starting at index 0, with each successive pool managing memory blocks of a size twice that of the previous pool. Each multipool allocation (deallocation) request allocates memory from (returns memory to) the internal pool managing memory blocks of the smallest size not less than the requested size, or else from a separately managed list of memory blocks, if no internal pool managing memory block of sufficient size exists. Both the <code>release</code> method and the destructor of a <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code> release all memory currently allocated via the object. <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,------------------------.
  ( bcema::MultiPoolAllocator )
   `------------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">               |         ctor/dtor</span>
<span class="stringliteral">               |         maxPooledBlockSize</span>
<span class="stringliteral">               |         numPools</span>
<span class="stringliteral">               |         reserveCapacity</span>
<span class="stringliteral">               V</span>
<span class="stringliteral">    ,----------------------.</span>
<span class="stringliteral">   ( bdlma::ManagedAllocator )</span>
<span class="stringliteral">    `----------------------&#39;</span>
               |         release
               V
       ,-----------------.
      (  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> )
       `-----------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                        allocate</span>
<span class="stringliteral">                        deallocate</span>
</pre></div><br/>
<br/>
 The main difference between a <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code> and a <code><a class="el" href="classbdlma_1_1ConcurrentMultipool.html">bdlma::ConcurrentMultipool</a></code> is that, very often, a <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code> is managed through a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> pointer. Hence, every call to the <code>allocate</code> method invokes a virtual function call, which is slower than invoking the non-virtual <code>allocate</code> method on a <code><a class="el" href="classbdlma_1_1ConcurrentMultipool.html">bdlma::ConcurrentMultipool</a></code>. However, since <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> is widely used across BDE interfaces, <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code> is more general purposed than a <code><a class="el" href="classbdlma_1_1ConcurrentMultipool.html">bdlma::ConcurrentMultipool</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="configuration_at_construction"></a> <a class="anchor" id="description.configuration_at_construction"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Configuration at Construction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When creating a <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code>, clients can optionally configure: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
NUMBER OF POOLS -- the number of internal pools (the block size managed by the first pool is eight bytes, with each successive pool managing block of a size twice that of the previous pool).  </li>
<li>
<p class="startli">GROWTH STRATEGY -- geometrically growing chunk size starting from 1 (in terms of the number of memory blocks per chunk), or fixed chunk size, specified as either:</p>
<ul>
<li>
the unique growth strategy for all pools, or  </li>
<li>
(if the number of pools is specified) an array of growth strategies corresponding to each individual pool  </li>
</ul>
<div class="hanging"> </div></li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> If the growth strategy is not specified, geometric growth is used for all</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> pools. </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<p>MAX BLOCKS PER CHUNK -- the maximum number of memory blocks within a chunk, specified as either:</p>
<ul>
<li>
the unique maximum-blocks-per-chunk value for all of the pools, or  </li>
<li>
an array of maximum-blocks-per-chunk values corresponding to each individual pool. </li>
</ul>
<div class="hanging"> <dl class="user"><dt><b></b></dt><dd>If the maximum blocks per chunk is not specified, an</dd></dl>
<dl class="user"><dt><b></b></dt><dd>implementation-defined default value is used. Note that the maximum</dd></dl>
<dl class="user"><dt><b></b></dt><dd>blocks per chunk can be configured only if the number of pools is also</dd></dl>
<dl class="user"><dt><b></b></dt><dd>configured. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>BASIC ALLOCATOR -- the allocator used to supply memory (to replenish an internal pool, or directly if the maximum block size is exceeded). If not specified, the currently installed default allocator (see <code>bslma_default</code>) is used.   </p>
<dl class="user"><dt><b></b></dt><dd>A default-constructed multipool allocator has a relatively small, implementation-defined number of pools <code>N</code> with respective block sizes ranging from <code>2^3 = 8</code> to <code>2^(N+2)</code>. By default, the initial chunk size, (i.e., the number of blocks of a given size allocated at once to replenish a pool's memory) is 1, and each pool's chunk size grows geometrically until it reaches an implementation-defined maximum, at which it is capped. Finally, unless otherwise specified, all memory comes from the allocator that was the currently installed default allocator at the time the <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code> was created. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using the various pooling options described above, we can configure the number of pools maintained, whether replenishment should be adaptive (i.e., geometric starting with 1) or fixed at a maximum chunk size, what that maximum chunk size should be (which need not be an integral power of 2), and the underlying allocator used to supply memory. Note that both GROWTH STRATEGY and MAX BLOCKS PER CHUNK can be specified separately either as a single value applying to all of the maintained pools, or as an array of values, with the elements applying to each individually maintained pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_a_bdlma~3A~3Aconcurrentmultipoolallocator"></a> <a class="anchor" id="usage.example_1~3A_using_a_bdlma~3A~3Aconcurrentmultipoolallocator"></a> <a class="anchor" id="description.usage.example_1~3A_using_a_bdlma~3A~3Aconcurrentmultipoolallocator"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using a bdlma::ConcurrentMultipoolAllocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code> can be used to supply memory to node-based data structures such as <code><a class="el" href="classbsl_1_1set.html">bsl::set</a></code>, <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code> or <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code>. Suppose we are implementing a container of named graphs data structure, where a graph is defined by a set of edges and nodes. The various fixed-sized nodes can be efficiently allocated by a <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, the edge class, <code>my_Edge</code>, is defined as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Node;

  <span class="keyword">class </span>my_Edge {
      <span class="comment">// This class represents an edge within a graph.  Both ends of the</span>
      <span class="comment">// edge must be connected to nodes.</span>

      <span class="comment">// DATA</span>
      my_Node *d_first;   <span class="comment">// first node</span>
      my_Node *d_second;  <span class="comment">// second node</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_Edge(my_Node *first, my_Node *second);
          <span class="comment">// Create an edge that connects to the specified &#39;first&#39; and</span>
          <span class="comment">// &#39;second&#39; nodes.</span>

      <span class="comment">// ...</span>
  };

  <span class="comment">// CREATORS</span>
  my_Edge::my_Edge(my_Node *first, my_Node *second)
  : d_first(first), d_second(second)
  {
  }
</pre></div><br/>
<br/>
 Then, the node class, <code>my_Node</code>, is defined as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Node {
      <span class="comment">// This class represents a node within a graph.  A node can be</span>
      <span class="comment">// connected to any number of edges.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1set.html">bsl::set&lt;my_Edge *&gt;</a> d_edges;  <span class="comment">// set of edges this node connects to</span>

      <span class="comment">// ...</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_Node(<span class="keyword">const</span> my_Node&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(my_Node, <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_Node(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a node not connected to any other nodes.  Optionally</span>
          <span class="comment">// specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

      <span class="comment">// ...</span>
  };

  <span class="comment">// CREATORS</span>
  my_Node::my_Node(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_edges(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Then we define the graph class, <code>my_Graph</code>, as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Graph {
      <span class="comment">// This class represents a graph having sets of nodes and edges.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1set.html">bsl::set&lt;my_Edge&gt;</a> d_edges;  <span class="comment">// set of edges in this graph</span>
      <a class="code" href="classbsl_1_1set.html">bsl::set&lt;my_Node&gt;</a> d_nodes;  <span class="comment">// set of nodes in this graph</span>

      <span class="comment">// ...</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_Graph(<span class="keyword">const</span> my_Graph&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(my_Graph, <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_Graph(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty graph.  Optionally specify a &#39;basicAllocator&#39;</span>
          <span class="comment">// used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      <span class="comment">// ...</span>
  };

  my_Graph::my_Graph(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_edges(basicAllocator)
  , d_nodes(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Then finally, the container for the collection of named graphs, <code>my_NamedGraphContainer</code>, is defined as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_NamedGraphContainer {
      <span class="comment">// This class stores a map that index graph names to graph objects.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1map.html">bsl::map&lt;bsl::string, my_Graph&gt;</a> d_graphMap;  <span class="comment">// map from graph names to</span>
                                                   <span class="comment">// graph</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_NamedGraphContainer(<span class="keyword">const</span> my_NamedGraphContainer&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(my_NamedGraphContainer,
                                     <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_NamedGraphContainer(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty named graph container.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// ...</span>
  };

  <span class="comment">// CREATORS</span>
  my_NamedGraphContainer::my_NamedGraphContainer(
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_graphMap(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Finally, in <code>main</code>, we can create a <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a></code> and pass it to our <code>my_NamedGraphContainer</code>. Since we know that the maximum block size needed is 32 (comes from <code>sizeof(my_Graph)</code>), we can calculate the number of pools needed by using the formula specified in the "configuration at construction" section: <br/>
<br/>
<div class="fragment"><pre class="fragment">  largestPoolSize &lt; 2 ^ (N + 2).
</pre></div><br/>
<br/>
 When solved for the above equation, the smallest <code>N</code> that satisfies this relationship is 3: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { k_NUM_POOLS = 3 };

  <a class="code" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a> basicAllocator(k_NUM_POOLS);

  my_NamedGraphContainer container(&amp;basicAllocator);
</pre></div><br/>
<br/>
 </dd></dl>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:44 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
