<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// ball_countingallocator.h                                           -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALL_COUNTINGALLOCATOR
#define INCLUDED_BALL_COUNTINGALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a concrete allocator keep a count of allocated bytes.
//
//@CLASSES:
//  ball::CountingAllocator: maximally-aligning, instrumented allocator adaptor
//
//@SEE_ALSO: ball_fixedsizerecordbuffer
//
//@DESCRIPTION: This component provides a special-purpose instrumented
// allocator, &#39;ball::CountingAllocator&#39;, that implements the &#39;bslma::Allocator&#39;
// protocol and guarantees maximal alignment of allocated blocks, even when
// the allocator supplied at construction guarantees only natural alignment
// (or no alignment at all).  &#39;ball::CountingAllocator&#39; maintains a
// user-resettable running sum of the total number of bytes
// allocated (called byte count, see below).
//..
//   ,----------------------.
//  ( ball::CountingAllocator )
//   `----------------------&#39;
//               |         ctor/dtor
//               |         numBytesTotal
//               |         resetNumBytesTotal
//               V
//       ,-----------------.
//      ( bslma::Allocator )
//       `-----------------&#39;
//                       allocate
//                       deallocate
//..
//
///Byte Count
///----------
// The byte count maintained by &#39;ball::CountingAllocator&#39; is set to 0 upon
// construction and after each call to &#39;resetNumBytesTotal&#39;.  Each call of
// &#39;allocate(size)&#39; increases the byte count by the sum of the least
// multiple of &#39;bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT&#39; that is greater than
// or equal to &#39;size&#39; and &#39;bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT&#39;.  Each call
// of &#39;deallocate&#39; decrements the byte count by the same amount by which the
// byte count was incremented on matching &#39;allocate&#39; call.  The current
// value of the byte count is returned by the &#39;numBytesTotal&#39; accessor.
//
///Usage
///-----
// In the following example we demonstrate how the counting allocator can
// be used to know the amount of dynamic memory allocated by a
// &#39;vector&lt;int&gt;&#39; after pushing one integer.  Let us assume that memory for
// the vector comes from a &#39;bslma::Allocator&#39; named &#39;allocator&#39;.
//..
//    // First create the counting allocator using &#39;allocator&#39;.
//    BloombergLP::ball::CountingAllocator countingAllocator(allocator);
//
//    // Now create the vector using the counting allocator.
//    bsl::vector&lt;int&gt; vec(&amp;countingAllocator);
//
//    vec.push_back(1);
//    // The following will print the memory consumed by the
//    // vector and the counting allocator.
//    bsl::cout &lt;&lt; &quot;dynamic memory after first push back: &quot;
//              &lt;&lt; countingAllocator.numBytesTotal() &lt;&lt; bsl::endl;
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTUTIL
#include &lt;bsls_alignmentutil.h&gt;
#endif



namespace BloombergLP {

namespace ball {
                        // ============================
                        // class CountingAllocator
                        // ============================

class CountingAllocator : public bslma::Allocator {
    // This class maintains a count of the total number of allocated bytes.
    // The running byte count is initialized to 0 upon construction, is
    // increased by the &#39;allocate&#39; method, and may be reset to 0 by the
    // &#39;resetNumBytesTotal&#39; method.  The &#39;deallocate&#39; method appropriately
    // decrement the byte count.  The precise definition of byte count is
    // described in the &quot;Byte Count&quot; section of the component-level
    // documentation.

    // DATA
    size_type         d_byteCount;    // byte count
    bslma::Allocator *d_allocator_p;  // holds (but does not own) allocator

    // NOT IMPLEMENTED
    CountingAllocator(const CountingAllocator&amp;);
    CountingAllocator&amp; operator=(const CountingAllocator&amp;);

  public:
    // CREATORS
    CountingAllocator(bslma::Allocator *basicAllocator = 0);
        // Create a counting allocator having an initial byte count of 0.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    virtual ~CountingAllocator();
        // Destroy this counting allocator.

    // MANIPULATORS
    virtual void *allocate(size_type size);
        // Return a newly allocated block of memory of (at least) the specified
        // positive &#39;size&#39; (bytes) and increment the byte count maintained by
        // this counting allocator by the sum of the least multiple of
        // &#39;bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT&#39; that is greater than or
        // equal to &#39;size&#39; and &#39;bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT&#39;.
        // The behavior is undefined unless 0 &lt;= size.  Note that the alignment
        // of the address returned is the maximum alignment for any fundamental
        // type defined for the calling platform, even if the supplied
        // allocator guarantees only natural alignment.

    virtual void deallocate(void *address);
        // Return the memory at the specified &#39;address&#39; back to this allocator
        // and update the byte count maintained by this counting allocator
        // appropriately.  If &#39;address&#39; is 0, this function has no effect.  The
        // behavior is undefined unless &#39;address&#39; was allocated using this
        // allocator and has not already been deallocated.

    void resetNumBytesTotal();
        // Reset the byte count maintained by this counting allocator to
        // 0.

    // ACCESSORS
    size_type numBytesTotal() const;
        // Return the byte count maintained by this counting allocator.
        // The precise definition of byte count is described in the &quot;Byte
        // Count&quot; section of the component-level documentation.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

// CREATORS
inline
CountingAllocator::CountingAllocator(
                                              bslma::Allocator *basicAllocator)
: d_byteCount(0)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

// MANIPULATORS
inline
void *CountingAllocator::allocate(size_type size)
{
    size_type paddedSize =
                          bsls::AlignmentUtil::roundUpToMaximalAlignment(size);
    size_type totalSize = paddedSize + bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT;

    d_byteCount += totalSize;
    void *address = d_allocator_p-&gt;allocate(totalSize);
    *((int *)address) = static_cast&lt;int&gt;(totalSize);
    return (char *)address + bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT;
}

inline
void CountingAllocator::deallocate(void *address)
{
    if (address) {
        address = (char *)address - bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT;
        d_byteCount -= *((int *)address);
        d_allocator_p-&gt;deallocate(address);
    }
}

inline
void CountingAllocator::resetNumBytesTotal()
{
    d_byteCount = 0;
}

// ACCESSORS
inline
CountingAllocator::size_type CountingAllocator::numBytesTotal() const
{
    return d_byteCount;
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
