<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlt_dayofweekset.h                                                -*-C++-*-
#ifndef INCLUDED_BDLT_DAYOFWEEKSET
#define INCLUDED_BDLT_DAYOFWEEKSET

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an ordered set of (unique) &#39;bdlt::DayOfWeek::Enum&#39; values.
//
//@CLASSES:
//  bdlt::DayOfWeekSet: ordered set of (unique) &#39;bdlt::DayOfWeek::Enum&#39; values
//
//@SEE_ALSO: bdlt_dayofweek
//
//@DESCRIPTION: This component implements an efficient value-semantic, ordered
// set class, &#39;bdlt::DayOfWeekSet&#39;, for elements of the &#39;bdlt::DayOfWeek::Enum&#39;
// enumeration.  As there are only seven possible element values, asymptotic
// performance characterization is not appropriate; all operations implicitly
// run in constant time and provide the no-throw guarantee.
//
///Supplementary Overloaded Operators
///----------------------------------
// In addition to the standard value-semantic operators &#39;=&#39;, &#39;==&#39;, &#39;!=&#39;, and
// &#39;&lt;&lt;&#39;, the following canonical set of binary and unary (free) operators are
// defined on &#39;bdlt::DayOfWeekSet&#39; objects:
//..
//                   set S: { e_MON, e_TUE, e_WED }
//                   set T: { e_MON, e_WED, e_FRI }
//
//           Union:  S | T  { e_MON, e_TUE, e_WED, e_FRI }
//
//    Intersection:  S &amp; T  { e_MON, e_WED }
//
//    Exclusive Or:  S ^ T  { e_TUE, e_FRI }
//
//     Subtraction:  S - T  { e_TUE }
//                   T - S  { e_FRI }
//
//  Unary Negation:     ~S  { e_SUN, e_THU, e_FRI, e_SAT }
//                      ~T  { e_SUN, e_TUE, e_THU, e_SAT }
//..
// The corresponding assignment (member) operators &#39;|=&#39; , &#39;&amp;=&#39;, &#39;^=&#39;, and &#39;-=&#39;
// (but not &#39;~=&#39;) are also provided.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Manipulation and Traversal of Day of Week Sets
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// A &#39;bdlt::DayOfWeekSet&#39; is useful for recording recurring appointments, or
// special days (e.g., weekend days), in a calendar.  The following snippets of
// code illustrate how to create and use a &#39;bdlt::DayOfWeek&#39; set.
//
// First, we create a couple of commonly useful sets.  First we define the
// &#39;bdlt::DayOfWeekSet&#39; &#39;weekendDays&#39;:
//..
//  bdlt::DayOfWeekSet weekendDays;
//..
// Then, we notice that this set is initially empty.
//..
//  assert(0 == weekendDays.length());
//..
// Next, we add the days that characterize weekends:
//..
//  weekendDays.add(bdlt::DayOfWeek::e_SUN);
//  assert(1 == weekendDays.length());
//
//  weekendDays.add(bdlt::DayOfWeek::e_SAT);
//  assert(2 == weekendDays.length());
//..
// Then, we observe that &#39;weekendDays&#39; now contains precisely the days we
// expect it to contain:
//..
//  assert(true  == weekendDays.isMember(bdlt::DayOfWeek::e_SUN));
//  assert(false == weekendDays.isMember(bdlt::DayOfWeek::e_MON));
//  assert(false == weekendDays.isMember(bdlt::DayOfWeek::e_TUE));
//  assert(false == weekendDays.isMember(bdlt::DayOfWeek::e_WED));
//  assert(false == weekendDays.isMember(bdlt::DayOfWeek::e_THU));
//  assert(false == weekendDays.isMember(bdlt::DayOfWeek::e_FRI));
//  assert(true  == weekendDays.isMember(bdlt::DayOfWeek::e_SAT));
//..
// Next, we create the complementary &#39;bdlt::DayOfWeekSet&#39; &#39;weekDays&#39; directly
// from &#39;weekendDays&#39; via a combination of unary negation and copy
// construction:
//..
//  bdlt::DayOfWeekSet weekDays(~weekendDays);
//
//  assert(5 == weekDays.length());
//
//  assert(false == weekDays.isMember(bdlt::DayOfWeek::e_SUN));
//  assert(true  == weekDays.isMember(bdlt::DayOfWeek::e_MON));
//  assert(true  == weekDays.isMember(bdlt::DayOfWeek::e_TUE));
//  assert(true  == weekDays.isMember(bdlt::DayOfWeek::e_WED));
//  assert(true  == weekDays.isMember(bdlt::DayOfWeek::e_THU));
//  assert(true  == weekDays.isMember(bdlt::DayOfWeek::e_FRI));
//  assert(false == weekDays.isMember(bdlt::DayOfWeek::e_SAT));
//..
// Then, to create a set containing all of the days in the week, we do so via
// unary negation of the default constructed value:
//..
//  const bdlt::DayOfWeekSet NO_DAYS;
//  const bdlt::DayOfWeekSet ALL_DAYS(~NO_DAYS);
//
//  assert(7 == ALL_DAYS.length());
//..
// Next, we observe that neither &#39;weekDays&#39; nor &#39;weekendDays&#39; represent the
// same value as &#39;ALL_DAYS&#39;, but their union does:
//..
//  assert(ALL_DAYS != weekendDays);
//  assert(ALL_DAYS != weekDays);
//  assert(ALL_DAYS == (weekDays | weekendDays));
//  assert(ALL_DAYS == (weekDays ^ weekendDays));
//
//  assert(weekendDays == ALL_DAYS - weekDays);
//
//  assert(weekDays    == ALL_DAYS - weekendDays);
//
//  assert(weekDays    == ALL_DAYS - weekendDays);
//..
// Then, we observe that similarly, neither &#39;weekDays&#39; nor &#39;weekendDays&#39;
// represents the same value as &#39;NO_DAYS&#39;, but their intersection does:
//..
//  assert(NO_DAYS != weekendDays);
//  assert(NO_DAYS != weekDays);
//  assert(NO_DAYS == (weekDays &amp; weekendDays));
//
//  assert(weekendDays == weekendDays - weekDays);
//
//  assert(weekDays    == weekDays - weekendDays);
//..
// Next, we create the corresponding set &#39;eDays&#39; consisting of the only days of
// the week that have an &#39;E&#39; in them: &#39;TUESDAY&#39; and &#39;WEDNESDAY&#39;:
//..
//  bdlt::DayOfWeekSet eDays;                 assert(0 == eDays.length());
//  eDays.add(bdlt::DayOfWeek::e_TUE);     assert(1 == eDays.length());
//  eDays.add(bdlt::DayOfWeek::e_WED);     assert(2 == eDays.length());
//
//  assert(false == eDays.isMember(bdlt::DayOfWeek::e_SUN));
//  assert(false == eDays.isMember(bdlt::DayOfWeek::e_MON));
//  assert(true  == eDays.isMember(bdlt::DayOfWeek::e_TUE));
//  assert(true  == eDays.isMember(bdlt::DayOfWeek::e_WED));
//  assert(false == eDays.isMember(bdlt::DayOfWeek::e_THU));
//  assert(false == eDays.isMember(bdlt::DayOfWeek::e_FRI));
//  assert(false == eDays.isMember(bdlt::DayOfWeek::e_SAT));
//..
// Then, we create a set consisting of days that have an &#39;n&#39; in them: &#39;MONDAY&#39;,
// &#39;WEDNESDAY&#39;, and &#39;SUNDAY&#39;.  We create the corresponding set &#39;nDays&#39; starting
// with the value of &#39;eDays&#39; by first removing &#39;TUESDAY&#39;, and then adding
// &#39;SUNDAY&#39; and &#39;MONDAY&#39;:
//..
//  bdlt::DayOfWeekSet nDays(eDays);          assert(2 == nDays.length());
//
//  nDays.remove(bdlt::DayOfWeek::e_TUE);  assert(1 == nDays.length());
//
//  nDays.add(bdlt::DayOfWeek::e_SUN);     assert(2 == nDays.length());
//  nDays.add(bdlt::DayOfWeek::e_MON);     assert(3 == nDays.length());
//
//  assert(true  == nDays.isMember(bdlt::DayOfWeek::e_SUN));
//  assert(true  == nDays.isMember(bdlt::DayOfWeek::e_MON));
//  assert(false == nDays.isMember(bdlt::DayOfWeek::e_TUE));
//  assert(true  == nDays.isMember(bdlt::DayOfWeek::e_WED));
//  assert(false == nDays.isMember(bdlt::DayOfWeek::e_THU));
//  assert(false == nDays.isMember(bdlt::DayOfWeek::e_FRI));
//  assert(false == nDays.isMember(bdlt::DayOfWeek::e_SAT));
//..
// Next, we observe that all &#39;eDays&#39; are &#39;weekDays&#39;, but that&#39;s not true of
// &#39;nDays&#39;:
//..
//  assert(true  == weekDays.areMembers(eDays));
//  assert(false == weekDays.areMembers(nDays));
//..
// Now, we observe that iteration order is defined by increasing enumerated
// &#39;bdlt::DayOfWeek::Day&#39; value &#39;[ SUN .. SAT ]&#39;.  The following use of the
// *forward* (bi-directional) iterator:
//..
//  for (bdlt::DayOfWeekSet::iterator it  = ALL_DAYS.begin();
//                                    it != ALL_DAYS.end();
//                                    ++it) {
//      bsl::cout &lt;&lt; *it &lt;&lt; bsl::endl;
//  }
//..
// produces:
//..
//  SUN
//  MON
//  TUE
//  WED
//  THU
//  FRI
//  SAT
//..
// on standard output.
//
// Finally, we observe that, similarly, the following use of the *reverse*
// iterator:
//..
//  for (bdlt::DayOfWeekSet::reverse_iterator it  = weekDays.rbegin();
//                                            it != weekDays.rend();
//                                            ++it) {
//      bsl::cout &lt;&lt; *it &lt;&lt; bsl::endl;
//  }
//..
// produces:
//..
//  FRI
//  THU
//  WED
//  TUE
//  MON
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLT_DAYOFWEEK
#include &lt;bdlt_dayofweek.h&gt;
#endif

#ifndef INCLUDED_BDLB_BITUTIL
#include &lt;bdlb_bitutil.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_ITERATOR
#include &lt;bsl_iterator.h&gt;
#endif

namespace BloombergLP {
namespace bdlt {

                          // =======================
                          // class DayOfWeekSet_Iter
                          // =======================

class DayOfWeekSet_Iter : public bsl::iterator&lt;bsl::bidirectional_iterator_tag,
                                               const DayOfWeek::Enum&gt; {
    // Implementation of standard bidirectional iterator for &#39;DayOfWeekSet&#39;.
    // Any modification of a &#39;DayOfWeekSet&#39; will invalidate any iterators
    // referring to that &#39;DayOfWeekSet&#39;.

    // CLASS DATA
    static const DayOfWeek::Enum s_dayOfWeekArray[9];  // = { ???, SUN, ...

    // DATA
    unsigned char d_data;       // copy of days of the week from the original
                                // container
    signed char   d_index;      // current position in the iteration; value
                                // &#39;[0 .. 8]&#39;

    // FRIENDS
    friend bool operator==(const DayOfWeekSet_Iter&amp;, const DayOfWeekSet_Iter&amp;);

  public:
    // CREATORS
    DayOfWeekSet_Iter();
        // Create a default (invalid) iterator.

    DayOfWeekSet_Iter(int data, int index);
        // Create an iterator using the specified &#39;data&#39; and &#39;index&#39;.  If
        // &#39;index&#39; is 1, this iterator references the first valid element of
        // &#39;data&#39;; if &#39;index&#39; is 8, then this iterator references one past the
        // last possible element in &#39;data&#39;.  The behavior is undefined unless
        // &#39;0 == (data &amp; 1)&#39;, &#39;index &gt;= 0&#39;, and &#39;index &lt;= 8&#39;.

    DayOfWeekSet_Iter(const DayOfWeekSet_Iter&amp; original);
        // Create an iterator having the value of the specified &#39;original&#39;
        // iterator.

    ~DayOfWeekSet_Iter();
        // Destroy this iterator.

    // MANIPULATORS
    DayOfWeekSet_Iter&amp; operator=(const DayOfWeekSet_Iter&amp; rhs);
        // Assign to this iterator the value of the specified &#39;rhs&#39; iterator,
        // and return a reference providing modifiable access to this iterator.

    DayOfWeekSet_Iter&amp; operator++();
        // Advance this iterator to the next valid data element, and return a
        // reference providing modifiable access to this iterator.  If there is
        // no next valid data element, this iterator will be set equal to
        // &#39;end()&#39;.

    DayOfWeekSet_Iter operator++(int);
        // Advance this iterator to the next valid data element, and return by
        // value the value of this iterator before it was incremented.  If
        // there is no next valid data element, this iterator will be set equal
        // to &#39;end()&#39;.

    DayOfWeekSet_Iter&amp; operator--();
        // Regress this iterator to the previous valid data element, and return
        // a reference providing modifiable access to this iterator.  If there
        // is no preceding data element, the value of &#39;reverse_iterator(*this)&#39;
        // will be &#39;rend()&#39;.

    DayOfWeekSet_Iter operator--(int);
        // Regress this iterator to the previous valid data element, and return
        // by value the value of this iterator before it was decremented.  If
        // there is no preceding data element, the value of
        // &#39;reverse_iterator(*this)&#39; will be &#39;rend()&#39;.

    // ACCESSORS
    const DayOfWeek::Enum&amp; operator*() const;
        // Return a reference providing non-modifiable access to the day of
        // week value referenced by this iterator.  The behavior is undefined
        // unless the iterator refers to a valid day of the week, specifically,
        // the behavior is undefined if &#39;*this == end()&#39;.
};

// FREE OPERATORS
bool operator==(const DayOfWeekSet_Iter&amp; lhs, const DayOfWeekSet_Iter&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators have the same
    // value, and &#39;false&#39; otherwise.  Two iterators have the same value if they
    // refer to data at the same index position.  The behavior is undefined
    // unless &#39;lhs&#39; and &#39;rhs&#39; both reference into the same set of data.

bool operator!=(const DayOfWeekSet_Iter&amp; lhs, const DayOfWeekSet_Iter&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators do not have the
    // same value, and &#39;false&#39; otherwise.  Two iterators do not have the same
    // value if they do not refer to data at the same index position.  The
    // behavior is undefined unless &#39;lhs&#39; and &#39;rhs&#39; both reference into the
    // same set of data.

                          // ==================
                          // class DayOfWeekSet
                          // ==================

class DayOfWeekSet {
    // This class implements an efficient value-semantic, ordered set of
    // &#39;DayOfWeek&#39; values.  This set requires a fixed capacity, and all
    // operations operate in constant time, and provide the no-throw guarantee.

    // DATA
    unsigned char d_days;  // bits &#39;1 .. 7&#39; reflect &#39;[ SUN, MON, ..., SAT ]&#39;;
                           // bit 0 is unused

    // FRIENDS
    friend bool operator==(const DayOfWeekSet&amp;, const DayOfWeekSet&amp;);
    friend bool operator!=(const DayOfWeekSet&amp;, const DayOfWeekSet&amp;);
    friend DayOfWeekSet operator~(const DayOfWeekSet&amp;);

  public:
    // TYPES
    typedef DayOfWeekSet_Iter iterator;
        // Standard nested alias for set container&#39;s iterator.

    typedef iterator const_iterator;
        // Standard nested alias for set container&#39;s constant iterator.

    typedef bsl::reverse_iterator&lt;iterator&gt; reverse_iterator;
        // Standard nested alias for set container&#39;s reverse iterator.

    typedef reverse_iterator const_reverse_iterator;
        // Standard nested alias for set container&#39;s constant reverse iterator.

    // CLASS METHODS

                                  // Aspects

    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    // CREATORS
    DayOfWeekSet();
        // Create an empty set.

    DayOfWeekSet(const DayOfWeekSet&amp; original);
        // Create a set initialized to the value of the specified &#39;original&#39;
        // set.

    ~DayOfWeekSet();
        // Destroy this object.

    // MANIPULATORS
    DayOfWeekSet&amp; operator=(const DayOfWeekSet&amp; rhs);
        // Assign to this set the value of the specified &#39;rhs&#39; set, and return
        // a reference providing modifiable access to this set.

    DayOfWeekSet&amp; operator|=(const DayOfWeekSet&amp; rhs);
        // Assign to this set the union of this set with the specified &#39;rhs&#39;
        // set (i.e., a set containing elements that are in either this set or
        // the &#39;rhs&#39; set, or in both sets), and return a reference providing
        // modifiable access to this set.

    DayOfWeekSet&amp; operator&amp;=(const DayOfWeekSet&amp; rhs);
        // Assign to this set the intersection of this set with the specified
        // &#39;rhs&#39; set (i.e., a set containing elements that are in both this
        // set and the &#39;rhs&#39; set), and return a reference providing modifiable
        // access to this set.

    DayOfWeekSet&amp; operator^=(const DayOfWeekSet&amp; rhs);
        // Assign to this set the exclusive-or of this set with the specified
        // &#39;rhs&#39; set (i.e., a set containing elements that are either in this
        // set, but not &#39;rhs&#39;, or in &#39;rhs&#39;, but not in this set), and return a
        // reference providing modifiable access to this set.

    DayOfWeekSet&amp; operator-=(const DayOfWeekSet&amp; rhs);
        // Assign to this set the subtraction of the specified &#39;rhs&#39; set from
        // this set (i.e., a set containing elements that are in this set, but
        // not in the &#39;rhs&#39; set), and return a reference providing modifiable
        // access to this set.

    void add(DayOfWeek::Enum value);
        // Add the specified &#39;value&#39; to this set.

    bool remove(DayOfWeek::Enum value);
        // Remove the specified &#39;value&#39; from this set.  Return &#39;true&#39; if
        // &#39;value&#39; was a member of this set, and &#39;false&#39; otherwise.

    void removeAll();
        // Remove all members of this set.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    bool areMembers(const DayOfWeekSet&amp; set) const;
        // Return &#39;true&#39; if this set contains all elements of the specified
        // &#39;set&#39;, and &#39;false&#39; otherwise.

    iterator begin() const;
        // Return an iterator referencing the first valid element in this set.

    iterator end() const;
        // Return an iterator indicating one position past the last possible
        // element in this set.

    bool isEmpty() const;
        // Return &#39;true&#39; if there are no elements in this set, and &#39;false&#39;
        // otherwise.

    bool isMember(DayOfWeek::Enum value) const;
        // Return &#39;true&#39; if the specified &#39;value&#39; is an element of this set,
        // and &#39;false&#39; otherwise.

    int length() const;
        // Return the number of elements in this set.

    reverse_iterator rbegin() const;
        // Return a reverse iterator referencing the last valid element in this
        // set.

    reverse_iterator rend() const;
        // Return a reverse iterator indicating one position before the first
        // possible element in this set.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39;, and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.


};

// FREE OPERATORS
DayOfWeekSet operator~(const DayOfWeekSet&amp; set);
    // Return a set containing the complement of the specified &#39;set&#39; (i.e.,
    // those members *not* contained in &#39;set&#39;).

DayOfWeekSet operator|(const DayOfWeekSet&amp; lhs, const DayOfWeekSet&amp; rhs);
    // Return a set containing the union of the specified &#39;lhs&#39; and &#39;rhs&#39; sets
    // (i.e., a set containing elements that are in either &#39;lhs&#39; or &#39;rhs&#39; or
    // both).

DayOfWeekSet operator&amp;(const DayOfWeekSet&amp; lhs, const DayOfWeekSet&amp; rhs);
    // Return a set containing the intersection of the specified &#39;lhs&#39; and
    // &#39;rhs&#39; sets (i.e., a set containing elements that are in both &#39;lhs&#39; and
    // &#39;rhs&#39;).

DayOfWeekSet operator^(const DayOfWeekSet&amp; lhs, const DayOfWeekSet&amp; rhs);
    // Return a set containing the exclusive-or of the specified &#39;lhs&#39; and
    // &#39;rhs&#39; sets (i.e., a set containing elements that are either in &#39;lhs&#39;,
    // but not &#39;rhs&#39;, or in &#39;rhs&#39;, but not &#39;lhs&#39;).

DayOfWeekSet operator-(const DayOfWeekSet&amp; lhs, const DayOfWeekSet&amp; rhs);
    // Return a set containing the subtraction of the specified &#39;rhs&#39; set from
    // the specified &#39;lhs&#39; set (i.e., a set containing elements that are in
    // &#39;lhs&#39;, but not in &#39;rhs&#39;).

bool operator==(const DayOfWeekSet&amp; lhs, const DayOfWeekSet&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; sets have the same value,
    // and &#39;false&#39; otherwise.  Two sets have the same value if they have the
    // same length and all the elements of one set are members of the other
    // set.

bool operator!=(const DayOfWeekSet&amp; lhs, const DayOfWeekSet&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; sets do not have the same
    // value, and &#39;false&#39; otherwise.  Two sets do not have the same value if
    // they differ in length or there exists an element of one set that is not
    // a member of the other set.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const DayOfWeekSet&amp; rhs);
    // Write the specified &#39;rhs&#39; set to the specified output &#39;stream&#39; in some
    // reasonable (single-line) format, and return a reference to &#39;stream&#39;.

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                          // -----------------------
                          // class DayOfWeekSet_Iter
                          // -----------------------

// CREATORS
inline
DayOfWeekSet_Iter::DayOfWeekSet_Iter()
: d_data(0)
, d_index(8)
{
}

inline
DayOfWeekSet_Iter::DayOfWeekSet_Iter(const DayOfWeekSet_Iter&amp; original)
: d_data(original.d_data)
, d_index(original.d_index)
{
}

inline
DayOfWeekSet_Iter::~DayOfWeekSet_Iter()
{
    BSLS_ASSERT_SAFE(0 == (d_data &amp; 1));  // lsb is unused and always 0
    BSLS_ASSERT_SAFE(d_index &gt;= 0);
    BSLS_ASSERT_SAFE(d_index &lt;= 8);
}

// MANIPULATORS
inline
DayOfWeekSet_Iter&amp;
DayOfWeekSet_Iter::operator=(const DayOfWeekSet_Iter&amp; rhs)
{
    d_data  = rhs.d_data;
    d_index = rhs.d_index;
    return *this;
}

inline
DayOfWeekSet_Iter DayOfWeekSet_Iter::operator++(int)
{
    DayOfWeekSet_Iter tmp(*this);
    this-&gt;operator++();
    return tmp;
}

inline
DayOfWeekSet_Iter DayOfWeekSet_Iter::operator--(int)
{
    DayOfWeekSet_Iter tmp(*this);
    this-&gt;operator--();
    return tmp;
}

// ACCESSORS
inline
const DayOfWeek::Enum&amp; DayOfWeekSet_Iter::operator*() const
{
    BSLS_ASSERT_SAFE(d_index &gt;= 1);
    BSLS_ASSERT_SAFE(d_index &lt;= 7);

    return s_dayOfWeekArray[d_index];
}

}  // close package namespace

// FREE OPERATORS
inline
bool bdlt::operator==(const DayOfWeekSet_Iter&amp; lhs,
                      const DayOfWeekSet_Iter&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.d_data == rhs.d_data);

    // If the data is not the same, either the objects were not initially the
    // same, or one has subsequently been modified.

    return lhs.d_index == rhs.d_index;
}

inline
bool bdlt::operator!=(const DayOfWeekSet_Iter&amp; lhs,
                      const DayOfWeekSet_Iter&amp; rhs)
{
    return !(lhs == rhs);
}

namespace bdlt {

                             // ------------------
                             // class DayOfWeekSet
                             // ------------------

// CLASS METHODS

                                  // Aspects

inline
int DayOfWeekSet::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// CREATORS
inline
DayOfWeekSet::DayOfWeekSet()
: d_days(0)
{
}

inline
DayOfWeekSet::DayOfWeekSet(const DayOfWeekSet&amp; original)
: d_days(original.d_days)
{
}

inline
DayOfWeekSet::~DayOfWeekSet()
{
    BSLS_ASSERT_SAFE(!(d_days &amp; 1));
}

// MANIPULATORS
inline
DayOfWeekSet&amp; DayOfWeekSet::operator=(const DayOfWeekSet&amp; rhs)
{
    d_days = rhs.d_days;
    return *this;
}

inline
DayOfWeekSet&amp; DayOfWeekSet::operator|=(const DayOfWeekSet&amp; rhs)
{
    d_days = static_cast&lt;unsigned char&gt;(d_days | rhs.d_days);
    return *this;
}

inline
DayOfWeekSet&amp; DayOfWeekSet::operator&amp;=(const DayOfWeekSet&amp; rhs)
{
    d_days = static_cast&lt;unsigned char&gt;(d_days &amp; rhs.d_days);
    return *this;
}

inline
DayOfWeekSet&amp; DayOfWeekSet::operator^=(const DayOfWeekSet&amp; rhs)
{
    d_days = static_cast&lt;unsigned char&gt;(d_days ^ rhs.d_days);
    return *this;
}

inline
DayOfWeekSet&amp; DayOfWeekSet::operator-=(const DayOfWeekSet&amp; rhs)
{
    const int mask = d_days &amp; rhs.d_days;
    d_days = static_cast&lt;unsigned char&gt;(d_days - mask);
    return *this;
}

inline
void DayOfWeekSet::add(DayOfWeek::Enum value)
{
    d_days = static_cast&lt;unsigned char&gt;(d_days | (1 &lt;&lt; value));
}

inline
bool DayOfWeekSet::remove(DayOfWeek::Enum value)
{
    const int  mask = 1 &lt;&lt; value;
    const bool rv   = d_days &amp; mask;
    d_days &amp;= static_cast&lt;unsigned char&gt;(~mask);
    return rv;
}

inline
void DayOfWeekSet::removeAll()
{
    d_days = 0;
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; DayOfWeekSet::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            unsigned char tmp;
            stream.getUint8(tmp);

            if (stream &amp;&amp; 0 == (tmp &amp; 1)) {
                d_days = tmp;
            }
            else {
                stream.invalidate();
            }
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }
    return stream;
}

// ACCESSORS
inline
bool DayOfWeekSet::areMembers(const DayOfWeekSet&amp; set) const
{
    return set.d_days == (d_days &amp; set.d_days);
}

inline
DayOfWeekSet::iterator DayOfWeekSet::begin() const
{
    return DayOfWeekSet::iterator(DayOfWeekSet_Iter(d_days, 1));
}

inline
DayOfWeekSet::iterator DayOfWeekSet::end() const
{
    return DayOfWeekSet::iterator(DayOfWeekSet_Iter(d_days, 8));
}

inline
bool DayOfWeekSet::isEmpty() const
{
    return 0 == d_days;
}

inline
bool DayOfWeekSet::isMember(DayOfWeek::Enum value) const
{
    const int mask = 1 &lt;&lt; value;
    return mask == (d_days &amp; mask);
}

inline
int DayOfWeekSet::length() const
{
    return bdlb::BitUtil::numBitsSet(static_cast&lt;unsigned int&gt;(d_days));
}

inline
DayOfWeekSet::reverse_iterator DayOfWeekSet::rbegin() const
{
    return DayOfWeekSet::reverse_iterator(end());
}

inline
DayOfWeekSet::reverse_iterator DayOfWeekSet::rend() const
{
    return DayOfWeekSet::reverse_iterator(begin());
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; DayOfWeekSet::bdexStreamOut(STREAM&amp; stream, int version) const
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            stream.putUint8(d_days);
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }
    return stream;
}


}  // close package namespace

// FREE OPERATORS
inline
bdlt::DayOfWeekSet bdlt::operator~(const DayOfWeekSet&amp; set)
{
    DayOfWeekSet tmp(set);
    tmp.d_days = static_cast&lt;unsigned char&gt;(~tmp.d_days &amp; 0xfe);
    return tmp;
}

inline
bool bdlt::operator==(const DayOfWeekSet&amp; lhs, const DayOfWeekSet&amp; rhs)
{
    return lhs.d_days == rhs.d_days;
}

inline
bool bdlt::operator!=(const DayOfWeekSet&amp; lhs, const DayOfWeekSet&amp; rhs)
{
    return lhs.d_days != rhs.d_days;
}

inline
bdlt::DayOfWeekSet bdlt::operator|(const DayOfWeekSet&amp; lhs,
                                   const DayOfWeekSet&amp; rhs)
{
    return DayOfWeekSet(lhs) |= rhs;
}

inline
bdlt::DayOfWeekSet bdlt::operator&amp;(const DayOfWeekSet&amp; lhs,
                                   const DayOfWeekSet&amp; rhs)
{
    return DayOfWeekSet(lhs) &amp;= rhs;
}

inline
bdlt::DayOfWeekSet bdlt::operator^(const DayOfWeekSet&amp; lhs,
                                   const DayOfWeekSet&amp; rhs)
{
    return DayOfWeekSet(lhs) ^= rhs;
}

inline
bdlt::DayOfWeekSet bdlt::operator-(const DayOfWeekSet&amp; lhs,
                                   const DayOfWeekSet&amp; rhs)
{
    return DayOfWeekSet(lhs) -= rhs;
}

inline
bsl::ostream&amp; bdlt::operator&lt;&lt;(bsl::ostream&amp; stream, const DayOfWeekSet&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}

// TRAITS SPECIALIZATIONS
namespace bslmf
{
template &lt;&gt;
struct IsBitwiseMoveable&lt;bdlt::DayOfWeekSet&gt; : ::bsl::true_type {};
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
