<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsc_timedchannelallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsc_timedchannelallocator<br/>
<small>
[<a class="el" href="group__btlsc.html">Package btlsc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide protocol for stream-based channel allocators with timeout.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsc.html">btlsc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Protocol Hierarchy</a> </li>
<li>
<a href="#3.2">Channel Allocation</a> </li>
<li>
<a href="#3.3">Asynchronous Events</a> </li>
<li>
<a href="#3.4">Timeouts</a> </li>
<li>
<a href="#3.5">Usage</a> </li>
<li>
<a href="#3.6">Server Side</a> </li>
<li>
<a href="#3.7">Client Side</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide protocol for stream-based channel allocators with timeout. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a> </td><td>blocking stream channel allocator w/timeout  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsc__timedcbchannelallocator.html" title="Provide protocol for stream-based channel allocators with timeout.">Component btlsc_timedcbchannelallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code>, that defines an abstract interface for a synchronous mechanism that allocates and deallocates synchronous channels having timeout capability; the allocation itself also has timeout capability. Each channel is an end point of a bi-directional stream-based communication connection to a peer; connection details, such as who the peer is, whether there is indeed one peer or multiple similar peers, and how the connection came to be, are not relevant to this channel-allocator protocol, and are therefore abstracted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="protocol_hierarchy"></a> <a class="anchor" id="description.protocol_hierarchy"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Protocol Hierarchy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code> forms the base of an interface hierarchy; other interfaces may be defined by direct public inheritance: <br/>
<br/>
<div class="fragment"><pre class="fragment">                  ,----------------------------.
                 ( <a class="code" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a> )
                  `----------------------------<span class="stringliteral">&#39;</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="channel_allocation"></a> <a class="anchor" id="description.channel_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Channel Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This protocol establishes methods for allocating synchronous, stream-based channels. Each allocation method blocks until (1) "success" -- the requested channel is allocated and its address returned to the user (in which case the <code>status</code> argument is not modified), (2) "interrupted" -- the operation was interrupted (e.g., via a timeout), the channel address is null, and <code>status</code> is set to a non-negative value (see below), or (3) "error" -- an implementation-dependent error occurred, the channel address is null, and <code>status</code> is less than -1. The user may retry interrupted operations with a reasonable expectation of success. An "error" status implies that the allocation is unlikely to succeed if retried, but does not <em>necessarily</em> invalidate the allocator. The <code>isInvalid</code> method may be used to confirm the occurrence of a permanent error. An allocation can <em>never</em> succeed once an allocator is invalid. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The meanings of the <code>status</code> value for an unsuccessful allocation (i.e., a null channel address) are summarized as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot;status&quot;</span>    meaning (only when returned channel address is null)
  --------    ----------------------------------------------------
  positive    Interruption by an <span class="stringliteral">&quot;asynchronous event&quot;</span>

  zero        Interruption by a user-requested timeout

  &lt; -1        Allocation operation unable to succeed at <span class="keyword">this</span> time
</pre></div><br/>
<br/>
 Note that unless asynchronous events are explicitly enabled (see below), they are ignored, and "status" will never be positive. Also note that, for consistency with non-blocking transport, a status of -1 is reserved for a "canceled" operation, which is not possible in this blocking protocol. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="asynchronous_events"></a> <a class="anchor" id="description.asynchronous_events"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Asynchronous Events: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Allocation methods in this protocol anticipate the possible occurrence of an "asynchronous event" (AE) during execution. A common example of an AE is a Unix signal, but note that a specific Unix signal, if not detected or implemented, <em>may</em> not result in an AE. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface cannot fully specify either the nature of or the behavior resulting from an AE, but certain restrictions can be (and are) imposed. By default, AEs are either ignored or, if that is not possible, cause an error. At the user's option, however, a concrete implementation can be authorized to return, if such occurrence is detected, with an "interrupted" status (leaving the allocator unaffected) upon the occurrence of an AE. Such authorizations are made explicitly by incorporating into the optional (trailing) integer <code>flags</code> argument to a method call the <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code> value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="timeouts"></a> <a class="anchor" id="description.timeouts"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Timeouts: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A timeout is registered by the caller, when a method is invoked, as a <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code> value indicating the absolute <em>system</em> time after which the operation should be interrupted. Information regarding the nature of an interruption is provided in the <code>status</code> value (see above). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The concrete allocator will make a "best effort" to honor the timeout request promptly, but no guarantee can be made as to the maximum duration of any particular allocation attempt. Any implementation of this interface will support a timeout granularity of ten milliseconds (0.01s) or less. The timeout is guaranteed <em>not</em> to occur before the specified time has passed. If a timeout is specified with a time that has already passed, the allocation will be attempted, but will not block. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The purpose of the <code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code> protocol is to isolate the act of requesting a connection from details such as who it will be to and which side initiated it. In this example we will consider both the Server and Client sides of a <code>my_Tick</code> reporting service. Since each side of this service could potentially be a library component, we do not want to "bake" into either side the details of how connections will be established. It is sufficient that, when a tick needs to be sent or received, a channel is obtained, the tick is transmitted, and the channel is returned to its allocator. Note that this example serves to illustrate the use of the <code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code> and does not represent production-quality software. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Tick {
      <span class="keywordtype">char</span>   d_name[5];
      <span class="keywordtype">double</span> d_bestBid;
      <span class="keywordtype">double</span> d_bestOffer;

    <span class="keyword">public</span>:
      my_Tick() { }
      my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker);
      my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker, <span class="keywordtype">double</span> bestBid, <span class="keywordtype">double</span> bestOffer);
      ~my_Tick() { assert(d_bestBid &gt; 0); };

      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> versionSelector) { <span class="keywordflow">return</span> 1; }

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write this value to the specified output &#39;stream&#39; using the</span>
          <span class="comment">// specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.</span>
          <span class="comment">// If &#39;stream&#39; is initially invalid, this operation has no effect.</span>
          <span class="comment">// If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but</span>
          <span class="comment">// otherwise unmodified.  Note that &#39;version&#39; is not written to</span>
          <span class="comment">// &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more</span>
          <span class="comment">// information on BDEX streaming of value-semantic types and</span>
          <span class="comment">// containers.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>

      <span class="keywordtype">void</span> <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(bsl::ostream&amp; stream) <span class="keyword">const</span>;
  };

  my_Tick::my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker)
  : d_bestBid(0)
  , d_bestOffer(0)
  {
     snprintf(d_name, <span class="keyword">sizeof</span> d_name, <span class="stringliteral">&quot;%s&quot;</span>, ticker);
  }

  my_Tick::my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker, <span class="keywordtype">double</span> bestBid, <span class="keywordtype">double</span> bestOffer)
  : d_bestBid(bestBid)
  , d_bestOffer(bestOffer)
  {
      snprintf(d_name, <span class="keyword">sizeof</span> d_name, <span class="stringliteral">&quot;%s&quot;</span>, ticker);
  }

  <span class="keywordtype">void</span> <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">my_Tick::print</a>(bsl::ostream&amp; stream)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      stream &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; d_name &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d_bestBid &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d_bestOffer
             &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;
  }

  <span class="keyword">inline</span>
  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> my_Tick&amp; tick)
  {
      tick.print(stream);
      <span class="keywordflow">return</span> stream;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">my_Tick::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putString(d_name);
          stream.putFloat64(d_bestBid);
          stream.putFloat64(d_bestOffer);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">my_Tick::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> temp1;
          stream.getString(temp1);
          <span class="keywordtype">int</span> maxLen = <span class="keyword">sizeof</span> d_name - 1;  <span class="comment">// the valid name length</span>
          <span class="keywordtype">int</span> len    = temp1.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>();
          <span class="keywordflow">if</span> (len &lt; maxLen) {
              strcpy(d_name, temp1.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>());
          }
          <span class="keywordflow">else</span> {
              strncpy(d_name, temp1.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>(), len);
              d_name[len] = 0;
          }
          stream.getFloat64(d_bestBid);
          stream.getFloat64(d_bestOffer);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 Let's also assume that we have a function that knows how to print platform neutral encodings of type <code>my_Tick</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> myPrintTick(bsl::ostream&amp; stream, <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> len)
      <span class="comment">// Print the value of the specified &#39;buffer&#39; interpreted as a</span>
      <span class="comment">// BDEX byte-stream representation of a &#39;my_Tick&#39; value, to the</span>
      <span class="comment">// specified &#39;stream&#39; or report an error to &#39;stream&#39; if &#39;buffer&#39; is</span>
      <span class="comment">// determined *not* to hold an encoding of a valid &#39;my_Tick&#39; value.</span>
  {
      my_Tick tick;
      <a class="code" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a> input(buffer, len);
      input &gt;&gt; tick;

      stream &lt;&lt; tick;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="server_side"></a> <a class="anchor" id="description.server_side"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Server Side: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Let's assume that we have a function that knows how to print platform neutral encodings of type <code>my_Tick</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #define VERSION_SELECTOR 20140601</span>
<span class="preprocessor"></span>
  <span class="keyword">static</span> <span class="keywordtype">int</span> calculateMyTickMessageSize()
      <span class="comment">// Calculate and return the number of bytes in a BDEX byte-stream</span>
      <span class="comment">// encoding of a (dummy) &#39;my_Tick&#39; value (called just once, see below).</span>
  {
      my_Tick dummy;
      <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> bos(VERSION_SELECTOR);
      bos &lt;&lt; dummy;
      <span class="keywordflow">return</span> bos.length();
  }

  <span class="keyword">static</span> <span class="keywordtype">int</span> myTickMessageSize()
      <span class="comment">// Return the number of bytes in a BDEX byte-stream encoding of a</span>
      <span class="comment">// &#39;my_Tick&#39; value without creating a runtime-initialized file-scope</span>
      <span class="comment">// static variable (which is link-order dependent).</span>
  {
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> MESSAGE_SIZE = calculateMyTickMessageSize();
      <span class="keywordflow">return</span> MESSAGE_SIZE;
  }
</pre></div><br/>
<br/>
 The following class illustrates how we might implement a tick-reporter server using just the <code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code> and <code><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a></code> protocols. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_TickReporter {
      <span class="comment">// This class implements a server that accepts connections, extracts</span>
      <span class="comment">// from each connection a single &#39;my_Tick&#39; value, and reports that</span>
      <span class="comment">// value to a console stream.  Both the acceptor and console stream</span>
      <span class="comment">// are supplied at construction.</span>

      <span class="keyword">enum</span> {
          ACCEPT_TIME_LIMIT = 300,  <span class="comment">// 5 minutes</span>
          READ_TIME_LIMIT   =  60   <span class="comment">// 1 minutes</span>
      };
      <a class="code" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a> *d_acceptor_p;  <span class="comment">// incoming connections</span>
      bsl::ostream&amp;                 d_console;     <span class="comment">// where to put tick info</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_TickReporter(<span class="keyword">const</span> my_TickReporter&amp;);
      my_TickReporter&amp; operator=(<span class="keyword">const</span> my_TickReporter&amp;);

    <span class="keyword">public</span>:
      my_TickReporter(bsl::ostream&amp;                 console,
                      <a class="code" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a> *acceptor);
          <span class="comment">// Create a synchronous tick-reporter using the specified</span>
          <span class="comment">// &#39;acceptor&#39; to establish incoming client connections, each</span>
          <span class="comment">// transmitting a single &#39;my_Tick&#39; value; write these values to the</span>
          <span class="comment">// specified &#39;console&#39; stream.  If the &#39;acceptor&#39; is idle for more</span>
          <span class="comment">// than five minutes, print a message to the &#39;console&#39; stream</span>
          <span class="comment">// supplied at construction and continue.  To guard against</span>
          <span class="comment">// malicious clients, a connection that does not produce a tick</span>
          <span class="comment">// value within one minute will be summarily dropped.</span>

      ~my_TickReporter();
          <span class="comment">// Destroy this server object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> reportTicker();
          <span class="comment">// Call &#39;d_acceptor_p&#39;s &#39;timedAllocateTimed&#39; to establish a</span>
          <span class="comment">// channel.</span>
  };

  my_TickReporter::my_TickReporter(bsl::ostream&amp;                 console,
                                   <a class="code" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a> *acceptor)
  : d_console(console)
  , d_acceptor_p(acceptor)
  {
      assert(&amp;d_console);
      assert(d_acceptor_p);
  }

  my_TickReporter::~my_TickReporter()
  {
      assert(&amp;d_console);
      assert(d_acceptor_p);
  }

  <span class="keywordtype">int</span> my_TickReporter::reportTicker()
  {
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> timeout(ACCEPT_TIME_LIMIT);
      <span class="keywordtype">int</span> status = 0;

      <span class="keywordflow">while</span> (1) {
          <a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> *newChannel =
                          d_acceptor_p-&gt;timedAllocateTimed(&amp;status, timeout);
          <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> nextTimeout(timeout);

          <span class="keywordflow">if</span> (newChannel) {     <span class="comment">// Successfully created a connection.</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span>                numBytes = ::myTickMessageSize();
              <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> now      = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();

              <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer = 0;
              <span class="keywordtype">int</span> ret = newChannel-&gt;<a class="code" href="classbtlsc_1_1TimedChannel.html#aa773c86182fbf9db87038eded3c100c0">timedBufferedRead</a>(&amp;status, &amp;buffer,
                                                      numBytes,
                                                      now + READ_TIME_LIMIT);
              <span class="keywordflow">if</span> (0 &gt;= ret) {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Error: The read operation timeout &quot;</span>
                               <span class="stringliteral">&quot;on this channel.&quot;</span>
                            &lt;&lt; bsl::endl;
                  d_acceptor_p-&gt;deallocate(newChannel);
              }
              <span class="keywordflow">else</span> {  <span class="comment">// Read successfully.</span>
                  ::myPrintTick(d_console, buffer, numBytes);
                  d_acceptor_p-&gt;deallocate(newChannel);
              }
              nextTimeout += ACCEPT_TIME_LIMIT;
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == status) {  <span class="comment">// Interrupted due to timeout event.</span>
              d_console &lt;&lt; <span class="stringliteral">&quot;Acceptor timed out, continuing...&quot;</span> &lt;&lt; bsl::endl;
              nextTimeout += ACCEPT_TIME_LIMIT;
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &gt; 0) {   <span class="comment">// Interrupted by unspecified event.</span>
              assert(0); <span class="comment">// Impossible, &quot;async interrupts&quot; not authorized.</span>
          }
          <span class="keywordflow">else</span> {         <span class="comment">// Allocation operation is unable to succeed.</span>
              assert(status &lt; 0);

              d_console &lt;&lt; <span class="stringliteral">&quot;Error: The channel allocator is not working now.&quot;</span>
                        &lt;&lt; bsl::endl;
              assert(0);
          }
      }
  }
</pre></div><br/>
<br/>
 The following is the server driver, which first creates supporting objects to construct the <code>reporter</code>, and then invokes <code>reportTicker</code> of the <code>reporter</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
  {
      <span class="keyword">enum</span> { DEFAULT_PORT = 5000 };

      <span class="keyword">const</span> <span class="keywordtype">int</span> portNumber = argc &gt; 1 ? atoi(argv[1]) : DEFAULT_PORT;

      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> address(btlso::IPv4Address::ANY, portNumber);
      btlso::Tcpipv4StreamSocketFactory sf;      <span class="comment">// concrete factory</span>
      btlsos::TimedCbChannelAcceptor acceptor(address, &amp;sf);

      <span class="keywordflow">if</span> (acceptor.<a class="code" href="classbtlsc_1_1TimedCbChannelAllocator.html#a40c1d76268ee3f52c53c384f49c1738b">isInvalid</a>()) {
           bsl::cout &lt;&lt; <span class="stringliteral">&quot;Error: Unable to create acceptor.&quot;</span> &lt;&lt; bsl::endl;
           <span class="keywordflow">return</span> -1;                                               <span class="comment">// RETURN</span>
      }

      my_TickReporter reporter(bsl::cout, &amp;acceptor);
      reporter.reportTicker();
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="client_side"></a> <a class="anchor" id="description.client_side"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Client Side: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to use this <code>my_Tick</code> reporting service, clients will need to know where such a service resides and how to establish such connections on demand. We will use the <code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code> protocol to abstract those details out of the stable software that generates (or forwards) ticks. For the purposes of this example, let's assume that ticks are generated in some ASCII format and arrive in fixed size chunks (e.g., 80 bytes) from a separate process. The client will ask the "allocator" instance for a new channel to send each tick until all ticks are sent. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span>
  <span class="keywordtype">int</span> parseTick(my_Tick *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> numBytes)
      <span class="comment">// Parse a tick value from the specified input &#39;buffer&#39; of the</span>
      <span class="comment">// specified &#39;numBytes&#39; and load that value into the specified</span>
      <span class="comment">// &#39;result&#39;.  Return 0 on success, and a non-zero value (with no effect</span>
      <span class="comment">// on &#39;result&#39;) otherwise.  The behavior is undefined unless</span>
      <span class="comment">// &#39;0 &lt;= numBytes&#39;.</span>
  {
      <span class="comment">// ...</span>

      <span class="keywordflow">return</span> 0;
  }

  <span class="keyword">class </span>my_TickerplantSimulator {
      <span class="comment">// Accept raw tick values in ASCII sent as fixed-sized packets via a</span>
      <span class="comment">// single &#39;btlsc::TimedChannel&#39; and send them synchronously one by one</span>
      <span class="comment">// to a peer (or similar peers) connected via channels provided via a</span>
      <span class="comment">// &#39;btlsc::TimedChannelAllocator&#39;.  Both the output channel allocator</span>
      <span class="comment">// and the input channel are supplied at construction.</span>

      <span class="keyword">enum</span> {
          CONNECT_TIME_LIMIT = 30,   <span class="comment">// 30 seconds</span>
          WRITE_TIME_LIMIT   = 10    <span class="comment">// 10 seconds</span>
      };
      <span class="keyword">enum</span> { MAX_PARSER_ERRORS = 3 };

      <a class="code" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a>
                               *d_connector_p;       <span class="comment">// outgoing connections</span>
      <a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a>      *d_input_p;           <span class="comment">// incoming packets</span>
      bsl::ostream&amp;             d_console;           <span class="comment">// where to write errors</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span>                 d_inputSize;         <span class="comment">// input packet size</span>
      <span class="keywordtype">int</span>                       d_parserErrorCount;  <span class="comment">// consecutive errors</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_TickerplantSimulator(<span class="keyword">const</span> my_TickerplantSimulator&amp;);
      my_TickerplantSimulator&amp; operator=(<span class="keyword">const</span> my_TickerplantSimulator&amp;);

    <span class="keyword">public</span>:
      my_TickerplantSimulator(bsl::ostream&amp;                 console,
                              <a class="code" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a> *connector,
                              <a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a>          *input,
                              <span class="keywordtype">int</span>                           inputSize);
          <span class="comment">// Create a non-blocking ticker-plant simulator using the specified</span>
          <span class="comment">// &#39;input&#39; channel to read ASCII tick records of the specified</span>
          <span class="comment">// &#39;inputSize&#39; and convert each record to a &#39;My_Tick&#39; structure;</span>
          <span class="comment">// each tick value is sent synchronously to a peer via a distinct</span>
          <span class="comment">// channel obtained from the specified &#39;connector&#39;, reporting any</span>
          <span class="comment">// errors to the specified &#39;console&#39;.  If &#39;connector&#39; fails or is</span>
          <span class="comment">// unable to succeed after 30 seconds, or if transmission itself</span>
          <span class="comment">// exceeds 10 seconds, display a message on &#39;console&#39; and abort the</span>
          <span class="comment">// transmission.  If three successive reads of the input channel</span>
          <span class="comment">// fail to produce a valid ticks, invalidate the channel and shut</span>
          <span class="comment">// down this simulator.  The behavior is undefined unless</span>
          <span class="comment">// &#39;0 &lt; inputSize&#39;.</span>

      <span class="keywordtype">int</span> sendTicker();
          <span class="comment">// Build &#39;My_Tick&#39; objects by reading from the &#39;d_input_p&#39; channel</span>
          <span class="comment">// and send the built tick, if it is valid, to the peer.  Return 0</span>
          <span class="comment">// on success, and a negative value otherwise.</span>

      ~my_TickerplantSimulator();
          <span class="comment">// Destroy this simulator object.</span>
  };

  my_TickerplantSimulator::my_TickerplantSimulator(
                                     bsl::ostream&amp;                 console,
                                     <a class="code" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a> *connector,
                                     <a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a>          *input,
                                     <span class="keywordtype">int</span>                           inputSize)
  : d_connector_p(connector)
  , d_console(console)
  , d_input_p(input)
  , d_inputSize(inputSize)
  , d_parserErrorCount(0)
  {
      assert(&amp;console);
      assert(connector);
      assert(input);
      assert(0 &lt; inputSize);
  }

  <span class="keywordtype">int</span> my_TickerplantSimulator::sendTicker()
  {
      <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer    = 0;
      <span class="keywordtype">int</span>         status    = 0;
      <span class="keywordtype">int</span>         augStatus = 0;

      <span class="keywordflow">while</span> (0 &lt; d_input_p-&gt;bufferedRead(&amp;augStatus, &amp;buffer, d_inputSize)) {
          my_Tick tick;
          <span class="keywordflow">if</span> (0 == ::parseTick(&amp;tick, buffer, d_inputSize)) {
              d_parserErrorCount = 0;  <span class="comment">// Successfully parsed tick value.</span>

              <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> now =
                    <a class="code" href="structbsls_1_1SystemTime.html#ab0ea90384d46487a1dce4487aaa12455">bsls::SystemTime::now</a>(<a class="code" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba4b4f6a6781cc76138225ba163ed717a8">bsls::SystemClockType::e_REALTIME</a>);

              <span class="comment">// Initiate a non-blocking timed allocate operation.</span>

              <a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> *newChannel =
                 d_connector_p-&gt;timedAllocateTimed(&amp;status,
                                                   now + CONNECT_TIME_LIMIT);
              <span class="keywordflow">if</span> (0 == newChannel) {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to install connect operation.&quot;</span>
                            &lt;&lt; bsl::endl;
              }
              <span class="keywordflow">else</span> {
                  <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> bos(VERSION_SELECTOR);
                  bos &lt;&lt; tick;
                  <span class="keywordtype">int</span> msgSize = bos.length();
                  <span class="keywordflow">if</span> (0 &gt;= newChannel-&gt;<a class="code" href="classbtlsc_1_1TimedChannel.html#adfb9b67e2675cf0bac48100380b7be46">timedWrite</a>(bos.data(),
                                                  msgSize,
                                                  now + WRITE_TIME_LIMIT)) {
                       d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable even to register a write&quot;</span>
                                    <span class="stringliteral">&quot; operation on this channel.&quot;</span>
                                 &lt;&lt; bsl::endl;
                  }
                  d_connector_p-&gt;deallocate(newChannel);
              }
          }
          <span class="keywordflow">else</span> {  <span class="comment">// parsing error</span>
              d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to parse tick data!&quot;</span> &lt;&lt; bsl::endl;

              ++d_parserErrorCount;

              <span class="keywordflow">if</span> (d_parserErrorCount &gt;= MAX_PARSER_ERRORS) {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Reached maximum parser error limit;&quot;</span>
                               <span class="stringliteral">&quot; invalidating input channel.&quot;</span> &lt;&lt; bsl::endl;

                  d_input_p-&gt;invalidate();
              }
              <span class="keywordflow">else</span> {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Continuing with next record.&quot;</span> &lt;&lt; bsl::endl;
              }
          }
      }

      <span class="keywordflow">if</span> (-1 == augStatus) {  <span class="comment">// EOF</span>
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> -1;                                                <span class="comment">// RETURN</span>
      }
  }

  my_TickerplantSimulator::~my_TickerplantSimulator()
  {
      assert(&amp;d_console);
      assert(d_connector_p);
      assert(0 &lt; d_inputSize);
      assert(0 &lt;= d_parserErrorCount);
      assert(d_parserErrorCount &lt;= MAX_PARSER_ERRORS);
  }
</pre></div><br/>
<br/>
 In order to make this <code>my_TickerplantSimulator</code> work, we will need to create those supporting objects first, then simply call <code>sendTicker</code> of the "simulator": <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
  {
      <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> DEFAULT_HOST = <span class="stringliteral">&quot;widget&quot;</span>;
      <span class="keyword">enum</span> { DEFAULT_PORT = 5000 };
      <span class="keyword">enum</span> { DEFAULT_SIZE = 80 };

      <span class="keyword">const</span> <span class="keywordtype">char</span> *hostName   = argc &gt; 1 ? argv[1]       : DEFAULT_HOST;
      <span class="keyword">const</span> <span class="keywordtype">int</span>   portNumber = argc &gt; 2 ? atoi(argv[2]) : DEFAULT_PORT;
      <span class="keyword">const</span> <span class="keywordtype">int</span>   inputSize  = argc &gt; 3 ? atoi(argv[3]) : DEFAULT_SIZE;

      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> address;
      <a class="code" href="structbtlso_1_1ResolveUtil.html#a797f7903638fd37e76bd39d9f7a43bb4">btlso::ResolveUtil&lt;btlso::IPv4Address&gt;::getAddress</a>(&amp;address, hostName);
      address.<a class="code" href="classbtlso_1_1IPv4Address.html#a0db9b6717cd8bd435caeeb46a9bbd818">setPortNumber</a>(portNumber);
      <a class="code" href="classbtlso_1_1InetStreamSocketFactory.html">btlso::InetStreamSocketFactory</a> sf;
      btlsos::TimedCbChannelConnector connector(address, &amp;sf);

      my_TickerplantSimulator simulator(bsl::cout,
                                        &amp;connector,
                                        input,
                                        inputSize);
      assert(0 == simulator.sendTicker());

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Please remember that these example code snippets are intended to illustrate the use of <code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code> and do not represent production-quality software. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:14 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
