<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslalg_rbtreenode.h                                                -*-C++-*-
#ifndef INCLUDED_BSLALG_RBTREENODE
#define INCLUDED_BSLALG_RBTREENODE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide a base class for a red-black binary tree node.
//
//@CLASSES:
//  bslalg::RbTreeNode: base class for a red-black binary tree node
//
//@SEE_ALSO: bslalg_rbtreeutil
//
//@DESCRIPTION: This component provides a single POD-like class, &#39;RbTreeNode&#39;,
// used to represent a node in a red-black binary search tree.  An &#39;RbTreeNode&#39;
// provides the address to its parent, left-child, and right-child nodes, as
// well as providing a &quot;color&quot; (red or black).  &#39;RbTreeNode&#39; does not, however,
// contain &quot;payload&quot; data (e.g., a value), as it is intended to work with
// generalized tree operations (see &#39;bslalg_rbtreenodeutil&#39;).  Clients creating
// a red-black binary search tree must define their own node type that
// incorporates &#39;RbTreeNode&#39; (generally via inheritance), and that maintains
// the &quot;key&quot; value and any associated data.
//
///Storing Color Information
///-------------------------
// To reduce the memory footprint of the &#39;RbTreeNode&#39;, the color information is
// stored at the least-significant-bit (LSB) of the parent node.  The address
// of the parent node and the color can be accessed through bit-wise
// operations.  This is possible because all memory addresses are at least
// 4-bytes aligned, therefore, the 2 LSB of any pointer are always 0.
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Creating a Function to Print a Red Black Tree
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates creating a function that prints, to a &#39;FILE&#39;, a
// tree of &#39;RbTreeNode&#39; objects.
//
// First, we define the signature of a function, &#39;printTree&#39;, that accepts, in
// addition to an output file and root node, a function pointer argument
// (supplied by clients) used to print each node&#39;s value, note that a node&#39;s
// value is not accessible through &#39;RbTreeNode&#39;:
//..
//  void printTree(FILE             *output,
//                 const RbTreeNode *rootNode,
//                 void (*printNodeValueCallback)(FILE *, const RbTreeNode *))
//  {
//..
// Now, we define the body of &#39;printTree&#39;, which is a recursive function that
// performs a prefix traversal of the supplied binary tree, printing the value
// and color of &#39;rootNode&#39; before recursively printing its left and then right
// sub-trees.
//..
//      if (0 == rootNode) {
//          return;                                                   // RETURN
//      }
//      fprintf(output, &quot; [ &quot;);
//
//      // Print the value and color of &#39;rootNode&#39;.
//
//      printNodeValueCallback(output, rootNode);
//      fprintf(output,
//              &quot;: %s&quot;,
//              rootNode-&gt;color() == RbTreeNode::BSLALG_RED ? &quot;RED&quot; : &quot;BLACK&quot;);
//
//      // Recursively call &#39;printTree&#39; on the left and right sub-trees.
//
//      printTree(output, rootNode-&gt;leftChild(), printNodeValueCallback);
//      printTree(output, rootNode-&gt;rightChild(), printNodeValueCallback);
//      fprintf(output, &quot; ]&quot;);
//  }
//..
// Notice that we use &#39;FILE&#39; in the context of this usage example to avoid a
// dependency of standard library streams.  Finally, we will use &#39;printTree&#39; to
// print a description of a tree in the next example.
//
///Example 2: Creating a Simple Red-Black Tree
///- - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates creating a simple tree of integer values using
// &#39;RbTreeNode&#39;.  Note that, in practice, clients should use associated
// utilities to manage such a tree (see &#39;bslalg_rbtreenodeutil&#39;).
//
// First, we define a node-type, &#39;IntTreeNode&#39;, that inherits from
//&#39;RbTreeNode&#39;:
//..
//  struct IntTreeNode : public RbTreeNode {
//      // A red-black tree node containing an integer data-value.
//
//      int d_value;  // &quot;payload&quot; value represented by the node
//  };
//..
// Then, we define a function &#39;printIntNodeValue&#39; to print the value of an
// integer node.  Note that this function&#39;s signature matches that
// required by &#39;printTree&#39; (defined in the preceding example):
//..
//  void printIntTreeNodeValue(FILE *output, const RbTreeNode *node)
//  {
//     BSLS_ASSERT(0 != node);
//
//     fprintf(output, &quot;%d&quot;, static_cast&lt;const IntTreeNode*&gt;(node)-&gt;d_value);
//  }
//..
// Next, we define &#39;main&#39; for our test, and create three nodes that we&#39;ll use
// to construct a tree:
//..
//  int main(int argc, const char *argv[])
//  {
//      IntTreeNode A, B, C;
//..
// Then, we describe the structure of the tree we wish to construct.
//..
//
//                A (value: 2, BLACK)
//              /       \.
//             /         \.
//  B (value: 1, RED)   C ( value: 3, RED )
//..
// Now, we set the properties for the nodes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; to form a valid
// tree whose structure matches that description:
//..
//      A.d_value = 2;
//      A.setColor(RbTreeNode::BSLALG_BLACK);
//      A.setParent(0);
//      A.setLeftChild(&amp;B);
//      A.setRightChild(&amp;C);
//
//      B.d_value = 1;
//      B.setColor(RbTreeNode::BSLALG_RED);
//      B.setParent(&amp;A);
//      B.setLeftChild(0);
//      B.setRightChild(0);
//
//      C.d_value = 3;
//      C.setColor(RbTreeNode::BSLALG_RED);
//      C.setParent(&amp;A);
//      C.setLeftChild(0);
//      C.setRightChild(0);
//..
// Finally, we use the &#39;printTree&#39; function with the &#39;printIntTreeNodeValue&#39;
// function to print the structure of our tree to &#39;stdout&#39;:
//..
//      printTree(stdout, &amp;A, printIntTreeNodeValue);
//  }
//..
// Resulting in a single line of console output:
//..
//  [ 2: BLACK [ 1: RED ] [ 3: RED ] ]
//..
//
///Example 3: Creating a Function To Validate a Red-Black Tree
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates creating a function to validate the properties of
// a red-black tree.
//
// First, we declare the signature of a function &#39;validateRbTree&#39;, which takes
// two arguments: (1) the address to the root node of a tree, and (2) a
// comparator function, which is used to compare the payload values of the tree
// nodes.  Note that the parameterized comparator is needed because a node&#39;s
// value is not accessible through the supplied &#39;RbTreeNode&#39;.
//..
//  template &lt;class NODE_COMPARATOR&gt;
//  int validateRbTree(const RbTreeNode       *rootNode,
//                     const NODE_COMPARATOR&amp;  comparator);
//      // Return the uniform number of black nodes between every leaf node in
//      // the tree and the specified &#39;rootNode&#39;, 0 if &#39;rootNode&#39; is 0, and a
//      // negative value if &#39;rootNode&#39; does not refer to a valid red-black
//      // binary-search tree that is ordered according to the specified
//      // &#39;comparator&#39;.  &#39;rootNode&#39; is considered a valid red-black binary
//      // search-tree if it obeys the following rules:
//      //
//      //: 1 All nodes in the left sub-tree of &#39;rootNode&#39; are ordered at or
//      //:   before &#39;rootNode&#39; (as determined by &#39;comparator&#39;), and all nodes
//      //:   in the right sub-tree are ordered at or after &#39;rootNode&#39;.
//      //:
//      //: 2 Both children of &#39;rootNode&#39; refer to &#39;rootNode&#39; as a parent.
//      //:
//      //: 3 If &#39;rootNode&#39; is red, its children are either black or 0.
//      //:
//      //: 4 Every path from &#39;rootNode&#39; to a leaf contains the same number of
//      //:   black nodes (the uniform number of black nodes in every path is
//      //:   returned by this function if valid).
//      //:
//      //: 5 Rules (1-4) are obeyed, recursively, by the left and right
//      //:   sub-trees of &#39;rootNode&#39;.
//      //
//      // Note that this particular specification of the constraints of a
//      // red-black tree does not require the presense of black-colored NIL
//      // leaf-nodes; instead NULL children are implicitly assumed to be NIL
//      // leaf-nodes (as is typically the case for C/C++ implementations).
//      // This specification also does not require the root node to be
//      // colored black, as there&#39;s no practical benefit to enforcing that
//      // constraint.
//..
// Then, we declare the signature for an auxiliary function,
// &#39;validateRbTreeRaw&#39;, that accepts, additionally, the address of minimum
// and maximum value nodes, and is needed to recursively apply rule 1:
//..
//  template &lt;class NODE_COMPARATOR&gt;
//  int validateRbTreeRaw(const RbTreeNode *rootNode,
//                        const RbTreeNode *minNodeValue,
//                        const RbTreeNode *maxNodeValue,
//                        NODE_COMPARATOR   comparator);
//
//      // Return the uniform number of black nodes between every leaf node in
//      // the tree and the specified &#39;rootNode&#39;, 0 if &#39;rootNode&#39; is 0, and a
//      // negative value if (1) &#39;rootNode&#39; does not refer to a valid red-black
//      // binary search tree that is ordered according to the specified
//      // &#39;comparator&#39;, (2) the specified &#39;minNodeValue&#39; is not 0 and there is
//      // at least 1 node in the tree ordered before &#39;minNodeValue&#39;, or (3)
//      // the specified &#39;maxNodeValue&#39; is not 0 and there is at least 1 node
//      // in the tree ordered after &#39;maxNodeValue&#39;.
//..
// Now, we define the implementation of &#39;validateRbTree&#39;, which simply
// delegates to &#39;validateRbTreeRaw&#39;.
//..
//  template &lt;class NODE_COMPARATOR&gt;
//  int validateRbTree(const RbTreeNode *rootNode,
//                     NODE_COMPARATOR   comparator)
//  {
//      return validateRbTreeRaw(rootNode, 0, 0, comparator);
//  }
//..
// Finally, we define the implementation of &#39;validateRbTreeRaw&#39;, which tests if
// &#39;rootNode&#39; violates any of the rules defined in the &#39;validateRbTree&#39; method
// documentation, and then recursively calls &#39;validateRbTreeRaw&#39; on the left
// and right sub-trees or &#39;rootNode&#39;:
//..
//  template &lt;class NODE_COMPARATOR&gt;
//  int validateRbTreeRaw(const RbTreeNode *rootNode,
//                        const RbTreeNode *minNodeValue,
//                        const RbTreeNode *maxNodeValue,
//                        NODE_COMPARATOR   comparator)
//  {
//      enum { INVALID_RBTREE = -1 };
//
//      // The black-height of a empty tree is considered 0.
//
//      if (0 == rootNode) {
//          return 0;                                                 // RETURN
//      }
//
//      // Rule 1.
//
//      if ((minNodeValue &amp;&amp; comparator(*rootNode, *minNodeValue)) ||
//          (maxNodeValue &amp;&amp; comparator(*maxNodeValue, *rootNode))) {
//          return INVALID_RBTREE;                                    // RETURN
//      }
//
//      // Rule 2.
//
//      const RbTreeNode *left  = rootNode-&gt;leftChild();
//      const RbTreeNode *right = rootNode-&gt;rightChild();
//      if ((left  &amp;&amp; left-&gt;parent()  != rootNode) ||
//          (right &amp;&amp; right-&gt;parent() != rootNode)) {
//          return INVALID_RBTREE;                                    // RETURN
//      }
//
//      // Rule 3.
//
//      if (RbTreeNode::BSLALG_RED == rootNode-&gt;color()) {
//          if ((left  &amp;&amp; left-&gt;color()  != RbTreeNode::BSLALG_BLACK) ||
//              (right &amp;&amp; right-&gt;color() != RbTreeNode::BSLALG_BLACK)) {
//              return INVALID_RBTREE;                                // RETURN
//          }
//      }
//
//      // Recursively validate the left and right sub-tree&#39;s and obtain their
//      // black-height in order to apply rule 5.
//
//      int leftDepth  = validateRbTreeRaw(rootNode-&gt;leftChild(),
//                                         minNodeValue,
//                                         rootNode,
//                                         comparator);
//
//      int rightDepth = validateRbTreeRaw(rootNode-&gt;rightChild(),
//                                         rootNode,
//                                         maxNodeValue,
//                                         comparator);
//
//      if (leftDepth &lt; 0 || rightDepth &lt; 0) {
//          return INVALID_RBTREE;                                    // RETURN
//      }
//
//      // Rule 4.
//
//      if (leftDepth != rightDepth) {
//          return INVALID_RBTREE;                                    // RETURN
//      }
//
//      return (rootNode-&gt;color() == RbTreeNode::BSLALG_BLACK)
//          ? leftDepth + 1
//          : leftDepth;
//  }
//..


#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {
namespace bslalg {

                        // ================
                        // class RbTreeNode
                        // ================

class RbTreeNode {
    // This POD-like &#39;class&#39; describes a node suitable for use in a red-black
    // binary search tree, holding the addresses of the parent, left-child, and
    // right-child nodes (any of which may be 0), as well as a &quot;color&quot; (red or
    // black).  This class is a &quot;POD-like&quot; to facilitate efficient allocation
    // and use in the context of a container implementation.  In order to meet
    // the essential requirements of a POD type, this &#39;class&#39; does not define a
    // constructor or destructor.  However its data members are private.  Since
    // this class will be aligned to a word boundary, a pointer type will be a
    // multiple of 4.  This class use this property to reduce its size by
    // storing the color information in the least significant bit of the parent
    // pointer.  Note that this type does not contain any &quot;payload&quot; member
    // data: Clients creating a red-black binary search tree must define an
    // appropriate node type that incorporates &#39;RbTreeNode&#39; (generally via
    // inheritance), and that holds the &quot;key&quot; value and any associated data.

  public:
    // TYPES
    enum Color{
        BSLALG_RED   = 0,
        BSLALG_BLACK = 1
    };

  private:
    // DATA
    RbTreeNode *d_parentWithColor_p;  // parent of this node (may be 0) with
                                      // the color information stored in the
                                      // least significant bit

    RbTreeNode *d_left_p;             // left-child of this node (may be 0)

    RbTreeNode *d_right_p;            // right-child of this node (may be 0)


  private:
    // PRIVATE CLASS METHODS
    static bsls::Types::UintPtr toInt(RbTreeNode *value);
        // Return the specified &#39;value&#39; as an &#39;unsigned int&#39;.

    static RbTreeNode *toNode(bsls::Types::UintPtr value);
        // Return the specified &#39;value&#39; as &#39;RbTreeNode *&#39;.

  public:
    //! RbTreeNode() = default;
        // Create a &#39;RbTreeNode&#39; object having uninitialized values.

    //! RbTreeNode(const RbTreeNode&amp; original) = default;
        // Create a &#39;RbTreeNode&#39; object having the same value as the specified
        // &#39;original&#39; object.

    //! ~RbTreeNode() = default;
        // Destroy this object.

    // MANIPULATORS
    //! RbTreeNode&amp; operator= (const RbTreeNode&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.

    void makeBlack();
        // Set the color of this node to black.  Note that this operation is
        // at least as fast as (and potentially faster than) &#39;setColor&#39;.

    void makeRed();
        // Set the color of this node to red.    Note that this operation is
        // at least as fast as (and potentially faster than) &#39;setColor&#39;.

    void setParent(RbTreeNode *address);
        // Set the parent of this node to the specified &#39;address&#39;.  If
        // &#39;address&#39; is 0, then this node will have not have a parent node
        // (i.e., it will be the root node).  The behavior is undefined unless
        // &#39;address&#39; is aligned to at least two bytes.

    void setLeftChild(RbTreeNode *address);
        // Set the left child of this node to the specified &#39;address&#39;.  If
        // &#39;address&#39; is 0, then this node will not have a left child.

    void setRightChild(RbTreeNode *address);
        // Set the right child of this node to the specified &#39;address&#39;.  If
        // &#39;address&#39; is 0, then this node will not have a right child.

    void setColor(Color value);
        // Set the color of this node to the specified &#39;value&#39;.

    void toggleColor();
        // Set the color of this node to the alternative color.  If this
        // node&#39;s color is red, set it to black, and set it to red otherwise.
        // Note that this operation is at least as fast as (and potentially
        // faster than) &#39;setColor&#39;.

    void reset(RbTreeNode *parent,
               RbTreeNode *leftChild,
               RbTreeNode *rightChild,
               Color       color);
        // Reset this object to have the specified &#39;parent&#39;, &#39;leftChild&#39;,
        // &#39;rightChild&#39;, and &#39;color&#39; property values.

    RbTreeNode *parent();
        // Return the address of the (modifiable) parent of this node if one
        // exists, and 0 otherwise.

    RbTreeNode *leftChild();
        // Return the address of the (modifiable) left child of this node if
        // one exists, and 0 otherwise.

    RbTreeNode *rightChild();
        // Return the address of the (modifiable) right child of this node if
        // one exists, and 0 otherwise.

    // ACCESSORS
    const RbTreeNode *parent() const;
        // Return the address of the parent of this node if one exists, and 0
        // otherwise.

    bool isBlack() const;
        // Return &#39;true&#39; if this node is black.

    bool isRed() const;
        // Return &#39;true&#39; if this node is red.

    const RbTreeNode *leftChild() const;
        // Return the address of the left child of this node if one exists,
        // and 0 otherwise.

    const RbTreeNode *rightChild() const;
        // Return the address of the right child of this node if one exists,
        // and 0 otherwise.

    Color color() const;
        // Return the color of this node.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

// PRIVATE METHODS
inline
bsls::Types::UintPtr RbTreeNode::toInt(RbTreeNode *value)
{
    return reinterpret_cast&lt;bsls::Types::UintPtr&gt;(value);
}

inline
RbTreeNode *RbTreeNode::toNode(bsls::Types::UintPtr value)
{
    return reinterpret_cast&lt;RbTreeNode *&gt;(value);
}

// MANIPULATORS
inline
void RbTreeNode::makeBlack()
{
    d_parentWithColor_p = toNode(toInt(d_parentWithColor_p) | 0x01);
}

inline
void RbTreeNode::makeRed()
{
    d_parentWithColor_p = toNode(toInt(d_parentWithColor_p) &amp; ~0x01);
}

inline
void RbTreeNode::setParent(RbTreeNode *address)
{
    BSLS_ASSERT_SAFE(0 == (toInt(address) &amp; 0x01));

    d_parentWithColor_p =
                  toNode(toInt(address) | (toInt(d_parentWithColor_p) &amp; 0x01));
}

inline
void RbTreeNode::setLeftChild(RbTreeNode *address)
{
    d_left_p = address;
}

inline
void RbTreeNode::setRightChild(RbTreeNode *address)
{
    d_right_p = address;
}

inline
void RbTreeNode::setColor(Color value)
{
    d_parentWithColor_p = toNode((toInt(d_parentWithColor_p) &amp; ~0x01) | value);
}

inline
void RbTreeNode::toggleColor()
{
    BSLMF_ASSERT(0 == BSLALG_RED);
    BSLMF_ASSERT(1 == BSLALG_BLACK);

    d_parentWithColor_p = toNode(toInt(d_parentWithColor_p) ^ 0x01);
}

inline
void RbTreeNode::reset(RbTreeNode *parent,
                       RbTreeNode *leftChild,
                       RbTreeNode *rightChild,
                       Color       color)
{
    BSLS_ASSERT_SAFE(0 == (toInt(parent) &amp; 0x01));

    d_parentWithColor_p = toNode(toInt(parent) | color);
    d_left_p = leftChild;
    d_right_p = rightChild;
}

inline
RbTreeNode *RbTreeNode::parent()
{
    return toNode(toInt(d_parentWithColor_p) &amp; ~0x01);
}

inline
RbTreeNode *RbTreeNode::leftChild()
{
    return d_left_p;
}

inline
RbTreeNode *RbTreeNode::rightChild()
{
    return d_right_p;
}

// ACCESSORS
inline
const RbTreeNode *RbTreeNode::parent() const
{
    return toNode(toInt(d_parentWithColor_p) &amp; ~0x01);
}

inline
bool RbTreeNode::isBlack() const
{
    return toInt(d_parentWithColor_p) &amp; 0x01;
}

inline
bool RbTreeNode::isRed() const
{
    return !isBlack();
}

inline
const RbTreeNode *RbTreeNode::leftChild() const
{
    return d_left_p;
}

inline
const RbTreeNode *RbTreeNode::rightChild() const
{
    return d_right_p;
}

inline
RbTreeNode::Color RbTreeNode::color() const
{
    return static_cast&lt;Color&gt;(toInt(d_parentWithColor_p) &amp; 0x01);
}

}  // close namespace bslalg
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
