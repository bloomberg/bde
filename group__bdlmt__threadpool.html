<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlmt_threadpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlmt_threadpool<br/>
<small>
[<a class="el" href="group__bdlmt.html">Package bdlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide portable implementation for a dynamic pool of threads.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlmt.html">bdlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Synchronous Signals on Unix</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Setting ThreadPool Attributes</a> </li>
<li>
<a href="#3.3.2">The "void function/void pointer" Interface</a> </li>
<li>
<a href="#3.3.3">The Functor Interface</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide portable implementation for a dynamic pool of threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a> </td><td>portable dynamic thread pool  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a portable and efficient implementation of a thread pool that can be used to distribute various user-defined functions ("jobs") to separate threads and execute the jobs concurrently. The thread pool manages a dynamic set of processing threads, adding or removing threads to manage load, based upon user-defined parameters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The pool uses a queue mechanism to distribute work among the threads. Jobs are queued for execution as they arrive, and each queued job is processed by the next available thread. If no threads are available, new threads are created dynamically (up to the application defined maximum number). If the maximum number of concurrent threads has been reached, new jobs will remain enqueued until a thread becomes available. If the threads become idle for longer than a user-defined maximum idle time, they are automatically destroyed, releasing unused resources. A client-defined minimum number of threads is always maintained even when there is no work to be done. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The thread pool provides two interfaces for specifying jobs: the commonly used "void function/void pointer" interface and the more versatile functor based interface. The void function/void pointer interface allows callers to use a C-style function to be executed as a job. The application need only specify the address of the function, and a single void pointer argument, to be passed to the function. The specified function will be invoked with the specified argument by the processing thread. The functor based interface allows for flexible job execution such as the invocation of member functions or the passing of multiple user-defined arguments. See the <code>bdef</code> package documentation for more on functors and their usage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An application can tune the thread pool by adjusting the minimum and maximum number of threads in the pool, and the maximum amount of time that dynamically created threads can idle before being destroyed. To avoid unnecessary and inefficient thread creation/destruction, an application should select a value for the minimum number of threads that reflects the expected average load. A higher value for the maximum number of threads can be used to handle periodic bursts. An application can also specify the attributes of the threads in the pool (e.g., thread priority or stack size), by providing a <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a></code> object with the desired values set. See <code>bslmt_threadutil</code> package documentation for a description of <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Thread pools are ideal for developing multi-threaded server applications. A server need only package client requests to execute as jobs, and <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code> will handle the queue management, thread management, and request dispatching. Thread pools are also well suited for parallelizing certain types of application logic. Without any complex or redundant thread management code, an application can easily create a thread pool, enqueue a series of jobs to be executed, and wait until all the jobs have executed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code> class is both <em>fully thread-safe</em> (i.e., all non-creator methods can correctly execute concurrently), and is <em>thread-enabled</em> (i.e., the class does not function correctly in a non-multi-threading environment). See <code>bsldoc_glossary</code> for complete definitions of <em>fully thread-safe</em> and <em>thread-enabled</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synchronous_signals_on_unix"></a> <a class="anchor" id="description.synchronous_signals_on_unix"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Synchronous Signals on Unix: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A thread pool ensures that, on unix platforms, all the threads in the pool block all asynchronous signals. Specifically all the signals, except the following synchronous signals are blocked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>SIGBUS SIGFPE SIGILL SIGSEGV SIGSYS SIGABRT SIGTRAP SIGIOT </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates the use of a <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code> to parallelize a segment of program logic. The example implements a multi-threaded file search utility. The utility searches multiple files for a string, similar to the Unix command <code>fgrep</code>; the use of a <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code> allows the utility to search multiple files concurrently. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The example program will take as input a string and a list of files to search. The program creates a <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code>, and then enqueues a single "job" for each file to be searched. Each thread in the pool will take a job from the queue, open the file, and search for the string. If a match is found, the job adds the filename to an array of matching filenames. Because this array of filenames is shared across multiple jobs and across multiple threads, access to the array is controlled via a <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="setting_threadpool_attributes"></a> <a class="anchor" id="usage.setting_threadpool_attributes"></a> <a class="anchor" id="description.usage.setting_threadpool_attributes"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Setting ThreadPool Attributes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>To get started, we declare thread attributes, to be used in constructing the thread pool. In this example, our choices for minimum search threads and maximum idle time are arbitrary; we don't expect the thread pool to become idle, so the thread pool should not begin to delete unused threads before the program terminates. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>However, a maximum number of 50 threads is meaningful, and may affect overall performance. The maximum should cover the expected peak, in this case, the maximum number of files to search. However, if the maximum is too large for a given platform, it may cause a bottleneck as the operating system spends significant resources switching context among multiple threads. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #define MIN_SEARCH_THREADS     10</span>
<span class="preprocessor"></span><span class="preprocessor">   #define MAX_SEARCH_THREADS     50</span>
<span class="preprocessor"></span><span class="preprocessor">   #define MAX_SEARCH_THREAD_IDLE 100 // use a very short idle time since new</span>
<span class="preprocessor">                                      // jobs will arrive only at startup</span>
</pre></div><br/>
<br/>
 Below is the structure that will be used to pass arguments to the file search function. Since each job will be searching a separate file, a distinct instance of the structure will be used for each job. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>my_FastSearchJobInfo {
       <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>        *d_word;    <span class="comment">// word to search for</span>
       <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>        *d_path;    <span class="comment">// path of the file to search</span>
       <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>             *d_mutex;   <span class="comment">// mutex to control access to the</span>
                                            <span class="comment">// result file list</span>
       <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a> *d_outList; <span class="comment">// list of matching files</span>
   };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_~22void_function~2Fvoid_pointer~22_interface"></a> <a class="anchor" id="usage.the_~22void_function~2Fvoid_pointer~22_interface"></a> <a class="anchor" id="description.usage.the_~22void_function~2Fvoid_pointer~22_interface"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>The "void function/void pointer" Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>myFastSearchJob</code> is the search function to be executed as a job by threads in the thread pool, matching the "void function/void pointer" interface. The single <code>void *</code> argument is received and cast to point to a 'struct my_FastSearchJobInfo', which then points to the search string and a single file to be searched. Note that different <code>my_FastSearchInfo</code> structures for the same search request will differ only in the attribute <code>d_path</code>, which points to a specific filename among the set of files to be searched; other fields will be identical across all structures for a given Fast Search. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See the following section for an illustration of the functor interface. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keyword">static</span> <span class="keywordtype">void</span> myFastSearchJob(<span class="keywordtype">void</span> *arg)
   {
       myFastSearchJobInfo *job =  (myFastSearchJobInfo*)arg;
       FILE *file;

       file = fopen(job-&gt;d_path-&gt;c_str(), <span class="stringliteral">&quot;r&quot;</span>);

       <span class="keywordflow">if</span> (file) {
           <span class="keywordtype">char</span>  buffer[1024];
           <span class="keywordtype">size_t</span> nread;
           <span class="keywordtype">int</span> wordLen = job-&gt;d_word-&gt;<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>();
           <span class="keyword">const</span> <span class="keywordtype">char</span> *word = job-&gt;d_word-&gt;<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>();

           nread = fread(buffer, 1, <span class="keyword">sizeof</span>(buffer) - 1, file);
           <span class="keywordflow">while</span>(nread &gt;= wordLen) {
               buffer[nread] = 0;
               <span class="keywordflow">if</span> (strstr(buffer, word)) {
</pre></div><br/>
<br/>
 If we find a match, we add the file to the result list and return. Since the result list is shared among multiple processing threads, we use a mutex lock to regulate access to the list. We use a <code><a class="el" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard</a></code> to manage access to the mutex lock. This template object acquires a mutex lock on <code>job-&gt;d_mutex</code> at construction, releases that lock on destruction. Thus, the mutex will be locked within the scope of the <code>if</code> block, and released when the program exits that scope. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See <code>bslmt_threadutil</code> for information about the <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code> class, and component <code>bslmt_lockguard</code> for information about the <code><a class="el" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard</a></code> template class. <br/>
<br/>
<div class="fragment"><pre class="fragment">                <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> lock(job-&gt;d_mutex);
                job-&gt;d_outList-&gt;push_back(*job-&gt;d_path);
                <span class="keywordflow">break</span>;  <span class="comment">// bslmt::LockGuard destructor unlocks mutex.</span>
            }
            memcpy(buffer, &amp;buffer[nread - wordLen - 1], wordLen - 1);
            nread = fread(buffer + wordLen - 1, 1, <span class="keyword">sizeof</span>(buffer) - wordLen,
                          file);
        }
        fclose(file);
       }
   }
</pre></div><br/>
<br/>
 Routine <code>myFastSearch</code> is the main driving routine, taking three arguments: a single string to search for (<code>word</code>), a list of files to search, and an output list of files. When the function completes, the file list will contain the names of files where a match was found. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">void</span>  myFastSearch(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;              word,
                      <span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp; fileList,
                      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp;       outFileList)
   {
       bdlmqq::Mutex     mutex;
       bdlmqq::ThreadAttributes defaultAttributes;
</pre></div><br/>
<br/>
 We initialize the thread pool using default thread attributes. We then start the pool so that the threads can begin while we prepare the jobs. <br/>
<br/>
<div class="fragment"><pre class="fragment">       <a class="code" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a> pool(defaultAttributes,
                              MIN_SEARCH_THREADS,
                              MAX_SEARCH_THREADS,
                              MAX_SEARCH_THREAD_IDLE);

       <span class="keywordflow">if</span> (0 != pool.start()) {
           bsl::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to start minimum number of threads.\n&quot;</span>;
           exit(1);
       }
</pre></div><br/>
<br/>
 For each file to be searched, we create the job info structure that will be passed to the search function and add the job to the pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As noted above, all jobs will share a single mutex to guard the output file list. Function <code>myFastSearchJob</code> uses a <code><a class="el" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard</a></code> on this mutex to serialize access to the list. <br/>
<br/>
<div class="fragment"><pre class="fragment">       <span class="keywordtype">int</span> count = fileList.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>();
       my_FastSearchJobInfo *jobInfoArray = <span class="keyword">new</span> my_FastSearchJobInfo[count];

       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i) {
           my_FastSearchJobInfo &amp;job = jobInfoArray[i];
           job.d_word    = &amp;word;
           job.d_path    = &amp;fileList[i];
           job.d_mutex   = &amp;mutex;
           job.d_outList = &amp;outFileList;
           pool.enqueueJob(myFastSearchJob, &amp;job);
       }
</pre></div><br/>
<br/>
 Now we simply wait for all the jobs in the queue to complete. Any matched files should have been added to the output file list. <br/>
<br/>
<div class="fragment"><pre class="fragment">       pool.drain();
       <span class="keyword">delete</span>[] jobInfoArray;
   }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_functor_interface"></a> <a class="anchor" id="usage.the_functor_interface"></a> <a class="anchor" id="description.usage.the_functor_interface"></a> <a class="anchor" id="3.3.3"></a> </dd></dl>
<dl class="user"><dt><b>The Functor Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "void function/void pointer" convention is idiomatic for C programs. The <code>void</code> pointer argument provides a generic way of passing in user data, without regard to the data type. Clients who prefer better or more explicit type safety may wish to use the Functor Interface instead. This interface uses the <code>bsl::function</code> component to provide type-safe wrappers that can match argument number and type for a C++ free function or member function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To illustrate the Functor Interface, we will make two small changes to the usage example above. First, we change the signature of the function that executes a single job, so that it uses a <code>my_FastSearchJobInfo</code> pointer rather than a <code>void</code> pointer. With this change, we can remove the first executable statement, which casts the <code>void *</code> pointer to <code>my_FastSearchJobInfo *</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> my_FastFunctorSearchJob(my_FastSearchJobInfo *job)
  {
      FILE *file;

      file = fopen(job-&gt;d_path-&gt;c_str(), <span class="stringliteral">&quot;r&quot;</span>);

      <span class="comment">// The rest of the function is unchanged.</span>
      <span class="keywordflow">if</span> (file) {
          <span class="keywordtype">char</span>  buffer[1024];
          <span class="keywordtype">size_t</span> nread;
          <span class="keywordtype">int</span> wordLen = job-&gt;d_word-&gt;length();
          <span class="keyword">const</span> <span class="keywordtype">char</span> *word = job-&gt;d_word-&gt;c_str();

          nread = fread(buffer, 1, <span class="keyword">sizeof</span>(buffer) - 1, file);
          <span class="keywordflow">while</span>(nread &gt;= wordLen) {
              buffer[nread] = 0;
              <span class="keywordflow">if</span> (strstr(buffer, word)) {
                  <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> lock(job-&gt;d_mutex);
                  job-&gt;d_outList-&gt;push_back(*job-&gt;d_path);
                  <span class="keywordflow">break</span>;  <span class="comment">// bslmt::LockGuard destructor unlocks mutex.</span>
              }
          }
          bsl::memcpy(buffer, &amp;buffer[nread - wordLen - 1], wordLen - 1);
          nread = fread(buffer + wordLen - 1, 1, <span class="keyword">sizeof</span>(buffer) - wordLen,
                        file);
      }
      fclose(file);
  }
</pre></div><br/>
<br/>
 Next, we make a change to the loop that enqueues the jobs in <code>myFastSearch</code>. The function starts exactly as in the previous example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> myFastFunctorSearch(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp;         word,
                                  <span class="keyword">const</span> vector&lt;string&gt;&amp; fileList,
                                  vector&lt;string&gt;&amp;       outFileList)
  {
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>            mutex;
      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> defaultAttributes;
      <a class="code" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a>       pool(defaultAttributes,
                                   MIN_SEARCH_THREADS,
                                   MAX_SEARCH_THREADS,
                                   MAX_SEARCH_THREAD_IDLE);

      <span class="keywordflow">if</span> (0 != pool.start()) {
          bsl::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to start minimum number of threads.  &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;Thread quota exceeded?\n&quot;</span>;
          assert(<span class="keyword">false</span>);
          <span class="keywordflow">return</span>; <span class="comment">// things are SNAFU</span>
      }

      <span class="keywordtype">int</span> count = fileList.size();
      my_FastSearchJobInfo  *jobInfoArray = <span class="keyword">new</span> my_FastSearchJobInfo[count];
</pre></div><br/>
<br/>
 We create a functor - a C++ object that acts as a function. The thread pool will "execute" this functor (by calling its <code>operator()</code> member function) on a thread when one becomes available. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i) {
          my_FastSearchJobInfo &amp;job = jobInfoArray[i];
          job.d_word    = &amp;word;
          job.d_path    = &amp;fileList[i];
          job.d_mutex   = &amp;mutex;
          job.d_outList = &amp;outFileList;

          bsl::function&lt;void()&gt; jobHandle =
                        <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_FastFunctorSearchJob, &amp;job);
          pool.enqueueJob(jobHandle);
      }
</pre></div><br/>
<br/>
 Note that the functor is created locally and handed to the thread pool. The thread pool copies the functor onto its internal queue, and takes responsibility for the copied functor until execution is complete. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The function is completed exactly as it was in the previous example. <br/>
<br/>
<div class="fragment"><pre class="fragment">      pool.drain();
      <span class="keyword">delete</span>[] jobInfoArray;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
