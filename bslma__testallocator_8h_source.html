<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslma_testallocator.h                                              -*-C++-*-
#ifndef INCLUDED_BSLMA_TESTALLOCATOR
#define INCLUDED_BSLMA_TESTALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide instrumented malloc/free allocator to track memory usage.
//
//@CLASSES:
//  bslma::TestAllocator: instrumented &#39;malloc&#39;/&#39;free&#39; memory allocator
//
//@MACROS:
//  BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN: macro to begin testing exceptions
//  BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END: macro to end testing exceptions
//
//@SEE_ALSO: bslma_newdeleteallocator, bslma_mallocfreeallocator
//
//@DESCRIPTION: This component provides an instrumented allocator,
// &#39;bslma::TestAllocator&#39;, that implements the &#39;bslma::Allocator&#39; protocol and
// can be used to track various aspects of memory allocated from it.  Available
// statistics include the number of outstanding blocks (and bytes) that are
// currently in use, the cumulative number of blocks (and bytes) that have been
// allocated, and the maximum number of blocks (and bytes) that have been in
// use at any one time.  A &#39;print&#39; function formats these values to &#39;stdout&#39;:
//..
//   ,--------------------.
//  ( bslma::TestAllocator )
//   `--------------------&#39;
//             |         ctor/dtor
//             |         lastAllocatedAddress/lastDeallocatedAddress
//             |         lastAllocatedNumBytes/lastDeallocatedNumBytes
//             |         numAllocations/numDeallocations
//             |         numBlocksInUse/numBlocksMax/numBlocksTotal
//             |         numBytesInUse/numBytesMax/numBytesTotal
//             |         numMismatches/numBoundsErrors
//             |         print/name
//             |         setAllocationLimit/allocationLimit
//             |         setNoAbort/isNoAbort
//             |         setQuiet/isQuiet
//             |         setVerbose/isVerbose
//             |         status
//             V
//     ,----------------.
//    ( bslma::Allocator )
//     `----------------&#39;
//                       allocate
//                       deallocate
//..
// If exceptions are enabled, this allocator can be configured to throw an
// exception after the number of allocation requests exceeds some specified
// limit (see the subsection on &quot;Allocation Limit&quot; below).  The level of
// verbosity can also be adjusted.  Each allocator object also maintains a
// current status.
//
// By default this allocator gets its memory from the C Standard Library
// functions &#39;malloc&#39; and &#39;free&#39;, but can be overridden to take memory from any
// thread-safe allocator (supplied at construction) that implements the
// &#39;bslma::Allocator&#39; protocol.  Note that allocation and deallocation using a
// &#39;bslma::TestAllocator&#39; object is explicitly incompatible with &#39;malloc&#39; and
// &#39;free&#39; (or any other allocation mechanism).  Attempting to use &#39;free&#39; to
// deallocate memory allocated from a &#39;bslma::TestAllocator&#39; -- even when
// &#39;malloc&#39; and &#39;free&#39; are used by default -- will result in undefined
// behavior, almost certainly corrupting the C Standard Library&#39;s runtime
// memory manager.
//
// Memory dispensed from a &#39;bslma::TestAllocator&#39; is marked such that
// attempting to deallocate previously unallocated (or already deallocated)
// memory will (with high probability) be flagged as an error (unless quiet
// mode is set for the purpose of testing the test allocator itself).  A
// &#39;bslma::TestAllocator&#39; also supports a buffer overrun / underrun feature --
// each allocation has &quot;pads&quot;, areas of extra memory before and after the
// segment which are initialized to a particular value and checked upon
// deallocation to see if they have been modified.  If they have, a message is
// printed and the allocator aborts, unless it is in quiet mode.
//
///Modes
///-----
// The test allocator&#39;s behavior is controlled by three basic *mode* flags:
//
// VERBOSE MODE: (Default 0) Specifies that each allocation and deallocation
// should be printed to standard output.  In verbose mode all state variables
// will be displayed at destruction.
//
// QUIET MODE: (Default 0) Specifies that mismatched memory and memory leaks
// should *not* be reported, and should not cause the process to terminate when
// detected.  Note that this mode is used primarily for testing the test
// allocator itself; behavior that would otherwise abort now quietly increments
// the &#39;numMismatches&#39; and &#39;numBoundsErrors&#39; counter.
//
// NO-ABORT MODE: (Default 0) Specifies that the test allocator should not
// invoke &#39;abort&#39; under any circumstances without suppressing diagnostics.
// Although the internal state values are independent, quiet mode implies the
// behavior of no-abort mode in all cases.  Note that this mode is used
// primarily for visual inspection of unusual error diagnostics in this
// component&#39;s test driver (in non-quiet mode only).
//
// Taking the default mode settings, memory allocation/deallocation will not be
// displayed individually.  However, in the event of a mismatched deallocation
// or a memory leak, the problem will be announced, any relevant state of the
// object will be displayed, and the program will abort.
//
// The three modes are independently set using the &#39;setVerbose&#39;, &#39;setQuiet&#39;,
// and &#39;setNoAbort&#39; manipulators.
//
///Allocation Limit
///----------------
// If exceptions are enabled at compile time, the test allocator can be
// configured to throw a &#39;bslma::TestAllocatorException&#39; after a specified
// number of allocation requests is exceeded.  If the allocation limit is less
// than 0 (default), then the allocator won&#39;t throw a &#39;TestAllocatorException&#39;
// exception.  Note that a non-negative allocation limit is decremented after
// each allocation attempt, and an exception is thrown only when the current
// allocation limit transitions from 0 to -1; no additional exceptions will be
// thrown until the allocation limit is again reset to a non-negative value.
//
// The allocation limit is set using the &#39;setAllocationLimit&#39; manipulator.
//
///Exception Test Macros
///---------------------
// This component also provides a pair of macros:
//..
//: o BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN(BSLMA_TESTALLOCATOR)
//: o BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END
//..
// These macros can be used for testing exception-safety of classes and their
// methods when memory allocation is needed.  A reference to an object of type
// &#39;bslma::TestAllocator&#39; must be supplied as an argument to the &#39;_BEGIN&#39;
// macro.  Note that if exception-handling is disabled (i.e., if
// &#39;BDE_BUILD_TARGET_EXC&#39; is not defined when building the code under test),
// then the macros simply print the following:
//..
//  BSLMA EXCEPTION TEST -- (NOT ENABLED) --
//..
// When exception-handling is enabled, the &#39;_BEGIN&#39; macro will set the
// allocation limit of the supplied allocator to 0, &#39;try&#39; the code being
// tested, &#39;catch&#39; any &#39;TestAllocatorException&#39;s that are thrown, and keep
// increasing the allocation limit until the code being tested completes
// successfully.
//
///Thread Safety
///-------------
// The &#39;bslma::TestAllocator&#39; class is fully thread-safe (see
// &#39;bsldoc_glossary&#39;) provided that the allocator supplied at construction (if
// any) is fully thread-safe.  Note that the &#39;bslma::MallocFreeAllocator&#39;
// singleton (the allocator used by the test allocator if none is supplied at
// construction) is fully thread-safe.
//
///Usage
///-----
// The &#39;bslma::TestAllocator&#39; defined in this component can be used in
// conjunction with the &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN&#39; and
// &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END&#39; macros to test the memory usage
// patterns of an object that uses the &#39;bslma::Allocator&#39; protocol in its
// interface.  In this example, we illustrate how we might test that an object
// under test is exception-neutral.  For illustration purposes, we will assume
// the existence of a &#39;my_shortarray&#39; component implementing an
// &#39;std::vector&#39;-like array type, &#39;myShortArray&#39;:
//..
//  // my_shortarray.t.cpp
//  #include &lt;my_shortarray.h&gt;
//
//  #include &lt;bslma_testallocator.h&gt;
//  #include &lt;bslma_testallocatorexception.h&gt;
//
//  // ...
//
//..
// Below we provide a &#39;static&#39; function, &#39;areEqual&#39;, that will allow us to
// compare two short arrays:
//..
//  static
//  bool areEqual(const short *array1, const short *array2, int numElements)
//      // Return &#39;true&#39; if the specified initial &#39;numElements&#39; in the
//      // specified &#39;array1&#39; and &#39;array2&#39; have the same values, and &#39;false&#39;
//      // otherwise.
//  {
//      for (int i = 0; i &lt; numElements; ++i) {
//          if (array1[i] != array2[i]) {
//              return false;                                         // RETURN
//          }
//      }
//      return true;
//  }
//
//  // ...
//
//..
// The following is an abbreviated standard test driver.  Note that the number
// of arguments specify the verbosity level that the test driver uses for
// printing messages:
//..
//  int main(int argc, char *argv[])
//  {
//      int                 test = argc &gt; 1 ? atoi(argv[1]) : 0;
//      bool             verbose = argc &gt; 2;
//      bool         veryVerbose = argc &gt; 3;
//      bool     veryVeryVerbose = argc &gt; 4;
//      bool veryVeryVeryVerbose = argc &gt; 5;
//
//..
// We now define a &#39;bslma::TestAllocator&#39;, &#39;sa&#39;, named &quot;supplied&quot; to indicate
// that it is the allocator to be supplied to our object under test, as well as
// to the &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN&#39; macro (below).  Note that
// if &#39;veryVeryVeryVerbose&#39; is &#39;true&#39;, then &#39;sa&#39; prints all allocation and
// deallocation requests to &#39;stdout&#39; and also prints the accumulated statistics
// on destruction:
//..
//  bslma::TestAllocator sa(&quot;supplied&quot;, veryVeryVeryVerbose);
//
//  switch (test) { case 0:
//
//    // ...
//
//    case 6: {
//
//      // ...
//
//      struct {
//          int   d_line;
//          int   d_numElem;
//          short d_exp[NUM_VALUES];
//      } DATA[] = {
//          { L_, 0, { } },
//          { L_, 1, { V0 } },
//          { L_, 5, { V0, V1, V2, V3, V4 } }
//      };
//      const int NUM_DATA = sizeof DATA / sizeof *DATA;
//
//      for (int ti = 0; ti &lt; NUM_DATA; ++ti) {
//          const int    LINE     = DATA[ti].d_line;
//          const int    NUM_ELEM = DATA[ti].d_numElem;
//          const short *EXP      = DATA[ti].d_exp;
//
//          if (veryVerbose) { T_ P_(ti) P_(NUM_ELEM) }
//
//          // ...
//
//..
// All code that we want to test for exception-safety must be enclosed within
// the &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN&#39; and
// &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END&#39; macros, which internally implement
// a &#39;do&#39;-&#39;while&#39; loop.  Code provided by the
// &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN&#39; macro sets the allocation limit
// of the supplied allocator to 0 causing it to throw an exception on the first
// allocation.  This exception is caught by code provided by the
// &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END&#39; macro, which increments the
// allocation limit by 1 and re-runs the same code again.  Using this scheme we
// can check that our code does not leak memory for any memory allocation
// request.  Note that the curly braces surrounding these macros, although
// visually appealing, are not technically required:
//..
//      BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN(sa) {
//        my_ShortArray mA(&amp;sa);
//        const my_ShortArray&amp; A = mA;
//        for (int ei = 0; ei &lt; NUM_ELEM; ++ei) {
//            mA.append(VALUES[ei]);
//        }
//        if (veryVerbose) { T_ T_  P_(NUM_ELEM) P(A) }
//        LOOP_ASSERT(LINE, areEqual(EXP, A, NUM_ELEM));
//      } BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END
//  }
//..
// After the exception-safety test we can ensure that all the memory allocated
// from &#39;sa&#39; was successfully deallocated:
//..
//          if (veryVerbose) sa.print();
//
//        } break;
//
//        // ...
//
//      }
//
//      // ...
//  }
//..
// Note that the &#39;BDE_BUILD_TARGET_EXC&#39; macro is defined at compile-time to
// indicate whether or not exceptions are enabled.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_TESTALLOCATOREXCEPTION
#include &lt;bslma_testallocatorexception.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BSLS_BSLLOCK
#include &lt;bsls_bsllock.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_CSTDIO
#include &lt;cstdio&gt;     // for printing in macros
#define INCLUDED_CSTDIO
#endif

namespace BloombergLP {
namespace bslma {

struct TestAllocator_List;

                             // ===================
                             // class TestAllocator
                             // ===================

class TestAllocator : public Allocator {
    // This class defines a concrete &quot;test&quot; allocator mechanism that implements
    // the &#39;Allocator&#39; protocol, and provides instrumentation to track (1) the
    // number of blocks/bytes currently in use, (2) the maximum number of
    // blocks/bytes that have been outstanding at any one time, and (3) the
    // cumulative number of blocks/bytes that have ever been allocated by this
    // test allocator object.  The accumulated statistics are based solely on
    // the number of bytes requested.  Additional testing facilities include
    // allocation limits, verbosity modes, status, and automated report
    // printing.
    //
    // Note that, unlike many other allocators, this allocator does NOT rely on
    // the currently installed default allocator (see &#39;bslma_default&#39;), but
    // instead -- by default -- uses the &#39;MallocFreeAllocator&#39; singleton, which
    // in turn calls the C Standard Library functions &#39;malloc&#39; and &#39;free&#39; as
    // needed.  Clients may, however, override this allocator by supplying (at
    // construction) any other allocator implementing the &#39;Allocator&#39; protocol
    // provided that it is fully thread-safe.

    // DATA

                        // Control Points

    const char *d_name_p;                // optionally specified name of
                                         // this test allocator object (or 0)

    bsls::AtomicInt
                d_noAbortFlag;           // whether or not to suppress
                                         // aborting on fatal errors

    bsls::AtomicInt
                d_quietFlag;             // whether or not to suppress
                                         // reporting hard errors

    bsls::AtomicInt
                d_verboseFlag;           // whether or not to report
                                         // allocation/deallocation events and
                                         // print statistics on destruction

    bsls::AtomicInt64
                d_allocationLimit;       // number of allocations before
                                         // exception is thrown by this object

                        // Statistics

    bsls::AtomicInt64
                d_numAllocations;        // total number of allocation
                                         // requests on this object (including
                                         // those for 0 bytes)

    bsls::AtomicInt64
                d_numDeallocations;      // total number of deallocation
                                         // requests on this object (including
                                         // those supplying a 0 address)

    bsls::AtomicInt64
                d_numMismatches;         // number of mismatched memory
                                         // deallocation errors encountered by
                                         // this object
    bsls::AtomicInt64
                d_numBoundsErrors;       // number of overrun/underrun errors
                                         // encountered by this object

    bsls::AtomicInt64
                d_numBlocksInUse;        // number of blocks currently
                                         // allocated from this object

    bsls::AtomicInt64
                d_numBytesInUse;         // number of bytes currently
                                         // allocated from this object

    bsls::AtomicInt64
                d_numBlocksMax;          // maximum number of blocks ever
                                         // allocated from this object at any
                                         // one time

    bsls::AtomicInt64
                d_numBytesMax;           // maximum number of bytes ever
                                         // allocated from this object at any
                                         // one time

    bsls::AtomicInt64
                d_numBlocksTotal;        // cumulative number of blocks ever
                                         // allocated from this object

    bsls::AtomicInt64
                d_numBytesTotal;         // cumulative number of bytes ever
                                         // allocated from this object

                        // Other Data

    bsls::AtomicInt64
                d_lastAllocatedNumBytes; // size (in bytes) of the most recent
                                         // allocation request

    bsls::AtomicInt64
                d_lastDeallocatedNumBytes;
                                         // size (in bytes) of the most
                                         // recently deallocated memory

    bsls::AtomicPointer&lt;int&gt;
                d_lastAllocatedAddress_p;// address of the most recently
                                         // allocated memory (or 0)

    bsls::AtomicPointer&lt;int&gt;
                d_lastDeallocatedAddress_p;
                                         // address of the most recently
                                         // deallocated memory (or 0)

    TestAllocator_List
               *d_list_p;                // list of allocated memory (owned)

    mutable bsls::BslLock
                d_lock;                  // ensure mutual exclusion in
                                         // &#39;allocate&#39;, &#39;deallocate&#39;, &#39;print&#39;,
                                         // and &#39;status&#39;

    Allocator  *d_allocator_p;           // memory allocator (held, not owned)

  private:
    // NOT IMPLEMENTED
    TestAllocator(const TestAllocator&amp;);             // = delete
    TestAllocator&amp; operator=(const TestAllocator&amp;);  // = delete

  public:
    // CREATORS
    explicit
    TestAllocator(Allocator  *basicAllocator = 0);
    explicit
    TestAllocator(const char *name,
                  Allocator  *basicAllocator = 0);
    explicit
    TestAllocator(bool        verboseFlag,
                  Allocator  *basicAllocator = 0);
    TestAllocator(const char *name,
                  bool        verboseFlag,
                  Allocator  *basicAllocator = 0);
        // Create an instrumented &quot;test&quot; allocator.  Optionally specify a
        // &#39;name&#39; (associated with this object) to be included in diagnostic
        // messages written to &#39;stdout&#39;, thereby distinguishing this test
        // allocator from others that might be used in the same program.  If
        // &#39;name&#39; is 0 (or not specified), no distinguishing name is
        // incorporated in diagnostics.  Optionally specify a &#39;verboseFlag&#39;
        // indicating whether this test allocator should automatically report
        // all allocation/deallocation events to &#39;stdout&#39; and print accumulated
        // statistics on destruction.  If &#39;verboseFlag&#39; is &#39;false&#39; (or not
        // specified), allocation/deallocation and summary messages will not be
        // written automatically.  Optionally specify a &#39;basicAllocator&#39; used
        // to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // &#39;MallocFreeAllocator&#39; singleton is used.

    ~TestAllocator();
        // Destroy this allocator.  In verbose mode, print all contained state
        // values of this allocator object to &#39;stdout&#39;.  Except in quiet mode,
        // automatically report any memory leaks to &#39;stdout&#39;.  Abort if either
        // &#39;numBlocksInUse&#39; or &#39;numBytesInUse&#39; return non-zero unless in
        // no-abort mode or quiet mode.  Note that, in all cases, destroying
        // this object has no effect on outstanding memory blocks allocated
        // from this test allocator (and may result in memory leaks -- e.g., if
        // the (default) &#39;MallocFreeAllocator&#39; singleton was used).

    // MANIPULATORS
    void *allocate(size_type size);
        // Return a newly-allocated block of memory of the specified &#39;size&#39; (in
        // bytes).  If &#39;size&#39; is 0, a null pointer is returned.  Otherwise,
        // invoke the &#39;allocate&#39; method of the allocator supplied at
        // construction, increment the number of currently (and cumulatively)
        // allocated blocks, and increase the number of currently allocated
        // bytes by &#39;size&#39;.  Update all other fields accordingly.

    void deallocate(void *address);
        // Return the memory block at the specified &#39;address&#39; back to this
        // allocator.  If &#39;address&#39; is 0, this function has no effect (other
        // than to record relevant statistics).  Otherwise, if the memory at
        // &#39;address&#39; is consistent with being allocated from this test
        // allocator, decrement the number of currently allocated blocks, and
        // decrease the number of currently allocated bytes by the size (in
        // bytes) originally requested for the block.  Although technically
        // undefined behavior, if the memory can be determined not to have been
        // allocated from this test allocator, increment the number of
        // mismatches, and -- unless in quiet mode -- immediately report the
        // details of the mismatch to &#39;stdout&#39; (e.g., as an &#39;std::hex&#39; memory
        // dump) and abort.

    void setAllocationLimit(bsls::Types::Int64 limit);
        // Set the number of valid allocation requests before an exception is
        // to be thrown for this allocator to the specified &#39;limit&#39;.  If
        // &#39;limit&#39; is less than 0, no exception is to be thrown.  By default,
        // no exception is scheduled.

    void setNoAbort(bool flagValue);
        // Set the no-abort mode for this test allocator to the specified
        // (boolean) &#39;flagValue&#39;.  &#39;If flagValue&#39; is &#39;true&#39;, aborting on fatal
        // errors is suppressed, and the functions simply return.  Diagnostics
        // are not affected.  Note that the default mode is to abort.  Also
        // note that this function is provided primarily to enable visual
        // testing of diagnostic messages produced by this component.

    void setQuiet(bool flagValue);
        // Set the quiet mode for this test allocator to the specified
        // (boolean) &#39;flagValue&#39;.  If &#39;flagValue&#39; is &#39;true&#39;, mismatched
        // allocations, overrun/underrun errors, and memory leak messages will
        // not be displayed to &#39;stdout&#39; and the process will not abort as a
        // result of such conditions.  Note that the default mode is *not*
        // quiet.  Also note that this function is provided primarily to enable
        // testing of this component; in quiet mode, situations that would
        // otherwise abort will just quietly increment the &#39;numMismatches&#39;
        // and/or &#39;numBoundsErrors&#39; counters.

    void setVerbose(bool flagValue);
        // Set the verbose mode for this test allocator to the specified
        // (boolean) &#39;flagValue&#39;.  If &#39;flagValue&#39; is &#39;true&#39;, all
        // allocation/deallocation events will be reported automatically on
        // &#39;stdout&#39;, as will accumulated statistics upon destruction of this
        // object.  Note that the default mode is *not* verbose.

    // ACCESSORS
    bsls::Types::Int64 allocationLimit() const;
        // Return the current number of allocation requests left before an
        // exception is thrown.  A negative value indicates that no exception
        // is scheduled.

    bool isNoAbort() const;
        // Return &#39;true&#39; if this allocator is currently in no-abort mode, and
        // &#39;false&#39; otherwise.  In no-abort mode all diagnostic messages are
        // printed, but all aborts are suppressed.  Note that quiet mode
        // implies no-abort mode.

    bool isQuiet() const;
        // Return &#39;true&#39; if this allocator is currently in quiet mode, and
        // &#39;false&#39; otherwise.  In quiet mode, messages about mismatched
        // deallocations, overrun/underrun errors, and memory leaks will not be
        // displayed to &#39;stdout&#39; and will not cause the program to abort.

    bool isVerbose() const;
        // Return &#39;true&#39; if this allocator is currently in verbose mode, and
        // &#39;false&#39; otherwise.  In verbose mode, all allocation/deallocation
        // events will be reported on &#39;stdout&#39;, as will summary statistics upon
        // destruction of this object.

    void *lastAllocatedAddress() const;
        // Return the address that was returned by the most recent allocation
        // request.  Return 0 if the most recent allocation request was for 0
        // bytes.

    size_type lastAllocatedNumBytes() const;
        // Return the number of bytes of the most recent allocation request.

    void *lastDeallocatedAddress() const;
        // Return the address that was supplied to the most recent deallocation
        // request.  Return 0 if a null pointer was most recently deallocated.
        // Note that the address is always recorded regardless of the validity
        // of the request.

    size_type lastDeallocatedNumBytes() const;
        // Return the number of bytes of the most recent deallocation request.
        // Return 0 if a null pointer was most recently deallocated, or if the
        // request was invalid (e.g., an attempt to deallocate memory not
        // allocated through this allocator).

    const char *name() const;
        // Return the name of this test allocator, or 0 if no name was
        // specified at construction.

    bsls::Types::Int64 numAllocations() const;
        // Return the cumulative number of allocation requests.  Note that this
        // number is incremented for every &#39;allocate&#39; invocation.

    bsls::Types::Int64 numBlocksInUse() const;
        // Return the number of blocks currently allocated from this object.
        // Note that &#39;numBlocksInUse() &lt;= numBlocksMax()&#39;.

    bsls::Types::Int64 numBlocksMax() const;
        // Return the maximum number of blocks ever allocated from this object
        // at any one time.  Note that
        // &#39;numBlocksInUse() &lt;= numBlocksMax() &lt;= numBlocksTotal()&#39;.

    bsls::Types::Int64 numBlocksTotal() const;
        // Return the cumulative number of blocks ever allocated from this
        // object.  Note that &#39;numBlocksMax() &lt;= numBlocksTotal()&#39;.

    bsls::Types::Int64 numBoundsErrors() const;
        // Return the number of times memory deallocations have detected that
        // pad areas at the front or back of the user segment had been
        // overwritten.

    bsls::Types::Int64 numBytesInUse() const;
        // Return the number of bytes currently allocated from this object.
        // Note that &#39;numBytesInUse() &lt;= numBytesMax()&#39;.

    bsls::Types::Int64 numBytesMax() const;
        // Return the maximum number of bytes ever allocated from this object
        // at any one time.  Note that
        // &#39;numBytesInUse() &lt;= numBytesMax() &lt;= numBytesTotal()&#39;.

    bsls::Types::Int64 numBytesTotal() const;
        // Return the cumulative number of bytes ever allocated from this
        // object.  Note that &#39;numBytesMax() &lt;= numBytesTotal()&#39;.

    bsls::Types::Int64 numDeallocations() const;
        // Return the cumulative number of deallocation requests.  Note that
        // this number is incremented for every &#39;deallocate&#39; invocation,
        // regardless of the validity of the request.

    bsls::Types::Int64 numMismatches() const;
        // Return the number of mismatched memory deallocations that have
        // occurred since this object was created.  A memory deallocation is
        // *mismatched* if that memory was not allocated directly from this
        // allocator.

    void print() const;
        // Write the accumulated state information held in this allocator to
        // &#39;stdout&#39; in some reasonable (multi-line) format.

    int status() const;
        // Return 0 on success, and non-zero otherwise: If there have been any
        // mismatched memory deallocations or over/under runs, return the
        // number of such errors that have occurred as a positive number; if
        // either &#39;0 &lt; numBlocksInUse()&#39; or &#39;0 &lt; numBytesInUse()&#39;, return an
        // arbitrary negative number; else return 0.
};

}  // close package namespace

               // ==============================================
               // macro BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN
               // ==============================================

// The following is a workaround for an intermittent Visual Studio 2005
// exception-handling failure.

#if defined(BSLS_PLATFORM_CMP_MSVC) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &lt; 1500
#define BSLMA_EXCEPTION_TEST_WORKAROUND try {} catch (...) {}
#else
#define BSLMA_EXCEPTION_TEST_WORKAROUND
#endif

#ifdef BDE_BUILD_TARGET_EXC

namespace bslma {

class TestAllocator_ProxyBase {
    // This class provides a common base class for the parameterized
    // &#39;TestAllocator_Proxy&#39; class (below).  Note that the &#39;virtual&#39;
    // &#39;setAllocationLimit&#39; method, although a &quot;setter&quot;, *must* be declared
    // &#39;const&#39;.

  public:
    virtual ~TestAllocator_ProxyBase()
    {
    }

    // ACCESSORS
    virtual void setAllocationLimit(bsls::Types::Int64 limit) const = 0;
};

template &lt;class BSLMA_ALLOC_TYPE&gt;
class TestAllocator_Proxy: public TestAllocator_ProxyBase {
    // This class provides a proxy to the test allocator that is supplied to
    // the &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN&#39; macro.  This proxy may be
    // instantiated with &#39;TestAllocator&#39;, or with a type that supports the same
    // interface as &#39;TestAllocator&#39;.

    // DATA
    BSLMA_ALLOC_TYPE *d_allocator_p;  // allocator used in &#39;*_BEGIN&#39; and
                                      // &#39;*_END&#39; macros (held, not owned)

  public:
    // CREATORS
    TestAllocator_Proxy(BSLMA_ALLOC_TYPE *allocator)
    : d_allocator_p(allocator)
    {
    }

    ~TestAllocator_Proxy()
    {
    }

    // ACCESSORS
    virtual void setAllocationLimit(bsls::Types::Int64 limit) const
    {
        d_allocator_p-&gt;setAllocationLimit(limit);
    }
};

template &lt;class BSLMA_ALLOC_TYPE&gt;
inline
TestAllocator_Proxy&lt;BSLMA_ALLOC_TYPE&gt;
TestAllocator_getProxy(BSLMA_ALLOC_TYPE *allocator)
    // Return, by value, a test allocator proxy for the specified parameterized
    // &#39;allocator&#39;.
{
    return TestAllocator_Proxy&lt;BSLMA_ALLOC_TYPE&gt;(allocator);
}

}  // close package namespace

#ifndef BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN
#define BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN(BSLMA_TESTALLOCATOR) {     \
    BSLMA_EXCEPTION_TEST_WORKAROUND                                         \
    {                                                                       \
        static int firstTime = 1;                                           \
        if (veryVerbose &amp;&amp; firstTime) {                                     \
            std::puts(&quot;\t\tBSLMA EXCEPTION TEST -- (ENABLED) --&quot;);          \
        }                                                                   \
        firstTime = 0;                                                      \
    }                                                                       \
    if (veryVeryVerbose) {                                                  \
        std::puts(&quot;\t\tBegin bslma exception test.&quot;);                       \
    }                                                                       \
    int bslmaExceptionCounter = 0;                                          \
    const bslma::TestAllocator_ProxyBase&amp; bslmaExceptionTestAllocator =     \
                       bslma::TestAllocator_getProxy(&amp;BSLMA_TESTALLOCATOR); \
    bslmaExceptionTestAllocator.setAllocationLimit(bslmaExceptionCounter);  \
    do {                                                                    \
        try {
#endif  // BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN

#else   // !defined(BDE_BUILD_TARGET_EXC)

#ifndef BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN
#define BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN(BSLMA_TESTALLOCATOR)       \
{                                                                           \
    static int firstTime = 1;                                               \
    if (verbose &amp;&amp; firstTime) {                                             \
        std::puts(&quot;\t\tBSLMA EXCEPTION TEST -- (NOT ENABLED) --&quot;);          \
        firstTime = 0;                                                      \
    }                                                                       \
}
#endif  // BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN

#endif  // BDE_BUILD_TARGET_EXC

                 // ============================================
                 // macro BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END
                 // ============================================

#ifdef BDE_BUILD_TARGET_EXC

#ifndef BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END
#define BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END                              \
        } catch (bslma::TestAllocatorException&amp; e) {                        \
            if (veryVeryVerbose) {                                          \
                std::printf(&quot;\t*** BSLMA_EXCEPTION: &quot;                       \
                            &quot;alloc limit = %d, last alloc size = %d ***\n&quot;, \
                            bslmaExceptionCounter,                          \
                            static_cast&lt;int&gt;(e.numBytes()));                \
            }                                                               \
            bslmaExceptionTestAllocator.setAllocationLimit(                 \
                                                 ++bslmaExceptionCounter);  \
            continue;                                                       \
        }                                                                   \
        bslmaExceptionTestAllocator.setAllocationLimit(-1);                 \
        break;                                                              \
    } while (1);                                                            \
    if (veryVeryVerbose) {                                                  \
        std::puts(&quot;\t\tEnd bslma exception test.&quot;);                         \
    }                                                                       \
    BSLMA_EXCEPTION_TEST_WORKAROUND                                         \
}

#endif  // BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END

#else   // !defined(BDE_BUILD_TARGET_EXC)

#ifndef BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END
#define BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END
#endif

#endif

namespace bslma {

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // -------------------
                        // class TestAllocator
                        // -------------------

// MANIPULATORS
inline
void TestAllocator::setAllocationLimit(bsls::Types::Int64 limit)
{
    d_allocationLimit.storeRelaxed(limit);
}

inline
void TestAllocator::setNoAbort(bool flagValue)
{
    d_noAbortFlag.storeRelaxed(flagValue);
}

inline
void TestAllocator::setQuiet(bool flagValue)
{
    d_quietFlag.storeRelaxed(flagValue);
}

inline
void TestAllocator::setVerbose(bool flagValue)
{
    d_verboseFlag.storeRelaxed(flagValue);
}

// ACCESSORS
inline
bsls::Types::Int64 TestAllocator::allocationLimit() const
{
    return d_allocationLimit.loadRelaxed();
}

inline
bool TestAllocator::isNoAbort() const
{
    return d_noAbortFlag.loadRelaxed();
}

inline
bool TestAllocator::isQuiet() const
{
    return d_quietFlag.loadRelaxed();
}

inline
bool TestAllocator::isVerbose() const
{
    return d_verboseFlag.loadRelaxed();
}

inline
void *TestAllocator::lastAllocatedAddress() const
{
    return reinterpret_cast&lt;void *&gt;(d_lastAllocatedAddress_p.loadRelaxed());
}

inline
Allocator::size_type TestAllocator::lastAllocatedNumBytes() const
{
    return static_cast&lt;size_type&gt;(d_lastAllocatedNumBytes.loadRelaxed());
}

inline
void *TestAllocator::lastDeallocatedAddress() const
{
    return reinterpret_cast&lt;void *&gt;(d_lastDeallocatedAddress_p.loadRelaxed());
}

inline
Allocator::size_type TestAllocator::lastDeallocatedNumBytes() const
{
    return static_cast&lt;size_type&gt;(d_lastDeallocatedNumBytes.loadRelaxed());
}

inline
const char *TestAllocator::name() const
{
    return d_name_p;
}

inline
bsls::Types::Int64 TestAllocator::numAllocations() const
{
    return d_numAllocations.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numBoundsErrors() const
{
    return d_numBoundsErrors.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numBlocksInUse() const
{
    return d_numBlocksInUse.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numBlocksMax() const
{
    return d_numBlocksMax.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numBlocksTotal() const
{
    return d_numBlocksTotal.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numBytesInUse() const
{
    return d_numBytesInUse.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numBytesMax() const
{
    return d_numBytesMax.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numBytesTotal() const
{
    return d_numBytesTotal.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numDeallocations() const
{
    return d_numDeallocations.loadRelaxed();
}

inline
bsls::Types::Int64 TestAllocator::numMismatches() const
{
    return d_numMismatches.loadRelaxed();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
